[{"title":"笔记 | Python 3 入门系列教程","url":"/2018/09/life-is-short-we-need-python.html","content":"\n## 序言\n本文章主要以黑马程序员的「 [Python 从入门到精通教程](https://www.bilibili.com/video/av14184325) 」的视频为主线，综合「 [廖雪峰的 Python 教程](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000) 」输出学习笔记，目的是检验自己的学习效果和日常复习之需。\n\n当然，本文章也可作为入门 Python 的参考资料，除了视频的基础内容外，文章会补充视频中讲解不详细或遗漏的必要知识点。文章的内容与视频内容，大体保持一致，即分模块讲解：`Linux 基础`、`Python 基础`、`Python 面向对象`、`项目实战` ( 实战部分与原教学视频有出入，即本文章以爬虫、数据分析为主的项目实战 )。\n\n人生苦短，我用 Python，期待您早日加入 Python 队伍中来。\n\n<!-- More -->\n\n## 更新进度\n2018.09.03：完成初稿，且完成 Linux 基础部分的内容；\n\n## 教学资源\n- 文章 | [廖雪峰. Python 3.6 教程. liaoxuefeng.com](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)\n- 视频 | [黑马程序员. Python 从入门到精通教程. 2017. bilibili.com](https://www.bilibili.com/video/av14184325)\n- 视频 | [老男孩教育. Python 3.5 全栈开发. 2017. bilibili.com](https://www.bilibili.com/video/av17118368)\n\n\t> 本框架的学习笔记是基于此系列教学视频所得的。\n\n## Linux 基础\n\n### Linux 常用终端命令\n> 仅列举一些项目中常用的命令。\n\n- LS 命令与通配符\n\t- `*`：代表任意个数个字符。\n\t- `?`：代表任意一个字符。\n\t- `[]`：表示可匹配字符组中任意一个。\n\t- `[abc]`：匹配 a、b、c 中的任意一个字符。\n\t- `[a-f]`：匹配从 a 到 f 范围内的任意一个字符。\n\n\t> 常使用 `ls -al` 显示当前文件目录所有文件的详细信息。\n\n- CD 命令与切换目录\n\t- 相对路径：最前面不是 `/` 或 `~`，表示相对 `当前目录` 所在的目录位置。\n\t- 绝对路径：最前面是 `/` 或 `~`，表示从 `根目录 / Home 目录` 开始的具体目录位置。\n\n\t\t```bash\n\t\t# 相对路径：返回上两级目录\n\t\tcd ../../ \n\t\t\n\t\t# 绝对路径：相当于 cd /Users/your username/\n\t\tcd ~\n\t\t```\n\t\t\n- Tree 命令：以树状结构显示文件目录结构，若 `tree -d` 则显示目录，不显示文件。\n\n- 查看文件内容\n\t- `cat 文件名`：查看文件内容、创建文件、文件合并、追加文件内容等功能。\n\t- `more 文件名`：分屏显示文件内容。\n\t- `grep 搜索文本的文件名`：搜索文件文件内容。\n\t\t- 例如搜索包含单词 “hello” 的文本，即 `grep \"hello\" sample.txt`。\n\t\t- 选项参数：`-n` 显示匹配行号；`-v` 显示不包含匹配文本的所有行；`-i` 忽略大小写。\n\n- Echo 命令与重定向\n\t- `echo` 命令：在终端中显示参数指定的文字。\n\t- 重定向 `>` 和 `>>`：\n\t\t- `>` 表示输出，会覆盖文件原有内容。\n\t\t- `>>` 表示追加，会将内容追加到已有文件的末尾。\n\t- `echo` 命令常结合 `重定向` 使用：\n\n\t\t```bash\n\t\t# 将字符串 \"Hello World\" 追加到\n\t\techo \"Hello World\" >> sample.txt\n\t\t```\n\t\t\n- 管道符 `|`\n\t- Linux 允许将一个命令的输出通过管道作为另一个命令的输入。\n\t- ls 命令与 grep 命令的结合使用，如从 Home 目录下搜索包含 \"python\" 关键字的文件或者文件夹：\n\n\t\t```bash\n\t\t# 从 Home 目录下搜索包含 \"python\" 关键字的文件或者文件夹\n\t\tls -al ~ | grep python\n\t\t```\n\t\n- Ifconfig 命令与 Ping 命令\n\t- `ifconfig` 命令可查看/配置计算机当前的网卡配置。\n\t- `ping` 命令一般用于检测当前计算机到目标计算机之间的网络是否畅通。\n\n\t\t```bash\n\t\t# 快速查看网卡对应的 IP 地址\n\t\tifconfig | grep inet\n\t\t```\n\n### 远程登录和复制文件\n\n#### 远程登录\n- 远程登录即通过 `SSH 客户端` 链接运行了 `SSH 服务器` 的远程机器上。\n- SSH 是目前较可靠，专为 `远程登录会话` 和 `其他网络服务` 提供安全性协议。\n\t- 有效防止远程管理过程中的信息泄露。\n\t- 对所有传输的数据进行加密，也能防止 DNS 欺骗和 IP 欺骗。\n- SSH 客户端是一种使用 `Secure Shell` 协议连接到远程计算机的软件程序。\n- SSH 客户端简单使用访问服务器：`ssh [-p port] user@remote`\n\t- `user` 是远程机器上的用户名。\n\t- `remote` 是远程机器地址，可为 IP、域名或别名。\n\t- `port` 是 SSH 服务器监听的端口，若不指定端口默认为 22。\n\n#### 复制文件\n- SCP 即 `Secure Copy`，是一个在 Linux 下用来进行 `远程拷贝文件` 的命令。\n\n\t```bash\n\t# 从本地复制文件到远程机器桌面上\n\tscp -P sample.py user@remote:Desktop/sample.py\n\t\n\t# 从远程机器桌面上复制文件夹到本地上\n\tscp -P port -r user@remote:Desktop/sample ~/Desktop/sample\n\t```\n\n#### SSH 高级用法\n\n##### 免密码登录\n免密码登录：即客户端访问服务端时，需要密码验证身份登录。\n\n- Step.01. 配置公钥：执行 `ssh-keygen` 即生成 SSH 密钥。\n- Step.02. 上次共钥到服务器：执行 `ssh-copy-id -p port user@remote`，让远程服务器记住我们的 `公钥`。\n\t\n\t> 1) 有关 SSH 配置信息都保存在 `/Home/yousr username/.ssh` 目录下。  \n\t> 2) 免密登录使用的是非对称加密算法 ( RSA )，即使用公钥加密的数据，需要使用私钥解密；使用私钥加密的数据，需要使用公钥解密。若有兴趣了解 RSA 算法的原理及计算，可参考引用文章 [1]、[2]。\n\t\t\n\t![图4-1免密码登录实现原理图](/images/illustration/Programme/2018/09/life-is-short-we-need-python_4-1.png)\n\t<center>图 4-1 免密码登录实现原理图</center>\n\t\t\n##### 配置别名\n配置别名：每次输入 `ssh -p port user@remote` 是非常繁琐重复的工作，配置别名的方式以替代上述这么一串命令代码。\n\n- 在 `/.ssh/config` 文件下追加以下内容 ( 需建立 Config 文件 )：\n\n\t```vim\n\tHost mac\n\tHostName 192.168.10.1\n\tUser user\n\tPort 22\n\t```\n\t\n- 命令输入 `ssh mac` 即可实现远程登录操作 ( SCP 同样原理 )。\n\n\t```bash\n\tscp -P 22 -r ~/Desktop/Sample mac:Desktop/Sample\n\t```\n\n### 用户和权限\n\n#### 基本概念\n- 在 Linux 中，可指定每一用户针对不同的文件或者目录的不同权限。\n- 对文件 / 目录包含的权限有：\n\n<center>表 4-1 文件/目录权限属性说明</center>\n\n| 权限 | 英文 | 缩写 | 数字代号 |\n| :---: | :---: | :---: | :---: |\n| 读 | read | r | 4 |\n| 写 | write | w | 2 |\n| 执行 | excute | x | 1 |\n\t\n#### 组\n- 为方便用户管理，提出组的概念。在实际开发中，可预先针对组设置好权限，然后将不同的用户添加到对应组中，从而不用依次为每个用户设置权限。\n\n#### LL 命令\n- LL 命令即 LS 命令的扩展用法 `ls -al`。\n- LL 命令可查看文件夹下文件的详细信息，从左往右依次是：\n\t- 权限：第一个字符是 `d`，表示目录；`-` 表示文件；\n\t- 硬链接数：通俗理解即有多少种方式可访问到当前目录 / 文件；\n\t- 拥有者：当前用户；\n\t- 组：当前用户所属的组；\n\t- 文件大小，修改时间，文件 / 目录名称.\n\n<center>表 4-2 \"ls -al\" 查看文件的权限信息说明</center>\n\n| 目录 | 拥有者权限 | 组权限 | 其他用户权限 | 备注 |\n| :---: | :---: | :---: | :---: | :---: |\n| - | r w - |  r w -  |  r - -  | 文件权限示例 |\n| d |  r w x | r w x | r - x | 目录权限示例 |\n\n#### Chmod 命令\n- Chmod 命令：可修改 `用户/组` 对 `文件/目录` 的权限。\n\n\t```bash\n\t# 一次性修改拥有者/组的权限\n\tchmod +/-rwx 文件名/目录名\n\t```\n\n#### Sudo 命令\n- Sudo 命令：使用预设 ( root, 系统管理员 ) 的身份来执行命令。\n\n\t> Linux 系统中，通常使用标准用户登录及使用系统，通常 `sudo` 命令临时获得权限用于系统的维护与和管理。\n\t\n### 系统信息相关命令\n- 查询时间和日期\n\t- `date`：查看系统时间。\n\t- `cal`：查看当月日历，`cal -y` 查看当年的日历。\n- 磁盘和目录空间\n\t- df：`df -h`，Disk Free 显示磁盘剩余空间。\n\t- du：`du -h`，Disk Usage 显示目录下的文件大小。\n- 进程信息\n\t- ps：`ps aux`，即 Process Status，查看进程的详细状况。\n\t- top：动态显示运行中的进程并排序。\n\t- kill：`kill [-9] 进程代号`，`-9` 表示强行终止，终止指定代号的进程。\n\n\t\t> 使用 `kill` 命令时，最好终止当前用户开启的进程，而不是终止 `root` 身份开启的进程。\n\t\t\n### 其他终端命令\n\n#### 查找文件\n查找文件：`find` 命令功能非常强大，通常在特定目录下搜索符合条件的文件。\n\n- 若省略路径，表示在当前文件夹下查找。\n- `find` 命令可结合 `通配符` 一起使用。\n\n\t```bash\n\tfind [路径] -name \"*.py\"\n\t```\n\t\n#### 软链接\n软链接：建立文件的软链接，通俗理解即 PC/MacOS 上的 `快捷方式`。\n\n- 源文件要使用绝对路径，即便于移动链接文件 (快捷方式) 仍能正常使用。\n- 没有 `-s` 选项是建立一个硬链接文件。\n\n\t```bash\n\tln -s 被链接的源文件 快捷方式的名称\n\t```\n\t\n- 在 Linux 中，文件名和文件的数据是分开储存的。\n\n\t![图4-2软、硬链接访问文件数据](/images/illustration/Programme/2018/09/life-is-short-we-need-python_4-2.png)\n\t<center>图 4-2 软、硬链接访问文件数据</center>\n\n#### 打包压缩\n- `tar` 是 Linux 中最常用的备份工具 ( **打包并不压缩** )，其命令格式如下：\n\n\t```bash\n\t# 选项 c：生成档案文件 (.tar)\n\t# 选项 x：解开档案文件\n\t# 选项 v：列出归档/解档的详细过程，显示进程\n\t# 选项 f：指定档案文件名称，选项 f 后应该紧跟 .tar 文件\n\t\n\t# 打包文件：打包放于同一目录下\n\ttar -cvf 打包文件.tar. 被打包文件路径\n\t\n\t# 解包文件\n\ttar - xvf 打包文件 [-C 目标路径]\n\t```\n\t\n- `tar` 与 `gzip` 命令结合可实现文件 `打包和压缩`，即 `tar` 只负责打包文件， `gzip` 负责压缩文件。\n\n\t```bash\n\t# 压缩文件：压缩文件放于同一目录下\n\ttar - zcvf 打包文件.tar.gz 被压缩文件路径\n\t\n\t# 解压缩文件\n\ttar -zxvf 打包文件.tar.gz\n\t\n\t# 解压缩文件到指定路径\n\ttar -zxvf 打包文件.tar.gz [-C 目标路径]\n\t```\n\n## 参考资料\n\\[1\\] [Eddie Woo. The RSA Encryption Algorithm. 2017. bilibili.com](https://www.bilibili.com/video/av10742893?from=search&seid=163310817147442185)  \n\\[2\\] [John cui. 轻松学习RSA加密算法原理. 2018. jianshu.com](https://www.bilibili.com/video/av10742893/?p=1)\n","tags":["数据分析"],"categories":["Programme"]},{"title":"项目 | SVN 环境搭建与使用","url":"/2018/08/building-a-svn-server.html","content":"\n最近有机会接触到公司的新项目，对于多人参与的项目，充分感受到 `源代码的版本控制` 的重要性。为了深刻理解和复用起见，本文将从 `搭建`、`配置` 和 `使用` 多方面总结 SVN。\n\n当然，版本控制的工具有很多，譬如 CVS、GIT、SVN，CVS 几乎淘汰；GIT 适合开源软件项目；SVN 适合企业内部由项目经理统一协调的多个并行项目的开发。选择哪款版本控制工具视具体情况而定。\n\n<!-- More -->\n\n## 源代码管理\n\n> 介绍参考了资料 [1]。 \n\n### 管理意义\n- 目的：为了解决在软件开发过程中，由源代码引发的各种繁琐的问题。\n- 作用：\n\t- 能追踪一个项目从诞生一直到定案的过程；\n\t- 记录一个项目的所有内容变化，方便地查阅特定版本的修订情况.\n- 常见问题：\n\t- **代码冲突**：多人操作同一个文件 ( 团队开发中的常见问题 )；\n\t- 无法后悔：做错了一个操作后，没有后悔药可以吃；\n\t- 版本备份：费空间；\n\t- 版本混乱：因版本备份过多造成混乱，难于找回正确的想要的版本；\n\t- 权限控制：无法对源代码进行精确的权限控制；\n\t- 追究责任：出现了严重的 BUG，无法得知是谁干的，容易耍赖.\n\n### 管理工具\n- CVS：历史悠久，现在几乎没人使用。\n- SVN：\n\t- 集中式版本控制的代表；\n\t- CVS 的接班人，速度和功能比 CVS 有很大幅度提升.\n- GIT：\n\t- 分布式源代码管理工具；\n\t- 目前被大多数开源项目使用。\n\n## 概念概述\n- Subversion 的简称为 SVN，是一个开放源代码的版本控制系统；\n- SVN 用于多个人共同开发同一个项目，目的是为了资源共享共用；\n- SVN 服务器有 2 种 `运行方式`：独立服务器和借助 Apache。两种方式各有利弊，可自行选择。\n- SVN `存储版本数据` 也有 2 种方式：`Berkeley DB` ( 事务安全型表类型 ) 和 `FSFS` ( 不需要数据库的存储系统 )。因为 Berkeley DB 方式在服务器中断时，有可能锁住数据，故选择 FSFS 的存储方式会更安全一点。\n\n## 环境搭建\n\n### SVN 服务器\n- 安装 SVN Server For Windows：[VisualSVN Server](https://www.visualsvn.com/server/download/) \n\n\t具体安装流程就不阐述了，可参考引用文章完成配置 $^{[1,2]}$。\n\n\t> Tips.01. 安装过程中，其中 SVN 服务器端口配置推荐使用HTTPS 的 `8443` 端口，因为 HTTPS 安全性比較高，尽管 `443` 是标准 HTTPSport。  \n\t> Tips.02. 还有就是用于验证的身份配置：Windows 验证和 Subversion 身份验证，默认是 Subversion 身份验证。\n\n- 安装 SVN Server For MacOS：MacOS 自带了 SVN 的服务器端和客户端功能。参考引用文章完成配置即可使用 $^{[3,4]}$。\n\n### SVN 客户端\n- Windows Client：[TortoiseSVN](https://tortoisesvn.net/downloads.html)\n- MacOS Client：[Cornerstone](https://cornerstone.assembla.com/)\n\n\t> 在 MacOS 上可利用 SVN 图形界面工具来管理源代码，可以大大减小使用命令行的痛苦 $^{[5]}$。\n\n### SVN 配置与使用\nWindows 端配置和使用 SVN 可通过图形界面工具即可完成操作，详细的步骤在引用文章 [1]、[2] 中也有提及。  \n故在本章节主要讲述 Mac 环境下搭建和配置 SVN。\n\n#### 创建代码仓库\n- Step.01. 新建一个 `svn` 目录，例如 `/Users/kofe/svn`，以后可在 `svn` 目录下创建多个仓库目录。\n- Step.02. 打开终端，创建一个名为 `idea` 仓库，输入指令：\n\n\t```bash\n\t# 指令执行成功后，会发现硬盘上多了个 /Users/kofe/svn/idea 目录\n\tsvnadmin create /Users/kofe/svn/idea\n\t```\n\n#### 配置用户权限\n主要是修改 `/svn/idea/conf` 目录下的三个文件：`svnserve.conf`、`Passwd` 文件和 `Authz` 文件。\n\n- svnserve.conf\n\n\t```bash\n\t# anon-access = read 代表匿名访问的时候是只读的\n\t# anon-access = none 代表禁止匿名访问，需要帐号密码才能访问\n\tanon-access = read\n\tauth-access = write\n\tpassword-db = passwd\n\tauthz-bd = authz\n\t```\n\n- Passwd 文件：在 `[users]` 下面添加账号和密码。\n\n\t```bash\n\t[users]\n\t# 格式：账号 = 密码\n\tkofe = 123456\n\tlucy = 123456\n\t```\n\n- Authz 文件：配置用户组和权限我们可以将在 Passwd 里添加的用户分配到不同的用户组里。以后就可对不同用户组设置不同的权限，没有必要对每个用户进行单独设置权限。即在 `[groups]` 下面添加组名和用户名，多个用户之间用逗号 **,** 隔开。\n\n\t```bash\n\t[groups] \n\tusergroup = kofe, lucy # 格式：组名 = 用户1, 用户2, ...\n\n\t# 使用 [/] 代表 SVN 服务器中的所有资源库\n\t# 某个组有读写权限\n\t[/]\n\t@usergroup = rw\n\n\t# 使用 [/] 代表 SVN 服务器中的所有资源库\n\t# 某个用户有读写权限\n\t# lucy = rw\n\t```\n\n#### 启动关闭服务\n- 在终端输入下列指令：若没有任何提示，恭喜你启动成功。\n\n\t```bash\n\tsvnserve -d -r /Users/kofe/svn\n\t# 或输入: svnserve -d -r /User/kofe/svn/idea\n\t```\n\n- 当然，会启用也要会关闭 SVN 服务器，特别是首次配置完 SVN 服务器需要重启。  \n\tCase.01. 在 `活动监视器` 中搜索 `svn`, 在列表中找到进程 `svnserve`, 点击左上角的`强制退出进程`。  \n\tCase.02. 或者可通过 shell 脚本实现一键关闭。  \n\t\n\t```bash\n\t#!/bin/sh\n\techo \"Current Process List:\"\n\techo \"= = = = = = = = = = =\"\n\tps -A | grep svn\n\techo \"= = = = = = = = = = =\"\n\tkill `pgrep \"svn\"`\n\n\techo \"Kill successfully!\" Current Process Status:\n\techo \"= = = = = = = = = = = = = = = = = = = = = =\"\n\tps -A | grep svn\n\techo \"= = = = = = = = = = = = = = = = = = = = = =\"\n\t```\n\n#### 代码版本控制\n\n> 当然，充分利用 SVN 图形界面工具 ( [Cornerstone](https://cornerstone.assembla.com/) ) 来管理源代码，可大大减小使用命令行的痛苦，提升使用效率。\n\n- 首次导入工程文件到 SVN 服务器：\n\n\t```bash\n\t# /Users/kofe/procedure/idea/SSM_DEMO，指的是需要导入的工程文件\n\t# svn://localhost/idea 指把工程文件上传到 idea 目录下\n\t# --username=admin --password=123456 指的是校验用户名和密码\n\t# -m \"初始化导入\" 指的是提交的信息注释\n\tsvn import /Users/kofe/procedure/idea/SSM_DEMO svn://localhost/idea --username=kofe --password=123456 -m \"初始化导入\"\n\t```\n\n- 从 SVN 服务器下载工程文件到本地 ( Checkout )：\n\n\t```bash\n\tsvn checkout svn://localhost/idea --username=kofe --password=123456 /Users/kofe/procedure/idea\n\t```\n\t\n- 二次提交代码到服务器：二次提交是有一个前提的, 那就是你首先需要在 SVN服务器上下载代码到本地，然后再去修改这一份代码, 才能够二次提交。\n\n\t```bash\n\tcd /Users/kofe/procedure/idea\n\tsvn commit -m \"修改部分代码 (注释修改的内容)\"\n\t```\n\t\n- SVN 基本操作原理：\n\t- `svn checkout`：将服务器代码完整下载到本地。\n\t- `svn update`：将服务器最新的代码下载到本地。\n\t- `svn commit`：将本地修改的内容提交到服务器。\n\n\t![图3-1SVN 基本操作原理](/images/illustration/Project/2018/08/building-a-svn-server_3-1.png)\n<center>图 3-1 SVN 基本操作原理</center>\n\n\t\n#### 代码版本冲突\n- 版本冲突原因：\n\n\t假设 A、B 两用户都在版本号为 100 时更新了 `sample.txt` 文件，A 用户在修改完成之后提交 sample.txt 到服务器，这个时候提交成功，这个时候 sample.txt 文件的版本号已经变成 101 了。同时 B 用户在版本号为 100 的 sample.txt 文件上作修改，修改完成之后提交到服务器时，由于不是在当前最新的 101 版本上作的修改，所以导致提交失败。\n\n- 版本冲突现象：\n\n\t冲突发生时，SVN 会在当前工作目录中保存所有的目标文件版本 [ 上次更新版本、当前获取的版本 ( 即别人提交的版本 )、自己更新的版本、目标文件 ]。  假设文件名是 `sample.txt` ，对应的文件名分别是 ( 同时在目标文件中标记来自不同用户的更改 )：\n\n\t```bash\n\tsample.txt.r101\n\tsample.txt.r102\n\tsample.txt.mine\n\tsample.txt\n\t```\n\t\n- `手工合并` SVN 冲突 $^{[6]}$，开始的时候让人觉得害怕，但有规律可循。例如有以下文本：\n\n\t```java\n\tMayonnaise\n\tLettuce\n\tTomato\n\tProvolone\n\t<<<<<<<.mine\n\tSalami\n\tMortadella\n\tProsciutto\n\t=======\n\tSauerkraut\n\tGrilledChicken\n\t>>>>>>>.r2\n\t```\n\n\t一连串的大于、小于、等于号是 SVN 冲突标记，这些数据得全部删除才可以提交。在 SVN 冲突区中，或许你需要和你的同事沟通来安排冲突区的文本内容，待所有冲突区得到合理的解决之后方可再提交文件。\n\n\t```java\n\t// 是你在冲突区里面做的修改\n\t<<<<<<<.mine\n\tSalami\n\tMortadella\n\tProsciutto\n\t=======\n\n\t// 是别人在冲突区做的修改\n\tSauerkraut\n\tGrilledChicken\n\t>>>>>>>.r2\n\t```\n\t\n- 如何降低冲突解决的复杂度：\n\t- 在提交时写上明确的 Message ( 注释 )，方便以后查找用户更新的原因。\n\t- 养成良好的使用习惯，使用 SVN 时每次都是先提交，后更新。每天 `早上` 打开后，首先要从版本库 `获取最新版本`，每天 `下班前` 必须将已经编辑过的文档都 `提交` 到版本库。\n\n## 参考资料 \n\\[1\\] [PhelanGeek. SVN 服务器搭建教程. jianshu.com. 2016](https://www.jianshu.com/p/96f2db36044b)  \n\\[2\\] [RealLiuNing. Windows 10 搭建独立 SVN 服务器. jianshu.com. 2018](https://juejin.im/post/5b0e50f5f265da08ec33b74e)  \n\\[3\\] [CainLuo. 搭建 MacOS 本地 SVN 服务器. juejin.im. 2016](https://juejin.im/post/58209be1a0bb9f0058c08452)  \n\\[4\\] [Sunny Fight. iOS 版本控制 SVN (Mac 环境下 SVN 的使用). jianshu.com. 2016](https://www.jianshu.com/p/66f085556fb2)  \n\\[5\\] [天蓝. SVN 在 Mac 上使用 Xcode+Cornerstone. jianshu.com. 2017](https://www.jianshu.com/p/650342b0a0ce)  \n\\[6\\] [aaronGao. svn conflict 冲突解决. cnbologs.com. 2016](https://www.cnblogs.com/aaronLinux/p/5521844.html)","tags":["版本控制"],"categories":["Project"]},{"title":"框架 | Java EE 之 SSM 框架配置与使用","url":"/2018/08/J2EE-SSM-1.html","content":"\n## 序言\n本文章主要围绕 J2EE 中 SSM ( Spring、Spring MVC、MyBatis ) 框架的配置以及使用问题展开学习的，最终目的是输出可复用的版本，以供后续的项目复用。当然，学习和配置的过程难免有不恰当或错误之处，还望朋友指出、斧正。\n\n\n## 更新进度\n- 2018.08.13：完成初稿，梳理 SSM 框架初识章节；\n- 2018.08.20：框架内容，梳理 SSM 框架基本内容；\n- 2018.08.24：框架内容，修正 SSM 框架部分内容；\n- 2018.08.26：框架内容，整合 Spring 和 MyBatis；\n\n## 教学资源\n- 视频 | [黑马程序员. J2EE 进阶. MyBatis 框架由浅入深. 2017. bilibili.com](https://www.bilibili.com/video/av20394903)\n\n\t> 本框架的学习笔记是基于此系列教学视频所得的。\n\t\n- 文章 | [吴操. 搭建一个基于 SSM 框架的人力资源管理系统. 2018. csdn.net](https://blog.csdn.net/noaman_wgs/article/details/79503559)\n\n\t> 发现这位博主搭建的例子 ( [nomico271. SSM_HRMS. Github](https://github.com/nomico271/SSM_HRMS) ) 紧凑、简练，适合初入门时来模仿构建自己的项目。\n\n<!-- More -->\n\n## IDE 搭建\nIDE 搭建以 [Java EE 之 SSH 框架配置与使用](https://www.kofes.cn/2018/07/J2EE-SSH-SSI-1.html#IDE-搭建) 为参考。\n\n\n## 版本信息\t\n-  框架版本：\n\t- Spring MVC：4.3.x\n\t- Spring：4.3.x\n\t- MyBatis：3.4.x\n- 其他组件：\n\t- MySQL：5.7.x / SQL Server：2008 R2\n\t- Tomcat：9.0.x\n\t- Maven：3.3.9\n\t- JDK：1.8\n- 构建框架，还需要相关依赖库 ( Jar 包 )，为便于你下载 Jar 包或校对依赖是否齐全，具体地，以下列举了 SSM 框架所需要的依赖库。\n\n| Spring | MyBatis |\n| :---- | :---- | \n| spring-core | mybatis | \n| spring-beans | mybatis-spring ( Spring 整合 Mybatis ) |\n| spring-context | pagehelper ( 分页助手 ) |\n| spring-webmvc | &nbsp; |\n| spring-web | &nbsp; |\n| spring-aop ( 整合 Aop ) | &nbsp; |\n| aopalliance ( 整合 Aop ) | &nbsp; |\n| spring-aspect ( 整合 Aop ) | &nbsp; |\n| aspectjweaver ( 整合 Aop ) | &nbsp; |\n| spring-tx ( 整合事务 ) | &nbsp; |\n| spring-jdbc | &nbsp; |\n\n|  其他依赖库 ( Jar 包 ) | 备注 |\n| :---- | :---- |\n| log4j | 日志支持 |\n| log4j-core、log4j-api | 日志支持 |\n| slf4j-api、slf4j-log4j12 | 日志支持 |\n| junit | Junit 单元测试 |\n| c3p0 | c3p0 数据库连接池 |\n| mysql-connector-java | 添加 MySQL 数据库支持 |\n| jackson-databind | Json 数据转化为类对象 |\n| jsp-api | JSP |\n| javax.servlet-api | Servlet |\n| jstl | JSTL 标签库 |\n| taglibs-standard-impl | JSP 标准标签库 |\n\n\n## 框架初识\n- SSM 框架集由 Spring、SpringMVC、MyBatis 三个开源框架整合而成，是继 SSH (Spring、Struts2、Hibernate ) 之后，目前比较主流的 Java EE 企业级框架，适用于搭建各种大型的企业级应用系统。 \n\n\t> SSM 与 SSH 都有各自的优缺点，而根据你的项目特点而选择合适的框架即可。关于 SSH 框架的配置与使用，感兴趣的可参考本博客的文章：[Java EE 之 SSH 框架配置与使用](https://www.kofes.cn/2018/07/J2EE-SSH-SSI-1.html)\n\n### ORM 框架\n- 对象关系映射（Object Relational Mapping，O/R Mapping，ORM）是通过使用描述对象和数据库之间映射的 `元数据`，将面向对象语言程序中的 `对象` 自动 `持久化` 到 `关系数据库` 中。本质上就是将数据从一种形式转换到另外一种形式。 \n- 让 `实体类` 和 `数据库表` 进行一一对应关系 (映射关系)，`实体类属性` 和 `表里面的字段` 对应。操作表对应实体类对象，而不需操作数据库表。\n\n### SSM 框架\n\n#### MyBatis\n\n##### 原生 Jdbc 操作数据库\n在引入 MyBatis ( 或 Hibernate ) 前，一般通过原生 Jdbc 来操作数据库，而这种方式存在很多问题 $^{[2]}$：\n\n- 程序创建数据库连接，即需求时创建，用完后关闭。若频繁的创建、关闭数据库连接，显然存在问题。 ( 可以通过数据库连接池来处理这个问题 )\n\n- 硬编码的地方太多了。例如，数据库连接相关信息，SQL相关信息等。( 可通过使用 XML 配置文件，来避免这个问题 )\n\n- 实质上，我们编写JDBC是有步骤可循的，即先得到数据库连接对象，传入SQL、输入参数、设置参数，再去执行SQL，然后遍历结果集将数据库 SQL 执行的结果对象转化为 JAVA 对象，然后再去业务处理，最后释放资源。\n\n\t那么这个过程，实际上是个 `模板方法`，能不能抽离出来，更好的去完成这个过程呢？\n\n\n##### 框架比较\n-  Hibernate\n\t- 优点：  \n\t1) Hibernate 这个纯粹的 ORM 框架，以面向对象的方式来完成数据库的操作。  \n\t2) Hibernate 不需要编写 SQL 即可完全映射，且可通过 HQL (Hibernate Query Language) 语言对 POJO 操作。  \n\t3) Hibernate 提供了日志、缓存、级联等特性。  \n\t- 缺点：\n\t1) Hibernate 可自由编写 SQL，但非常繁琐，则优化 SQL 实现高性能数据库操作有限制，在互联网项目快速迭代开发中显得过于笨重。\n\t2) Hibernate 的 `级联会造成太多性能的丢失`。\n\t3) Hibernate 不支持存储过程。\n- MyBatis\n\t- 优点：自由书写 SQL、支持动态 SQL、处理列表、动态生成表名、支持存储过程。\n\t- 缺点：需要编写 SQL 和映射规则，工作量相对较大。\n\n##### 基本介绍\n- MyBatis 前身是 Apache 的开源项目 `iBatis`，`iBatis` 一词源于 internet 和 abatis 的组合，是一个基于 Java 的持久层框架。\n\n- MyBatis 是一款持久层框架，它支持定制化 SQL (不屏蔽 SQL)、存储过程以及高级映射。\n- MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。\n- MyBatis 可使用 XML配置文件形式或注解形式来配置和映射原生信息，将接口和 POJOs ( Plain Ordinary Java Object，普通 Java 对象 / 实体类 ) 映射成数据库中的记录。\n\n\t> 我们把 POJO 对象和数据库表相互映射的框架称为对象关系映射框架 ( Object Relational )。\n\n##### 架构原理\n\n![图6-1SSM架构原理图](/images/illustration/Project/2018/08/J2EE-SSM-1_6-1.png)\n<center>图 6-1 SSM架构原理图</center>\n\n- `SqlMapConfig.xml`：MyBatis 全局配置文件，配置数据源、事务等运行环境相关信息；SQL文件即是 `Mapper.xml`。\n\n- `SqlSessionFactory`：会话工厂，用于创建 SqlSession。\n\n- `SqlSession`：即操作数据库的接口，其内部借助 `Executor` 执行器完成对数据库的操作。\n\n- `MappedStatement`：底层封装对象，对操作数据库储存封装，其中包括 SQL 语句 ( Mapper.xml )、输入对象和输出结果类型。\n\n##### 配置文件\n\n- 全局配置文件：在 Src 根目录下建立并配置 `SqlMapConfig.xml`  \n\n\t与 Spring 整合 Hibernate 一样，后期 Spring 整合 MyBatis 后此配置文件可省略。当然，学习阶段代码还是得提供。\n\t\n\t```xml\n\t<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\t<!DOCTYPE configuration\n\t    PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n\t    \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\t<configuration>\n\n\t    <!-- 加载 Java 的配置文件或者声明属性信息 ( 详细见本项目源码 ) -->\n\t    <properties resource=\"c3p0.properties\"></properties>\n\n\t    <!-- 全局参数配置 -->\n\t    <!-- <settings></settings> -->\n\n\t    <!-- 自定义别名 -->\n\t    <typeAliases>\n\t        <!-- 单个别名定义\n\t        <typeAlias type=\"cn.kofes.ssm.pojo.Sample\" alias=\"Sample\"/>\n\t        -->\n\n\t        <!-- 批量别名定义 ( 推荐 )\n\t         | package：指定包名称来为该包下的 pojo 类声明别名，默认的别名就是类名 ( 首字母大小写都可 )\n\t        -->\n\t        <package name=\"cn.kofes.pojo\"/>\n\t    </typeAliases>\n\n\t    <!-- 配置 MyBatis 的环境信息，与 Spring 整合，该信息由spring来管理 -->\n\t    <environments default=\"development\">\n\t        <environment id=\"development\">\n\t            <!-- 配置 Jdbc 事务控制，由 MyBatis 进行管理 -->\n\t            <transactionManager type=\"JDBC\"></transactionManager>\n\t            <!-- 配置数据源，采用 MyBatis 连接池 -->\n\t            <dataSource type=\"POOLED\">\n\t                <property name=\"driver\" value=\"${datasource.driverClass}\"/>\n\t                <property name=\"url\" value=\"${datasource.jdbcUrl}\"/>\n\t                <property name=\"username\" value=\"${datasource.user}\"/>\n\t                <property name=\"password\" value=\"${datasource.password}\"/>\n\t            </dataSource>\n\t        </environment>\n\t    </environments>\n\n\t    <!-- 加载映射文件 -->\n\t    <mappers>\n\t        <!-- 单个映射文件添加 -->\n\t        <mapper resource=\"mapper/SampleMapper.xml\"/>\n\n\t        <!-- 批量加载映射文件：mapper.java 与 mapper.xml 同名，且在同一目录下\n\t        <package name=\"cn.kofes.ssm.mapper\" />\n\t        -->\n\t    </mappers>\n\t</configuration>\n\t```\n\t\n- Mapper 映射文件：例如 `SampleMapper.xml`\n\n\t- 创建实体类对象 ( POJOs )：\n\n\t```java\n\t// cn.kofes.pojo.Sample.java\n\tpublic class Sample {\n\t    private Integer id;\n\t    private String name;\n\t\n\t    public Integer getId() { return id; }\n\t    public void setId(Integer id) { this.id = id; }\n\t    public String getName() { return name; }\n\t    public void setName(String name) { this.name = name; }\n\t}\t\n\t```\n\n\t- 在映射文件中配置 SQL 语句，如建立 `SampleMapper.xml` ( 便于管理，把映射文件统一放置 mapper 文件夹下 )：\n\n\t```xml\n\t<!-- mapper/SampleMapper.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\t<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n\t    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n\n\t<!-- namespace 用于绑定 Mapper 代理开发 -->\n\t<mapper namespace=\"cn.kofes.mapper.SampleMapper\">\n\t    <!--\n\t     | 配置 SQL 语句：例如查找某一元组\n\t     | - id 属性：唯一标识映射文件中的 SQL\n\t     | - parameterType 属性：指定输入参数的类型\n\t     | - resultType 属性：指定输出参数的类型\n\t     |   SQL 语句会封装到 MappedStatement 对象中，故 ID 又称为 Statement 的 ID\n\t     | - #{}：表示一个占位符号\n\t     | - #{id}：id 表示接收输入的参数，参数名称就是 id\n\t    -->\n\t    <select id=\"findCertianTupleById\" parameterType=\"int\" resultType=\"cn.kofes.bean.Sample\">\n\t        SELECT * FROM t_sample WHERE id = #{id}\n\t    </select>\n\t    \n\t    <!-- 插入元组 -->\n\t    <insert id=\"insertOneTuple\" parameterType=\"cn.kofes.pojo.Sample\">\n\t        <!-- 用于自增 ID 的情况，在完成插入后将 ID 返回 user 对象中\n\t        <selectKey keyProperty=\"id\" order=\"AFTER\" resultType=\"java.lang.Integer\">\n\t            SELECT LAST_INSERT_ID()\n\t        </selectKey>\n\t        -->\n\n\t        <!-- 用于非自增 ID 的情况，先产生 ID 放入 user 对象中，再执行保存\n\t        <selectKey keyProperty=\"id\" order=\"BEFORE\" resultType=\"java.lang.String\">\n\t            SELECT UUID()\n\t        </selectKey>\n\t        INSERT INTO t_sample (id, name) VALUES (#{id}, #{name})\n\t        -->\n\t        INSERT TO t_sample(id, name) value(#{id}, #{name})\n\t    </insert>\n\t    \n\t    <!-- 删除一条元组 -->\n\t    <delete id=\"deleteOneTupleById\" parameterType=\"java.lang.Integer\">\n\t        DELETE FROM t_sample WHERE id = #{id}\n\t    </delete>\n\n\t    <!-- 更新一条元组 -->\n\t    <update id=\"updateOneTupleById\" parameterType=\"cn.kofes.pojo.Sample\">\n\t        UPDATE t_sample SET id = #{id}, name = #{name}\n\t        WHERE id = #{id}\n\t    </update>\n\t</mapper>\n\t```\n\t\n##### 案例演示 \n- 单独使用 MyBatis 框架，根据 id 查询指定用户：\n\n\t```java\n\t// 便于检验效果，这里以单元测试类实现\n\tpublic class DBOperatorTest {\n\t    @Test\n\t    public void testDoSomethingInDB() {\n\t        // 加载 MyBatis 配置文件\n\t        String resource  = \"SqlMapConfig.xml\";\n\t        // 得到配置文件流\n\t        InputStream inputStream = Resource.getResourceAsStream(resource);\n\t        // 创建会话工厂\n\t        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder()\n\t            .build(inputStream);\n\t            \n\t        // 通过会话工厂，得到 SqlSession 对象\n\t        SqlSession sqlSession = sqlSessionFactory.openSession();\n\t        \n\t        // 通过 SqlSession 操作数据库\n\t        // 第一个参数：namespace + statement id\n\t        // 第二个参数：指定和映射文件中所匹配的 parameterType 相同属性类型的参数\n\t        \n\t        /* 根据 ID 查询元组\n\t        Sample sample = sqlSession.selectOne(\n\t            \"cn.kofes.mapper.SampleMapper.findCertainTupleById\", 1);\n\t        */\n\n\t        /* 插入一条元组\n\t        Sample sample = new Sample();\n\t        sample.setName(\"邯郸\");\n\t        sqlSession.insert(\n\t            \"cn.kofes.mapper.SampleMapper.insertOneTuple\", sample);\n\t        */\n\t        \n\n\t        /* 根据 ID 修改元组\n\t        Sample sample = new Sample();\n\t        sample.setId(14);\n\t        sample.setName(\"阿斗\");\n\t        sqlSession.update(\n\t            \"cn.kofes.mapper.SampleMapper.updateOneTupleById\", sample);\n\t        */\n\t        \n\t        sqlSession.commit();\n\t        sqlSession.close();\n\t    }\n\t}\n\t```\n\t\n- 案例总结：\n\t- `namespace`：命名空间，作用是隔离 SQL。在 MyBatis 和 Spring 结合使用时具有特殊的意义，这里暂且使用全限定类名。\n\t- `<select>` 等 SQL Command 标签需要一个 ID，还需要输入参数 parameterType，输出参数映射 resultType 等。在 MyBatis 底层封装成了一个 MappedStatement 对象，使用时以 `namespace.id` 的方式引用即可。\n\t- `#{}` 和 `${}`：\n\t\t- `#{}`：表示一个占位符号，用于接收输入参数，类型可以是简单类型，也可是 POJO、HashMap 等。( 通过 `OGNL 表达式` 读取对象的属性值 )\n\t\t- `${}`：表示一个拼接符号，会引入 `SQL注入`，故不建议使用。\n\n- 思考问题：\n\t- 我们重点关注的是 SqlSession，它其实是一个 interface，定义了很多操作数据库的接口，其中实现了 Closeable 接口，很明确是使用完毕后需要 `close()` 的。  \n\t- 它的实现类 DefaultSqlSession 中有一些数据域，比如说 autoCommit，在默认情况下是不开启自动提交的；且方法也并不是 Synchronized 的，这说明 SqlSession 并不是线程安全的，因此我们应该是局部使用 SqlSession，且在使用完毕后 `close()` 关闭 sqlSession。\n\n##### ~~MyBatis 原始方法~~\n\n> 这种方式，重复的代码太多，现阶段基本弃用，目前使用最多的就是 Mapper 代理开发。\n\n- 在开始 Mapper 代理开发前，可了解一种 MyBatis 的原始 Dao 开发方法：\n\t- Step.01.提供 Dao 接口，有增、删、改、查的方法。\n\t- Step.02.提供 Dao 的实现类，在实现类中利用 Spring 注入 SqlSessionFactory，然后在各个方法中得到 SqlSession，进行操作后，关闭 SqlSession 即可。\n- 便于理解，放上实现代码：\n\n\t```java\n\t// DAO 层接口\n\tpublic interface BaseDao {\n\t    public void insertOneTuple(User user) throw Exception;\n\t    public void deleteOneTupleById(int id)  throw Exception;\n\t    public void updateOneTupleById(User user)  throw Exception;\n\t    public User findCertainById(int id) throw Exception;    \n\t}\n\t\n\t// DAO 层实现类\n\tpublic class SampleDaoImpl implements BaseDao {\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    \n\t    public SampleDaoImpl(SqlSessionFactory sqlSessionFactory) \n\t        throw Exception {\n\t        this.sqlSessionFactory = sqlSessionFactory;\n\t    }\n\t    \n\t    @Override\n\t    public User findCertainById(int id) throw Exception { \n\t        // 省略实现逻辑...\n\t    }\n\t    @Override\n\t    public void deleteOneTupleById(int id)  throw Exception { \n\t        // 省略实现逻辑...\n\t    }\n\t    @Override\n\t    public void updateOneTupleById(User user)  throw Exception {\n\t        // 省略实现逻辑...\n\t    }\n\t    @Override\n\t    public User findCertainById(int id) throw Exception {\n\t        // 省略实现逻辑...\n\t    }\n\t}\n\t\n\t// 单元测试类\n\tpublic class SampleDaoTest {\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    \n\t    @Before\n\t    public void setUp() {\n\t        InputStream inputStream = \n\t            Resource.getResourceAsStream(\"SqlMapConfig.xml\");\n\t        SqlSessionFactory sqlSessionFactory = \n\t            new SqlSessionFactoryBuilder().build(inputStream);\n\t    }\n\n\t    @Test\n\t    public void testFindCertainById() {\n\t        BaseDao sampleDao = new SampleDaoImpl(sqlSessionFactory);\n\t        User user = sampleDao.findCertainById(5);\n\t        System.out.println( user.toString() );\n\t    }\n\t}\n\t```\n\n##### Mapper 代理开发\n\n- Mapper 映射文件：上一节配置的映射文件 `SampleMapper.xml`\n\n- Mapper 接口：\n\t-  在 SampleMapper.xml 中 namespace 等于 Mapper 的接口地址 ( `全路径地址` )；\n\t-  在 Mapper 接口中的 `方法名` 和 SampleMapper.xml 中 Statement 的 `ID` 名称一致；\n\t-  在 Mapper 接口中的方法 `输入参数类型` 和 SampleMapper.xml 中 Statement 的 `parameterType` 指定的类型一致。\n\t-  在 Mapper 接口中的 `方法返回值类型` 和 SampleMapper.xml 中 Statement 的 `resultType` 指定的类型一致。\n\n- 关于规范的启示：故我们进行 Mapper 的开发应该遵循一些规范，这样 MyBatis 方可自动生成 `XXXMapper` 类的代理实现类。\n\t- 保证 XXXMapper.xml 中的 `namespace` 同 XXXMapper.java 的 `全限定名称` 一致；\n\t- 保证 XXXMapper.xml 中的 `Statement ID` 同 XXXMapper.java 的 `方法名称` 一致；\n\t- 保证 XXXMapper.xml 中的 Statement 的输入参数的类型 ( `parameterType` )、输出参数的类型 ( `resultType` ) 同 `XXXMapper.java` 的保持一致.\n\n\t![图6-2Mapper代理开发规范](/images/illustration/Project/2018/08/J2EE-SSM-1_6-2.png)\n<center>图6-2 Mapper 代理开发规范</center>\n\n\t```java\n\t// Mapper 接口：cn.kofes.ssm.mapper.SampleMapper.java\n\tpublic interface SampleMapper {\n\t    public void insertOneTuple(Sample sample);\n\t    public void deleteOneTupleById(Integer id);\n\t    public void updateOneTupleById(Sample sample);\n\t    public Sample findCertainTupleById(Integer id);\n\t}\n\t\n\t// 单元测试类\n\tpublic class SampleMapperTest {\n\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    private  SqlSession sqlSession;\n\n\t    @Before\n\t    public void setUp() throws IOException {\n\t        // 加载 MyBatis 配置文件，得到配置文件流\n\t        InputStream inputStream =\n\t            Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n\t        // 创建会话工厂\n\t        SqlSessionFactory sqlSessionFactory =\n\t            new SqlSessionFactoryBuilder().build(inputStream);\n\t        // 通过会话工厂，得到 SqlSession 对象\n\t        sqlSession = sqlSessionFactory.openSession();\n\t    }\n\n\t    @Test\n\t    public void testFindCertainTupleById() {\n\t        SampleMapper sampleMapper = sqlSession.getMapper(SampleMapper.class);\n\t        System.out.println( sampleMapper.findCertainTupleById(15).toString() );\n\t        sqlSession.close();\n\t    }\n\t}\n\t```\n- 当然不要忘记在全局配置文件 `SqlMapConfig.xml` 中加载映射文件 ( 参考上述配置文件 )。\n\n##### POJO 包装类型查询\n\n###### 输入映射\n-  输入映射：通过 parameterType 指定输入参数的类型，类型可以是 `简单类型`，也可以是  `POJO`、`HashMap` 类型。\n\n\t```java\n\t// 定义包装类型 POJO：自定义所需要的查询条件，实现多表查询\n\tpublic class POJOCollection {\n\t    /**\n\t     * 为更加形象、理解，这里引入用户和部门的实体类\n\t     * 一个用户对应一个部门，一个部门包含多个用户\n\t     */\n\t    private User user; // User 实体类\n\t    private Department department; // Department 实体类\n\t    \n\t    // 构造函数初始化\n\t    public POJOCollection() {\n\t        user = new User();\n\t        department = new Department();\n\t    }\n\t\t\n\t    // 生成 Setter 和 Getter 方法\n\t    public void setUser(User user) { this.user = user; }\n\t    public User getUser() { return user; }\n\t    public void setDepartment(Department department) { this.department = department; }\n\t    public Department getDepartment() { return department; }\n\t}\n\t```\n\n- 在映射文件 `SampleMapper.xml` 中配置 SQL 语句：\n \n\t```xml\n\t<!--  自定义所需要的查询条件，实现多表查询 -->\n\t<select id=\"findPOJOList\"\n\t    parameterType=\"cn.kofes.ssm.pojo.POJOCollection\"\n\t    resultType=\"cn.kofes.ssm.pojo.User\">\n\t    SELECT * FROM t_user as u, t_department as d\n\t    WHERE u.uid = #{user.uid} and d.depart_id = #{department.depart_id}\n\t</select>\n\t```\n\n- Mapper 接口：\n\n\t```java\n\t// Mapper 接口：cn.kofes.ssm.mapper.SampleMapper.java\n\tpublic interface SampleMapper {\n\t    public List<Sample> findPOJOList(POJOCollection pojoCollection);\n\t}\n\n\t// 单元测试类\n\tpublic class SampleMapperTest {\n\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    private  SqlSession sqlSession;\n\n\t    @Before\n\t    public void setUp() throws IOException {\n\t        // 同上\n\t    }\n\n\t    @Test\n\t    public void testFindPOJOList() {\n\t        // Mapper 接口代理\n\t        SampleMapper sampleMapper =\n\t            sqlSession.getMapper(SampleMapper.class);\n\n\t        POJOCollection pojoCollection = new POJOCollection();\n\t        pojoCollection.getUser().setUid(50);\n\t        pojoCollection.getDepartment().setDepart_id(1);\n\n\t        List<User> list =\n\t            sampleMapper.findPOJOList(pojoCollection);\n\t        System.out.println( list.get(0).toString() );\n\n\t        sqlSession.close();\n\t    }\n\t}\n\t```\n\n###### 输出映射\n\n- 输出映射：使用 resultType 进行输出映射，查询列名和 POJO 中的属性名一致，该列才会成功映射。\n\n\t> 若查询出来的列名 ( 通过 AS 自定义的列名 ) 和 POJO 的属性名不一致，通过定义一个 resultMap 对列名和属性名之间作一个映射关系。\n\t\n- 定义 resultMap：在映射文件 `SampleMapper.xml` 中定义；\n\n\t```xml\n\t<!--\n\t | id：resultMap 唯一标识\n\t | type：\n\t-->\n\t<resultMap id=\"sampleResultMap\" type=\"cn.kofes.ssm.pojo.Sample\">\n\t    <!--\n\t     | id 表示查询结果集中的唯一标识\n\t     | colum：查询出来的列名 ( AS 自定义列名 )\n\t     | property：type 指定的 POJO 类型中的属性名\n\t    -->\n\t    <id column=\"id_\" property=\"id\" />\n\t    <!--\n\t     | result 对非 ID 的属性进行映射定义\n\t    -->\n\t    <result column=\"name_\" property=\"name\" />\n\t</resultMap>\n\t\n\t<!-- 使用 resultMap 作为 Statement 的输出映射类型 -->\n\t<select id=\"listCustomView\"\n\t    parameterType=\"int\" resultMap=\"sampleResultMap\">\n\t    SELECT id as id_, name as name_\n\t    FROM t_sample\n\t    WHERE id = #{id}\n\t</select>\n\t```\n\n- Mapper 接口：\n\n\t```java\n\t// Mapper 接口：cn.kofes.ssm.mapper.SampleMapper.java\n\tpublic interface SampleMapper {\n\t    public Sample listCustomView(Integer id);\n\t}\n\n\t// 单元测试类\n\tpublic class SampleMapperTest {\n\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    private  SqlSession sqlSession;\n\n\t    @Before\n\t    public void setUp() throws IOException {\n\t        // 同上\n\t    }\n\n\t    @Test\n\t    public void testListCustomView() {\n\t        // Mapper 接口代理\n\t        SampleMapper sampleMapper = \n\t            sqlSession.getMapper(SampleMapper.class);\n            \n\t        System.out.println( sampleMapper.listCustomView(15) );\n\t    }\n\t}\n\t```\n\n###### 映射对比\n- `resultType` 查询出来的列名 ( 通过 AS 自定义的列名 ) 和 POJO 的属性名需一致，该列才会成功映射。  \n\t`resultMap` 可根据查询出来的列名指定 POJO 类型中的应的属性名。\n- `resultType` 返回的是 User 对象，适应较简单的输出结果映射，MyBatis 其实还提供了`resultMap` 作为复杂输出结果映射。在 [高级映射](#高级映射) 章节将对比阐述。\n\t\n##### 动态 SQL\nMyBatis 核心是对 SQL 语句进行灵活操作，通过表达式进行判断，对 SQL 进行灵活拼接、组装。\n\n- SQL 语句 `拼接`，例如 `<where>` 和 `<if>` 标签的组合使用；\n- SLQ 语句 `抽离`，例如 `<sql>` 和 `<include>` 标签的组合使用； \n- Foreach：向 SQL 传递数组或 List 集合，MyBatis 使用 `<foreach>` 标签解析。例如，我们需要查询多个 ID 值；\n\n\t```xml\n\t<!-- 将通用的 SQL 语句抽离，例如：属性名、表名等 -->\n\t<sql id=\"t_sample\">t_sample</sql>\n\n\t<select id=\"findPOJOList\" \n\t    parameterType=\"cn.kofes.ssm.pojo.POJOCollection\"\n\t    resultType=\"cn.kofes.ssm.pojo.Sample\">\n\t    SELECT * FROM <include refid=\"t_sample\" />\n    \n\t    <!-- 自动去掉条件中第一个 AND 或者 OR  -->\n\t    <where>\n\t        <!-- Case.01.注意下面这种写法只适用于 id 类型为 String  -->\n\t        <if test=\" sample.id != null and sample.id != '' \">\n\t            AND sample.id = #{sample.id}\n\t        </if>\n\t        <if test=\" other.id != null and other.id  != '' \">\n\t            AND other.id = #{other.id}\n\t        </if>\n        \n\t        <!-- Case.02.若 id 类型为 Integer 需要以下写法 \n\t        <if test=\"_parameter!=null and _parameter > 0\">\n\t            AND id = #{id}\n\t        </if>\n\t        -->\n\t        \n\t        <!-- Case.03.查询多个 ID 值 -->\n\t        \n\t        <!--  拼接效果：AND(id = ? OR id = ? OR id = ?) \n\t        <if test=\"ids != null\">\n\t            <foreach collection=\"ids\" item=\"id\" \n\t                open=\"AND (\" close=\")\" separator=\"OR\">\n\t                id = #{id}\n\t            </foreach>\n\t        </if>\n\t        -->\n\t        \n\t        <!--  拼接效果：IN(1, 3, 5)\n\t        <if test=\"ids != null\">\n\t            <foreach collection=\"ids\" item=\"id\" \n\t                open=\"IN (\" close=\")\" separator=\",\">\n\t                id = #{id}\n\t            </foreach>\n\t        </if>\n\t        -->\n\t    </where>\n\t</select>\n\t```\n\t\n##### 高级映射\n为便于后续章节的学习，这里以用户表、商品表、订单表和订单明细表的实例来阐述问题：\n\n![图6-3用户购物清单ER图](/images/illustration/Project/2018/08/J2EE-SSM-1_6-3.png)\n<center>图 6-3 用户购物清单 ER 图</center>\n\n- 用户表 ( User )：购买商品的用户信息；\n- 商品表 ( Item )：商品的明细信息；\n- 订单表 ( Order )：用户所创建的订单；\n- 订单明细表 ( OrderDetail )：每一张订单记录购买的商品信息；\n\n\t> 为便于理解，数据表与 POJO ( 实体类 ) 的名称统一命名为相同名称。\n\n###### 一对一映射\n便于理解，我们可以确立一需求：查询订单表，关联查询 `创建订单的用户信息`。\n\nUser 和 Order 的关联查询，关键是查询出来的结果如何映射？是用 resultType，还是用 resultMap？\n\n1) `resultType`  \n\n显然我们的实体类 ( User 仅仅包含用户信息，Order 仅仅包含订单信息，Order 中没有 User 的引用 ) 并不能接受关联查询的结果集，那么我们可以考虑使用 OrderVoUser 映射类，即让它 `extends Orders`，然后在加上一些 User 的属性作为输出结果类型。\n\t\n> OrdersVoUser 映射类的创建原理与上述的 POJOCollection 映射类一样。\n\t\n2) `resultMap`  \n\t\n可满足复杂输出结果映射，例如数据库字段名称与查询的字段名称 ( 或通过 AS 声明了别名 ) 不一致的映射；延迟加载；一对一，一对多，多对多等高级映射特性。\n\t\n> 这里引用实例说明，即使用 resultMap 将查询结果中的订单信息映射到 Other 对象中，在 Order 类中添加 User 属性，将关联查询出来的用户信息映射到 Other 对象中的 User 属性中。 \n\t\n- 配置映射文件 Mapper.xml \n\n\t```xml\n\t<!-- 映射文件 Mapper.xml -->\n\t\n\t<!-- 订单查询映关联查询用户信息的 resultMap  -->\n\t<resultMap id=\"OrderUserResultMap\" type=\"cn.kofes.ssm.pojo.Order\">\n\t    <!-- \n\t     | 配置映射的订单信息\n\t     | colum：订单信息的列名\n\t     | property：订单信息的列名所映射到 POJO 中的属性名\n\t    -->\n\t    <id column=\"order_id\" property=\"order_id\" />\n\t    <result column=\"createtime\" property=\"createtime\" />\n\t    \n\t    <!-- \n\t     | 配置映射的关联用户信息\n\t     | association 标签中 javaType 必须要明确指明类型\n\t     -->\n\t     <association property=\"user\" javaType=\"cn.kofes.ssh.pojo.User\">\n\t         <id column=\"uid\" property=\"uid\" />\n\t         <result column=\"username\" property=\"username\" />\n\t         <result column=\"age\" property=\"age\" />\n\t         <result column=\"phone\" property=\"phone\" />\n\t     </association>\n\t</resultMap>\n\t\n\t<!-- SQL 语句：查询订单表，关联查询创建订单的用户信息  -->\n\t<select id=\"findOrderUserResultMap\" resultMap=\"OrderUserResultMap\">\n\t    SELECT\n\t        u.uid, u,username, u.age, u.phone, \n\t        o.order_id\n\t    FROM\n\t        Order AS o, User AS u\n\t    WHERE\n\t        o.id = u.uid\n\t</select>\n\t```\n\t\n- Mapper 接口：\n\n\t```java\n\t// SampleMapper 接口\n\tpublic interface SampleMapper {\n\t    public List<Order> findOrderUserResultMap();\n\t}\n\n\t// 单元测试类\n\tpublic class SampleMapperTest {\n\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    private  SqlSession sqlSession;\n\n\t    @Before\n\t    public void setUp() throws IOException {\n\t        // 同上\n\t    }\n\n\t    @Test\n\t    public void testFindOrderUserResultMap() {\n\t        // Mapper 接口代理\n\t        SampleMapper sampleMapper = \n\t            sqlSession.getMapper(SampleMapper.class);\n            \n\t        List<Order> list = sampleMapper.findOrderUserResultMap();\n\t    }\n\t}\n\t```\n\n###### 一对多映射\n确立一需求：查询订单及订单明细的信息。\n\n- 实体类配置\n\n\t> 为了满足二级缓存需求，所有实体类实现 `Serializablle` 接口，实现序列化。\n\n\t```java\n\tpublic class User implements Serializable {\n\t\n\t    private Integer uid;\n\t    private String username;\n\t    private Integer age;\n\t    private String phone;\n\t    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t\n\tpublic class Order implements Serializable {\n\t    private Integer order_id;\n\t    private Date createtime;\n\t    \n\t    // 把订单所对应的订单明细映射到 orderDetail 属性中\n\t    private List<OrderDetail> orderDetail;\n\t    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t\n\tpublic class OrderDetail implements Serializable {\n\t    private Integer orderdetail_id;\n\t    private Integer item_id;\n\t    private Integer order_id;\n\t    private Integer amount;\n\t    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\n\tpublic class Item implements Serializable {\n\t    private Integer item_id;\n\t    private String itemname;\n\t    private String itemprice;\n    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t```\n\n- 配置映射文件 Mapper.xml \n\n\t```xml\n\t<!-- 映射文件 Mapper.xml -->\n\t\n\t<!-- 查询订单及关联查询订单明细的 resultMap  -->\n\t<resultMap \n\t    id=\"OrderAndOrderDetailResultMap\"\n\t    type=\"cn.kofes.ssm.pojo.Order\"\n\t    extend=\"OrderUserResultMap\">\n\t\n\t    <!-- 配置映射的订单信息 -->  \n\t    <!-- 配置映射的用户信息 -->\n\t    <!-- 通过继承免去重复配置：extend=\"Objective ResultMap ID\" -->\n\t    \n\t    <!-- \n\t     | 配置映射的订单明细信息：使用 Collection 对关联查询的多条记录\n\t     | 映射到一个 List 集合属性中\n\t     | ofType：指定映射到集合属性中 POJO 的类型\n\t    -->\n\t    <collection property=\"orderDetail\" ofType=\"cn.kofe.ssm.pojo.OrderDetail\">\n\t        <id column=\"orderdetail_id\" property=\"id\">\n\t        <result column=\"item_id\" property=\"username\" />\n\t        <result column=\"order_id\" property=\"username\" />\n\t        <result column=\"amount\" property=\"amount\" />\n\t    </collection>\n\t</resultMap>\n\t\n\t<!-- SQL：查询订单及订单明细的信息 -->\n\t<select \n\t    id=\"findOrderAndOrderDetailResultMap\"\n\t    resultMap=\"OrderAndOrderDetailResultMap\">\n\t    SELECT\n\t        o.order_id, o.createtime, \n\t        od.item_id, od.amount,\n\t        i.itemname\n\t    FROM\n\t        Order AS o, Item AS i, OrderDetail As od\n\t    WHERE \n\t        od.order_id = o.order_id AND \n\t        od.item_id = i.item_id\n\t</select>\n\t```\n\t\n- Mapper 接口：\n\n\t```java\n\t// SampleMapper 接口\n\tpublic interface SampleMapper {\n\t    public List<Order> findOrderAndOrderDetailResultMap();\n\t}\n\n\t// 单元测试类\n\tpublic class SampleMapperTest {\n\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    private  SqlSession sqlSession;\n\n\t    @Before\n\t    public void setUp() throws IOException {\n\t        // 同上\n\t    }\n\n\t    @Test\n\t    public void testFindOrderAndOrderDetailResultMap() {\n\t        // Mapper 接口代理\n\t        SampleMapper sampleMapper = \n\t            sqlSession.getMapper(SampleMapper.class);\n            \n\t        List<Order> list = sampleMapper.findOrderAndOrderDetailResultMap();\n\t    }\n\t}\n\t```\n\n###### 多对多映射\n确立一需求：查询用户及用户购买的商品信息。\n\n在多对多映射中，具体的映射思路是：  \n1) 在 User 实体类中添加订单列表属性 `List<Order> orderList`，将用户创建的订单映射到 orderList。  \n2) 在 Order 实体类中添加订单明细列表属性 `List<OrderDetail> orderDetail`，将订单的明细映射到 orderDetail。  \n3) 在 OrderDetail 实体类中添加 `Item` 属性，将订单明细所对应的商品映射到 item。  \n\n- 实体类配置\n\n\t```java\n\tpublic class User implements Serializable {\n\t    private Integer uid;\n\t    private String username;\n\t    private Integer age;\n\t    private String phone;\n\t    \n\t    // 将用户创建的订单映射到 orderList\n\t    private List<Order> orderList;\n\t    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t\n\tpublic class Order implements Serializable {\n\t    private Integer order_id;\n\t    private Date createtime;\n\t    \n\t    // 将订单所对应的订单明细映射到 orderDetail 属性中\n\t    private List<OrderDetail> orderDetail;\n\t    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t\n\tpublic class OrderDetail implements Serializable {\n\t    private Integer orderdetail_id;\n\t    private Integer item_id;\n\t    private Integer order_id;\n\t    private Integer amount;\n\t    \n\t    private Item item;\n\t    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t\n\tpublic class Item implements Serializable {\n\t    private Integer item_id;\n\t    private String itemname;\n\t    private String itemprice;\n    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t```\n\n- 配置映射文件 Mapper.xml \n\n\t```xml\n\t<!-- 映射文件 Mapper.xml -->\n\t\n\t<!-- 查询用户及关联查询用户购买的商品信息的 resultMap  -->\n\t<resultMap \n\t    id=\"UserAndItemResultMap\" type=\"cn.kofes.ssm.pojo.User\">\n\t    \n\t    <!-- 配置用户信息 -->\n\t    <id column=\"uid\" property=\"uid\">\n\t    <result column=\"username\" property=\"username\" />\n\t    <result column=\"age\" property=\"age\" />\n\t    <result column=\"phone\" property=\"phone\" />\n\n\t    <!-- \n\t     | 配置映射的订单信息：使用 Collection 对关联查询的多条记录\n\t     | 映射到一个 List 集合属性中\n\t     | ofType：指定映射到集合属性中 POJO 的类型\n\t    -->\n\t    <collection property=\"orderList\" ofType=\"cn.kofe.ssm.pojo.Order\">\n\t    \n\t        <id column=\"order_id\" property=\"order_id\">\n\t        <result column=\"createtime\" property=\"createtime\" />\n\t        \n\t        <!-- 配置映射的订单明细信息：一个订单包含多个订单明细 -->\n\t        <collection property=\"orderDetail\" ofType=\"cn.kofe.ssm.pojo.OrderDetail\">\n\t        \n\t            <id column=\"orderdetail_id\" property=\"id\">\n\t            <result column=\"item_id\" property=\"username\" />\n\t            <result column=\"order_id\" property=\"username\" />\n\t            <result column=\"amount\" property=\"amount\" />\n\t            \n\t            <!-- 配置映射的商品信息：一个订单明细对应一个商品 -->\n\t            <association property=\"item\" javaType=\"cn.kofes.ssm.pojo.Item\">\n\t                <id column=\"item_id\" property=\"item_id\">\n\t                <result column=\"itemname\" property=\"itemname\" />\n\t                <result column=\"itemprice\" property=\"itemprice\" />\n\t            </association>\n\t            \n\t        </collection>\n\t        \n\t    </collection>\n\t    \n\t</resultMap>\n\t\n\t<!-- SQL：查询用户信息和用户购买过的商品信息 -->\n\t<select id=\"findUserAndItemResultMap\" resultMap=\"UserAndItemResultMap\">\n\t    SELECT \n\t        u.uid, u.username, \n\t        o.order_id,\n\t        od.item_id, od.amount\n\t        i.itemname, i.itemprice\n\t    FROM\n\t        Order AS o, User AS u, Item AS i, OrderDetail As od\n\t    WHERE\n\t        o.user_id = u.uid AND\n\t        od.order_id = o.order_id AND\n\t        od.item_id = i.item_id\n\t</select>\n\t```\n\t\n- Mapper 接口：\n\n\t```java\n\t// SampleMapper 接口\n\tpublic interface SampleMapper {\n\t    public List<User> findUserAndItemResultMap();\n\t}\n\n\t// 单元测试类\n\tpublic class SampleMapperTest {\n\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    private  SqlSession sqlSession;\n\n\t    @Before\n\t    public void setUp() throws IOException {\n\t        // 同上\n\t    }\n\n\t    @Test\n\t    public void testFindUserAndItemResultMap() {\n\t        // Mapper 接口代理\n\t        SampleMapper sampleMapper = \n\t            sqlSession.getMapper(SampleMapper.class);\n            \n\t        List<User> list = sampleMapper.findUserAndItemResultMap();\n\t    }\n\t}\n\t```\n\n###### 高级映射总结\n- 一对一映射：在 `Order` 实体对象中引入 `User` 属性，且在配置文件 Mapper.xml 中，通过 `<association>` 标签关联用户信息。\n- 一对多映射：在 `Order` 实体对象中添加订单明细列表属性 `List<OrderDetail> orderDetails`，且在配置文件 Mapper.xml 中，通过 `<collection>` 标签关联订单明细信息。\n- 多对多映射：\n\t- 在 User 实体对象中添加订单列表属性 `List<Order> orderList`，将用户创建的订单映射到 orderList。  \n\t- 在 Order 实体对象中添加订单明细列表属性 `List<OrderDetail> orderDetail`，将订单的明细映射到 orderDetail。  \n\t- 在 OrderDetail 实体对象中添加 `Item` 属性，将订单明细所对应的商品映射到 item。\n\n##### 延迟加载\n- 延迟加载，即需要时才发出 SQL 查询请求。Hibernate 中有延迟加载，MyBatis 同样提供了这个功能，具体以 `<resultMap>` 标签的属性完成配置。当然，我们可具体分析 MyBatis 的延迟加载。\n\n- MyBatis是默认开启延迟加载的么？如果不是，那么显然应该进行延迟加载配置。\n\n\t在 MyBatis 的全局核心配置文件 SqlMapConfig.xml 的 `<settings>` 标签中可设置 lazyLoadingEnabled 以及 aggressiveLazyLoading 属性值。\n\t\n\t- `lazyLoadingEnabled`：全局性设置懒加载，默认值为 flase，即所有相关联的都会被初始化加载。\n\n\t- `aggressiveLazyLoading`：默认值为 ture，懒加载的对象可能被任何懒属性全部加载。否者，每个属性按需加载。\n\n- 要实现延迟加载，就得进行 SQL 拆分 ( 若我们的SQL都写在一起，DB要么执行，要么不执行，根本做不到按需查询，所以要延迟加载就得拆分 SQL ) 那么怎么进行拆分呢？\n\n\t在 resultMap 中的 `<collection>` 以及 `<association>` 标签中有 `select` 属性，也就是说当使用到了 `<collection>` 或者 `<association>` 时才发出 `select` 属性对应的 SQL。\n\t\n\t```xml\n\t<!-- 映射文件 Mapper.xml -->\n\t\n\t<!-- 延迟加载的 resultMap -->\n\t<resultMap\n\t    id=\"OrderUserLazyLoadingResultMap\" type=\"cn.kofes.ssm.pojo.Order\">\n\t    <id column=\"order_id\" property=\"order_id\" />\n\t    <result column=\"createtime\" property=\"createtime\" />\n\n\t    <!-- 实现对用户信息进行延迟加载\n\t     | select 属性：指定延迟加载需要执行的 Statement 的 ID，\n\t     | 即根据 user_id 查询用户信息的 Statement\n\t     | column 属性：订单信息中关联查询用户信息得到的列，\n\t    -->\n\t    <association \n\t        property=\"user\" javaType=\"cn.kofes.ssh.pojo.User\"\n\t        select=\"findUserById\" column=\"user_id\" />\n\t    \n\t</resultMap>\n\t\n\t<!-- Step.01.查询订单管理查询用户信息，用户信息需要延迟加载 -->\n\t<select\n\t    id=\"finOrderUserLazyLoading\" resultMap=\"OrderUserLazyLoadingResultMap\">\n\t    SELECT * FROM Order\n\t</select>\n\t\n\t<!-- Step.02.关联查询用户信息：根据订单信息中的 user_id 去关联查询用户信息 -->\n\t<select\n\t    id=\"findUserById\" parameterType=\"int\" resultType=\"cn.kofes.ssm.pojo.User\">\n\t    SELECT * FROM User WHERE user_id = #{user_id}\n\t</select>\n\t\n\t<!-- \n\t | 执行顺序：即先执行 finOrderUserLazyLoading，\n\t | 当需要查询用户时在再执行 findUserById\n\t-->\n\t```\n\t\n- 我们其实可以借助 MyBatis 去完成延迟加载，也可以自己实现延迟加载。怎么做呢？即有需求时，我们自己调用相应的 Statement 完成即可。\n\n##### 查询缓存\n\n![图6-4MyBatis的一级缓存和二级缓存](/images/illustration/Project/2018/08/J2EE-SSM-1_6-4.png)\n<center>图 6-4 MyBatis 的一级缓存和二级缓存 $^{[3]}$</center>\n\n- MyBatis 提供一级缓存和二级缓存：\n\t- 一级缓存是 sqlSession 级别的缓存。在操作数据库时需要构造 sqlSession 对象，在对象中有一个数据结构 ( HashMap，KEY 主要就是 SqlSession + StatementId 构成 ) 用于存储缓存数据。不同的 sqlSession 之间的缓存数据区域是互不影响的；\n\t- 二级缓存是 Mapper 级别的缓存 ( `按 Namespace 划分` )。多个 sqlSession 去操作同一个 Mapper 的 SQL 语句，多个 sqlSession 去操作数据库得到数据的数据会存到二级缓存中。二级缓存区域是共享的。\n\n###### 一级缓存\n- 一级缓存的工作原理：\n\t- 如图 6-3 所示，当 sqlSession 发起 `查询` 操作，查询结果会 `写入` 到一级缓存中，待二次 `读取` 直接从一次缓存中读取即可；若 sqlSession 发起 `插入、更新、删除` 操作，则会 `清空` 一级缓存区域中的信息，以避免脏读。\n\t- 当 sqlSession 关闭时，sqlSession 缓存也随之失效。\n- MyBatis 是默认支持一级缓存的，无需配置开启。\n\n###### 二级缓存\n- 二级缓存是需要配置开启的：\n\t- 在全局配置文件 `SqlMapConfig.xml` 中指明，即在 `<setting>` 标签中的 `cacheEnabled` 属性，开启全局性缓存开关；\n\t- 其次在需要开启二级缓存的 `XXXMapper.xml` 中指明 `<cache>` 标签。\n\n\t```xml\n\t<mapper namespace=\"cn.kofes.mapper.SampleMapper\">\n\t    <!-- \n\t     | 开启本 Mapper namespace 下的二级缓存\n\t     | type 属性：指定 cache 接口的实现类的类型，默认使用 PerpetualCache\n\t     | \n\t    -->\n\t    <cache type=\"...\"/>\n\t    \n\t    <!-- 当然也可使用分布式缓存：Ehcache\n\t    <cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/>\n\t    -->\n\t</mapper>\n\t```\n\t\n- 所有 POJO 实现序列化接口：若开启二级缓存，其存储介质可在内存、磁盘等，即为了将缓存数据取出执行反序列化操作。\n\n\t```java\n\tpublic class User implements Serializable { /* 省略细节 */ }\n\tpublic class Order implements Serializable { /* 省略细节 */ }\n\t```\n\t\n- 二级缓存的局限性：\n\n\t例如，我们仅仅更新了其中一个信息，那么意味着二级缓存的清空。而我们真正想要的是刷新该商品的缓存信息而不要影响其他商品的缓存信息。\n\t\n##### 整合 ehcache\n- `ehcache` 是一个分布式缓存框架，当然还有 `redis`、`memached` 等。\n- 分布式缓存，系统为了提高系统并发、性能，一般对系统进行分布式部署 ( 集群部署方式 )。\n- 整合方法：MyBatis 提供的 Cache 接口，实现缓存逻辑即实现 Cache 接口即可。\n\t- 提供 ehcache 以及 ehcache 与 MyBatis 整合的依赖 ( 或者 Jar 包 )；\n\t- 在 `<cache>` 标签中，type 属性指明 ehcache 实现 Cache 接口的实现类，既有：  \n\t`<cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/>`；\n\t- 提供相关的 ehcache 配置文件.\n\n\t```java\n\t// MyBatis 提供的 Cache 接口\n\tpublic interface Cache {\n\t    String getId();\n\t    void putObject(Object var1, Object var2);\n\t    Object getObject(Object var1);\n\t    Object removeObject(Object var1);\n\t    void clear();\n\t    int getSize();\n\t    ReadWriteLock getReadWriteLock();\n\t}\n\t```\n\n##### 逆向工程\n- MyBatis 官方提供逆向工程，可针对单表自动生成 MyBatis 执行所需要的代码 ( mapper.java，mapper.xml，pojo 等 )。\n- 企业实际开发中，常用的逆向工程方式：由数据库表生成 Java 代码。\n- 添加依赖或添加 Jar 包：[MyBatis-Generator](http://mvnrepository.com/artifact/org.mybatis.generator/mybatßis-generator-core) ( Maven 中央仓库 )\n\n###### 运行逆向工程\n- 参考官方指南 [MyBatis Generator](http://www.mybatis.org/generator/running/running.html)，运行逆向工程有如下方式：\n\t- 使用命令提示符读取 XML 配置文件；\n\t- 使用 Maven 插件；\n\t- 使用 Java 程序读取 XML 配置文件 ( 推荐，即不依赖 IDE )；\n\t- 使用 IDE 插件 ( Eclipse )；\n\n###### 代码配置文件\n- MyBatis 官方提供了配置文档的范例：[MyBatis GeneratorXML Configuration File Reference](http://www.mybatis.org/generator/configreference/xmlconfig.html)\n\n\t当然，你可以参考下文 $^{[5]}$，搭配注释，互相补充：\n\t\n\t```xml\n\t<!-- generatorConfig.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<!DOCTYPE generatorConfiguration\n\t    PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n\t    \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n\t    \n\t<generatorConfiguration>\n\t    <context id=\"testTables\" targetRuntime=\"MyBatis3\">\n\t    \n\t        <commentGenerator>\n\t            <!-- 是否去除自动生成的注释：true / false -->\n\t            <property name=\"suppressAllComments\" value=\"true\" />\n\t        </commentGenerator>\n\t        \n\t        <!-- ( 必填 ) 数据库连接的信息：驱动类、连接地址、用户名、密码 -->\n\t        \n\t        <!-- 连接 MySQL 数据库 -->\n\t        <jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" \n\t            connectionURL=\"jdbc:mysql://127.0.0.1:3306/db_testdb?characterEncoding=utf-8\" \n\t            userId=\"root\" password=\"123456\">\n\t        </jdbcConnection>\n\t        \n\t        <!-- 连接 Oracle 数据库\n\t        <jdbcConnection driverClass=\"oracle.jdbc.OracleDriver\"\n\t            connectionURL=\"jdbc:oracle:thin:@127.0.0.1:1521:db_testdb\" \n\t            userId=\"kofe\" password=\"123456\">\n\t        </jdbcConnection>\n\t        -->\n\n\t        <!--\n\t         | false ( 默认 )，把 Jdbc Decimal 和 Numeric 类型解析为 Integer\n\t         | true，把 Jdbc Decimal 和 Numeric 类型解析为 java.math.BigDecimal\n\t        -->\n\t        <javaTypeResolver>\n\t            <property name=\"forceBigDecimals\" value=\"false\" />\n\t        </javaTypeResolver>\n\n\t        <!-- targetProject：生成 PO 类的位置 -->\n\t        <javaModelGenerator targetPackage=\"cn.kofes.ssm.pojo\"\n\t            targetProject=\".\\src\">\n\t            <!-- enableSubPackages 是否让 schema 作为包的后缀 -->\n\t            <property name=\"enableSubPackages\" value=\"false\" />\n\t            <!-- 从数据库返回的值被清理前后的空格 -->\n\t            <property name=\"trimStrings\" value=\"true\" />\n\t        </javaModelGenerator>\n\t            \n\t        <!-- targetProject:mapper 映射文件生成的位置 -->\n\t        <sqlMapGenerator targetPackage=\"cn.kofes.ssm.mapper\" \n\t            targetProject=\".\\src\">\n\t            <!-- enableSubPackages 是否让 schema 作为包的后缀 -->\n\t            <property name=\"enableSubPackages\" value=\"false\" />\n\t        </sqlMapGenerator>\n\t            \n\t        <!-- targetPackage:mapper 接口生成的位置 -->\n\t        <javaClientGenerator type=\"XMLMAPPER\"\n\t            targetPackage=\"cn.kofes.ssm.mapper\" \n\t            targetProject=\".\\src\">\n\t            <!-- enableSubPackages 是否让 schema 作为包的后缀 -->\n\t            <property name=\"enableSubPackages\" value=\"false\" />\n\t        </javaClientGenerator>\n\t            \n\t        <!-- 指定数据库表 -->\n\t        <table tableName=\"Item\"></table>\n\t        <table tableName=\"Order\"></table>\n\t        <table tableName=\"Orderdetail\"></table>\n\t        <table tableName=\"User\"></table>\n\t        \n\t        <!--\n\t        <table schema=\"\" tableName=\"sys_user\"></table>\n\t        <table schema=\"\" tableName=\"sys_role\"></table>\n\t        <table schema=\"\" tableName=\"sys_permission\"></table>\n\t        <table schema=\"\" tableName=\"sys_user_role\"></table>\n\t        <table schema=\"\" tableName=\"sys_role_permission\"></table>\n\t        -->\n\n\t        <!-- 有些表的字段需要指定 Java 类型\n\t        <table schema=\"\" tableName=\"\">\n\t            <columnOverride column=\"\" javaType=\"\" />\n\t        </table>\n\t        -->\n\t        \n\t    </context>\n\t</generatorConfiguration>\n\t```\n\n###### 执行逆向工程生成代码\n\n- 配置文件配置完成后，执行以下程序即可生成代码，细节如下：\n\n\t```java\n\tpublic class GeneratorSqlmap {\n\n\t    public void generator() throws Exception{\n\n\t        List<String> warnings = new ArrayList<String>();\n\t        boolean overwrite = true;\n\t        \n\t        //指定逆向工程配置文件\n\t        File configFile = new File(\"generatorConfig.xml\"); \n\t        \n\t        ConfigurationParser cp = new ConfigurationParser(warnings);\n\t        Configuration config = cp.parseConfiguration(configFile);\n\t        DefaultShellCallback callback = new DefaultShellCallback(overwrite);\n\t        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,\n\t            callback, warnings);\n\t        myBatisGenerator.generate(null);\n\t    } \n\t    \n\t    // 调用 generator() 执行逆向工程生成代码\n\t    public static void main(String[] args) throws Exception {\n\t        try {\n\t            GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap();\n\t            generatorSqlmap.generator();\n\t        } catch (Exception e) {\n\t            e.printStackTrace();\n\t        }\n\t    }\n\t    \n\t}\n\t```\n\n- 值得注意的是，除了生成基本的 POJO 类还多了一个类，就是 `xxxExample.java`。这个类是给用户自定义 SQL 使用的。到这里就生成好了，下面我们就把生成的代码 `拷贝` 到自己的工程即可。\n\n\n---\n\n#### Spring\n\n- Spring 框架是 Java 应用最广的框架，其成功源于它的理念，即 `控制反转` ( Inversion of Control，IoC ) 和 `面向切面编程` ( Aspect Oriented Programming，AOP )。\n- Spring 框架也可理解为一个轻量级的 IoC 和 AOP 的容器框架。\n- Spring 框架在 [SSH 部分](https://www.kofes.cn/2018/07/J2EE-SSH-SSI-1.html#Spring) 有阐述，在本章节就不具体展开探讨，笔记以补充和整合部分内容为主。\n\n\t> 在 SSH Spring 章节中，要求导入相关 Jar 包，而本文的 SSM 框架要求导入的 Jar 包 ( 或者 Maven 依赖 ) 以 `版本信息` 的为标准。\n\n##### Spring 整合 MyBatis \nSpring 整合 MyBatis 是通过 `MyBatis-Spring` 的类库实现的，具体配置和使用信息可参考 [MyBatis-Spring 官方使用文档](http://www.mybatis.org/spring/zh/index.html) $^{[4]}$。\n\n###### 原始 DAO 开发\n首先要向 DAO 的实现类中注入 SqlSessionFactory ( 交由 Spring 管理，即 Spring 声明式注入 SqlSessionFactory )，然后在各个方法中得到 SqlSession 进行数据库操作。\n\n> `诉求`：在 Spring 运作中，首先加载 Spring 核心配置文件，再创建对象 ( SqlSessionFactory )。而创建对象可通过 New 的方式创建 ( [原始方法](#MyBatis-原始方法) )，但效率太低，则我们可以把加载配置文件和创建对象过程，在服务器启动时完成。故引入 Spring 声明式注入 SqlSessionFactory。\n\n- 使用封装的方法，即让 Dao 的实现类继承 `SqlSessionDaoSupport`，而 SqlSessionDaoSupport 类中已经存在 `setSqlSessionFactory()` 方法，因此我们可以直接向 Dao 的实现类注入 SqlSessionFactory。\n- 另外 SqlSessionDaoSupport 中有 SqlSession，因此使得操作更加简单；而且都交给 Spring 管理，我们自然不必担心忘记关闭 SqlSession。\n\t\n\t```java\n\t// 下述实现是通过 XML 配置方式加载配置和 Bean ( 注解方式也是可行的，但写法有区别 )\n\t\n\t// Dao 接口\n\tpublic interface BaseDao {\n\t    public List<Sample> findSampleById(int id);\n\t}\n\t\n\t// Dao 层实现类\n\tpublic class SampleDaoImpl extends SqlSessionDaoSupport implements BaseDao {\n\t\n\t    private SqlSession sqlSession;\n\t    \n\t    public SampleDaoImpl() throws Expection {\n\t        sqlSession = this.getSqlSession();\n\t    }\n\t\n\t    public Sample findSampleById(int id) throws Exception {\n\t        return sqlSession.selectOne(\n\t            \"cn.kofes.ssm.mapper.SampleMapper.findSampleById\", id);\n\t    }\n\t}\n\t\n\t// 单元测试类\n\tpublic class SampleDaoTest {\n\t\n\t    private BaseDao baseDao;\n\t    \n\t    @Before\n\t    public void setUp() {\n\t        applicationContext = \n\t            new ClassPathXmlApplicationContext(\"classpath:spring.xml\");\n\t        baseDao = (BaseDao) applicationContext.getBean(\"baseDao\");\n\t    }\n\n\t    @Test\n\t    public void testFindCertainById() {\n\t        System.out.println( baseDao.findSampleById(15).toString() );\n\t    }\n\t}\n\t```\n\n###### Mapper 代理开发\n\n- Mapper 代理开发的具体思路：\n\t- SqlSessionFactory 交给 Spring 管理 ( 单例模式 )。\n\n\t注意到 SqlSessionFactory 的创建显然需要数据库连接相关的信息，因此需要 `数据库连接池 (c3p0)`；除此之外还需要 MyBatis 的主配置文件 `SqlMapConfig.xml`。\n\t\n\t- Spring 和 MyBatis 整合生成代理对象，使用 SqlSessionFactory 创建 SqlSession ( Spring 和 MyBatis 整合后自动完成此过程 )。\n\n\t- 若采用 Mapper 代理的方式开发，我们需要 Spring 管理 Mapper 动态代理实现。\n\n- 在 Spring 配置文件下配置数据库信息，并整合 MyBatis。后者将 SessionFacotry 交由 Spring 管理：\n\n\t> c3p0.properties 配置文件位于 Src 根目录下，键值分离以便修改配置。\n\n\t```xml\n\t<!-- spring.xml -->\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xsi:schemaLocation=\"\n\t    http://www.springframework.org/schema/beans \n\t    http://www.springframework.org/schema/beans/spring-beans.xsd \n\t    http://www.springframework.org/schema/context \n\t    http://www.springframework.org/schema/context/spring-context.xsd\">\n\n\t    <!-- 扫描包下注解，并注册为 Bean -->\n\t    <context:component-scan base-package=\"cn.kofes.ssm\">\n\t        <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\">\n\t        </context:exclude-filter>\n\t    </context:component-scan>\n           \n\t    <!-- 在根目录下新建文件 c3p0.properties，存储数据连接信息 -->\n\t    <context:property-placeholder location=\"classpath:c3p0.properties\" />\n\n\t    <!-- Dao 层的配置，即 Mybatis 的配置 ( 分模块开发思想 ) -->\n\t    <import resource=\"spring/mybatis-spring.xml\"/>\n\t</beans>\n\t\n\t<!-- mybatis-spring.xml -->\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xsi:schemaLocation=\"\n\t    http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\t    \n\t    <!-- 1. 数据源 : DriverManagerDataSource -->\n\t    <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" destroy-method=\"close\">\n\t        <!-- 引用 c3p0.properties 的键值对即可，格式如 ${key.value} -->\n\t        <property name=\"driverClass\" value=\"${datasource.driverClass}\"/>\n\t        <property name=\"jdbcUrl\" value=\"${datasource.jdbcUrl}\"/>\n\t        <property name=\"user\" value=\"${datasource.user}\"/>\n\t        <property name=\"password\" value=\"${datasource.password}\"/>\n\t        <!-- 设置数据库连接池的最大连接数 -->\n\t        <property name=\"maxPoolSize\" value=\"${datasource.maxPoolSize}\"/>\n\t        <!-- 设置数据库连接池的最小连接数 -->\n\t        <property name=\"minPoolSize\" value=\"${datasource.minPoolSize}\"/>\n\t        <!-- 设置数据库连接池的初始化连接数 -->\n\t        <property name=\"initialPoolSize\" value=\"${datasource.initialPoolSize}\"/>\n\t        <!-- 设置数据库连接池的连接最大空闲时间 -->\n\t        <property name=\"maxIdleTime\" value=\"${datasource.maxIdleTime}\"/>\n\t        <!-- c3p0缓存Statement的数量数 -->\n\t        <property name=\"maxStatements\" value=\"${datasource.maxStatements}\"/>\n\t        <!-- 当连接池的连接用完的，从 C3p0 下获取新的连接数 -->\n\t        <property name=\"acquireIncrement\" value=\"${datasource.acquireIncrement}\"/>\n\t        <property name=\"checkoutTimeout\" value=\"${datasource.checkoutTimeout}\"/>\n\t        <property name=\"idleConnectionTestPeriod\" value=\"${datasource.idleConnectionTestPeriod}\"/>\n\t    </bean>\n\n\t    <!-- 2. 配置和 MyBatis 的整合 -->\n\t    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n\t        <property name=\"dataSource\" ref=\"dataSource\"/>\n\t    </bean>\n\n\t    <!-- 3. 配置一个可以执行批量的 SqlSession -->\n\t    <bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n\t        <constructor-arg name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/>\n\t        <constructor-arg name=\"executorType\" value=\"BATCH\"/>\n\t    </bean>\n\n\t    <!--\n\t     | 4. MyBatis 自动扫描加载 Sql 映射文件: MapperScannerConfigurer\n\t     | 自动扫描出的 Mapper Bean 的 ID 名称为首字母小写的类名\n\t     | 且效果与 SqlMapConfig.xml 中配置批量加载映射文件相同，即 <package name=\"cn.kofes.ssm.mapper\"/>\n\t     | 1) 批量加载映射文件：mapper.java 与 mapper.xml 同名，且在同一目录下\n\t     | 2) 当然，你可以建立同样的文件夹目录 (cn/kofes/ssm/mapper)，把 mapper.xml 单独放置资源目录下\n     -->\n\t    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n\t        <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\" />\n\t        <property name=\"basePackage\" value=\"cn.kofes.ssm.mapper\" />\n\t    </bean>\n\n\t</beans>\n\t```\n\n- 代码实现：注解方式实现 Mapper 类的调用：\n\n\t```java\n\t// 下述实现是通过注解方式加载配置和 Bean ( XML 方式也是可行的，但写法有区别 )\n\t\n\t// Mapper 接口\n\tpublic interface SampleMapper {\n\t    public Sample findCertainTupleById(Integer id);\n\t}\n\t\n\t// 单元测试类\n\t@RunWith(SpringJUnit4ClassRunner.class)\n\t@ContextConfiguration(locations = {\"classpath:spring.xml\"})\n\tpublic class SampleMapperTest {\n\t\n\t    @Autowired\n\t    private SampleMapper sampleMapper;\n\n\t    @Test\n\t    public void testFindCertainTupleById() {\n\t        System.out.println( \n\t            sampleMapper.findCertainTupleById(15).toString() );\n\t    }\n\t}\n\t```\n\n---\n\n#### Spring MVC\n\n- MVC ( Model-View-Controller ) 模式把应用程序 ( 输入逻辑、业务逻辑和 UI 逻辑 ）分成不同的方面，同时提供这些元素间的松耦合。\n\t- Model：模型，封装了应用程序的 `数据` 和由它们组成的 `POJO`。\n\t- View：视图，负责把模型数据 `渲染到视图` 上，将数据以一定形式展现给用户。\n\t- Controller：负责 `处理用户请求`，并建立适当的模型把它传递给视图渲染。\n- Spring MVC 把 `模型`、`视图` 和 `控制器` 分层，组合成一个有机灵活的系统。\n- Spring MVC 中可定义逻辑视图，通过其提供的解析器找到对应的视图渲染；或在 Controller 的方法内加入注解 ( `@ResponseBody` )，通过消息转换系统将数据转换为 JSON，提供给前端 Ajax 请求使用。\n\n\n## 参考资料\n\n- \\[1\\] [ 杨开振. Java EE 互联网轻量级框架整合开发 [M]. 电子工业出版社. 2017](https://book.douban.com/subject/27090950/)\n- \\[2\\] [张丰哲. MyBatis + Spring MVC 开发指南 (一). 简书. 2017](https://www.jianshu.com/p/91a32e3d4b26)\n- \\[3\\] [张丰哲. MyBatis + Spring MVC 开发指南 (二). 简书. 2017](https://www.jianshu.com/p/48b78ee24fa3)\n- \\[4\\] [MyBatis. MyBatis-Spring 官方使用文档. mybatis.org](http://www.mybatis.org/spring/zh/index.html)\n- \\[5\\] [李阿昀. MyBatis 逆向工程自动生成代码. csdn.net. 2017](https://blog.csdn.net/yerenyuan_pku/article/details/71909325)\n\n","tags":["Spring MVC"],"categories":["Project"]},{"title":"极客探索 |  MacOS VMware 安装 OpenWrt ( 从软路由到硬路由的过渡 )","url":"/2018/07/Vmware-OpenWrt.html","content":"\n配置一台 VMware 上运作的路由系统，启发式从软路由到硬路由的进阶之旅。\n\n<!-- More -->\n\n## 更新进度\n- 2018.07.25：完成初稿；\n- 2018.07.26：安装 OpenWrt 系统，配置 MySQL、FTP 插件，并形成文档；\n- 2018.07.27：购置路由开发板，了解系统版本支持信息；\n- 2018.07.29：鉴于之前的理解有偏差，修正固件系统章节的内容；\n\n## 固件系统\n\n### OpenWrt\n\n#### 支持文档\n\n- [官方使用指南 (英文)](https://openwrt.org/) | [官方使用指南 (中文)](https://openwrt.org/zh/start)\n- [硬件支持表格](https://openwrt.org/toh/views/toh_fwdownload)：查阅硬件支持表格，若您的硬件已被支持，可参考官方的 OpenWrt [安装教程](https://openwrt.org/docs/guide-quick-start/begin_here)，开始安装。 \n\n\t> 在表格顶部的白色区域可以输入筛选标准进行条件筛选。若找到目标型号后， `Firmware OpenWrt Install URL` 列中存放的是固件的最新版本下载地址。\n\n- [常见问题解答](https://openwrt.org/faq/start)：包含常见问题，安装前、安装后问题，无线网络问题等。\n\n#### 固件版本\n\n固件版本：每种型号的路由一般会提供多种版本的固件 $^{[8]}$。\n\n- `XXX-factory` / `XXX-kernel`：对应于内核的固件，必须把它刷入一个OEM (原厂) 固件。\n- `XXX-jffs2` / `XXX-squashfs`：对应于文件系统的固件。这两种不同格式的固件区别在于 $^{[9]}$：\n\t- `Squashfs`：安装后占用一定空间来存放系统的一些必要文件，这些文件都只是可读的，其作用是帮助恢复系统；\n\t- `Jffs2`：而 Jffs2 则不会存储这些文件，好处在于节省了空间。一般推荐使用 Squashfs 格式的固件，以方便恢复系统到初始状态。\n- `XXX-sysupgrade`：对应于完整的固件，用于固件升级，要求您的设备必须已安装较旧的 LEDE 或 OpenWrt 固件。\n\n> 固件的后缀名也有很多种，例如 `xxx.img`、`xxx.bin`、`xxx.trx` 等，虽然整体内容是相同的，但它们的文件头的信息是有差异的 $^{[10]}$。\n\t\n#### 烧写方式\n烧写方式：根据不同的路由硬件环境，选择不同的方式将固件烧写进路由。\n\n- OEM (原厂) 管理界面：完整安装 OpenWrt / LEDE / Padavan 设备。\n- [LUCI ( Web 管理界面 )](https://openwrt.org/docs/guide-quick-start/sysupgrade.luci)：升级现有的 OpenWrt / LEDE 设备。(Pavadan 有自己的 Web 管理界面)\n- Bootloader 引导加载器：路由系统里常见有 Breed、U-Boot。即开机初始化时加载的最小系统，用于识别基础硬件和设置环境信息，以引导方式烧写固件 ( 集成 HTTP、TFTP 协议 )。\n\n### Padavan\n\n#### 支持文档\n\n- Padavan：[荒野无灯.Padavan](http://p4davan.80x86.io/) | [Bitbucket.Padavan](https://bitbucket.org/padavan/rt-n56u/overview)\n\n## 软路由篇\n\n了解了相关路由系统的事宜后，找准定位，你是配置用来开发 ( 推荐 OpenWrt ) 的，还是家用 ( 推荐 Pavadan ) 等，即选择一款迎合需求的路由开始你的 “改造旅程”。\n\n软路篇即以 VMware 为例展开实践，而本文主要是记录实践过程中的基本过程和要点。\n\n### 固件信息\n\n- 系统版本：[OpenWrt-15.05.1-x86](http://archive.openwrt.org/chaos_calmer/15.05.1/x86/)\n\n\t> 虚拟机上运行的，我们选择 x86 架构的即可 ( x64 架构也是可以的 )。\n    \n- 固件版本：[openwrt-15.05.1-x86-generic-combined-squashfs](http://archive.openwrt.org/chaos_calmer/15.05.1/x86/generic/openwrt-15.05.1-x86-generic-combined-squashfs.img)\n\n### 安装过程\n\n此章节是基于 MacOS 的 VMware 展开实践的，WIndows 版本可自行百度、谷歌，或者参考下述文章 $^{[1,2]}$。\n\n当然，OpenWrt 安装步骤可参考引用文章 $^{[1,2,7]}$，这里不详细阐述，仅对核心的配置部分进行说明。 \n\n- 本机 VMware 得配置两张虚拟网卡，暂且命名为：\n\t- 网络适配器 1 (MAC 地址)：`00:50:56:28:EF`\n\t- 网络适配器 2 (MAC 地址)：`00:50:56:3B:0E:CD`\n\n\t\t> MAC 地址可让我们判断 OpenWrt 中外网接口 `WAN` 和内网接口 `LAN` 口的映射情况。\n\n- 在 OpenWrt 默认配置中，外网接口 WAN 对应于 Eth1，内网接口 LAN 对应于 Eth0，即：\n\t- 外网接口 WAN：`Eth1`\n\t- 内网接口 LAN：`Eth0`\n   \n\t```shell\n\t# 如何查看虚拟主机的网卡与外网、内外接口的关系：\n    \n\t# OpenWrt 下执行下述代码：\n\t# 查看网卡的具体信息，即可以查到虚拟机网卡 MAC 地址\n\tifconfig | more\n\t# 查看网络配置信息，即可查看外网、内外接口 (Ethx) 与虚拟主机的网卡的绑定情况\n\tcat /etc/config/network\n\t```\n\n- 在 OpenWrt 中，配置外网、内外接口 (Ethx) 信息：\n\n\t> 提示：使用 WAN 口的网卡桥接到宿主机的网卡即可访问外网。\n\t\n\t```shell\n\t# 环路地址，不用配置\n\tconfig interface 'loopback'\n\t   option ifname 'lo'\n\t\toption ipaddr '127.0.0.1'\n\t\toption netmask '255.255.255.0'\n\t\n\t# 内网接口\n\tconfig interface 'lan'\n\t\toption ifname 'eth0'\n\t\toption type 'bridge'\n\t\toption proto 'static'\n\t\toption ipaddr '192.168.1.1'\n\t\toption netmask '255.255.255.0'\n\t\toption ip6assign '60'\n\t   \n\t# 外网接口\n\tconfig interface 'wan'\n\t\toption ifname 'eth1'\n\t\toption proto 'dhcp'\n\t   \n\t# 其他配置默认，不作修改\n\t```\n\t\n> 关于配置中的一些批注：\n    \n- Note.01：配置完成后，记得重启下网络服务 `./etc/init.d/network restart` 。\n- Note.02：若需要让宿主机访问本 OpenWrt 系统，你可以配置 (关闭) 防火墙。\n    \n\t```Shell\n\t# 让防火墙开机不自启\n\t./etc/init.d/firewall disable\n\t# 关闭防火墙服务\n\t./etc/init.d/firewall stop\n\t```\n\t\n- 本机 OpenWrt 信息：\n\t- 本机地址：`192.168.0.100`\n\t- 路由地址：`192.168.0.x (192.168.0.161)` -- 与宿主机在同一局域网就对了。\n\t- 路由管理用户：`root`\n\t- 路由管理密码：`123321`\n\n## 硬路由篇\n\n选择一款合适的路由器很重要。这里瞎折腾太久，很多产品不太满意 ( 价格贵 )，最后选择了定制的产品。路由开发板：基于 Newifi D1 板件定制 ( 芯片：MT7621A / 闪存：32M / 内存：256MB )。\n\n当然，你对路由器刷固件，固件版本一定要配对你的设备，具体细节请查阅：[设备支持信息表单](https://openwrt.org/toh/views/toh_fwdownload)\n\n> 值得注意的是，你需要对下载的固件文件进行 [MD5/SHA256 验证](https://openwrt.org/docs/guide-quick-start/verify_firmware_checksum)，以防止文件破损或其他原因，使得你的路由器 `变砖` ！\n\n### 固件信息\n- OpenWrt\n\t- 系统版本：[LEDE 17.01.5 Ramips MT7621](http://downloads.openwrt.org/releases/17.01.5/targets/ramips/mt7621/)\n\t- 固件版本：基于 Breed / Uboot 刷完整固件：[newifi-d1-initramfs-kernel.bin](http://downloads.openwrt.org/releases/17.01.5/targets/ramips/mt7621/lede-17.01.5-ramips-mt7621-newifi-d1-initramfs-kernel.bin)\n- Padavan\n\t- 固件版本：[荒野无灯.Padavan.NEWIFI-D1](http://p4davan.80x86.io/download/)\n\n### 安装过程\n\n此章节是基于 `Newifi D1 (MT7621A)`  板件定制的路由开发板展开实践的，采用 Breed 形式引导刷固件。\n\n## 拓展功能\n\n- 关于插件的批注：\n\t- 默认情况，插件会安装在：`/etc/init.d/` 目录下；\n\t- 其相应的配置文件放置在： `/etc/config/` 目录下。\n\n\t```shell\n\tetc\n\t├── config\t# 配置目录\n\t└── init.d\t# 插件目录\n\t└── xxx.cnf\t# 有些插件的配置文件在根目录下\n\t```\n\n### 安装 FTP 服务\n\n- 快速引导：[官方指南](https://wiki.openwrt.org/doc/howto/ftp.overview)\n\t- 可通过 Web 交互界面安装或者命令行安装 `VSFTPD`。\n\t- 安装完成后，即可使用；`ftp://Your route IP adress`。\n\t- 配置文件位于 `/etc/vsftpd.conf`，配置可参考：\n\n\t\t```Shell\n\t\tchown_uploads=YES       # 上传后更改文件所属权\n\t\tchown_username=root     # 上传后更改文件所属权\n\t\tftp_username=nobody     # 定义匿名用户名\n\t\tanonymous_enable=YES            # 允许匿名用户访问\n\t\tanon_upload_enable=YES          # 允许匿名上传\n\t\tanon_mkdir_write_enable=YES     # 允许匿名创建目录\n\t\tanon_root=/mnt/anymous          # 匿名用户根目录\n\t\tanon_max_rate=512000            # 匿名用户限速\n\t\tlocal_enable=YES    # 允许本地用户登录 (必须)\n\t\tlocal_root=/mnt/ftp # 本地用户的默认访问路径 (必须)\n\t\twrite_enable=YES    # 允许上传\n\t\tlocal_umask=022     # 允许上传\n\t\tcheck_shell=NO\n\t\t```\n\t\t\n- 命令操作细节如下：\n\n\t```shell\n\t# 第一次使用 opkg 需更新资源\n\topkg update\n\topkg install vsftpd\n\n\t# FTP 服务操作\n\t/etc/init.d/vsftpd start        # Start the service\n\t/etc/init.d/vsftpd stop         # Stop the service\n\t/etc/init.d/vsftpd restart      # Restart the service\n\t/etc/init.d/vsftpd reload       # Reload configuration files or restart if that fails\n\t/etc/init.d/vsftpd enable       # Enable service autostart)\n\t/etc/init.d/vsftpd disable      # Disable service autostart)\n    \n\t# 附：修改文件权限\n\tchown root /mnt/ftp\n\tchmod 666 /mnt/ftp\n\t```\n    \n- 当然，除了 FTP 服务外，还有 Samba 服务，具体配置可参考 [4] 。\n\n### 安装 Samba 服务\n\n### 安装 Shadowsocks\n\n> 科学上网 (FQ)，践行社会主义核心价值观。\n\n### 安装 MySQL\n\n- 通过命令行安装：\n\n\t```shell\n\t# 第一次使用 opkg 需更新资源\n\topkg update\n\topkg install mysql-server\n\t```\n\t\n- 设置数据库数据存储目录：\n\n\t```shell\n\t# 配置 Mysql 数据库的存储目录\n\tcd /mnt\n\tmkdir -p /mysql/data /mysql/tmp\t\n\t\t\n\t# 当然也可把数据放到 U 盘或 SD 卡上\n\t# 详细教程可查看 USB 挂载相关教程，参考 [6]\n\t```\n\t\n- 配置 MySql：\n\n\t```shell\n\tvi /etc/my.cnf\n\t# 找到 datadir 和 tmpdir 字段，并修改其值\n\tdatadir = /mnt/mysql/data\n\ttmpdir = /mnt/mysql/tmp\n\t\n\t# 给文件夹赋予权限\n\tchmod 750 -R mysql/data mysql/tmp\n\t\t\n\t# 找到 bind-address，修改为 0.0.0.0，以允许远程访问\n\tbind-address = 0.0.0.0\n\t\t\n\t#  记得保存再退出\n\t\t\n\t# 初始化建库 ( Database )\n\t/usr/bin/mysql_install_db --force\n\t```\n\t\t\n- 启动 MySQL 数据库：\n\t\n\t```shell\n\t# 启动 mysql 守护进程\n\t/etc/init.d/mysqld enable\t\t# 开启自启动\n\t/etc/init.d/mysqld start\t\t# 启动 MySQL 服务\n\t\t\n\t# 当重新修改配置时，需要重启 Mysql 服务，可这样处理\n\t# killall mysqld\n\t# /etc/init.d/mysqld start\n\t# 或者重新加载配置信息\n\t# /etc/init.d/mysqld reload\n\t```\n\t\t\n- 使用 MySQL 数据库和修改账户密码：\n\n\t```shell\n\t# 提示输入密码，进入即可数据库操作\n\tmysql -u root -p\n\t\t\n\t# 当然，刚配置的 MySQL 用户名账号密码不是还没有配置么？\n\t# 故我们需要以非授权的方式进入 MySQL 进行权限设置\n\t/etc/init.d/mysqld --skip-grant &\n\tmysql -u root\n\t\t\n\t# 注意：命名行里面的形式已经变成【mysql>】提示符，即可继续下步操作\n\t\t\n\t# 显示数据库，选择 mysql 数据库\n\tSHOW databases;\t\t\n\tUSE mysql;\n\t\t\n\t# 修改账户连接权限：\n\tUPDATE user \n\tSET host = '%', password = PASSWORD(\"Your Password\")\n\tWHERE user = 'root';\n\n\t# (非必要操作) 当你的数据库需要远程访问时，你还需要建立一个新用户\n\t# grant all privileges on *.* to  kofe@\"%\"\n\t# identified by \"pwd123\"\n\t# with grant option;\n\t\t\n\t# Grant 是授权命令\n\t# 其中 kofe 是我们连接用的用户名、pwd123 是连接密码\n\t# @ 后接的 “%” 通用符表示允许各 host 操作\n\t\t\n\t# 清理数据库缓存\n\tflush privileges;\n\t\t\n\t# 退出 mysql\n\tquit;\n\t\t\n\t# 重启 Mysql 服务\n\t/etc/init.d/mysqld restart\n\t\t\n\t# 此时重新执行 mysql -u root -p\n\t# 输入你修改过后的密码能进入 【mysql>】模式即成功。\n\t```\n\n- MySQL 数据库管理软件推荐： [Sequel Pro](http://www.sequelpro.com/) 或者 [Dbeaver](https://dbeaver.io/download/)。\n\t\n\n### 安装 Python\n\n## 参考资料\n\n- \\[1\\] [Code Insight. HowTo 虚拟机上尝试 OpenWrt 开源路由. cnblogs.com](https://www.cnblogs.com/codeinsight/p/openwrt_vmware.html)\n- \\[2\\] [luoqeng. OpenWrt-on-VMware. github.com](https://github.com/luoqeng/OpenWrt-on-VMware)\n- \\[3\\] [whatday. 路由、交换机等嵌入设备软件包管理 OPKG. csdn.net](https://blog.csdn.net/whatday/article/details/78920494)\n- \\[4\\] [Double WIn. Samba 服务 & vsFTP 服务. cnblogs.com](http://www.cnblogs.com/double-win/p/3848797.html)\n- \\[5\\] [Double Win. MySQL配置. cnblogs.com](http://www.cnblogs.com/double-win/p/3866189.html)\n- \\[6\\] [Double Win. USB挂载 & U盘启动. cnblogs.com](http://www.cnblogs.com/double-win/p/3841801.html)\n- \\[7\\] [Double Win. Openwrt 项目开发笔记. cnblogs.com](http://www.cnblogs.com/double-win/p/3888399.html)\n- \\[8\\] [OpenWrt. Howtos 下载固件中文说册. openwrt.org](https://openwrt.org/zh-cn/doc/howto/obtain.firmware.download)\n- \\[9\\] [Keep Silence. TP-LINK WR703N 刷 OpenWrt 及配置、安装插件. csdn.net](https://blog.csdn.net/qinpeng_zbdx/article/details/8570488)\n- \\[10\\] [OpenWrt. TRX vs. TRX2 vs. BIN. openwrt.org](https://openwrt.org/start?id=docs/techref/header)","tags":["路由器"],"categories":["Technique"]},{"title":"框架 | Java EE 之 SSH 框架配置与使用","url":"/2018/07/J2EE-SSH-SSI-1.html","content":"\n## 序言\n本文章主要围绕 J2EE 中 SSH ( Spring、Struts、Hibernate ) 框架的配置以及使用问题展开学习的，最终目的是输出可复用的版本，以供后续的项目复用。当然，学习和配置的过程难免有不恰当或错误之处，还望朋友指出、斧正。\n\n\n## 教学资源\n- 视频 | [黑马程序员. J2EE 进阶. 4 天精通 Hibernate 框架. 2017. bilibili.com](https://www.bilibili.com/video/av14626440)\n- 视频 | [黑马程序员. J2EE 进阶. 60 集精通 Spring 框架. 2017. bilibili.com](https://www.bilibili.com/video/av14839030)\n- 视频 | [黑马程序员. J2EE 进阶. Struts2 框架精品教程. 2017. bilibili.com](https://www.bilibili.com/video/av13748042)\n\n\t> 本框架的学习笔记是基于此系列教学视频所得的。\n\n<!-- More -->\n\n## 更新进度\n- 2018.07.17：完成初稿，IDE 搭建、框架初识章节；\n- 2018.07.20：更新 SSH 框架 Hibernate 的内容；\n- 2018.07.31：更新 SSH 框架 Spring 的内容；\n- 2018.08.03：整合 SSH 框架 ( 输出基本框架 )；\n- 2018.08.08：补充 SSH 框架 Struts 部分的内容；\n- 2018.08.15：重新整理 SSH 框架项目，见版本信息；\n\n\n## IDE 搭建\n- Step.01：安装 JDK；\n- Step.02：安装 IDE ( `IntelliJ Idea` / Eclipse / MyEclipse )；\n- Step.03：配置 Tomcat 环境；\n\t- 让 Tomcat 可同时运行多个 Module，即在菜单栏 `Run > Run Configurations > Deployment > Application context` 下配置目录访问路径即可 ( 一般规范填写项目名 )。\n\n\t![Tomcat 9.0.x Deployment](/images/illustration/Project/2018/08/J2EE-SSH-SSI-1_4-1.jpg)\n<center>图 4-1 Tomcat 9.0.x Deployment</center>\n\t\n\t- 紧接着，在菜单栏 `File > Project Structure > Artifacts` 下配置，把对应的 module 的 Available Elements `Put into Output Root` 到 `xxx:war_exploded` 下。\n\t\n\t![Project Structure Artifacts](/images/illustration/Project/2018/08/J2EE-SSH-SSI-1_4-2.jpg)\n<center>图 4-2 Project Structure Artifacts</center>\n\t\n- Step.04：配置 MySQL / SQL Server 数据库；\n\t- 命名规范：数据库 `db_dbname`；数据表 `t_tablename`；属性 `attribute`\n\t- 访问外网：若在虚拟机或者本机测试，让数据库允许外网访问，注意得关闭防火墙或添加规则允许某端口的访问权限。\n\n\t\t> Case.01：本机和服务器端互相 `Ping` 对方 IP，以检验网络是否畅通、是否拒绝访问。  \n\t\t> Case.02：若网络畅通、没有拒绝访问，还要留意对应端口是否有权限访问，通过 `nc -vz IP 端口`  检验，返回 `Succeeded` 即成功。  \n    \n\t- 数据库权限：若 MySQL 通过命令安装，需特别注意的权限问题，即账号和密码是默认配置的，用户可自行修改，具体修改细节见参考 [6] - [8] 中的方法 ( 可能实操过程中还会遇到其他问题，推荐翻阅下参考文章，也许对你有帮助 )。\n\n\t\t> 若有需求远程连接数据库，我们需要创建一个新用户，并赋予访问权限 (当然，你可让你的 root 账户也赋予远程连接数据库的权限)。具体地：  \n\t\t> `grant all privileges on *.* to  kofe@\"%\" identified by \"123321\" with grant option;`. \n\t\t> 授权完成后，刷新下账户权限即可：`flush privileges;`。  \n    \n- Step.05：以 IntelliJ Idea IDE 为参考搭建框架，参考 [1] - [3] 中的方法；\n\t- [1] 中 `全注解方式的 SSH 基础框架` 的框架整合的思想不错，推荐在你搭建框架时参详。\n\t- [2] - [3] 的搭建方法都是 `导 Jar 包形式`，但千万要注意相对应的 Jar 包是否已经下载到本地。\n\t- 当然，推荐 `Maven` 管理项目，即它是添加依赖库的方式配置环境的，下述的内容也是基于 Maven 构建框架。\n\n## 版本信息\n- **基于以下版本，打包的 SSH 框架 ( Maven )**：[SSHFrameComposition.2018.08.15](https://pan.baidu.com/s/11czZlhOzSLNX7gB16t1AtQ)\n\n\t> 这是基于 Maven 构建的 SSH 框架项目，若有错误的地方还望指正。\n\n-  框架版本：\n\t- Struts：2.5.16\n\t- Spring：4.3.x\n\t- Hibernate：5.2.x\n- 其他组件：\n\t- MySQL：5.7.x / SQL Server：2008 R2\n\t- Tomcat：9.0.x\n\t- Maven：3.3.9\n\t- JDK：1.8\n- 构建框架，还需要相关依赖库 ( Jar 包 )，详细请参阅 [ioC 入门案例](#ioC-入门案例)。\n\n\t> 为便于你下载 Jar 包或校对依赖是否齐全，具体地，以下列举了 SSH 框架所需要的依赖库。\n\n| Spring | Struts2 | Hibernate |\n| :---- | :---- | :---- | \n| spring-core | asm | antlr | \n| spring-beans | asm-commons | stax2-api |\n| spring-context | asm-tree | geronimo-jta\\_1.1\\_spec |\n| spring-expression | commons-fileupload | hibernate-commons-annotation |\n| spring-web ( 整合 Web ) | commons-io | hibernate-core |\n| spring-aop ( 整合 Aop ) | commons-lang3 | hibernate-jpa |\n| aopalliance ( 整合 Aop ) | freemarker | jandex |\n| spring-aspect ( 整合 Aop ) | javassist | javassist |\n| aspectjweaver ( 整合 Aop ) | log4j-api | jboss-logging |\n| spring-orm | log4j-core | &nbsp; |\n| spring-tx ( 整合事务 ) | ognl | &nbsp; |\n| spring-jdbc ( 整合 Hibernate ) | struts-core | &nbsp; |\n| c3p0 ( 数据库连接池 ) | &nbsp; | &nbsp; |\n\n|  其他依赖库 ( Jar 包 ) | 备注 |\n| :---- | :---- |\n| junit | Junit 单元测试 |\n| mysql-connector-java | 添加 MySQL 数据库支持 |\n| struts2-spring-plugin | Struts 整合 Spring 插件 |\n| struts2-junit-plugin | 便于浏览项目中所有 action 及其与 Jsp View 的映射 |\n| jstl | JSTL 标签库 |\n| taglibs-standard-impl | 标签库 |\n\n\n\n## 框架初识\n\n### ORM 框架\n- 对象关系映射（Object Relational Mapping，O/R Mapping，ORM）是通过使用描述对象和数据库之间映射的 `元数据`，将面向对象语言程序中的 `对象` 自动 `持久化` 到 `关系数据库` 中。本质上就是将数据从一种形式转换到另外一种形式。 \n- 让 `实体类` 和 `数据库表` 进行一一对应关系 (映射关系)，`实体类属性` 和 `表里面的字段` 对应。操作表对应实体类对象，而不需操作数据库表。\n\n### SSH 框架\nSSH 框架：[Spring](http://spring.io/)、[Struts2](http://struts.apache.org/)、[Hibernate](http://hibernate.org/) \n\n集成 SSH 框架的系统从职责上分为四层：`表示层`、`业务逻辑层`、`数据持久层` 和 `域模块层`，以帮助开发人员在短期内搭建结构清晰、可复用性好、维护方便的 Web 应用程序。其中使用 `Struts` 作为 `系统的整体基础架构`，负责 MVC 的分离，在 Struts 框架的模型部分，控制业务跳转，利用 `Hibernate` 框架对 `持久层` 提供支持，`Spring` 做管理，`管理 Struts 和 Hibernate`。\n    \n具体做法是：用面向对象的分析方法根据需求提出一些模型，将这些模型实现为基本的 Java 对象，然后编写基本的 DAO (Data Access Objects) 接口，并给出 Hibernate 的 DAO 实现，采用 Hibernate 架构实现的 DAO 类来实现 Java 类与数据库之间的转换和访问，最后由 Spring 做管理，管理 Struts 和 Hibernate。\n\n---\n\n#### Struts\n主要是用来做 `表示层`，也就所谓的 `界面`，和用户直接打交道，用来处理用户的请求和请求后返回给用户的模型数据。 Struts 对 Model，View 和 Controller 都提供了对应的组件。\n\n##### Struts2 入门\n\n###### Struts2 概述\n- Struts2 框架应用在 Java EE 三层结果中的 Web 层框架；\n- Struts2 解决的问题：\n\n\t![Struts2解决的问题](/images/illustration/Project/2018/08/J2EE-SSH-SSI-1_6-1.png)\n<center>图 6-1 Struts2 解决的问题</center>\n\n###### Struts2 案例\n\n- 创建 Action：\n\n\t```java\n\t// BaseAction.java\n\t\n\tpublic class BaseAction extends ActionSupport {\n\t    @Override\n\t    // 每次访问 action ，默认执行名称 execute() 方法\n\t    public String execute() throws Exception {\n\t        return NONE;\n\t    }\n\t}\n\t```\n\t\n- 配置 Action 类访问路径：需在 Src 根目录下创建核心配置文件 struts.xml，其名称和位置是固定的。\n\n\t```xml\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<!DOCTYPE struts PUBLIC\n\t    \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\"\n\t    \"http://struts.apache.org/dtds/struts-2.3.dtd\">\n\n\t<struts>\n\t    <package name=\"sample\" extends=\"struts-default\" namespace=\"/\">\n\t        <!--\n\t         | Name 属性值填写 action 访问的名称，例如 BaseAciton.action\n\t         | Class 属性值填写目标 Action 的全路径\n\t        -->\n\t        <action name=\"BaseAction\" class=\"cn.kofes.action.BaseAction\">/\n\t            <result name=\"success\">/jsp/success.jsp</result>\n\t        </action>\n\t    </package>\n\t</struts>\n\t```\n\t\n- 配置过滤器：在 web.xml 中添加过滤器\n\t\n\t```xml\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n\t    version=\"4.0\">\n\n\t    <!-- 过滤器模块 -->\n\t    <filter>\n\t        <filter-name>struts2</filter-name>\n\t        <filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>\n\t    </filter>\n\t    <filter-mapping>\n\t        <filter-name>struts2</filter-name>\n\t        <url-pattern>/*</url-pattern>\n\t    </filter-mapping>\n\n\t    <welcome-file-list>\n\t        <welcome-file>index.jsp</welcome-file>\n\t    </welcome-file-list>\n\t</web-app>\n\t```\n\n###### Struts2  底层执行过程\n\n如图 6-2 所示，为 Struts 底层执行过程图示。\n\n![Struts底层执行过程](/images/illustration/Project/2018/08/J2EE-SSH-SSI-1_6-2.png)\n<center>图 6-2 Struts 底层执行过程</center>\n\n###### Struts2 配置\n\n- Struts 核心配置文件 ( Struts2.5.x 版本 )\n\n\t```xml\n\t<!-- Struts 2.5.x 版本的约束 -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<!DOCTYPE struts PUBLIC\n\t    \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\"\n\t    \"http://struts.apache.org/dtds/struts-2.5.dtd\">\n\t<struts>\n\t    <!-- 表单的编码/乱码问题 -->\n\t    <constant name=\"struts.i18n.encoding\" value=\"UTF-8\" />\n\t    <!-- 指定Struts2处于开发阶段，可以进行调试 -->\n\t    <constant name=\"struts.devMode\" value=\"true\" />\n\t    <constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\" />\n\n\t    <!--\n\t     | Name 属性：唯一标识 Package\n\t     | Extends 属性：属性固定的的，即 Package 中配置的类具有 action 功能\n\t     | Namespace 属性：与 action 标签名构成访问路径\n\t    -->\n\t    <package name=\"sample\" namespace=\"/\" extends=\"struts-default\" strict-method-invocation=\"false\">\n\t        <!-- Struts2.5.x 版本特征，提升安全性 -->\n\t        <global-allowed-methods>regex:.*</global-allowed-methods>\n\n\t        <!--\n\t         | Name 属性：唯一标识，与 namespace 构成访问访问路径\n\t         | Class 属性：Action 类的全路径\n\t         | Method 属性：除了 execute() 方法，若绑定 Action 类其他方法则用此属性\n\t        -->\n\t        <action name=\"baseAction\" class=\"cn.kofe.action.baseAction\" method=\"login\">\n\t            <!--\n\t             | 根据 Action 类中方法的返回值，配置到不同的路径里面\n\t             | Name 属性：与 Action 类对应的方法的返回值一样\n\t             | Type 属性：配置如何到路径中 ( 转发或者重定向 )，默认值为转发\n\t            -->\n\t            <result name=\"success\">/success.jsp</result>\n\t        </action>\n\t\n\t        <!-- Add actions here -->\n\n\t    </package>\n\t</struts>\n\t```\n\n###### Struts2 Action 创建\n\n- 创建普通类，不继承任何类，不实现任何接口；\n\n- ~~创建类，实现 Action 接口~~；\n\n\t```java\n\tpublic class BaseAction implements Action {\n\t    @Override\n\t    public String execute throws Exception {\n\t        return NONE; // SUCCESS、ERROR ( 也可自定义字符串 ) ... \n\t    }\n\t}\n\t```\n- 创建类，继承 ActionSupport；\n\n\t```java\n\tpublic class BaseAction extends ActionSupport {\n\t    @Override\n\t    public String execute throws Exception {\n\t        return NONE; // SUCCESS、ERROR ( 也可自定义字符串 ) ... \n\t    }\n\t    \n\t    // 自定义方法\n\t    public String login() { return SUCCESS; }\n\t}\n\t```\n\n###### Struts2 Action 方法访问\n\n- 使用 action 标签中的 method 属性，在属性里写执行的 action 的方法名称；\n\n\t```xml\n\t<package name=\"sample\" namespace=\"/\" extends=\"struts-default\" strict-method-invocation=\"false\">\n\t    <action name=\"login\" class=\"cn.kofes.action.BaseAction\" method=\"login\" />\n\t</package>\n\t```\n\n- 使用通配符方式实现；\n\n\t```xml\n\t<package name=\"sample\" namespace=\"/\" extends=\"struts-default\" strict-method-invocation=\"false\">\n\t    <!-- 例如，访问路径为 http://192.168.x.x/action_login.action -->\n\t    <action name=\"action_*\" class=\"cn.kofes.action.BaseAction\" method=\"{1}\" />\n\t</package>\n\t```\n\n- 动态访问实现；\n\n\t```xml\n\t <!-- 动态方法访问 -->\n\t<constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\" />\n\t\n\t<!-- strict-method-invocation：是否允许使用通配符 ( 默认开启，不需要关闭 ) -->\n\t<package name=\"sample\" namespace=\"/\" extends=\"struts-default\" strict-method-invocation=\"true\">\n\t    <!-- 还可以限制具体哪些方法可以动态访问 -->\n\t    <global-allowed-methods>regex:.*</global-allowed-methods>\n\t    <action name=\"login\" class=\"cn.kofes.action.BaseAction\" method=\"login\" />\n\t</package>\n\t```\n\n- 常见错误：\n\t- 若 action 方法有返回值，在配置文件中没有配置，会出现无法找到页面的错误 (404)。\n\t- action 的名称，action 方法的返回值常量，规范使用 `驼峰式命名` 定义。\n\n##### Struts2 数据操作\n\n###### 结果页面配置\n- 全局结果页面：若多个 Action，方法的返回值相同，到达页面也是相同，则可使用全局结果页面配置。\n\n\t```xml\n\t<package name=\"sample\" namespace=\"/\" extends=\"struts-default\">\n\t    <global-results>\n\t        <result name=\"success\">/success.jsp</result>\n\t    </global-results>\n\t</package>\n\t```\n\n- 局部结果页面：若配置了全局和局部结果页面，以局部为准。\n\n\t```xml\n\t<package name=\"sample\" namespace=\"/\" extends=\"struts-default\">\n\t    <action name=\"login\" class=\"cn.kofes.action.BaseAction\" method=\"login\" />\n\t</package>\n\t```\n\n- Result 标签 的 Type 属性 (值)：\n\t- `dispatcher`：默认值，转发操作。\n\t- `redirect`：重定向操作。\n\t- `redirectAction`：重定向到 action。\n\t- ~~`chain`：转发到 action ( 缓存问题 )~~。\n\n###### 表单数据操作\n- 先构造一个表单：\n\n\t```html\n\t<!-- login.jsp -->\n\t<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n\t<html>\n\t    <head>\n\t        <title>SSH_FRAME_COMP</title>\n\t    </head>\n    \t    \n\t    <body>\n\t        <form action=\"${pageContext.request.contextPath}/form.action\" method=\"post\">\n\t            Username：<input type=\"text\" name=\"username\" /><br/>\n\t            Age：<input type=\"text\" name=\"age\" /><br/>\n\t            Email：<input type=\"text\" name=\"email\" /><br/>\n\t            Phone：<input type=\"text\" name=\"phone\" /><br/>\n\t        <input type=\"submit\" value=\"Submit\" />\n\t        </form>\n\t    </body>\n\t</html>\n\t\n\t<!-- struts.xml -->\n\t<action name=\"FormOperator\" class=\"cn.kofes.action.FormOperator\" method=\"execute\">\n\t    <!-- 若返回 \"success\"，则重定向到另一个 action，即执行登录 -->\n\t    <result name=\"success\" type=\"redirectAction\">login</result>\n\t</action>\n\t```\n\n- action 获取表单提交数据\n\n\t```java\n\tpublic class FormOperator extends ActionSupport {\n\t\n\t    public String execute() throw Exception { \n\t    \n\t        // Case.01.使用 ActionContext 类获取\n\t        ActionContext context = ActionContext.getContext();\n\t        // key 时表单输入项 Name 的属性值，Value 时输入的值 \n\t        Map<String, Object> map = context.getParameters();\n\t        Set<String> keys = map.keySet();\n\t        for(String key : keys) {\n\t            // 数组形式，考虑有复选框的情况\n\t            Object[] obj = (Object[]) map.get(key);\n\t        }\n \t\n\t        // Case.02.使用 ServletActionContext 类获取\n\t        HttpServletRequest request = ServletActionContext.getRequest();\n\t        String username = request.getParamter(\"username\");\n\t        \n\t        rerun NONE;\n\t    }\n\t}\n\t\n\t// Case.03.使用接口注入方式获取\n\tpublic class FormOperator extends ActionSupport implements ServletRequestAware {\n\t\n\t    private HttpServletRequest request;\n\t    \n\t    @Overrride\n\t    public  void setServletRequest(HttpServletRequest request) {\n\t        this.request = request;\n\t    }\n\t    \n\t    public String execute() throw Exception {\n\t        String username = request.getParamter(\"username\");\n\t        return NONE;\n\t    }\n\t}\n\t```\n\t\n- action 操作域对象\n\n\t```java\n\tpublic class FormOperator extends ActionSupport {\n\t\n\t    public String execute() throw Exception { \n\t    \n\t        // 操作域对象\n\t        // Request 域\n\t        HttpServletRequest request = ServletActionContext.getRequest();\n\t        request.setAttribute(\"requestKey\", \"requestValue\");\n\t        \n\t        // Session 域\n\t        HttpSession session = request.getSession();\n\t        session.setAttribute(\"sessionKey\", \"sessionValue\");\n\t        \n\t        // ServletContext 域\n\t        ServletContext context = ServletActionContext.getServletContext();\n\t        context.setAttribute(\"contextKey\", \"contextValue\");\n\t        \n\t        rerun NONE;\n\t    }\n\t}\n\t```\n\n- struts2 提供获取表单数据方式\n\n\t```java\n\t// 原始方式获取表单数据，再封装数据到实体类对象中\n\tUser user = new User();\n\tHttpServletRequest request = ServletActionContext.getRequest();\n\tuser.setUsername( request.getParamter(\"username\") );\n\t\n\t// 属性封装：获取表单数据到属性中  ( Setter 和 Getter 方法补全即可 )\n\t// 在 action 的成员变量位置定义变量 ( 变量名称和表单输入项的 Name 属性值一样 )\n\tprivate String username;\n\tpublic void setUsername(String username) { this.username = username }\n\tpublic String getUsername() { return username; }\n\t// 以此类推...\n\t\n\t// 模型驱动封装\n\t// Step.01. 实现接口 ModelDriven\n\t// Step.02. 实现接口的方法 getModel()，再把创建对象返回\n\t// Step.03. 在 action 里『创建』实体类对象\n\tpublic class FormOperator extends ActionSupport implements ModelDriven<User> {\n\t    private User user = new User();\n\t    @Override\n\t    public User getModel() {\n\t        return user;\n\t    }\n\t    @Override\n\t    public Sring execute() throw EXception {\n\t        return NONE;\n\t    }\n\t}\n\t\n\t// 表达式封装\n\t// Step.01.在 action 中『声明』实体类；\n\t// Step.02.生成实体类变量的 Setter 和 Getter 方法\n\t// Step.03.再表单输入项的 Name 属性值中填写表达式\n\t\n\t// 表达式：<input type=\"text\" name=\"user.username\" />\n\t\n\tpublic class FormOperator extends ActionSupport {\n\t    private User user;\n\t    public void setUser(User user) { this.user = user; }\n\t    public User getUser() { return user; }\n\t    \n\t    @Override\n\t    public Sring execute() throw EXception {\n\t        return NONE;\n\t    }\n\t}\n\t```\n\t\n> 使用模型驱动和属性封装是注意事项：在同一个 action 中，获取表单数据可以是模型驱动合作和属性封装，但不能同时使用二者。`同时使用只会执行模型驱动`。  \n\n- `表达式封装` 和 `模型驱动` 比较：  \n\t- 相同点：使用表达式封装和模型驱动封装都可把数据封装到实体类对象里。\n\t- 不同点：使用模型驱动只能把数据封装到一个实体类对象里。而表达式封装没有限制，即通过表达式封装可把数据封装到多个、不同的实体类对象里面。\n\n- struts2 获取数据封装到集合：\n\t\n\t```xml\n\t<!-- 封装数据到 List 集合 -->\n\t<input type=\"text\" name=\"list[0].username\" />\n\t<input type=\"text\" name=\"list[0].age\" />\n\t<input type=\"text\" name=\"list[1].username\" />\n\t<input type=\"text\" name=\"list[1].age\" />\n\t\n\t<!-- 封装数据到 Map 集合 -->\n\t<input type=\"text\" name=\"map['Lucy'].username\" />\n\t<input type=\"text\" name=\"map['Lucy'].age\" />\n\t<input type=\"text\" name=\"map['Mark'].username\" />\n\t<input type=\"text\" name=\"map['Mark'].age\" />\n\n\t\n\t<!-- 在实现类中声明 -->\n\tpublic class FormOperator extends ActionSupport {\n\t    private List<User> list;\n\t    public void setList(List<User> list) { this.list = list; }\n\t    public List<User> list getUser() { return list; }\n\t     \n\t    // private Map<String, User> map;\n\t    // public void setMap(Map<String, User> map) { this.map = map }\n\t    // public Map<String, User> getMap() { return map; }\n\t    \n\t    @Override\n\t    public Sring execute() throw EXception {\n\t        return NONE;\n\t    }\n\t}\n\t```\n\t\n###### 案例实操展示\n- 新建表单操作页面 `form.jsp` 和数据展示页面 `info.jsp`：\n\n\t```html\n\t<!-- form.jsp -->\n\t<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n\t<html>\n\t    <head>\n\t        <title>SSH_FRAME_COMP</title>\n\t    </head>\n\t    <body>\n\t        <form name=\"loginForm\" action=\"${pageContext.request.contextPath}/form.action\" method=\"post\">\n\t            Username：<input type=\"text\" name=\"user.username\"/><br/>\n\t            Age：<input type=\"text\" name=\"user.age\"/><br/>\n\t            Email：<input type=\"text\" name=\"user.email\"/><br/>\n\t            Phone：<input type=\"text\" name=\"user.phone\"/><br/>\n\t            <input type=\"submit\" value=\"Submit\"/>\n\t        </form>\n\t    </body>\n\t</html>\n\t\n\t<!-- info.jsp -->\n\t```\n\t\n- 在 struts.xml 配置文件中添加 action：\n\n\t```xml\n\t<!-- struts.xml -->\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<!DOCTYPE struts PUBLIC\n\t    \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\"\n\t    \"http://struts.apache.org/dtds/struts-2.5.dtd\">\n\n\t<struts>\n\t    <!-- 表单的编码/乱码问题 -->\n\t    <constant name=\"struts.i18n.encoding\" value=\"UTF-8\" />\n\t    <!-- 动态方法访问 -->\n\t    <constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\" />\n\n\t    <package name=\"sample\" namespace=\"/\" extends=\"struts-default\" strict-method-invocation=\"true\">\n\t        <global-allowed-methods>regex:.*</global-allowed-methods>\n\t        \n\t        <!-- 使用注解创建 FormOperator 对象，直接引用标签值 -->\n\t        <action name=\"form\" class=\"formOperator\" method=\"saveInfo\">\n\t            <result name=\"getinfo\" type=\"redirectAction\">info</result>\n\t        </action>\n\t        \n\t        <!-- 插入数据后加载数据库 -->\n\t        <action name=\"info\" class=\"formOperator\" method=\"getInfo\">\n\t            <result name=\"listinfo\">/jsp/info.jsp</result>\n\t        </action>\n\t        \n\t    </package>\n\t</struts>\n\t```\n\t\n- 在 Action 中实现逻辑处理类：\n\n\t```java\n\t// FormOperator.java\n\t// Action 层：界面交互层\n\t@Controller(value=\"formOperator\")\n\t@Scope(value = \"prototype\")\n\tpublic class FormOperator extends ActionSupport {\n\t    private User user;\n\t    \n\t    // Service 处理业务逻辑\n\t    @Resource(name = \"sampleService\")\n\t    private BaseService service;\n\t    \n\t    @Override\n\t    public Sring execute() throw EXception {\n\t        return NONE;\n\t    }\n\t    \n\t    public String saveInfo() {\n\t        service.saveUserInfo(user);\n\t        return \"info\";\n\t    }\n\t    \n\t    public String getInfo() {\n\t        // 从数据库中加载数据\n\t        return NONE;\n\t    }\n\t}\n\t\n\t// SampleServiceImpl.java\n\t// Servie 层：业务逻辑层\n\t@Service(value = \"sampleService\")\n\t@Transactional\n\tpublic class SampleServiceImpl implements BaseService {\n\n\t    @Resource(name = \"sampleDao\")\n\t    private BaseDao dao;\n\n\t    @Override\n\t    public void saveUserInfo(User user) {\n\t        if( null != dao.queryOneTuple(user.getClass(), user.getUid()) ) {\n\t            dao.updateOneTuple(user);\n\t        } else {\n\t            dao.insertOneTuple(user);\n\t        }\n\t    }\n\t}\n\t\n\t// SampleDaoImpl.java\n\t// Dao 层：数据持久层\n\t@Repository(value = \"sampleDao\")\n\tpublic class SampleDaoImpl implements BaseDao {\n\n\t    @Resource(name = \"hibernateTemplate\")\n\t    private HibernateTemplate hibernateTemplate;\n\n\t    @Override\n\t    public void insertOneTuple(Object entity) {\n\t        hibernateTemplate.save(entity);\n\t    }\n\t    \n\t    @Override\n\t    public void updateOneTuple(Object entity) {\n\t        hibernateTemplate.update(entity);\n\t    }\n\t    \n\t    @Override\n\t    public <T> T queryOneTuple(Class<T> entityClass, Serializable id) {\n\t        T temporary = null;\n\t        if (null != entityClass) {\n\t            temporary = hibernateTemplate.get(entityClass, id);\n\t        }\n\t        return temporary;\n\t    }\n\t}\n\t```\n\n##### Struts2 值栈\n\n###### 值栈概念\n- 什么是值栈：\n\t- Struts 里本身提供一种存储机制，类似于 `域对象`。即值栈，可存储数据也可读取数据。\n\t- Striuts 把数据放到值栈里，在 Jsp 页面中获取到值栈数据。\n\n- Ognl：Web 阶段，EL 表达在 Jsp 中获取域对象中的值。而 Ognl 也是一种表达式。\n\t- Struts 中操作值栈数据，和 `Struts 标签` 一起使用、操作值栈。\n\t- Ognl 不是 Struts 的一部分，可以单独使用。\n- Struts 标签：虽然标签封装了样式，方便操作，但故样式上会有限制。\n\n\t```html\n\t<!-- 在对应的 jsp 页面中引入标签库  -->\n\t<%@ taglib uri=\"/struts-tags\" prefix=\"s\" %>\n\t\n\t<!-- 查看值栈结构和数据 -->\n\t<s:debug />\n\t\n\t<!-- 使用 Ognl + Struts 标签，实现计算字符串长度 -->\n\t<s:property value=\"'str'.length()\" />\n\t\n\t<!-- html 表单标签\n\t | 1) form：action、method、enctype\n\t | 2) 输入项：大部分在 input 中封装 type 值实现各种输入项，例如：\n\t |    text，普通文本输入项\n\t |    password，密码输入项\n\t |    radio，单选输入项\n\t |    checkbox，复选输入项\n\t |    file，文件上传项\n\t |    hidden，隐藏项\n\t |    button，普通按钮\n\t |    submit，提交按钮\n\t |    image，图片提交\n\t |    reset，重置\n\t | 3) select：下拉输入项\n\t | 4) textarea：文本域\n\t-->\n\t<s:form name=\"signupForm\" action=\"form.action' method=\"POST\">\n\t    <!-- 普通输入项 -->\n\t    <s:textfield name=\"username\" label=\"username\" />\n\t    <!-- 密码输入项 -->\n\t    <s:password name=\"password\" label=\"password\" />\n\t    <!-- 单选项 -->\n\t    <s:radio list=\"#{'male':'男', 'female':'女'}\" name=\"gender\" label=\"gender\" />\n\t    <!-- 多选项 -->\n\t    <s:checkboxlist list=\"{'sleep', 'eat'}\" name=\"interest\" label=\"interest\" />\n\t    <!-- 下拉输入框 -->\n\t    <s:select list=\"{'str1', 'str2', 'str3'}\" name=\"sample\" label=\"sample\" />\n\t    <!-- 文件上传项 -->\n\t    <s:file name=\"file\" label=\"file\" />\n\t    <!-- 文本域 -->\n\t    <s:textarea row=\"10\" cols=\"10\" name=\"description\" value=\"description\" />\n\t    <!--  隐藏项 -->\n\t    <s:hidden name=\"hiddenContent\" value=\"hidden content is here\" />\n\t    <!-- 提交按钮 -->\n\t    <s:submit value=\"Submit\" />\n\t</s:form>\n\t\n\t\n\t```\n- Servlet 和 Action 区别：\n\t- Servlet：默认在第一次访问时创建，仅创建一次。( 单实例 )\n\t- Action：访问时候创建，且每次访问时都会创建 action 对象。( 多实例 )\n\n\n###### 获取值栈对象\n- 使用 ActionContext 类的方法获取值栈对象\n\n\t```java\n\t\n\tpublic class FormOperator extends ActionSupport {\n\t    private User user;\n\t    \n\t    @Override\n\t    public Sring execute() throw EXception {\n\t        ActionContext context = ActionContext().getContext();\n\t        ValueStack stack = context.getValueStack();\n\t        return NONE;\n\t    }\n\t}\t\n\t```\n\n###### 值栈内部结构\n值栈主要分为两部分：\n\n- Root：List 集合 `Class Compoundroot extends ArrayList { ... }`\n\t\n- Context：Map 集合 `Class Compoundroot extends Object implements Map { ... }`\n\n\t![Context 存储的对象引用](/images/illustration/Project/2018/08/J2EE-SSH-SSI-1_6-3.png)\n\t<center>图 6-3 Context 存储的对象引用</center>\n\n###### 向值栈存数据\n\n> 结合 `<s:debug />` 标签，可浏览值栈的传值情况。\n\n向值栈存数据的多种方式：\n\n- 获取值栈对象，调用值栈对象的 set 方法。\n- 获取值栈对象，调用值栈对象的 push 方法。\n- 在 action 定义变量，生产变量的 get 方法。\n\t\n\t```java\n\t// 获取值栈对象\n\tActionContext context = ActionContext.getContext();\n\tValueStack stack = context.getValueStack();\n\t\n\t// 向值栈放字符串\n\t// Case.01\n\tstack.set(\"username\", \"AttrSet\");\n\t// Case.02\n\tstack.push(\"PushMethod\");\n\t// Case.03.声明变量，生成 Getter 方法\n\tprivate String str;\n\tpublic String getStr() { return str; }\n\tstr = \"SetStrAttr\";\n\n\t// 向值栈放对象\n\tprivate User user;\n\tpublic User getUser() { return user; }\n\t// user.setXXX();\n\t\n\t// 向值栈放 List 集合\n\tprivate List<User> list;\n\tpublic List<User> getList() { return list; }\n\tlist = getAllUserInfo(User.class);\n\t```\n\n###### 从值栈取数据\n\n- 从值栈获取数据\n\n\t```html\n\t<!-- 在对应的 jsp 页面中引入 struts 标签库  -->\n\t<%@ taglib uri=\"/struts-tags\" prefix=\"s\" %>\n\t\n\t<!-- 在 Jsp 页面中获取属性值 -->\n\t<s:property value=\"str\" />\n\t\n\t<!-- Jsp 页面中获取对象的值 -->\n\t<s:property value=\"user.username\" />\n\t<s:property value=\"user.email\" />\n\t\n\t<!-- Jsp 页面中获取 List 集合：方式 1 -->\n\t<s:iterator value=\"list\">\n\t    <s:property value=\"username\" />\n\t    <s:property value=\"age\" />\n\t    <s:property value=\"email\" />\n\t    <s:property value=\"phone\" />\n\t</s:iterator>\n\t\n\t<!-- Jsp 页面中获取 List 集合：方式 2 -->\n\t<s:iterator value=\"list\" var=\"user\">\n\t    <s:property value=\"#user.username\" />\n\t    <s:property value=\"#user.age\" />\n\t    <s:property value=\"#user.email\" />\n\t    <s:property value=\"#user.phone\" />\n\t</s:iterator>\n\t```\n\n---\n\n#### Spring\n`业务逻辑层`，是一个轻量级的控制反转 (IoC) 和面向切面 (AOP) 的容器框架。\n\n#####  Spring 概念\n- 一站式轻量级开源框架，在 Java EE 三层结构中，每一层提供不同的解决技术。\n\t- `Web 层`：Spring MVC\n\t- `Service 层`：ioC\n\t- `DAO 层`：Spring 的 JdbcTemplate\n- AOP：`面向切面编程`，扩展功能不是通过修改源码实现的，即通过 `动态代理技术`，把各类通知 / 增强织入到它所约定的流程当中。事实上，是通过引入其他类的方法来实现的。\n- ioC：`控制反转`，例如：对象的创建不通过 new 方式实现，而是通过 Spring 配置创建类对象。\n\n##### Spring ioC\n控制反转 (ioC)，是一种通过描述 (在 Java 中可以是 XML 或者注解) 并通过第三方去产生或获取特定对象的方式。\n\n###### ioC 底层原理\n- 使用技术：\n\t- XML 配置文件；\n\t- Dom4j 解析 XML；\n\t- 工厂设计模式；\n\t- 类的反射.\n- 代码实现：\n\t- 创建 XML 配置文件，配置要创建对象类。\n\t- 创建工厂类，使用 Dom4j 解析配置文件，通过反射创建类对象。\n\t\n###### ioC 入门案例\n- Maven 中添加依赖库 ( 对应导入 Jar 包 )：\n\n\t> 下载 Jar 包：到 [Maven Pository](http://mvnrepository.com/) 中搜索目标 Jar 包，在具体页面中的 Files 一栏可下载。例如：[log4j-core.2.11.0](http://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core/2.11.0)\n\n\t```xml\n\t<!-- porm.xml -->\n\t\n\t<!-- Version Control of Jar Dependency  -->\n\n\t<properties>\n\t    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n\t    <spring.version>4.3.18.RELEASE</spring.version>\n\t    <hibernate.version>5.2.17.Final</hibernate.version>\n\t    <struts2.version>2.5.16</struts2.version>\n\t</properties>\n\t\n\t<!-- Foundation of SSH ( Spring、Struts 2、Hibernate ) -->\n\n\t<dependencies>\n\n\t    <!-- spring -->\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-beans</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-core</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-context</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-expression</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n        \n\t    <!-- 以下依赖包为下文所需要的，为方便起见这里统一配置 -->\n\n\t    <!-- struts2 -->\n\t    <dependency>\n\t        <groupId>org.apache.struts</groupId>\n\t        <artifactId>struts2-core</artifactId>\n\t        <version>${struts2.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.ow2.asm</groupId>\n\t        <artifactId>asm</artifactId>\n\t        <version>5.2</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.ow2.asm</groupId>\n\t        <artifactId>asm-commons</artifactId>\n\t        <version>5.2</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.ow2.asm</groupId>\n\t        <artifactId>asm-tree</artifactId>\n\t        <version>5.2</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>commons-fileupload</groupId>\n\t        <artifactId>commons-fileupload</artifactId>\n\t        <version>1.3.3</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>commons-io</groupId>\n\t        <artifactId>commons-io</artifactId>\n\t        <version>2.5</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.apache.commons</groupId>\n\t        <artifactId>commons-lang3</artifactId>\n\t        <version>3.6</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.freemarker</groupId>\n\t        <artifactId>freemarker</artifactId>\n\t        <version>2.3.23</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.javassist</groupId>\n\t        <artifactId>javassist</artifactId>\n\t        <version>3.22.0-GA</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>ognl</groupId>\n\t        <artifactId>ognl</artifactId>\n\t        <version>3.1.15</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>javax</groupId>\n\t        <artifactId>javaee-api</artifactId>\n\t        <version>8.0</version>\n\t        <scope>provided</scope>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>javax.servlet</groupId>\n\t        <artifactId>jstl</artifactId>\n\t        <version>1.2</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.apache.taglibs</groupId>\n\t        <artifactId>taglibs-standard-impl</artifactId>\n\t        <version>1.2.5</version>\n\t    </dependency>\n\n\t    <!-- config-browser-plugin 插件方便浏览项目中的所有 Action 及其与 Jsp View 的映射 -->\n\t    <dependency>\n\t        <groupId>org.apache.struts</groupId>\n\t        <artifactId>struts2-junit-plugin</artifactId>\n\t        <version>${struts2.version}</version>\n\t        <scope>test</scope>\n\t    </dependency>\n\n\t    <!-- Hibernate -->\n\t    <dependency>\n\t        <groupId>org.hibernate</groupId>\n\t        <artifactId>hibernate-core</artifactId>\n\t        <version>${hibernate.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.hibernate.common</groupId>\n\t        <artifactId>hibernate-commons-annotations</artifactId>\n\t        <version>5.0.4.Final</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.hibernate.javax.persistence</groupId>\n\t        <artifactId>hibernate-jpa-2.1-api</artifactId>\n\t        <version>1.0.2.Final</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.jboss</groupId>\n\t        <artifactId>jandex</artifactId>\n\t        <version>2.0.5.Final</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.jboss.logging</groupId>\n\t        <artifactId>jboss-logging</artifactId>\n\t        <version>3.3.2.Final</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>antlr</groupId>\n\t        <artifactId>antlr</artifactId>\n\t        <version>2.7.7</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.codehaus.woodstox</groupId>\n\t        <artifactId>stax2-api</artifactId>\n\t        <version>3.1.4</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.apache.geronimo.specs</groupId>\n\t        <artifactId>geronimo-jta_1.1_spec</artifactId>\n\t        <version>1.1.1</version>\n\t    </dependency>\n\n\t    <!-- Combining with SSH ( Spring、Struts 2、Hibernate ) framework -->\n\n\t    <!-- Spring 整合 Hibernate 和事务 -->\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-jdbc</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-orm</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-tx</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\n\t    <!-- Spring 整合 AOP -->\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-aop</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-aspects</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>aopalliance</groupId>\n\t        <artifactId>aopalliance</artifactId>\n\t        <version>1.0</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.aspectj</groupId>\n\t        <artifactId>aspectjweaver</artifactId>\n\t        <version>1.9.1</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>cglib</groupId>\n\t        <artifactId>cglib-nodep</artifactId>\n\t        <version>3.2.7</version>\n\t    </dependency>\n\n\t    <!-- Spring 整合 Web -->\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-web</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\n\t    <!-- Sturts 2 整合 Spring 框架 -->\n\t    <dependency>\n\t        <groupId>org.apache.struts</groupId>\n\t        <artifactId>struts2-spring-plugin</artifactId>\n\t        <version>${struts2.version}</version>\n\t    </dependency>\n\n\t    <!-- Others -->\n\n\t    <!-- 添加对 MySQL 数据库的支持 -->\n\t    <dependency>\n\t        <groupId>mysql</groupId>\n\t        <artifactId>mysql-connector-java</artifactId>\n\t        <version>6.0.6</version>\n\t    </dependency>\n\n\t    <!-- 添加对数据源的支持 -->\n\t    <!-- https://mvnrepository.com/artifact/com.mchange/c3p0 -->\n\t    <dependency>\n\t        <groupId>com.mchange</groupId>\n\t        <artifactId>c3p0</artifactId>\n\t        <version>0.9.5.2</version>\n\t    </dependency>\n\n\t    <!-- c3p0数据库连接池的辅助包 -->\n\t    <dependency>\n\t        <groupId>com.mchange</groupId>\n\t        <artifactId>mchange-commons-java</artifactId>\n\t        <version>0.2.15</version>\n\t    </dependency>\n\n\t    <!-- 日志系统 -->\n\t    <dependency>\n\t        <groupId>org.apache.logging.log4j</groupId>\n\t        <artifactId>log4j-core</artifactId>\n\t        <version>2.10.0</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.apache.logging.log4j</groupId>\n\t        <artifactId>log4j-api</artifactId>\n\t        <version>2.10.0</version>\n\t    </dependency>\n\n\t    <!-- Junit -->\n\t    <dependency>\n\t        <groupId>junit</groupId>\n\t        <artifactId>junit</artifactId>\n\t        <version>4.12</version>\n\t        <scope>compile</scope>\n\t    </dependency>\n\n    </dependencies>\n\t```\n\t\n- 创建 Spring 配置文件：在 Src 目录下 (建议)，创建 Spring 核心配置文件 applicationContext.xml。\n\t\n\t```xml\n\t<!-- applicationContext.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xsi:schemaLocation=\"\n\t    http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd>\n\t    <bean id=\"operator\" class=\"cn.entity.UserOperator\"></bean>\n\t</beans>\n\t```\n\n- 再配置创建类，对象创建 (方便演示，以单元测试形式呈现)：\n\n\t```java\n\t// 单元测试类\n\tpublic class ioCTest() {\n\t    @Test\n\t    public void testUser() {\n\t        // Step.01.加载 Spring 配置文件\n\t        ApplicationContext context  = \n\t            new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t            \n\t        // Step.02. 得到配置创建的对象\n\t        UserOperator operator = \n\t            (UserOperator) context.getBean(\"operator\");\n\t    }\n\t}\n\t```\n\n##### Spring Bean 管理 (XML)\n\n###### Bean 标签常用属性\n- ID 属性：Bean 标签的名称，要求只含数字和大小写英文字母。\n- Class 属性：常见对象所在类的全路径。\n- Name 属性：功能和 ID 属性一样，Name 属性可包含特殊字符值。\n- Scope 属性：\n\t- `singleton`：单例的 ( 默认值 )。\n\t- `prototype`：多例的。\n\n###### Bean 实例化的方式\n- 使用类的无参数构造创建对象\n\n\t```java\t\n\tpublic class UserOperator {\n\t   public UserOperator() { }\n\t}\n\t```\n\n- 使用静态工厂创建对象\n\n\t```java\n\tpublic class UserOperatorFactory {\n\t    public static UserOperator getOperator() {\n\t        String className = \"classValue\"; // cn.entity.UserOperator\n\t        Class clz = Class.forName(className);\n\t        return clz.newInstance();\n\t    }\n\t}\n\t```\n\t\n- 上述实例化方法在 applicationContext.xml 中的配置：\n\n\t```xml\n\t<!-- 无参数构造创建对象 -->\n\t<bean id=\"operator\" class=\"cn.kofes.entity.UserOperator\" scope=\"singleton\"></bean>\n   \n\t<!-- 静态工厂创建对象 -->\n\t<bean id=\"operator\" class=\"cn.kofes.entity.UserOperatorFactory\" factory-method=\"getOperator\"></bean>\n    \n\t```\n\n###### 属性注入方式\n- Set() 方法注入\n\n\t```java\n\tpublic class UserOperator {\n\t    private String operationType;\n\t    public void setUsername(String operationType) {\n\t        this.operationType = operationType;\n\t    }\n\t}\n\t```\n\n- 有参数构造注入\n\n\t```java\n\tpublic class UserOperator {\n\t    private String operationType;\n\t    public UserOperator(String operationType) {\n\t        this.operationType = operationType;\n\t    }\n\t}\n\t```\n\t\n- 注入 `对象属性` 类型：\n\n\t```java\n\tpublic class UserOperator {\n\n    private User user;\n    \n    public void setUser(User user) {\n        this.user = user;\n    }\n    \n\t    @Test\n\t    public void operatorTest() {\n\t        ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t        UserOperator operator = (UserOperator) context.getBean(\"operator\");\n\t        // TODO\n\t    }\n\t}\n\t```\n\t\n- 注入 `复杂类型` 属性：\n\t- 数组\n\t- List 集合\n\t- Map 集合\n\t- Properties 类型\n\n\t```java\n\tpublic class UserOperatorXML {\n\t    private String arrs;\t\t// 数组\n\t    private List<String> list;\t\t// List 集合\n\t    private Map<String, String> map;\t// Map 集合\n\t    private Properties properties;\t// Properties 类型\n\t    \n\t    // Setter() 方法此处省略...\n\t    \n\t    @Test\n\t    public void operatorTest() {\n\t        ApplicationContext context = \n\t        \tnew ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t        UserOperatorXML operator =\n\t        \t (UserOperatorXML) context.getBean(\"operator\");\n\t        // TODO\n\t    }\n\t}\n\t```\n\t\n- 上述 `注入方法` 在 applicationContext.xml 中的配置：\n\n\t```xml\n\t<!-- -- 有参数构造注入属性 -- -->\n\t<bean id=\"operator\" class=\"cn.kofes.entity.UserOperatorXML\">\n\t    <constructor-arg name=\"operationType\" value=\"modify\" />\n\t</bean>\n    \n\t<!-- -- Set 方法注入属性 -- -->\n\t<bean id=\"operator\" class=\"cn.kofes.entity.UserOperatorXML\">\n\t    <property name=\"operationType\" value=\"modify\" />\n\t</bean>\n\t\n\t<!-- -- 注入 对象属性 类型 -- -->\n\t<bean id=\"user\" class=\"cn.kofes.entity.User\"></bean>\n\n\t<bean id=\"operator\" class=\"cn.kofes.entity.UserOperatorXML\">\n\t    <!--\n\t     | Name 属性值：类里面的定义属性的名称\n\t     | Ref 属性：定义属性在 Bean 标签中的 ID 值\n\t    -->\n\t    <property name=\"user\" ref=\"user\" />\n\t</bean>\n\t\n\t\n\t<!-- -- 注入 复杂类型 属性 -- -->\n\t<bean id=\"complex\" class=\"cn.kofes.entity.UserOperatorXML\">\n\t    <!-- 数组、List 集合适用 -->\n\t    <property name=\"arrs\">\n\t        <lsit><value>Arrs0</value></lsit>\n\t        <lsit><value>Arrs1</value></lsit>\n\t        <lsit><value>Arrs2</value></lsit>\n\t    </property>\n\n\t    <!-- Map 集合 -->\n\t    <property name=\"map\">\n\t        <map>\n\t            <entry key=\"seq1\" value=\"str1\" />\n\t            <entry key=\"seq2\" value=\"str2\" />\n\t            <entry key=\"seq3\" value=\"str3\" />\n\t        </map>\n\t    </property>\n\n\t    <!-- Properties：例如我们要配置数据库 -->\n\t    <property name=\"properties\">\n\t        <props>\n\t            <prop key=\"driverclass\">com.mysql.jdbc.Driver</prop>\n\t            <prop key=\"username\">root</prop>\n\t            <prop key=\"password\">123456</prop>\n\t        </props>\n\t    </property>\n\t</bean>\n\t```\n\t\n###### Spring DI\nioC 与 DI 的区别\n\n- `ioC`：`控制反转`，把对象创建交给 Spring 进行配置。\n- `DI`：`依赖注入`，向类中的属性设置属性值。\n\t\n\t> 关系：依赖注入不能单独存在，需在 ioC 基础之上完成操作。\n\t\n##### Spring Bean 管理 (注解)\n- 注解格式：`@注解名称(value=\"属性值\")` 或者 `@注解名称(\"属性值\")` \n- `@Component(\"user\")` 相当于 `<bean id=\"user\" class=\"\" />`，其三个衍生注解为：\n\t- @Controller：Web 层，相当于 Struts 中的 Action 层。\n\t- @Service：业务层 ，业务逻辑处理。\n\t- @Repository：持久层，标注数据访问组件，即 DAO 组件。\n\n\t> 功能目前来说是一致的，即创建对象。\n\t\n- `@Scope(\"prototype\")` 或 `@Scope(\"singleton\")`：即配置的对象是单实例还是多实例。\n\n\t```java\n\t@Component(\"BaseAction\")\n\t@Scope(\"prototype\")\n\tpublic class BaseAction { ... }\n\t```\n\n###### 基本内容\n- 使用注解创建对象\n- 使用注解注入对象\n- xml 和注解方式混合使用\n\n###### 小试牛刀\n- 创建类和方法\n\n\t```java\n\tpublic class User { /* 省略实体类的属性 */ }\n\tpublic class Customer { /* 省略实体类的属性 */ }\n\tpublic class Firm { /* 省略实体类的属性 */ }\n\t```\n\n- 创建 Spring 配置文件，并引入约束 (在上述 applicationContext.xml 中追加)\n\t\n\t```xml\n\t<!-- applicationContext.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xsi:schemaLocation=\"\n\t    http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n\t    http://www.springframework.org/schema/context\n\t    http://www.springframework.org/schema/context/spring-context-2.5.xsd\">\n\t    \n\t    <!-- 注解扫描：扫描属性上面的注解 -->\n\t    <context:annotation-config/>\n\t    \n\t    <!-- \n\t     | 注解扫描：到包里扫描类、方法、属性上面的注解，\n\t     | 即使用 Annotation 自动注册 Bean\n\t    -->\n\t    <context:component-scan base-package=\"cn.kofes\"/>\n\t    <context:component-scan base-package=\"cn.kofes.entity\"/>\n\t</beans>\n\t```\n\t\n- 注解中创建对象\n\n\t```java\n\t// 此方式相当于 <bean id=\"user\" class=\"cn.kofes.entity.User\" />\n\t\n\t@Component(value=\"user\")  \n\tpublic class User { \n\t    // 省略实体类的属性...\n\t}\n\n\tpublic class UserOperatorAnn {\n\t    private User user;\n\n\t    @Test\n\t    public void operatorTest() {\n\t        ApplicationContext context = \n\t        \tnew ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t        System.out.println(user);\t // 直接调用 user 对象\n\t    }\n\t}\n\t```\n\n- 注解注入属性\n\n\t```java\n\t// 实体操作类\n\tpublic class UserOperatorAnn {\n\t\n\t    // 相当于 Set 方法注入属性：\n\t    // @Autowired 或者 @Resource(name = \"user\") \n\t    \n\t    @Autowired\t\n\t    private User user;\n\n\t    @Test\n\t    public void operatorTest() {\n\t        ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t        System.out.println(user);\t\n\t        System.out.println(customer);\t\n\t        System.out.println(firm);\t\n\t    }\n\t}\n\t```\n\t\n- XML 配置文件和注解混合使用\n\t- 创建对象操作使用 XML 配置文件方式实现；\n\t- 注入属性的操作使用注解方式实现.\n\n\t```java\n\t/* Start：applicationContext.xml */\n\t\n\t<bean id=\"user\" class=\"cn.kofes.entity.User\" />\n\t<bean id=\"customer\" class=\"cn.kofes.entity.Customer\" />\n\t<bean id=\"firm\" class=\"cn.kofes.entity.Firm\" />\n\t\n\t/* End：applicationContext.xml */\n\t\n\tpublic class UserOperatorAnn {\t\n\t    // 注解方式注入属性\n\t    @Resource(name = \"user\") \n\t    private User user;\n\t    @Resource(name = \"customer\") \n\t    private Customer customer;\n\t    @Resource(name = \"firm\") \n\t    private Firm firm;\n\n\t    @Test\n\t    public void operatorTest() {\n\t        ApplicationContext context = \n\t        \tnew ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t        System.out.println(user);\t\n\t        System.out.println(customer);\t\n\t        System.out.println(firm);\t\n\t    }\n\t}\n\t```\n\n##### Spring AOP\n\n###### AOP 概述\n面向切面编程 (Aspect Oriented Programing，AOP)，扩展功能不通过修改代码实现。AOP 采取 `横向抽取机制` 取代传统 `纵向继承体系` 重复性代码。\n\n- 纵向继承体系：通过继承获得父类的功能 (方法)。\n- 横向抽取机制：动态代理方式。\n\t- 针对有接口的情况，使用 JDK 动态代理。\n\t- 针对没有接口情况，使用 Cglib 动态代理。\n\n\t```java\n\tpublic interface Dao {\n\t    public void add();\n\t}\n\t\n\tpublic class DaoImpl implements Dao {\n\t    public void add() {\n\t        // 具体逻辑\n\t    }\n\t}\n\t```\n\n######  AOP 相关术语\n\n便于理解，引入实体类进行说明：\n\n```java\npublic class User {\n    public void add() {}\n    public void update() {}\n    public void delete() {}\n    public void findAll() {}\n}\n```\n\n- 连接点 (Join Point)：指那些被拦截到的点，在 Spring 这些点指的是方法，因 Spring 只支持方法类型的连接点。\n\n\t> 类中有哪些方法可被增强，这些方法称为连接点。\n\n- `切入点 (Pointcut)`：指我们要对哪些 `Join Point` 进行拦截的定义。\n\n\t> 类中有很多方法被增强，例如实际操作中，只是增强了类中的 add() 和 update() 方法，即称为切入点。\n\t\n- 引介 (Introduction)：一种特殊的通知在不修改类代码的前提下， Introduction 可为类动态地添加一些方法或 Field。\n\n- `通知/增强 (Advice)`：指拦截到 `Join Point` 之后要做的事情就是通知。通知分为前置通知、后置通知、异常通知、最终通知、环绕通知 (切面要完成的功能)。\n\n\t> 增强的逻辑称为增强，例如扩展日志功能，这个日志功能称为增强。  \n\t> 前置通知，在方法之前执行；后置通知，在方法之后执行；  \n\t> 异常通知，方法出现异常；最终通知，在后置之后执行；  \n\t> 环绕通知，在方法之前和之后执行.  \n\n- 目标对象 (Target)：代理的目标对象 (要增强的类)。\n\n- 织入 (Weaving)：把增强应用到目标的过程，即把 Advice 应用到 Target 的过程。\n\n- `切面 (Aspect)`：切入点和通知 (引介) 的结合。\n\n\t> 把增强应用到具体方法上，此过程称为切面。例如把日志功能写进 add() 方法中。\n\t\n- 代理 (Proxy)：一个类被 AOP 织入增强后，产生一个结果代理类。\n\n###### Spring AOP 操作\n\n> (1) 基于 AspectJ 的 Spring AOP 操作。\n\nASpectJ：面向切面的框架，其扩展了 Java 语言。AspectJ 定义了 AOP 语法，故它有一个专门的编译器来生成遵守 Java 字节编码规范的 Class 文件。 \n\nAspectJ 并不是 Spring 一部分，和 Spring 一起使用进行 AOP 操作。\n\n使用 AspectJ 实现 AOP 有两种方式：1) 基于 AspectJ 的 XML 配置；2) 基于 AspectJ 的注解方式。\n\n> (2) 操作基本流程 ( XML 方式 )：\n\n- 使用表达式配置切入点\n\t- execution( <访问修饰符>?<返回类型><方法名>(<参数>)(异常) )\n\n\t> execution( \\* cn.kofes.UserOpertor.add(..) )  -- UserOperator 类中 add() 方法增强\n\t> execution( \\* cn.kofes.UserOperator.\\*(..) )  -- UserOperator 类中所有方法增强\n\t> execution( \\* \\*.\\*(..) )  -- 所有类中所有方法增强  \n\t> execution( \\* save\\*(..) ) -- 所有 save 开头的方法增强\n\t\n- 代码实现\n\n\t```java\n\t// strengthenUserOperator.java\n\tpublic class strengthenUserOperator {\n\n\t    public strengthenUserOperator() { }\n\n\t    /**\n\t     * This's an aspect inserting to the method() the front.\n\t     */\n\t    public void listBeforeOperatorType() {\n\t        System.out.println(\"Inserting to the method() the front.\");\n\t    }\n\n\t    /**\n\t     * This's an aspect inserting to the method() the front and latter.\n\t     * @param proceedingJoinPoint 执行被增强的方法\n\t     * @throws Throwable\n\t     */\n\t    public void listArroundOperatorType(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n\t        System.out.println(\"Inserting to the method() the front.\");\n\t        proceedingJoinPoint.proceed();\n\t        System.out.println(\"Inserting to the method() the latter.\");\n\t    }\n\t}\n\t\n\t// UserOperatorXML.java\n\tpublic class UserOperatorXML {\n\n\t    private User user;\n\n\t    public void setUser(User user) { this.user = user; }\n\n\t    public User getUser() { return user; }\n\n\t    @Test\n\t    public void operatorTest() {\n\t        ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t        UserOperatorXML operator = (UserOperatorXML) context.getBean(\"operator\");\n\t        // 会在用户信息之前输出 “前置增强” 的信息。\n\t        System.out.println( operator.getUser() );\n\t    }\n\t}\n\t```\n\n- 创建 Spring 配置文件，并引入约束 (在上述 applicationContext.xml 中追加)\n\t\n\t```xml\n\t<!-- applicationContext.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n\t    xsi:schemaLocation=\"\n\t    http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n\t    http://www.springframework.org/schema/context\n\t    http://www.springframework.org/schema/context/spring-context-2.5.xsd\n\t    http://www.springframework.org/schema/aop\n\t    http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\">\n\t    \n\t    <!-- 无参数构造创建对象 -->\n\t    <bean id=\"operator\" class=\"cn.kofes.entity.UserOperatorXML\" />\n\t    <bean id=\"strengthenoperator\" class=\"cn.kofes.entity.strengthenUserOperator\" />\n\t    \n\t    <!-- 配置 AOP 操作 -->\n\t    <aop:config>\n\t        <!-- 配置切入点：匹配 UserOperator 类中所有方法 -->\n\t        <aop:pointcut id=\"pointcutA\" expression=\"execution( * cn.kofes.UserOperatorXML.*(..))\" />\n\t        <!-- 配置切面：把增强用到方法上面 -->\n\t        <aop:aspect ref=\"strengthenoperator\">\n\t            <!-- 配置增强类型\n\t             | Aop：增强类型有 before、after、arroud 等\n\t             | Method：增强类里面使用哪个方法作为前置\n\t            -->\n\t            <aop:before method=\"listAllOperatorType\" pointcut-ref=\"pointcutA\" />\n\t        </aop:aspect>\n\t    </aop:config>\n\t    \n\t</beans>\n\t```\n\t\n> (3) 操作基本流程 ( 注解方式 )：\n\n- 创建 Spring 配置文件 (在上述 applicationContext.xml 中追加)，XML 配置创建对象，并开启 AOP 操作：\n\n\t```xml\n\t<!-- 无参数构造创建对象 -->\n\t<bean id=\"strengthenoperator\" class=\"cn.kofes.entity.strengthenUserOperator\" />\n\t\n\t<!-- 开启 AOP 操作 -->\n\t<aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n\t```\n\t\n- 在增强类上面使用注解完成 AOP 操作：\n\n\t```java\n\t// strengthenUserOperator.java\n\t@Aspect\n\tpublic class strengthenUserOperator {\n\n\t    public strengthenUserOperator() { }\n\n\t    /**\n\t     * This's an aspect inserting to the method() the front.\n\t     */\n\t    public void listBeforeOperatorType() {\n\t        System.out.println(\"Inserting to the method() the front.\");\n\t    }\n\n\t    /**\n\t     * This's an aspect inserting to the method() the front and latter.\n\t     * @param proceedingJoinPoint 执行被增强的方法\n\t     * @throws Throwable\n\t     */\n\t    @Around(value=\"execution( * cn.kofes.entity.UserOperatorXML.*(..) )\")\n\t    public void listArroundOperatorType(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n\t        System.out.println(\"Inserting to the method() the front.\");\n\t        proceedingJoinPoint.proceed();\n\t        System.out.println(\"Inserting to the method() the latter.\");\n\t    }\n\t}\n\t```\n\n##### Spring 整合 Web 项目\n`诉求`：在 Spring 运作中，首先加载 Spring 核心配置文件，再创建对象。而创建对象可通过 New 的方式创建，但效率太低，则我们可以把加载配置文件和创建对象过程，在服务器启动时完成。\n\n###### 问题引入\n- Action 调用 Service，Service 调用 Dao。而每次 Action 时都会加载 Spring 配置文件，影响性能。\n\n###### 实现原理\n- ServletContext 对象\n- 监听器 (观察者模式)\n\n###### 操作简叙\n- 在服务器启动时，为每个项目创建一 ServletContext 对象；\n- 在 ServletContext 对象创建时，使用监听器监听 ServletContext 对象在什么时创建；\n- 监听到 ServletContext 对象创建时，加载 Spring 配置文件，把配置文件配对象创建；\n- 把创建的对象放置 ServletContext 域对象里；\n- 到 ServletContext 域中，通过 getAttribute() 方法获取对象。\n\n###### 具体实现\n- 在 `web.xml` 配置文件中添加监听器，并指定 Spring 配置文件 的位置。\n\n\t```xml\n\t<!-- 指定 Spring 配置文件 -->\n\t<context-param>\n\t    <param-name>contextConfigLocation</param-name>\n\t    <param-value>classpath:applicationContext.xml</param-value>\n\t</context-param>\n    \n\t<!-- 监听器模块 -->\n\t<listener>\n\t    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n\t</listener>\n\t```\n\n##### Spring JdbcTemplate 操作\n- Spring 对不同的持久化层技术都进行了封装：\n\t- `Jdbc`\n\t- `Hibernate 5.x`\n\t- `iBatis / MyBatis`\n\t- `JPA`\n- JdbcTemplate 对 Jdbc 进行了封装，以下为实际操作介绍。\n\n###### JdbcTemplate 增删改查\n\n- Step.01.创建对象，设置数据库信息\n- Step.02.创建 jdbcTemplate 对象，设置数据源\n- Step.03.调用 jdbcTemplate 对象，实现其中的方法实现增、删、改、查操作。\n \n\t```java\n\t// Jdbc 模板依赖连接池获得数据库连接，所以必须先构造连接池\n\tDriverManagerDataSource dataSource = new DriverManagerDataSource();\n\tdataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n\tdataSource.setUrl(\"jdbc:mysql://192.168.x.x/db_testdb\");\n\tdataSource.setUsername(\"root\");\n\tdataSource.setPassword(\"123456\");\n \n\t// 创建 Jdbc 模板\n\tJdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n \n\t// 建表 SQL 语句\n\tString sql_create = \"CREATE TABLE \" + \n\t\t\"t_user(id int primary key auto_increment, username varchar(20), password varchar(20))\";\n\tString sql_insert = \"INSERT INTO t_user VALUES(?, ?, ?)\";\n\tString sql_update = \"UPDATE t_user password = ? WHERE username = ?\";\n\tString sql_delete = \"DELETE FROM t_user WHERE username = ?\";\n\n\t// JdbcTemplate 实现增、删、改操作\n\tjdbcTemplate.execute(sql_create); \n\tjdbcTemplate.update(sql_insert, \"Lucy\", \"123456\"); \n\tjdbcTemplate.update(sql_update, \"Lucy\", \"abc123\");\n\tjdbcTemplate.update(sql_delete, \"Lucy\");\n\n\t/**\n\t * JdbcTemplate 实现查询操作，使用 RowMapper 接口，\n\t * 但 JdbcTemplate 没有针对这个接口提供实现类，得到不同的类型数据需要进行数据封装\n\t */\n\n\t// 查询返回某一个值 \n\tsql_select_certain = \"SELECT count(*) FROM t_user\";\n\t// args0：SQL 语句，args1：返回类型 Class\n\tjdbcTemplate.queryForObject(sql_select_certain, Integer.class);\n\t \n\t// 查询返回 list 集合\n\tsql_select_all = \"SELECT * FROM t_user\";\n\tList<User> list = jdbcTemplate.query( sql_select_all, new MyRowMapper() );\n\t\n\t// 查询返回 list 集合，需要创建类实现 RowMapper 接口\n\tpublic class MyRowMapper implements RowMapper<User> {\n\t    @Override\n\t    public User mapRow(ResultSet rs, int num) throws SQLExpection {\n\t        User user = new User();\n\t        user.setUsername( rs.getString(\"username\") );\n\t        user.setPassword( rs.getString(\"password\") );\n\t        return user;\n\t    }\n\t}\n \t```\n\n##### Spring 配置连接池\n- 创建 Spring 配置文件，配置连接池：\n\n\t```xml\n\t<!-- 为便于修改配置，可在根目录下新建文件 c3p0.properties，填写格式如下：\n\t | datasource.driverClass=com.mysql.jdbc.Driver\n\t | datasource.jdbcUrl=jdbc:mysql://192.168.x.x:3306/db_testdb?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC\n\t | datasource.user=root\n\t | ...\n\t-->\n\t<context:property-placeholder location=\"classpath:c3p0.properties\"/>\n\t\n\t<!-- Data Connection Setting -->\n\t<bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n\t    <!-- 引用 c3p0.properties 的键值对即可 -->\n\t    <property name=\"driverClass\" value=\"${datasource.driverClass}\"/>\n\t    <property name=\"jdbcUrl\" value=\"${datasource.jdbcUrl}\"/>\n\t    <property name=\"user\" value=\"${datasource.user}\"/>\n\t    <property name=\"password\" value=\"${datasource.password}\"/>\n\t    <!-- 设置数据库连接池的最大连接数 -->\n\t    <property name=\"maxPoolSize\" value=\"${datasource.maxPoolSize}\"/>\n\t    <!-- 设置数据库连接池的最小连接数 -->\n\t    <property name=\"minPoolSize\" value=\"${datasource.minPoolSize}\"/>\n\t    <!-- 设置数据库连接池的初始化连接数 -->\n\t    <property name=\"initialPoolSize\" value=\"${datasource.initialPoolSize}\"/>\n\t    <!-- 设置数据库连接池的连接最大空闲时间 -->\n\t    <property name=\"maxIdleTime\" value=\"${datasource.maxIdleTime}\"/>\n\t    <!-- c3p0缓存Statement的数量数 -->\n\t    <property name=\"maxStatements\" value=\"${datasource.maxStatements}\"/>\n\t    <!-- 当连接池的连接用完的，从 C3p0 下获取新的连接数 -->\n\t    <property name=\"acquireIncrement\" value=\"${datasource.acquireIncrement}\"/>\n\t    <property name=\"checkoutTimeout\" value=\"${datasource.checkoutTimeout}\"/>\n\t    <property name=\"idleConnectionTestPeriod\" value=\"${datasource.idleConnectionTestPeriod}\"/>\n\t</bean>\n\t\n\t<!-- JdbcTemplate 类中封装了 DataSource 类，以 XML 配置形式注解关系即可 -->\n\t<bean name=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n\t    <property name=\"dataSource\" ref=\"dataSource\" />\n\t</bean>\n\t```\n\t\n- 代码引用：\n\n\t```java\n\t@Resource(name = \"jdbcTemplate\")\n\tprivate JdbcTemplate jdbcTemplate;\n\t\n\tString sql = \"SELECT * FROM t_user\";\n\t    List<User> list = jdbcTemplate.query(sql, new MyRowMapper());\n\t}\n\t```\n\n##### Spring 事务管理\n\n###### 编程式事务管理\n此部分省略。\n\n######  声明式事务管理\n- 创建 Service 类和 Dao 类，再添加注入关系：  \n\t1) Service 层，又称业务逻辑层；  \n\t2) Dao 层，数据持久层，单纯对数据库进行操作.  \n\t\n- 引入问题：ServiceTest 类中制造的异常，即造成了转账的不一致问题，细节如下：\n\n\t```java\n\t// ServiceTest.java\n\tpublic class ServiceTest {\n\t\n\t    private DaoTest daotest;\n\t    \n\t    public void setDaotest(DaoTest daotest) {\n\t        this.daotest = daotest;\n\t    }\n\t    \n\t    /* @Transactional 注解方式时填写 */\n\t    public void executeUpdateInDB() {\n\t        GrowUp();\n\t        int exception = 10 / 0;\t// 人为制造异常\n\t        Dealth();\n\t    }\n\t    public void GrowUp() {\n\t        daotest.updateOneTuple(\"UPDATE t_user SET age=age+1 where username = ?\",\n\t        \tnew Object[]{\"诸葛亮\"}, new int[]{Types.VARCHAR});\n\t    }\n\t    public void Dealth(){\n\t        daotest.updateOneTuple(\"UPDATE t_user SET age=0 where username = ?\",\n\t        \tnew Object[]{\"诸葛亮\"}, new int[]{Types.VARCHAR});\n\t    }\n\t\n\t    }\n\t\n\t// DaoTest.java\n\tpublic class DaoTest {\n\t\n\t    private JdbcTemplate jdbcTemplate;\n\t    \n\t    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {\n\t        this.jdbcTemplate = jdbcTemplate;\n\t    }\n\t    \n\t    /**\n\t     * @param sql 插入元组的 SQL 语句\n\t     * @param obj 插入的属性值，与 SQL 中填写属性名的顺序相同\n\t     * @param types 对应属性值的数据类型\n\t     */\n\t    public void updateOneTuple(String sql, Object[] obj, int[] types) {\n\t        jdbcTemplate.update(sql, obj, types);\n\t    }\n\t}\n\t```\n\n- 基于 XML 配置文件形式实现 ( AOP 的思想 )\n\n\t> 目前为止，Spring 配置文件中约束添加完毕，以后配置复制此段即可。\n\n\t```xml\n\t<!-- 目前为止，Spring 配置文件中约束添加完毕，以后的程序复制此段即可 -->\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n\t    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n\t    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n\t    http://www.springframework.org/schema/context\n\t    http://www.springframework.org/schema/context/spring-context-2.5.xsd\n\t    http://www.springframework.org/schema/aop\n\t    http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\n\t    http://www.springframework.org/schema/tx\n\t    http://www.springframework.org/schema/tx/spring-tx-2.5.xsd\">\n\t    \n\t    <!-- set 方法注入属性 -->\n\t    <bean id=\"service\" class=\"cn.kofes.service.ServiceTest\">\n\t        <property name=\"daotest\" ref=\"dao\" />\n\t    </bean>\n\t    <bean id=\"dao\" class=\"cn.kofes.dao.DaoTest\">\n\t        <!-- 引用上例的 jdbcTemplate bean 即可 -->\n\t        <property name=\"jdbcTemplate\" ref=\"jdbcTemplate\" />\n\t    </bean>\n   \n\t    <!-- 配置事务管理器 -->\n\t    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t        <!-- 注入 dataSource  -->\n\t        <property name=\"dataSource\" ref=\"dataSource\" />\n\t    </bean>\n\n\t    <!-- 配置事务增强 -->\n\t    <tx:advice id=\"txadvice\" transaction-manager=\"transactionManager\">\n\t        <!-- 做事务操作 -->\n\t        <tx:attributes>\n\t            <!--\n\t             | 事务操作方法的匹配规则，若事务操作的方法有规范命名，可以简写为：\n\t             | <tx:method name=\"execute*\" />\n\t            -->\n\t            <tx:method name=\"executeTrading()\" />\n\t        </tx:attributes>\n\t    </tx:advice>\n\t    \n\t    <!-- 配置 AOP 操作 -->\n\t    <aop:config>\n\t        <!-- 切点 -->\n\t        <aop:pointcut id=\"poitncutB\" expression=\"execution( * cn.kofes.service.ServiceTest.executeTrading(..) )\" />\n\t        <!-- 切面 -->\n\t        <aop:advisor advice-ref=\"txadvice\" pointcut-ref=\"pointcutB\" />\n\t    </aop:config>\n\t    \n\t</beans>\n\t```\n\n- 基于注解形式实现\n\n\t在需要事务操作的类上配置注解 `@Transactional`，再配置 applicationContext.xml：\n\t\n\t```xml\n\t<!-- 在 applicationContext.xml 中配置事务管理器 -->\n\t<!-- 配置事务管理器 -->\n\t<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t    <!-- 注入 dataSource  -->\n\t    <property name=\"dataSource\" ref=\"dataSource\" />\n\t</bean>\n\t\n\t<!-- 开启注解事务 -->\n\t<tx:annotation-driven transaction-manager=\"transactionManager\" />\n\t```\n\n---\n\n#### Hibernate\n`数据持久层`，Hibernate 是一个开放源码的 `ORM` 持久层框架。简单的说，Hibernate 只是一个将持久化类与数据库表相映射的工具，`每个持久化类实例均对应于数据库表中的一个数据行而已`。用户只需直接使用面向对象的方法操作此持久化类实例，即可完成对数据库表数据的插入、删除、修改、读取等操作。\n\n##### Hibernate 配置\n- 使用配置文件将映射关系对应起来；\n\n\t```xml\n\t<!-- 配置文件命名规范：*.hbm.xml -->\n\n\t<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\t<!DOCTYPE hibernate-mapping PUBLIC \n\t    \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\t    \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n\t<hibernate-mapping>\n\t    <!--\n\t     | 配置类和表相对应：Class 标签\n\t     | name 属性：实体类全路径\n\t     | table 属性：数据库表名称\n\t    -->\n\t    <class name=\"cn.entity.User\" table=\"t_user\">          \n\t        <!--\n\t         | 配置实体类 ID 与表 ID 对应：ID 标签\n\t         | Hibernate 要求实体类有一个属性唯一值，且要求表有字段作为唯一值\n\t         | name 属性：实体类的 id 属性名称\n\t         | column 属性：生产的表字段名称\n\t        -->\n\t        <id name=\"uid\" column=\"uid\">\n\t            <!-- 设置数据库表 id 增长策略：Class 标签\n\t             | 属性有：increment、hilo、squence、identity、native、uuid、guid 等。\n\t            -->\n\t            <generator class=\"native\" />\n\t        </id>\n                    \n\t        <!-- 配置其他属性和表字段对应：Property 标签 -->\n\t        <!-- 若使用的是 SQL Server 数据库系统，Property 映射对的顺序要和数据库中列 (属性) 的顺序相对应 -->\n\t        <property name=\"username\" column=\"username\" type=\"string\" />\n\t        <property name=\"age\" column=\"age\" type=\"int\" />       \n\t    </class>\n\t</hibernate-mapping> \n\t```\n\t\n> 关于映射配置的一些批注：\n    \n- Note.01：就映射配置来说，这里千万要记住，若访问的是 SQL Server 数据库系统，则 **<property> 映射对的顺序要和数据库中列 (属性) 的顺序相对应**。( 其他数据库系统没有出现此类问题，鉴于阅读与编程的规范，则不管使用哪种数据库系统驱动，都以此种方式编辑 Property 映射对 )\n- Note.02：关于配置中实体类的主键生成策略有多种形式，详细见参考 [4]。\n- Note.03：User 实体类对象的状态：\n\t- `瞬时态`：对象没有 ID 值，且其与 Session 没有关联。\n\t- `持久态`：对象有 ID 值，且其与 Session 有关联。\n\t- `托管态`：对象有 ID 值，但其与 Session 没有关联。\n\n\t```Java\n\t/**\n\t * 下述代码只列举了细节不同的部分，其他细节见源代码\n\t */\n\tUser user = new User();\n            \n\t// 瞬时态：即插入元组\n\tuser.setUserName(\"Sample\");\n\tuser.setAge(25);\n\tsession.saveOrUpdate(user);\n\n\t// 托管态：对数据表中具体 ID 的元组进行数据修改，即更新元祖\n\tuser.setUid(attr_id);\n\tuser.setUserName(\"Sample\");\n\tuser.setAge(25);\n\tsession.saveOrUpdate(user);\n\t// session.save(user); // 注意：此操作为新增元组，但不是全部属性都修改，会引入空值\n            \n\t// 持久态：对数据表中具体 ID 的元组进行数据修改，即更新元祖\n\tuser = session.get(User.class, attr_id);\n\tuser.setUserName(\"Sample\");\n\tuser.setAge(25);\n\tsession.saveOrUpdate(user);\n            \n\t// 启示：从持久态和托管态态的实验结果可知，修改元组，先查再改，防止空值。\n\t```\n\n- 创建 Hibernate 的核心配置文件；\n        \n\t核心配置文件格式是 XML，且核心配置文件名称和位置是 `固定的` ( Src 根目录下，且名称为 `hibernate.cfg.xml` )。Hibernate 操作过程中，仅加载核心配置文件。\n\n\t```xml\n\t<!-- 配置文件命名规范：hibernate.cfg.xml -->\n                \n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<!DOCTYPE hibernate-configuration PUBLIC\n\t    \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n\t    \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\">\n    \n\t<hibernate-configuration>\n\t    <session-factory>\n\t        <!-- (必填) 配置数据库信息：从 hibernate.property 中获取 -->\n\t        <property name=\"hibernate.connection.driver_class\" value=\"com.mysql.jdbc.Driver\" />\n            \n\t        <!-- SQL Server 数据库管理系统的 Driver \n\t        <property name=\"hibernate.connection.driver_class\">com.microsoft.sqlserver.jdbc.SQLServerDriver</property>\n\t        <property name=\"hibernate.connection.url\">\n\t            jdbc:sqlserver://192.168.0.133:1433;DatabaseName=testDB\n\t        </property>\n\t        -->\n            \n\t        <!-- MySQL 数据库管理系统的 Driver -->\n\t        <property name=\"hibernate.connection.driver_class\">com.mysql.jdbc.Driver</property>\n\t        <property name=\"hibernate.connection.url\">\n\t            jdbc:mysql://192.168.0.163:3306/testDB?serverTimezone=UTC\n\t        </property>\n            \n\t        <property name=\"hibernate.connection.username\">sa</property>\n\t        <property name=\"hibernate.connection.password\">pztech753</property>\n                    \n\t        <!-- (可选) 配置 Hibernate 信息：从 hibernate.property 中获取 -->\n\t        <!-- 操作数据库时，向控制台输出 SQL 语句 -->\n\t        <property name=\"hibernate.show_sql\">true</property> \n\t        <!-- 操作数据库时，向控制台输出格式化的 SQL 语句 -->\n\t        <property name=\"hibernate.format_sql\">true</property>\n\t        <!-- Hibernate 配置自动建表：Update，有表更新没表建立 -->\n\t        <property name =\"hibernate.hbm2ddl.auto\">update</property>\n\t        <!-- \n\t         | 例如，实现分页功能：\n\t         | MySQL 里面使用 LIMIT 关键字，Oracle 中使用 ROWNUM 关键字\n\t         | 让 Hibernate 识别不同数据库中特有的语句\n\t        -->\n\t        <property name=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</property>\n                    \n\t        <!-- (必填) 把映射文件放到核心配置文件中 ( 填 Src 之后的路径 ) -->\n\t        <mapping resource=\"cn/entity/User.hbm.xml\" />\n\t    </session-factory>\n\t</hibernate-configuration>\n\t```\n\n> 关于核心配置的一些批注：\n\n> 面对不同的数据库管理系统，对应的配置属性也存在差异，详细见参考 [5]。\n            \n- 通过 Session 保存实体类数据到数据库表中；\n\n    简单演示，详细见下一章节：[Hibernate 使用](#Hibernate-使用)\n        \n    ```java\n    User user = new User();\n    user.setUsername(\"Lucy\");\n    user.setAge(25);\n    Session.save(user);\n    ```\n     \n##### Hibernate 使用\n- 以下代码为 Hibernate 最基本的使用方法，后续将通过优化 Configuration，以及规范事务来优化 Hibernate。\n\n\t```java\n\t// Step.01：加载 Hibernate 核心配置文件 hibernate.cfg.xml\n\tConfiguration cfg = new Configuration();\n\tcfg.configure();\n    \n\t// Step.02：创建 SessionFactory 对象；\n\t// 在此过程中，根据映射关系在数据库中把表创建起来\n\tSessionFactory sessionFactory = cfg.buildSessionFactory();\n\n\t// Step.03：使用 SessionFactory 创建 Session 对象；\n\tSession session = sessionFactory.openSession();\n\n\t// Step.04：手动开始事务；\n\tTransaction trans = session.beginTransaction();\n\n\t// Step.05：写具体逻辑，例如：增删改查；\n\t// 例如添加操作 ( 不操作数据表，而操作实体类 )\n\tUser user = new User();\n\tuser.setUsername(\"Lucy\");\n\tuser.setAge(25);\n\tsession.save(user);\n\n\t// Step.06：提交事务；\n\ttrans.commit();\n\n\t// Step.07：关闭资源；\n\tsession.close();\n\tsessionFactory.close();\n\t```\n\n- Configuration\n    - 到 Src 目录下加载核心配置文件 `hibernate.cfg.xml`；\n- SessionFactory\n    - 根据核心配置文件中数据库配置、映射配置，且根据映射关系，到数据库中把表创建起来。\n    - 创建 SessionFactory 过程中，特别消耗资源，故应该采取优化措施：\n    \n    在 Hibernate 操作中，建议一个项目创建一个 SessionFacotry 对象，以静态的工具类形式封装使用。  \n        \n\t```java\n\tpublic class HibernateUtils {\n\t\tprivate static Configuration cfg = null;\n\t\tprivate static SessionFactory sessionFactory = null;            \n\t\tstatic {\n\t\t    cfg = new Configuration();\n\t\t    cfg.configure();\n\t\t    sessionFactory = cfg.buildSessionFactory();\n\t\t}\n         \n\t\tpublic static SessionFactory getSessionFactory() {\n\t\t    return sessionFactory;\n\t\t}\n\t}\n\t```\n\n- Session\n    - 类似 Jdbc 中的 Connection，可调用 Session 中的不同方法实现 `增、删、改、查` 操作。 \n        - 增加：save()；\n        - 修改：update()；\n        - 删除：delete()；\n        - 查询：get()；\n    - Session 为单线程对象，即不能共用，仅自己使用。\n\t\t- Hibernate 已实现本地线程与 Session 的绑定：在 Hibernate 的核心配置文件中，再调用 sessionFactory 的方法得到。\n        \n\t\t```XML\n\t\t<property name=\"hibernate.current_session_context_class\">thread</property>\n\t\t```\n\n\t\t- 在 HibernateUtils 静态工具类中追加静态方法：\n \n\t\t```java\n\t\tpublic class HibernateUtils {\n\t\t    // 返回与本地线程绑定的 Session\n\t\t    public static Session getSessionObject() {\n\t\t    return sessionFactory.getCurrentSession();\n\t\t    }\n\t\t}\n        \n\t\t/* 在其他类中调用该方法 */\n\t\tSession session = HibernateUtils.getSessionObject();\n\t\t```\n\n- Transaction\n    - 事务概念；\n    - 事务特性：原子性、一致性、隔离性、持久性；\n\n        > 隔离性：不考虑隔离性会产生的问题，如脏读、不可重复读和虚读。当然，可以设置隔离的级别来解决问题。\n         \n    - Hibernate 使用 Transaction 创建事务对象；\n    - 事务的 commit() 与 rollback() 方法 ( `规范用法` )；\n\n\t```java\n\tSessionFactory sessionFactory = null;\n\tSession session = null;\n\tTransaction trans = nu\n\ttry {\n\t    sessionFactory = HibernateUtils.getSessionFactory()\n\t    session = sessionFactory.openSession();\n\t    // 开启事务\n\t    trans = session.beginTransaction();\n            \n\t    // 人为制造异常，被除数不能为零\n\t    User user = ne0w User();\n\t    user.setAge(50/0);\n\t    session.save(user);\n            \n\t    // 提交事务\n\t    trans.commit();\n\t} catch(Exception ex) {\n\t    // 发生异常\n\t    trans.rollback();\n\t} finally {\n\t    session.close();\n\t    sessionFactory.close();\n\t}\n\t```\n    \n##### Hibernate 优化\n\n###### Hibernate 缓存机制\n- 一级缓存：默认是打开的，其使用的范围为 Session 创建到关闭的范围，且存储数据必须为持久态数据。\n- 一级缓存的特性：持久态的数据会自动更新数据库 ( 不用 session.update(user)、session.save(user) )，过程细节如下：\n\n\t```java\n\t// Get() 操作后，将返回持久态对象 user 存于一级缓存中，\n\t// 及存一份到缓存中的快照区 (副本)。\n\tuser = session.get(User.class, attr_id);\n\t// setXXX() 操作，同时修改持久态对象的值和一级缓存中的内容。\n\tuser.setUserName(\"Sample\");\n\t// 当提交事务时，会比较一级缓存和快照区，\n\t// 若不相同，会触发更新数据库操作。\n\ttrans.commit();\n\t```\n        \n- 二级缓存 (替代技术：`redis` )：默认关闭，SessionFactroy 的使用范围。\n\n##### Hibernate 查询\n\n> 在 `Hibernate 查询方式` 小节将详细阐述。\n\n###### Query 对象\n\n> 推荐使用\n\n- 使用 Query 对象，不需要写 SQL 语句，以 HQL 替代。\n    \n    > HQL：Hibernate Query Language，有别于 SQL 语句，即：SQL 操作表和表字段，而 HQL 操作实体类和属性。\n    \n-  Query 对象的使用：\n    \n    ```java\n    // 创建 Query 对象\n    Query query = session.createQuery(\"from User\");\n    // 调用 query 对象的方法得到结果\n    List<User> list = query.list();\n    ```\n        \n###### Criteria 对象\n- Ceiteria 对象的使用： \n\n    ```java\n    // 创建 Criteria 对象　\n    Criteria criteria = session.createCriteria(User.class);\n    // 调用 criteria 对象的方法得到结果\n    List<User> list = criteria.list();\n    ```\n\n###### ~~SQLQuery 对象~~\n- SQLQuery 对象的使用：\n\n\t```java\n\t// 创建 SQLQuery 对象\n\tString sql = \"SELECT * FROM t_user t WHERE t.username= ? AND t.age = ?\";\n\tSQLQuery sqlQuery = session.createSQLQuery(sql)\n\t    .setParameter(0, \"ABC\").setParameter(1, 15);\n    \n\t// Case.01. 以数组形式接收结果\n\t// List<Object []> list = sqlQuery.list();\n    \n\t// Case.02. 返回目标的 User 对象 \n\tsqlQuery.addEntity(User.class);\n\tList<User> list = sqlQuery.list();\n\t```\n\t\n##### Hibernate 多表操作\n- 数据库的多表查询\n\t- 外键\n\t\t- 指定外键关键字： Foreign Key(列名)\n\t\t- 引用外键关键字： References <主表名>(主表主键)\n\t- 关系\n\t\t- 一对一\n\t\t- 一对多\n\t\t- 多对多\n\n###### 一对多操作\n- 一对多映射配置：`实体类配置`\n\t- 创建两个实体类，例如：公司和客户 ( 公司是一，客户是多 )；\n\t- 让两个实体类间互相表示；  \n    \n\t```java\n\t// 客户实体类\n\tpublic class Customer { \n\t    // 省略其他属性\n\t    // ...\n\t    \n\t    // 在客户实体类中表示所属公司，一个客户只属于一个公司\n\t    private Firm firm;\n\t   \n\t    public void setFirm(Firm firm) { this.frim = firm; }\n\t    public Firm getFirm() { return firm; }\n\t}\n    \n\t// 公司实体类\n\tpublic class Firm {\n\t    // 省略其他属性\n\t    // ...\n\t    \n\t    // Set 集合：无序，元素不可重复\n\t    private Set<Customer> customerSet = new HashSet<Customer>();    \n\t    public Set<Customer> getCustomerSet() { return customerSet; }\n\t    public void setCustomerSet(Set<Customer> customerSet) { this.customerSet = customerSet; }\n\t}\n\t```\n\t\t\t\t\n- 一对多映射配置：`XML 配置文件`，一个实体类对应一个映射文件，除了映射文件的基本配置之外，且要在映射文件中配置一对多的关系。\n\n\t```xml\n\t<!-- firm.bhm.xml -->\n\t<class name=\"cn.kofes.entity.Firm\" table=\"t_firm\">\n\t    <!-- \n\t     | 表示公司的所有客户\n\t     | Name 属性：属性值写公司实体类里表示客户 Set 集合的对象名称\n\t    -->\n\t    <set name=\"customerSet\">\n\t        <!--\n\t         | 一对多关系建表，有外键\n\t         | Hibernate 机制，双向维护外键，即在一和多方都配置外键\n\t         | Column 属性：属性值为外键的名称，名称可自定义\n\t        -->\n\t        <key column=\"f_fid\" />\n\t        <!-- 公司的所有客户，即 Class 里写客户实体类全路径 -->\n\t        <one-to-many class=\"cn.entity.Customer\" />\n\t    </set>\n\t</class>\n\n\t<!-- customer.bhm.xml -->\n\t<class name=\"cn.kofes.entity.Customer\" table=\"t_customer\">\n\t    <!--\n\t     | 表示客户所属公司\n\t     | Name 属性：客户实体类中使用 firm 对象表示\n\t     | Class 属性：Firm 实体类的全路径\n\t     | Column 属性：外键名称，名称可自定义\n\t    -->\n\t    <many-to-one name=\"firm\" class=\"cn.entity.Firm\" column=\"c_fid\" />\n\t</class>\n\t```\n\t\n- 核心配置文件中，加入 customer.bhm.xml 和 firm.bhm.xml。\n\n\t```xml\n\t<!-- (必填) 把映射文件放到核心配置文件中 ( 填 Src 之后的路径 ) -->\n\t<mapping resource=\"cn/entity/firm.hbm.xml\" />\n\t<mapping resource=\"cn/entity/customer.hbm.xml\" />\n\t```\n\t\n- 一对多级联的操作实现\n\n\t> 在原生数据库中，对包含外键的元组直接删除，是无法成功执行的。正确操作方式为：先删除外键约束，再删除对应元组。但在 Hibernate 中，不用考虑此类问题，因为内置封装了相关功能组件。\n    \n\t- 一对多级联的保存\n    \n\t```java\n\t// Step.01.建立公司对象和客户对象的关系\n\tFirm firm = new Firm();\n\tCustomer customer = new Customer();\n\t// Step.02.把客户对象放到公司对象的 Set 集合里\n\tfirm.getCustomerSet().add(customer);\n\t// Step.03.把公司对象放到客户对象里\n\tcustomer.setFirm(firm);\n\t\t\n\t/**\n\t * 级联保存：即一方和多方都需配置数据\n\t */\n    \n\tsession.save(customer);\n\tsession.save(firm);\n\t```\n\n\t- 一对多级联的删除：在一方 ( 与多方对立 ) 即公司对象，修改其配置文件。\n\n\t最后，直接在代码中进行删除操作即可。\n\n\t```xml\n\t<!-- firm.bhm.xml -->\n\t<class name=\"cn.kofes.entity.Firm\" table=\"t_firm\">\n\t    <!-- 对 Set 标签的 casade 值为 delete -->\n\t    <set name=\"customerSet\" cascade=\"delete\">\n\t        ...\n\t   </set>\n\t</class>\n\t```\n\t\n    \n- 优化步骤之 `Inverse 属性`\n\n\t> 因为 Hibernate 是双向维护外键，在公司和客户里面都需维护外键 ( 从级联删除的执行过程中可体验出来 )。故我们可以设置其中的一方 `放弃` 维护外键，以优化性能。\n\n\t```xml\n\t<!-- firm.bhm.xml -->\n\t<class name=\"cn.kofes.entity.Firm\" table=\"t_firm\">\n\t\t<!--\n\t\t | Inverse 属性\n\t\t | Flase，表示不放弃关系维护\n\t\t | True，表示放弃关系维护\n\t\t-->\n\t\t<set name=\"customerSet\" cascade=\"save-update, delete\" inverse=\"true\">\n\t\t\t...\n\t\t</set>\n\t</class>\n\t```\n\t\n###### 多对多操作\n- 多对多映射配置：实体类配置\n\t- 创建两个实体类，例如：用户和角色 ( 一个用户可扮演多个角色，一个角色可由多个用户扮演 )；\n\t- 让两个实体类间互相表示；  \n\n\t```java\n\t// 用户实体类\n\tpublic void User {\n\t\t// 省略其他属性\n\t\t// ...\n\t\tprivate Set<Role> roleSet = new HashSet<Role>();\n\t\tpublic Set<Role> getRoleSet() { return roleSet; }\n\t\tpublic void setRoleSet(Set{Role} roleSet) { this.roleSet = roleSet; }\n\t}\n\t\n\t// 角色实体类\n\tpublic void Role {\n\t\t// 省略其他属性\n\t\t// ...\n\t\tprivate Set<User> userSet = new HashSet<User>();\n\t\tpublic Set<User> getUserSet() { return userSet; }\n\t\tpublic void setUserSet(Set<User> userSet { this.userSet = userSet; }\n\t}\n\t```\n\t\n- 多对多映射配置：`XML 配置文件`，一个实体类对应一个映射文件，除了映射文件的基本配置之外，且要在映射文件中配置多对多的关系。\n\n\t```xml\n\t<!-- user.bhm.xml -->\n\t<class name=\"cn.kofes.entity.User\" table=\"t_user\">\n\t    <!--\n\t     | 在用户中，表示所有的角色\n\t     | Name 属性：属性值写用户实体类里表角色 Set 集合的对象名称\n\t     | Table 属性：填写多对多时，两实体的联系转化成表 ( 第三张表 )\n\t    -->\n\t    <set name=\"roleSet\" table=\"t_user_role\">\n\t        <!--\n\t         | 多对多关系建表，有外键\n\t         | Column 属性：当前用户实体，在第三张表中的外键名称 \n\t        -->\n\t        <key column=\"u_fid\" />\n\t        <!-- \n\t         | Class 属性：填写角色实体类全路径\n\t         | Column 属性：角色实体，在第三张表中的外键名称\n\t        -->\n\t        <many-to-many class=\"cn.entity.Role\" column=\"r_fid\" />\n\t    </set>\n\t</class>\n\t\n\t<!-- role.bhm.xml -->\n\t<class name=\"cn.kofes.entity.Role\" table=\"t_role\">\n\t    <!--\n\t     | 在角色中，表示所有的用户\n\t     | Name 属性：属性值写角色实体类里表示用户 Set 集合的对象名称\n\t     | Table 属性：填写多对多时，两实体的联系转化成表 ( 第三张表 )\n\t    -->\n\t    <set name=\"userSet\" table=\"t_user_role\">\n\t        <!--\n\t         | 多对多关系建表，有外键\n\t         | Column 属性：当前角色实体，在第三张表中外键的名称\n\t        -->\n\t        <key column=\"r_fid\" />\n\t        <!-- \n\t         | Class 属性：填写用户实体类全路径\n\t         | Column 属性：用户实体，在第三张表中外键的名称\n\t        -->\n\t        <many-to-many class=\"cn.entity.User\" column=\"u_fid\" />\n\t    </set>\n\t</class>\n\t```\n\t\n- 核心配置文件中，加入 customer.bhm.xml 和 firm.bhm.xml。\n\n\t```xml\n\t<!-- (必填) 把映射文件放到核心配置文件中 ( 填 Src 之后的路径 ) -->\n\t<mapping resource=\"cn/entity/user.hbm.xml\" />\n\t<mapping resource=\"cn/entity/role.hbm.xml\" />\n\t```\n\n- 多对多级联的操作实现\n\t- 多对多级联保存\n\n\t\t```java\n\t\t// 和一对多级联操作一样，在用户配置文件 user.hbm.xml 中，\n\t\t// 对 Set 标签的 casade 值为 save-update\n\t\n\t\t// 多对多级联保存\n\t\tUser user_1 = new User();\n\t\tUser user_2= new User();\n\t\tRole role_1 = new Role();\n\t\tRole role_2 = new Role();\n\t\tRole role_3 = new Role();\n\t\n\t\t// user_1 拥有角色 1、2，user_2 拥有角色 2、3\n\t\tuser_1.getRoleSet().add(role_1);\n\t\tuser_1.getRoleSet().add(role_2);\n\t\tuser_2.getRoleSet().add(role_2);\n\t\tuser_2.getRoleSet().add(role_3);\n\t\n\t\t// 保存用户即可 ( 对应于配置文件中设置了 casade 值的实体 )\n\t\tsession.save(user_1);\n\t\tsession.save(user_2);\n\t\t```\n\t- 多对多级联删除 ( 不推荐 )：配置文件；最后，直接在代码中进行删除操作即可。\n\n\t\t```xml\n\t\t// 和一对多级联操作一样，在用户配置文件 user.hbm.xml 中，\n\t\t// 对 Set 标签的 casade 值为 delete ( 可以与保存的属性共存 )\n\t\t<!-- user.bhm.xml -->\n\t\t<class name=\"cn.kofes.entity.User\" table=\"t_user\">\n\t\t    <set name=\"roleSet\" table=\"t_user_role\" casade=\"save-update, delete\">\n\t\t        ...\n\t\t    </set>\n\t\t</class>\n\t\t```\n\t- 维护多对多的关系，通过维护 `第三张表` ( 两实体的联系转化成的表 ) 实现。\n\n##### Hibernate HQL 查询详解\n\n-  `OID` 查询和 `对象导航` 查询 \n\n```java\n// 单元测试类\npublic class HibernateTest {\n    @Test\n    public void testSelect1() {\n        SessionFactory sessionFactory = null;\n        Session session = null;\n        Transaction trans = null;\n\t\t\n        try {\n            sessionFactory = HibernateUtils.getSessionFactory();\n            session = sessionFactory.openSession();\n            trans = session.beginTransaction();\n\t\t\t\n            // 需求：根据 ID 查询某个公司，再查询这个公司的所有客户\n\t\n            // OID 查询：查询 ID 为 1 的公司\n            Firm firm = session.get(Firm.class, 1); // \n            // 对象导航查询：根据某条记录的 ID，返回对象 (公司的客户)\n            Set<Customer> customer = firm.getCustomerSet();\n            System.out.print( customer.toString() );\n\n            trans.commit();\n        } catch(Exception ex) {\n            e.printStackTrace();\n            transaction.rollback();\n        } finally {\n            session.close();\n            sessionFactory.close();\n        }\t\n    }\t\n}\n```\n\n###### HQL 查询\n\n```java\n// Step.01.创建 Query 对象，写 HQL 语句实现查询\n// Step.02.调用 query 对象的方法得到结果\n\n// 查询所有\nQuery query = session.createQuery(\"FROM t_user\");\nList<User> list = query.list();\n\n// 条件查询\nString sql_obscure = \"FROM t_user WHERE username LIKE ?\"; // 模糊查询\nString sql_accurate = \"FROM t_user WHERE age = ? AND username = ?\"; // 精确查询\nQuery query = session.createQuery(sql_accurate);\n// arg0 为占位符位置，arg1 为参数\nquery.setParameter(0, 25).setParameter(1, \"Lucy\");\nList<User> list = query.list();\n\n// 排序查询：ASC，升序 / DESC，降序\nString sql = \"FROM t_user ORDER BY uid ASC\"; \nQuery query = session.createQuery(sql);\nList<User> list = query.list();\n\n// 分页查询：LIMIT 关键字\nString sql = \"FROM t_user\";\nQuery query = session.createQuery(sql);\nquery.setFirstResult(0);\nquery,.setMaxResults(10);\nList<User> list = query.list();\n\n// 投影查询\nString sql = \"SELECT username, age FROM t_user\";\nQuery query = session.createQuery(sql);\nList<Object> list = query.list();\n\n// 聚集函数\n// COUNT()、SUM()、MAX()、MIN()...\nString sql = \"SELECT COUNT(*) FROM t_user\";\nQuery query = session.createQuery(sql);\n// 将结果以对象形式返回\nObject obj = query.uniqueResult();\n```\n\n###### HQL 多表查询\n- 内连接：连接两个表有关联的数据，忽略两个表中对应不起来的数据。\n\t- SQL：SELECT * FROM t_user AS u, t_role AS r ON  u.uid = r.uid;\n \t- 或者：SELECT * FROM t_user u INNER JOIN t_role r ON  u.uid = r.uid;\n\n- 左外链接：左边表所有元组，右边表关联数据。\n\t- 若左表与右表没有关联数据，则右边表数据补 NULL 值，多了则删除\n\t- SQL：SELECT * FROM t_user u LEFT OUTER JOIN t_role r ON  u.uid = r.uid;\n- 右外链接：与左外链接同理。\n\n```java\n// HQL 内连接 ( 左、右外链接同理 )\nString sql_inner_join = \"FROM t_user u INNER JOIN u.roleSet\";\nQuery query = session.createQuery(sql_inner_join);\nList list = query.list(); // list 返回的每部分都是数组\n\n// HQL 迫切内连接\nString sql_inner_join_fetch = \"FROM t_user u INNER JOIN FETCH u.roleSet\";\nQuery query = session.createQuery(sql_inner_join_fetch);\nList list = query.list();  // list 返回的每部分都是对象\n\n// HQL 迫切左外连接  ( 没有迫切右外连接 )\nString sql_inner_join_fetch = \"FROM t_user u LEFT OUTER JOIN FETCH u.roleSet\";\n```\n\n##### Hibernate 检索策略\n\n###### 立即查询\n根据 ID 查询，调用 get() 方法，则马上发送语句查询数据库。\n\n```java\n// Debug 方式可检验，即执行代码马上发送 SQL 语句\nUser user = session.get(User.class, 1);\n```\n\n###### 延迟查询\n根据 ID 查询，调用 load() 方法，不会马上发送语句查询数据库，只有得到对象的值时，才发送语句查询数据库。\n\n```java\n// 调用 load() 方法之后，并不会马上发送 SQL 语句\nUser user = session.load(User.class, 1);\nSystem.out.println( user.getUid() );\n// 当得到对象里其他值时，即非 ID 值，才发送 SQL 语句进行查询\nSystem.out.println( user.getUsername() );\n```\n\n- 类级别延迟：例如，根据 ID 查询返回实体类对象，调用 load() 方法不会马上发送 SQL 语句。 \n-  关联级别查询：例如上述 `对象导航查询`，查询某个公司后，再查询这间公司的所有客户，查询公司所有客户的过程是否需要延迟，则称其为关联级别延迟。\n\n\t```xml\n\t<!-- \n\t | 在配置文件中实现关联级别延迟\n\t | fetch 属性：select\n\t | lazy 属性：true / false / extra\n\t | \t- True，当得到对象里其他值时，即非 ID 值，才发送 SQL 语句进行查询。\n\t | \t- False，反之，会多执行一次查询 ( getUid() )。\n\t | \t- Extra，需要什么属性，查询什么属性 ( 仅需少量属性时推荐使用 )\n\t-->\n\t<class name=\"cn.kofes.entity.User\" table=\"t_user\">\n\t    <set name=\"roleSet\" table=\"t_user_role\" fetch=\"select\" lazy=\"true\" >\n\t        ...\n\t    </set>\n\t</class>\n\t```\n\t\n###### 批量抓取\n- 例如，我们需要查询所有公司的所有客户，代码实现如下：\n\t\n\t```java\n\tCriteria criteria = session.createCriteria(User.class);\n\tList<Firm> list = criteria.list();\n\tfor(Firm firm : list) {\n\t    System.out.println( firm.getId() + \":\" + firm.getName() );\n\t    Set<Customer> customerSet = firm.getCustomerSet();\n\t    for(Customer customer : customerSet) {\n\t        System.out.println( customer.getUid() + \":\" + customer.getUsername() );\n\t    }\n\t}\n\t\n\t// 但在执行过程中，暴露的问题时：每次循环都执行一次查询，拖沓性能\n\t```\n\t\n- 故我们只需要在实体映射配置文件中，对 Set 标签进行设置属性即可：\n\n\t```xml\n\t<!-- firm.bhm.xml -->\n\t<class name=\"cn.kofes.entity.Firm\" table=\"t_firm\">\n\t    <!-- batch-size 的值为整数即可 -->\n\t    <set name=\"customerSet\" batch-size=\"10\">\n\t        ...\n\t    </set>\n\t</class>\n\t```\n\t\n---\n\n#### SSH 框架总结\n\n##### Struts\n- Action 操作\n\t- Action 创建 (三种方式)：继承 `ActionSupport` 类。\n\t- Action 访问路径：创建 `struts.xml` 配置文件，文件名称和位置 ( Src 目录 ) 固定。\n\t- 访问 Action 的多个方法：使用 `通配符方式` 配置。\n\t- Action 获取表单提交数据：\n\t\t- 获取 Request 对象 ( 使用 `ServletAction` 类 )；\n\t\t- 属性封装；\n\t\t- 模型驱动；\n\t- Action 操作域对象：使用 `ServletAction` 类。\n\t- 配置 Struts2 过滤器。\n- 值栈\n\t- 向值栈放数据：\n\t\t- Set 方法；\n\t\t- Push 方法；\n\t\t- 定义变量，生成 Get 方法.\n\t- 从值栈获取数据：在 JSP 中使用 Struts2 标签 + Ognl 获取\n\t\t- `<s:property />`\n\t\t- `<s:iterator />`\n- 拦截器\n\t- AOP 和责任链模式；\n\t- 自定义拦截器：\n\t\t- 继承 `MethodFilterInterceptor` 类，并重写类方法；\n\t\t- 配置拦截器和 Action 关联.\n\n##### Spring\n- Spring 核心配置文件：\n\t- 名称和位置没有固定要求；\n\t- 在 Spring 核心配置文件中引入 Schema 约束.\n- 创建对象：\n\t- XML 配置方式：`<bean id=\"\" class=\"\" />`；\n\t- 注解方式：`@Component` 或 `@Controller` (Web层)、`@Service` (业务层)、`@Repository` (持久层).\n- 注入属性:\n\t- XML 配置方式：`<bean id=\"\" class=\"\"><property name=\"\" ref=\"\" /></bean>`；\n\t- 注解方式：`@autowired`、`@Resource(name=\"value\")`.\n- 使用 ServletContext 对象和监听器实现\n\t- 在服务器启动时，加载 Spring 配置文件，创建对象；\n\t- 配置 Spring 的监听器；\n\t- 指定 Spring 配置文件位置.\n- Spring JdbcTemplate \n- Spring 事务配置：\n\t- XML 配置方式；\n\t- 注解方式：`@Transational`\n\n##### Hibernate\n- ORM 思想：`对象关系映射`，参考 [ORM 框架](#ORM-框架)；\n- 数据库信息配置：MySQL / SQL Server 2008 R2；\n- Hibernate 信息配置：即配置 Hibernate 核心配置文件 ( `hibernate.cfg.xml` )。\n\n\t> Hibernate 和 Spring 整合时，配置文件的名称和位置是没有固定要求的。\n\t\n- 映射关系配置：即配置 Hibernate 映射配置文件 ( `xxx.hbm.xml` )，实体类和数据表映射关系 ( 使用 ORM 思想 )。\n- Hibernate 操作步骤：Spring 框架对 Hibernate 框架也有封装，即 `HibernateTemplate` 类。\n\n#### SSH 框架整合\n\n![SSH框架整合思想](/images/illustration/Project/2018/08/J2EE-SSH-SSI-1_6-4.png)\n<center>图 6-4 SSH 框架整合思想</center>\n\n- Spring 与 Struts 2 框架的整合\n\t\n\t把 Struts 2 的 Action 对象创建交给 Spring 进行管理。\n\n\t```xml\n\t<bean id=\"\" class=\"\" scope=\"prototype\" />\n\t```\n\n- Spring 与 Hibernate 框架的整合\n\n\t把 Hibernate 的核心配置文件里的数据库配置，直接写在 Spring 配置文件中。且把 SessionFactory 对象创建交给 Spring 管理。\n\t\n#### SSH 整合演示\n\n##### Spring 与 Struts 2 整合\n\n- Action 代码实现：\n\n\t```java\n\t// cn.kofes.dao.BaseAction.java\n\t\n\tpublic class BaseAction extends ActionSupport {\n\t    @Override\n\t    public String execute() throws Exception {\n\t        System.out.println(\"The portion of action has deployed successfully.\");\n\t        return NONE;\n\t    }\n\t}\n\t```\n\t\n- 在 Spring  配置文件下整合 Struts：\n\n\t```xml\n\t<!-- spring.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n\t    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n\t    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n\t    http://www.springframework.org/schema/context\n\t    http://www.springframework.org/schema/context/spring-context-2.5.xsd\n\t    http://www.springframework.org/schema/aop\n\t    http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\n\t    http://www.springframework.org/schema/tx\n\t    http://www.springframework.org/schema/tx/spring-tx-2.5.xsd\">\n\n\t    <!-- 整合 Struts：Action 对象的配置 -->\n\t    <bean id=\"BaseAction\" class=\"cn.kofes.action.BaseAction\" scope=\"prototype\"/>\n\t    \n\t</beans>\n\t```\n\n- 整合 Web，当服务器启动时加载 Spring 配置即初始化，我们需要在 web.xml 下配置监听器：\n\n\t```xml\n\t<!-- web.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n\t    version=\"4.0\">\n\t    \n\t    <!-- 加载 Spring 的配置文件 -->\n\t    <context-param>\n\t        <param-name>contextConfigLocation</param-name>\n\t        <param-value>classpath:spring.xml</param-value>\n\t    </context-param>\n\n\t    <!-- 监听器模块：作用就是启动 Web 容器时,自动装配 spring.xml 文件的配置信息 -->\n\t    <listener>\n\t        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n\t    </listener>\n\n\t    <!-- 过滤器模块 -->\n\t    <filter>\n\t        <filter-name>struts2</filter-name>\n\t        <filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>\n\t    </filter>\n\t    <filter-mapping>\n\t        <filter-name>struts2</filter-name>\n\t        <url-pattern>/*</url-pattern>\n\t    </filter-mapping>\n\n\t    <welcome-file-list>\n\t        <welcome-file>index.jsp</welcome-file>\n\t    </welcome-file-list>\n\t\n\t</web-app>\n\t```\n\t\n- 最后，struts.xml 填入以下配置即可：\n\n\t```xml\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<!DOCTYPE struts PUBLIC\n\t    \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\"\n\t    \"http://struts.apache.org/dtds/struts-2.3.dtd\">\n\n\t<struts>\n\t    <package name=\"sample\" extends=\"struts-default\" namespace=\"/\">\n\t        <!--\n\t         | Class 属性值不写目标 Action 的全路径，原因是防止二次创建对象\n\t         | 引入 Spring 相对应  Action 的 Bean 标签 ID\n\t        -->\n\t        <action name=\"BaseAction\" class=\"BaseAction\" />\n\t    </package>\n\t</struts>\n\t```\n\n##### Spring 与 Hibernate 整合\n\n- 在 Spring  配置文件下配置数据库信息，及整合 Hibernate。后者即将 SessionFacotry 交由 Spring 管理：\n\n\t> `c3p0.properties` 和 `hibernate.properties` 配置文件位于 Src 根目录下，键值分离以便以后修改配置。\n\n\t```xml\n\t<!-- spring.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n\t    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n\t    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n\t    http://www.springframework.org/schema/context\n\t    http://www.springframework.org/schema/context/spring-context-2.5.xsd\n\t    http://www.springframework.org/schema/aop\n\t    http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\n\t    http://www.springframework.org/schema/tx\n\t    http://www.springframework.org/schema/tx/spring-tx-2.5.xsd\">\n\n\t    <!-- 在根目录下新建文件 c3p0.properties，存储数据库连接信息 -->\n\t    <context:property-placeholder location=\"classpath:c3p0.properties\"/>\n\n\t    <!-- Data Connection Settings -->\n\t    <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n\t        <!-- 引用 c3p0.properties 的键值对即可，格式如 ${key.value} -->\n\t        <property name=\"driverClass\" value=\"${datasource.driverClass}\"/>\n\t        <property name=\"jdbcUrl\" value=\"${datasource.jdbcUrl}\"/>\n\t        <property name=\"user\" value=\"${datasource.user}\"/>\n\t        <property name=\"password\" value=\"${datasource.password}\"/>\n\t        <!-- 设置数据库连接池的最大连接数 -->\n\t        <property name=\"maxPoolSize\" value=\"${datasource.maxPoolSize}\"/>\n\t        <!-- 设置数据库连接池的最小连接数 -->\n\t        <property name=\"minPoolSize\" value=\"${datasource.minPoolSize}\"/>\n\t        <!-- 设置数据库连接池的初始化连接数 -->\n\t        <property name=\"initialPoolSize\" value=\"${datasource.initialPoolSize}\"/>\n\t        <!-- 设置数据库连接池的连接最大空闲时间 -->\n\t        <property name=\"maxIdleTime\" value=\"${datasource.maxIdleTime}\"/>\n\t        <!-- c3p0缓存Statement的数量数 -->\n\t        <property name=\"maxStatements\" value=\"${datasource.maxStatements}\"/>\n\t        <!-- 当连接池的连接用完的，从 C3p0 下获取新的连接数 -->\n\t        <property name=\"acquireIncrement\" value=\"${datasource.acquireIncrement}\"/>\n\t        <property name=\"checkoutTimeout\" value=\"${datasource.checkoutTimeout}\"/>\n\t        <property name=\"idleConnectionTestPeriod\" value=\"${datasource.idleConnectionTestPeriod}\"/>\n\t    </bean>\n\t    \n\t    <!-- 整合 Hibernate：SessionFactory 对象的配置 -->\n\t    <bean id=\"sessionFactory\"\n\t        class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\">\n\t        <!-- (必填信息) 指定数据库 -->\n\t        <property name=\"dataSource\" ref=\"dataSource\" />\n\t        <!-- (可选信息) 配置 Hibernate 信息 -->\n\t        <property name=\"hibernateProperties\" value=\"classpath:hibernate.properties\" />\n\t        <!-- (必填信息) 把映射文件放到核心配置文件中 ( 现直接加载到 LocalSessionFactoryBean 类中即可 )  -->\n\t        <property name=\"mappingResources\">\n\t            <list>\n\t                <value>mapper/sample.hbm.xml</value>\n\t            </list>\n\t        </property>\n\t    </bean>\n\n\t</beans>\n\t```\n\n- 创建实体类：\n\n\t```java\n\t// Employee.java\n\tpublic class Sample { ... }\t\n\n\t```\n\t\n- 创建实体类映射文件 ( 文件位置没有固定要求，建议统一文件夹存储 )：\n\n\t```xml\n\t<!-- src/resource/HbmCollection/sample.hbm.xml -->\n\t\n\t<?xml version='1.0' encoding='UTF-8'?>\n\t<!DOCTYPE hibernate-mapping PUBLIC\n\t    \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\t    \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n\t    \n\t<hibernate-mapping>\n\t    <!--\n\t     | name 属性：实体类全路径\n\t     | table 属性：数据库表名称\n\t    -->\n\t    <class name=\"cn.kofes.bean.Sample\" table=\"t_sample\">\n\t        <!--\n\t         | Hibernate 要求实体类有一个属性唯一值，且要求表有字段作为唯一值\n\t         | name 属性：实体类的 id 属性名称\n\t         | column 属性：数据表字段名称\n\t        -->\n\t        <id name=\"id\" column=\"id\">\n\t            <!-- 设置数据库表 id 增长策略：Class 标签\n\t             | 属性值：increment、hilo、squence、identity、native、uuid、guid 等。\n\t            -->\n\t            <generator class=\"native\"/>\n\t        </id>\n\n\t        <!-- 配置其他属性和表字段对应：Property 标签 -->\n\t        <property name=\"name\" column=\"name\" type=\"string\"/>\n\t    </class> \n\t</hibernate-mapping>\n\t```\n\n- 在 `核心配置文件` 中引入 `映射配置文件`：\n\n\t> 在 Spring 配置文件中已引入映射配置文件，故不需要再单独配置 `hibernate.cfg.xml`。\n\t\n- 事务配置：在 spring.xml 配置文件中配置并开始事务注解，再到 Service 层添加注解 `@Transactional`： \n\n\t```xml\n\t<!-- 配置事务管理器 -->\n\t<bean id=\"transactionManager\"\n\t    class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\">\n\t    <property name=\"sessionFactory\" ref=\"sessionFactory\"/>\n\t</bean>\n\n\t<!--  开始事务注解 -->\n\t<tx:annotation-driven transaction-manager=\"transactionManager\" />\n\t```\n\n##### Spring 分模块开发\n\n- 在 Spring 里配置多个内容，容易造成配置混乱，不利于维护。\n- 把 Spring 核心配置文件中，将一部分配置放到单独的配置文件中，再在 Spring 核心配置文件中引入单独配置文件。\n\n\t```xml\n\t<!-- \n\t | 将原 Spring 中的部分配置放置到独立 xml 中，\n\t | 例如我把 Dao 层的配置独立出来，再到 spring.xml 中引入配置文件 dao.xml 即可。\n\t-->\n\t<import resource=\"classpath:dao.xml\" />\n\t```\n\t\n##### SSH 框架使用演示\n\nSSH 整合工作告一段落，当然你可通过 Maven 打包工程，以便以后复用。\n\n\n### SSM 框架\n\n> 当然，随着框架技术的迭代更新，更加科学、合理的新框架也逐渐在项目中使用起来，如 SSM 框架。具体细节可参考：[Java EE 之 SSM 框架配置与使用](https://www.kofes.cn/2018/08/J2EE-SSM-1.html)\n\n- `SSM 框架`：Spring MVC、Spring、MyBatis\n\n\tSSM ( Spring + SpringMVC + MyBatis ) 框架集由 Spring、SpringMVC、MyBatis 三个开源框架整合而成，常作为数据源较简单的 Web 项目的框架。\n\n- `Spring`：是一个轻量级的控制反转 (IoC) 和面向切面 (AOP) 的容器框架。\n\n\t> 与本文的 Spring 章节内容相同。\n\n- `SpringMVC`：分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。\n- `Mybatis`：[Mybatis](http://blog.mybatis.org/) 是一个支持普通SQL查询，存储过程和高级映射的优秀持久层框架。它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs (Plain Old Java Objects，普通的 Java对象 ) 映射成数据库中的记录。\n\n##参考资料 \n\n- \\[1\\] [ 一枪尽骚 · 魂. 基于全注解方式的SSH基础框架. csdn.net](https://blog.csdn.net/u012377333/article/details/50037825)\n- \\[2\\] [刻下岁月. IntelliJ IDEA 2016.1.2 + Spring + Struts2 + Hibernate ( SSH ). lunhui.ren](http://blog.lunhui.ren/archives/225) \n- \\[3\\] [kent. JavaEE SSH 三大框架整合 ( Spring + Struts2 + Hibernate ). cnblogs.com](https://www.cnblogs.com/xieyupeng/p/7108141.html)\n- \\[4\\] [Starskyhu. Hibernate 各种主键生成策略与配置详解. cnblogs.cn](https://www.cnblogs.com/hoobey/p/5508992.html)\n- \\[5\\] [陈铁锋. Hibernate 连接三种数据库的配置 ( SQL Server、Oracle、MySQL ). csdn.net](https://blog.csdn.net/chentiefeng521/article/details/58775415)\n- \\[6\\] [RoadOfStudy. MySQL 5.7版本的root用户重置密码问题. cnbolgs.com](https://www.cnblogs.com/roadofstudy/p/7446690.html)\n- \\[7\\] [Time Tries All. MySQL 重置密码出现的一系列问题. csdn.net](https://blog.csdn.net/time_tries_all/article/details/78571984)\n- \\[8\\] [Souvc. 连接虚拟机 (Ubuntu16.04) 的 MySQL 服务器. souvc.com](http://www.souvc.com/?p=915)","tags":["Struts"],"categories":["Project"]},{"title":"论文 | 从商用车队的 GPS 数据中归类车辆停留意图信息","url":"/2018/06/Stop-purpose-classification-from-GPS-data-of-commercial-vehicle-fleets.html","content":"\n{% note default %}\n原文：Stop purpose classification from GPS data of commercial vehicle fleets\n作者：Sarti L, Bravi L, Sambo F.    \n来源：Data Mining Workshops, 2017 IEEE International Conference on. IEEE, 2017: 280-287.  \n{% endnote %}\n\n## 摘要\n\n从原始 GPS (全球定位系统) 数据中提取 `汽车停靠意图数据` 是大多数位置感知应用程序中的关键任务，且随着从移动设备收集 GPS 数据的不断增长，这项任务变得越来越有趣。近期很多研究都集中在行人 (手机) 数据上 (可理解为红海市场)，而商用车领域几乎没有探索 (蓝海市场)。\n\n在本论文中，针对车辆 GPS 数据的汽车停靠意图的 `识别` 和 `分类` 问题 (利用来自不同行业的商业车队的大型异构数据集)。按照意图分类，旨在把汽车停靠点分为：`工作相关` 和 `非工作相关`，以挖掘相关商业价值。\n\n且还对每个汽车停靠点计算一组含 100 个不同特征的集合，特征可分为四个主要类别：`汽车停靠点特征`，`兴趣点特征`，`汽车停靠点集群特征` 和 `序列特征`。并通过随机森林分类模型，评估四组特征中每个特征对停靠点的相对重要性，以处理不同类型的问题。\n\n实验结果表明，本论文的方法显着地超越了现有商业车辆背景下用于汽车停靠意图的分类模型。\n\n<!-- More -->\n\n## 正文\n\n### 引入\n在过去的十年中，GPS 设备的巨大推广，使得人们越发关注 `数据挖掘算法` 在 `时空数据` (GPS 产生的数据) 中的应用。而许多实际应用需要使用关于用户行为和地理位置的语义信息。例如，下述的两个实例：\n\n- 基于用户的历史位置以衡量用户之间的相似度 $^{[1]}$；\n- 基于位置的兴趣地点推荐系统 $^{[2]}$。\n\n语义标记 GPS 数据，目标旨在 `识别` 和 `归类` GPS 沿途轨迹上的位置信息，即具体工作有 `语义位置的侦察` 和 `汽车停靠或出游的意图识别`。尽管上述问题不是同一类型的问题，但却是强相关的。例如，对多个用户而言具有相同意图的共同定位点，可能是语义上相关联的地方，因为知道某个地方的语义对分类每个汽车停靠点意图有很大的帮助。\n\n通常，对于上述 `识别` 和 `归类` 问题的解决方法分两个阶段执行：\n\n- `侦查兴趣地点`：通常以非监督的方式实现位置侦查 $^{[3,4]}$，而作者提出了基于 `DBSCAN` $^{[5\\,or\\,6]}$ 的修改版本的聚类算法，即利用层次聚类从汽车停靠位置中提取访问点。\n\n\t> 当要处理非常大的数据集时需要考虑计算性能的问题，可参考其他论文中的扩展方法，例如对地点坐标进行哈希散列法 $^{[7,8]}$。\n\n- `对侦查到的地点分类`：对有关地点或汽车停靠点进行分类，可以在文献中找到两种主要方法：\n\t- 基于规则的系统 $^{[9,10]}$，其主要依赖于活动的位置、土地利用的数据以及机器学习方法，即活动本身提取特征；\n\t- 利用 SVM 分类器来区分标识位置内的活动停靠点和非活动停靠点。分类器 (SVM，随机森林或逻辑回归) 利用时间和空间特征 $^{[6]}$，以及隐马尔可夫模型 (HMM) 利用时序特征把这些汽车停靠点分类为预定义类型。\n\n        > 1) SVM 提取三个主要特征：停车驻留时间，每个汽车停靠地段周围的点到质心的平均距离。    \n        > 2) 地点的语义分类是基于GPS数据和卫星图像的组合而定的 $^{[8]}$。  \n\t\n最后说明，本论文解决了与参考文献 [7] 的同样问题，即利用四个不同的特征集，使用一个随机森林分类器，对商业车队的汽车停靠意图数据进行分类。且本文的主要贡献如下：\n\n- 描述了一种方法，即从 GPS Pings (GPS 定位仪) 中提取汽车停靠点信息，并从工作状态停车点一览表 (已知的地点信息) 中給它们分配地面实况标签 (贴标签);\n- 基于带标签的数据集，建立了一个模型，可以自动分类汽车停靠点，即工作状态和非工作状态的停靠点;\n- 提供了严格评估的多类型特征集，便于我们处理不同问题，其中包括：\n\t- 汽车停靠点特征 (Stop-wise features，SWF)；\n\t- 兴趣点特征 (Points of interest features，POIF)；\n\t- 停靠点集群特征 (Stop Cluster，CF)；\n\t- 序列特征 (Sequential features，SeqF).\n\n### 方法\n\n#### GPS和工单数据\n- 本论文采用的数据集由 Fleetmatics 公司 (车队情报公司) 提供。\n- 采集的数据有两种类型，分别是`原始 GPS pings 数据` 和 `工单数据`。\n\t- 原始 GPS Pings 数据\n\t\t- 提供有关车辆位置的信息，工单状态的信息，有关司机执行的工作进度及进度信息；\n\t\t- 设定有一系列的 GPS Pings $\\{P_i\\}_{i=1}^n = \\{P_1, ..., P_n\\}$ 分别描述每辆车行驶的路线。\n\t\t- 每一个 GPS Ping $P_i$ 包含每辆车的状态信息，即有车辆 ID $v_i$，经度和纬度 (位置信息 $p_i$)，里程表 $d_i$，时间戳 $t_i$ 和 事件代码 $e_i$。\n\t- 工单数据\n\t\t- 设定有一系列的工单 $\\{W_i\\}_{i=1}^n = \\{W_1, ..., W_n\\}$。\n\t\t- 每一个工单包含的信息有：车辆 ID $v_i$，经度和纬度 (位置 $p_i$)，时间戳 $t_i$ 和 状态代码 $c_i$ (例如：挂起，启动，完成)。\n\n#### 车辆停靠侦查技术\n正如上述所描述的，关于瞬时车辆位置的原始数据是由 GPS Ping 组成的，将它们汇集起来以描述车辆的活动。为此本论文开发了一个 `时空聚类程序`。\n\n- 首先得为每个 GPS 信息分配一种状态类型 (Engine off，iDling，Journey)，然后把它们聚集成 GPS Ping 群组，并把这个 GPS Ping 群组称为 `汽车停靠点集`。\n- GPS Ping 的状态可分为三种类型：\n\t- `Engine Off (发动机关闭状态)`：发动机关闭事件。即这些 Ping 在发动机关闭的瞬间产生的 (当发动机处于关闭状态时不发送 Ping);\n\t- `iDling (空转/怠速状态)`：发动机处于开启状态，但车辆静止或车辆在小区域内仍然缓慢行驶。对于后者，我们还需要作一些约束，设定 $H(p_i,p_{i-1})$ 表示两点间的半正定距离。然后，对于给定车辆给予一对连续的 Ping $P_{i-1}\\,and\\,P_i$，且满足以下约束，则可定义为怠速：\n\t\t- $s_i = H(p_i,p_{i-1})\\,/\\,(t_i - t_{i-1}) \\leq 1.4\\,m/s\\,(5km/h)$，确定速度接近零；\n\t\t- $H(p_i,p_{i-1}) \\leq 150\\,m$，确保 $P_{i-1}\\,and\\,P_i$ 足够接近，且避免了由于丢失数据而产生的 `伪影`。\n\t- `Journey (行驶状态)`：即不是发动机关闭状态，也不是怠速状态。\n- 当 Ping 被分类后，以每辆车为单位，按时间顺序排序；并把所有连续的怠速状态和发动机关闭状态的 Ping 聚集成集群 (并不会被其中 Journey 状态的 Ping 給分割开来)。\n- 由于丢失数据，导致一组连续的怠速状态 Ping 彼此相对较远地分布开来。故我们得重新执行 `时间-空间` 的约束条件 ($s_i \\leq 1.4\\,m/s$ and $H(p_i,p_{i-1}) \\leq 150\\,m$)。\n\n\t> 无法满足约束条件：即一组连续的怠速状态 Ping 将被分隔得很远，其中的 Journey 状态的 Ping 都给丢失了。 \n\t\n- 以这种方式创建的 `Pings 集群` 代表我们想要分类的 `已识别的汽车停靠点`。综上所述，汽车停靠点被定义为按时间顺序排序的 Ping  集群 (包含怠速状态或发动机关闭状态的 Ping，并且满足进一步的 `时间-空间` 得约束条件。\n- 每个 `汽车停靠点` 都有几个特性 (通过计算其中的 Ping)：Ping 的数量，停靠点的起点和终点 (属于该停靠点的 Ping 的第一个和最后一个时间戳)，驻留时间 (属于该停靠点的起始时间和结束时间) 和形状 (由GPS消息的最大 (最小) 纬度/经度坐标定义)。\n- 所有这些信息对于在第二阶段提取特征工作至关重要，即汽车停靠点意图的分类。\n\n#### 贴标签\n- 首先，对上述程序中获得的汽车停靠点分配 `地面实况标签`；再者，将它们与 `工单数据` 进行匹配。一般来说，若车辆停留点在时间上和空间上与工单数据 $W_i$ 相匹配，则可认为该汽车停靠点即为某一工单数据。\n\t- 对于只包含 idling 和 engine off Pings 的停靠点，我们认为它满足空间上的匹配。\n\t- 对于任何工单，空间上匹配了停留点；如果停留点的驻留时间与工单的时间项 (指示作业已启动的时间和指示服务已结束的时间) 间隔相交，时间的匹配也随着满足。\n\n#### 分类特征\n在 `车辆停靠侦查技术` 章节中描述的，从一系列的 GPS Pings 提取汽车停靠点，并从中提取 100 个不同的特征用于训练随机森林模型，随之将这些特征划分为 4 个不同的组：\n\n- 汽车停靠点特征 ( Stop-wise features，SWF )：\n\t- 驻留时间：(汽车) 停靠点第一个和最后一个 Ping 的时间差。\n\t- 开始时间特征：一天中的小时，一周中的某天，某月某日，某年某日。\n\t- 关闭引擎所花费的时间：对于每一个引擎关闭事件，我们计算当前 Ping 与前一个非引擎关闭状态的 Ping 之间的时间差，以表示引擎启动的时间。由于每个停靠点包含多个引擎关闭状态的 Ping，我们需要使用几个聚合函数聚合取得结果。\n\t- 形状：停靠点的宽度、高度、面积、比例。\n\t- 停靠点类型：发动机关闭状态。\n\t- 停靠点中发动机关闭状态 Ping 的数量。\n\t- 里程表距离：从第一次 Ping 到最后一次 Ping。\n\t- 停靠点内 Ping 的总数。\n\t- 平均速度 (根据停留点中第一次和最后一次 Ping 之间的里程差除以驻留时间计算所得)。\n- 兴趣点特征 ( Points of interest features，POIF)：利用 `PTV xLocate Server` 中提取以下 POI 类型：\n\t- 银行;\n\t- 大学;\n\t- 酒店;\n\t- 餐厅;\n\t- 休息区;\n\t- 杂货店;\n\t- 学校;\n\t- 购物中心;\n\t- 汽油;\n\t- 开放式停车场;\n- 汽车停靠点集群特征 ( Stop cluster features，CF )：其原理是存在一些工单数据和非工单数据趋向于聚类成簇，类似于 [7] 中提出的熵度量方法：对于每个停靠点，查看并收集 250 米半径内的周边环绕的停靠点数据。\n\t- 车辆熵，计算公式为：\n\n\t$$E_v = - \\sum_{\\nu \\in V} \n\t\t\\frac{n_{\\nu}}{N} ln(\\frac{n_{\\nu}}{N})\n\t\t\\tag{1}\n\t$$\n\t\n\t> $V$ 是车队中的车辆集合， $N$ 是 250 米半径范围内车队所有车辆的总停留点数，$n_{\\nu}$ 是车辆 $\\nu$ 在同一区域停靠的总次数。这个熵度量给出了一个区域内同一车队车辆的多样性。\n\t\n\t- 簇中汽车停靠点的平均，总和，最大和最小驻留时间。\n\t- 邻近汽车停靠点的数量 (在其质心250米半径以内)。\n\t\n- 序列特征 (Sequential features，SeqF).\n\n## 不足\n\n- 在车辆停靠点侦查技术章节中，使用的是非监督方式的算法，即基于密度的 DBSCAN 聚类算法。其中涉及密度阈值的设定多少问题，就需要对具体样本量进行考究才能决定。\n\n## 参考\n[1] Horozov T, Narasimhan N, Vasudevan V. Using location for personalized POI recommendations in mobile environments [C]//Applications and the internet, 2006. SAINT 2006. International symposium on. IEEE, 2006: 6 pp.-129.  \n[2] Jiang K, Yin H, Wang P, et al. Learning from contextual information of geo-tagged web photos to rank personalized tourism attractions [J]. Neurocomputing, 2013, 119: 17-25.\n[3] Palma A T, Bogorny V, Kuijpers B, et al. A clustering-based approach for discovering interesting places in trajectories [C]//Proceedings of the 2008 ACM symposium on Applied computing. ACM, 2008: 863-868.  \n[4] Gong L, Sato H, Yamamoto T, et al. Identification of activity stop locations in GPS trajectories by density-based clustering method combined with support vector machines [J]. Journal of Modern Transportation, 2015, 23(3): 202-213.  \n[5] Ester M, Kriegel H P, Sander J, et al. A density-based algorithm for discovering clusters in large spatial databases with noise [C]//Kdd. 1996, 96(34): 226-231.  \n[6] Lv M, Chen L, Xu Z, et al. The discovery of personally semantic places based on trajectory data mining [J]. Neurocomputing, 2016, 173: 1142-1153.  \n[7] Gingerich K, Maoh H, Anderson W. Classifying the purpose of stopped truck events: An application of entropy to GPS data [J]. Transportation Research Part C: Emerging Technologies, 2016, 64: 17-27.  \n[8] Sambo F, Salti S, Bravi L, et al. Integration of GPS and satellite images for detection and classification of fleet hotspots [C]//Intelligent Transportation Systems (ITSC), 2017 IEEE 20th International Conference on. IEEE, 2017: 1-6.  \n[9] Wolf J, Guensler R, Bachman W. Elimination of the travel diary: Experiment to derive trip purpose from global positioning system travel data [J]. Transportation Research Record: Journal of the Transportation Research Board, 2001 (1768): 125-134.  \n[10] Bohte W, Maat K. Deriving and validating trip purposes and travel modes for multi-day GPS-based travel surveys: A large-scale application in the Netherlands [J]. Transportation Research Part C: Emerging Technologies, 2009, 17(3): 285-297.  ","tags":["特征提取"],"categories":["Paper"]},{"title":"论文 | 通过非线性随机邻近嵌入自动分类细胞表达","url":"/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding.html","content":"\n{% note default %}\n原文：Automatic classification of cellular expression by nonlinear stochastic embedding (ACCENSE)  \n作者：Karthik Shekhar, Petter Brodin, Mark M.Davis and Arup K.Chakraborty.  \n来源：Proceedings of the National Academy of Sciences (PNAS), 2014, 111(1): 202-207.  \n{% endnote %}\n\n## 摘要\n\n质谱流式细胞技术 (Mass cytometry) 能够在单细胞水平上测试近 40 种不同的蛋白质，即提供前所未有的多维信息水平。由于各式各样的细胞种群数据集的复杂性，要收集有用的生物学知识对计算工具也有新的要求。回顾之前的聚类方法，即对于不同功能的细胞识别是基于细胞表征相似性来实现区分的。当然，经典方法存在一定局限性，例如单细胞分辨率的损失；经典方法需要预知簇中的对象数量 (本文中指细胞亚群的规模数量)。\n\n<!-- More -->\n\n则该论文引入 `ACCENSE` (Automatic classification of cellular expression by nonlinear stochastic embedding) 高维单细胞数据分析工具：\n\n- 基于密度划分的非线性降维方法，降维步骤采用 `t-Distributed Stochastic Neighbor Embedding (t-SNE)` 算法 $^{[1]}$。\n- 探索性数据分析，同时避免任何手动 `阀门(阈值)` 的需要，即有别于基于距离的方法 (离群点判定)、基于密度的方法 (密度阈值)。\n- 化繁为简，在二维或三维图上展示多元细胞的表型。\n\n再有，本论文将 ACCENSE 应用于 35 参数的质谱流式细胞技术，检测 CD8+ T 细胞的数量 (数据来自于特定的无病原和无菌小鼠)，并将细胞分层到表型亚群中。即对于具体的聚类算法、降维算法中，特定的符号名称会以具体的对象名称替代。\n\n## 正文\n\n### 背景介绍\n- 免疫系统包含了许多类型的细胞，它们在免疫应答过程中表现出多样化的功能和复杂方式的相互作用，即通过不同蛋白质的表达水平所定义，故个体细胞的功能与其细胞表型密切相关。这里启示我们，对于不同功能的细胞可通过细胞表型相似性进行聚类区分。\n\n- 传统流式细胞技术和质谱流式细胞技术\n\t- 传统流式细胞技术 (Flow Cytometry) $^{[2]}$ 中，用 `荧光基因` 标记的抗体染色，其蛋白质靶标通过单细胞分辨率的光发射信号进行量化。\n\n\t> 由于有限的光谱和重叠的发射信号，每个细胞限制为 12-16 个参数。\n\n\t- 质谱流式细胞技术 (Mass Cytometry) $^{[3]}$ ，使用 `金属螯合探针` 可以对多达 42 个参数的单个细胞进行量化。\n\n\t- 传统流式细胞技术和质谱流式细胞技术相比，主要有两点不同：  \n\t\t- 标签系统的不同，前者主要使用各种荧光基团作为抗体的标签，后者则使用各种金属元素作为标签；  \n\t\t- 检测系统的不同，前者使用激光器和光电倍增管，而后者使用 ICP 质谱技术。 \n\n### 聚类算法\n由 `质谱流式细胞技术产生的高维数据`，以具有生物学意义的方式解释是具有挑战性的。然而，很多聚类工具是基于细胞的蛋白表达相似性进行细胞分类的，例如：\n\n- `SPADE 算法` $^{[4,5]}$：SPADE 使用多元信息定义细胞簇，并在树状结构中显示潜在的表型层次结构。但尚有不足之处：\n\t- 一是单细胞分辨率的损失；\n\t- 二是对目标集群数量的需要预知。\n\n### 降维算法\n同样，降维算法以蛋白质表达相似性，把空间组织的细胞群在低维空间聚集成不同的细胞亚群。\t\n\t\n- `PCA 算法`：PCA降维的大致思想就是，挑选特征明显的、显得比较重要的信息保留下来。在本论文中，Newell 等人将主成分分析 (Principal component analysis，PCA) 应用于 25 参数的质谱流式细胞技术，检测人的 CD8+ T 细胞的数量，且使用前三种主成分 (3D-PCA) 分离细胞亚群。3D-PCA 以三个汇总变量表示数据，每个汇总变量都是原始维度的线性组合，并去捕获投影后数据的方差，直至其取值为最大值。然而，PCA 能在数据中所有的可能线性组合中找到最优表达，但也存在限制条件：线性投影可能太严格而不能产生精确的表示 $^{[6]}$ ( 引入 t-SNE 算法 )。\n- `t-SNE 算法` $^{[7]}$：t-Distributed Stochastic Neighbor Embedding，数据降维与可视化的方法，具体的算法细节如下：\n\t- 让 $\\{x^{(i)}\\}$ 表示归一化 n 维蛋白质表达向量编码的细胞 i 表型 (i=1, 2, ..., M)。\n\t- 若在 2D 平面图下，$\\{y^{(i)}\\}$ 向量表示高维 $\\{x^{(i)}\\}$ 对应于低维的映射，它使得具有相似表型的 T 细胞彼此靠近嵌入，表型不相似的则嵌入相对较远的距离。\n\t- 采用细胞 i 和 j 之间的成对概率 $\\{p_{i,j}\\}$ 表示 $\\{x^{(i)}\\}$ 与 $\\{x^{(j)}\\}$ 之间的相似性。\n\t- 若在 2D 平面图下，成对概率 $\\{q_{i,j}\\}$ 表示 $\\{y^{(i)}\\}$ 与 $\\{y^{(j)}\\}$ 之间的相似性。\n\t- 通过最小化 $\\{p_{i,j}\\}$ 与 $\\{q_{i,j}\\}$ 的 KL 散度 (可理解为代价函数)，然后找出嵌入向量 $\\{y^{(i)}\\}$，即它让高维转低维的表示信息能最大程度被保存下来。\n\t\n\t> KL 散度 ([详细见附录 1](#1-t-SNE-中的概率))，Kullback-Leibler Divergence，又称相对熵，即描述两概率分布 P 和 Q 的差异。KL 散度公式 (1) 如下：\n\t\n\t$$D_{KL}(\\{p_{i,j}\\}|\\{q_{i,j}\\}) = \\sum_{i,j} p_{i,j} log \\frac{p_{i,j}}{q_{i,j}} \\tag{1}$$\n\t\n\t- $\\{y^{(i)}\\}$ 可以编码非线性关系，不像 PCA 中被约束为 $\\{x^{(i)}\\}$ 的线性组合。\n\t- `最佳嵌入` 是通过数值梯度下降法来确定的，即所有数据点的 KL 散度总和减小到最小 ([详细见附录 2](#2-数值梯度下降法))。\n\n### 识别细胞亚群\n- 使用一个内核密度变换，从 t-SNE 的细胞散布图计算出一个复合图像 $K_\\gamma(y)$：\n\t$$K_\\gamma(y) = exp(\n\t-\\frac{||y - y'||^{2}}{2\\gamma^2}\n\t)\\tag{2}$$\n\t\n- 在本论文中，$K_\\gamma(y)$ 的 `局部最大值` 表示具有共同表型的 CD8+ T 细胞亚群，且使用了 matlab 的峰值检测算法识别这些局部最大值。\n\n\t> 当然，也可以在嵌入点上使用 K-Means 聚类算法来识别 T 细胞子集，但其要求事先指定簇的数量。\n\t\n- 如何求得 `局部最大值`，关键是对于公式 (2) 中 $\\gamma$ 的参数设定多少有关。即通过比较不同的核-宽带 $\\gamma$ 产生的结果，则存在一个 $\\gamma$ 值为表型空间中存在的局部和全局特征提供了准确的粗粒度表示。从图 1-2 中可得，即启示我们可以以数据驱动的方式，近似地识别 CD8+ T 细胞的亚群。\n\n### 相关图表\n\n- 如图 1-1 所示，ACCENSE 应用于质谱高维数据。\n\n![图1-1ACCENSE ACCENSE 应用于质谱高维数据](/images/illustration/Paper/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding_1-1.jpg)\n<center>图 1-1 ACCENSE 应用于质谱高维数据</center>\n\n(A) 质谱细胞计数数据集样本的图示。行对应于不同的细胞，而列对应于测量其表达 (细胞表面抗原和细胞内蛋白) 的不同标记的金属螯合抗体。每一元组对应于指示每个标记的表达水平的质荷比变换值 (反双曲函数)。(C) 来自SPF B6 小鼠的 CD8+ T 细胞的 2D t-SNE 图谱。每个点代表来自训练集的一个细胞 (M = 18304)，且数据点是通过对原始数据集进行下采样得到。(D) 通过使用基于内核密度变换 ($K_{\\gamma}(y)\\,{,}\\,\\gamma = 7$)，将细胞的局部概率密度嵌入 (C) 的复合图像。并使用标准的峰值检测算法进行识别局部最大值，在二维密度图表示表型亚群的中心。\n\n- 如图 1-2 所示，展示了峰值随着 $\\gamma$ 的增加而变化。\n\n![图1-2展示了峰值随着γ的增加而变化](/images/illustration/Paper/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding_1-2.png)\n<center>图 1-2 展示了峰值随着 $\\gamma$ 的增加而变化</center>\n\n\t\n## 附录\n\n### 1 t-SNE 中的概率\n\n#### $p_{i,j}$ 概率\n基于蛋白质相似性，设 $p_{j|i}$ (i,j = 1, 2, ..., M) 表示细胞 i 将选择细胞 j 作为其最近邻的概率 ( $p_{j|i}$ 越大，$x^{(i)} 和 x^{(j)}$ 越近 )：\n\n$$\np_{j|i} = \\frac{\n\texp({-d_{i,j}^2} / {\n\t2\\sigma_i^2})\n}{ \n\t\\sum_{k \\neq i} exp({-d_{i,k}^2} / {\n\t2\\sigma_i^2})\n}, d_{i,j} = ||x^{(i)} - x^{(j)}||_2\n\\tag{3}\n$$\n\n对于概率 $p_{j|i}$ 的几点说明：\n\n- $d_{i,j}$ 可以使用其他距离范式替代欧式距离范式；\n- 原始的 SNE 算法是不对称的，为简化梯度公式，t-SNE 中让公式 (3) 的条件概率是对称的。即初始化 $p_{i|i} = 0$，对于任意的 $p_{i|j} = p_{j|i}$，可得：\t\n$$\np_{i,j} = \\frac{\n\tp_{j|i} + p_{i|j} \n}{2M} = \\frac{\n\texp({-d_{i,j}^2} / {\n\t2\\sigma_i^2})\n}{ \n\t\\sum_{k \\neq i} exp({-d_{i,k}^2} / {\n\t2\\sigma_i^2})\n}\n\\tag{4}\n$$ \n\t\n- 不同的点 $x_i$，带宽 $\\sigma_i$ 的取值也是不同的。\n\t- 公式 (3) 中的带宽 $\\sigma_i$ 是确保对于每一个细胞都有相同的复杂度 (Complexity)。复杂度可理解为一个点附近的 `有效近邻点个数`。\n\t- 定义复杂度为 $P_i = 2^{H_{j|i}}$，其近似地解释为细胞 i 的最近邻点的数量。\n\t- 定义 $p_{j|i}$ 的香农熵 (信息熵) 为 $H_{j|i} = - \\sum_j p_{j|i} \\log_2 p_{j|i}$，且 $H_{j|i}$ 随着 $\\sigma_i$ 的增加而增加。\n\n\t\t> 在本论文中，t-SNE 图谱的复杂度被设定为 30，即 10-50 范围内的复杂度对最终结果的影响不大 (较好的鲁棒性)。\n\n#### $q_{i,j}$ 概率\n对于低维度下的 $\\{y_i\\}$，在原始的 SNE 算法 $^{[7]}$ 中 Hinton 和 Rowers 引用高斯核函数 (Gaussian Kernels) 定义 $q_{i,j}$，但在低维表达中发现了 `拥挤问题`。\n\n> `拥挤问题`：就是说各个簇聚集在一起，无法区分。譬如，有一高维度数据在降维到 10 维下可以有很好的表达，但是降维到两维后无法得到可信映射。具体情况是，10 维中有数个点之间两两等距离的，在二维下就无法得到可信的映射结果。  \n> 进一步说明，假设一个以数据点 $x^i$ 为中心，半径为 r 的 m 维球(三维空间就是球)，其体积是按 $r^m$ 增长的，假设数据点是在 m 维球中均匀分布的，我们来看看其他数据点与 $x^i$ 的距离随维度增大而产生的变化。\n\nt-SNE 减轻了拥挤问题，即使用更加偏重长尾分布的方式来将距离转换为概率分布 $^{[8]}$，故有 $q_{i,j}$：\n\n$$\nq_{i,j} = \\frac{\n\t(1 + \\Delta_{i,j}^2)^{-1}\n}{ \n\t\\sum_{k \\neq i} (1 + \\Delta_{i,k}^2)^{-1}\n}, \\Delta_{i,j} = ||y^{(i)} - y^{(j)}||_2\n\\tag{5}\n$$\n\n同样地，对于概率 $q_{i,j}$ 的几点说明：\n\n- $\\Delta_{i,j}$ 可以使用其他距离范式替代欧式距离范式；\n- 原始的 SNE 算法是不对称的，为简化梯度公式，t-SNE 中让公式 (5) 的条件概率是对称的。即初始化 $q_{i|i}=0$，对于任意的 $q_{i|j} = q_{j|i}$。\n\n### 2 数值梯度下降法\n- 在 [7] 中的概述过程，获得优化的梯度公式，如下所示:\n\n$$\n\\frac{\n\t\\partial D_{KL}(\\{p_{i,j}\\} | \\{q_{i,j}\\})\n}{\n\t\\partial_{y_t}^{(i)}\n} = 4 \\sum_j \\frac{\n\t\t(p_{i,j} - q_{i,j})\n\t}{\n\t\t(1 + ||y_t^{(i)} - y_t^{(j)}||^2)\n\t}\n\t(y_t^{(i)} - y_t^{(j)})\n\t\\tag{6}\n$$\n\n- 通过梯度下降法迭代计算局部最大值：\n\n\t$$\n\ty_{t+1}^{(i)} = y_{t}^{(i)} + \\eta(t) \\frac{\n\t\t\\partial D_{KL}(\\{p_{i,j}\\} | \\{q_{i,j}\\})\n\t}{\n\t\t\\partial_{y_t}^{(i)}\n\t}\n\t+ \\alpha(t)(y_{t}^{(i)} - y_{t-1}^{(i)})\n\t\\tag{7}\n\t$$\n\n\t- $y_t^{(i)}$ 表示迭代 t 次的解，$\\eta(t)$ 表示学习速率，$\\alpha(t)$ 表示迭代 t 次的动量。\n\t- 学习速率初始值为 $\\eta(t) = 100\\,^{[9]}$，且动能量 $\\alpha(t)$ 设定为：\n\t\n\t$$\n\t\\alpha(t) = \\begin{cases} 0.8, & t < 300 \\\\\n\t0.5, & t \\geq 300 \\end{cases}\n\t$$\n\n## 不足\n\n- t-SNE 主要用于可视化，很难用于其他目的。譬如测试集合降维，因为他没有显式的预估部分，不能在测试集合直接降维。\n- 关于核-带宽 $\\gamma$ 参数设定问题：文中展示了 $\\gamma$ 参数的大小与识别细胞亚群能力的数量关系。然而，数据驱动方式虽能实现自动聚类，但缺乏对于 $\\gamma$ 参数设定范围该如何控制的说明。\n\n## 参考\n\n[1] Maaten L, Hinton G. Visualizing data using t-SNE [J]. Journal of machine learning research, 2008, 9(Nov): 2579-2605.  \n[2] Cantor H, Simpson E, Sato V L, et al. And functional studies of peripheral t-cells binding different amounts of fluorescent anti-thy 1.2 (theta) Antibody using a fluorescence--activated cell sorter (FACS) [J]. 1975.  \n[3] Bendall S C, Nolan G P, Roederer M, et al. A deep profiler's guide to cytometry [J]. Trends in immunology, 2012, 33(7): 323-332.  \n[4] Qiu P, Simonds E F, Bendall S C, et al. Extracting a cellular hierarchy from high-dimensional cytometry data with SPADE [J]. Nature biotechnology, 2011, 29(10): 886.  \n[5] Bendall S C, Simonds E F, Qiu P, et al. Single-cell mass cytometry of differential immune and drug responses across a human hematopoietic continuum [J]. Science, 2011, 332(6030): 687-696.  \n[6] Van Der Maaten L, Postma E, Van den Herik J. Dimensionality reduction: a comparative [J]. J Mach Learn Res, 2009, 10: 66-71.  \n[7] Maaten L, Hinton G. Visualizing data using t-SNE [J]. Journal of machine learning research, 2008, 9(Nov): 2579-2605.\n[[8] Chrispher. t-SNE 完整笔记 [OL]. www.datakit.cn. 2017.](http://www.datakit.cn/blog/2017/02/05/t_sne_full.html)  \n[9] Jacobs R A. Increased rates of convergence through learning rate adaptation[J]. Neural networks, 1988, 1(4): 295-307.\n","tags":["机器学习"],"categories":["Paper"]},{"title":"论文 | 扩展 K-Means 算法：混合数据类型的聚类方法","url":"/2018/06/Extensions-to-the-k-Means-algorithm-for-custering-large-datasets-with-categorical-values.html","content":"\n{% note default %}\n原文：Extensions to the k-means algorithm for clustering large datasets with categorical values  \n作者：ZHEXUE HUANG.  \n来源：Data mining and knowledge discovery, 1998, 2(3): 283-304.  \n{% endnote %}\n\n## 摘要\n\n在早期，大多数聚类工作主要集中在数值数据上，且它们主要是利用数值数据的固有几何特性，即数据点之间的 `距离函数` ([见附录1](#1-距离函数))。但是，数据挖掘应用程序通常涉及许多数据集，这些数据集是由混合数值属性和标称属性组成的，仅拥有数值数据的测量方法已无法满足混合数据类型的聚类工作。\n\n本论文基于经典的 K-Means 算法上，提出了两种聚类算法，分别应对 `标称域` 和 `混合数值与标称域` 属性值的聚类操作。首先介绍的是`K-Modes (K-众数)` 聚类算法，他运作的方式与 K-Means 相仿，只是它利用的是相异性度量处理标称对象，聚类中心以众数替代均值，且众数以基于频率的方法去迭代更新，直至 `聚类代价函数` 的结果最小化停止迭代。其次，是 `K-Prototype` 聚类算法，它定义了一组合的相异性度量值，进一步整合 `K-Means` 和 `K-Modes` 算法，以实现对混合数值与标称属性的对象进行聚类操作。\n\n<!-- More -->\n\n## 正文\n\n### 引入\n将数据库中的一组对象划分为同构组或集群是数据挖掘中最基本的操作。而讨论划分操作，自然离不开聚类。聚类是把每一组对象划分为一个簇，且同一簇中对象之间相似，而不同簇之间的对象相异。\n\n数据挖掘最显著的特征是处理复杂的大型数据集。特别地，数据集包含数以百万计由不同类型属性或变量描述的对象，由此数据挖掘操作和算法应充分考虑可扩展性，以应付处理不同类型的属性。\n\n在本论文中，提出的两个新聚类算法，即利用 `K-Means 范式` 对拥有标称属性的数据进行聚类。`K-Modes (K-众数)` 聚类算法，他运作的方式与 K-Means 相仿，只是它利用的是相异性度量处理标称对象，聚类中心以众数替代均值，且众数以基于频率的方法去迭代更新，直至 `聚类代价函数` 的结果最小化停止迭代。其次，是 `K-Prototype` 聚类算法，它定义了一组合的相异性度量值 $s^r + \\gamma s^c$，以实现对混合数值与标称属性的对象进行聚类操作。其中，$s^r$ 是由 `平方欧式距离` 定义的 `数值属性` 的相异性度量值，$s^c$ 是由 `两个对象间类别不匹配的数量` 定义的 `标称属性` 的相异性度量值，$\\gamma$ 是平衡数值属性和标称属性两部分的的权值，以避免偏向于某一属性。若聚类的效果更青睐于数值属性，则可以设定一个较小的 $\\gamma$ 值；反之，设定一较大的 $\\gamma$ 值。\n\n### 符号\n- 假设需要聚类的对象数据集储存在数据集 D 中。\n\t- 集合的属性 $A_1, A_2, ... , A_m$ 分别是值域 $D_1, D_2, ... , D_m$ 的描述。\n\t- 在 D 中的每个对象由元组 t 表示，$t \\in D_1 \\times D_2 \\times ... \\times D_m$。\n- 针对本文讨论的聚类问题，仅考虑两种常见数据类型：数值类型和标称类型。\n\t- 数值域的取值范围是实数域。\n\t- 在多维的密度空间中，每一个数值型的数据点都采用诸如欧式或马氏的距离度量方法。\n\t- 若值域 $D_i$ 被定义为有限、无序的标称域，则对象的比较操作只允许在 $D_i$ 中执行，即有 $a, b \\in D_i$，either a = b or $a \\neq b$。\n- 对于数据集中的每一数据对象 $X$，也可由 `属性-属性值` 的键值对表示，\n\n\t$$[A_1=x_1] \\bigwedge [A_2=x_2] \\bigwedge ... \\bigwedge [A_m=x_m]$$\n\n- 即当 $x_i \\in D_i$，for i = 1, 2, ..., m。为简单起见，这里以 $X$ 表示元组：\n\n\t$$[x_1^r, x_2^r, ...,x_p^r, x_{p+1}^c, ..., x_m^c] \\in D_1 \\times D_2 \\times ... \\times D_m$$\n\n\t> 最后一个数值对象为元素 $p$ ，其余的都是标称对象。当然，若元组中仅有一种数据类型，可表示为 $[x_1, x_2, ..., x_m]$。\n\n### K-Means (均值) 算法\n- K-Means，是一种划分或非分层的聚类算法，为进一步阐述细节，需给出如下设定：\n    - 一组含 $n$ 个数值数据的对象集 $D = \\{X_1, X_2, ..., X_n\\}$；\n    - 距离度量 $d$；\n    - 自然数 $k (\\leq n)$，并把 $D$ 划分 $k$ 个非空且相分离的簇群：\n    $$\n    C_1, C_2, ..., C_k, \\, with \\, C_i \\bigcap C_j = \\emptyset \\, and \\, \\bigcup_{i=1}^k C_i = D\n    $$\n    - $D$ 中随机选取 $k$ 个对象，每个对象代表一个簇的初始均值或中心。\n- 如此一来，使得数据对象与其簇的中心之间的平方误差总和被最小化。然后，根据非线性优化问题，将该问题描述为:\n\n    $$\n    Minimise \\, P(W,Q) = \\sum_{l=1}^k \\sum_{i=1}^n w_{i,l} d(X_i, Q_l)\n    \\tag{1}\n    $$\n\n    且服从：\n\n    $$\n    \\begin{cases}\n    \\sum_{l=1}^k w_{i,l} = 1, \\, i = 1, 2, ..., n \n    \\\\ w_{i,l} \\in \\{0,1\\}, \\, i = 1, 2, ..., n; l = 1, 2, ..., k\n    \\end{cases}\n    \\tag{2}\n    $$\n    \n   - $w_{i,l}$ 指标变量表示对象 $X_i$ 仅属于哪一个簇。即取值为 1 时，表示对象 $X_i $ 在 簇 $C_l$ 中；反之，取值为 0。\n   - $W = \\left[ w_{i,l} \\right]_{n \\times k}$ 是分块矩阵 (见公式 3)，$Q = \\{Q_1, Q_2, ..., Q_K\\}$ 是簇的中心集合，$d(·,·)$ 是两对象间的平方欧式距离 ([见附录1](#1-距离函数))。\n\n   $$W = \\left[ w_{i,l} \\right]_{n \\times k} = \n   \\begin{bmatrix} \n   w_{11} & \\cdots & w_{1l} & \\cdots & w_{1k} \\\\ \n   \\vdots & & \\vdots & & \\vdots \\\\\n   w_{i1} & \\cdots & w_{il} & \\cdots & w_{ik} \\\\\n   \\vdots & & \\vdots & & \\vdots \\\\\n   w_{n1} & \\cdots & w_{nl} & \\cdots & w_{nk} \\\\ \n   \\end{bmatrix}\n   \\tag{3}\n   $$\n\n- 紧接着，在约束条件 (2) 下对 (1) 中的 P 进行优化，即对 Q 和 W 进行局部优化。首先，我们先固定 Q 并找出必要条件 W 使 P 最小化。然后，根据 Q 去修正 W 并最小化 P。基于上述几点，若为了达到 P 最小化，K-Means 算法通过 `三步迭代`，直到 P(W, Q) `收敛` 到某个 `局部最小值`。\n    - `Step.01`： 初始化 $Q^{(0)} = \\{Q_1^{(0)}, Q_2^{(0)}, ..., Q_k^{(0)}\\}$，且设立 $t = 0$。\n    - `Step.02`：固定 $Q^{(t)}$ 不变，求解 $P(W, Q^{(t)})$ 再去获得 W，即以 Q 作为簇群的中心，将每个对象分配到距离其最近的簇中心的簇群当中。\n    - `Step.03`：固定 $W^{(t)}$  不变，生成 $Q^{(t+1)}$，求解 $P(W^{(t)}, Q^{(t+1)})$。比较 $P(W, Q^{(t)}) \\, and \\, P(W^{(t)}, Q^{(t+1)})$，若后者为最小化，则根据当前的对象部分构造新的簇群中心。\n        - $Q_t^{t+1} = \\{q_{l,1}^{(t+1)}, ..., q_{l,m}^{(t+1)}\\}, \\, for \\, l = 1, 2, ..., k$，且：\n    \n        $$\n        q_{l,j}^{(t+1)} = \\frac {\n            \\sum_{i=1}^n w_{i,l}^{(t)} x_{i,j}\n        }{\n            \\sum_{i=1}^n w_{i,l}^{(t)}\n        }, \\, j = 1, 2, ..., m\n        \\tag{4}\n        $$\n        \n    - `Step.04`：当满足收敛或给定的停止条件时 ( `局部最优化` )，输出结果并停止；反之，令 $t = t + 1$，并继续从 `Step.02` 开始执行。\n- 为了解决 `簇间边界不明确` 的问题，模糊分区的概念成功地应用到聚类问题中，即模糊聚类 $^{[2,3]}$。但是，我们在本论文中不考虑这个问题。\n- 综上所述，K-Means 算法具有以下特征：\n    - 局部最优化为算法结束的终止条件；\n    - 仅适用于数值属性数据的聚类；\n    - 簇群的特征为球形簇.\n\n### K-Modes (众数) 算法\n原则上，K-Means 算法中问题 P 的公式对于分类和混合类型的对象也是有效的，之所以 K-Means 算法不能对标称属性对象进行聚类的原因是它的相异性度量方法和用于构造新的簇群中心的方法不适用，故通过对 K-Means 算法进行以下修改，可消除不适用问题：\n\n- 用于标称属性对象的相异性度量的方法；\n- 簇群的中心以 `众数` 替代 `均值`；\n- 使用基于频率的方法求的众数，以构造新的簇群中心。\n\n#### 相异性度量\n相异性度量：设 $X,Y$ 是由 m 个标称属性描述的两个标称属性对象， $X,Y$ 的相异性度量可通过两个对象间相对应属性的不匹配总和来定义，即不匹配的次数越少，两个对象越相似。定义如下：\n\n$$\nd_1(X,Y) = \\sum_{j=1}^m \\delta (x_j,y_j)\n\\tag{5}\n$$\n\n 且满足条件：\n\n$$\n\\delta (x_j,y_j) = \\begin{cases}\n0 , \\, (x_j = y_j) \\\\\n1 , \\, (x_j \\neq y_j)\n\\end{cases}\n \\tag{6}\n$$\n    \n#### 众数集\n设 $X$ 是由标称属性 $A_1, A_2, ..., A_m$ 描述的标称属性对象集。$X= \\{X_1, X_2, ..., X_n\\}$ 的众数由向量 $Q =\\{q_1, q_2, ..., q_m\\}$ 表示，并最小化函数：\n\n$$\nMinimise \\, D(X,Q) = \\sum_{i=1}^n d_1(Xi,Q)\n\\tag{7}\n$$\n    \n>  注意，这里 $Q$ 并不一定是 $X$ 中包含元素 (有别于 K-Medoids 算法 $^{[4]}$，质心从它的样本点中选择 )。    \n    \n#### 挑选众数\n设 $n_{c_{k,j}}$ 为属性 $A_j$ 中包含第 k 个标称属性 $c_{k,j}$ 的对象数量，且定义 $f(A_j = c_{k,j} | X) = \\frac{ n_{c_{k,j}} }{n}$ 为标称属性 $c_{k,j}$ 在 $X$ 中的出现频率。\n\n- `定理 1`：若满足下述条件 (8)，即 $D(X,Q)$ 已最小化 ( 证明见[附录2](#2-定理证明) )。即定理定义了一种从给定的 $X$ 中找到 $Q$ 的方法，即它允许使用 K-Means 范式来聚类标称数据，且定理 1 暗示了数据集 $X$ 的众数不是唯一的。 \n\n    $$\n    f(A_j = q_j | X) \\geq f(A_j = c_{k,j} | X) \\, for \\, q_j \\neq c_{k,j},j=1, 2, ..., m\n    \\tag{8}\n    $$  \n\n#### 算法核心\n- 当公式 (5) 用作标称属性对象的相异性度量时，公式 (1) 的代价函数将推导为：\n\n$$\nP(W,Q) = \\sum_{l=1}^k \\sum_{i=1}^n \\sum_{j=1}^m w_{i,l} \\delta(x_{i,j},q_{l,j})\\\\\\ where \\, w_{i,l}  \\in W \\, and \\, Q_l = [q_{l,1}, q_{l,1}, ..., q_{l,m}] \\in Q\n\\tag{9}\n$$\n\n- 为了最小化代价函数，则修改经典 K-Means 算法：\n    - 以相异性度量方法求解 $W$，即上述 `Step.02` 所描述的，以当前 $Q$ 为簇群中心，将每个对象分配到距离其最近的簇中心的簇当中去；\n    - 用簇的众数代替均值，根据 `定理 1` 选择众数来求解  $Q$，即上述 `Step.03` 所描述的，求得新的簇群中心。\n- 在经典算法中，我们需要在每次获得一个新的 $Q$ 或 $W$ 时，根据整个数据集计算总代价 P。为了提高计算效率，我们在实践中采用了下面的算法。\n    - `Step.01`：初始化 k 个众数，且每个众数对应一个簇；\n    - `Step.02`：根据公式 (5)，将距离众数最近的对象分配该簇当中。再根据 `定理 1`，在每次分配后更新簇群的众数。\n    - `Step.03`：当所有对象分配到具体的簇群之后，重新测试对象与当前众数的相异性。如果找到一个对象，距离其最近的众数属于另一个簇群而不是当前的簇群，则将该对象重新分配给该簇群，并更新两个簇群的众数。\n    - `Step.04`：重复执行 `Step.03`，直到对整个数据集进行完整的循环测试之后，没有对象更改簇群。\n\n        > 目前，虽没有证明该算法的收敛性，但在实际使用过程中，它的表现总是收敛的。\n\n- 与 K-Means 算法一样，K-Modes 算法也是产生 `局部最优解`，且依赖于数据集中的 `初始的众数` 和 `对象的顺序`。考虑 `初始的众数` 和 `对象的顺序` 的因素影响，我们通过两种方法改进算法。\n    - 第一个方法是第一次从数据集中选择 $k$ 个不同的记录作为初始 $k$ 个众数值。\n    - 第二个方法通过以下步骤实现：\n        - `Step.01`：计算所有属性的所有标称值的频率，并按照频率的降序将它们存储在一个标称类型的数组中，如图 2-1 所示，展示了标称类型数组中，分别包含 4、2、5、3 个标称值的 4 个属性。这里 $c_{i,j}$ 表示属性 $i$ 的标称值 $j$，$f(c_{i,j})$ 为标称值的频率，且 $f(c_{i,j}) \\geq f(c_{i+1,j})$。\n        - `Step.02`：将频率最高的标称值作为 $k$ 个众数的初始值。\n        - `Step.03`：从 $Q_1$ 开始，选择相似性最接近其的记录并替换它的初始众数。以此类推，直至 $Q_k$  的初始众数被替换完成。其中，$Q_l \\neq Q_t \\, for \\, l \\neq t$。\n        \n            > `Step.03` 的目的在于避免空簇群的情况，致使初始众数具有多样性，以获得更好的聚类结果。\n\t\n\t$$\n\t\\begin{Bmatrix} \n\tc_{1,1} & c_{1,2} & c_{1,3} & c_{1,4} \\\\ \n\tc_{2,1} & c_{2,2} & c_{2,3} & c_{2,4} \\\\ \n\tc_{3,1} & \\, & c_{3,3} & c_{3,4} \\\\ \n\tc_{4,1} & \\,  & c_{4,3} & \\, \\\\ \n\t\\,  & \\,  & c_{5,3} & \\, \\\\ \n\t\\end{Bmatrix}\n\t$$\n\n\t<center>图 2-1 标称类型数组 ( 横向表示集合的属性 A，纵向表示簇中心点 Q )</center>\n\t\n### K-Prototypes 算法\n- 将 K-Means 和 K-Modes 算法集成到 K-Prototypes 算法中是很容易的，这种算法用于混合类型对象的簇群聚类。\n\t\n- 在混合对象 $X$ 和 $Y$ 间的相异性可由属性 $A_1^r, A_2^r, ..., A_p^r, A_{p+1}^c, ..., A_m^c$ 描述，并定义其相异性度量为：\n\t\n    $$\n    d_2(X,Y) = \\sum_{j=1}^p (x_j - y_j)^2 + \\gamma \\sum_{j=p+1}^m \\delta(x_j,y_j)\n    \\tag{10}\n    $$\n \t\n     > 其中，第一项是数值属性的平方欧氏距离度量，第二项是标称属性的相异性度量。权重 $\\gamma$ 是用来避免偏袒任何类型的属性，即聚类结果更趋向于数值属性还是标称属性。\n \t\n- 当公式 (10) 用作混合类型属性对象的相异性度量时，公式 (1) 的代价函数将推导为：\n \n    $$\n    P(W,Q) = \\sum_{l=1}^k (\n        \\sum_{i=1}^n w_{i,l} \\sum_{j=1}^p(x_{i,j}-q_{l,j})^2\n        + \\gamma \\sum_{i=1}^n w_{i,l} \\sum_{j=p+1}^m \\delta(x_{i,j}-q_{l,j})\n    )\n    \\tag{11}\n    $$\n    \n    > $ \\sum_{i=1}^n w_{i,l}$ 即公式 (2) 所描述的，每个簇对象只对应一个簇中心。\n    \n    - 为简化公式 (11)，让：\n\n    $$\n    P_l^r = \\sum_{i=1}^n w_{i,l} \\sum_{j=1}^p(x_{i,j}-q_{l,j})^2\n    \\tag{12}\n    $$    \n    \n    $$\n    P_l^c =  \\gamma \\sum_{i=1}^n w_{i,l} \\sum_{j=p+1}^m \\delta(x_{i,j}-q_{l,j})\n    \\tag{13}\n    $$\n    \n    - 重写公式 (11)：\n\n    $$\n    P(W,Q) = \\sum_{l=1}^k (P_l^r + P_l^c)\n    \\tag{14}\n    $$\n \n - $P_l^r$ 和 $P_l^c$ 都是非负的，最小化 $P(W,Q)$ 等同于最小化 $P_l^r$ 和 $P_l^c$，$1 \\leq l \\leq k$。\n \t\n## 附录\n\n### 1 距离函数\n`距离函数`：关于数据点之间的距离函数，即数值属性刻画的对象相异性的距离度量。度量方法 $^{[1]}$ 包括闵可夫斯基距离 (闵氏距离)、欧几里得距离 (欧式距离) 和曼哈顿距离。\n\n令 $i=(x_{i1},x_{i2},...,x_{ih})$ 和 $j=(x_{j1},x_{j2},...,x_{jh})$ 是两个被 h 个属性描述的对象。 \n\n闵氏距离是欧式距离和曼哈顿距离的推广，定义如下：\n\n$$\nd(i, j) = \\sqrt[h](\n\t\\sum_{f=1}^h |x_{if}-x_{jf}|^{h}\n),h \\geq 1\n\\tag{1}\n$$\n\n- 当 h = 1 时，它表示 `曼哈顿距离`，也称 `城市块` 距离 (城市两点之间的街区距离，如向南 2 个街区，横过 3 个街区，共计五个街区)，其定义如下：\n\n$$\nd(i, j) = \\sum_{f=1}^h |x_{if}-x_{jf}|,h \\geq 1\n\\tag{2}\n$$\n\n- 当 h = 2 时，它表示 `欧式距离`，也称 `直线或乌鸦飞行` 距离，其定义如下：\n\n$$\nd(i, j) = \\sqrt(\\sum_{f=1}^h (x_{if}-x_{jf})^2)\n,h \\geq 1\n\\tag{3}\n$$\n\n- 当 h = $\\infty$ 时，它表示 `上确界距离`，又称 `切比雪夫距离`，其定义如下L：\n\n$$\nd(i, j) = \\lim_{h \\to \\infty} (\n\t\\sum_{f=1}^h |x_{if}-x_{jf}|^h\n)^\\frac{1}{h} = max_{f}^h |x_{if}-x_{jf}|\n\\tag{4}\n$$\n\n### 2 定理证明\n`定理 1` 的证明如下：\n\n- 让 $f_r (A_j = c_{k,j} | X) = \\frac { n_{c_{k,j}} }{n}$ 为属性 $A_j$ 的第 $k$ 个标称属性 $c_{k,j}$ 的相对频率，$n$ 是 $X$ 中对象的总数，$n_{C_{k,j}}$ 是拥有标称属性 $c_{k,j}$ 的对象的计数。\n- 则有，相异性度量公式可推导为：\n\n$$\n\\sum_{i=1}^n d(X_i,Q) = \\sum_{i=1}^n \\sum_{j=1}^m \\delta(x_{i,j},q_j)\n\\\\ = \\sum_{i=1}^n ( \\sum_{j=1}^m \\delta(x_{i,j},q_j) )\n= \\sum_{i=1}^m n(1-\\frac{n_{q_j}}{n})\n= \\sum n( 1-f_r(A_j = q_j | X) )\n$$\n\n- 因为 $n( 1-f_r(A_j = q_j | X) ) \\geq 0 \\, , \\, 1 \\leq j \\leq m$，若让 $\\sum_{i=1}^n  d(X_i,Q)$ 最小化，则需让每一个 $n( 1-f_r(A_j = q_j | X) )$ 取最小值，即 $f_r(A_j = q_j | X)$ 必须取最大值。\n\n## 思考\n\n## 参考\n[1] Jiewei Han, Micheline Kamber and Jian Pei. 数据挖掘 (第三版) [M]. 机械工业出版社, 2018, 48-49.  \n[2] Bezdek J C. A convergence theorem for the fuzzy ISODATA clustering algorithms [J]. IEEE transactions on pattern analysis and machine intelligence, 1980 (1): 1-8.  \n[3] Ismail M A, Selim S Z. Fuzzy c-means: optimality of solutions and effective termination of the algorithm[J]. Pattern recognition, 1986, 19(6): 481-485.  \n[4] Park H S, Jun C H. A simple and fast algorithm for K-medoids clustering[J]. Expert systems with applications, 2009, 36(2): 3336-3341.  ","tags":["K-Means"],"categories":["Paper"]},{"title":"论文 | 通过快速查找和发现密度峰值进行聚类","url":"/2018/05/Clustering-by-fast-search-and-find-of-density-peaks.html","content":"\n\n{% note default %}\n原文：Clustering by fast search and find of density peaks  \n作者：Alex Rodriguez and Alessandro Laio  \n来源：Science 344.6191(2014), 1492-1496.\n{% endnote %}\n\n\n## 摘要\n\n聚类分析的目的在于根据元素的相似性将元素分类。而该论文基于这样一种观点的提出新的方法，即聚类中心的密度高于其邻居，而密度高的点相对较远。这个想法构成了聚类过程的基础，其中簇的数量直观地产生，异常值被自动地发现并从分析中排除，并且聚类被识别，而不管它们的形状和嵌入它们的空间的维度如何。\n\n<!-- More -->\n\n## 正文\n\n### 不同的聚类策略\n\n#### 基于距离的方法\n在 `K-means` 和 `K-medoids`，聚类是以距离聚类中心很小的距离为特征的数据集合。\n\n然而，因为数据点总是被分配到最近的中心，所以该类算法只能发现球形的簇，而在发现任意形状的簇时会遇到困难。\n\n> 提示：`K-均值 (K-Means)` 的方法仅当簇中均值有定义时才有意义，而当涉及具有标称属性的数据时，K-均值的方法失效。而这里可采用 `K-众数 (K-Modes)` 的变体，即采用 `基于频率` 的方法来更新簇的众数，对具有标称属性的数据进行聚类。当然，还有 `K-Prototype` $^{[1,2]}$、`K-Means++` $^{[3]}$ 等优化版本的算法。\n\n#### 基于密度的方法\n通过基于数据点局部密度的方法很容易检测具有任意形状的簇。其主要思想是：在某领域 (对象或数据点的数目) 内，给定密度阈值，将密度低于该阈值的数据点视为噪声丢弃，并将其分配给不连续的高密度领域的其他簇。这样的方法可用来过滤噪声或离群点，发现任意形状的簇。\n\n`DBSCAN` (Density-Based Spatial Clustering of Applications with Noise) 是一个基于密度的聚类算法，它将簇定义为密度相连的点的最大集合，能够把具有足够高密度的领域划分为簇。在噪声的空间数据库中可发现任意形状的聚类。\n\n然而，从上述当中可知，除了要选择合适的阈值，且它缺少均值漂移的聚类方法。虽然这种方法允许发现非球形簇，但仅适用于由一组坐标定义的数据。\n\n#### 本文改进的方法\n首先，该算法提出假设：类簇中心被具有较低局部密度的 `邻居点` 包围，且与具有较高密度的 `任何点` 有相对较大的距离。对于每一个数据点 i，要计算 `两个量`：点的局部密度 $\\rho_i$ 和该点到具有更高局部密度的点的距离 $\\delta_i$。而这两个值都取决于数据点间的距离 ${d}_{ij}$ (欧几里得距离，也称 `欧式距离`)。数据点的局部密度定义为：\n\n$$ \\rho_i = \\sum_j \\chi(d_{ij} - d_c) $$\n\n\n其中 $\\chi(x)$ 为 0-1 函数，如果 x < 0，那么 $\\chi(x) = 1$；否则 $\\chi(x) = 0$，$d_{c}$ 是一个 `截断距离`。基本上，$\\rho_i$ 等于与点 i 的距离小于 $d_{c}$ 的点的个数。算法只对不同点 $\\rho_i$ 的相对大小敏感，这意味着对于大数据集，分析结果在 $d_{c}$ 的选择方面具有很好 `鲁棒性`。\n\n- $\\delta_i$ 是通过计算点之间的 `最小距离` 来测量的，即数据点 i 与距离它最近的、密度更高的点 j 的距离最小值式：\n\n\t> 提示：在图 1-1.(A) 中可知，数据点是按照密度降序排列。\n\n$$ \\delta_i = min_{j:\\rho_j>\\rho_i}(d_{ij}) $$\n\n- 若数据点 i 是密度最大的点，$\\delta_i$ 为所有节点中到数据点 i 的最大距离：\n\n$$ \\delta_i = max_j(d_{ij}) $$\n\n如图 1-1 所示，其展示了算法的核心思想。图 1-1.(A) 展示了二维空间中的 28 个点，`且 A 中数据点是按照密度降序排列`。图 1-1.(B) 中以 $\\rho_i$ 作为横坐标，$\\delta_i$ 作为纵坐标，画二维图，并称其为决策图。可以发现点 1 和点 10 的  $\\rho_i$ 和 $\\delta_i$ 最大，故将其作为类簇中心。\n\n> 点 9 和点 10 的 $\\rho_i$ 相似，但 $\\delta_i$ 值却有很大差别：点 9 属于点 1 的类簇，且有其它几个更高 $\\rho_i$ 的点距其很近，然而点 10 拥有更高密度的最近邻属于其它的类簇。  \n> \n> 所以，正如预期的那样，只有具有高 $\\delta_i$ 和相对较高 $\\rho_i$ 的的点才是 `类簇中心`。因为点 26、27、28 是孤立的，所以有相对较高的 $\\delta_i$ 值和低 $\\rho_i$ 值，它们可以被看作是由单个点做成的类簇，也就是 `异常点`。\n\n![图1-1算法在二维空间的展示](/images/illustration/Paper/2018/05/Clustering-by-fast-search-and-find-of-density-peaks_1-1.jpg)\n<center>图 1-1 算法在二维空间的展示</center>\n\n类簇中心找到后，剩余的每个点被归属到它的有更高密度的最近邻所属类簇。类簇分配只需 `一步即可完成`，不像其它算法要对目标函数进行 `迭代优化`。\n\n在聚类分析中，定量的衡量分配的可信度是很重要的。在该算法中，首先为每个类簇定义一个 `边界区域` (即分配到该类簇的点集合，且与其它类簇的点的距离小于 $d_c$)，然后为每个类簇的找到其边界区域中密度最高的点 $\\rho_b$，并以来表示该点的密度。若类簇中局部密度值比 $\\rho_b$ 大的点被看作是类簇的核心部分 (即分配到该类簇的可靠性较高)，其他点 (类簇中局部密度值比 $\\rho_b$ 小的点) 被看作是类簇的 `光晕部分` (亦可被看作是噪声)。\n\n![图1-2合成点分布的结果](/images/illustration/Paper/2018/05/Clustering-by-fast-search-and-find-of-density-peaks_1-2.jpg)\n<center>图 1-2 合成点分布的结果</center>\n\n(A) 为绘制点分布的概率分布。(B和C) 分分别为 4000 和 1000 样本点的点分布。且每个点以其颜色表示所属类簇，黑色点属于光晕类簇 (噪声点)。(D和E) 为 (B和C) 相应的决策图，其中心由相应簇来着色。(F) 作为样本维度的函数，分配给不正确聚类的点的分数。误差线表示平均值的标准误差。\n\n从图 1-2.(F) 中可以看到，错分点的比例即使在只有 1000 个点的小样本中仍保持在 1% 以下，说明算法有很好的鲁棒性。\n\n从图 1-3 中可以看到，该算法对于各种数据级都能达到很好的聚类效果 (图中为引用文献中的测试用例结果)。\n\n![图1-3引用文献中的测试用例结果](/images/illustration/Paper/2018/05/Clustering-by-fast-search-and-find-of-density-peaks_1-3.jpg)\n<center>图 1-3 引用文献中的测试用例结果</center>\n\n## 思考\n\n1. 摘要部分提到的，异常点能 `自动地` 被分析出来，但从它的 Matlab 源码可知，还是需要人为判断异常点 (与问题三结合思考)？\n2. 文中提到的截断距离 $d_c$，该设定多少才算较合理？\n3. 文中判断簇中心的两个参数量 $\\delta_i$ 和 $\\rho_i$，即同时具有相对较高的距离和局部密度可选为簇中心，那么如何定义相对较高的具体值？\n\n## 参考\n\n[1] Huang Z. Clustering large data sets with mixed numeric and categorical values [C]. 1997: 21-34.  \n[2] Huang Z. Extensions to the k-means algorithm for clustering large data sets with categorical values [J]. Data mining and knowledge discovery, 1998, 2(3): 283-304.  \n[3] San O M, Huynh V N, Nakamori Y. A clustering algorithm for mixed numeric and categorical data [J]. Journal of Systems Science and Complexity, 2003, 16(4): 562-571.  \n\n\n","tags":["机器学习"],"categories":["Paper"]},{"title":"笔记 | 高级软件工程 & 导论","url":"/2018/05/Sofeware-Engineering.html","content":"\n## 序言\n在软工系列课程上，老师常提及的一条等式  `软件 = 程序 + 软件工程` ( 或 `软件 = 程序 + 文档`)，即一般情况讨论，一款软件产品的诞生之际总是伴随着一系列的软件过程。\n\n那么如何充分理解软件工程 (过程)？从本书作者理念出发，我所理解的即应该时刻对软件产品持有 `生命周期` 的思维模式，将 `需求、建模、设计、实现、测试、维护` 等工程阶段联系起来，以自身代入案例环境中，去模拟开展软件过程的一系列活动，而非割裂。而这样的动态过程中，不仅仅是枯燥地学习理论、方法，则更像是问题所需、问题导向的理论应用过程。\n\n当然，软件工程作为一门工程学科，学习过程的最大收获可以说是对 `项目思维模式` 的掌握。譬如，我们可以抛开软件产品的范畴，谈谈现实生活的实例：假若你需要在一定时限内掌握一门新知识、任务，则我们的做法可以从调研、计划、布局、实施，直至验收，即类似的过程可复用软件工程的方法。\n\n最后，也是想声明的一点：学习软件工程的过程中，无可避免地将反映本人的一些观点、倾向，当然这也反映该学科需要 `多沟通` 的特点，若有不恰当、错误之处，欢迎大伙出建议、斧正。\n\n<!-- More -->\n\n- 参考书目：\n\t- 《 软件工程 》. Ian Sommerville 著：计算机科学丛书，且是著名软件工程学家 Ian Sommerille 系统介绍软件工程理论的经典教材。\n\t- 《 构建之法(第二版) 》: 待整理。贴上本书豆瓣的书评，供朋友评判，做出抉择。[构建之法(第二版)](https://book.douban.com/subject/26577755/) \n\n- 更新进程\n\t- 2018.05.02 - 完成初稿；\n\t- 2018.05.04 - 更新正文：导论部分  (第 4 / 8 章)；\n\n## 零 总览\n- 软件工程导论\n\t- [壹 软件过程](#壹-软件过程)\n\t- [贰 敏捷软件开发](#贰-敏捷软件开发)\n\t- [叁 需求工程](#叁-需求工程)\n\t- [肆 系统建模](#肆-系统建模)\n\t- [伍 体系结构设计](#)\n\t- [陆 设计与实现](#)\n\t- [柒 软件测试](#)\n\t- [捌 软件进化 / 软件维护](#)\n- 高级软件工程\n\t- [玖 软件复用](#)\n\t- [拾 基于组件的软件工程](#)\n- 软件管理\n\t- [拾壹 项目管理](#)\n\t- [拾贰 项目规划](#)\n\n## 壹 软件过程\n\n- 学习目标\n\t- 3个一般的 `软件过程模型`；\n\t- 了解软件需求工程、开发、测试和进化中所涉及的 `基本过程活动`；\n\t- 理解为什么软件过程要有效地组织以应对软件需求和设计上的变更；\n\t- Rational 统一过程 (RUP).\n- 软件过程必须具有的基本活动\n\t- 软件描述\n\t- 软件设计和实现\n\t- 软件有效性验证\n\t- 软件进化\n- 没有“理想”的软件过程 -- 寻找平衡点\n\t- 计划驱动过程：提前计划好所有的过程活动，再按计划去考核过程的执行。\n\t- 敏捷过程：计划是增量式的，且容易根据不断变化的客户需求变更过程。更多详细内容见 `第叁章`。\n\t\n### 软件过程模型\n- 软件过程：产生一个软件系统的一系列活动。\n- 软件过程的简化表示 (抽象表示)。\n- 每个过程模型都是从一个特定的侧面表现软件过程，所以只提供过程的部分信息。\n\n\t> 如过程活动模型表现了这些活动和他们的顺序，但可能表现不出人们在这些活动中的角色。\n\t\n#### 瀑布模型\n![图1-1瀑布模型](/images/illustration/Reading/2018/05/Sofeware-Engineering_1-1.png)\n<center>图 1-1 瀑布模型</center>\n\n- 计划驱动模型；\n- 该模型将基本的过程活动、描述、开发、有效性验证和进化，看成是一些界限分明的独立的过程阶段。\n\t- 需求分析和定义：通过咨询系统用户建立系统的服务、约束和目标，并对其详细定义形成系统描述。\n\t- 系统和软件设计\n\t\t- 系统设计 -- 建立系统的总体体系结构，将需求区分为硬件需求和软件需求。\n\t\t- 软件设计 -- 识别和描述一些基本的软件系统抽象及其之间的关系。\n\t- 实现和单元测试\n\t\t- 软件设计实现 -- 实现为一组程序或程序单元。\n\t\t- 单元测试 -- 验证每个单元是否符合其描述。\n\t- 集成和系统测试\n\t\t- 集成 -- 集成单个的程序单元或一组程序。\n\t\t- 系统测试 -- 评估系统的可靠性；是否满足软件需求。\n\t- 运行和维护\n\n#### 增量式开发\n![图1-2增量式开发](/images/illustration/Reading/2018/05/Sofeware-Engineering_1-2.png)\n<center>图 1-2 增量式开发</center>\n\n- 即可是计划驱动的，也可是敏捷方法的。\n\t- 系统增量是提前定义好的，即为 `计划驱动方法`。\n\t- 最初的增量是定义好的，但往后的增量的开发取决于项目的进展情况及客户的优先选择，即为 `敏捷方法`。\n- 系统的开发是建立一系列的版本 (增量) 每个版本添加部分功能到先前版本中。\n- 增量式开发的特性\n\t- 降低了适应用户需求变更的成本。\n\t- 开发过程中及时得到用户已做的开发工作的反馈意见。\n\t- 更快地交付和部署有用的软件到客户方。\n\n#### 面向复用的软件工程\n基于复用开发的一般过程模型如图 1-3 所示。初始需求描述阶段、有效性验证阶段与其他过程差不多，面向复用过程的中间阶段是不同的。\n\n![图1-3面向复用的软件工程](/images/illustration/Reading/2018/05/Sofeware-Engineering_1-3.png)\n<center>图 1-3 面向复用的软件工程</center>\n\n- 中间阶段：即组件分析、需求修改、使用复用的系统设计、开发和集成阶段。\n\t- 组件分析：需求描述 -> 搜组件 (往往只提供所需的部分功能)。\n\t- 需求修改：根据得到组件信息分析需求，再修改需求以反映可得到的组件。\n\t- 使用复用的系统设计：设计系统的框架或者重复使用一个已存在的框架。\n\t- 开发和集成\n\n### 过程活动\n\n#### 软件描述\n- 软件描述或需求工程是理解和定义系统需要提供什么样的服务，以及找出开发和运行中受到哪些约束。\n- 需求工程过程的主要阶段，如图 1-4 所示。\n\t- 可行性研究\n\t- 需求导出和分析\n\t- 需求描述\n\t- 需求有效性验证\n\n![图1-4需求工程过程](/images/illustration/Reading/2018/05/Sofeware-Engineering_1-4.png)\n<center>图 1-4 需求工程过程</center>\n\n#### 软件设计和实现\n- 软件设计和实现阶段是把系统描述转换成一个可运行的系统的过程。\n- 软件设计是对实现软件的结构、系统的数据、系统组件间的接口以及所用的算法的描述。这是一反复、迭代的过程。\n\n#### 软件有效性验证\n- 程序测试：用模拟测试数据运行系统。\n- 测试过程各阶段\n\t- 组件 (单元) 测试：每个组件单独测试；组件可是简单实体，如函数、对象类或这些实体的集合。\n\t- 系统测试：集成组件形成完整系统，对组件组成的子系统测试。\n\t- 接收测试：客户提供真实数据测试系统。\n\n#### 软件进化/软件维护\n软件工程不再是开发和维护两个独立的过程，而是一个进化过程。即软件在其生命内不断随着需求的变更而变更的进化式过程。\n\n![图1-5系统进化](/images/illustration/Reading/2018/05/Sofeware-Engineering_1-5.png)\n<center>图 1-5 系统进化</center>\n\n### 应对变更\n- 有效降低变更成本\n\t- 变更避免：预测变更，如 `原型系统` 的开发，客户试用原型，在花费高额的软件生产成本之前重新定义需求。\n\t- 变更容忍：`增量开发`，即使单个增量(系统一小部分)的修改来适应变更，以较低成本处理变更。\n- 应对变更系统需求的方法\n\t- 系统原型：快速开发一个系统版本或系统一部分，以检验客户需求和某些设计决定的可行性，即它支持 `变更避免`。\n\t- 增量交付：系统增量地交付给用户，给用户评审和试用。即它支持 `变更避免` 和 `变更容忍`。\n\n#### 原型构造\n- 原型是一个软件系统的最初版本，用于验证概念、试用设计选项、发现更多的问题和可能的解决方法。\n- 原型开发的过程模型如图 1-6 所示。\n\t\n\t![图1-6原型开发的过程](/images/illustration/Reading/2018/05/Sofeware-Engineering_1-6.png)\n\t<center>图 1-6 原型开发的过程</center>\n\t\n\t> 最后一阶段：原型评估，则必须安排用户培训，应根据原型的目标制定一个评估计划。即用户需习惯并适用新系统，一旦他们自然地使用了系统，将可能发现错误和被遗漏的需求。\n\n- 不强求原型是可执行的。\n\n\t> 基于纸质的模型系统的用户界面，用户和这个界面交互，但他们的请求被传递给一个人，该人员解释此请求并输出相应的响应。\n\t\n#### 增量式交付\n- 增量式开发是软件开发的一种方法，如图 1-7 所示。\n\n\t![图1-7增量式交付](/images/illustration/Reading/2018/05/Sofeware-Engineering_1-7.png)\n\t<center>图 1-7 增量式交付</center>\n\n- 增量式开发过程的好处\n\t- 早期的增量作为原型，从中获得对后面系统增量的需求经验。\n\t- 每一增量会满足他们大多数需求，即软件马上就能使用。\n\t- 具有高优先权的服务被首先交付，而后继有增量不断被集成进来，使得最重要的系统服务接受了多次测试。\n- 增量式交付存在的问题\n\t- 软件描述和软件本身一起开发是迭代过程的本质。在增量方法中，直到最后的增量描述完成，才会有完整的系统描述。而许多机构 (如政府) 的采购模型是，系统开发合同中附带完整的系统描述，即相互冲突。\n\t- 旧系统的所有功能与新系统的部分功能，多数用户宁可选前者，即获取反馈较困难。\n\n#### Boehm 的螺旋模型\n- 风险驱动的软件过程框架 (螺旋模型)\n\t- 在螺旋线中每个回路表示软件过程的一个阶段，如最里的回路可能与系统可行性研究有关，下一回路与系统需求定义有关等。\n\t- 螺旋线中每个回路被分成4部分：  \n\t1) 目标设置  \n\t2) 风险评估和规避  \n\t3) 开发和有效性验证  \n\t4) 规划  \n\n### Rational 统一过程\n- RUP 一般从3个视角描述过程\n\t- 动态视角：给出模型中随时间所经历的各个阶段。\n\t- 静态视角：给出所进行的过程活动。\n\t- 实践视角：提出在过程中可采用的良好实践建议。\n- RUP 是一阶段化模型，如图 1-8 所示。\n\t- 开端  \n\t\t- 目标是建立系统的一个业务案例。  \n\t\t- 识别所有与系统交互的外部实体 (人和系统) 并定义这些交互。\n\t\t- 适用这些信息评估系统对业务的贡献，若贡献微小，那么项目在此阶段结束。\n\t- 细化\n\t\t- 目标是增进对问题域的理解，建立系统的体系框架，给出项目计划并识别关键项目风险。\n\t\t- 输出系统的需求模型 (描述的用例、体系结构描述及开发计划)。\n\t- 构造：系统设计、编程和测试。\n\t- 转换：将系统从开发单位转移到用户单位，并使之在真实环境中工作。\n\n\t> 1) RUP 中的阶段是紧密与业务关联，而不是与技术层面关联。  \n\t> 2) RUP 把 `阶段` (开端、细化、构造、转换) 和 `工作流` (需求、分析、设计...) 分离，即各种 RUP 工作流在整个过程的所有阶段都是可能存放的。  \n\n\t![图1-8Rational统一过程的各阶段](/images/illustration/Reading/2018/05/Sofeware-Engineering_1-8.png)\n\t<center>图 1-8 Rational 统一过程的各阶段</center>\n\t\n- 实践视角\n\t- 迭代地开发软件；\n\t- 对需求的管理：记录并跟踪客户的需求；\n\t- 使用基于组件的体系结构，将系统体系结构组织成组件形态；\n\t- 可视化地建模软件：UML 模型表现软件的静态、动态视图；\n\t- 检验软件质量；\n\t- 控制对软件的变更：变更管理系统、配置管理程序和工具来管理软件的变更。\n- 静态视角\n\t- 聚焦在开发过程中所发生的活动上，这些在 RUP 描述中被称为工作流。\n\t- 此过程中包含6个核心过程工作流，3个核心支持工作流，见图 1-9 所示。\n\n\t![图1-9RUP中的静态工作流](/images/illustration/Reading/2018/05/Sofeware-Engineering_1-9.png)\n\t<center>图 1-9 RUP 中的静态工作流</center>\n\t\n## 贰 敏捷软件开发\n\n{% note success %} 开始敏捷开发篇章前，引入一有趣的例子。Jazz Band 模式，跟 “敏捷的开发模式” 类似，同样也可以产生优秀的作品。( 演奏中，Miles Davis 先用小号吹出主题 ( 类比为架构师 )，然之后到一旁抽烟。曲目交由其他人员即兴发挥。最后， Miles Davis 加入演奏，回应主题 )。\n\n感兴趣的可以观看视频：[Miles Davis So What](http://v-wb.youku.com/v_show/id_XMTUzNzUxOTEwNA==.html) {% endnote %}\n\n- 学习目标\n\t- 理解敏捷软件开发方法的基本原理、核心内涵，以及它与计划驱动软件开发方法的差别；\n\t- 极限编程；\n\t- 理解敏捷项目管理的 `Scrum` 方法；\n\t- 应用伸缩的敏捷方法时的事项和问题 -> 大型软件系统开发过程.\n\n### 敏捷方法\n- 敏捷方法是一种专注于快速开发的 `增量式开发`，`频繁地发布软件`、`降低过程开销`、生产高质量代码。他们使用户直接参与到开发过程中。\n- 敏捷方法的基本原理体现在 `敏捷宣言` 中：\n\t- 个体和交互胜过工具和过程；\n\t- 编写软件胜过书写详尽文档；\n\t- 用户合作胜过合同谈判；\n\t- 响应变更更胜过遵循计划.\n\t\n\t> 即我们更重视左边的项的价值，虽左右两边的项都有价值。\n\t\n- 大量的软件工程努力维护和进化现有的软件系统，而由敏捷方法的特性可知，敏捷方法维护的问题有：\n\t- 软件交付后的主要困难可能是继续让用户参与到过程中。\n\t- 保持开发团队的持续性，因没有参考文档可循，若一个敏捷开发团队解散了，则 `依赖于团队成员理解系统` 的 `隐式知识` 旧丢失了。\n- 混成方法：敏捷方法嵌入来自计划计划驱动式开发的某些技术。\n\n### 计划驱动开发和敏捷开发\n计划驱动和敏捷描述如图 2-1 所示。\n\n![图2-1计划驱动和敏捷描述](/images/illustration/Reading/2018/05/Sofeware-Engineering_2-1.png)\n<center>图 2-1 计划驱动和敏捷描述</center>\n\n- 敏捷方法：\n\t- 迭代发生在所有活动间。\n- 计划驱动方法：\n\t- 迭代发生在各个活动中，用 `正式文件` 在软件过程中各阶段间沟通。\n\n\t> `正式文件`：可视化作为各阶段的输出产物。\n- 在计划驱动和敏捷方法之间得到平衡，必须回答以下一些技术的、人员的和机构方面的问题。\n\t- 详尽的描述和设计 -> `计划驱动开发`\n\t- 交互用户并快速取得反馈 -> `敏捷开发`\n\t- 开发系统的规模；\n\t- 开发的系统类型，如有复杂时序需求的实时系统，通常需要相当详细的设计来实现分析 -> `计划驱动开发`\n\t- 预想的系统寿命有多长；\n\t- 什么样的技术支持系统开发 (敏捷方法通常依赖于工具，以跟踪设计进化)；\n\t- 开发团队的组织情况；\n\t- 影响系统开发的文化问题 (传统的工程机构有计划驱动的文化)；\n\t- 开发团队的成员专业水平；\n\t- 系统是否受制于外部法规 (如联邦的航空管理局 FAA 核准一个安全性要求极高的航空操作软件)；\n\n### 极限编程 (XP)\n- 极限编程所属敏捷方法，它集成了一系列好的编程经验。例如，频繁地软件发布、连续软件改善和客户参与到软件开发团队。\n- XP 中，所有的需求都表示为脚本 (称为用户故事情节)，它将直接实现为一系列任务。\n- 一个 XP 过程，产生了正在开发的系统的一个增量，具体如图 2-2 所示。\n\n![图2-2极限编程的版本循环](/images/illustration/Reading/2018/05/Sofeware-Engineering_2-2.png)\n<center>图 2-2 极限编程的版本循环</center>\n\n- 脚本卡是 XP 规划过程的主要输入。\n\t- 开发团队把每个 `脚本` 拆分成 `任务`，并估计实现所需人力资源。\n\t- 与客户交谈，定义需求，对脚本进行优先权排序。\n\n#### 极限编程中的测试\t\n- 很多增量开发方法的测试过程是很不规范的。\n- 为避免一些测试和系统验证方面的问题，XP 方法更加强调测试过程。\n- XP 当中测试的关键特性：\n\t- 测试优先的开发 (先写测试程序再写代码)；\n\t- 来自脚本的增量式测试开发；\n\t- 用户参与测试开发和有效性验证；\n\t- 自动测试系统的使用。将测试写成了可执行的组件，该测试组件是独立的。自动测试框架即是这样的一个系统。譬如 Eclipse 的 JUnit，JUnit 用于单元测试。\n\n#### 结对编程\n结对编程是有一些质量效益，但却不足以抵消它的开销。但信息共享在结对编程是很重要的，因为当有团队成员离开时，它降低了项目风险。\n\n### 敏捷项目管理\n- 项目管理的标准：计划驱动。\n- 适合增量开发 (敏捷方法) 的管理方法 (框架)：`Scrum`。\n\t- Scrum 的管理过程如图 2-3 所示。\n\n\t![图2-3Scrum的管理过程](/images/illustration/Reading/2018/05/Sofeware-Engineering_2-3.png)\n\t<center>图 2-3 Scrum 的管理过程</center>\n\n\t- Scrum 的 3 个阶段\n\t\t- 规划纲要阶段：建立大致的项目目标和设计软件体系结构。\n\t\t- 冲刺循环阶段：\n\t\t\t- 每个循环开发出一个系统增量；\n\t\t\t- 每个循环为一个计划单元，其中的工作有评估、特征选择和开发、软件实现；\n\t\t- 项目结束阶段：完善文档，如系统帮助和用户手册。\n\t\t- 冲刺循环阶段的特征：\n\t\t\t- 冲刺有固定长度，一般是 2-4 周，在 XP 过程中对对应与一个系统版本的开发。\n\t\t\t- 规划的起点，即积压的任务 (Backlog)，也是项目中要完成的工作清单。\n\t\t\t- 评估阶段：Backlog 需经过审查，并对它们进行优先级排序和风险指派。\n\t\t\t- 选择阶段：项目所有成员都要参加，和用户一起选择冲刺循环中要开发的特性和功能。\n\t\t\t- 开发阶段：达成共识将组织进行软件开发，每一天团队开发成员参与段时间会议，回顾开发过程，若有必要重新安排工作。且在此阶段开发团队是隔离于客户和机构的。\n\t\t\t- 冲刺循环阶段结束，对已做工作复查并交付给用户。\n\t\t\t\n\t\t\t> 所有交流都是通过 `Scrum Master` 进行，SM 可理解为调解人。体现了 Scrum 的思想，即整个团队被赋予决定的权利。\n\t\t\n\t- Scrum 适合分布式的开发环境。\n\n### 可扩展的敏捷方法\n- 敏捷方法的开发是为同一房间办公与交流的小团队开发使用，因此常被用于小型系统开发。\n- 可伸缩的敏捷方法也可适用于开发大型系统。\n- 大型、小型系统开发的区别 (可理解为可扩展的敏捷方法应用于大型系统的挑战)。\n\t- 大型系统经常由独立的、交互的子系统组成。不同团队独立开发不同子系统，且团队可能在不同地点或不同时区工作。\n\t- 大型系统包含了一系列的已存在的系统并与它们进行交互，许多系统需求关注这种交互。\n\t- 当一个系统由多个系统集成产生时，开发工作中重要部分是系统配置而不是原始代码开发。这不一定与增量式开发和频繁的系统集成兼容。\n\t- 大型系统通常具有不同的信息持有者，将不同的信息持有者加入开发流程中是必要的。\n- 伸缩的敏捷方法的两个观点\n\t- 照搬放大，即关注如何将这些方法应用到哪些 `小团队` 无法开发的 `大型项目` 中。\n\t- 渗透，即关注如何将敏捷方法介绍 `推广` 到拥有多年开发经验的 `大机构` 中。\n\t\n## 叁 需求工程\n\n- 学习目标\n\t- 了解用户需求、系统需求；\n\t- 了解功能需求、非功能需求；\n\t- 如何在软件需求文档中 `机构需求`；\n\t- 了解需求工程活动的内容及他们之间的关系；\n\t- 了解需求管理.\n\n- 一些概念\n\t- 用户需求：用自然语言加图的形式给出的关于系统 `需要提供` 哪些服务及系统操作受到哪些 `声明的约束`。\n\n\t> 高层 (抽象) 的概要需求。\n\t\n\t- 系统需求：详细给出系统 `将要提供` 的服务及系统所受到的约束。系统的需求文档也称功能描述。\n\n\t> 系统应提供哪些服务的详细描述。\n\n### 功能需求与非功能需求\n- 功能需求\n\t- 描述系统所提供的功能或服务。\n\t- 若是用户需求，就要用可以被系统用户理解的一种抽象方法描述功能需求。\n\t- 更具体的功能性系统需求则需要详细地描述系统功能、异常、输入和输出。\n- 非功能需求\n\t- 指那些不直接关系到系统向用户提供的具体服务的一类需求。简言之，他们对 `系统实现` 定义了 `约束`，如 I/O 设备的能力、与其他系统接口的数据的表示。\n\t- 非功能性系统需求：通常会从总体上规范或约束系统的特性。\n\n\t> 若一个非功能系统需求没有满足则可能使整个系统无法使用。\n\t\n\t- 非功能需求分类：表明非功能需求或是来源于所要求的软件特性 (产品需求)，或是来源于开发软件的机构 (机构需求)，或是来源于外部来源。如图 3-1 所示。\n\n\t![图3-1非功能需求的类型](/images/illustration/Reading/2018/05/Sofeware-Engineering_3-1.png)\n\t<center>图 3-1 非功能需求的类型</center>\n\n### 软件需求文档\n- 如表 3-1 所示，是基于 IEEE 标准的需求文档的结构。\n\t- 需求文档中内容的详细程序，取决于所要开发的系统的类型及所使用的开发过程。\n\n<center>表 3-1 需求文档结构</center>\n\n| 章节 | 描述 |\n| :--- | :--- |\n| 绪言 | 定义文档的读者对象，说明版本的修正历史，包括新版本为什么要创建，每个版本间的变更内容的概要 |\n| 引言 | 描述为什么需要该系统，简要描述系统的功能，解释系统是如何与其他系统协同工作的。描述该系统在机构总体业务目标和战略目标中的位置和作用 |\n| 术语 | 定义文档中的技术术语和词汇。假设文档读者是不具有专业知识和经验的人 |\n| 用户需求定义 | 这一部分要描述系统应该提供的服务以及非功能系统需求，该描述可以使用自然语言、图表或者其他各种客户能理解的标记系统。产品和过程必须遵循的标准也要在此定义 |\n| 系统体系结构 | 这一部分要对待建系统给出体系结构框架，该体系结构要给出功能在各个模块中的分布。能被复用的结构中组件要用醒目方式示意出来 |\n| 系统需求描述 | 这一部分要对功能和非功能需求进行详细描述。如有必要，对非功能需求要再进一步描述，例如定义与其他系统间的接口 |\n| 系统模型 | 这一部分要提出一个或多个系统模型，以表达系统组件、系统以及系统环境之间的关系。这些模型可以是对象模型、数据流模型和语义数据模型 |\n| 系统进化 | 这一部分要描述系统基于的基本设想和定位以及硬件和用户需求改变时所要做的改变。这部分对系统设计人员来说是有用的，因为这有助于他们避免一些设计决策，这些决策可能会限制未来系统的变更 |\n| 附录 | 这一部分要提供与开发的应用有关的详细、专门的信息。该附录的例子是硬件和数据库的描述，硬件需求定义了系统最小和最优配置，数据库需求定义了系统所用的数据的逻辑结构和数据之间的关系 |\n| 索引 | 可以包括文档的几个索引。除了标准的字母顺序索引外，还可以有图标索引、功能索引等 |\n\n### 需求描述\n- 即在需求文档中写下用户需求和系统需求。\n\t- 用户需求：从用户角度来描述系统功能需求和非功能需求，一般用自然语言、图形叙述。\n\t- 系统需求：\n\t\t- 用户需求的扩展；\n\t\t- 软件工程师开始系统设计的起点；\n\t\t- 解释如何能让系统提供用户需求.\n- 原则上系统需求应 `反描述` 系统的 `外部行为` 和对它的 `操作限制`，而不是描述系统如何设计、实现。\n\n\t> 当然，并不是不提及任何设计信息，这也是不可能的，例如系统初始的体系结构设计。\n\n#### 自然语言描述\n- 在使用自然语言书写需求时，为了尽力 `减少误解`，应有一些简单的指导原则：\n\t- 设计一个 `标准格式`，并保证所用的需求定义都遵循此格式书写。\n\t- 使用一致性的语言来区分强制性需求和可选性需求。\n\t\t- 强制性需求：必须支持的，定义时使用 `必须`。\n\t\t- 可选性需求：不是必要的，定义时使用 `应该`。\n\t- 对文本加亮 (粗体、斜体、颜色) 来突出显示关键性需求。\n\t- 避免使用专业术语和缩写语 (无法避免时应该在有标注说明)。\n\t- 任何情况下，都应尝试把需求原理和每一个用户需求联系起来。\n\n#### 结构化描述\n- 使用结构化方法来描述系统需求，则先为需求定义一个或多个的 `标准模板`，并将模板表示成结构化的表格形式。如表 3-2 所示，是胰岛素泵需求的结构化描述。\n\n<center>表 3-2 胰岛素泵需求的结构化描述</center>\n\n| 项目名称 | 胰岛素泵/控制软件/SRS/3.3.2 |\n| :--- | :--- |\n| 功能 | 计算胰岛素剂量；安全的胰岛素水平 |\n| 描述 | 计算所要传输的胰岛素剂量，这是在当前度量的血糖水平处于 3-7 个单位之间这样正常范围之内时的胰岛素计算 |\n| 输入 | 当前血糖读数 (r2)，先前的两个读数 (r0, r1) |\n| 来源 | 来自传感器的当前血糖读数。其他读数来自内存 |\n| 输出 | CompDose：所要传输的胰岛素剂量 |\n| 目的地 | 主控制循环 |\n| 行动 | 如果血糖水平是稳定的或往下掉或是上升但速率下降，则 CompDose 为 0。若血糖的水平是在上升且上升速率也上升，那么 CompDose 的计算方法是求当前血糖水平和先前血糖水平，再除以 4 并取整。若取整的结果为 0，那么 CompDose 就被设置成可以传输的最小剂量 |\n| 需求 | 两个先前的读数，这样血糖变化速率就可以计算出来了 |\n| 前置条件 | 胰岛素池容纳至少是单个传输剂量的最大值 |\n| 后置条件 | r0 被 r1 替换，然后 r1 被 r2 替换 |\n| 副作用 | 无 |\n\n- 标准格式描述功能需求时，应包括下列信息：\n\t- 关于所定义的功能或实体的描述；\n\t- 关于输入及输入来源的描述；\n\t- 关于输出及输出去向的描述；\n\t- 关于计算所需要的信息及系统中所使用的其他实体信息；\n\t- 关于所采取的行动的描述；\n\t- 如果使用一个功能方法，前置条件、后置条件的设定描述；\n\t- 关于操作的副作用，没有则填写无.\n\t\n### 需求工程过程\n- 需求工程过程包括4个高层活动：\n\t- 系统可行性研究：评估系统是否对业务有用。\n\t- 需求导出和分析：需求发现。\n\t- 需求描述：将需求转变为某种标准格式描述。\n\t- 需求有效性验证：检验需求是否正确地定义了客户所希望的系统。\n- 在实际需求工程是一个活动相互交错的迭代过程，如图 3-2 体现了这种交错性。\n\n![图3-2需求工程过程的螺旋模型](/images/illustration/Reading/2018/05/Sofeware-Engineering_3-2.png)\n<center>图 3-2 需求工程过程的螺旋模型</center>\n\n### 需求导出和分析过程\n- 反复的过程，也可看做是一种 `螺旋式活动`。\n- 需求发现 (需求导出)\n\t- 对准备建立的系统和正使用的系统进行信收集，并从中提取用户需求和系统需求的过程。\n\t- 与 `信息持有者` 通过交谈和观察进行交互，即可使用 `用例` 和 `原型` 来帮助对方理解系统。\n- 采访\n\t- 封闭式采访：即信息持有者回答一组 `锁定的问题`。\n\t- 开放式采访：需求工程团队 `即兴访问`，更深层次了解对方需求是什么。\n- 脚本\n\t- 脚本是对 `交互实例片段` 的描述。\n\t- 脚本开始于一个 `交互框架`，在导出过程中细节增加，直至产生一完整的交互描述。\n\t- 脚本的内容\n\t\t- 开始部分有一系统和用户期望的描述；\n\t\t- 标准事件流的描述；\n\t\t- 处理错误的描述；\n\t\t- 完成后系统状态的描述.\t\n- 用例\n\t- 统一建模语言 (UML) 的基本特征。\n\t- 用例的集合代表所有将会在系统需求中出现的交互。过程中的角色可为人、其他系统等。\n\t- UML 对于面向对象模型来说，是一约定俗成的标准，因此基于用例的导出被广泛应用于需求导出中。\n- 深入实际：如图 3-3 所示的需求分析的深入实际方法和原型法。\n\n![图3-3需求分析的深入实际方法和原型法](/images/illustration/Reading/2018/05/Sofeware-Engineering_3-3.png)\n<center>图 3-3 需求分析的深入实际方法和原型法</center>\n\t\n### 需求有效性验证\n- 有效性检查：任何一组需求都不可避免地要在不同用户之间协商。\n- 一致性检查：需求不应该彼此冲突。\n- 完备性检查：需求文档应包括所有系统用户想要的功能和约束。\n- 真实性检查：检查需求以保证需求能真正实现。\n- 可检验性检查：检查方法 -> 验证需交付的系统 -> 满足定义的需求。\n\t- 需求评审：主要是错误检查和不一致检查。\n\t- 原型建立：提供一可执行的系统模型，客户和最终用户在此基础检查系统。\n\t- 测试用例生成。\n\n### 需求管理\t\n- 大型软件系统的需求总是在变化的，即开发这些系统需满足某些棘手问题，则这些问题不可能被完全定义。如图 3-4 所示为需求进化的过程。\n\n![图3-4需求进化过程](/images/illustration/Reading/2018/05/Sofeware-Engineering_3-4.png)\n<center>图 3-4 需求进化过程</center>\n\t\n#### 需求管理规划\n- 需求识别：每一需求有 `唯一标识码`。\n- 变更管理过程：变更带来的影响和成本的评估活动。\n- 可追溯策略：`策略` 定义了需求间和需求与系统设计间的 `关系`；关系是要记录的，并附有记录的 `维护方法`。\n- 工具支持\n\t- 需求存储\n\t- 变更管理：如图 3-5 所示，即变更过程由有效工具来支持。\n\t- `可追溯性` 管理：需求间的 `关联` <- 自然语言处理技术 (NLP)\n\n\t![图3-5需求变更管理](/images/illustration/Reading/2018/05/Sofeware-Engineering_3-5.png)\n\t<center>图 3-5 需求变更管理</center>\n\n#### 需求变更管理\n- 问题分析和变更描述：问题或变更 -> 检验有效性 -> 反馈变更请求者 -> 导致两种结果：\n\t- 更加详尽的需求变更、提议；\n\t- 取消本次变更.\n- 变更分析和成本计算：需求文档修改、系统设计和实现的成本估算。\n- 变更实现：与编写程序类似，文档的 `可追溯性` 即 `关联性` 是通过最小化外部引用和尽量使之模块化来实现的。\n\n## 肆 系统建模\n\n- 学习目标\n\t- 如何用图形模型表示软件系统；\n\t- 基本的建模角度 (如上下文、交互、结构、行为等)；\n\t- 统一建模语言 (UML)；\n\t- 模型驱动工程.\n- 系统建模：建立系统抽象模型的过程\n\t- 图形建模；\n\t- 形式化建模 (数学模型). \n- 不同角度表述系统 `与 第陆章 中的「4+1」视图相仿`\n\t- `外部` -- 上下文模型：系统上下文；系统环境；\n\t- `交互` -- 交互模型：系统与环境之间；系统各组成部分之间；\n\t- `结构` -- 结构模型：系统的体系结构；\n\t- `行为` -- 行为模型：系统的动态行为和它对事件响应方式.\n\n### 上下文模型\n- 定义系统边界：定义系统上下文和系统与环境之间的依赖关系。\n- 上下文模型表示某一环境包括几个其他的自动系统 (忽略子系统之间及待描述的系统与它们之间的关联关系的类型)。\n- 结合业务过程模型 \n\t- 活动图：如图 4-1 所示。\n\n\t![图4-1活动图](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-1.png)\n\t<center>图 4-1 活动图</center>\n\t\n### 交互模型\n- 为用户交互建模 -> 识别用户需求。\n- 为系统各部分之间的交互建模 -> 系统结构能否实现系统所需的功能及其可靠性。\n\n#### 用例建模\n- 用例图：如图 4-2 所示。\n\n![图4-2用例图](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-2.png)\n\t<center>图 4-2 用例图</center>\n\n- 时序图：表示在特定用例中的交互发生顺序。如图 4-3 所示。\n\n![图4-3时序图](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-3.png)\n\t<center>图 4-3 时序图</center>\n\n### 结构模型\n\n> 课本第 6、18、19 章讲述软件体系结构的不同方面和软件体系结构建模。\n\n- 静态模型：表示系统设计的结构。\n- 动态模型：表示系统执行时的构成。\n\n#### 类图\n- 类图可表示系统中的类和这些类之间的关联。\n\n\t> 类与类之间的链接，表示类与类之间具有某种关系。\n\t\n\t- 简单类图：如图 4-4 所示。其中一对多关系的类图，类似于语义数据模型，即数据实体、与他们相关的属性。\n\n\t![图4-4简单类图](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-4.png)\n\t<center>图 4-4 简单类图</center>\n\n\t- 扩展类图：如图 4-5 所示。\n\n\t![图4-5扩展类图](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-5.png)\n\t<center>图 4-5 扩展类图</center>\n\n#### 泛化\n- 推断一些类的成员具有的某些共同特征，针对类的所有成员给出一般性的描述。如图 4-6 所示。\n\n![图4-6泛化关系](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-6.png)\n<center>图 4-6 泛化关系</center>\n\t\n#### 聚合\n- 一个对象 (全体) 可有由其他对象 (部分) 组成。如表示一条病人记录由 Patient 和一个不确定的 Consulation 组成。如图 4-7 所示，表示了一条病人记录由 Patient 和一个不确定的 Consulation 组成。\n\n![图4-7聚合关系](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-7.png)\n<center>图 4-7 聚合关系</center>\n\n#### 依赖\n如图 4-8 所示，展示了依赖关系。\n\n![图4-8依赖关系](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-8.png)\n<center>图 4-8 依赖关系</center>\n\n### 行为模型\n- 描述系统运行时的动态行为的模型，表示系统响应于所处环境的刺激所发生或可能发生的事情。\n- 刺激：`数据`、`事件`\n\t- 数据：一些数据到达必须由系统处理。\n\t- 事件：某些触发系统处理的事件的发生。\n\n#### 数据驱动的建模\n- 数据驱动模型描述一个 `动作序列`，该动作序列涉及输入数据的处理和相关 `输出的产生`。\n\n\t> `输出的产生`：指系统的响应。\n\n- 处理序列的方法：\n\t- `时序图`：强调系统中的对象。\n\t- `数据流图` (DFD)：关注于功能。\n\n#### 事件驱动模型\n- 事件驱动模型表示系统对内、外部事件的响应方式。\n- 基于事件的模型表示方法：状态图，表示系统状态和引起状态和引起状态改变的事件。其中状态图的表示如图 4-9 所示。\n\n![图4-9状态图](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-9.png)\n<center>图 4-9 状态图</center>\n\n### 模型驱动工程\n- 模型驱动工程 (MDE) 起源于模型驱动体系结构 (MDA)，该体系由对象管理组织 (OMG) 提出。\n- 支持者与反对方：\n\t- `支持者`：更高的抽象水平上考虑系统，不用关心实现细节，减少出错可能性，加速设计和实现过程，且可复用。\n\t- `反对方`：并不是模型所支持的抽象都是正确的、可实现的。\n\n#### 模型驱动体系结构\n- 计算独立模型 (CIM) -- `领域建模` -- 不同的 CIM 反映系统的不同方面。\n- 平台独立模型 (PIM) -- 表示静态系统结构和系统对内外事件的响应。\n- 平台特定模型 (PSM) -- PIM -> PSM。如图 4-10 所示，为一个复合平台特定模型实例。\n\n![图4-10复合平台特定模型](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-10.png)\n<center>图 4-10 复合平台特定模型</center>\n\n#### 可执行 UML：xUML\n- 为建立一 UML 可执行子集，模型类型可分为：\n\t- 领域模型：识别出系统的主要关注点，由 UML 的类图定义，包括对象、属性和关联。\n\t- 类模型：定义类及它们的属性和操作。\n\t- 状态模型：每一状态与一个类相关联，并且用来描述类的生命周期。","tags":["UML"],"categories":["Reading"]},{"title":"笔记 | 一个 APP 的诞生 ( 方法论 )","url":"/2018/03/Producting-An-Application.html","content":"\n## 序言\n\n[《 一个 APP 的诞生 》](https://book.douban.com/subject/26865230/)被定义是一本教科书、工具书，适合想通过 APP 实现自己的产品梦的受众通读，即通过本书可让你快速了解 APP 产品的整个流程，从零到一，创造 APP 产品。\n\n而通读本书籍后，或许你、我有同样的感受，即大部分内容是以设计师的角度看待问题的。这样，若你就是设计师，或许这将助你更加透彻理解 APP 的产出过程；若你是软件工程师，也可看待成是从另一角度理解软件过程。当然，这些知识只停留在书本层面，而对实际项目而言，有出入是无法避免的，但不失它的参考价值。简言之，这样一本图文并茂、实例贴近现实且含有众多跨界元素 (设计、开发、交互、产品等) 的工具书，特别是产品这一类别的书目 (下述还有同类型的书籍推荐)，不仅让你有机会感同身受业界优秀企业的工作流程，也是自身寻求产品方法论的不二选择。\n\n<!-- More -->\n\n- 推荐书目\n\t- 《 U一点·料 》：由阿里巴巴集团 1688.UED 团队历经多年实践之后的佳作，内容重实战、讲方法、求专业、论文化，且以 “道─术─器” 的思路为编排脉络，从设计观、思考体系、方法论上层层剖析，将零散的行业技术诀窍串成体系，对 “UED如何发展突破” 提出了自己的真知灼见。  \n\t贴上本书的 [豆瓣书评](https://book.douban.com/subject/26594029/)，供朋友评判，做出抉择。\n\t\n\t- 《 设计之下 》：由搜狐新闻客户端 UED 团队共同出品的佳作，分别以交互设计、视觉设计、设计师视觉，全面讲解了用户体验设计的流程和方法。  \n\t贴上本书的 [豆瓣书评](https://book.douban.com/subject/25817190/)，供朋友评判，做出抉择。\n- 更新进程\n\t- 2018.03.25 - 完成序言；\n\t- 2018.03.26 - 更新内容 ( 共 6 章 )；\n\t- 2018.04.02 - 更新完毕.\n\n## 零 思维导图 \n\n> 学习思路：根据思维导图的架构，掌握知识；以及参考部分项目经验，文档归纳。\n\n- 前景探索\n\t- 竞品分析\n\t\t- 熟悉竞品分析的流程；\n\t\t- 明确竞品分析的每个部分包含的内容；\n\t\t- 分析报告的输出.\n\t- 用户研究\n\t\t- 了解用户研究的方法及它们的定义；\n\t\t- 用户画像  \n\t\t1) 掌握建立的流程；  \n\t\t2) 用户画像的分类，每种分类的使用方法及优缺点；  \n\t\t3) 用户画像的构成、价值.  \n- 设计规范及流程\n\t- 建立设计规范的特定情况；\n\t- iOS 和 Android 规范的差别；\n\t- 主要元素及作用.\n- 交互设计\n\t- 用户体验\n\t\t- 交互设计师的工作内容、状况分析及处理；\n\t\t- 紧密联系生活.\n\t- 交互设计的基本流程\n\t\t- 交互设计五要素：`人`、`目的`、`环境`、`媒介`、`行为`；\n\t\t- 基本流程.\n- 视觉设计\n\t- Ui 设计\n\t\t- Ui 设计制作流程；\n\t\t- 对未来设计趋势的了解与把握.\n\t- 图标品质的提升\n\t- 界面细节设计\n\t\t- 栅格系统提升界面易读性与可用性；\n\t\t- 切图标注的知识与技能；\n\t\t- 设计资源命名及文件分类整理.\n- 开发实现\n\t- 如何与产品、运营、开发配合工作\n\t\t- 互联网企业中产品开发实现过程；\n\t\t- 主要工作岗位职责和工作性质，以及岗位配合的注意事项.\n\t- 发布制作完成的 APP\n\t\t- 发布方式\n\t\t- 常见市场\n- 线上运营\n\t- 运营的定义\n\t\t- 什么是运营及运营的目标；\n\t\t- 运营手段及运营岗位.\n\t- 线上运营活动：策划线上活动流程\n\t- H5 页面和 Banner 设计\n- 服务设计\n\n\t> 推荐阅读 *This is service design thinking* \\\\(^{[1]}\\\\)\n\t\n\t- 服务设计的概念\n\t- 服务设计的流程\n\t- 工具箱：熟悉常见服务设计工具\n- 跨界设计\n\n## 壹 前景探索\n\n### 竞品分析\n竞品分析，能带来的价值：\n\n- 企业：优势 (Strength，S) 和 劣势 (Weakness，W)\n- 设计：User Interface\n\n#### 为什么要竞品分析\n- 知己知彼\n\t- 市场：红海 (已知的市场空间)；蓝海 (还不存在的产品)\n\t- 动向：目标人群、运营策略、用户体验、用户反馈\n- 设计灯塔：权衡利益与设计成本的关系\n\n#### 如何做竞品分析\n- `确立` 竞争对手\n\t- 市场目标一致；\n\t- 目标用户相同；\n\t- 产品功能相同、相似；\n\t- 用户需求相同.\n\t\t\n> 选择优质和合适的竞品，再进行分析。如表 1-1 所示，定位于即时通信类 APP ，即所要考虑的竟品类型及竞争关系。\n\t\n<center>表 1-1 即时通信类 APP 的竟品类型及竞争关系</center>\n\n| 考虑因素 | 主要分析对象 | 参考分析对象 |\n| :------ | :--------- | :--------- |\n| 市场目标方向一致、目标用户群体大致相同、功能用户需求相似 | QQ、微信 | 陌陌、JUJU |\n| 市场目标方向不一致、功能需求互补 | YY、斗鱼 | -- |\n\n- `挖掘` 对手信息\n\t- 搜集资料\n\t\t- 数据资料，例如：APP 下载量，市场方面数据等。\n\t\t- 其他信息，例如：APP 新闻动态，研究报告，APP 评价等。\n\t- 搜集渠道\n\t\t- 公司内部资源\n\t\t- 运营部门\n\t\t- 搜索引擎\n\n- `分析` 数据信息\n\t- [分析数据模型](#分析数据信息)\n\t- 整合收集的信息 (企业战略、目标人群、交互设计、视觉设计、运营策略等)\n\n- `输出` 分析报告 -- [可视化输出](#输出分析报告)\n\n#### 分析数据信息\n\n- 分析数据模型\n\t- `SWOT` 模型，即道斯矩阵、态势分析法，经常用于企业战略制定、竞争对手分析。\n\t\n\t详细解释见：[MBAlib.智库百科.SWOT分析模型](http://wiki.mbalib.com/wiki/%E9%81%93%E6%96%AF%E7%9F%A9%E9%98%B5)\n\n\t> `SWOT` 分别代表企业的优势 (Stength)、劣势 (Weakness)、机会 (Opportunity) 和威胁 (Threats)。\n\t\n\t- 波士顿矩阵 \\\\(^{[2,3]}\\\\)，四象限分析法。详细解释见：[MBAlib.智库百科.波士顿矩阵](http://wiki.mbalib.com/wiki/%E6%B3%A2%E5%A3%AB%E9%A1%BF%E7%9F%A9%E9%98%B5)\n\n\t- KANO 模型 \\\\(^{[4]}\\\\)，一种典型的定性分析模型，经常用于绩效指标分类。其定义了顾客需求的三个层次：基本型需求、期望型需求和兴奋型需求。详细解释见：[MBAlib.智库百科.KANO 模型](http://wiki.mbalib.com/wiki/KANO%E6%A8%A1%E5%9E%8B)\n\n- 关于 SWOT 分析模型\n\t- SW：竞争优势指一企业超越其竞争对手的能力，这种能力有助于实现企业的主要目标 -- 盈利。  \n\t- OT：不利发展趋势所形成的挑战。\n\n<center>表 1-2 SWOT 分析模型</center>\n\n| 发展趋势 (负) | 条件 | 发展趋势 (正) |\n| :----: | :----: | :----: |\n| 劣势 (Weakness，W) | 企业自身自身实力与竞争对手比较 | 优势 (Strength，S) |\n| 威胁 (Threats，T) | 外部环境变化对企业可能的影响 | 机遇 (Opportunity，O) |\n\n> 举例：对蚂蜂窝 APP 实行 SWOT 分析法\t\n\n- `S`：旅游攻略是蚂蜂窝进军移动端的拳头产品，手持海量 UGC 数据和攻略引擎技术。\n- `W`：盈利模式单一，知识与传统 OTA 合作的佣金 + 广告模式)。\n- `O`：OTA & O2O。\n- `T`：行业壁垒；变现能力还能支持技术和运营走多远？\n\n- 关于波士顿矩阵：波士顿矩阵区分出4种业务组合，如表 1-3 所示。\n\n<center>表 1-3 波士顿矩阵业务组合</center>\n\n|   | 销售增长率 | 市场占有率 |\n| :--- | :--- | :--- |\n| 明星类产品 | 高 | 高 |\n| 瘦狗类产品 | 低 | 低 |\n| 问题类产品 | 高 | 低 |\n| 现金牛类产品 | 低 | 高 |\n\n#### 输出分析报告\n- 竞品分析包括内容：\n\t- 市场趋势、行业现状； -- `SWOT 分析法`\n\t- 竞品的企业愿景、APP 定位、发展策略；\n\t- 目标用户，用户画像；\n\t- 核心功能；\n\t- 交互设计；\n\t- APP 优缺点；\n\t- 运营及推广策略；\n\t- 总结并建议.\n\n### 用户研究\n用户研究最终的输出产物之一就是用户画像，即用户研究 => 用户画像。\n\n#### 一般方法\n- 场景观察：正常的工作环境或其他产品合适的 `物理场景` 中观察用户并与其交流。\n- 可用性测试：用户在一定场景下使用产品。由可用性工程师对 `用户操作过程、习惯` 等进行 `观察、记录和测量`，以评估产品的可用性问题。\n- 问卷调查：用 `统一、严格设计的问卷` 收集研究对象有关的 `心理特征` 和 `行为数据` 资料。\n- 访谈研究：在访问用户过程中，提示被访者对某一问题的 `潜在冬季、新年、态度和感情`。\n\n\t> 潜在冬季、新年、态度和感情？\n\n- 焦点小组：定性研究方法。一定的组织结构，让用户一起进行 `互动`，用以激发新的思考和想法。\n- 桌面研究：对已收集信息进行调研活动，即对二手资料进行搜集、筛选，并判断问题是否已经 `局部解决` 或 `全部解决`。\n- 专家评估：组织各领域专家运用专业方面知识和经验，通过直观归纳，对产品过去、现在及发展过程进行综合分析、研究，再作判断。\n\n#### 用户画像\n\n- 输出用户画像的流程\n\t- 获取研究用户信息\n\t- 细分用户群\n\t- 建立并丰富用户画像\n\n- 建立用户画像的方法\n\t- `定性` 用户画像\n\t- 经 `定量验证` 的 `定性` 用户画像\n\t- `定量` 用户画像\n\t\n\t> 定性 (性质) 研究：创立理论的过程。即 `具体向抽象转化`，形成理论。通常以 `访谈、观察` 等方法收集第一手描述性资料 (归纳法)。 \n\t> \n\t> 定量 (度量) 研究：`提出理论假设`，使用 `问卷` 等工具收集具有数量关系的资料，对资料进行 `量化`，以 `数据形式` 验证假设。\n\n- 定性用户画像 -- `直接分用户群`\n\t- 步骤  \n\t1) 定性研究访谈；  \n\t2) 细分用户群；  \n\t3) 建立细分群体的用户画像。 \n\t- 定性用户画像优缺点\n\t\t- 优点 - 省时省力、简单、需要专业人员少。\n\t\t- 缺点 - 缺少数据支持和验证。\n\t\t\n- 经定量验证的定性用户画像 -- `分了用户群再验证`\n\t- 步骤  \n\t1) 定性研究访谈；  \n\t2) 细分用户群；  \n\t3) 定量验证细分群体；  \n\t4) 建立细分群体的用户画像。  \n\t- 经定量验证的定性用户画像优缺点\n\t\t- 优点 - 有一定的定量验证工作，需要少量的专业人员。\n\t\t- 缺点 - 工作量较大，成本较高。\n\t\t\n- 定量用户画像 -- `验证了再分用户群`\n\t- 步骤  \n\t1) 定性研究；  \n\t2) 多个细分假设；  \n\t3) 通过定量收集细分数据；  \n\t4) 聚类分析细分用户；  \n\t5) 建立细分群体的用户画像。  \n\t- 定量用户画像的优缺点\n\t\t- 优点 - 有充分的佐证、更加科学、需要大量的专业人员。\n\t\t- 缺点 - 工作量较大，成本高。\n\n- 用户画像包含以下元素：\n\t- 基本信息 (姓名、照片、年龄、家庭状况、收入、工作)；\n\t- 典型场景；\n\t- 目标和动机；\n\t- 需求和痛点；\n\t- 对 APP 的态度；\n\n\t如图 1-1 以音乐沉侵爱好者为例，建立用户画像。\n\t\n![音乐沉侵爱好者的用户画像](/images/illustration/Reading/2018/03/Producting_An_Application_1-1.png)\n<center>图 1-1 音乐沉侵爱好者的用户画像</center>\n\n#### 调查问卷设计\n设计问卷的目的是为了更好地搜集信息或者定量去验证定性研究的结果。故在问卷设计的过程中，要把握调查的目的和需求，具体可分为以下几个步骤：\n\n- 问卷设计流程\n\t- 确定所需要的信息\n\t\t- 调研目的\n\t\t- 竞品分析文档\n\t\t- 用户画像\n\t- 确定问题顺序：`先易后难`\n\t- 问卷的测试和修改\n\t\t- 投放预测试\n\t\t- 问题修改\n\n- 设计问卷题目\n\t- 用户基本信息 (年龄、爱好、APP 相关生活行为)\n\t- 用户使用 APP 典型场景 (碎片化时间使用，使用频次)\n\t- 用户的痛点与需求\n\t\n\t> 可参考书本 P27-30 的实例，全民 K 歌用户体验调研问卷。\n\t\n## 贰 交互设计\n\n### 用户体验\n- 用户体验，即站在用户角度考虑问题。\n- 交互设计师\n\t- 核心价值：沟通\n\t- 工作流程：\n\t\t- 对重要或者紧急设计任务进行准备、分工、安排；\n\t\t- 写解决方案，画稿；\n\t\t- 评审待确认的设计；\n\t\t- 总结方案，输出结果，同步给部门；\n\t\t- 输出设计稿，与产品、研发及时沟通；\n\t\t- 与项目接口人沟通.\n\t\n### 交互设计基本流程\n\n#### 交互五要素\n- 人 (Amber)：有记录灵感的设计师，有需求的人称之为用户。\n- 媒介 (Tools)：用户使用的设备。\n- 行为 (Behavior)：用户的具体操作。\n- 目的 (Purpose)：要达到某种的效果。\n- 环境 (Enviroment)：用户使用的设备，这里指手机。\n\t\n![交互设计五元素](/images/illustration/Reading/2018/03/Producting_An_Application_2-1.png)\n<center>图 2-1 交互设计五元素</center>\n\n#### 如何参与一个项目\n\n交互设计师接到一个项目或者需求后，他们的工作流程基本按照以下流程执行，即需求分析、信息架构设计、流程图设计、原型设计、最终进入产品的可用性测试，当然需求分析阶段完成后，也可以进行可用性测试，以验证方案的可行性。图 2-2 描述了交互设计师如何参与一个项目。\n\n![交互设计师如何参与一个项目](/images/illustration/Reading/2018/03/Producting_An_Application_2-2.png) \n<center>图 2-2 交互设计师如何参与一个项目</center>\n\t\n> 提示：实例中，我们以便签 APP 为主题展开讨论的。\n\n- 1) 需求分析\n\t- 了解需求\n\t- 用户调研\n\t- 需求定位：竟品分析、头脑风暴、绘制故事板、人物建模 (用户画像)、产品数据\n\t- `实例`：在需求分析阶段，我们从诸多研究方法和数据中简明得出便签 APP 的产品定位：  \n\t\t- 产品定义\n\t\t\t- 使用人群 -- `设计师、学设计的学生`  \n\t\t\t- 主要功能 -- `记录想法、分享想法`  \n\t\t- 用户需求\n\t\t\t- 使用目标 -- `随时随地记录想法、把想法分享给同事和朋友`  \n\t\t\t- 使用场景 -- `商场、会议、课堂、工作、训练、作图`  \n\t\t\t- 用户目标 -- `操作方便快捷、耗流量少、学习成本低`\n\n- 2) 信息架构\n\t- 需求收集\n\t- 需求删减\n\t- 定义优先级\n\t- 用户任务\n\t- `实例`：根据需求分析得到的信息，接下来便梳理架构，开始架构草图设计。如图 2-2 所示。\n \n\t![信息架构图](/images/illustration/Reading/2018/03/Producting_An_Application_2-3.png) \n\t<center>图 2-3 信息架构图</center>\n\t\n- 3) 流程图\n\t- 操作流程\n\t- 页面流\n\t- 布局设计\n\n- 4) 原型设计\n\t- 交互原型\n\t- 交互说明\n\t- 设计规范\n\t- 项目跟进\n\n- 5) 测试\n\t- 可用性测试\n\t- A/B 测试\n\t- 用户反馈\n\t- 产品数据\n\n#### 需求分析的考虑因素\n在产品设计的整个过程中，要充分考虑商业需求和用户体验的平衡。如图 2-4 所示，展示了需求收集需要考虑的因素。\n\n需求的删减是需求分析中很有必要的步骤，他是设计师们综合考虑各种因素，取舍得到的结果。\n\n![信息架构图](/images/illustration/Reading/2018/03/Producting_An_Application_2-4.png)\n<center>图 2-4 需求收集需要考虑的因素</center>\n\n#### 如何组织需求\n- 1) 定义信息优先级\n\t- 产品定位：核心功能，意味着这些功能的优先级最高。\n\t- 真实需求：区分次要需求。它们是围绕核心功能进行拓展的。\n\t- 需求删减：权衡删减需求。\n- 2) 信息架构：深度和广度要均衡。\n\n#### 流程图设计\n- 确定信息架构\n- 确定用户任务\n- 如何完成操作\n\n\t完成任务方法即我们所说的流程，任务流程是根据用户实际操作的心理和行为来确定的。  \n\t\n\t[实例] 人在使用纸质版的便签的流程：  \n\t\n\t- 首先拿出纸和笔；\n\t- 纸上记录想法；\n\t- 粘贴醒目的地方便于查看。\n\t\n\t在现实中使用便签的过程和在手机上使用便签的实际操作步骤基本吻合，如图 2-5 所示，展示了添加便签的流程图。\n\t\n\t> 这里的流程图设计，可以使用 C 语言程序设计中的程序流程图。\n\t\n![添加便签的流程图](/images/illustration/Reading/2018/03/Producting_An_Application_2-5.png)\n<center>图 2-5 添加便签的流程图素</center>\n\n#### 原型设计及设计原则\n- 确立功能和逻辑后\n- 设计草图\n- 低保真线框图\n- 高保真原型图\n\t\n\t图 2-6 是本人早期设计的沙漏记事 APP 的低保真线稿，强制插入了一段广告哈。而对应的高保真原型图，可参考对应的专题介绍。[「沙漏记事」APP](http://www.zcool.com.cn/work/ZMTU3NjcxMTI=.html)\n\t\n\t![沙漏记事APP低保真线稿](/images/illustration/Reading/2018/03/Producting_An_Application_2-6.jpg)\n\t<center>图 2-6 沙漏记事 APP 低保真线稿</center>\n\n#### 总结\n- 交互设计基本流程\n\t- 需求收集和分析\n\t- 定义优先级\n\t- 信息架构设计\n\t- 流程设计\n\t- 原型设计\n- 需求分析过程，要综合考虑 `商业`、`项目`、`用户` 三要素。\n\n## 叁 视觉设计\n\n### UI 设计\n\n#### UI 的定义\n用户界面 (User Interface，UI)，系统和用户之间进行交互和信息交换的媒介，它实现信息的内部形式与人类可接受形式之间的转换。\n\n#### UI 设计流程\n\n- 具体把 UI 设计流程分为前期准备和情绪板两个阶段。\n\t- 1) 定义：做好定义 / 用户细分。\n\t- 2) 找寻：找到同类竞品的 APP 安装并进行沉侵式体验。\n\t- 3) 分析：分析竞品并学习。\n\t- 4) 关键字：确定情感关键字。\n\t- 5) 收集：图片素材收集，建立情绪板。\n\t- 6) 分析：对情绪板进行色彩和质感分析。\n\t- 7) 访谈：用户验证确定设计风格。\n\t- 8) 完善：完善整个 APP 视觉设计。\n\n\t> Step 1 \\~ 4 为前期准备阶段，Step 5 \\~ 8 为情绪板阶段。\n- 做用户定义：如何定义用户在这不再重复阐述，详细见 [第一章 前景探索](#壹-前景探索)。\n- 找寻同类竞品 APP 使用并体验：站得高，看得远。即选择的竞品也要有足够的市场表现力。\n- 确定情感关键字：该 APP 的视觉所要表达的情感感受。\n- 情绪板：把每个人对情感的抽象理解成实际可定义的元素。\n\t- 关键字提炼；\n\t- 建立具象图库 (具体的事实物、场景) 和抽象；\n\t- 图库 (色彩质感等元素).\n- 对情绪板进行色彩和质感分析，即把握图片上的颜色、元素的感觉，再抽象成颜色方案。\n\n### 图标品质提升\n\n#### 素描色彩的基础\n- 素描的三大面五大调\n\t- 三大面：亮面，灰面，暗面。\n\t- 五大调：亮面，灰面，明暗交界线，反光部和投影。\n\n\t> 在构图中，我们都是通过假设光源的方法来进行创作。\n\t\n- 构图注意事项\n\t- 构图不能太小 (让人觉得画面不够饱满，显得小气)；\n\t- 构图应注重重心平衡；\n\t- 构图应注意透视的变化及比例关系.\n\n- 色彩的魅力\n\t- 色彩的冷暖：物体通过表面色彩给人温暖或凉爽的观感。\n\t- 色彩的轻重：质感与色感的复合感觉。\n\t- 色彩的前进性与后腿性：一般而言，暖色比冷色更富有前进的特性。\n\n#### 一个像素也是事儿\n- `边缘像素` 的完美方案：图标变虚问题 => 没有边缘对齐，故在矢量绘图当中，需要对齐边缘，对齐像素。\n- `旋转像素` 的完美方案：\n\t- 旋转中心点挪到任意定点，再旋转。\n\t- 若是旋转并缩放，建议先旋转再缩放。\n- Ai 到 Ps 的完美粘贴\n\t- 1) Ai 里选 `对齐像素网格`；\n\t- 2) Ps 里建一个图标大小相同的 `选区`，再粘贴进来，粘贴时最好选择 `形状图层`，这样便于后期编辑。\n\n#### 国际化的图标设计\n- 表现形式上符合全球化潮流的设计趋势。\n\n\t> 这里非常容易理解，例如地铁、高铁、机场的指示标志，还有厕所指示标志等。\n\n- 动感：动效与交互的相交融。\n- 质感：拟物、扁平和微质感，这里视具体情况而决定，如公司文化、应用受众、市场趋势等因素，总得来说，调研、分析工作是少不了环节。\n\n### 界面细节提升\n\n#### 栅格系统\n栅格系统，又称网格系统。主要以规则的网格阵列来指导和规范页面中的版面布局以及信息布局。当然，栅格系统也只是一种布局辅助工具，在实际项目中应灵活地根据需求在整体或布局合理应用，即综合 iOS 或 Android 的规范准则，总体把控每个元素与界面的协调感。\n\n#### 资源规范\n- 切图\n\t- iOS：选择一这种的分辨率，即 @2x，750 x 1334 px，再输出 @3x，@4x。当然，你的设计稿是基于 `矢量工具` 绘制的。\n\t- Android：MDPI (160 DPI)，HDPI (240 DPI)，XHDPI (320 DPI), XXHDPI (480DPI)，或更多。\n\t\n\t> 1) 关于切图适配的问题，除了上述的原始办法外，现有很多插件、工具可帮你完成此项工作了。  \n\t> 2) 一套切图尽可能适配 iOS 与 Android，即找准 @ 与 DPI 的大小关系即可。\n\t\n\t- 在标注文档中，可采用 `物理像素单位` 描述元素的大小、布局的位置和间距留白的大小。  \n\t这样做的好处是，**开发人员直接设置参数，设计人员按照切图的倍率输出切图** (@2x、@3x、@4x)。\n\t\n\t- 特别地，切图是以偶数倍放大的，便于缩放，设计元素的大小注意使用偶数单位即可。  \n\t\n\t例如，标注的基准信息是 `14.0 DP / @1x`，适配对应尺寸的参数即有：\n\t`XHDPI / @2x <=> 28px`，`XXHDPI / @3x <=> 42px`，`@4x <=> 56px`。\n\t\n- .9.PNG\n\t- 最外围的一圈像素，必须限定是 `1px` 大小，必须是纯黑色 `#000000`，任何参杂都不行。\n\t- 文件名后缀必须是 `*.9.PNG`。\n\n\t![.9.PNG使用演示图](/images/illustration/Reading/2018/03/Producting_An_Application_3-1.png)\n\t<center>图 3-1 .9.PNG使用演示图</center>\n\n- 压缩切图：在 Photoshop 中，输出方式为 `存储为 web 所用格式`；在 Sketch 中使用 `导出功能` 导出图片；其他工具可自行查阅资料，这里就不一一列举了。\n- 标注\n\t- 常用的标注软件：`Markman`、PxCook、Assistor PS。\n\t- 若公司、团队有规范的设计、开发手册，则请按照规范标准进行设计。\n\t- 拥有自己的一套标注文档 (迎合大众的，容易理解的)。\n\n\t对于一界面来说，图片、图标、框架、文字等元素，是必不可少的。若是为了更高程度的还原，那么详细的标注描述、文字说明、交互说明是必要的。在一般情况下，很多朋友为了便捷 (偷懒) 会在同一界面一次性把上述工作都堆积在一起完成，而这样带来的问题就是 `糟糕的阅读体验`。\n\t\n\t这里推崇一种做法 `分页描述法`。即：  \n\t1) 第一页，描述界面布局的信息，如间距大小、背景颜色；  \n\t2) 第二页，描述文字属性信息，如文字的字体、字号、颜色、布局；  \n\t3) 第三页，描述组件属性信息，如按钮、小图标等；\n\t4) 第四页，描述界面的交互信息，按照需求，你还可以细分为每个组件的交互信息；\n\t5) 以此类推...\n\t\n- 资源命名\n\t- `组件类型_模块_子功能_状态` 或者 `模块_组件类型_子功能_状态`；\n\n\t> 例如：btn\\_setting\\_logout\\_n.png / setting\\_btn\\_logout\\_n.png\n\t\n\t- 下划线相连命名，如 `ico_appicon_normal.png`\n- PSD 源文件\n\t- 以模块为单位，归类于不同文件夹中；\n\t- PSD 源文件中，有 `分组分层` 的习惯.\n\n## 肆 开发实现\n\n### 如何与产品、运营、开发配合\n\n#### 互联网产品的研发流程\n- 需求来了：产品经理，负责需求的策划和整理，输出产品需求文档 (Product Requirement Document，PRD)。那么产品经理的需求来自哪：\n\t- 版本规划：从无到有策划一款产品，这些功能不是一次性开发的，而是分布在若干版本中。\n\t- 动态演变的产品：根据市场的反馈，调整后续的增量版本。\n\t- 细节的优化：注重用户体验的优化。\n\t- 适应丰富的使用场景。\n- 需求要评审：方案需要和开发、设计、测试、运维人员一起评审。\n- 开始设计\n- 开始开发\n- 测试把关\n\n#### 与各种角色融洽相处\n可借助一些 `协作平台` 来规范研发流程，如需求的追加、任务分派、提交 BUG 等。相关人员通过日志、文档开展工作。\n\n`协作平台`：[Worktile](https://worktile.com/) 、 [Teambition](https://www.teambition.com/) 、[有道云协作](http://co.youdao.com/) 、 [ProcessOn (在线绘图)](https://processon.com/)  \n\n当然，软件过程中，一款合适的团队协作工具能使事情事半功倍。特别是敏捷方法，它是非常依赖工具的。至于哪款工具更适合于你们团队，建议参考知乎的文章再作判断：[Worktile 与 Teambition 的优劣对比？](https://www.zhihu.com/question/24920474)\n\n#### 发布应用程序\n- 灰度发布：在发布新版本时，仅针对少部分用户样本发布。灰度发布是一种常用的产品测试及质量管理工具。对于用户量大的产品，贸然发布一个新版本取代用户当前使用的版本，风险太大。因此互联网公司摸索出了一种工具，即灰度发布。\n\n#### 快速制作原型\n快速原型的工具有很多，推荐几款制作工具：[墨刀](https://modao.cc/) 、 [Axure PR](https://www.axure.com/download) 、 [Proto.io](https://proto.io/)\n\n## 伍 线上运营\n\n### 运营的概述\n\n#### 运营的定义\n在互联网中，针对不同群体推广产品，进行内容建议，并通过数据指标优化运营手段、产品功能与体验等行为。\n\n- 运营三要素：产品、用户和渠道，如图 5-1 所示。\n\n![运营三要素](/images/illustration/Reading/2018/03/Producting_An_Application_5-1.png)\n<center>图 5-1 运营三要素</center>\n\n- 运营的目标：运营是以目标为导向，数据为基础的工作。一切工作都围绕着运营三要素来进行，即产品、用户和渠道。运营的目标如图 5-2 所示。\n\n![运营的目标](/images/illustration/Reading/2018/03/Producting_An_Application_5-2.png)\n<center>图 5-2 运营的目标</center>\n\n- 产品、运营、设计工作的关系：为了达到运营目标，运营经理需要与产品经理、设计师等配合工作，如图 5-3 所示，简单地描述了产品经理、运营经理和设计师的工作关系。\n\n\t![产品、运营、设计工作关系图](/images/illustration/Reading/2018/03/Producting_An_Application_5-3.png)\n\t<center>图 5-3 产品、运营、设计工作关系图</center>\n\n#### 运营工作内容及岗位\n- 典型的产品生命周期：即每个阶段的运营重点都不同。图 5-4 展示了一款产品的生命周期。\n\n\t![产品的生命周期](/images/illustration/Reading/2018/03/Producting_An_Application_5-4.png)\n\t<center>图 5-4 产品的生命周期</center>\n\n- 运营目标：可量化的指标\n\t- 拉新：为 APP 带来下载或注册，或微信公众号拉粉。\n\t常用手段有：`搜索引擎优化`，`广告投放`，`渠道合作`、`社交媒体推广`。\n\t- 留存：想办法留住用户。运营的方式为：`优化产品内容机制`；`策划活动与用户互动`。\n\t- 促活：\n\t\t- 促用户更高频使用产品，增加用户黏性。可用 `等级设定`、`激励体系`、`积分制度` 等增加长期活跃性。\n\t\t- 已流失的用户，通过 `站内信`、`邮件`、`短信` 等手段召回。\n\t- 营收：增加付费用户和提高付费用户的活跃度。\n\n#### 运营工作方法论\n- 如何让运营手段更抓住人心，追根溯源就是研究人性，一款好的产品及运营，一定能迎合人性七宗罪中的其中之一。下述为 `利用人性` 的产品功能举例。\n\t- `色欲`：美女直播、陌陌、基于 LBS (基于位置的服务) 的陌生人社交。\n\t- `虚荣`：游戏装备。\n\t- `贪婪`：双十一折扣、抽奖、送红包。\n\t- `懒惰`：一键下单、二维码。\n\t- `窥探`：无秘、悄悄关注。\n\t- `傲慢`：吵架营销、粉丝大战。\n- 数据化运营：基于数据的运营决策更可靠。\n\t- 产品数据\n\t\t- 用户注册：包括下载量、注册用户激活数、APP 打开数、新增注册数等；\n\t\t- 用户留存：留存率、使用留存、购买留存等；\n\t\t- 用户活跃：活跃用户数、注册活跃转化率、APP 启动数、访问频率、浏览时长等；\n\t\t- 营收数据：付费用户数、付费转化率、付费金额、付费频次等；\n\t\t- 功能数据：每日评论数、交互反馈次数 (收藏、分享、喜欢等功能)。\n\t- 用户数据：用户画像 (性别、职业、学历、年龄、地域、使用设备、操作系统、消费行为)。\n\n### 活动运营\n\n#### 什么是活动运营\n- 传统行业短期的活动促销，带来一定人气增长、销售额增加。\n- 社交网络的病毒式传播，例如春晚微信摇红包、支付宝集五福等。\n\n#### 活动使用场景\n- 常规活动：有针对性提高某一指标，或新功能推广。其活动形式有：签到、邀请好友、新用户福利。\n- 节日：每个节日都有其自带的属性，利用节假日的情感共鸣。如表 5-1 所示。\n\n<center>表 5-1 常见节日举例</center>\n\n| 常见节日 | 举例 |\n| :----- | :--- |\n| 常规节日 | 春节、情人节、圣诞节、母亲节、劳动节 |\n| 人为创造 | 双十一、双十二、520告白日 |\n| 店庆活动 | 天猫店庆、周年庆 |\n| 季节变化 | 换季清仓、节气、春夏秋冬交替 |\n| 体育赛事 | 奥运会、欧冠、世界杯、NBA |\n| 颁奖典礼 | 奥斯卡、电影节 |\n\n每个节日都有其自带属性，例如春节会想到春运，双十一想到打折促销、中秋节想到团圆等。\n\n- 突发热点事件：极具话题性，短期爆发力强，能迅速传播。如表 5-2 列举了一些热点。\n\n<center>表 5-2 热点举例</center>\n\n| 热点 | 举例 |\n| :--- | :--- |\n| 民生类 | 与我有关的话题，生老病死的话题 |\n| 公益类 | 环保、支教、老人、儿童、宠物 |\n| 娱乐类 | 明星八卦、热门参与、笑话段子 |\n| 敏感话题 | 权利、金钱、色情 |\n| 技术趋势 | 人工智能、区块链、科技公司新品发布 |\n\n例如，肌萎缩侧索硬化症引发的冰桶挑战，达到的效果有：微博话题阅读超 7 亿，捐款总额达 137 万元。\n\n#### 如何策划线上活动\n策划线上活动共四阶段，即准备阶段、策划阶段、执行阶段和总结阶段。\n\n- `准备阶段`：活动前的准备\n\t- 活动需求：目的、人群、平台、机会点 (借势发挥，如世界杯)\n\t- 活动目的：量化为数据指标，核心目标为推广品牌、拉新用户、促进消费、提升用户活跃度。\n- `策划阶段`：活动方案策划\n\t- 明确活动的时间、内容、规范、文案、流程；\n\t- 确认奖品及协调推广资源；\n\t\n\t[注意] 策划方案时应：\n\t1) 流程简单，文案清晰；\n\t2) 吸引力，例如奖励等手段；\n\t3) 适时反馈，精神激励。例如动态显示参与人数、突出用户收益、获奖用户轮播。\n- `执行阶段`：活动上线后做好三点\n\t- 客服跟进：解决用户疑难，平息用户情绪。\n\t- 监控数据：随时调整，保证活动质量和预期。\n\t- 分布活动结果和活动善后 (`不要让用户感到被欺骗`)。\n- `总结阶段`\n\t- 用户参与情况和数据，用以判断是否达到目标。\n\t- 总结活动经验，提炼亮点和失误点，为下次活动做准备。\n\n#### 案例分析\n以 “新浪微博愚人节刮奖” 活动为例。\n\n- 活动类型：游戏\n- 活动目标：提升用户活跃度\n- 活动时间：愚人节，七天活动\n- 目标人群及切入需求：针对老用户 -> `逐利心理`\n- 平台：手机\n- 交互方式：模拟真实的刮奖操作\n- 规则判定\n\t- 每天每个用户可参与 5 次 刮刮卡活动，第一次免费。\n\t- 完成某些指定任务可获得更多抽奖活动。\n- 奖品设置\n\t- 根据预算控制奖品数量和中奖概率。\n\t- 头奖要吸引眼球，配合普通奖品，`增加用户获奖信心`。\n- 文案与视觉设计\n\t- 标题醒目，规则明确，页面简洁。\n\t- 结合活动主题渲染气氛。\n- 活动指标：参与人数，传播度 (分享数)，任务完成度，活动期间的活跃用户数。\n\n### H5 与 Banner 的设计\n\n#### H5 表现形式\nH5，即第五代 HTML，也泛指利用 HTML5 语言制作的页面。在开始设计前，先了解 H5 专题页的类型。\n\n- 按功能形式分：如图 5-5 所示。\n\n![按功能形式分的H5](/images/illustration/Reading/2018/03/Producting_An_Application_5-5.png)\n<center>图 5-5 按功能形式分的 H5</center>\n\t\n- 按目标分：如图 5-6 所示。\n\t\n![按目标分的H5](/images/illustration/Reading/2018/03/Producting_An_Application_5-6.png)\n<center>图 5-6 按目标分的 H5</center>\n\t\n- 在确定了专题页的功能与目标后，接下来的设计阶段尤为关键。即可从用户角度出发，思考用户的分享动机 (共六种情况)。\n\t- 利益相关：`有奖形式` 促进用户分享。\n\t- 有所收获：通过传播内容，学习自己感兴趣的知识，或 `自我提升`。\n\t- 身份认同：内容使某一类型人产生身份认同和归属感。\n\t- 成就吸引：朋友间竞技，满足用户 `炫耀心理需求`。\n\t- 情感共鸣：`情感共鸣`，从而产生集体回忆的分享冲动。\n\t- 借助热点：借助 `当前热点`，吸引用户眼球。\n\t\n- H5 页面表现形式\n\t- 展示型：支付宝十年账单、微信故事。\n\t- 互动型：智能招聘的职场神曲 DIY。\n\t- 产品型：微信公众号里的微商城，如京东。\n\n#### Banner \n投放于线上 (PC端、移动端) 的各种尺寸和形状的广告图。\n\n- 设计流程\n\t- 了解目的，定义信息优先级；\n\t- 确定文案，确定设计方向；\n\t- 视觉设计排版，讨论修改.\n- 搭配方式 => 输出 Banner\n\t- 内容专题：文案 + 主体物或文案 + 背景形式。`P238`\n\t- 电商：文案 + 主体物 + 背景形式。`P239`\n\t- 活动：文案 + 主体物 + 引导 Button + 背景 + 引导 Button 的形式。`P240 ~ 241`\n\n## 陆 服务设计\n\n### 概念\n\n#### 服务设计的定义\n一种新兴领域，主要关注通过 `有形、无形媒介的结合方式` 形成细致考量过的 `体验设计过程`。它已经在实践中为各种传统下行业都带来了更优良的用户体验。\n\n#### 相关术语\n\n> 本章节将围绕一个虚构的餐馆为例，姑且称他为 `美食与爱`。\n\n- 服务提供者：除一般含义的服务人员外，还包括电子显示屏、按钮开关等实体。\n\n\t> 在 `美食与爱` 中，就包括侍应、收银员、厨师、后台系统等。\n\n- 利益相关者：服务提供者所属的商业实体负责人。\n\n\t> 餐馆老板、门店经理、收银系统的服务商。\n\n- 服务设计团队：除设计师外，还包括利益相关者、一些顾客等。\n\n- 顾客：指服务提供者面向的用户、消费者等。\n\n- 触点：顾客与服务提供者之间每个有接触点的点。\n\n\t> 门口排位服务员、侍应、菜单、桌椅。\n\n- 服务周期：前期、中期和后期。\n\n\t以就餐为例：\n\t\n\t- `前期` 顾客感到饥饿时，有人推荐或搜 `美食与爱`，前往餐馆就餐。\n\t- `中期` 到门店后，需排位等待，收号入座，点菜，等就餐，就餐，结账。\n\t- `后期` 离开餐馆，呼叫的士回家 / 公司。 \n\n#### 五个原则\n- 用户至上：应通过客户的视角出发来设计整套服务。\n- 合作创新：设计师 (主持人)，利益相关者，服务提供人员，顾客。每种角色必须从自己视角出发提出想法。\n- 先后顺序：服务是一般以 `时间为序` 的 `动态` 的过程，而每一 `服务片段` 类似电影中的帧一样，把服务结构成一个个 `独立触点` 和 `交互行为`。\n- 有理有据：服务是无形的，需要用人工制品的形式“显示”出来，让其容易被感知。\n\n\t> 例如，酒店的清洁人员在客人不在时打扫卫生。\n\n- 全局视觉：涉及的角色、触点众多，具备全局视觉，以统筹好各个环节。\n\n### 设计流程\n以下介绍服务设计的基本流程，即 `探索` => `创造` => `反思` => `实施`。\n\n- `探索`\n\t- 了解公司对于设计思维的态度，是否接受服务设计这样需要合作创新的设计流程。\n\t- 找服务设计要解决的本质问题 (问题往往是公司自身的，或是从公司角度提出的)。\n\t- 找出问题本质所在。\n\n\t> 从 `潜在顾客` 和 `顾客` 的角度出发，理解他们当时的处境以及做出对应行为背后的真实动机。\n\n\t- 设计师要把研究后的发现和现有服务流程可视化方法展现出来。\n- `创造`：产生解决方案的阶段\n\t- 服务设计的最大特点：鼓励各种试错，而不是避免出错。\n\t- 阶段任务：\n\t\t- 基于探索阶段发现的核心问题；\n\t\t- 基于顾客需求；\n\t\t- 基于服务提供者本身诉求等约束条件；\n\t\t- 基于用户旅程图的一系列的触点.\n\n\t\t> 设计新的方案，并不断加以迭代验证、优化方案。\n- `反思`：创新阶段产生新方案后，这个阶段要进行测试验证。\n\t- 产品原型 (人机交互 Demo / 实体产品小样)，找顾客或者专家进行测试评估，然后不断改进以达到预期目标。\n\t- 服务原型：通过 `角色扮演` 等 `互动沉侵` 的方式，让顾客与服务之间产生 `真实的交互` 以及 `情感上的沟通`。\n- `实施`：工具 -- `服务蓝图`\n\n### 工具箱\n在 *This is service design thinking* \\\\(^{[1]}\\\\) 中，列举了 24 种服务设计的工具，下述选择了其中三款常用工具进行阐述，即 `影子跟随法`、`顾客旅程图`、`服务蓝图`，若对此模块有兴趣可查阅原书学习。\n\n#### 影子跟随法\n- 概念：研究人员或设计师把自己融入到顾客的，前后台人员的日常生活或工作中去，像 `影子` 一样跟着他们去观察他们一举一动。\n\n\t> 该方法可以真正做到从全局或者 `上帝视觉` 审视整个服务运作方式。\n\t\n#### 顾客旅程图\n- 概念：用 `顾客` 与 `服务` 之间产生互动的一个个 `触点` 来构成用户完整旅程的 `地图`。即这个图是从顾客的视角表达出所有与服务之间互动的行为以及由于互动而产生的情感。\n- 如何绘制顾客旅程图\n\t- 1) 需要找到顾客与服务之间所有互动的行为触点。\n\t- 2) 当所有行为触点找出后，按时序的方式进行罗列以形成完整的体验流程。\n\t- 3) 然后通过访谈或利用顾客自己的描述和记录，以顾客口吻表达出他们每个步骤的心理活动，对应某种情绪，打分以形成情绪曲线图。\n\t- 4) 分析旅程图中情绪分值较低部分 (尤其是 `谷底` 时)，找出问题所在，往往当中存在不错创新设计机会点。\n\n\t如图 6-1 所示，为餐馆就餐的典型顾客旅程图。\n\t\n![餐馆就餐的典型顾客旅程图](/images/illustration/Reading/2018/03/Producting_An_Application_6-1.png)\n<center>图 6-1 餐馆就餐的典型顾客旅程图</center>\n\n#### 服务蓝图\n> 服务蓝图，类似建筑设计的蓝图。\n\n- 从全局的视觉详细地设计服务体系里包含的所有对象、交互、触点等的图形化语言。\n- 该图包含多种角色：用户、服务提供者，涉及服务流程相关者，触点及后台流程。\n- 服务蓝图绘制方法： \n\t- 首先按时序把 `用户新的行为` (设计后的行为) 从左到右罗列出来。并从服务的前中后阶段 (如就餐前、就餐时、就餐后) 对其进行分类。\n\t- 在行为 `上一行`，列出用户行为所接触的物理触点或环境。\n\t- 在行为 `下一行`，列出用户交互的服务提供者。\n\t- 在行为 `下两行`，是后台服务提供者以及提供的支援流程。\n\n\t如图 6-2 所示，针对餐馆优化后的服务蓝图。\n\n![针对餐馆优化后的服务蓝图](/images/illustration/Reading/2018/03/Producting_An_Application_6-2.png)\n<center>图 6-2 针对餐馆优化后的服务蓝图</center>\n\n## 参考资料\n[[1] Schneider, Jakob. This is service design thinking [M]. Canada: BIS Publishers, 2011](https://book.douban.com/subject/5397784/)  \n[2] 赵晋. 波士顿矩阵分析在实际案例中的运用[J]. 中国高新技术企业,2008,(8).  \n[3] 张镜天. 波士顿矩阵在酒类营销中的运用[J]. 中国酒业. 2006,(1).  \n[4] 上海质量科学研究院. 顾客满意的测量、分析与改进[M]. 中国标准出版社,2009.10.  ","tags":["规范"],"categories":["Reading"]},{"title":"笔记 | 设计模式之 Android 实践与案例 ( 速记手册 )","url":"/2018/01/Design-Pattern-Based-on-Android.html","content":" \n## 序言\n\n在你接触过的安卓项目当中，如监听器、适配器、迭代器等并不陌生，然而它们无不体现着设计模式的精髓。设计与模式的结合，往往与设计能力与代码质量息息相关。同理，逆过来思考此类问题，对于一些优秀项目、源码的理解障碍往往是对其设计 (逻辑、性能、解耦等) 的理解，而非源码本身。而作为开发者，知其然知其所以然，这也正是我们深入学习设计模式的理由之一。\n\n当然，我们还要正视学习设计模式的心态。掌握了各种设计模式，并不代表你的设计能力与代码质量就会突飞猛进，同样在项目中运用设计模式也不是生搬硬套就解决问题了，在《 [Head First 设计模式](https://book.douban.com/subject/2243615/) 》一书中，则把设计模式的使用心智分为：初学者、中级人员和悟道者，虽有“玄学”的味道，但也恰当。即没有最好的模式，而是你综合众多因素，根据经验、方法来筛选合适的设计模式与你的项目结合，运用。\n\n最后，对于设计模式的学习，不要局限于《 [Android 源码设计模式](https://book.douban.com/subject/26644935/) 》本身，你可以搭配一些经典论文、综述，或者书籍，以至于怀疑一个问题的正误，多比对、多思考，以得到最精确的理解。而本笔记的作用也在于此，即一个设计模式的架构，或是借鉴学习，亦或是复习之需便于查询。\n\n<!-- More -->\n\n- 推荐书目：\n\t- 《 设计模式（可复用面向对象软件的基础）》：待补充\n- 推荐项目：\n\t- [Design Pattern Quick Reference.Jason Mcdonald](http://www.mcdonaldland.info/2007/11/28/40/)：[PDF Download](/pdf/Design_Pattern_Quick_Reference.pdf)\n\t- [Awesome design patterns.DovAmir.Github](https://github.com/DovAmir/awesome-design-patterns#languageframework-design-patterns-mainly-gof)\n- 更新进程\n\t- 2018.01.30 - 完成序言；\n\t- 2018.01.31 - 更新第壹章；\n\t- 2018.02.05 - 更新第贰章 ( 共 23 种设计模式 )；\n\t- 2018.03.19 - 更新完毕.\n\n## 总览\n\n- [零 本书架构](#零-本书架构)\n- [壹 面向对象编程六大原则](#壹-面向对象编程六大原则)\n- [贰 二十三种设计模式解析](#贰-二十三种设计模式解析)\n- [叁 MVC 与 MVP 模式](#叁-MVC-与-MVP-模式)\n\n\n## 零 本书架构\n\n### 面向对象六大原则\n\n- 单一职责原则\n> 优化代码第一步。即就一个类而言，应该有且仅有一个引起它变化的原因。\n\n- 开闭原则\n> 让程序更稳定，更灵活。即软件中的对象（类、模块、函数等）应该对于扩展是开放的，但对于修改是封闭的。\n\n- 里氏替换原则\n> 构建扩展性更好的系统。\n\n- 依赖倒置原则  \n> 让项目拥有变化能力，即依赖抽象，不依赖具体实现。\n\n- 接口隔离原则\n> 系统拥有更高灵活性。\n\n- 迪米特原则\n> 也称为「最少知识原则」。即一个对象应对其他对象有最少的了解。\n\n### 二十三种设计模式\n\n| 模式名称 | 一句话描述 |\n| :--- | :--- |\n| 单例模式 | 一个类只有一个实例 |\n| Build 模式 | 自由拓展你的项目 |\n| 原型模式 | 使程序运行更高效 |\n| 工厂方法模式 | 生成复杂对象 |\n| 抽象工厂模式 | - |\n| 策略模式 | 时势造英雄 |\n| 状态模式 | 随遇则安 |\n| 责任链模式 | 使编程更有灵活性 |\n| 解释器模式 | 化繁为简的翻译机 |\n| 命令模式 | 让程序畅通执行 |\n| 观察者模式 | 解决、解耦的钥匙 |\n| 备忘录模式 | 编程中的后悔药 |\n| 迭代器模式 | 解决问题的第三者 |\n| 模块方法模式 | 抓住问题的核心 |\n| 访问者模式 | 数据结构与操作分离 |\n| 中介者模式 | 调解者模式或调停者模式 |\n| 代理模式 | 委托模式 |\n| 组合模式 | 物以类聚 |\n| 适配器模式 | 得心应手粘合剂 |\n| 装饰模式 | 动态给对象添加额外职责 |\n| 享元模式 | 对象共享，避免创建多对象 |\n| 外观模式 | 统一编程接口 |\n| 桥接模式 | 连接两地的交通枢纽 |\n\n### MVC 与 MVP 模式\n\n\n## 壹 面向对象编程六大原则\n\n### 单一职责原则\n\n- Single Responsibility Principle，SRP.\n- 即就一个类而言，应该仅有一个引起它变化的原因。\n\n> 如何划分一个类，一个函数的职责？每个人的经验不同，观点看法也不同，故视具体任务而定。但它也有一些基本的知道原则：  \n> \n> * 两个完全不一样的功能就不应该放到同一个类中。\n> * 一个类中应该是一组相关性很高的函数、数据的封装。\n\n### 开闭原则\n\n- Open Close Principle，OCP.\n- 即软件中的对象（类、模块、函数等）应该对于扩展是开放的，但对于修改是封闭的。\n- 勃兰特·梅耶. 《面向对象软件构造》中提倡：\n\t- 新的或改变的特性应通过新建不同的类实现，新建的类可通过 `继承` 的方式来重用原类的代码。\n\t- 已存在的实现类对于修改是封闭的，但新的实现类可通过 `覆写父类的接口` 应对变化。\n\n> 开闭原则知道我们，当软件需变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。\n\n### 里氏替换原则\n\n> **往往开闭原则与里氏替换原则是生死相依、不离不弃的。**\n\n\n- Liskov Substitution Principle，LSP。\n- 所有引用基类的地方必须能透明地使用其子类的对象。\n\n```Java\npublic abstract class View {\n\tpublic abstract void draw();\n\tpublic void measure(int width, int height) {\n\t\t// 测量视图的大小\n\t}\n}\n\npublic class Button extends View {\n\tpublic draw() {\n\t\t// 绘制按钮\n\t}\t\n}\n\npublic class Windows {\n\tpublic show(View child) {\n\tchild.draw();\n\t}\n}\n```\n\n> 上述例子中，任何继承自 View 类的子类都可以设置给 show 方法，即里氏替换。这样千变万化的 View 传递给 Window，Window 只管组织 View，并显示在屏幕上。\n\n### 依赖倒置原则\n\n- Dependence Inversion Principle，DIP.\n- 一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节。\n- 依赖倒置原则的几个关键点：\t\n\t- 高层模块不应该依赖低层模块，两者都应以来其抽象（接口或抽象类）\n \n\t> 高层模块指调用端，低层模块指实现类。\n\t\n\t- 抽象不应该依赖细节\n\t- 细节应依赖抽象\n- 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系。一句话概括：`面向接口编程，面向抽编程`\n\n```Java\n/*\n * 设计一款实现图片缓冲功能的接口，具体的缓冲实现方式、细节，根据实际情况编写。\n */\n\npublic interface ImageChache {\t// ImageCache 缓存抽象\n\tpublic Bitmap get(String url);\n\tpublic void put(String url, Bitmap bmp);\n}\n\npublic class MemoryCache implements ImageCache {\n\t// 根据实际需求，再实现具体细节\n}\n\npublic class ImageLoader {\n\t// 图片缓存类，依赖抽象，不依赖细节\n\tImageCache mCache = new MemoryCache();\n\t\n\tpublic void displayImage(String url, ImageView imageView) {\n\t\tBitmap bmp = mCache.get(url);\n\t\tif(null == bmp){\n\t\t\tdownloadImageAsync(url, imageView);\n\t\t} else {\n\t\t\timageView.setImageBitmap(bmp);\n\t\t}\n\t}\n\t\n\tpublic void setImageCache(ImageCache cache) {\n\t\tmCache = cache;\n\t}\n}\n```\n\n### 接口隔离原则\n\n- Interface Segregation Principles，ISP.\n- 类间的依赖关系应建立在最小的接口上。ISP 将非常庞大、臃肿的接口拆分成更小的和更具体的接口。IPS的目的是系统解开耦合。\n\n> 如上例中，ImageLoader 中的 ImageCache，ImageLoader 只需要知道该缓存对象有存、取缓存图片的接口即可，其他一概不管。\n\n### 迪米特原则\n\n- 一个对象应对其他对象有最少的了解、即类的内部如何实现与调用者、依赖者没关系，调用者或依赖者之需知道它需要的方法即可，其他一概不管。\n\n- 图 1-1 展示了租客、中介与房间相互之间的需求关系。\n\n\t![租客、中介与房间关系](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_1-1.png )\n\t<center>图 1-1 租客、中介与房间关系</center>   \n\n\t因为租客只需要房子，即把需求转达中介，对房子具体的租金、维修、签约等交由中介处理，租客不需要再了解细节。改进效果见图 1-2。\n\n\t![租客、中介与房间关系](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_1-2.png )\n\t<center>图 1-2 改进：租客、中介与房间的关系</center>  \n\n## 贰 二十三种设计模式解析\n\n### 单例模式\n#### 单例模式的定义\n- 确保某 `一个类只有一个实例` ，而且自行实例化并向整个系统提供这个实例。\n\n\t> `一个类只有一个实例` ：避免产生多个对象消耗过多资源，如访问 I/O 和数据库等资源。\n\n\n#### 单例模式 UML 类图\n![单例模式示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-1.png )\n<center>图 2-1 单例模式示意图</center> \n\n- 实现单例模式主要有如下几个关键点：\n\t- `构造函数` 不对外开放，一般设为 `私有` ；\n\t- 通过一个 `静态方法` 或者 `枚举返回` 单例类对象；\n\t- 确保单例类的对象有且只有一个，尤其多线程环境下；\n\t- 确保单例类对象在 `反序列化` 时不会重新构建对象；\n\t\n\t> 序列化：将对象的状态信息转换为可以存储或传输的形式的过程。一般将一个对象存储至一个储存媒介，例如档案或是记亿体缓冲等。在网络传输过程中，可以是字节或是XML等格式。  \n\t> \n\t> 反序列化：而字节的或XML编码格式可以还原完全相等的对象。这个相反的过程又称为反序列化。\n \n#### 单例模式的简单示例\n例如一个公司只有一个 CEO，一个应用只有一个 Application 对象等。下面以公司里的 CEO 为例来简单演示，即一个公司可有几个 VP，无数个员工，但 CEO 只有一个。\n\n```Java\n// 员工的基类\npublic class Staff { \n\tpublic void work(){\n\t\t// 忽略执行细节\n\t}\n}\n\n// 副总裁类\npublic class VP extends Staff {\n\tpublic void work() {\n \t\t// 覆写执行细节\n\t}\n}\n\n// 饿汉单例模式：声明静态对象时已初始化\npublic class CEO extends Staff { // 公司保证只有一个 CEO\n\tprivate static final CEO mCeo = new CEO();\n\tprivate CEO(){}\n\tpublic static CEO getCeo() {\n\t\treturn mCeo;\n\t}\n\tpublic void work() {\n\t\t// 覆写执行细节\n\t}\n}\n\n/*\n * 实际中使用：\n * CEO 类不能通过 new 的形式构造对象，只能通过 CEO.getCeo() 函数获取。\n * CEO 对象是静态对象，并在声明时已初始化，保证 CEO 对象的唯一性。\n */\n \nStaff ceo1 = CEO.getCeo();\t\nStaff ceo2 = CEO.getCeo();\n```\n\n#### 单例模式的其他实现方式\n##### 懒汉模式\n- 声明一静态对象；\n- 调用 getInstance() 方法初始化 ( 用时才初始化，即惰性处理机制 )\n\n```Java\n// 懒汉单例模式：用时才初始化，即惰性处理机制\npublic class Singleton {\n\tprivate static Singleton instantce;\n\tprivate Singleton() {}\n\t\n\t// 添加 synchronized 关键字，即 getInstance() 是一个同步方法\n\tpublic static synchronized Singleton getInstance() {\n\t\tif( null == instance ) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n- 懒汉单例模式的优缺点：  \n\t- 优点 - 使用时才实例化，一定程度上节约资源。  \n\t- 缺点 - 每次调用 getInstance() 都进行同步，造成不必要同步开销。\n\n##### Double CheckLock (DCL)\n\n```Java\npublic class Singleton {\n\t// private static Singleton sInstance = null;\n\tprivate volatile static Singleton sInstance = null; // 保证 sInstance 对象每次都是从主内存存、读取。\n\t\n\tprivate Singleton() {}\n\t\n\tpublic void doSomething() {\n\t\tSystem.out.println(\"do sth.\");\n\t}\n\t\n\tpublic static Singleton getInstance() {\n\t\tif( null == sInstance ) { // 避免不必要同步\n\t\t\tsynchronized(Singleton.class) {\n\t\t\t\tif( null == sInstance ) { // 此处判空操作，是因为 Java 编译器允许处理器乱序执行，具体解析见注解\n\t\t\t\t\tsInstance = new Singleton();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sInstance;\n\t}\n}\n```\n\nDCL 又称「丑陋的优化」？  \n\nDCL 虽一定程度解决了资源消耗，多余同步、线程安全等问题，但某种情况下还是会出现失效问题 ( 双重检查锁定(DCL) )，即称「丑陋的优化」。\n\n- 线程A，执行 `sInstance = new Singleton();`，编译器会编译成多条汇编指令，具体汇编指令的分工为：  \n\t- Step.01 给 Singleton 实例分配内存；  \n\t- Step.02 调用 Singleton() 的构造函数；  \n\t- Step.03 将 sInstance 对象指向分配的内存空间；  \n\t\n- 然而 Java 编译器允许处理器乱序执行，即有「1-2-3」或「1-3-2」的执行顺序。\n- 若执行「1-3-2」的顺序，这样会使 DCL 的优化失效，即第三步执行完毕，sInstance 非空，线程B取走 sInstance。再使用时就会报错。\n\n##### 静态内部类单例模式\n\n```Java\npublic class Singleton {\n\tprivate Singleton() {}\n\tpublic static Singleton getInstance() {\n\t\treturn SingletonHolder.sInstance;\n\t}\n\tprivate static class SingletonHolder { // 静态内部类\n\t\tprivate static final Singleton sInstance = new Singleton();\n\t}\n}\n```\n\n第一次加载 Singleton 的 getInstance() 方法才会使 sInstance 被初始化。因此，第一次调用 getInstance() 方法会导致虚拟机加载 SingletonHolder 类.\n\n> 内部类是延时加载的，只会在第一次使用时加载，不使用不加载。这样，即保证了线程安全，又保证单例对象唯一性，同时也延迟单例的实例化。\n\n##### 枚举单例\n\n```Java\n// 默认枚举实例的创建是线程安全的，并且在任何情况下它都是一个单例。\npublic enum SingletonEnum {\n\tINSTANCE;\n\tpublic void doSomething() {\n\t\tSystem.out.println(\"do sth.\");\n\t}\n}\n```\n\n#### 总结\n- 不管以哪种形式实现单例模式，它们的核心原理都是将 `构造函数私有化` ，并通过 `静态方法获取一个唯一的实例` 。\n\n\t> 获取实例的过程须保证线程安全，防止反序列化导致重新生成实例对象等。\n\n- 选择哪种实现形式取决项目本身，如是否是复杂的并发环境、JDK 版本是否过低、单例对象的资源消耗等。\n- 单例模式的优缺点\n\t- 优点  \n\t1) 只生成一个实例，减少系统的性能开销；  \n\t2) 当一对象的产生需要较多资源时，如读取配置、产生其他依赖对象时，可通过应用启动时直接产生一个单例对象，永久驻留内存。  \n\t- 缺点  \n\t1) 单例模式一般没有接口，扩展性难；  \n\t2) 单例对象若持有 Context，那么很容易引发内存泄漏，此时需注意传递给单例对象的 Context 应该是 `Application.Context` 。\n \n### Bulider 模式\n#### Bulider 模式的定义\n- 创建型设计模式。\n- 将一个复杂对象的 `构建` 与它的 `表示` 分离，使得同样的构建过程可以创建不同的表示。\n- Builder 模式是一步步创建一个复杂对象的，它允许用户在不知内部构建细节的情况下，可以更精细地控制对象的构造流程。\n\n#### Builder 模式的使用场景\n- 产品类非常复杂，或产品类中调用顺序不同产生不同的作用，这时需要使用 Builder 模式。\n- 初始化一个对象特别复杂，如参数多，且很多参数都具有默认值。\n\n#### Builder 模式的UML类图\n![Builder模式示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-2.png )\n<center>图 2-2 Builder 模式示意图</center> \n\n#### Builder 模式的简单实现\n\n便于理解，本示例的 UML 类图见图 2-3。\n\n![计算机组装过程](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-3.png )\n<center>图 2-3 计算机组装过程</center> \n\n```Java\n/*\n * 下述程序以计算机组装过程简化为：构建主机，设置操作系统，设置显示器。\n */\n \n// 计算机抽象类，即 Product 角色\npublic abstract class Computer {\n\tprotected String mBoard;\n \tprotected String mDisplay;\n \tprotected String mOS;\n \tprotected Computer() {}\n \tpublic void setBoard(String board) { // 设置 CPU 核心数\n \t\tmBoard = board;\n \t}\n \tpublic void setDisplay(String display) { // 设置内存\n \t\tmDisplay = display;\n \t}\n \tpublic abstract void setOS();\n \t@override\n \tpublic String toString() {\n \t\treturn \"Computer[...]\";\n \t}\n }\n \n// 具体的 Computer 类 - MacBook\npublic class Macbook extends Computer {\n \tprotected Macbook() {}\n \t@override\n \tpublic void setOS() {\n \t\tmOS = \"MAC OSX 10.10\";\n\t}\n}\n \n// 抽象 Builder 类\npublic abstract class Builder {\n \tpublic abstract class Builder {\n \t\tpublic abstract void buildBoard(String board); // 设置主机\n \t\tpublic abstract void buildOS(); // 设置操作系统\n \t\tpublic abstract void buildDisplay(String display); // 设置显示器\n \t\tpublic abstract Computer create(); // 创建 Computer\n\t}\n}\n \n// 具体的 Builder 类 - MacbookBuilder\npublic class MacbookBuilder extends Builder {\n \tprivate Computer mComputer = new Macbook();\n \tpublic void buildBoard(String board){\n \t\tmComputer.setBoard(board);\n \t}\n \tpublic void buildDisplay(String display) {\n \t\tmComputer.setDisplay(display);\n \t}\n \tpublic void buildOS() {\n \t\tmComputer.setOS();\n \t}\n \tpublic Computer create() {\n \t\treturn mComputer;\n \t}\n}\n \n// Director 类，负责构造 Computer\npublic class Director {\n \tBuilder mBuilder = null;\n \tpublic Director(Builder builder) {\n \t\tmBuilder = builder;\n \t}\n \tpublic void construct(String board, String display) {\n \t\tmBuilder.buildBoard(board);\n \t\tmBuilder.buildDisplay(display);\n\t\tmBuilder.buildOS();\n \t}\n}\n\n// 客户端实现\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tBuilder builder = new MacbookBuilder(); // 构造器\n \t\tDirector pcDirector = new Director(builder); // Director\n \t\t// 封装构建过程\n \t\tpcDirector.construct(\"英特尔主板\", \"Retina 显示器\");\n \t\tSystem.out.println(\"Computer Info: \" + builder.create().toString());\n \t}\n}\n```\n\n#### Builder 模式实战\n```Java\n/*\n * 知名图片加载库：Universal-Image-Loader\n */\n\nImageLoaderConfiguration config = new ImageLoaderConfiguration\n.Builder(context) // 用户只能通过 Builder 对象构建 ImageLoaderConfiguration 对象，这就是构建和表示相分离\n.threadPriority(Thread_NORM_PRIORITY_2)\n.denyCacheImageMultipleSizesInMemory()\n.discCacheFileNameGenerator( new MD5FileNameGenerator() )\n.tasksProcessingOrder(QueueProcessingType.LIFO)\n.bulider();\n\nImageLoader.getInstance().init(config);\n```\n\n#### 总结\n- Builder 模式，通过作为配置类的构建器将配置的构建和表示分离开来，同时也将配置从目标类中隔离出来，避免过多的 Setter 方法暴露在目标类当中。\n- Builder 模式的优缺点\n\t- 优点  \n\t1) 良好的封装性，不必知道产品内部组成的细节；  \n\t2) 建造者独立，易于扩展。\n\t- 缺点  \n\t1) 产生多余 Builder 对象及 Director 对象，消耗内存。\n\n### 原型模式\n#### 原型模式的定义\n- 创建型的模式。\n- 定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。\n\t- 原型拥有样板实例，可克隆内部属性一致的对象。\n\t- 原型模式多用于创建复杂的或构建耗时的实例，即复制一个已经存在的实例可使程序运行更高效。\n\n#### 原型模式的使用场景\n- 类初始化需消耗非常多的资源 ( 数据、硬件资源等 )。\n- 通过 new 产生一个对象需要非常繁琐的数据准备或访问权限。\n- 一个对象需提供其他对象访问，且各调用者可能都需修改其值时，可考虑用原型模式或拷贝多个对象以供调用者使用，即 `保护性拷贝` 。\n\n#### 原型模式的 UML 类图\n![Builder模式示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-4.png )\n<center>图 2-4 原型模式的 UML 类图</center> \n\n#### 原型模式的简单实现\n便于理解，本示例的 UML 类图见图 2-5。\n\n![WordDocument文档编辑器](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-5.png )\n<center>图 2-5 WordDocument 文档编辑器</center> \n\n```Java\n/*\n * WordDocument 具有文字、图片编辑功能的简单文档处理类。且为保护源文件，其可在克隆对象上作内容修改。\n */\n\npublic class WordDocument implements Cloneable {\n\t// WordDocument 扮演 ConcretePrototype 角色\n\t// Cloneable 扮演 Prototype 角色\n\tprivate String mText; // 文本\n\tprivate ArrayList<String> mImages = new ArrayList<String>(); // 图片名列表\n\tpublic WordDocument() {\n\t\t// 忽略实现细节\n\t}\n\t@Override\n\tprotected WordDocument clone() {\n\t\ttry {\n\t\t\tWordDocument doc = (WordDocument) super.clone();\n\t\t\tdoc.mText = this.mText;\n\t\t\tdoc.mImages = this.mImages;\n\t\t\treturn doc;\n\t\t} catch(Exception e) {\n\t\t}\n\t\treturn null;\n\t}\n\tpublic String getText() {\n\t\treturn mText;\n\t}\n\tpublic void setText(String mText) {\n\t\tthis.mText = mText;\n\t}\n\tpublic List<String> getImage() {\n\t\treturn mImages;\n\t}\n\tpublic void addImage(String img) {\n\t\tthis.mImages.add(img);\n\t}\n\tpublic void showDocument() {\n\t\tSystem.out.println(\"Text:\" + mText);\n\t\tSystem.out.println(\"Images List:\");\n\t\tfor(String imgName:mImages) {\n\t\t\tSystem.out.println(\"image name:\" + imgName);\n\t\t}\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tWordDocument originDoc = new WordDocument();\n\t\t\n\t\t/* Partion A start */\n\t\toriginDoc.setText(\"This is a Aircle\");\n\t\toriginDoc.addImage(\"Image A\");\n\t\t/* Partion A end */\n\t\toriginDoc.showDocument();\n\t\t\n\t\tWordDocument secDoc = originDoc.clone();\n\t\tsecDoc.showDocument();\n\t\tsecDoc.setText(\"This is a Paper\"); // 只是改变了引用指向\n\t\tsecDoc.showDocument();\n\t\toriginDoc.showDocument(); // 还是输出 Partion A 的结果\n\t}\n}\n```\n\n> 注：通过 clone() 拷贝对象时并不会执行构造函数。如果在构造函数中需要一些特殊的初始化操作类型，在使用 Cloneable 实现拷贝时，注意构造函数不会执行的问题。\n\n#### 浅拷贝和深拷贝\n- 浅拷贝：上述例子实际上只是一个浅拷贝，也称 `影子拷贝`，即只是副本文档引用原始文档的字段。\n\n ![浅拷贝示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-6.png )\n <center>图 2-6 浅拷贝示意图</center> \n\n ```Java\n secDoc.setText(\"This is a Paper.\");\n secDoc.addImage(\"Image B\");\n secDoc.showDocument(); // Case 1\n originDoc.showDocument(); // Case 2\n\n // Case 1，2 都增加了图片 “Image B”，原因是 secDoc 只是单纯指向了 this.mImages\n ```\n\n- 深拷贝：为了解决浅拷贝所带来的“问题” ( 视具体问题而定 )，引入深入拷贝。\n\n ```Java\n @Override\n protected WordDocument clone() {\n \ttry {\n \t\tWordDocument doc = (WordDocument) super.clone();\n \t\tdoc.mText = this.mText;\n \t\t// doc.mImages 指向 mImages 的一份拷贝，而不是 this.mImages 本身\n \t\tdoc.mImages = (ArrayList<String>) this.mImages.clone();\t\t\n \t\treturn doc;\n \t} catch(Exception e) {\n \t}\n \treturn null;\n }\n ```\n\n#### 原型模式实战\n```Java\n/*\n * 在线用户信息修改 (需登录后修改用户信息)\n */\n\n// 用户实体类\npublic class User {\n\tpublic int age;\n\tpublic String name;\n\tpublic String phoneNum;\n\tpublic Adress,adress;\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"User[age=...]\";\n\t}\n}\n\n// 登录接口\npublic interface Login (\n\tvoid login();\n)\n\npublic class LoginImpl implements Login {\n\t@Override\n\tpublic void login() {\n\t\tUser loginedUser = new User(); // 登录服务器，获取用户信息\n\t\tloginedUser.age = 12;\n\t\tloginedUser.name = \"Mr.Sample\";\n\t\tloginedUser.address = new Address(\"BeiJing\", \"HaiDing\", \"Garden Rd\");\n\t\t\n\t\t// 登录完成后，将用户信息设置到 Session:\n\t\tLoginSession.getLoginSession()\n\t\t\t.setLoginedUser(loginedUser)\n\n\t}\n}\n\n// 登录 Session\npublic class LoginSession {\n\tstatic LoginSession sLoginSession = null;\n\tprivate User longinedUser; // 已登录用户\n\tprivate LoginSession() {}\n\tpublic static LoginSession getLoginSession() {\n\t\tif(null == sLoginSession) {\n\t \t\tsLoginSession = new LoginSession();\n\t \t}\n\t \treturn sLoginSession;\n\t}\n\t\n\t// 包级私有：即不加任何修饰符，该模式(默认访问模式)下，只允许在同一包中进行访问\n\tvoid setLoginedUser(User user) { // 设置已登录用户信息，不对外开放\n\t\tloginedUser = user;\n\t}\n\t\n\tpublic User getLoginedUser() {\n\t\treturn loginedUser;\n\t}\n}\n\n/* Partion A : 以下是实际执行部分，可能在不同包的某个类下执行 */\n\n// 获取已登录的 User 对象\nUser newUser = LoginSession.getLoginSession().getLoginedUser();\n// 更新用户信息\nnewUser.address = new Adress(\"BeiJing\", \"ChaoYang\", \"DaWang Rd\");\n```\n\n用户信息的更新，限定于与 LoginSession 类在同一包下才能执行，即 Partion A 的操作，使这样的限定失效。我们可作以下改进：\n\n- 在 User 类中实现 Cloneable 接口。\n- 在 LoginSession 中将 getLoginedUser() 改为 `return loginedUser.clone()` ，即在任何地方调用，获得的都是用户拷贝的对象，修改只是作用于拷贝的对象。\n\n\n```Java\n// 实现 Cloneable 接口\npublic class User implements Cloneable { // 用户实体类\n\tpublic int age;\n\tpublic String name;\n\tpublic String phoneNum;\n\tpublic Adress,adress;\n\t\n\t@Override\n\tpublic User clone() {\n\t\tUser user = null;\n\t\ttry {\n\t\t\tuser = (User) super.clone();\n\t\t} catch(CLoneNotSupportedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn user;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"User[age=...]\";\n\t}\n}\n\npublic class LoginSession { \n\t// 即管在任何地方调用，获得的都是用户拷贝的对象\n\tpublic User getLoginedUser() {\n\t\treturn loginedUser.clone();\n\t}\n}\n```\n#### 总结\n- 原型模式的优缺点\n\t- 优点 - 原型模式是在内存中二进制的拷贝，比 new 一个对象性能更优。\n\t- 缺点 - 内存中拷贝，构造函数是不会执行的。\n\n### 工厂方法模式\n#### 工厂方法模式的定义\n- 创建型设计模式。\n- 定义一个用于创建对象的接口，让子类决定实例化哪个类。\n\n#### 工厂方法模式的使用场景\n- 复杂对象的创建，而用 New 就可以完成创建的对象则不必使用工厂方法了。\n\n#### 工厂方法模式的 UML 类图\n工厂方法模式的 UML 如图 2-7 所示。\n\n![浅拷贝示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-7.png )\n<center>图 2-7 工厂方法模式 UML 类图</center> \n \n```Java\npublic abstract class Product {\n\tpublic abstract void method();\n}\npublic class ConcreteProductA extends Product { // 具体产品 A\n\t@Override\n\tpublic void method() {\n\t\tSystem.out.println(\"我是具体的产品A.\");\n\t}\n}\npublic class ConcreteProductB extends Product { // 具体产品 B\n\t@Override\n\tpublic void method() {\n\t\tSystem.out.println(\"我是具体的产品B.\");\n\t}\n}\n\npublic abstract class Factory { // 抽象工厂类\n\t/*\n\t * @return 具体的产品对象\n\t */\n\t public abstract Product createProduct();\n}\npublic class ConcreteFactory extends Factory {\n\t@Override\n\tpublic Product createProduct() {\n\t\t// 返回具体产品 A 或者具体产品 B\n\t\t// return new ConcreteProductA();\n\t\t// return new ConcreteProductB();\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tFactory factory = new ConcreteFactory();\n\t\tProduct p = factory.createProduct();\n\t\tp.method();\n\t}\n}\n```\n\n另外，我们可以利用反射的方式实现多工厂方法模式，具体见下述代码。\n\n```Java\npublic abstract class Factory {\n\n\t/*\n \t* 具体生产什么由子类去实现\n \t* @param clz 产品对象类类型\n \t* @return 具体的产品对象\n \t*/ \t\n \tpublic abstract<T extends Product> T createProduct(class<T> clz);\n}\n\npublic class ConcreteFactory extends Factory {\n\t@Override\n\tpublic <T extends Product> T createProduct(class<T> clz) {\n\t\tProduct p = null;\n\t\ttry {\n\t\t\tp = (Product) class.forName(clz.getName()).newInstance();\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn (T) p;\n\t}\n}\n\n// 客户端中实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tFactory factory = new ConcreteFactory();\n\t\tProduct p = factory.createProduct(ConcreteProductA.class);\n\t\tp.method();\n\t}\n}\n```\n\n#### 工厂方法模式的简单实现\n某汽车厂主要就是组装某款 SUV 车型，比如 Q3、Q5、Q7，对于这类车型来说，内部结构差异并不是很大，因此一条生产线足以应付 3 种车型，对于该类生产线可提供一抽象类定义。\n\n便于理解，本示例的 UML 类图见图 2-8。\n\n![某工厂生产某车型的工厂方法](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-8.png )\n<center>图 2-8 某工厂生产某车型的工厂方法</center> \n \n```Java\npublic abstract class AudiFactory {\n\n\t/*\n\t * 某工厂生产某种车型的工厂方法\n\t * @param clz 具体的 SUV 型号类型\n\t * @return 具体型号的 SUV 车对象\n \t */\n\tpublic abstract<T extends AudiCar> T createAudiCar(class<T> clz);\n}\n\npublic class AudiCarFactory extends AudiFactory {\n\t@Override\n\tpublic <T extends AudiCar> T createProduct(class<T> clz) {\n\t\tProduct p = null;\n\t\ttry {\n\t\t\tp = (AudiCar) class.forName(clz.getName())\n\t\t\t\t.newInstance(); \n\t\t} catch() {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn (T) p;\n\t}\n}\n\n// 汽车的抽象产品类\npublic abstract class AudiCar {\n\tpublic abstract void drive();\n\tpublic abstract void selfNavigation();\n}\n\n// 具体车型：Q3\npublic class AudiQ3 exntends AudiCar {\n\t@Override\n\tpublic void drive() {\n\t\tSystem.out.println(\"Q3 Launched!\");\n\t}\n\t@Override\n\tpublic void selfNavigation() {\n\t\tSystem.out.println(\"Q3 starts a auto-navigation!\");\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tAudiFactory factory = new AudiFactory();\n\t\tAudiQ3 audiQ3 = factory.createProduct(AudiQ3.class);\n\t\taudiQ3.dirve();\n\t\taudiQ3.selfNavigation();\t\n\t}\n}\n```\n#### 工厂方法模式的实战\nAndroid 数据持久化有很多方式，如 SharedPreferences (XML)、SQLite (关系数据库)。对数据操作的方法无非就是增、删、改、查，若我们将每种数据储存的方式作为一个产品类，在抽象产品类中定义对数据操作的方法，即我们宏观层面把握操作的逻辑，具体的实现逻辑由储存数据的方式决定。\n\n```Java\npublic abstract class IOHandler {\n\tpublic abstract void add(String id, String name);\n\tpublic abstract void remove(String id);\n\tpublic abstract void update(String id, String name);\n\tpublic abstract String query(String id);\n}\n\npublic class FileHandler extends IOHandler { // 普通文件存储\n\t@Override\n\tpublic void add(String id, String name) {\n\t\t/* 业务逻辑 */ }\n\t@Override\n\tpublic void remove(String id) {\n\t\t/* 业务逻辑 */ }\n\t@Override\n\tpublic void update(String id, String name) {\n\t\t/* 业务逻辑 */ }\n\t@Override\n\tpublic String query(String id) {\n\t\t/* 业务逻辑 */ \n\t\treturn \"AigeStudio\";\n\t}\n}\n\npublic class XMLHandler extends IOHandler { // XML 文存储\n\tpublic void add(String id, String name) {\n\t\t/* 业务逻辑 */ }\n\tpublic void remove(String id) {\n\t\t/* 业务逻辑 */ }\n\tpublic void update(String id, String name) {\n\t\t/* 业务逻辑 */ }\n\tpublic String query(String id) {\n\t\t/* 业务逻辑 */\n\t\treturn \"SMBrother\";\n\t}\n}\n\npublic class DBHandler extends IOHandler { // SQLite 数据库存储\n\tpublic void add(String id, String name) {\n\t\t/* 业务逻辑 */ }\n\tpublic void remove(String id) {\n\t\t/* 业务逻辑 */ }\n\tpublic void update(String id, String name) {\n\t\t/* 业务逻辑 */ }\n\tpublic String query(String id) {\n\t\t/* 业务逻辑 */\n\t\treturn \"Android\";\n\t}\n}\n\npublic class IOFactory {\n\t\n\t/*\n\t * 获取 IO 处理者\n\t * @param clz IOHandler 类型的类类型\n\t * @return IOHandler 对象\n\t */\n\t \n\tpublic static <T extends IOHandler> T getIOHandler(class<T> clz) {\n\t\tIOHandler handler = null;\n\t \ttry {\n\t \t\thandler = (IOHandler) class.forName(clz.getName())\n\t \t\t\t.newInstance();\n\t \t} catch(Exception e) {\n\t \t\te.printStackTrace();\n\t \t}\n\t\treturn (T) handler;\n\t}\n}\n\n// 客户端实现\npublic class FactoryActivity extends Activity {\n\t@override\n\tprotected void onCreate(Bundle saveInstanceState) {\n\t\tsuper.onCreate(saveInstanceState);\n\t\tsetContentView(R.layout.activity_factory);\n\t\t\n\t\t// 获取显示查询内容的 TextView 对象\n\t\tfinal TextView tvContent = (TextView) this.findViewById(R.id.factory_content_tv);\n\t\t// 获取查询普通文件数据的按钮对象，并设置监听\n\t\tButton btnFile = (Button) this.findViewById(R.id.factory_file_btn);\n\t\tbtnFile.setOnClickListener(new View.OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tIOHandler handler = IOFactory.getIOHanHandler(FileHandler.class);\n\t\t\t\tLog.d(\"AigeStudio\", handler.query(\"4455645646\"));\n\t\t\t\ttvContent.setText(handler.query(\"4455645646\"));\n\t\t\t}\n\t\t});\n\t}\n}\n```\n\n### 抽象工厂模式\n#### 抽象工厂模式的定义\n- 创建型设计模式。\n- 为创建一组相关或者是相互依赖的对象 提供一个 `接口` ，而不需要指定它们的具体类。\n\n#### 抽象工厂模式的使用场景\n一个对象族有相同约束时可以使用抽象工厂模式。如：  \nAndroid、iOS、Window Phone 下都有短信软件和拨号软件，两者属于软件范畴，但由于操作系统平台不一样，其代码实现细节也是有差异的，则我们可考虑使用抽象工厂方法模式去产生不同平台下的同款软件。\n\n#### 抽象工厂模式的 UML 类图\n抽象工厂方法模式的 UML 如图 2-9 所示。\n\n![抽象工厂方法模式UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-9.png )\n<center>图 2-9 抽象工厂方法模式 UML 类图</center> \n\n```Java\npublic abstract class AbstractProductA { // 抽象产品类 A\n    public abstractvoid method();\n}\n \npublic abstract class AbstractProductB { // 抽象产品类 B\n    public abstractvoid method();\n}\n \npublic class ConcreteProducxtA1 extends AbstractProductA { // 具体产品类 A1\n    @Override\n    public void method() {\n        System.out.println(\"具体产品 A1 的方法.\");\n    }\n}\n \npublic class ConcreteProducxtA2 extends AbstractProductA { // 具体产品类 A2\n    @Override\n    public void method() {\n        System.out.println(\"具体产品 A2 的方法.\");\n    }\n}\n \npublic class ConcreteProducxtB1 extends AbstractProductB { // 具体产品类 B1\n    @Override\n    public void method() {\n \t    System.out.println(\"具体产品 B1 的方法.\");\n    }\n}\n \npublic class ConcreteProducxtB2 extends AbstractProductB { // 具体产品类 B2\n    @Override\n    public void method() {\n        System.out.println(\"具体产品 B2 的方法.\");\n    }\n }\n \npublic abstract class AbstractFactory { // 抽象工厂类\n \n    /**\n     * 创建产品 A 的方法\n     * @return 产品 A 的对象\n     */\n    public abstract AbstractProductA createProductA();\n \t \n    /**\n     * 创建产品 B 的方法\n     * @return 产品 B的对象\n     */\n    public abstract AbstractProductB createProductB();\n}\n \npublic class ConcreteFactory1 extends AbstractFactory { // 具体工厂类1\n    @Override\n    public abstract AbstractProductA createProductA1() {\n        return new ConcreteProductA1();\n    };\n    @Override\n    public abstract AbstractProductB createProductB1() {\n        return new ConcreteProductB1();\n    };\n}\n \npublic class ConcreteFactory2 extends AbstractFactory { // 具体工厂类2\n    @Override\n    public abstract AbstractProductA createProductA2() {\n        return new ConcreteProductA2();\n    };\n    @Override\n    public abstract AbstractProductB createProductB2() {\n        return new ConcreteProductB2();\n    };\n}\n```\n\n#### 抽象工厂模式的简单实现\n在简单工厂模式的简单实现中，我门以车厂生产汽车为例。虽 Q3、Q5、Q7 同为一车系，但三者之间的零部件产别却很大，如 Q3、Q7 当中，Q3 装配的是国产发动机，普通轮胎和普通制动系统；Q7 则装配的是进口发动机，全尺寸越野轮胎和制动性能极好的制动系统。\n\n即同为一系列车，大家共有部件有发动机、轮胎和制动系统等，由于具体的部件品质不同，装配的细节又不同。故我们可将抽象工厂模式应用当中，化繁为简。具体的架构如图 2-10 的 UML 类图所示。\n\n![车厂生产同系列汽车的抽象工厂模式](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-10.png )\n<center>图 2-10 车厂生产同系列汽车的抽象工厂模式</center>\n \n```Java\npublic abstract class CarFactory {\n\t/**\n\t * 生产轮胎\n\t * @return ITire 轮胎\n\t */\n \tpublic abstract ITire createTire();\n \t\n\t/**\n\t * 生产发动机\n\t * @return IEngine 发动机\n\t */\n \tpublic abstract IEngine createEngine();\n \t\n\t/**\n\t * 生产制动系统\n\t * @return IBrake 制动系统\n\t */\n\tpublic abstract IBrake createBrake();\n}\n \npublic interface ITire { // 轮胎\n\tvoid tire();\n}\n \npublic class NormalTire implements ITire {\n\t@Override\n\tpublic void tire() {\n\t\tSystem.out.println(\"普通轮胎\");\n\t}\n}\n \npublic class SUVTire implements ITire {\n\t@Override\n\tpublic void tire() {\n\t\tSystem.out.println(\"越野轮胎\");\n\t}\n}\n \npublic interface IEngine() { // 发动机\n\tvoid engine();\n}\n \npublic class DomesticEngine implements IEngine {\n\t@Override\n\tpublic void engine() {\n\t\tSystem.out.println(\"国产发动机\");\n\t}\n}\n \npublic class ImportEngine implements IEngine {\n\t@Override\n\tpublic void engine() {\n\t\tSystem.out.println(\"进口发动机\");\n\t}\n}\n \npublic interface IBrake { // 制动系统\n\tvoid brake();\n}\n \npublic class NormalBrake implements IBrake {\n\t@Override\n\tpublic void brake() {\n\t\tSystem.out.println(\"普通制动\");\n\t}\n}\n  \npublic class SeniorBrake implements IBrake {\n\t@Override\n\tpublic void brake() {\n\t\tSystem.out.println(\"高级制动\");\n\t}\n}\n\npublic class Q3Factory extends CarFactory { // Q3工厂类\n\t@Override\n\tpublic ITire createTire() {\n\t\treturn new NormalTire();\n\t}\n\t@Override\n\tpublic IEngine createEngine() {\n\t\treturn new Domestic Engine();\n\t}\n\t@Override\n\tpublic IBrake createBrake() {\n\t\treturn new NormalBrake();\n\t}\n}\n \npublic class Q3Factory extends CarFactory { // Q3工厂类\n\t@Override\n\tpublic ITire createTire() {\n\t\treturn new NormalTire();\n\t}\n\t@Override\n\tpublic IEngine createEngine() {\n\t\treturn new DomesticEngine();\n\t}\n\t@Override\n\tpublic IBrake createBrake() {\n\t\treturn new NormalBrake();\n\t}\n}\n \npublic class Q7Factory extends CarFactory { // Q7 工厂类\n\t@Override\n\tpublic ITire createTire() {\n\t\treturn new SUVTire();\n\t}\n\t@Override\n\tpublic IEngine createEngine() {\n\t\treturn new ImportEngine();\n\t}\n\t@verride\n\tpublic IBrake createBrake() {\n\t\treturn new SeniorBrake();\n\t}\n}\n \n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t// 构造一个生产 Q3 的工厂\n\t\tCarFactory factoryQ3 = new Q3Factory();\n\t\tfactoryQ3.createTire().tire();\n\t\tfactoryQ3.createEngine().engine();\n\t\tfactoryQ3.createBrake().brake();\n \t\t\n\t\t// 构造一个生产 Q7 的工厂\n\t\tCarFactory factoryQ7 = new Q7Factory();\n\t\tfactoryQ7.createTire().tire();\n\t\tfactoryQ7.createEngine().engine();\n\t\tfactoryQ7.createBrake().brake();\n\t}\n}\n```\n\n#### 总结\n- 抽象工厂方法模式的优缺点\n\t- 优点 - 分离接口与实现，即客户端使用抽象工厂的创建对象，客户端不知具体实现是谁，客户端只是面向产品的接口编程而已，使其从具体的产品实现中解耦。\n\t- 缺点  \n\t1) 类文件的爆炸性增加。  \n\t2) 不太容易扩展新的产品类，因为每当增加一个产品类，就需修改抽象工厂，故所有具体工厂类均会被修改。\n\n### 策略模式\n#### 策略模式的介绍\n实现某功能，可以有多种算法或策略选择，例如排序算法，有插入排序、归并排序、冒泡排序等。\n\n> 思考：多种排序算法，可以写在一个类中，一个方法对应一种具体排序。但是缺点也是很明显，即臃肿；维护成本高，且容易引发错误；每增加一种排序需修改封装类的源码。  \n> \n> 改进：提供一个统一接口，不同的算法或策略有不同的实现类。\n\n\n#### 策略模式的使用场景\n- 针对同类问题的多种处理方式，仅仅是 `具体行为` 有差别。\n- 需要安全地封装多种 `同类型` 的操作。\n- 出现同一抽象类，有多个子类，而又需使用 `if-else` 或 `switch-case`  来选择具体子类。\n\n\t> 但缺点也明显，耦合性高；代码臃肿难维护。\n\n#### 策略模式的 UML 类图\n策略模式的 UML 如图 2-11 所示。\n\n![策略模式UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-11.png )\n<center>图 2-11 策略模式 UML 类图</center> \n\n#### 策略模式的简单实现\n下面以在北京乘坐公共交通工具的费用计算来演示一简单示例。在 2014 年 12 月 20 号之后，北京提高公交价格，不在是单一票价制，而是分段计费。显然，公交车和地铁的价格计算方式是不一样的。但是，我们的示例中是需要计算乘不同出行工具的成本，故我们采用策略模式进行设计、编码。\n\n便于理解，本示例的 UML 类图如图 2-12 所示。\n\n![交通方案UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-12.png )\n<center>图 2-12 交通方案的 UML 类图</center> \n\n```Java\npublic interface CalculateStragety {\n\t/**\n\t * 按距离来计算价格\n\t * @param km 公里\n\t * @return 返回价格\n\t */\n\tint calculatePrice();\n}\n\npublic class BusStragety implements CalculateStragety {\n\t@Override\n\tpublic int calculatePrice(int km) {\n\t\t// 公交车价格计算策略\n\t}\n}\n\npublic class SubwayStragety implements CalculateStragety {\n\t@Override\n\tpublic int calculatePrice(int km) {\n\t\t// 地铁价格计算策略\n\t}\n}\n\n// 客户端实现: 出行价格计算器\npublic class TranficCalculator {\n\tCalculateStrategy mStrategy = null;\n\t\n\tpublic static void main(String[] args) {\n\t\tTranficCalculator calculator = new TranficCalculator();\n\t\t// 设置计算策略\n\t\tcalculator.setStrategy( new BusStrategy() );\n\t\t// 计算价格\n\t\tSystem.out.println(\"公交车乘16公里的价格: \" + calculator.calculatePrice(16));\n\t}\n\t\n\tpublic void setStrategy(CalculateStrategy mStrategy) {\n\t\tthis.mStrategy = mStrategy;\n\t}\n\t\n\tpublic int calculatePrice(int km) {\n\t\treturn mStrategy.calculatePrice(km);\n\t}\n}\n```\n\n#### 策略模式的实战应用\n对于默认情况下，ImageLoader 会按照先后顺序加载图片，但在实际算法当中，相反顺序加载图片也是有可能的，即反序列加载图片。当然加载方式可看作多种策略，共同的目标是实现加载图片。图 2-13 是 ImageLoader 的 UML 类图。\n\n![ImageLoader的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-13.png)\n<center>图 2-13 ImageLoader 的 UML 类图</center>\n\n```Java\npublic interface LoadPolicy { // 加载策略接口\n\tpublic int compare(BitmapRequest request1, BitmapRequest request2);\n}\n\n/**\n * 顺序加载策略\n */\npublic class SerialPolicy implements LoadPolicy {\n\t@Override\n\tpublic int compare(BitmapRequest request1, BitmapRequest request2) {\n\t\t// 按照添加到队列的序列号顺序来执行\n\t\treturn request1.serialNum - request2.serialNum;\n\t}\n}\n\n/**\n * 逆序加载策略，即从最后加入队列的请求进行加载\n */\npulbic class ReversePolicy implements LoadPolicy {\n\t@Override\n\tpublic int compare(BitmapRequest request1, BitmapRequest request2) {\n\t// 注意: Bitmap 请求要先执行最晚加入队列的请求，ImageLoader 的策略 \n\treturn request2.serialNum - request1.serialNum;\n\t}\n}\n\n/** \n * 因每个请求都有一序列号，序列号以递增形式增加，越晚加入队列的请求序列号越大。\n * 而请求队列是优先级队列，因此我们需要在图片加载请求类中实现 Comparable 接口，以实现对这些请求的排序处理。\n */\npublic class BitmapRequest implements Comparable<BitmapRequest> { // 加载策略\n\tLoadPolicy mLoadPolicy = new SerialPolicy();\n\t@Override\n\tpublic int compareTo(BitmapRequest another) {\n\t\t// 委托给 LoadPolicy 进行处理，实现按照策略模式\n\t\treturn mLoadPolicy.compare(this, another);\n\t}\n}\n\n/**\n * 用户在配置 ImageLoader 时可以设置加载策略，\n * 这个策略会被设置给每个图片加载请求对象，具体如下：\n */\npublic void displayImage(final ImageView imageView, final String uri, final DisplayConfig config, final ImageListener listener) {\n\tBitmapRequest request = new BitmapRequest(imageView, uri, config, listener);\n \t\n\t// 加载的配置对象，如果没有设置则使用 ImageLoader 的配置\n\trequest.displayConfig = request.displayConfig != null ?\n\t\trequest.displayConfig : mConfig.displayConfig;\n \t// 设置加载策略\n \trequest.setLoadPolicy(mConfig.loadPolicy);\n \t// 添加到队列中\n\tmImageQueue.addRequest(request);\n}\n```\n\n#### 总结\n- 策略模式的优缺点\n\t- 优点  \n\t1) 很好地演示了开闭原则，也就定义了抽象。  \n\t2) 耦合度相对较低，扩展方法。\n\t- 缺点 - 随着策略的增加，子类会变得繁多。\n\n### 状态模式\n- 状态模式和策略模式和结构几乎一样，但它们的目的本质完全相异。\n\t- 状态模式：行为是平行的，不可替换的。\n\t- 策略模式：行为彼此独立，可相互替换。\n\n#### 状态模式的定义\n当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。\n\n#### 状态模式的使用场景\n代码中包含大量与对象状态有关的条件语句。如操作中含有庞大的多分支语句 ( `if-else` 或 `switch-case` )，且这些分支依赖与该对象的状态。\n\n若使用状态模式来优化架构，即每一条件分支放于独立的类。\n\n#### 状态模式的 UML 类图\n![状态模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-14.png)\n<center>图 2-14 状态模式的 UML 类图</center> \n\n#### 状态模式的简单示例\n下面以电视遥控器为例演示状态模式的实现。便于理解，本示例的 UML 类图如图 2-15 所示。\n\n![电视遥控器UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-15.png)\n<center>图 2-15 电视遥控器 UML 类图</center> \n\n#### 状态模式实战\n在新浪微博中，用户在未登录的情况下点击转发按钮，此时会先让用户登录，然后再执行转发操作；如果已登录的情况下，那么用户输入转发的内容后就可以直接进行操作。\n\n![新浪微博用户状态管理UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-16.png)\n<center>图 2-16 新浪微博用户状态管理 UML 类图</center> \n\n#### 总结\n- 状态模式的优缺点\n\t- 优点 - 将所有与一个特定的状态相关的行为都放入一个状态对象中，它提供了一个更好的方法来组织与特定状态相关的代码，将繁琐的状态判断转为结构清晰的状态类族。\n\t- 缺点 - 必然增加系统类和对象的个数。\n\n### 责任链模式\n#### 责任链模式的定义\n- 行为型设计模式。\n- 通俗定义：每个节点看作一对象，每一对象拥有不同的处理逻辑，将一请求从链式的首端发出，沿着链的路径一次传递每个节点对象，直至有对象处理这个请求为止。\n- 标准定义：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成链，并沿着这条链传递该请求，直至有对象处理它为止。\n\n#### 责任链模式的使用场景\n- 多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动态决定。\n- 在请求处理者不明确的情况下向多个对象中的其一提交一个请求。\n- 需要动态指定一组对象处理请求。\n\n#### 责任链模式的 UML 类图\n责任链模式的 UML 类图如图 2-17 所示。\n\n![责任链模式UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-17.png)\n<center>图 2-17 责任链模式 UML 类图</center>\n\n```Java\n// 抽象处理者\npublic abstract class Handler {\n\tprotected Handler successor; // 下一节点的处理者\n\t/**\n\t * 请求处理\n\t * @param condition 请求条件\n\t */\n\tpublic abstract void handleRequest(String condition);\n}\n\n// 具体的处理者1\npublic class ConcreteHandler1 extends Handler {\n\t@Override\n\tpublic void handleRequest(String condition) {\n\t\tif(condition.equals(\"ConcreteHandler1\")) {\n\t\t\tSystem.out.println(\"ConcreteHandler1 handled\");\n\t\t\treturn;\n\t\t} else {\n\t\t\tsuccessor.handleRequest(condition);\n\t\t}\n\t}\n}\n\n// 具体的处理者2\npublic class ConcreteHandler1 extends Handler {\n\t@Override\n\tpublic void handleRequest(String condition) {\n\t\tif(condition.equals(\"ConcreteHandler2\")) {\n\t\t\tSystem.out.println(\"ConcreteHandler2 handled\");\n\t\t\treturn;\n\t\t} else {\n\t\t\tsuccessor.handleRequest(condition);\n\t\t}\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t// 构造一个 ConcreteHandler1 对象\n\t\tConcreteHandler1 handler1 = new ConcreteHandler1();\n\t\t// 构造一个 ConcreteHandler2 对象\n\t\tConcreteHandler2 handler1 = new ConcreteHandler2();\n\t\t// 设置 handler1 的下一个节点\n\t\thandler1.successor = handler2;\n\t\t// 设置 handler2 的下一个节点\n\t\thandler2.successor = handler1;\n\t\t// 处理请求\n\t\thandler1.handleRequest(\"ConcreteHandler2\");\n\t}\n}\n```\n\n#### 责任链模式的简单实现\n在公司中报销费用中，审批的流程其实就是一个类似责任链的实例。例如，小明是请求的发起者，而处理者有组长、部门主管、经理和老板，对于不同额度的报销费用需要不同级的处理者审批，准确地说，每一类人代表这条链上的一个节点。\n\n例如小民是请求的发起者，而老板则是处于链条顶端的类，小民从链的底端开始发出一个申请报账的请求，首先由组长处理该请求，组长比对后发现自己权限不够于是将该请求转发给位于链中下一个节点的主管，主管比对后发现自己权限不足又将该请求转发给经理，经理也基于同样的原因将请求转发给老板，这样层层转达直至请求被处理。即至始至终小民关心的是报账结果，而不用在乎处理者是谁。责任链模式在这里很好地将请求的发起者与处理者解耦。\n\n便于理解，本示例的 UML 类图如图 2-18 所示。\n\n![报账审核机制UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-18.png)\n<center>图 2-18 报账审核机制 UML 类图</center>\n\n```Java\n// 抽象领导者\npublic abstract class Leader {\n\tprotected Leader nextHandler; // 上一级领导处理者\n\t\n\t/**\n\t * 处理报账请求\n\t * @param money 能批复的报账额度\n\t */\n\tpublic final void handleRequest() {\n\t\tif( money < limit() ) {\n\t\t\thandle(money);\n\t\t} else {\n\t\t\tif( null != nextHandlder ) {\n\t\t\t\tnextHandler.handleRequest(money);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * 自身能批复的额度权限\n\t * @return 额度\n\t */\n\tpublic abstract int limit();\n\t\n\t/**\n\t * 处理报账行为\n\t * @param money 具体金额\n\t */\n\tpulbic abstract void handle(int money);\n}\n\npublic class GroupLeader extends Leader {\n\t@Override\n\tpublic int limit() {\n\t\treturn 1000;\n\t}\n\t@Override\n\tpublic void handle(int money) {\n\t\tStsten.out.println(\"组长批复报销\" + money + \"元\");\n\t}\n}\n\npublic class Director extends Leader {\n\t@Override\n\tpublic int limit() {\n\t\treturn 5000;\n\t}\n\t@Override\n\tpublic void handle(int money) {\n\t\tStsten.out.println(\"主管批复报销\" + money + \"元\");\n\t}\n}\n\npublic class Manager extends Leader {\n\t@Override\n\tpublic int limit() {\n\t\treturn 10000;\n\t}\n\t@Override\n\tpublic void handle(int money) {\n\t\tStsten.out.println(\"经理批复报销\" + money + \"元\");\n\t}\n}\n\npublic class Boss extends Leader {\n\t@Override\n\tpublic int limit() {\n\t\treturn Integer.MAX_VALUE;\n\t}\n\t@Override\n\tpublic void handle(int money) {\n\t\tStsten.out.println(\"老板批复报销\" + money + \"元\");\n\t}\n}\n\n// 小民从组长开始发起请求申请报账\npublic class XiaoMin {\n\tpublic static void main(String[] args) {\n\t\t// 构造各个领导对象\n\t\tGroupLeader groupLeader = new GroupLeader();\n\t\tDirector director = new Director();\n\t\tManager manager = new Manager();\n\t\tBoss boss = new Boss();\n\t\t\n\t\t// 设置上一级领导处理者对象\n\t\tgroupLeader.nextHandler = director;\n\t\tdirector.nextHandler = manager;\n\t\tmanager.nextHandler = boss;\n\t\t\n\t\t// 发起报账申请\n\t\tgroupLeader.handleRequest(50000);\n\t}\n}\n```\n\n#### 责任链模式实战\nAndroid 中我们可以借鉴责任链模式的思想来优化 BroadcastReceiver 使之成为一个全局的责任链处理者。\n\n我们知道 Broadcast 可以被分为两种:\n\n- Normal Broadcast：普通广播，异步广播，发出时可被所有的接收者收到。\n- Ordered Broadcast：有序广播，依优先级依次传播的，直到有接收者将其终止或所有接收者都不终止它。\n\n有序广播这一特性与我们的责任链模式很相近，通过它可实现一种全局的责任链事件处理。\n\n```Java\n// 具体的实现思路是，通过 Intent 的限制值来限定最终的广播权归谁所有\npublic class FirstReceiver extends BroadcastReceiver {\n\t@Override\n\tpublic void onReceive(Context context, Intent intent) {\n\t\t// 获取 Intent 中附加的限制值\n\t\tint limit = intent.getIntExtra(\"limit\", -1001);\n\t\t\n\t\t// 如果限定值等于 1000 则处理，否则继续转发给下一个 Receiver\n\t\tif( 1000 == limit ) {\n\t\t\t// 获取 Intent 中附加的字符串消息并 Toast\n\t\t\tString msg = intent.getStringExtra(\"msg\");\n\t\t\tToast.makeText(context, msg, Toast.LENGTH_SHORT).show();\t\t\n\t\t\t// 终止广播\n\t\t\tabortBroadcast();\n\t\t} else {\n\t\t\t// 添加信息发送给下一个 Receiver\n\t\t\tBundle b = new Bundle();\n\t\t\tb.putString(\"new\", \"Message from FirstReceiver\");\n\t\t\tsetResultExtras(b);\n\t\t}\n\t}\n}\n\npublic class SecondReceiver extends BroadcastReceiver {\n\t@Override\n\tpublic void onReceive(Context context, Intent intent) {\n\t\t// 获取 Intent 中附加的限制值\n\t\tint limit = intent.getIntExtra(\"limit\", -1001);\n\t\t\n\t\t// 如果限定值等于 100 则处理，否则继续转发给下一个 Receiver\n\t\tif( 100 == limit ) {\n\t\t\t// 获取 Intent 中附加的字符串消息\n\t\t\tString msg = intent.getStringExtra(\"msg\");\n\t\t\t\n\t\t\t// 获取上一个 Receiver 增加的消息\n\t\t\tBundle b = getResultExtras(true);\n\t\t\tString str = b.getString(\"new\");\n\t\t\t\n\t\t\tToast.makeText(context, msg + str, Toast.LENGTH_SHORT).show();\t\t\n\t\t\t// 终止广播\n\t\t\tabortBroadcast();\n\t\t} else {\n\t\t\t// 添加信息发送给下一个 Receiver\n\t\t\tBundle b = new Bundle();\n\t\t\tb.putString(\"new\", \"Message from FirstReceiver\");\n\t\t\tsetResultExtras(b);\n\t\t}\n\t}\n}\n\npublic class ThirdReceiver extends BroadcastReceiver {\n\t@Override\n\tpublic void onReceive(Context context, Intent intent) {\n\t\t// 获取 Intent 中附加的限制值\n\t\tint limit = intent.getIntExtra(\"limit\", -1001);\n\t\t\n\n\t\t// 如果限定值等于 10 则处理，否则继续转发给下一个 Receiver\n\t\tif( 10 == limit ) {\n\t\t\t// 获取 Intent 中附加的字符串消息\n\t\t\tString msg = intent.getStringExtra(\"msg\");\n\t\t\t\n\t\t\t// 获取上一个 Receiver 增加的消息\n\t\t\tBundle b = getResultExtras(true);\n\t\t\tString str = b.getString(\"new\");\n\t\t\t\n\t\t\tToast.makeText(context, msg + str, Toast.LENGTH_SHORT).show();\t\t\n\t\t\t// 终止广播\n\t\t\tabortBroadcast();\n\t\t} else {\n\t\t\t// 添加信息发送给下一个 Receiver\n\t\t\tBundle b = new Bundle();\n\t\t\tb.putString(\"new\", \"Message from FirstReceiver\");\n\t\t\tsetResultExtras(b);\n\t\t}\n\t}\n}\n\n// 客户端实现\npublic class OrderActivity extends Activity {\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_order);\n\t\t\n\t\tButton btnSend = (Button) findViewById(R.id.order_send_btn);\n\t\tbtnSend.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tIntent i = new Intent();\n\t\t\t\ti.setAction(\"com.aigestudio.action.ORDER_BROADCAST\");\n\t\t\t\ti.putExtra(\"limit\", 100);\n\t\t\t\ti.putExtra(\"msg\", \"Message from OrderActivity\");\n\t\t\t\tsendOrderedBroadcast(i, null);\n\t\t\t}\n\t\t});\n\t}\n}\n\n// 这里我们设置 limit = 100，即只有 SecondReceiver 才会处理它。\n```\n\n#### 总结\n- 责任链模式的优缺点\n\t- 优点 - 对请求者和处理者关系解耦，提高代码灵活性。\n\t- 缺点 - 递归调用。特别是处理者太多，那么遍历定会影响性能。\n\n### 解释器模式\n\n#### 解释器模式的定义\n- 行为型设计模式。\n- 概念：给定一个语言，定义它的 `文法` 的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。\n- 文法：例如我们熟悉的「主谓宾结构」，通过下述短语举例，我们可把短语抽象看作：I am a/an [noun.]\n\n| 主语 | 谓语 | 宾语 |\n| --- | --- | --- |\n| I | am | a designer |\n| I | am | a teacher |\n\n- 再举例：假设有如以 ab 开头 ef 结尾，中间排列 N(N>=0) 个 cd 的字符串。\n> abcdcd...cdef\n\n 在计算机科学中，我们将上述字符串中的 “a”、“b”、“c”、“d”、“e” 和 “f” 这 6 个字符称为一种形式语言的 `字符表`。\n\n 而这些字符组成的集合，如 “abcdcd...cdef” 这样由字符表构成的字符串则称为 `形式语言`。注意这里的语言不是文法。\n\n 假设定义一个符号 S，从符号 S 出发推导上述字符串，即可得到如下推导式：\n\n ```Java\n S ::= abA*ef  \n A ::= cd\n ```\n \n - `::==` 称为推导；  \n - `*` 表示闭包，上述推导式中意思是，符号 A 可以有 0 或 N 个重复；  \n - 非终结符号：`S` 和 `A` 则称非终结符号，即它们能推导出式子右边的表达式；  \n - 终结符号：\"pqmn\"，“ab”，“ef”，即无法再推导；\n\n#### 解释器模式的使用场景\n- 某个 `简单语言` 需要解释执行且可将该语言中的语句表示为 `抽象语法树` 时可考虑使用解释器模式。\n\n\t> 如：有非终结符号 p+q+m-n，即该数学表示式可表示为一棵抽象语法树。如图 2-19 所示。\n\n![p+q+m-n的抽象语法树](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-19.png)\n<center>图 2-19 p+q+m-n 的抽象语法树</center>\n\n- 某些特定的领域出现不断重复的问题时，可将该领域的问题转化为一种语法规则下的语句，然后构建解释器来解释该语句。\n\n\t> 英文字母的大小写转换；阿拉伯数字转为中文的数字...   \n\t> 即它们都是一个个终结符，不同的只是具体内容。\n\t\n#### 解释器模式的 UML 类图\n解释器模式的 UML 类图如图 2-20 所示。\n\n![解释器模式UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-20.png)\n<center>图 2-20 解释器模式 UML 类图</center>\n\n```Java\npublic abstract class AbstractExpression {\n\t/**\n\t * 抽象的解析方法\n\t * @param ctx 上下文环境对象\n\t */\n\tpublic abstract void interpret(Context ctx);\n}\n\n// 终结符表达式\npublic class TerminalExpression extends AbstractExpression {\n\t@Override\n\tpublic abstract void interpret(Context ctx) {\n\t\t// 实现文法中与终结符有关的解释操作\n\t}\n}\n\n// 非终结符表达式\npublic class NonterminalExpression extends AbstractExpression {\n\t@Override\n\tpublic abstract void interpret(Context ctx) {\n\t\t// 实现文法中与非终结符有关的解释操作\n\t}\n}\n\npublic class Context {\n\t// 包含解释器之外的全局信息\n}\n\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t// 根据文法对特定句子构建抽象语法树后解释\n\t}\n}\n```\n\n#### 总结\n- 解释模式的优缺点\n\t- 优点 - 灵活的扩展性，即我们想对文法规则进行扩展延伸时，只需增加相应的非终结符解释器，并在构建抽象语法树时，使用到新增的解释器对象进行具体的解释即可。\n\t- 缺点  \n\t1) 对于每一条文法对应至少一个解释器，其会生成大量的类，导致后期维护困难； \n\t2) 构建其抽象语法树会显得异常繁琐，甚至可能出现需要构建多棵抽象语法树的情况。\n\n### 命令模式\n\n#### 命令模式的定义\n- 行为型设计模式。\n- 介绍：将一系列的方法调用封装，用户只需调用一个方法执行，那么所有这些被封装的方法就会被挨个执行调用。\n- 定义：\n - 将一个请求封装成一个对象，从而让用户使用不同的请求把客户端参数化。\n - 对请求排队或者记录请求日志，以及支持可撤销的操作。\n\n#### 命令模式的使用场景\n- 需要抽象出待执行的动作，然后以参数的形式提供处理 (类似过程设计中的回调机制)。\n- 在不同的时刻指定、排列和执行请求。一个命令对象可以有与初始请求无关的生存期。\n- 需要支持取消操作。\n- 需要支持事务操作。\n- 支持修改日志功能，若系统崩溃，这些修改可重做一遍。\n\n#### 命令模式的 UML 类图\n命令模式的 UML 类图如图 2-21 所示。\n\n![命令模式UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-21.png)\n<center>图 2-21 命令模式 UML 类图</center>\n\n**Receiver：接收者角色**  \n该类负责具体实施或执行一个请求，通俗地说，执行具体逻辑的角色。\n\n**Command：命令角色**  \n定义所有具体命令类的抽象接口。\n\n**ConcreteCommand：具体命令角色**  \n该类实现了 Command 接口，在 execute() 方法中调用接收者角色的相关方法，在接收者和命令执行的具体行为之间加以弱耦和。\n\n**Invoker：请求者角色**  \n该类的职责就是调用命令对象执行具体的请求，相关的方法我们称为行动方法。\n\n这里其实大家可以看到，命令模式的应用其实可用一句话概述，就是将行为调用者与实现者解耦。\n\n```Java\n// 接收者类\npublic class Receiver {\n\t/**\n\t * 真正执行具体命令逻辑的方法\n\t */\n\tpublic void action() {\n\t\tSystem.out.println(\"执行具体操作\");\n\t}\n}\n\n// 抽象命令接口\npublic interface Command {\n\t/**\n\t * 执行具体操作的命令\n\t */\n\tvoid execute();\n}\n\n// 具体命令类\npublic class ConcreteCommand implements Command {\n\tprivate Receiver receiver; // 持有一个对接受者对象的引用\n\tpublic ConcreteCommand(Receiver receiver) {\n\t\tthis.receiver = receiver;\n\t}\n\t@Override\n\tpublic void execute() {\n\t\t// 调用接收者的相关方法来执行具体逻辑\n\t\treceiver.action();\n\t}\n}\n\n// 请求者类\npublic class Invoker {\n\tprivate Command command; // 持有一个对应命令对象的引用\n\t\n\tpublic Invoker() {\n\t\tthis.command = command;\n\t}\n\t\n\tpublic void action() {\n\t\t// 调用具体命令对象的相关方法，执行具体命令\n\t\tcommand.execute();\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t// 构造一个接受者对象\n\t\tReceiver receiver = new Receiver();\n\t\t// 根据接收者对象构造一个命令对象\n\t\tCommand command = new ConcreteCommand(receiver);\n\t\t// 根据具体的对象构造请求者对象\n\t\tInvoker invoker = new Invoker(command);\n\t\t// 执行请求方法\n\t\tinvoker.action();\n\t}\n}\n```\n\n#### 命令模式的简单实现\n这里以古老的俄罗斯方块游戏为例，在命令模式下如何操控俄罗斯方块变换。游戏中含有 4 个按钮，即上下左右。设定玩游戏的人相当于我们的客户端，游戏上的 4 个按钮相当于请求者，而执行具体按钮命令的逻辑方法可看作命令角色。\n\n便于理解，本示例的 UML 类图如图 2-22 所示。\n\n![命令模式实现俄罗斯方块游戏](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-22.png)\n<center>图 2-22 命令模式实现俄罗斯方块游戏</center>\n\n```Java\n// 接收者角色\npublic class TetrisMachine {\n\n\tpublic void toLeft() { // 真正处理 “向左” 操作的逻辑代码\n\t\tSystem.out.println(“向左”);\n\t}\n\t\n\tpublic void toRight() { // 真正处理 “向右” 操作的逻辑代码\n\t\tSystem.out.println(“向右”);\n\t}\n\t\n\tpublic void fastToBottom() { // 真正处理 “快速落下” 操作的逻辑代码\n\t\tSystem.out.println(“快速落下”);\n\t}\n\t\n\tpublic void transform() { // 真正处理 “改变形状” 操作的逻辑代码\n\t\tSystem.out.println(“改变形状”);\n\t}\t\n}\n\n// 命令者抽象\npublic interface Command {\n\t/**\n\t * 命令执行方法\n\t */\n\tvoid execute();\n}\n\n// 具体命令者：向左移的命令类\npublic class LeftCommand implements Command {\n\t// 持有一个接收者俄罗斯方块游戏对象的引用\n\tprivate TetrisMachine machine;\n\tpublic LeftCommand(TetriMachine machine){\n\t\tthis.machine = machine;\n\t}\n\t@Override\n\tpublic void execute() {\n\t\t// 调用游戏机里的具体方法执行操作\n\t\tmachine.toLeft();\n\t}\n}\n\n// 具体命令者：向右移的命令类\npublic class RightCommand implements Command {\n\t// 持有一个接收者俄罗斯方块游戏对象的引用\n\tprivate TetrisMachine machine;\n\tpublic RightCommand(TetriMachine machine){\n\t\tthis.machine = machine;\n\t}\n\t@Override\n\tpublic void execute() {\n\t\t// 调用游戏机里的具体方法执行操作\n\t\tmachine.toRight();\n\t}\n}\n\n// 具体命令者：快速落下的命令类\npublic class FallCommand implements Command {\n\t// 持有一个接收者俄罗斯方块游戏对象的引用\n\tprivate TetrisMachine machine;\n\tpublic FallCommand(TetriMachine machine){\n\t\tthis.machine = machine;\n\t}\n\t@Override\n\tpublic void execute() {\n\t\t// 调用游戏机里的具体方法执行操作\n\t\tmachine.fastToBottom();\n\t}\n}\n\n// 具体命令者：改变形状的命令类\npublic class TransformCommand implements Command {\n\t// 持有一个接收者俄罗斯方块游戏对象的引用\n\tprivate TetrisMachine machine;\n\tpublic TransformCommand(TetriMachine machine){\n\t\tthis.machine = machine;\n\t}\n\t@Override\n\tpublic void execute() {\n\t\t// 调用游戏机里的具体方法执行操作\n\t\tmachine.transform();\n\t}\n}\n\n// 请求者类：命令由按钮发起\npublic class Buttons {\n\tprivate LeftCommand leftCommand; // 向左移动的命令对象引用\n\tprivate RightCommand rightCommand; // 向右移动的命令对象引用\n\tprivate FallCommand fallCommand; // 快速落下的命令对象引用\n\tprivate TransformCommand transformCommand; // 变换形状的命令对象引用\n\t\n\t/**\n\t * 设置向左移动的命令对象\n\t * @param leftCommand 向左移动的命令对象\n\t */\n\tpublic void setLeftCommand(LeftCommand leftCommand) {\n\t\tthis.leftCommand = leftCommand;\n\t}\n\t\n\t/**\n\t * 设置向右移动的命令对象\n\t * @param rightCommand 向右移动的命令对象\n\t */\n\tpublic void setRightCommand(RightCommand rightCommand) {\n\t\tthis.rightCommand = rightCommand;\n\t}\n\t\n\t/**\n\t * 设置快速落下的命令对象\n\t * @param fallCommand 向左移动的命令对象\n\t */\n\tpublic void setFallCommand(FallCommand fallCommand) {\n\t\tthis.fallCommand = fallCommand;\n\t}\n\t\n\t/**\n\t * 设置变换形状的命令对象\n\t * @param transformCommand 向左移动的命令对象\n\t */\n\tpublic void setTransformCommand(TransformCommand transformCommand) {\n\t\tthis.leftCommand = leftCommand;\n\t}\n\t\n\tpublic void toLeft() { // 按下按钮向左移动\n\t\tleftCommand.execute();\n\t}\n\t\n\tpublic void toRight() { // 按下按钮向右移动\n\t\trightCommand.execute();\n\t}\n\t\n\tpublic void fall() { // 按下按钮快速落下\n\t\tfallCommand.execute();\n\t}\n\t\n\tpublic void transform() { // 按下按钮改变形状\n\t\ttransformCommand.execute();\n\t}\n}\n\n// 客户端实现\npublic class Player {\n\tpublic static void main(String[] args) {\n\t\t// 首先要有俄罗斯方块游戏\n\t\tTetrisMachine machine = new TetrisMachine();\n\t\t\n\t\t// 根据游戏我们构造 4 种命令\n\t\tLeftCommand leftCommand = new LeftCommand(machine);\n\t\tRightCommand rightCommand = new RightCommand(machine);\n\t\tFallCommand fallCommand = new FallCommand(machine);\n\t\tTransformCommand transformCommand = new TransformCommand(machine);\n\t\t\n\t\t// 按钮可以执行不同的命令\n\t\tButtons buttons = new Buttons();\n\t\tbuttons.setLeftCommand(leftCommand);\n\t\tbuttons.setRightCommand(rightCommand);\n\t\tbuttons.setFallCommand(fallCommand);\n\t\tbuttons.setTransformCommand(transformCommand);\n\t\t\n\t\t// 具体按下哪个按钮玩家决定\n\t\tbuttons.toLeft();\n\t\tbuttons.toRight();\n\t\tbuttons.fall();\n\t\tbuttons.transform();\n\t}\n}\n```\n\n对于大部分开发者来说，更愿意接受的形式：\n\n```Java\nTetrisMachine machine = new TetrisMachine();\n\n// 实现怎样的控制方式，直接调用相关函数\n// machine.toLeft();\n// machine.toRight();\n// machine.fastToBottom();\n// machine.transform();\n\nmachine.toLeft();\n```\n\n调用逻辑做得如此复杂，其实是为了开发起来方便，即每次我们增加或修改游戏功能只需修改 TetrisMachine 类即可。\n当然，其实这样做是有原因的，即设计模式种有一条重要的原则：对修改关闭对扩展开放。具体好处是：\n\n- 如修改功能、代码的具体逻辑，以上例为例，即修改 TetrisMachine 类即可。\n- 此外，命令模式还可以实现命令记录的功能，如在 Buttons 里使用数据结构存储执行过的命令对象，需要时可恢复。\n\n#### 总结\n- 命令模式的优缺点\n\t- 优点 - 更灵活的控制性以及更好的扩展性；更弱的耦合性。\n\t- 缺点 - 类的膨胀，大量衍生类的创建。\n\n### 观察者模式\n\n#### 观察者模式的定义\n定义对象间一种 `一对多` 的 `依赖关系`，使得每当一个对象改变状态，则所有依赖与它的对象都会得到通知并被自动更新。\n\n#### 观察者模式的使用场景\n- 关联行为场景，即关联行为是可拆分的，而不是“组合”关系。\n- 事件多级触发场景。\n- 跨系统的消息交换场景，如消息队列、事件总线的处理机制。\n\n#### 观察者模式的 UML 类图\n观察者模式的 UML 类图如图 2-23 所示。\n\n![观察者模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-23.png)\n<center>图 2-23 观察者模式的 UML 类图</center>\n\n#### 观察者模式实战\n\n#### 总结\n- 观察者模式主要的作用就是对象解耦，将观察者与被观察者完全隔离，只依赖于 Observer 和 Obserable 抽象。\n\n> 如：ListView 就是运用了 Adapter 和观察者模式，使之它的扩展性、灵活性增强，且耦合度却很低。\n\n- 观察者模式的优缺点\n\t- 优点  \n\t1) 增强系统灵活性、可扩展性；  \n\t2) 将观察者与被观察者之间是抽象耦合，应对业务变换。\n\t- 缺点 - 应用观察者模式，需考虑开放效率和运行效率问题 (一般考虑采用异步的方式)\n\n### 备忘录模式\n\n#### 备忘录模式的介绍\n- 行为型设计模式。\n- 用于保存对象当前状态，并在之后可再次恢复到此状态。\n- 保证被保存的对象状态不能被对象从外部访问，目的是为了保护好被保存对象状态的完整性及内部实现不向外暴露。\n\n#### 备忘录模式的定义\n在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原生保存的状态。\n\n#### 备忘录模式的 UML 类图\n备忘录模式的 UML 类图如图 2-24 所示。\n\n![备忘录模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-24.png)\n<center>图 2-24 备忘录模式的 UML 类图</center>\n\n**Originator**  \n负责创建一个备忘录，可以记录、恢复自身的内部状态。同时 Originator 还可以根据需要决定 Memoto 存储自身的哪些内部状态。\n\n**Memoto**  \n备忘录角色，用于储存 Originator 的内部状态，并且可以防止 Originator 以外的对象访问 Memoto。\n\n**Caretaker**\n负责储存备忘录，不能对备忘录的内容进行操作和访问，只能够将备忘录传递给其他对象。\n\n#### 备忘录模式的简单实例\n对于备忘录模式来说，比较贴切的场景应该是游戏中的存档功能，该功能就是将游戏进度存储到本地文件系统或者数据库中，下次再次进入时从本地加载进度，使得玩家能够继续上一次的游戏之旅。下面我们以“使命召唤”这款游戏为例简单演示备忘录模式的实现。\n\n首先我们建立游戏类 CallOfDuty，备忘录类 Memoto 和负责管理 Memoto 的 CareTaker 类。玩游戏到某个节点对游戏进行存档，然后退出游戏，再重新进入时从存档中读取进度，并且进入存档时的进度。\n\n便于理解，本示例的 UML 类图如图 2-25 所示。\n\n![使命召唤的存储功能实现](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-25.png)\n<center>图 2-25 使命召唤的存储功能实现</center>\n\n```Java\n// ”使命召唤“ 游戏 ( 简化的数据模型，仅供简单演示 )\npublic class CallOfDuty {\n\tprivate int mCheckPoint = 1;\n\tprivate int mLifeValue = 100;\n\tprivate String mWeapon = \"沙漠之鹰\";\n \n\tpublic void play() { // 玩游戏\n\t\t// 忽略实现细节\n\t}\n \n\tpublic void quit() { // 退出游戏\n\t\t// 忽略实现细节\n\t}\n \n\tpublic Memoto createMemoto() { // 创建备忘录\n \t\tMemoto memoto = new Memoto();\n \t\tmemoto.mCheckPoint = mCheckPoint;\n \t\tmemoto.mLifeValue = mLifeValue;\n \t\tmemoto.mWeapon = mWeapon;\n \t\treturn memoto;\n\t}\n \n \tpublic void restore(Memoto memoto) { // 恢复游戏\n \t\tthis.mCheckPoint = memoto.mCheckPoint;\n \t\tthis.mLifeValue = memoto.mLifeValue;\n \t\tthis.mWeapon = memoto.mWeapon;\n \t\tSystem.out.println(\"恢复后的游戏属性: \" + this.toString());\n\t}\n \n \t@Overrride\n\tpublic String toString() {\n\t\treturn \"CallOfDuty[mCheckPoint=..., mLifeValue=..., mWeapon=...]\"\n\t}\n}\n\n// 备忘录类\npublic class Memoto {\n\tpublic int mCheckPoint;\n\tpublic int mLifeValue;\n\tpublic String mWeapon;\n}\n\n// Caretaker，负责管理 Memoto\npublic class Caretaker {\n\tMemoto memoto = null;\n\t\n\tpublic void archive(Memoto memoto) { // 存档\n\t\tthis.memoto = memoto;\n\t}\n\t\n\tpublic Memoto getMemoto() { // 读取存档\n\t\treturn memoto;\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tCallOfDuty game = new CallOfDuty();\n\t\t\n\t\t// Step.01 游戏开始\n\t\tgame.play();\n\t\t\n\t\t// Step.02 游戏存档\n\t\tCaretaker caretaker = new Caretaker();\n\t\tcaretaker.archive( game.createMemoto() );\n\t\t\n\t\t// Step.03 退出游戏\n\t\tgame.quit();\n\t\t\n\t\t// Step.04 恢复游戏\n\t\tCallOfDuty newGame = new CallOfDuty();\n\t\tnewGame.restore( caretaker.getMemoto() );\n\t}\n}\n```\n\n#### 总结\n- 备忘录模式是在不破坏封装的条件下，通过备忘录对象 (Memoto) 存储另外一个对象内部状态的快照，在需求的时候把对象还原到存储的状态。\n- 备忘录的优缺点\n\t- 优点 - 恢复状态机制；信息封装\n\t- 缺点 - 消耗内存 \n \n### 迭代器模式\n\n#### 迭代器模式的介绍\n- 又称游标 (Cursor) 模式，行为型设计模式。\n- 迭代器模式源于对容器的访问，若我们将遍历的方法封装在容器中，则存在问题：\n\t- 不仅维护自身内部数据且要对外提供遍历的接口方法。\n\t- 不能对同一个容器同时进行多个遍历操作。\n\t- 不提供遍历方法，而让使用者自行实现，必暴露内部细节。  \n \n\t解决方案：在客户访问类与容器直接插入一个第三者 `迭代器`。\n\n#### 迭代器模式的定义\n提供一种方法顺序访问一个容器对象中的各个元素，而不需暴露该对象内部细节。\n\n#### 迭代器模式的 UML 类图\n迭代器模式的 UML 类图如图 2-26 所示。\n\n![迭代器模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-26.png)\n<center>图 2-26 迭代器模式的 UML 类图</center>\n\n**Iterator：迭代器接口**  \n迭代器接口，负责定义、访问和遍历元素的接口。\n\n**ConcreteIterator：具体迭代器类**  \n具体迭代器类，实现迭代器接口，并记录遍历的当前位置。  \n\n**Aggregate：容器接口**  \n容器接口，负责提供创建具体迭代器角色的接口。\n\n**ConcreteIterator：具体容器类**\n具体容器类，具体迭代器角色与该容器相关联。\n\n```Java\n// 迭代器接口\npublic interface Iterator<T> {\n\t/**\n\t * 是否还有下一个元素\n\t * @return true 表示有，false 表示没有\n\t */\n\tboolean hasNext();\n\t\n\t/**\n\t * 返回当前位置的元素并将位置移至下一位\n\t * @return T 返回当前位置的元素\n\t */\n\tT next();\n}\n\n// 具体迭代器类\npublic class ConcreteIterator<T> implements Iterator<T> {\n\tprivate List<T> list = new ArrayList<T>();\n\tprivate int cursor = 0;\n\t\n\tpublic ConcreteIterator(List<T> list) {\n\t\tthis.list = list;\n\t}\n\t\n\t@Override\n\tpublic boolean hasNext() {\n\t\treturn cursor != list.size();\n\t}\n\t\n\t@Override\n\tpublic T next() {\n\t\tT obj = null;\n\t\tif( this.hasNext()) {\n\t\t\tobj = this.list.get(cursor++);\n\t\t}\n\t\treturn obj;\n\t}\n}\n\n// 容器接口\npulbic interface Aggregate<T> {\n\t/**\n\t * 添加一个元素\n\t * @param obj 元素对象\n\t */\n\tvoid add(T obj); \n\t\n\t/**\n\t * 移除一个元素\n\t * @param obj 元素对象\n\t */\n\tvoid remove(T obj);\n\t\n\t/**\n\t * 获取容器的迭代器\n\t * @return 迭代器对象\n\t */\n\tIterator<T> Iterator();\n}\n\n// 具体容器类\npublic class ConcreteAggregate<T> implements Aggregate<T> {\n\tprivate List<T> list = new ArrayList<T>();\n\t\n\t@Override\n\tpublic void add() {\n\t\tlist.add(obj);\n\t}\n\t\n\t@Override\n\tpublic void remove() {\n\t\tlist.remove(obj);\n\t}\n\t\n\t@Override\n\tpublic Iterator<T> iterator() {\n\t\treturn new ConcreteIterator<T>(list);\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tAggregate<String> aggregate = new ConcreteAggregate<>();\n\t\t\n\t\taggregate.add(\"Aige \");\n\t\taggregate.add(\"Studio\\n\");\n\t\taggregate.add(\"SM \");\n\t\taggregate.add(\"Brother\\n\");\n\t\t\n\t\tIterator<String> iterator = aggregate.iterator();\n\t\twhile( iterator.hasNext() ) {\n\t\t\tSystem.out.println(iterator.next());\n\t\t}\t\n\t}\n}\n```\n\n#### 总结\n- 迭代器模式的优缺点\n\t- 优点 - 支持以不同的方式遍容器对象，也可以有多个遍历，弱化了容器类与遍历算法之间的关系。\n\t- 缺点 - 类文件的增加。  \n- 当然几乎每一种高级语言都有相应的内置迭代器实现，故本章的内容在于了解而非应用。\n\n### 模板方法模式\n\n#### 模板方法模式的介绍\n若我们知道一个算法所需的关键步骤，并确定了这些步骤的执行顺序，但某些步骤的具体实现是未知的，或实现是随着环境变化的。\n\n> 例如，执行程度的流程大致为：  \n> Step.01：检查代码正确性  \n> Step.02：链接相关类库  \n> Step.03：编译  \n> Step.04：执行程序  \n> 即上述步骤不一样 ( 实现细节 )，但执行流程是固定的。\n\n#### 模板方法模式的定义\n- 定义一个操作的 `算法框架`。\n- 将步骤延迟到子类，使子类不改变算法结构即可重定义该算法的某些特定步骤。\n\n#### 模板方法模式的使用场景\n- 多个子类有公有的方法，且逻辑基本相同。\n- 重要复杂的算法，可把核心算法设计为模板方法，周边细节功能则由各个子类实现。\n- 重构时，使用模板方法，即相同代码抽取到父类中，然后通过 `钩子函数` 约束其行为。\n\n\t> 钩子函数：普通的抽象类多态，即它在模板方法模式中提供了改变原始逻辑的空间。\n\n#### 模板方法模式的 UML 类图\n模板方法模式的 UML 类图如图 2-27 所示。\n\n![模板方法模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-27.png)\n<center>图 2-27 模板方法模式的 UML 类图</center>\n\n#### 总结\n- 模板方法模式：流程封装，即把某个固定的流程封装到一个 final 函数中，并让子类能够定制这个流程中的某些或者所有步骤。\n\n\t> 要求父类提供共同代码，即提高代码复用性、可扩展性。\n\n- 模板方法的优缺点\n\t- 优点  \n\t1) 封装不变部分，扩展可变部分。  \n\t2) 提取公共部分代码。  \n\t- 缺点：代码阅读有难度？\n\n### 访问者模式\n\n#### 访问者模式的介绍\n- 将 `数据操作` 与 `数据结构` 分离的设计模式。\n- 软件系统拥有由许多对象构成的对象结构，这些对象类拥有一 accept() 方法接受访问者对象访问。\n- 访问者是一接口，拥有一 visit() 方法对访问到的对象结构中不同类型的元素作出不同的处理。\n\n\t> * 在对象结构的一次访问中，遍历整个对象结构，对每个元素实施 accept() 方法。  \n\t> * 每一元素的 accept() 方法会调用访问者的 visit() 方法，即访问者可针对对象结构设计不同的访问类来完成不同操作。\n\n#### 访问者模式的定义\n封装用于某种数据结构中各元素操作，且在不改数据结构的前提下定义这些元素的新操作。\n\n#### 访问者模式的使用场景\n- 对一对象结构中的对象进行不同且不相关的操作。\n- 需避免操作“污染”对象的类。\n- 增加新操作是不修改这些类。\n- 对象结构稳定，但经常需在对象结构上定义新操作。\n\n#### 访问者模式的 UML 类图\n访问者模式的 UML 类图如图 2-28 所示。\n\n![访问者模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-28.png)\n<center>图 2-28 访问者模式的 UML 类图</center>\n\n#### 访问者模式的简单示例\n公司给员工进行业绩考核，评定由公司高层负责。但不同领域的管理人员对与员工的评定标准不一样。即我们把员工分为工程师和经理，评定员工分为 CTO 和 CEO。\n\n假定 CTO 关注工程师的代码量，经理的新产品数量；CEO 关注工程师的 KPI，经理的 KPI 及新产品数量。\n\n便于理解，本示例的 UML 类图如图 2-29 所示。\n\n![公司员工业绩考核](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-29.png)\n<center>图 2-29 公司员工业绩考核</center>\n\n```Java\n// 员工基类\npublic abstract class Staff {\n\tpublic String name;\n\tpublic int kpi; // 员工 KPI\n\tpublic Staff(String name) {\n\t\tthis.name = name;\n\t\tkpi = new Random().nextInt(10); // 随机生成 10 内的值.\n\t}\n\t\n\t// 接受 Visitor 的访问\n\tpublic abstract void accept(Visitor visitor);\n}\n\n// 工程师类型\npublic class Engineer extends Staff {\n\tprivate int codes; // 代码量\n\t\n\tpublic Engineer (String name) {\n\t\tsuper(name);\n\t\tcodes = new Random().nextInt(100000)\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic int getCodeLines() { // 工程师一年内写的代码量\n\t\treturn codes;\n\t}\n}\n\n// 经理类型\npublic class Manager extends Staff {\n\tprivate int products; // 产品数量\n\t\n\tpublic Manager (String name) {\n\t\tsuper(name);\n\t\tproducts = new Random().nextInt(10);\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic int getProducts() { // 经理一年内做的产品数量\n\t\treturn products;\n\t}\n}\n\npublic interface Visitor {\n\t// 访问工程师类型\n\tpublic void visit(Engineer engineer); \n\t\n\t// 访问经理类型\n\tpublic void visit(Manager leader); \n}\n\n// CEO 访问者\npublic class CEOVisitor implements Visitor {\n\t@Override\n\tpublic void visit(Engineer engineer) {\n\t\tSystem.out.println(\"Name:..., KPI:...\");\n\t}\n\t\n\t@Override\n\tpublic void visit(Manager mgr) {\n\t\tSystem.out.println(\"Name:..., KPI:..., Products:...\");\n\t}\n}\n\n// CTO 访问者\npublic class CTOVisitor implements Visitor {\n\t@Override\n\tpublic void visit(Engineer engineer) {\n\t\tSystem.out.println(\"Name:..., Codes:...\");\n\t}\n\t\n\t@Override\n\tpublic void visit(Manager mgr) {\n\t\tSystem.out.println(\"Name:..., Products:...\");\n\t}\n}\n\npublic class BusinessReport {\n\tList<Staff> mStaffs = new LinkedList<Staff>();\n\t\n\tpublic BusinessReport() {\n\t\tmStaffs.add(new Manager(\"Manager Wang.\"));\n\t\tmStaffs.add(new Manager(\"Manager Lin.\"));\n\t\tmStaffs.add(new Manager(\"Engineer Kael.\"));\n\t\tmStaffs.add(new Manager(\"Engineer Chaos.\"));\n\t}\n\t\n\t/**\n\t * 为访问者展示报表\n\t * @param visitor 公司高层，如 CEO、CTO\n\t */\n\tpublic void showReport(Visitor visitor) {\n\t\tfor( Staff staff : mStaffs ) {\n\t\t\tstaff.accept(visitor);\n\t\t}\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tBusinessReport report = new BusinessReport();\n\t\treport.showReport( new CEOVisitor() );\n\t\treport.showReport( new CTOVisitor() );\n\t}\n}\n```\n\n#### 总结\n- 对象结构足够稳定，需在对象结构上经常定义新操作，且需对对象结构中的对象进行很多不同且不相关的操作，考虑访问者模式。\n- 访问者模式的优缺点\n\t- 优点  \n\t1) 单一职责原则，即各角色职责分离。  \n\t2) 数据结构和作用于该结构上的操作解耦。  \n\t- 缺点  \n\t1) 具体元素对访问者公布细节。  \n\t2) 具体元素变更导致修改成本大。  \n\t3) 违反依赖倒置原则，即为了“区别对待”而依赖了具体类，没有依赖抽象，如上例中的 Engineer 与 Manager。  \n\t\n### 中介者模式\n\n#### 中介者模式的介绍\n- 又称为调节者模式或调停者模式，行为型设计模式。\n\n#### 中介者模式的定义\n- 包装一系列对象相互作用的方式，使这些对象不必相互明显作用。\n- 将多对多的相互作用转化为一对多的相互作用。\n- 将对象的行为和协作抽象化。\n\n#### 中介者模式的使用场景\n- 对象间交互操作较多且每个对象的行为操作都依赖彼此时，为防止修改其中一对象的行为同时涉及修改很多其他对象的行为。\n- 该模式将对象之间的多对多关系变成一对多关系。\n- 中介者对象将系统从网状结构变成以调停者为中心的星形结构，以降低系统复杂性，提高可扩展性作用。\n\n#### 中介者模式的 UML 类图\n中介者模式的 UML 类图如图 2-30 所示。\n\n![中介者模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-30.png)\n<center>图 2-30 中介者模式的 UML 类图</center>\n\n```Java\n// 抽象中介者\npublic abstract class Mediator {\n\tprotected ConcreteColleagueA colleagueA; // 具体同事类 A\n\tprotected ConcreteColleagueB colleagueB; // 具体同事类 B\n\t\n\t// 抽象中介方法、子类实现\n\tpublic abstract void method();\n\t\n\tpublic void setColleagueA(ConcreteColleagueA colleagueA) {\n\t\tthis.colleagueA = colleagueA;\n\t}\n\t\n\tpublic void setColleagueB(ConcreteColleagueB colleagueB) {\n\t\tthis.colleagueB = colleagueB;\n\t}\n}\n\n// 具体中介者\npublic class ConcreteMediator extends Mediator {\n\t@Override\n\tpublic void method() {\n\t\tcolleagueA.action();\n\t\tcolleagueB.action();\n\t}\n}\n\n// 抽象同事\npublic abstract class Colleague {\n\tprotected Mediator mediator; // 中介者对象\n\t\n\tpublic Colleague(Mediator mediator) {\n\t\tthis.mediator = mediator;\n\t}\n\t\n\t// 同事角色的具体行为，由子类去实现\n\tpublic abstract void action();\n}\n\n// 具体同事 A\npublic class ConcreteColleagueA extends Colleague {\n\tpublic ConcreteColleagueA(Mediator mediator) {\n\t\tsuper(mediator);\n\t}\n\t\n\t@Override\n\tpublic void action() {\n\t\tSystem.out.println(\"Colleague A 将信息递交给中介者处理.\");\n\t}\n}\n\n// 具体同事 B\npublic class ConcreteColleagueB extends Colleague {\n\tpublic ConcreteColleagueB(Mediator mediator) {\n\t\tsuper(mediator);\n\t}\n\t\n\t@Override\n\tpublic void action() {\n\t\tSystem.out.println(\"Colleague B 将信息递交给中介者处理.\");\n\t}\n}\n```\n\n#### 中介者模式的简单实现\n便于理解，本示例的 UML 类图如图 2-31 所示。\n\n![电脑内部硬件的交互](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-31.png)\n<center>图 2-31 电脑内部硬件的交互</center>\n\n中介者模式就是用来协调多个对象之间的交互，就像上例中的主板，没有主板这个中介者，那么电脑里的每一个零部件都要与其他零部件建立关联。\n\n比如 CPU 要与内存交互，与显卡交互以及与 IO 设备交互，那么这样一来就会构成一个错综复杂的网状图，而中介者模式即将网状图变成一个结构清晰的星形图。\n\n#### 中介者模式实战\n协调多个交互的对象，Android 中这么多形形色色控件也算是交互对象。其中社交、网商等应用的用户登录模块，账号框、密码框、登录按钮之间的相互制约、联系，正是中介者模式的表现，具体的实例样式可自行尝试。\n\n#### 总结\n- 中介者模式的优缺点\n\t- 优点 - 将网状般的依赖关系转化为以中介者为中心的星形结构，即使用中介者模式可对这种依赖关系进行解耦使逻辑结构清晰。\n\t- 缺点 - 若几个类间的依赖关系并不复杂，使用中介者模式反而会使原本不复杂的逻辑结构变得复杂。\n\n### 代理模式\n\n#### 代理模式的定义\n- 结构型设计模式。\n- 为其他对象提供一种代理以控制对这个对象的访问。\n\n#### 代理模式的使用场景\n- 无法或不想直接访问某个对象或访问某对象存在困难。\n- 为保证客户端使用的透明性，委托对象与代理对象需实现相同的接口。\n\n#### 代理模式的 UML 类图\n代理模式的 UML 类图如图 2-32 所示。\n\n![代理模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-32.png)\n<center>图 2-32 代理模式的 UML 类图</center>\n\n**Subject：抽象主题类**  \n该类主要职责是声明真实主题与代理的共同接口方法，其可是抽象类或接口。\n\n**RealSubject：真实主题类**  \n该类也被称为被委托类或者被代理类，该类定义了代理所表示的真实对象，由其执行具体的业务逻辑方法，而客户类则通过代理类间接地调用真实主题类中定义的方法。\n\n**ProxySubject：代理类**  \n该类也称为委托类或者代理类，该类持有一个对真实主题类的引用，在其所实现的接口方法中调用真实主题类中相应的接口方法执行，以起到代理的作用。\n\n```Java\n// 抽象主题类\npublic abstract class Subject {\n\t// 一个普通的业务方法\n\tpublic abstract void visit();\n}\n\n// 实现抽象主题的真实主题类\npublic class RealSubject extends Subject {\n\tpublic void visit() {\n\t\tSystem.out.println(\"Real Subjetc!\");\n\t}\n}\n\n// 代理类\npublic class ProxySubject extends Subject {\n\tprivate RealSubject mSubject; // 持有真实主题的引用\n\t\n\tpublic ProxySubject(RealSubject mSubject) {\n\t\tthis.mSubject = mSubject;\n\t}\n\t\n\t@Override\n\tpublic void visit() {\n\t\tmSubject.visit();\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String args) {\n\t\t// 构造一个真实主题对象\n\t\tRealSubject real = new RealSubject();\n\t\t// 通过真实主题对象构造一个代理对象\n\t\tProxySubject proxy = new ProxySubject(real);\n\t\t// 调用代理的相关方法\n\t\tproxy.visit(); \n\t}\n}\n```\n\n#### 代理模式的简单实现\n以生活中常有的例子，老板拖欠工资甚至克扣工资的情况，而最恰当的途径就是通过法律诉讼解决问题。一旦选择走法律途径解决该纠纷，那么不可避免地需请一个律师来作为自己的诉讼代理人。\n\n便于理解，本示例的 UML 类图如图 2-33 所示。\n\n![律师作为诉讼代理人](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-33.png)\n<center>图 2-33 律师作为诉讼代理人</center>\n\n```Java\n// 诉讼接口类\npublic interface ILawsuit {\n\tvoid submit(); // 提交申请\n\tvoid burden(); // 进行举证\n\tvoid defend(); // 开始辩护\n\tvoid finish(); // 诉讼完成\n}\n\n// 具体诉讼人\npublic class XiaoMin implements ILawsuit {\n\t@Override\n\tpublic void submit() {\n\t\tSystem.out.println(\"老板拖欠工资，特此申请仲裁!\");\n\t}\n\t@Override\n\tpublic void burden() {\n\t\tSystem.out.println(\"这是合同书和过去一年的银行工资流水!\");\n\t}\n\t@Override\n\tpublic void defend() {\n\t\tSystem.out.println(\"证据确凿!\");\n\t}\n\t@Override\n\tpublic void finish() {\n\t\tSystem.out.println(\"诉讼成功!\");\n\t}\n}\n\n\n// 代理律师\npublic class Lawyer implements ILawsuit {\n\tprivate ILawsuit mLawsuit; // 持有一个具体被代理者的引用\n\t\n\tpublic Lawyer(ILawsuit lawsuit) {\n\t\tmLawsuit = lawsuit;\n\t}\n\t@Override\n\tpublic void submit() {\n\t\tmLawsuit.submit();\n\t}\n\t@Override\n\tpublic void burden() {\n\t\tmLawsuit.burden();\n\t}\n\t@Override\n\tpublic void defend() {\n\t\tmLawsuit.defend();\n\t}\n\t@Override\n\tpublic void finish() {\n\t\tmLawsuit.finish();\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\n\t\tILawsuit xiaomin = new XiaoMin();\n\t\tILawsuit lawyer = new Lawyer(xiaomin);\n\n\t\tlawyer.submit();\n\t\tlawyer.burden();\n\t\tlawyer.defend();\n\t\tlawyer.finish();\n\t}\n}\n```\n\n- 静态代理  \n\t代码由程序员自己或者通过一些自动化工具生成固定的代码再对其进行编译，即说在我们的代码运行前代理类的 Class 编译文件就已经存在。上述例子即为静态代理的实现模式。\n\n- 动态代理  \n\t通过反射机制动态地生成代理者的对象，即我们在编译阶段不需要知道代理者是谁，代理谁我们将在执行阶段决定。Java 提供了便捷的动态代理接口 InvocationHandler。  \n\t同样，以动态代理方式实现上述例子，本示例的 UML 类图如图 2-34 所示。\n\t\n![动态代理的实现案例](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-34.png)\n<center>图 2-34 动态代理的实现案例</center>\n\n```Java\npublic class DynamicProxy implements IncocationHandler {\n\tprivate Object obj; // 被代理的类引用\n\t\n\tpublic DynamicProxy(Object obj) {\n\t\tthis.obj = obj;\n\t}\n\t@Override\n\tpublic Object invoke(\n\tObject proxy, Method method, Object[] args) throws Throwable {\n\t\tObject result = method.invoke(obj, args);\n\t\treturn result;\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tILawsuit xiaomin = new XiaoMin();\n\t\tDynamicProxy proxy = new DynamicProxy(xiaomin);\n\t\t\n\t\t// 获取被代理类小民的 ClassLoader\n\t\tClassLoader loader = xiaomin.getClass().getClassLoader();\n\t\t// 动态构造一个代理者律师\n\t\tILawsuit lawyer =(ILawsuit) Proxy.newProxyInstance(loader,\n\t\t\tnew Class[] {ILawsuit.class}, proxy);\n\t\t)\n\t\t// 律师提交诉讼申请\n\t\tlawyer.submit();\n\t\t// 律师进行举证\n\t\tlawyer.burden();\n\t\t// 律师代替小民进行辩护\n\t\tlawyer.defend();\n\t\t// 完成诉讼\n\t\tlawyer.finish();\n\t}\n}\n```\n\n#### 总结\n- 代理模式的优缺点\n\t- 优点 - 代理模式可看作一种针对性优化。\n\t- 缺点 - 暂没有明显的缺点。\n\n### 组合模式\n\n#### 组合模式的介绍\n- 又称部分整体模式，结构型设计模式。\n- 它将一组相似的对象看作一个对象处理，并根据一个树状结构来组合对象，然后提供一个统一的方法去访问相应对象。\n\n\t例如公司组织结构的树状图，如图 2-35 所示。\n\n\t![公司组织结构的树状图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-35.png)\n<center>图 2-35 公司组织结构的树状图</center>\n\n\t在组合模式中，我们将这样的一个拥有分支的节点称之为枝干构件，位于树状结构顶部的枝干结构比较特殊，我们称为根结构件，因其为整个树状图的始端。同样对于像行政部和研发部这样没有分支的结构，我们称之为叶子结构，这样的一个结构就是组合模式的雏形。如图 2-36 所示。\n\n\t![组合模式的雏形](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-36.png)\n<center>图 2-36 组合模式的雏形</center>\n\n#### 组合模式的定义\n将对象组合成 `树状结构` 以表示 \"部分-整体\" 的 `层次结构`，使得用户对单个对象和组合对象的使用具有一致性。\n\n#### 组合模式的使用场景\n- 表示对象的 `部分-整体` 层次结构时。\n- 从一个整体中能够独立出部分模块或功能的场景。\n\n#### 组合模式的 UML 类图\n组合模式的 UML 类图如图 2-37 所示。\n\n![组合模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-37.png)\n<center>图 2-37 组合模式的 UML 类图</center>\n\n上述所讲与依赖倒置原则相违背，既然是面向接口编程，则我们就该把焦点放在接口设计上，即在 Composite 的一些实现方法定义到 Component 中。\n\n这样，我们会得到一个不一样的组合模式，也称为安全的组合模式，该安全组合模式的 UML 类图见图 2-38 所示。\n\n透明组合模式不管是叶子还是枝干节点都有相同的结构，那么意味着不能单一的 getChildren() 方法得到子字节的类型 (已是叶子节点)，则必须在方法实现的内部进行判断。\n\n![安全的组合模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-38.png)\n<center>图 2-38 安全的组合模式的 UML 类图</center>\n\n```Java\n// 透明的组合模式抽象根节点\npublic abstract class Component {\n\tprotected String name; // 节点\n\t\n\tpulbic Component(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\t/**\n\t * 具体的逻辑方法由子类实现\n\t */\n\tpublic abstract void doSomething();\n\t\n\t/**\n\t * 添加子节点\n\t * @child 子节点\n\t */\n\tpublic abstract void addChild(Component child);\n\t\n\t/**\n\t * 移除子节点\n\t * @child 子节点\n\t */\n\tpublic abstract void removeChild(Component child);\n\t\n\t/**\n\t * 获取子节点\n\t * @param index 子节点对应下标\n\t * @return 子节点\n\t */\n\tpublic abstract Component getChildren(int index);\n}\n\n// 透明的组合模式具体枝干节点\npublic class Composite extends Component {\n\n\t// 存储节点的容器\n\tprivate List<Component> components = new ArrayList<>();\n\t\n\tpublic Composite(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t@Override\n\tpublic void doSomething() {\n\t\tSystem.out.println(name);\n\t\tif( null != components ) {\n\t\t\tfor(Component c : components) {\n\t\t\t\tc.doSomething();\n\t\t\t}\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void addChild(Component child) {\n\t\tcomponents.add(child);\n\t}\n\t\n\t@Override\n\tpublic  void removeChild(Component child) {\n\t\tcomponents.remove(child);\n\t}\n\t\n\t@Override\n\tpublic Component getChildren(int index) {\n\t\treturn components.get(index);\n\t}\n}\n\n// 透明的组合模式叶子节点\npublic class Leaf extends Component {\n\tpublic Leaf(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t@Override\n\tpublic void doSomething() {\n\t\tSystem.out.println(name);\n\t}\n\t\n\t@Override\n\tpublic void addChild(Component child) {\n\t\tthrow new UnsupportedOperationException(\"叶子节点没有子节点\");\n\t}\n\t\n\t@Override\n\tpublic  void removeChild(Component child) {\n\t\tthrow new UnsupportedOperationException(\"叶子节点没有子节点\");\n\t}\n\t\n\t@Override\n\tpublic Component getChildren(int index) {\n\t\tthrow new UnsupportedOperationException(\"叶子节点没有子节点\");\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t// 构造一个根节点\n\t\tComponent root = new Composite(\"Root\");\n\t\t\n\t\t// 构造两个枝干节点\n\t\tComponent branch1 = new Composite(\"Branch1\");\n\t\tComponent branch2 = new Composite(\"Branch2\");\n\t\t\n\t\t// 构造两个叶子节点\n\t\tComponent leaf1 = new Leaf(\"Leaf1\");\n\t\tComponent leaf2 = new Leaf(\"Leaf2\");\n\t\t\n\t\t// 将叶子节点添加至枝干节点中\n\t\tbranch1.addChild(leaf1);\n\t\tbranch2.addChild(leaf2);\n\t\t\n\t\t//将枝干节点添加到根节点中\n\t\troot.addChild(branch1);\n\t\troot.addChild(branch2);\n\t\t\n\t\t// 执行方法\n\t\troot.doSomething();\n\t}\n}\n```\n\n#### 组合模式的简单实现\n在操作系统中，文件系统其实就是一种典型的组合模式例子。\n\n具体地，文件系统中文件就是可被具体程序执行的对象，文件夹就是可存放文件和文件夹的对象。文件系统的组合模式表示如图 2-39 所示。\n\n![文件系统的组合模式表示](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-39.png)\n<center>图 2-39 文件系统的组合模式表示</center>\n\n便于理解，本实例的 UML 类图如图 2-40 所示。\n\n![文件系统的组合模式实现](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-40.png)\n<center>图 2-40 文件系统的组合模式实现</center>\n\n```Java\n// 表示文件或文件夹的抽象类\npublic abstract class Dir {\n\t/**\n\t * 声明一个 List 成员变量存储文件夹下的所有元素\n\t */\n\tprotected List<Dir> dirs = new ArrayList<>();\n\tprivate String name; // 当前文件或文件夹的名称\n\tpublic Dir(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\t/**\n\t * 添加一个文件或文件夹\n\t * @param dir 文件或文件夹\n\t */\n\tpublic abstract void addDir(Dir dir);\n\t\n\t/**\n\t * 移除一个文件或文件夹\n\t * @param dir 文件或文件夹\n\t */\n\tpublic abstract void rmDir(Dir dir);\n\t\n\t/**\n\t * 清空文件夹下所有元素\n\t */\n\tpublic abstract void clear();\n\t\n\t/**\n\t * 输出文件夹目录结构\n\t */\n\tpublic abstract void print();\n\t\n\t/**\n\t * 获取文件夹下所有的文件或文件夹\n\t * @return 文件夹下所有的文件或文件夹\n\t */\n\tpublic abstract List<Dir> getFiles();\n\t\n\t/**\n\t * 获取文件或文件夹的名称\n\t * @return 文件或文件夹的名称\n\t */\n\tpublic String getName() {\n\t\treturn name;\n\t}\n}\n\n// 表示文件夹的类\npublic class Folder extends Dir {\n\tpublic Folder(String name) {\n\t\tsuper(name);\n\t}\n\t@Override\n\tpublic void addDir(Dir dir) {\n\t\tdirs.add(dir);\n\t}\n\t@Override\n\tpublic void rmDir(Dir dir) {\n\t\tdirs.remove(dir);\n\t}\n\t@Override\n\tpublic void clear() {\n\t\tdirs.clear();\n\t}\n\t@Override\n\tpublic void print() {\n\t\tSystem.out.println( getName() + \"(\" );\n\t\tIterator<Dir> iterator = dirs.iterator();\n\t\twhile( iterator.hasNext() ) {\n\t\t\tDir dir = iterator.next();\n\t\t\tdir.print();\n\t\t\tif( iterator.hasNext() ) {\n\t\t\t\tSystem.out.println(\",\\t\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\")\");\n\t}\n\t@Override\n\tpublic List<Dir> getFiles() {\n\t\treturn dirs;\n\t} \n}\n\n// 表示文件的类\npublic class File extends Dir {\n\tpublic File(String name) {\n\t\tsuper(name);\n\t}\n\t@Override\n\tpublic void addDir(Dir dir) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\"文件类不能作为文件夹类来使用，即文件不支持添加也不支持删除\");\n\t}\n\t@Override\n\tpublic void rmDir(Dir dir) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\"文件类不能作为文件夹类来使用，即文件不支持添加也不支持删除\");\n\t}\n\t@Override\n\tpublic void clear() {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\"文件类不能作为文件夹类来使用，即文件不支持添加也不支持删除\");\n\t}\n\t@Override\n\tpublic void print() {\n\t\tSystem.out.println(getName());\n\t}\n\t@Override\n\tpublic List<Dir> getFiles() {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\"文件类不能作为文件夹类来使用\");\n\t} \n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t// 构造一个目录对象表示 C 盘根目录\n\t\tDir diskC = new Folder(\"C\");\n\t\t\n\t\t// C 盘根目录下有一个文件 FileLog.txt\n\t\tdiskC.addDir( new File(\"Filelog.txt\") );\n\t\t\n\t\t// C 盘根目录下有3个子目录 windows、perflogs 和 Program File\n\t\tDir dirWin = new File(\"windows\");\n\t\tDir dirPerf = new File(\"perflogs\");\n\t\tDir dirProg = new File(\"Program File\");\n\t\t\n\t\t// windows 目录下有文件 explorer.exe\n\t\t// perflogs 目录下有文件 perflogs.txt\n\t\t// Program File 目录下有文件 syslogs.txt\n\t\tdirWin.addDir( new File(\"explorer.exe\") );\n\t\tdirPerf.addDir( new File(\"perflogs.txt\") );\n\t\tdirProg.addDir( new File(\"syslogs.txt\") );\n\t\t\n\t\tdiskC.add(dirWin);\n\t\tdiskC.add(dirPerf);\n\t\tdiskC.add(dirProg);\n\t\t\n\t\tdiskC.print();\n\t}\n}\n```\n\n#### 总结\n- 组合模式与解释器模式有一定的类同，两者在迭代对象时都涉及递归的调用，但组合模式所提供的属性层次结构使我们能 `一视同仁` 对待单个对象的对象集合。\n- 组合模式的优缺点\n\t- 优点  \n\t1) 清楚定义分层次的复杂对象，表示对象的全部或部分层次，让高层模块忽略了层次差异，方便对整个层次结构进行控制。  \n\t2) \u0010高层模块可一致地使用一个组合结构或其中单个对象。  \n\t3) 在组合模式中增加新的枝干结构和叶子构件很方便，无须对类库进行修改。  \n\t4) 通过叶子对象和枝干对象的递归组合，形成复杂的树形结构，但对其控制却非常简单。\n\t- 缺点  \n\t1) 新增构件时，不好对枝干中的构件类型进行限制，不能依赖类型系统来施加这些约束，因为大多数情况下他们来自相同的抽象层。  \n\t2) 因此必须进行类型检查来实现。\n\t\n### 适配器模式\n\n#### 适配器模式的介绍\n- ListView、GirdView、RecyclerView 都需要使用 Adapter。\n- 两个没有关系的类型之间交互，一种解决方法是修改各自类接口；另一种情况是使用一个 Adapter，在两种接口间创建一个 “混血儿” 接口，将两接口兼容。\n\n#### 适配器模式的定义\n把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法一起工作的两个类能一起工作。\n\n#### 适配器模式的使用场景\n- 系统需要使用现存类，而此类接口不符系统需求，即接口不兼容。\n- 需一个统一的输出接口，而输入端的类型不可预知。\n\n#### 适配器模式的 UML 类图\n适配器模式也分两种，即类适配器模式和对象适配器模式。\n\n- 类适配器模式，如图 2-41 所示。\n\n![类适配器的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-41.png)\n<center>图 2-41 类适配器的 UML 类图</center>\n\n目标接口需要的是 operation2()，而 Adaptee 对象中有一个 operation3()，因此不兼容。故通过 Adapter 实现一个 operation2() 将 Adapter 的 operation3() 转换为 Target() 需要的 operation2()。\n\n- 对象适配器模式，如图 2-42 所示。\n\n![对象适配器的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-42.png)\n<center>图 2-42 对象适配器的 UML 类图</center>\n\n这种实现方式直接将要被适配的对象传递到 Adapter 中，使用组合的形式实现接口兼容的效果。即带来的好处有，在被适配的对象中不暴露方法细节；且相对类适配器，由于继承了被适配对象，在 Adapter 类中出现一些奇怪接口。因此对象适配器模式的实现更加灵活。\n\n#### 适配器模式的简单示例\n以电源适配器为例，分别以类适配器和对象适配器模式阐述具体情况。\n\n- 5V 电压是 Target 接口。\n- 220V 电压是 Adaptee 类。\n- 将电压 220V 转换到 5V 是 Adapter 类。 \n\n```Java\n/**\n * 以类适配器模式实现\n */\n\n// Target 角色\npublic interface FiveVolt {\n\tpublic int getvolt5();\n}\n\n// Adaptee 角色，需被转换的对象\npublic class Volt220 {\n\treturn 220;\n}\n\n// Adapter 角色，将 220V 的电压转换为 5V 电压\npublic class VoltAdapter extends Volt220 implements FiveVolt {\n\t@OVerride\n\tpublic int getVolt5() {\n\t\treturn 5;\n\t}\n}\n\n// 客户端实现\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tVoltAdapter adpter = new VoltAdapter();\n\t\tSystem.out.println(输出电压：adapter.getVolt5);\n\t}\n}\n\n\n/**\n * 以对象适配器模式实现\n */\n \n // Target 角色\npublic interface FiveVolt {\n\tpublic int getvolt5();\n}\n\n// Adaptee 角色，需被转换的对象\npublic class Volt220 {\n\treturn 220;\n}\n\n// Adapter 角色，将 220V 的电压转换为 5V 电压\npublic class VoltAdapter implements FiveVolt {\n\n\tVolt220 mVolt220;\n\t\n\tpublic VoltAdapter(Volt220 adaptee) {\n\t\tmVolt220 = adaptee;\n\t}\n\t\n\tpublic int getVolt220() {\n\t\treturn mVolt220.getVolt220();\n\t}\n\t\n\t@OVerride\n\tpublic int getVolt5() {\n\t\treturn 5;\n\t}\n}\n\n// 客户端实现\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tVoltAdapter adpter = new VoltAdapter( new Volt220() );\n\t\tSystem.out.println(输出电压：adapter.getVolt5);\n\t}\n}\n```\n\n#### 总结\n- 适配器模式的优缺点\n\t- 优点  \n\t1) 更好的复用性：系统需使用现有的类，而此类的接口不符系统需求，则通过适配器模式可让这些功能得到更好的复用。  \n\t2) 更好的扩展性。  \n\t- 缺点 - 若可对系统重构，尽可能不使用适配器，过多使用适配器，容易让系统凌乱，不易整体把握。\n\n### 装饰模式\n\n#### 装饰模式的介绍\n- 又称为包装模式，结构性设计模式。\n- 使用一种对客户端透明的方式来动态地扩展对象的功能，同时它也是继承关系的一种替代方案。\n\n#### 装饰模式的定义\n动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式相比生成子类更为灵活。\n\n#### 装饰模式的使用场景\n需要透明地、动态地扩展类的功能时，装饰模式不失一种理想方案。\n\n#### 装饰模式的 UML 类图\n装饰模式的 UML 类图如图 2-43 所示。\n\n![装饰模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-43.png)\n<center>图 2-43 装饰模式的 UML 类图</center>\n\n**Component：抽象组件**  \n可以是一个接口或者抽象类，充当被装饰的原始对象。\n\n**ConcreteComponent：组件具体实现类**   \n该类是 Component 类的基本实现，也是我们装饰的具体对象。\n\n**Decorator：抽象装饰者**  \n其承担的职责是为了装饰我们的组件对象，其内部一定要有一个指向组件对象的引用。\n\n**ConcreteDecorator：抽象装饰者**  \n对抽象装饰者做出具体实现。\n\n```Java\n// 抽象组件类\npublic abstract class Component {\n\t/**\n\t * 抽象的方法：自由增加你需要的抽象方法\n\t */\n\tpublic abstract void operate();\n}\n\n// 组件具体实现类\npublic class ConcreteComponent extends Component {\n\t@Override\n\tpublic void operate() {\n\t\t// 忽略实现细节\n\t}\n}\n\n// 抽象装饰者\npublic abstract class Decorator extends Component {\n\tprivate Component component; // 持有一个 Component 对象的引用\n\t\n\t/**\n\t * 必要的构造方法，需要一个 Component 类型的对象\n\t * @param component Component 对象\n\t */\n\tpublic Decorator(Component component) {\n\t\tthis.component = component;\n\t}\n\t\n\t@Override\n\tpublic void operate() {\n\t\tcomponent.operate();\n\t}\n}\n\n// 装饰者具体实现类\npublic class ConcreteDecoratorA extends Decorator {\n\tprotected ConcreteDecoratorA(Component component) {\n\t\tsuper(component);\n\t}\n\t@Override\n\tpublic void operate() {\n\t\toperateA();\n\t\tsuper.operate();\n\t\toperateB();\n\t}\n\t\n\tpublic void operateA() { // 自定义的装饰方法 A\n\t\t// 装饰方法逻辑\n\t}\n\tpublic void operateB() { // 自定义的装饰方法 B\n\t\t// 装饰方法逻辑\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\n\t\t// 构造被装饰的组件对象\n\t\tComponent component = new ConcreteComponent();\n\t\t\n\t\t// 根据组件对象构造装饰者对象并调用，即给组件对象增加装饰者的功能方法\n\t\tDecorator.decoratorA = new ConcreteDecoratorA(component);\n\t\tdecoratorA.operate();\n\t\t\n\t\tDecorator.decoratorB = new ConcreteDecoratorB(component);\n\t\tdecoratorB.operate();\n\t}\t\n}\n```\n\n#### 装饰模式实战\n其实装饰模式并不复杂，也不陌生，它就是一种 `类间的封装`，例如我们常在 Activity 的 onCreate() 方法中做一些相关的初始化操作。\n\n```Java\npublic class DecoratorActivity extends Activity {\n\t@Override\n\tprotected void onCreate(Bundle saveInstanceState) {\n\t\tsuper.onCreate(saveInstanceState);\n\t\t\n\t\tinitViews();\n\t\tfindViews();\n\t\tsetListeners();\n\t}\n\t\n\tprivate void initViews() {\n\t\tsetContentView(R.layout.activity_main);\n\t}\n\tprivate void findViews() {\n\t\t// 匹配组件\n\t}\n\tprivate void setListeners() {\n\t\t// 设置组件的监听器\n\t}\n}\n```\n\n#### 总结\n- 装饰模式与代理模式的区别 (容易混淆)\n\t- 装饰模式：以对客户端透明的方式 `扩展对象的功能`，即继承关系的一个替代方案。\n\t- 代理模式：给一个对象提供一个代理对象，并由 `代理对象` 来控制对原有对象引用。 \n\n\t> 代理模式，即对代理的对象施加控制。\n\n### 享元模式\n\n#### 享元模式的介绍\n- 又称 FlyWeight，代表轻量级的意思，结构型设计模式。\n- `对象池` 的一种实现。\n- 享元模式用来是尽可能减少内存使用量，它适用于可能存在大量重复对象的场景。  \n\t\n\t> 目的：缓存可共享的对象，达到对象共享，避免过多创建对象，即提升性能、避免内存移除。\n- 享元对象\n\t- 内存状态：可共享，不随环境变化\n\t- 外部状态：不可共享，随环境变化\n\t- 对象容器：在经典的享元模式中，对象容器为一 Map，它的 `键` 是享元对象的`内部状态`，它的 `值` 是 `享元对象本身`。\n- 客户端通过这个内部状态从享元工厂中获取享元对象，若有缓存则使用缓存对象，否则创建一个享元对象并存入容器中。\n\n#### 享元模式的定义\n使用共享对象可有效地支持大量的细粒度的对象。\n\n#### 享元模式的使用场景\n- 系统中存在大量的 `相似对象`。\n- 细粒度的对象都具备较接近的外部状态，且内部状态与环境无关，即对象没有特定身份。\n- 需要 `缓冲池` 的场景。\n\n#### 享元模式的 UML 类图\n享元模式的 UML 类图如图 2-44 所示。\n\n![享元模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-44.png)\n<center>图 2-44 享元模式的 UML 类图</center>\n\n#### 享元模式的简单示例\n例1. 过年回家买火车票，无数人在客户端上订票 (有多次购票、刷票的情况)，即不断向服务端发送请求。\n\n而每次查询，服务器必须做出回应，具体地，用户查询输入出发地和目的地，查询结构返回值只有一趟列车的车票。而数以万计的人有同样需求，即不间断请求数据，每次重新创建一个查询的车票结果，即造成大量重复对象创建、销毁，使得服务器压力加重。\n\n享元模式正好适合解决该情形的问题，例如 A 到 B 地的车辆是有限的，车上铺位分硬卧、软卧和坐票三种，将这些可公用的对象缓存起来。用户查询时优先使用缓存，反之则重新创建。\n\n便于理解，本示例的 UML 类图如图 2-45 所示。\n\n![网上订票系统的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-45.png)\n<center>图 2-45 网上订票系统的 UML 类图</center>\n\n```Java\npublic interface Ticket {\n\tpublic void showTicketInfo(String bunk);\n}\n\n// 火车票\npublic class TrainTicket implements Ticket {\n\tpublic String from; // 始发地\n\tpublic String to; // 目的地\n\tpublic String bunk; // 铺位\n\t\n\tTrainTicket(String from, String to) {\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t}\n\t\n\t@Override\n\tpublic void showTicketInfo(String bunk) {\n\t\tprice = new Random().nextInt(300);\n\t\tSystem.out.println(\"From:\" + from\n\t\t\t+ \"To:\" + to\n\t\t\t+ \"Bunk:\" + bunk\n\t\t\t+ \"Price:\" + price);\n\t}\n}\n\npublic class TicketFactory {\n\tstatic Map<String, Ticket> sTicketMap = \n\t\tnew ConcurrentHashMap<String, Ticket>();\n\t\t\n\tpublic static Ticket getTicket(String from, String to) {\n\t\tString key = from + \"-\" + to;\n\t\t\n\t\tif( sTicketMap.containsKey(key) ) { // 使用缓存\n\t\t\treturn sTicketMap.get(key);\n\t\t} else { // 创建对象\n\t\t\tTicket ticket = new TrainTicket(from, to);\n\t\t\tsTicketMap.put(key, ticket);\n\t\t\treturn ticket;\n\t\t}\n\t}\n}\n```\n\n例2. 我们知道 Java 中 String 是存在于常量池中，即一个 String 被定义之后它就被缓存到了常量池中，当其他地方使用同样的字符串，则直接使用缓存，而非创建。\n\n```Java\npublic void testString() {\n\tString str1 = \"Hello World\";\n\tString str2 = new String(\"Hello World\");\n\tString str3 = \"Hello \" + \"World\";\n\t\n\tSystem.out.println( \"\\nStr1 - Str3: \" + str1.equals(str3)\n\t\t+  \"\\nStr2 - Str3: \" + str2.equals(str3)\n\t\t+  \"\\nStr1 - Str2: \" + str1.equals(str1));\n\n\t// 输出的结果分别是：true，false，false\n}\n```\n\n#### 总结\n- 享元模式的优缺点\n\t- 优点 - 大幅度地降低内存中对象的数量。\n\t- 缺点  \n\t1) 为了使对象可共享，需将一些状态外部化，使程序的逻辑复杂化。  \n\t2) 将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。  \n\n### 外观模式\n\n#### 外观模式的介绍\n- 又称门面模式 (Facade模式)，结构型设计模式。\n- 通过一个外观类使得整个系统中接口只有一个 `统一的高层接口`，即这样降低用户使用成本，也对用户屏蔽了很多实现细节。\n- 外观模式是 `封装API` 的常用手段。\n\n#### 外观模式的定义\n- 要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。\n- 外观模式提供一个高层次接口，使得子系统更易于使用。\n\n#### 外观模式的使用场景\n- 为一个复杂的子系统提供一个简单接口。\n\n\t> 对于系统进行定制、修改，这种易变性，使得隐藏子系统的具体实现变得尤为重要，对外隐藏子系统的具体实现，隔离变化。\n- 构建一层次结构的子系统，子系统间相互依赖，则通过 Facade 接口进行通信，从而简化他们的依赖关系。\n\n#### 外观模式的 UML 类图\n外观模式的 UML 类图如图 2-46 所示。\n\n![外观模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-46.png)\n<center>图 2-46 外观模式的 UML 类图</center>\n\n#### 总结\n- 外观模式的精髓在于 `封装`。通过一高层次结构为用户提供统一的 API 入口，使得用户通过一个类就基本能够操作整个系统。\n- 外观模式的优缺点\n\t- 优点  \n\t1) 对客户端隐藏子系统细节，因而减少客户对于子系统的耦合。  \n\t2) 外观类对子系统的接口封装，使得系统更易于使用。  \n\t- 缺点  \n\t1) 外观类没有遵循开闭原则，当业务出现变更时，可能需要直接修改外观类。\n\n### 桥接模式\n\n#### 桥接模式的介绍\n- 又称桥梁模式，结构型设计模式。\n- 承接者连接 `两边` 的作用，两边指抽象部分和实现部分。\n\n#### 桥接模式的定义\n将 `抽象部分` 和 `实现部分` 分离，使它们都可以独立地进行变化。\n\n#### 桥接模式的使用场景\n- 对于不希望使用继承或因多层次继承导致系统类的个数急剧增加的系统，考虑使用桥接模式。\n- 需要在构件的抽象化角色和具体角色之间增加更多灵活性，避免两层次间建立静态的继承关系，可通过桥接模式使它们在抽象层建立一个关联关系。\n- 一个类存在两个独立变化的维度，且这两个维度都需进行扩展。\n- 任何多维度变化类或多个树状类之间的耦合可通过桥接模式解耦。\n\n#### 桥接模式的 UML 类图\n桥接模式的 UML 类图如图 2-47 所示。\n\n![桥接模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-47.png)\n<center>图 2-47 桥接模式的 UML 类图</center>\n\n**Abstraction：抽象部分**  \n该类保持一个对实现部分对象的引用，抽象部分中的方法需要调用实现部分的对象来实现。该类一般为抽象类。\n\n**RefinedAbstraction：优化的抽象部分**  \n抽象部分的具体实现，该类一般是对抽象部分的方法进行完善和扩展。\n\n**Implementor：实现部分**  \n可以为接口或抽象类，其方法不一定要与抽象部分中的一致，一般情况下是由实现部分提供基本的操作，而抽象部分定义的则是基于实现部分这些基本操作的业务方法。\n\n**ConcreteImplementorA/B：实现部分的具体实现**  \n完成实现部分中定义的具体逻辑。\n\n```Java\n// 实现部分的抽象接口\npublic interface Implementor {\n\t/**\n\t * 实现抽象部分的具体方法\n\t */\n\tpublic void operationImpl();\n}\n\n// 实现部分具体的实现\npublic class ConcreteImplementorA implements Implementor {\n\t@Override\n\tpublic void operationImpl() {\n\t\t// 忽略实现逻辑\n\t}\n}\n\n// 抽象部分\npublic abstract class Abstraction {\n\t// 声明一私有成员变量引用实现部分的对象\n\tprivate Implementor mImplementor; \n\t\n\t/**\n\t * 通过实现部分对象的引用构造抽象部分的对象\n\t * @param implementor 实现部分对象的引用\n\t */\n\tpublic Abstraction(Implementor implementor) {\n\t\tmImplementor = implementor;\n\t}\n\t\n\t/**\n\t * 通过调用实现部分具体的方法实现具体的功能\n\t */\n\tpublic void operation() {\n\t\tmImplementor.operationImpl();\n\t}\t\n}\n\n// 优化的抽象部分\npublic class RefinedAbstraction extends Abstraction {\n\tpublic RefinedAbstraction(Implementor implementor) {\n\t\tsuper(implementor);\n\t}\n\t\n\t/**\n\t * 对 Abstraction 中的方法进行扩展\n\t */\n\tpublic void refinedOperation() {\n\t\t// 忽略实现逻辑\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tRefinedAbstraction abstration = \n\t\t\tnew RefinedAbstraction( new ConcreteImplementorA );\n\t\t\t\n\t\tabstraction.operation();\n\t\tabstraction.refinedOperation();\n\t}\n}\n```\n\n#### 桥接模式实战\nView 的视图层级与执行真正的硬件绘制相关类之间的关系可看作是一种桥接模式。即模仿这种行为，我们可自定义控件以桥接的方式提供多种不同的实现机制。\n\n以进度条为例，我们可继承 View 类来实现进度条控件，自定义水平、垂直和圆形等不同形式的进度条。\n\n便于理解，本示例的 UML 类图如图 2-48 所示。\n\n![进度条框架的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-48.png)\n<center>图 2-48 进度条框架的 UML 类图</center>\n\n#### 总结\n桥接模式，分离抽象与实现，其优点毋庸置疑，即灵活的扩展以及对客户来说透明的是实现。但不足之处在于运用桥接模式进行设计，是有一定难度的，需多加推敲与研究。\n\n## 叁 MVC 与 MVP 模式\n\n### MVC\n- 模型 - 视图 - 控制器 (Model - View - Controller，MVC)，是一种 `框架模式` ，而非设计模式。\n\n\t> GOF 把 MVC 看作3种设计模式，即观察者模式、策略模式与组合模式的合体，也就是一个基于 `发布/订阅者模型` 的框架。\n- 软件开发领域的3种级别重用：\n\t- 内部重用：同一应用中能公共使用的抽象块。\n\t- 代码重用：将通用模块组合成库或工具集，以便在多个应用和领域都能使用。\n\t- 应用框架重用：为专用领域提供通用的或者现成的基础结构，以获得最高级别的重用性。\n\n\t> 平时开发过程中，常见的框架模式除了 MVC 外，还有 MVVC、MTV、CBD、ORM 和 MVP。\n- MVC 模式的优缺点\n\t- 优点 - 表现层与业务层分离实现，各司其职。若在实际项目中，即前端工程师专注界面的研发，后端工程师致力于业务逻辑。\n\t- 缺点：  \n\t1) Model 和 View 严格分离，在调试应用程序时较困难。  \n\t2) 小规模项目，采用 MVC 模式反而显得工序更加繁琐。  \n\t\n### MVP\n- 数据的存取 - 用户界面 - 交互中间人 (Model - View - Presenter，MVP)，分离显示层和逻辑层，它们之间通过接口进行通信，降低耦合。\n\n- MVP 模式的三个角色\n\t- **Presenter：交互中间人**  \n\tView 和 Model 沟通的桥梁。它从 Model 层检索数据后，返回给 View 层，使得 View 和 Model 之间没有耦合，也将业务逻辑从 View 角色上抽离。\n\t\n\t- **View：用户界面**  \n\t在 Android 中，通常指 Activity、Fragment 或某个 View 控件，它含有一个 Presenter 成员变量，且 View 需实现以逻辑接口。将 View 上操作通过转交给 Presenter 实现，最后 Presenter 调用 View 逻辑接口将结果返回给 View。 \n\t \n\t- **Model：数据的存取**  \n\t主要提供数据的存取功能。Presenter 需通过 Model 层存储、获取数据。\n\n![MVP模式的三个角色](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_3-1.png)\n<center>图 3-1 MVP模式的三个角色</center>\n\n- 与 MVC 模式的区别\n\t- MVC 特点  \n\t1) 用户可向 View 发送指令，再由 View 直接要求 Model 改变状态。  \n\t2) 用户可向 Controller 发送指令，再由 Controller 发送给 View。  \n\t3) Controller 起到时间路由的作用，同时业务逻辑都部署在 Controller 中。  \n\n\t> View 可直接访问 Model，即 MVC 模式的耦合性还是相对较高的。\n\t\n![MVC模式的三个角色](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_3-2.png)\n<center>图 3-2 MVC模式的三个角色</center>","tags":["设计模式"],"categories":["Reading"]},{"title":"项目 | 基于 Hexo 框架在 Github 上搭建博客","url":"/2018/01/Hexo-Installation-Guide.html","content":"\n## 序言\n\nHexo\\\\(^{[1]}\\\\)，一个快速、简洁且高效的博客框架，若以个人博文为主导需求，它的强大毋庸置疑。    \n\nHexo 支持 GitHub Flavored Markdown 的所有功能；且基于 Node.Js 所带来的超快生成速度，百页博文秒级渲染；开放性 API 以及丰富的插件等，即功能来得纯粹，不失个性化定制，上手容易且操作便捷。更重要的一点，它是开源的、免费的博客框架，数据保存在本地以及 Github 上，相信在众多博客产品中选择、博弈，相信 Hexo 的表现不会令你失望。\n\n对于 Hexo 的安装、使用教程尽量遵照官方使用文档的流程操作，而本文则将侧重于 Hexo 的优化体验、实用插件等方面的内容分享。\n\n若想了解详情可访问「[hexo.io](https://hexo.io/)」。\n\n<!-- more -->\n\n## 壹 搭建环境\n\n- Mac OS、Windows 环境下的配置流程和步骤大同小异，而搭建环境的大致流程为：  \n - Git 环境配置 ( Windows )\n - Node.Js 环境配置\n - Github 账号注册和配置\n - Hexo 的安装和配置\n- 考虑到是流程操作类的文章，为简单起见，则我们以 MacOS 和 Windows 版本分别说明情况：\n - [MacOS 版本](#MacOS-版本)\n - [Windows 版本](#Windows-版本)\n\n\n### MacOS 版本\n#### 配置环境\n\n-  Xcode: Hexo的编译依赖于 Xcode\n - Xcode 可自行到 Apple App Store 下载\n-  Node.Js: Hexo 是基于 Node.Js 开发的\n - [官方下载](https://nodejs.org/)\n - 本地安装，文件包为「Node-Vx.x.x.pkg」\n - 检测是否安装成功，当然返回版本信息即成功安装\n\n\t```bash\n\t# 终端下输入命令:  \n\tnode -v  \n\tnpm -v\n\t```\n \n- Github Account ( **已有账号、项目可忽略** )\n - 注册账号「[GitHub](https://github.com/)」\n - 创建代码库 \n\n\t> 具体操作步骤:  \n\t> 1. Add ( 右上角「+」图标 ) > New Repository；  \n\t> 2. Repository Name，填写`yourname.github.io`；        \n\t> 3. Repository Description，填写`简单描述`；\n \n - 配置代码库\n \n\t> 具体操作步骤:  \n\t> 1. 进入项目「yourname.github.io」；  \n\t> 2. Settings > GitHub Pages，开启`GH-Pages`功能；  \n\t> 3. 点击「Launch Automatic Page Generator」；\n\n\t> 第三步说明:  \n\t> Github 将会自动替你创建出一个 GH-Pages 的页面。若配置没有问题，约15分钟后，yourname.github.io 就可以正常访问了，配置结束。\n\t\n#### 安装 HEXO\n##### 安装 HEXO\n- 本地选择安装目录\n \n ```bash\n cd your-hexo-site \n ```\n\n- 在线安装 HEXO ( [NPM淘宝源](http://npm.taobao.org/) )\n\n ```bash\n npm install hexo-cli -g  \n hexo init  \n hexo install\n ```\n\t\t\n- 检测是否安装成功，当然返回版本信息即成功安装\n \n ```bash\n hexo -v\n ```\n \n##### 运作 HEXO \n- 本地运作 HEXO\n\n ```bash\n hexo server\t# 或简写 hexo s\n ```\n\n- 当终端提示以下信息，则本地配置工作基本完成。\n\n\t> Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.\n\n##### 使用 HEXO\n\n> [注意] 此项操作，需要确保在 Hexo 安装目录下执行。\n\n- 新建一篇博文 ( 当然，更新过往的文章只需修改「Hexo > Source > _Posts」目录下相应的 MarkDown 文件 )\n\n ```bash\n hexo new post \"Article Title\"\n ```\n\t\n- 生成博文 ( 生成静态网页 )\n \n ```bash\n hexo generate\n ```\n\n##### 部署至 GitHub\n- 部署至 Git 的准备工作\n \n ```bash\n # 在部署前，还需要安装「Git部署插件」:  \n npm install hexo-deployer-git --save\n \n # 若没有安装该插件，会出现情况：\n # deloyer not found:git\n ```\n \n- 再者，与 Github 连接前需要获得授权，不然会出现以下情况 ( 本机没有配置 Public Key ):\n     \n\t> Permission denied (publickey).  \n\t> fatal: Could not read from remote repository.  \n\t> Please make sure you have the correct access rights and the repository exists.\n\t\n- 配置「SSH KEY / Public KEY」\n\n\t> [注意] 若之前机器上配置了 Git 的信息，请跳过该步骤。\n   \n\t```bash\n\t# 1. 配置 Git 的 UserName 和 Email \n\t# “YourAnonymousName\"，可以替换成自己的用户名   \n\tgit config --global user.name \"YourAnonymousName\"  \n\t# \"UserName@xxx.com\"，替换成自己的邮箱  \n\tgit config --global user.email \"UserName@xxx.com\"  \n\t\n\t# 2. 检查是否已经有 SSH KEY\t \n\t# Step01. 列出该目录下的文件；\n\t# Step02. 看是否存在「id_isa」和「id_isa.pub」文件；\n\tcd ~/.ssh\n\tls\n\t \n\t# Step03. 若存在则跳过，没有则执行此步骤「生成密钥」.\n\t# 邮箱「UserName@xxx.com」替换成自己的邮箱\n\tssh-keygen -t rsa -C \"UserName@xxx.com\"\n\t\t\n\t# 3. 登陆 Github, 添加 SSH KEY\n\t# Step01. Avatar(头像) > Settings > Personal Settings > SSH and GPG keys； \n\t# Step02. New SSH KEY，把「id_isa.pub」的密钥粘贴过去即可.  \n\t \n\t# 4. 测试是否配置成功\t\n\tssh -T git@github.com\n\t# 提示「Hi YourName! You've successfully authenticated, but GitHub does not provide shell. access.」即成功配置。\n\t```\n\n- 配置「_config.yml」文件  \n\n - 在 Hexo 安装目录下找到 _config.yml 文件，如「~/你的安装目录/Hexo/_config.yml」。找到「deploy」字段，修改配置。\n\n\t > deploy:  \n\t > type: git  \n\t > repo: https://github.com/yourname/yourname.github.io.git  \n\t > branch: master  \n\n - 注意: 冒号后面含一个空格；使用 Github 不用 branch 字段；若使用多个 deployer，则有：\n\t\n\t ```bash\n\t deploy:\n\t - type: git\n\t repo:\n\t - type: heroku \n\t repo:\n\t ```\n\n- 部署至 Git\n \n\t```bash\n\thexo deploy\t  \n\thexo d -g\t# 即在部署之前先生成\n\t```\n\n### Windows 版本\n#### 配置环境\n\n> Github 账号注册和配置和 Hexo 的安装和配置，在 Windows 与 MacOS 上是通用的。因此，在 Windows 版本中，主要阐述 Node.Js和 Git 的安装和配置即可。\n\n- Node.Js 的安装和准备\n - 下载并安装「[Node.Js for Windows x86/x64 bit](https://nodejs.org/en/download/)」\n - 检测是否安装成功，当然返回版本信息即成功安装\n\n\t```bash  \n\tnode -v  \n\tnpm -v\n\t```\n\t\n- Git 的安装和准备\n - 下载并安装「[Git for Windows x86/x64 bit](https://git-scm.com/download/win)」\n - 检测是否安装成功，当然返回版本信息即成功安装\n\n\t```bash \n\tgit --version\n\t```\n\n## 贰 优化拓展\t\n至此，Hexo 的安装以及 GitHub 的配置工作暂告一段落。能正常运行使用 Hexo 是没问题的，而下面的章节则是对 Hexo 的扩展和个性化定制，根据自己的需求挑选阅读、实践。\n\n### 套用一款主题\n\nHexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。\n\n在 Hexo 中有两份主要的配置文件，其名称都是「_config.yml」。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。\n\n为了描述方便，在以下说明中，将前者称为「`站点配置文件`」， 后者称为「`主题配置文件`」。\n\n具体以 NexT\\\\(^{[2]}\\\\) 为例说明，安装步骤如下。\n\n#### 下载主题  \n\n如果你熟悉 Git， 建议你使用`克隆最新版本`的方式，之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。\n\n```bash\n# 克隆最新版本\ncd your-hexo-site  \ngit clone https://github.com/iissnan/hexo-theme-next. themes/next\n\n# 快速更新\ncd themes/next\ngit pull\n```\n\n#### 启用主题  \n- 与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到`theme`字段，并将其值更改为`next`。\n \n\t> theme: next\n\n- 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。\n \n\t```bash\n \thexo clean\n\t```\n\t\n#### 主题设定\n- 选择 Scheme\n\n Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：\n \n - Muse - 默认 Scheme，黑白主调，大量留白  \n - Mist - Muse 的紧凑版本，整洁有序的单栏外观  \n - Pisces - 双栏 Scheme，小家碧玉似的清新  \n\n\t```bash\n\t#scheme: Muse\n\t#scheme: Mist\n\tscheme: Pisces\n\t```\n\n\t> Scheme 的切换通过更改`主题配置文件`，搜索「scheme」关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。\n\t\n- 设置语言\n\n\t编辑`站点配置文件`， 将`language`设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下 ( 更多请语言配置请参考下述表格 )：\n \n\t> language: zh-Hans  \n\n| 语言 | 代码 | 设定示例 |\n| :---- | :---- | :---- |\n| English | en | language: en |\n| 简体中文 | zh-Hans\t| language: zh-Hans |\n| Français | fr-FR | language: fr-FR |\n| Português | pt | language: pt or pt-BR |\n| 繁體中文 | zh-hk | language: zh-hk |\n| Русский\t | язык\tru | language: ru |\n| Deutsch | de | language: de |\n| 日本語 | ja | language: ja |\n| Indonesian | id | language: id |\n| Korean | ko | language: ko |\n\n- 设置菜单\n\n\t菜单配置包括三个部分，第一是菜单项 ( 名称和链接 )，第二是菜单项的显示文本，第三是菜单项对应的图标。\n \n\tNexT 使用的是 [Font Awesome](http://fontawesome.io/)\\\\(^{[3]}\\\\) 提供的图标，600+ 的图标可满足大部分需求，且适配 Retina 屏幕。\n \n\t编辑`主题配置文件`，修改以下内容：\n \n \t{% note warning %} 请注意键值（如 home）的大小写要严格匹配。 {% endnote %}\n \n - 设定菜单内容，对应的字段是`menu`，菜单内容的设置格式是：`item name: link`。其中`item name`是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。\n\n\t ```bash\n\t menu:\n\t home: /\n\t archives: /archives\n\t #about: /about\n\t #categories: /categories\n\t tags: /tags\n\t #commonweal: /404.html\n\t \n\t # 若你的站点运行在子目录中，请将链接前缀的/去掉\n\t ```\n\n\t NexT 默认的菜单项有( 标注 `*` 的项表示需要手动创建这个页面 )：\n\n| 键值 | 设定值| 显示文本(简体中文) | \n| :--- | :--- | :--- |  \n| home | home: / | 主页 |  \n| archives | archives: /archives | 归档页 |  \n| categories | categories: /categories | 分类页 `*` |  \n| tags | tags: /tags | 标签页 `*` |  \n| about | about: /about | \t关于页面 `*` |  \n| commonweal | commonweal: /404.html\t | 公益 404 `*` |  \n\t\n - 设置菜单项的显示文本，在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用这个名称查找对应的语言翻译，并提取显示文本。\n \n\t 这些翻译文本放置在 NexT 主题目录下的`languages/{language}.yml` （ {language} 为你所使用的语言 )。\n\n\t 以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件`languages/zh-Hans.yml`，在`menu`字段下添加一项：\n\t \n\t ```bash\n\t menu:\n\t home: 首页\n\t archives: 归档\n\t categories: 分类\n\t tags: 标签\n\t about: 关于\n\t search: 搜索\n\t commonweal: 404\n\t something: 有料\n\t ```\n\n - 设定菜单项的图标，对应的字段是`menu_icons`。\n \n\t ```bash\n\t menu_icons:\n\t enable: true\n\t # Icon Mapping.\n\t home: home\n\t about: user\n\t categories: th\n\t tags: tags\n\t archives: archive\n\t commonweal: heartbeat\n\t \n\t #  此设定格式是「item name: icon name」\n\t # 「item name」与上一步所配置的菜单名字对应\n\t # 「icon name」是 Font Awesome 图标的名字\n\t # 「enable」用于控制是否显示图标，你可以设置成「false」来去掉图标\n\t ```\n\t  \n- 设置侧栏 \n\n\t可以通过修改`主题配置文件`中的`sidebar`字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。\n \n - 设置侧栏的位置，修改 sidebar.position 的值，支持的选项有：\n \n\t > left - 靠左放置  \n\t > right - 靠右放置  \n\n\t 目前仅 Pisces Scheme 支持 position 配置。影响版本5.0.0及更低版本。\n\n\t ```bash\n\t sidebar:  \n\t position: left\n\t ```\n\n - 设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有：\n\n\t > post - 默认行为，在文章页面（ 拥有目录列表 ）时显示  \n\t > always - 在所有页面中都显示  \n\t > hide - 在所有页面中都隐藏（ 可以手动展开 ）  \n\t > remove - 完全移除  \n\n\t ```bash\n\t sidebar:\n\t display: post\n\t ```\n\n\t 已知侧栏在 use motion: false 的情况下不会展示。影响版本5.0.0及更低版本。\n\t\n- 设置头像\n\n\t编辑`主题配置文件`， 修改字段`avatar`，值设置成头像的链接地址。其中，头像的链接地址可以是：\n \n - 站外链接\n \n\t > avatar: http://example.com/avatar.png\n\t\n - 站内资源 \n\n\t > 放置在「source/images/」目录下，images 为自建目录   \n\t > avatar: avatar: /images/avatar.png\n\t\n### 揽收实用插件\n\n## 叁 参考资料\n\n[[1] HexoJs. 使用文档. 2018](https://hexo.io/docs/)  \n[[2] NexT. 使用文档. 2018](http://theme-next.iissnan.com/getting-started.html)  \n[[3] Dave Gandy. Font Awesome Accessibility](http://fontawesome.io/accessibility/)  \n[[4] 徐俊. 手把手教你搭建属于自己的博客. CSDN. 2017](http://blog.csdn.net/gdutxiaoxu/article/details/53576018) ","tags":["hexo"],"categories":["Project"]},{"title":"笔记 | Java 入门系列教程 | Java In a Nutshell ( Awsome Docs )","url":"/2017/09/Java-in-a-Nutshell.html","content":"\n## 序言\n\n由于对图灵出品的 O'Reilly 动物书情有独钟，至此本篇文章以动物书系列之 [Java 技术手册](https://book.douban.com/subject/26674131/) 为主要框架，开启我的 Java 语言学习旅程。\n\n当然，通读一遍本书之后，你会发现本书对 Java 基础知识部分的讲述一定是有所欠缺的，所以课后补充工作很有必要。如通过参考其他 Java 书籍（下文中有参考书目推荐）、优秀博文的补充，核心需求就是要输出一份便于常翻阅、可复用的读书笔记、学习笔记。\n\n需要说明的是，笔记当中会包含实际项目当中深入了解、研究的知识点，如 Class 类文件结构、Java 范型等。既经由分析、解决、随之文档化的过程，这不仅仅可作为自己的案例库，也可用于分享、交流。毕竟自身的知识面是非常有限的，有不恰当之处、不正确的地方，欢迎广大朋友的帮忙、斧正，互为补足。\n\n<!-- more -->\n\n- 参考书目\n\n > 基础篇\n\t\n - 《 Java 技术手册 》:  O'Reilly 动物书系列，因本书籍不会刻意去阐述面向对象编程（Object Oriented Programming，OOP）的相关概念、内容，适合对 OOP、Java 编程语言有一定了解后，所使用的学习材料。\n \n > 进阶篇\n \n - 《 Java编程思想 / Thinking in Java 》：待阅读。贴上本书豆瓣的书评，供朋友评判，做出抉择。[TIJ(中文第四版)](https://book.douban.com/subject/2130190/) | [TIJ(英文第四版)](https://book.douban.com/subject/2061172/)\n\n- 优秀博文 (主要的采集源：Guihub、CSDN)\n\t- [ 索引 - 小土刀. Java 资源索引. 2012. wdxtub.com](http://wdxtub.com/2012/09/11/awesome-java/) \n\t- [ 索引 - Akullpp. Awsome Java. 2018. github.com](https://github.com/akullpp/awesome-java)\n\t- [ 规范 - BlankJ. Java / Android 开发规范. 2017. github.com](https://github.com/Blankj/AndroidStandardDevelop)\n\t- [ API - BieZhi. 30 Seconds Of Java8. 2018. github.com](https://github.com/biezhi/30-seconds-of-java8)\n \n- 开源项目\n\t- [ BieZhi. Awesome Java Leetcode. 2018. github.com](https://github.com/Blankj/awesome-java-leetcode)\n\n\t> 转载自 BieZhi，学习数据结构和算法或打算刷 LeetCode 的伙伴们推荐阅读。\n\n\t- [ CTOlib. Java 实战类库与框架. 2018. ctolib.com](https://www.ctolib.com/java/categoriesallsub.html)\n\n- 更新进程\n\t- 2017.09.01 - 整理 Notes 草稿；\n\t- 2017.09.14 - 输出 Markdown 文档；  \n\t- 2018.01.30 - 完成序言；\n\t- 2018.03.20 - 更新正文 (共 10 章)；\n\t- 2018.04.30 - 更新完毕.\n\n## 总览\n\n- [壹 Java 环境介绍](#壹-Java-环境介绍)  \n- [贰 Java 基本句法](#贰-Java-基本句法)\n- [叁 Java 面向对象编程](#叁-Java-面向对象编程)\n- [肆 Java 类型系统](#肆-Java-类型系统)  \n- [伍 Java 的面向对象设计](#伍-Java-的面向对象设计)  \n- [陆 Java 实现内存管理和并发编程的方式](#陆-Java-实现内存管理和并发编程的方式)  \n- [柒 编程和文档约定](#柒-编程和文档约定)  \n- [捌 使用 Java 集合](#捌-使用-Java-集合)  \n- [玖 处理常见的数据格式](#玖-处理常见的数据格式)  \n- [拾 处理文件和 I/O](#拾-处理文件和-I-O)  \n- [拾壹 类加载、反射和方法句柄](#拾壹-类加载、反射和方法句柄)  \n\n## 壹 Java 环境介绍\n\n### JVM - 程序、环境\n- Java 虚拟机 (Java Virtual Machine，JVM)。\n- JVM 是一个程序，提供运行 Java 程序所需的运行时环境。\n- 应用代码的容器。\n- 提供一个安全、跨平台的执行环境。\n- Java 源码 -> Java 字节码 (*.class) -> JVM (即字节码格式程序的解码器，即图 1-1 中的解释器)。\n\n### Java 程序的生命周期\n\n- Java 代码的编译和加载\n\n\t整个流程从 Java 源码开始，经过 Javac 程序处理后得到类文件，类文件保存的是编译源码后得到的 Java 字节码。类文件是 Java 平台能处理的最小功能单位，也是把新代码传给运行中程序的唯一方式。\n\n\t新的类文件通过类加载机制载入虚拟机，从而把新类型提供给解释器执行。\n\n\tJava 代码的编译和加载过程，如图 1-1 所示。\n\n![Java代码的编译和加载过程](/images/illustration/Programme/2017/09/Java_in_a_Nutshell_1-1.png)\n<center>图 1-1 Java 代码的编译和加载过程</center>\n\n- 其中，涉及了 `机器码` 与 `字节码` 的概念\n\n\t- 机器码 (Machine Code)，学名机器语言指令，有时也被称为原生码（Native Code），是电脑的CPU可直接解读的数据。  \n\t通常意义上来理解的话，机器码就是计算机可以直接执行，并且执行速度最快的代码。\n\t\n\t- 字节码 (Bytecode)，是一种包含执行程序、由一序列 `数据对` 组成的二进制文件。字节码是一种中间码，它比机器码更抽象，需要直译器转译后才能成为机器码的中间代码。  \n\t通常情况下字节码通常不像源码一样可以让人阅读，而是编码后的数值常量、引用、指令等构成的序列。\n\t   \n\t\t- 关于 `字节码文件`，即 Class 类文件，根据Java虚拟机规范的规定，Class 文件格式采用一种类似于 C 语言结构体的伪结构表示，如下述代码所示。    \n\t\t若想了解更多 Class 文件结构的内容，可参考周志明老师写的《深入理解Java虚拟机》\\\\(^{[1]}\\\\)，其中有对 Class 文件结构的详细介绍。  \n\t\t- 延伸：其实每种类型的文件的头都有着 4 个字节的作用域，则把其称为 `魔数`，它的作用是唯一标识该文件所属类型。\n\t\n\t```Java\n\tClassFile {  \n      u4 magic;  \n      u2 minor_version;  \n      u2 major_version;  \n      u2 constant_pool_count;  \n      cp_info constant_pool[constant_pool_count-1];  \n      u2 access_flags;  \n      u2 this_class;  \n      u2 super_class;  \n      u2 interfaces_count;  \n      u2 interfaces[interfaces_count];  \n      u2 fields_count;  \n      field_info fields[fields_count];  \n      u2 methods_count;  \n      method_info methods[methods_count];  \n      u2 attributes_count;  \n      attribute_info attributes[attributes_count];  \n\t}  \n\t```\n\n###  Java 和其他语言比较\n\n<center>表 1-1 Java 与 C 语言的区别</center>\n\n| Java | C    |\n| :--- | :--- |\n| Java 是面向对象的语言 | C 是面向过程的语言 |\n| 通过类文件实现可移植性 | C 需要重新编译实现移植 |\n| 没有指针 | 有指针 |\n| 垃圾回收提供了自动内存管理功能 | 无法从低层布局内存 (结构体) |\n\n<center>表 1-2 Java 与 PHP 语言的区别</center>\n\n| Java | PHP  |\n| :--- | :--- |\n| Java 是静态类型语言 | PHP 是动态类型语言 |\n| Java 支持多线程操作 | PHP 不支持多线程 |\n\n\n- 书本中，关于静态语言与动态语言的区别，即在于编译时还是运行时检测错误。\n- 对于类型系统的概念，众说纷纭，如何理解静态、动态类型语言，推荐知乎 [rainoftime](https://www.zhihu.com/question/19918532/answer/21647195) 的回答： \n\n\t- Program Errors  \n\tTrapped errors：导致程序终止执行，例如：零为被除数、Java 数组越界访问。  \n\tUntrapped errors：出错后继续执行，但可能出现任意行为。如 C 里的缓冲区溢出、Jump 到错误地址。\n\t\n\t- Forbidden Behaviours   \n\t语言设计时，可以定义一组 Forbidden behaviors，它必须包括所有 Untrapped errors，但可能包含 Trapped errors。\n\t\n\t- Well behaved、ill behaved  \n\twell behaved: 如果程序执行不可能出现 Forbidden behaviors, 则为 Well behaved。   \n\till behaved: 否则为 ill behaved。  \n\n\t有了上面的概念，再讨论强、弱类型，静态、动态类型强、弱类型。\n\n\t- 强类型 ( Strongly typed )  \n\t如果一种语言的所有程序都是 Well behaved，即不可能出现 Forbidden behaviors，则该语言为 Strongly typed。\n\t\n\t- 弱类型 ( Weakly typed)  \n\t否则为 Weakly typed。譬如 C 语言的缓冲区溢出，属于 Trapped errors，即属于 Forbidden behaviors，故 C 是弱类型。 \n\t \n\t弱类型语言类型检查更不严格，如偏向于容忍隐式类型转换。譬如说 C 语言的 int 型可强转为 double 型。这样的结果是：容易产生 Forbidden behaviours，所以是弱类型的。\n\n\t- 静态类型 (Statically)\n\t如果在编译时拒绝 ill behaved 程序，则是 Statically typed。\n\t\n\t- 动态类型 (Dynamiclly)  \n\t如果在运行时拒绝 ill behaviors, 则是 Dynamiclly typed。\n\n<center>表 1-3 Java 与 JavaScript 语言的区别</center>\n\n| Java | JavaScript (Js) |\n| :--- | :--- |\n| Java 是静态类型语言 | Js 是动态类型语言 |\n| Java 使用基于类的对象 | JS 使用基于原型的对象 |\n| Java 提供良好的对象封装 | -- |\n| Java 支持多线程操作 | Js 不支持多线程 |\n\n## 贰 Java 基本句法\n\n### 词法结构\n{% note success %} \n说明：词法结构的内容与 Java / Android 开发规范的内容有所交集，可参阅上述推荐的优秀博文：  \n[BlankJ. Java / Android 开发规范. 2017. github.com](https://github.com/Blankj/AndroidStandardDevelop)。\n{% endnote %}\n\n- Java 编码使用的是 Unicode 字符集。\n- 需要区分大小写与空白的情况\n\t- 关键字使用小写 (class、interface、abstract、public、static 等)；\n\t- 函数、方法名称使用 `驼峰式命名法`；\n\t- `宏定义` 使用全大写字母的命名风格；\n- 注释：单行注释、多行注释和块注释\n\n\t```Java\n\t// 单行注释：注释的内容\n\n\t/* 多行注释：注释的内容 */\n\n\t/**\n\t * 块注释的风格：\n\t * 注释的内容 1\n\t * 注释的内容 2\n\t */\n\t```\n\n- 保留字  \n如 interface、class、public、private、protected、true、null 等，是不能单用来命名变量名称和类名称的。\n- 标识符：Java 程序中某个部分的名称，例如类、类中方法和方法中声明的变量。\n\t- 不能以数字开头；\n\t- 不能包含标点符号；\n\t- 可以使用货币符号 (¥或$)；\n\t\n\t> 货币符号主要用在自动生成的源码中，例如 Javac 生成的代码。不在标识符中使用货币符号，可避免自己的标识符和自动生成的标识符冲突。\n\t\n- 字面量  \n直接出现在 Java 源码中的值，包括 整数 `1`、浮点数 `3.141`，单引号字符 `'A'`、双引号字符 `\"Hello\"` 以及保留字 `true、false、null`。\n\n### 基本数据类型\n\n| 类型  | 取值 | 默认值 | 大小 | 范围 |\n| :--- | :--- | :--- | :--- | :--- |\n| boolean | true/false  | false | 1 位 | NA |\n| char    | Unicode 字符 | \\u0000 | 16 位 | \\u0000 ~ \\uFFFF |\n| byte    | 有符号的整数  | 0 | 8 位 | [-128, 127] |\n| short   | 有符号的整数  | 0 | 16 位 | [-32768, 32767] |\n| int     | 有符号的整数  | 0 | 32 位 | [-2147483648, 2147483647] |\n| long    | 有符号的整数  | 0 | 64 位 | [-9223372036854775808, 9223372036854775807] |\n| float   | IEEE 154 浮点数 | 0.0 | 32 位 | [1.4E-25, 3.4028235E+38] |\n| double  | IEEE 754 浮点数 | 0.0 | 64 位 | [4.9E-324, 1.7976931348623157E+308] |\n\n#### 布尔类型\n表示两种个逻辑状态，可表示开或关，也可是与否。\n\n- 零或非零表逻辑\n\n\t```Java\n\twhile(1) { // -7,-1,1,8...等非零数值都可作为条件体 \n\t    // 永真循环，条件体内为非零数值，即逻辑为真，若没有终止操作会一直操作下去\n\t}\n\t```\n- 对象体表逻辑\n\n\t```Java\n\tObject obj = new Object();\n\n\tif( null != obj) {\n\t    // 忽略实现细节\n\t}\n\t```\n\t\n#### 字符类型\n- 普通字符\n- 转义字符\n\n| 名称  | 符号 |\n| :--- | :--- |\n| 退格符\t\t| \\b |\n| 水平制表符\t| \\t |\n| 换行符\t\t| \\n |\n| 换页符\t\t| \\f |\n| 回车符\t\t| \\r |\n| 双引号\t\t| \\\\\" |\n| 八进制\t\t| \\000 |\n| 十六进制\t\t| \\u0000 |\n\n> 在上表中，以取双引号为例，只需附加上反斜杆 `\\` 即可。  \n> 例如：`\\\\`、`\\\"` `\\'`。\n\n### 表达式和运算符\n\n- 运算符概述\n\t- 优先级：与 [C语言类同](https://www.kofes.cn/2017/04/C-Programming-Design-Learning.html#4-1-关系运算符及其优先次序) (单目运算符 > 双目运算符 > 三目运算符)\n\t- 结合方式：从左向右\n\t\n- 算术运算符：加 `+`、减 `-`、乘 `*`、除 `/`、求模 `%`、负号 `-`。\n\n- 字符串连接符：`\"Hello\" + \"World\"` 相当于 `“HelloWorld”`。\n\n- 递增、递减运算符：操作数必须是变量、数组中的元素或对象的字段。\n\n- 比较运算符：等于 `==`、不等于 `!=`、小于 `<`、大于 `>`、大于等于 `>=`、小于等于 `<=`。\n\n- 逻辑运算符：条件与 `&&`、条件或 `||`、逻辑非 `!`。\n\n- 位运算符和位移运算符\n\t- 按位补码 `~`：把操作数的每一位反相，0变1，1变0  \n\t~12 => ~00001100 => 11110011 => -13\n\t- 位与 `&`   \n\t10 & 7 => 00001010 & 00000111\t=>\t00000010 => 2\n\t- 位或 `|`  \n\t10 | 7 => 00001010 | 00000111\t=>\t00001111 => 15\n\t- 位异或 `^`：相异为真  \n\t10 ^ 7 => 00001010 ^ 00000111\t=>\t00001101 => 13\n\t\n- 左移 `<<`：高位丢掉，右边补零，向左移动 n 位，相当于乘以 2\\\\(^{n}\\\\)。\n\n\t```Java\n\t左移运算的实例：\n\n\t10 << 1 => 00001010 << 1 => 00010100 => 20 => 10 * 2\n\t07 << 3 => 00000111 << 3 => 00111000 => 56 => 07 * 2^3\n\t-1 << 2 => 11111111 << 2 => 11111100 => -4 => -1 * 2^2\n\n\t// -1<<2 => 11111111<<2：即负数是补码形式存储的。\n\t```\n\n- 带符号右移 `>>`：高位 `补符号`，左侧操作数为正数则 `高位补0`，左侧操作数为负数则 `高位补1`。向右移动 n 位，相当于除以 2\\\\(^{n}\\\\)。\n\n\t```Java\n\t10 >> 1  => 00001010 >> 1 => 0 0000101 => 05 => 10 / 2\n\t27 >> 3  => 00011011 >> 3 => 000 00011 => 03 => 27 / 2^3\n\t-50 >> 2 => 11001110 >> 2 => 11 110011 => -13\n\t```\n\n- 赋值运算符 与 条件运算符\n\n\t```Java\n\te = a < b ? c :d; // 条件运算符鼻赋值运算符优先级高\n\t```\n\n- 特殊运算符\n\t- 访问对象成员 `.`\n\t- 访问数组中元素 `[]`\n\t- 调用方法 `()`\n\t- lambda 表达式 `->`\n\t- 创建对象 `new`\n\t- 类型转换及校正 `()`，\n\n### 语句\n\n- 选择结构和循环结构和 C 语言的相差无几，这里就不详细列举。\n\n- synchronized 语句\n\n\t```Java\n\tsynchronized( Expression ) {\n        // Statements\n\t}\n\t```\n\t`Expression` 表达式的计算结果必须是一个对象或数组。`Statements` 是能导致破坏的代码块。\n\n\t即 Java 解析器为 `Expression` 计算得到的对象或数组获取一个排它锁，直到语句块执行完毕再释放。只要某个线程拥有对象的排它锁，其他线程就不能再获取这个锁。\n\n- throw 语句\n\n\t```Java\n\t// throw expression;\n\n\tpublic static double factorial(int x) {\n\tdouble fact;\n\t\n\tif( x < 0 ) {\n\t    throw new IllegalArgumentException(\"x must be >= 0.\");\n\t} else {\n\t    for(fact=1.0; x > 1; fact *= x, x--) {\n\t        // Nothing\n\t    }\n\t}\n\treturn fact;\n\t}\n\t```\n\n- try/catch/finall 语句\n\n\t```Java\n\ttry {\n        // 正常情况，从上往下执行\n        // 也有可能跑出异常，或是 throw 语句直接抛出异常\n\t} catch( SomeException e1 ) {\n        // 处理 SomeException 或其子类型的异常对象\n        // 使用名称 e1 引用那个异常对象\n\t} catch( AnotherException e2 ) {\n        // 处理 AnotherException，使用名称 e2 引用传入的异常对象\n\t} finally {\n        // 不管 try 子句的结束方式如何，这段代码都会执行。\n        // 但是 try 子句中调用了 System.exit()，解析器会马上退出，而不执 finally 子句。\n\t}\n\t```\n\n\t即 Java 解析器执行 throw 语句，会立即停止常规程序执行，开始捕获或处理异常的异常处理程序 ( try/catch/finally 语句编写 )。\n\n### 方法\n\n#### 定义方法\n- 方法的定义都是以签名开头，后面跟着方法主体。方法主体，即放在花括号里的任意语句序列。方法签名包括下述内容：\n\n\t- 方法名称；\n\t- 方法所用参数的数量、顺序、类型和名称；\n\t- 方法的返回值类型；\n\t- 方法抛出的已检异常 ( 下述有解释：已检异常和未检异常 )；\n\t- 提供方法额外信息的多个方法修饰符.\n\n- 方法签名的格式：`modifiers` `type` `name(paramlist)` [ throws `exceptions` ]  \n\t- `modifiers` : 指零个或多个特殊的修饰符关键字；  \n\t- `type` : 指明方法的返回类型；  \n\t- `name` : 即方法名称；  \n\t- `paramlist` : 指形参列表；  \n\t- `exceptions` : 抛出已检异常.  \n\n#### 方法修饰符\n| 修饰符 | 作用描述 |\n| :---- | :------ |\n| abstract | abstract 修饰方法，类本身也必须声明 abstract。 |\n| final | final 修饰的方法不能被子类覆盖或隐藏。 |\n| public、protected、private | 这些访问修饰符指定方法是否能在定义它的类之外使用，或能在何处使用。 |\n| synchronized | synchronized 修饰符的作用是实现线程安全的方法 (避免两个线程同时执行该方法)。 |\n| static | static 声明的方法是类方法。 |\n\n#### 已检异常和未检异常\n- 已检异常和未检异常 -- `什么情况抛出异常`\n\t- 已检异常：明确的特定情况下抛出。\n\t> 例如：FileNotFoundException -- 打开某个文件却不在目录中。\n\t\n\t- 未检异常：任何方法任何时候都可能抛出。\n\t> 例如：OutOfMemoryError、NullPointerException。\n\t\n- 区分已检和未检异常，记两点：  \n\t1. 异常是 Throwable 对象；  \n\t2. 异常分两种类型：Error (未检) 和 Exception (已检).\n\n- 处理已检异常：在方法签名的 throws 子句中声明这个异常。Java 编译器检查方法签名，若没有声明会导致编译出错，故叫已检异常。\n\t\n\t```Java\n\tpublic static estimateHomePageSize(String host) throw IOException {\n\t    URL url = new URL(\"htts://\" + host);\n\t    try( InputStream in = url.openStream() ) {\n\t        return in.available();\n\t    }\n\t}\n\t```\n\t\n#### 变长参数列表\n- 变长参数列表：方法可声明为数量不定的参数。\n\n\t```Java\n\tpublic static int max(int first, int...rest) { \n        // int...rest 相当于 int[] rest\n        // 省略实现细节\n\t}\n\t```\n\n### 介绍类和对象\n\n关于类最重要的事情是，它们定义了一种新数据类型。例如定义一个 Point 类表示笛卡尔二维坐标系中的数据点。\n\n- 定义类\n\n\t```Java\n\tpublic class Point {\n\t    public double x, y;\n\t    public Point(double x, double y) {\n\t        this.x = x;\n\t        this.y = y;\n\t    }\n\t    public double distanceFromOrigin() {\n\t        return Math.sqrt(x*x,y*y);\n\t    }\n\t}\n\t```\n\n- 创建对象与使用对象\n\n\t```Java\n\tPoint point = new Point(2.0, 3.5);\n\tSystem.out.println( \"Sqrt(x, y):\" + point.distanceFromOrigin() );\n\t```\n\n- 再谈数据类型\n\t谈论数据类型时，得分开数据类型和数据类型的值。Char 类型的值表示某个具体的字符，而 Point 类是一种新的数据类型，用于表示坐标 (x, y)，Point 类为引用类型，即聚合类型，而 Point 类表示的值是对象。\n\n| 数据类型 | 数据类型的值 |\n| :------ | :--------- | \n| char   | unicode 字符 |\n| Point 类 | point 对象 |\n\n- lambda 表达式：其实就是没有名称的函数，`某个类中定义的匿名方法`。  \n\n\t> 某个类中定义的匿名方法：Java 不允许脱离类的概念运行方法。\n\n\t定义 lambda 表达式：( paramlist ) -> { Statements }\n\t\n\t```Java\n\tRunable r = () -> { System.out.println(\"Hello World.\"); }\n\t```\n\n### 数组\n\n#### 数组的类型\n数组中元素的类型可是任何有效的 Java 类型，包括数组类型。\n\n```Java\n// byte 是基本类型\nbyte b;\n\n// byte[] 是由 byte 类型的值组成的数组\nbyte[] arrayOfBytes;\n\n// byte[][] 是由 byte[] 类型的值组成的数组\nbyte[][] arrayOfArrayOfBytes;\n\n// String[] 是由字符串组成的数组\nString[] points;\n```\n\n#### 创建和初始化数组\nJava 在运行时 `初始化数组` 有个推论：数组初始化程序中的 `表达式` 可能会在运算时计算，而且不一定非要使用 `编译时常量`。\n\n```Java\nPoint[] point = \n\t{circle1.getCenterPoint(), circle2.getCenterPoint()}\n\t\t\nString[] lines = new String[50]; // 中括号中使用非负整数\nString[] greetings = \n\tnew String[] {\"Hello\", \"World\", \"I'm Kofes.\"}\n```\n\n#### 使用数组\n- 数组的边界：a[ 0...a.length-1 ]\n- 迭代数组：遍历数组\n\n```Java\nint[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23 };\nint sumOfPrimes = 0;\n\t\nfor( int = 0; i < primes.length; i++ ) {\n    sumOfPrimes += prime[i];\n}\n\t\n// 等价于上一个 for 循环\nfor( int p : primes ) sumOfPrimes += p;\n```\n\n#### 多维数组\n\n```Java\nint[][] products = new int[10][]; // 正确\nint[][] products = new int[][10]; // 错误，指定的维度必须位于最左边\n\nfor( int i = 0; i < 10; i++ ) {\n    products[i] = new int[10];\n}\n```\n\n### 引用类型\n- 引用类型与基本类型\n\t- 引用类型  \n\t1) 引用类型由用户定义，可有无限多个。  \n\t2) 即聚合类型，保存零或多个基本值或对象。\n\t- 基本类型  \n\t1) 8 种基本类型由 Java 语言定义，不能由我们自己定义新基本类型。  \n\t2) 基本类型表示单个值。  \n\t3) 基本类型需要 1 到 8 字节的内存空间。\n\n- 处理对象和引用副本\n\n\t```Java\n\tPoint p = new Point(1.0, 2.0);\n\tPoint q = p; // 因变量 p 和 q 保存的引用都指向同一对象。\n\tSystem.out.println(p.x); // 1.0\n\tq.x = 13.0;\n\tSystem.out.println(p.x); // 13.0\n\t```\n\n- 比较对象，即 `==` 与 `x.equal()` 的区别\n\t- `==` 比较引用类型时，比较的是引用是否指向同一对象。\n\t- `x.equal()` 比较的是对象内容是否一样。\n\t\n\t```Java\n\tString letter = \"O\";\n\tString s = \"Hello\";\n\tString t = \"Hell\" + letter;\n\t\n\tif( s==t ) {\n\t    System.out.println(\"equal\"); // 显然不等\n\t}\n\tif( s.equal(t) ) {\n\t    System.out.println(\"equal\"); // 内容相等\n\t}\n\t```\n\n### 包和 Java 命名空间\n- 声明包：package org.apache.commons.net;\n\n\t> package 指定类属于哪个包 (Java 代码的第一行标记，除注释和空格外)\n\t\n- 导入类型\n\t\n\t```Java\n\t// 现不用输入 java.io.File 了，输入 File 定义即可\n\timport java.io.File; \n\tFile file = new File();\t\n\t\n\t// java.io 包中的所有类都可以使用简称\n\timport java.io.*;\n\t```\n\n- 导入静态成员\n\n\t```Java\n\timport static java.lang.Math.*;\n\tMath.sqrt( abs(sin(x)) ); // 直接使用 sqrt( abs(sin(x)) );\n\t```\n\n- Java 文件结构\n\t- `一个` 可选的 package 指令；\n\t- `零个或多个` import 或者 import static 指令；\n\t- Java 文件中 `只有一个` 声明 public 的类，且类名必须与文件名相同.\n\t\n\t> public 类的目的是供其他包中的类使用。不管类是否为 public，一个文件只定义一个类，并且名称相同，是良好的编程习惯。\n\n## 叁 Java 面向对象编程\n\n### 类\n#### 面向对象的基本概念\n- 类\n\t- 由一些保存值的数据字段和处理这些值的方法组成。\n\t- 类定义一种新的引用类型。\n\n\t> 例如：Point 类，表示所有笛卡尔二维坐标点。\n- 对象：类的实例，对象一般通过实例化类来创建。\n\n#### 定义类的句法\n\n```Java\npublic class IntegerNumber extends Number\n\timplements Serialzable, Comparable {\n\t// 类的成员 (成员变量和成员方法)\n}\n```\n\n### 字段和方法\n\n- 类字段\n- 类方法\n\n\t> 类字段、类方法：关联在类自身上的类成员 (静态变量)。\n- 实例字段\n- 实例方法\n\n\t> 实例字段、实例方法：关联在类的单个实例 (对象) 身上的实例成员。\n\t\n\t```Java\n\tpublic class Circle {\n\t    // 类字段\n\t    public static final double PI = 3.14159; \n\t    \n\t    // 类方法\n\t    public static double radiusToDegrees(double radius) {\n\t        return radius * 180 / PI;\n\t    }\n\t    \n\t    // 实例字段，即实例化后获得参数\n\t    public double r; \n\t    \n\t    // 实例方法\n\t    public double area() { \n\t        return PI * r * r;\n\t    }\n\t}\n\t```\n\t\n- this 引用的工作方式\n\n\t只要 Java 方法在类中访问 `实例字段`，都默认方法 this 参数指向的对象中的字段。\n\n\t```Java\n\tdouble radius;\n\n\tpublic void setRadius(double radius) {\n\t    this.radius = radius; // 把参数赋值给类字段\n\t}\n\t```\n\n\t- 一般地，若实参变量名称与类字段不一致，可省略 this，例如形参为 `double r`，即  `radius = r` 。在该例子中省略会让编译器报错，即无法理解值是谁赋给谁。\n\t- 实例方法可以使用 this 关键字，相反类方法不能使用。\n\n### 创建和初始化对象\n\n- 定义构造方法\n\n\t```Java\n\tpublic class Circle {\n        protected double r;\n        public Circle(double r) {\n            this.r = r;\n        }\n\t}\n\t```\n\n\t- 构造放方法的成名始终和类名一样。\n\t- 声明构造方法时不指定返回值类型，连 void 都不用。\n\n- 定义多个构造方法\n\n\t只要构造方法的参数列表不同，为一个类定义多个构造方法是可以的。\n\n\t```Java\n\tpublic class Circle {\n\t    protected double r;\n\t    public Circle() {\n\t        r = 1.0;\n\t    }\n\t    public Circle(double r) {\n\t        this.r = r;\n\t    }\n\t}\n\t```\n\n- 字段的默认值和初始化程序\n\n\t类中的字段不一定要初始化，因为字段自己使用默认值初始化。\n\t\n\t> 良好的编程习惯，或字段的默认值不适合情景。建议显式提供初始值。\n\t\n### 子类的继承\n\n#### 扩展类\n\n```Java\npublic  class PlanCircle extends Circle { // 自动继承了 Circle 类的字段和方法\n    private final double x, y;\n    public PlanCircle(double r, double x, double y) {\n    \n        // 调用超类的构造方法 Circle()\n        super(r);\n        \n        this.cx = x;\n        this.cy = y;\n    }\n}\n```\n\n#### 构造方法链和默认构造方法\n\n- 创建类的实例，Java 保证会调用这个类的构造方法。\n- 创建任何子类的实例，Java 保证会调用超类的构造方法。\n- 若构造方法没有调用超类的构造方法，Java 会隐式调用。\n- 若类没有声明构造方法，Java 会为类隐式添加一个构造方法。\n\n\t> 若超类没有声明无参数的构造方法，这种隐式调用会导致编译出错。所以，若类中没有定义任何构造方法，默认会为其提供一个无参数的构造方法。\n\t\n#### 覆盖超类的方法\n\n> 注意，覆盖不是遮盖\n\n类中定义的某个实例方法和超类的某个方法有相同 `名称`、`返回类型`、`参数`，那么这个方法会覆盖，即 `@Override`。\n\n### 数据隐藏和封装\n\n- 封装：把数据隐藏在类中，只能通过方法获取。\n\t- 隐藏类的内部细节。\n\t- 保护类，如一些相互依赖的字段。\n- 访问控制\n\t- 访问包  \n\t1) 访问控制一般在类和类的成员这些层级完成。  \n\t2) 访问其他包，import 导入相关包即可。  \n\t- 访问类：默认情况，顶层类在定义它的包中可以访问。\n\t- 访问成员：类的成员在类的主体里始终可以访问。\n\t\n\t> public、private、protected (default) 作为修饰符，修饰类的成员。  \n\t> public => 类的任何地方都可访问这个成员。  \n\t> private => 除了类内部能访问。  \n\t> protected => 包里的所有类都能访问这个成员，只限制在同一包内进行访问。  \n\t\n\t- 访问控制和继承\n\t\t- 使用 `private` 声明的字段和方法绝不会被继承，类字段和类方法也一样。\n\t\t- 构造方法不会被继承，而不是链在一起调用。\n\t\t- 子类和超类  \n\t\t1) 同一包中，子类继承所有没使用 `private` 声明的实例字段和方法。  \n\t\t2) 不同包中，子类继承所有使用 `protected` 和 `public` 声明的实例字段和方法。\n\t\t\n\t\t> 不继承类字段、类方法。\n\n### 抽象类和方法\n\n- 类中有一 abstract 方法，则该类为 abstract，若是 final 关键字声明的类不能有任何 abstract 方法。\n- abstract 类无法实例化。\n\n#### 转换引用类型\n- 对象不能转换不相关的类型。\n\n\t> String 对象 -> Point 对象\n\t\n- 对象可以转成超类类型，或任何祖先类型。即放大转换，因此不需要校正。\n- 对象可以转换成子类型，缩小转换，但需确保转换有效。\n\n#### 修饰符总结\n\n| 修饰符 | 用于 | 意义 |\n| :---- | :-- | :--- |\n| abstract | 类 | 这个类不能实例化，且可能包含未实现的方法 |\n|  | 接口 | 所有接口都是抽象的，声明接口时这个修饰符是可选的 |\n|  | 方法 | 这个方法没有主体，主体由子类提供，签名后面紧接一个分号。所在的类必须也是抽象的 |\n| default | 方法 | 这个接口方法的实现是可选的。 |\n| final | 类 | 不能创建这个类的子类 |\n|  | 方法 | 不能覆盖这个方法 |\n|  | 字段 | 这个字段的值不能改变 |\n|  | 变量 | 值不能改变的局部变量、方法参数或异常参数 |\n| 无(包) | 类 | 包级私有：没有声明 public 的类只能在包中访问 |\n|  | 接口 | 包级私有：没有声明 public 的接口只能在包中访问 |\n|  | 成员 | 包级私有：没有声明 public、private 或 protected 的成员只能在包中访问 |\n| private | 成员 | 该成员只在定义它的类中可以访问 |\n| protected | 成员 | 该成员只在定义它的包中和子类中可以访问 |\n| public | 类 | 能访问所在包的地方都能访问这个类 |\n|  | 接口 | 能访问所在包的地方都能访问这个接口 |\n|  | 成员 | 能访问所在类的地方都能访问这个成员 |\n| static | 类 | 使用 static 声明的内部类是顶层类，而不是所在类的成员 |\n|  | 方法 | static 方法是类方法，不隐式传入 this 对象引用，可通过类名调用 |\n|  | 字段 | static 字段是类字段，不管创建多少类实例，这个字段只有一个实例，可通过类名访问 |\n|  | 初始化程序 | 这个初始化程序在加载类时运行，而不是创建实例时运行 |\n| synchronized | 方法 | 这个方法对类或实例执行非原子操作，故得确保不能让两个线程同时修改类或实例。对 static 方法来说，执行方法前先为类获取一个锁；对非 static 方法来说，会为具体的对象实例获取一个锁 |\n| volatile | 字段 | 该字段能被异步线程访问，因此必须对其做些特定的优化 |\n\n## 肆 Java 类型系统\n\nJava 是一种静态语言，如果把不兼容型的值赋给变量，会导致编译出错。而在运作时检查类型兼容性的语言叫做动态类型语言，如 Javascript。  \n\n> 在 [第壹章：Java 和其他语言比较](#Java-和其他语言比较) 中有对语言类型的深入了解。\n\n\n### 接口\n- 接口的作用只是描述 API，接口提供类型的描述信息，以及实现这个 API 的类应提供的方法 (和签名)。\n- Java 的接口不为它描述的方法提供实现代码，这些方法是强制要实现的。\n\n#### 定义接口\n\n```Java\ninterface Centered {\n    void setCenter(double x, double y);\n    double getCenterX();\n    double getCenterY();\n}\n```\n\n- 特别说明\n\t- 接口中所有强制方法都隐式使用 abstract 声明，不能有方法主体，以分号结束。\n\t- 接口定义公开的 API，接口所有成员都隐式使用了 public 声明。\n\n\t> 使用 protected 或 private 定义方法，将会编译出错。\n\t\n\t- 接口不能实例化，因此不定义构造方法。\n\t- 接口中可包含嵌套类型。\n\t- 接口中可包含静态方法。\n\n#### 扩展接口\n继承父接口的所有方法和常量，且可定义新方法和常量。接口的 extends 子句可包含多个父接口。\n\n```Java\ninterface Transformable extends Scalable, Translateble, rotalable {\n    // 忽略细节\n}\n```\n注意：实现这个接口的类必须实现这个 `接口直接定义` 的抽象方法，包括所有 `父接口` 中继承的全部抽象方法。\n\n#### 实现接口\n\n实现多个接口：一个类即可实现一个接口，也可实现多个接口，后者表明的这个类要实现所有接口中的全部抽象方法 (强制方法)。\n\n```Java\npublic class SuperDuperSquare extends Shape \n    implements Centered, UpperRightCornered, Scalable {\n    // 忽略细节\n}\n```\n\n#### 默认方法\n\n- 向后兼容性：前一版平台编写 (或已编译) 的代码在最新版平台中必须能继续使用。\n- 实现默认方法：若升级某一接口，重新定义接口后，尝试在为旧接口编写的代码中使用这个新接口，不会成功。  \n\t即抛出 `NoClassDefError` 异常，如下例中添加新的强制方法。\n\t\n\t```Java\n\tinterface Positionable extends Centered {\n\t    void setUpperRightCorner(double x, double y);\n\t    double getUpperRightX();\n\t    double getUpperRightY();\n\t\t\n\t    // 在此接口增加以下强制方法，是不会成功的。后续的解决办法是使用抽象类\n\t    void setLowerLeftCorner(double x, double y);\n\t    double getowerLeftX();\n\t    double getowerLeftY();\n\t}\n\t```\n\n### Java 泛型\n\n#### 介绍泛型\n- 使用泛型增强程序的安全性，使编译时信息避免简单的类型错误。具体以下述的引例展开学习。\n\n\t```Java\n\tList shapes = new ArrayList();\n\tshapes.add( new CenteredCircle(1.0, 1.0, 1.0) );\n\tshapes.add( new CenteredSquare(2.5, 2, 3) );\n\n\t// list::get() 返回 Object 对象，想得到 CenteredCircle 对象必须校正\n\tCenteredCircle circle0 = (CenteredCircle) shapes.get(0);\n\n\t// 运行此代码时会导致运行失败\n\tCenteredCircle circle1 = (CenteredCircle) shapes.get(1);\n\t```\n\n\t`CenteredCircle circle1 = (CenteredCircle) shapes.get(1);` 运行失败的原因，即把不同类型的对象放在同一容器中，一切正常运行。但若做了不合法的校正，程序就会崩溃。\n\n\t为了解决此类问题，Java 提供了一种句法，即指明某中类型是一个容器，这个容器中保存着其他引用类型的实例。容器中保存的 `负载类型` 在尖括号中指定：\n\n\t```Java\n\tList<CenteredCircle> shapes = new ArrayList<CenteredCircle>();\n\tshapes.add( new CenteredCircle(1.0, 1.0, 1.0) );\n\tshapes.add( new CenteredCircle(2.5, 2, 3) );\n\t```\n\n- 容器类型，一般叫泛型\n\n\t```Java\n\tinterface Box<T> {\n\t    void box(T t);\n\t    T unbox();\n\t}\n\t```\n\n#### 泛型和类型参数\n- `<T> 句法`，也称 `类型参数`，因此泛型还有一个名称 `参数化类型`。\n- 定义有参数的类型，要使用一种不对类型参数做任何假设的方式指定具体的值。且类型参数可在方法的签名和主体中使用，就像真正的类型一样。\n\n\t```Java\n\tinterface List<E> extends Collection<E> {\n\t    boolean add(E e);\n\t    E get(int index);\n\t}\n\t```\n\n#### 菱形句法\n使用菱形句法创建一个由 CenteredCircle 对象组成的 List。\n\n```Java\n// 后一个 <> 内为空，但编译器能推导出类型参数的值\nList<CenteredCircle> shapes = new ArrayList<>(); \n```\n\n#### 类型擦除\n\n- Java 平台十分看重向后兼容性，问题的关键是，如果让类型系统既能使用旧的非泛型集合类又能使用新的泛型集合类，则设计者们选择 `校正` 的解决方案。\n\n\t```Java\n\tList someThings = getSomeThing();\n\t// 这种校正不安全，即使 someThings 的内容确定是字符串\n\tList<String> myStrings = (List<String>) SomeThings;\n\t```\n\t上述代码表明，`List` 与 `List<String>` 是兼容的，Java 通过类型擦除实现这种兼容性。\n\n- 类型擦除机制还能禁止使用某些其他定义方式。\n\n\t```Java\n\tinterface OrderCounter {\n\t    int totalOrder( Map<String, List<String>> orders );\n\t    int totalOrder( Map<String, Integer> orders );\n\t}\n\t```\n\t上述代码看似合法，其实是无法编译的。其实当擦除类型后，两方法的签名变成 `int totalOrder(Map);`，Java 语言规范把这种句法列为不合法的句法。\n\t\n#### 通配符\n\n- 受限通配符，限制类型参数的值能使用哪些类型。\n\t- 类型协变：表示`容器类型之间` 和 `负载类型之间` 具有 `相同` 的关系，这种关系通过 `extends` 关键字表示。\n\t- 类型逆变：表示`容器类型之间` 和 `负载类型之间` 具有 `相反` 的关系，这种关系通过 `super` 关键字表示。\n\t\n\t[实例] 例如，Cat 类 扩展 Pet 类，`List<Cat>` 是 `List<? extends Pet>` 的子类型。List 是 Cat 对象的制造者，应使用关键字 extends。\n\n\t> [Joshua Bloch](https://baike.baidu.com/item/Josh%20Bloch/4419184?fr=aladdin) 把这种用法总结为 PECS. `Producer Extends, Consumer Super` 原则，即使用者使用 super，制造者使用 extends。\n\t\n- 使用和设计泛型\n\t- 使用者：理解类型擦除的基本知识。\n\t- 设计者：泛型更多功能。如通配符、\"Capture of\" 错误信息等。\n\n### 枚举和注解\n\n#### 枚举\n\n```Java\npublic enum RegularPolygon {\n    // 带参数的枚举必须使用分号\n    TRIANGLE(3), SQUARE(4), PENTAGON(5), HEXAGON(6);\n    \n    private Shape shape; \n    \n    public Shape getShape {\n        return this.shape;\n    }\n    \n    // 因枚举实例在 Java 运行时创建，在外部不能实例化，故把构造方法声明为私有。\n    // 只能有一个私有的构造方法 (或默认访问权限，即不写)。\n    private RegularPolygon(int sides) {\n        switch(sides) {\n            case 3: // 三角形\n                shape = new Triangle(1, 1, 1, 60, 60, 60);\n                break;\n            case 4: // 矩形\n                shape = new Rectangle(1, 1);\n                break;\n            case 5: // 五边形\n                shape = new Pentagon(\n                    1, 1, 1, 1, 1, 108, 108, 108, 108, 108);\n                break;\n            case 6: // 六边形\n                shape = new Hexagon(\n                    1, 1, 1, 1, 1, 1, 120, 120, 120, 120, 120, 120);\n                break;\n        }\n    }\n}\n\n// 实际使用\nRegularPolygon polygon = \n    new RegularPolygon( RegularPolygon.TRIANGLE );\n```\n\n- 注意\n\t- 枚举不能泛型化，不能被扩展；\n\t- 可以实现接口；\n\t- 只能有一个私有的构造方法 (或使用默认访问权限，不写).\n\n#### 注解\n\n- 注解是一种特殊的接口，其作用是注解 Java 程序的某个部分。\n- 能为编译器和集成环境 (IDE) 提供有用的提示。\n- 注解没有直接作用，例如 `@Override` 为注解的方法提供额外信息，注明这个方法覆盖了超类中的方法。\n- Java 平台中常见的基本注解：\n\t- `@Override` - 注明方法是覆盖的。\n\t- `@Deprecated` - 注明方法已经废弃了。\n\t- `@SuppressWarnings` - 注明编译器生成的警告。\n\t- `@SafeVarargs` - 为变长参数方法提供增强的警告静态方法、默认方法功能\n\t- `@FunctionalInterface` - 接口是一正确的函数式接口，注解能够更好地让编译器进行检查。\n\n#### 自定义注解\n使用 `@interface` 关键字定义新的注解类型，与定义类和接口的方式差不多。\n\n自定义注解的关键是使用 `元注解`，他们是用来注解新注解类型的定义，必须使用两个基本元注解 `@Target` 和 `@Retention`。\n\n- `@Target`：指明自定义的新注解能在 Java 源码的什么地方使用。可用的值在枚举 `ElementType` 中定义，其中包括：\n\t- TYPE - 类、接口 (包括注解类型) 或 Enum 声明\n\t- FIELD - 域声明 (包括 Enum 实例)\n\t- METHOD - 方法声明\n\t- PARAMETER - 参数声明\n\t- CONSTRUCTOR - 构造器声明\n\t- LOCAL_VARIABLE - 局部变量声明\n\t- ANNOTATION_TYPE - 注解\n\t- PACKAGE - 包声明\n- `@Retention`：指明 Javac 和 Java 运行时如何处理自定义的注解类型。可用的值得在枚举 `RetentionPolicy` 中定义，其中包括：\n\t- SOURCE - 表示注解将被编译器丢弃。\n\t- CLASS - 表示注解会出现在类文件中，但运行时 JVM 无法访问。\n\t- RUNTIME - JVM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。\n- `@Documented`：将此注解包含在 Javadoc 中。\n- `@Inherited`：允许子类继承父类中的注解。\n\n\t便于理解，这里定义一个名为 @Nickname 的注解，使用这个注解为方法指定一个昵称，运行时使用反射可以找到这个方法。\n\n\t```Java\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface Nickname {\n\t    String[] value() default {};\n\t}\n\t```\n\t\n#### 嵌套类型\n- 顶层类型：诸如类、接口和枚举类型都定义为顶层类型，即都是包中的直接成员。\n- 嵌套类型：也称为 `内部类`，不能作为完全独立的实体真实存在，类型通过四种不同方式嵌套在其他类型中。\n- 四种嵌套方式：\n\t- 静态成员类型：嵌套的接口，枚举和注解 (既使不使用 static 关键字)。\n\t- 非静态成员类型：没有 static 关键字声明，只有类才能作为非静态成员类型。\n\t- 局部类：Java 代码块中定义的类，只是这个块可见。\n\t- 匿名类：局部类，匿名类是不能有名字的类，在创建 new 语句来声明它们。\n\n\t```Java\n\tRunnable runnable = new Runnable() {\n\t    public void run() {\n\t        // 忽略细节\n\t    }\n\t}\n\t\n\tThread thread = new Thread();\n\trunnable.start();\n\t```\n- 嵌套类型的运作方式\n\n\t对于 Java 解析器而言，并没有所谓的嵌套类型，`所有类型都是普通的顶层类`。为了实现嵌套类型，Javac 把每个嵌套类型编译为 `单独类文件`，得到的类文件使用 `特殊命名约定`。\n\n\t- 静态 / 非静态成员类型：以 `EnclosingType$Member.class` 格式命名成员类型的类文件。\n\n\t> 例如在 LinkedStack 类中，定义一个 Linkable 的静态成员接口。  \n\t> 在编译这个 LinkedStack 类时，编译器会生成两个类文件，分别是 LinkedStack.class 和 LinkedStack$Linkable.class。\n\t\n\t- 匿名类：类文件的名称由实现细节决定，例如 Oracle 或 OpenJDK 中 Javac 使用数字表示匿名类的名称，即 `EnclosingType$1.class`.\n\t- 局部类：综合使用前两种方式命名，例如 `EnclosingType$1Member.class`。\n\n#### Lambda 表达式\n列出目录中文件名以 \".java\" 结尾的文件。\n\n```Java\nFile dir = new File(\"/src\");\n\n// 调用 list() 方法，参数的值是匿名类实现的 FilenameFilter\nString[] fileList = dir.list( new FilenameFilter() {\n    public boolean accept(File file, String str) {\n        return str.endsWith(\".java\");\n    }\n});\n\n// Lambda 表达式\nString[] fileList = dir.list( \n    (file, str) -> {return str.endsWith(\".java\"); }\n);\n```\n\n- 转换 lambda 表达式：必须满足以下条件才算是合法的 Java 代码。 \n\t- 必须出现在期望使用接口类型实例的地方；\n\t- 期望使用接口类型必须只有一个强制方法；\n\t- 该强制方法的签名要完全匹配 lambda 表达式).\n- 方法引用\n\n\t```Java\n\t// 该接口只有一个非默认方法：\n\t// 该方法接受一个 MyObject 类型的参数，返回类型为 String\n\t(MyObject myobject) -> { myobject.toString(); }\n\t\n\t// 方法引用：Java 8 提供了更简洁的句法\n\tMyObject::toString;\n\t```\n\n## 伍 Java 的面向对象设计\n\n### Java 的值\nJava 的值有两种类型，基本值和对象引用，只有这两种值才能赋值给变量。\n\n- 基本值：基本值不能改，2永远是2。\n- 对象引用：对象引用的内容一般能修改，一般为对象内容的变化。\n\n\t[说明] Java 不是 \"引用传递\" 的语言。\n\t\n\t```Java\n\tpublic void manipulate(Circle circle) {\n\t    circle = new Circle(3);\n\t}\n\t\n\tCircle circle = new Circle(2);\n\tmanipulate(circle);\n\t\n\t// 还是输出 => Radius:2\n\tSystem.out.println(\"Radius:\" + circle.getRadius() ); \n\t```\n\n#### 面向对象的设计要略\n\n- 常量：实现某个接口的任何类都会继承这个接口中定义的常量。特别是在多给类中使用的一组常量。\n- 高度抽象：选择接口还是抽象类\n\t- 在已定义的接口添加一个新的强制方法，那么已经实现这个接口的所有类都会出现问题，即接口中添加新方法必须为默认方法，并提供实现。\n\t- 抽象类，可放心添加非抽象方法。子类必须实现抽象方法，但非抽象方法不要求。\n- 实例方法还是类方法\n\t- 类方法：static 声明的静态方法。\n\t- 实例方法：关联在类的单个实例 (对象) 身上的实例成员。\n\n\t> 选择实例方法还是类方法，视设计方式决定，哪个方便来哪种。\n- 合成还是继承：可参考 `装饰模式`。\n- 字段继承和访问器\n\t- `protected` 修饰字段，允许子类直接访问这些字段。\n\t- 提供访问器，即字段声明为私有，对外隐藏细节。\n\n\t```Java\n\tprivate double radius;\n\tpublic double getRadius() {\n\t    return radius;\n\t}\n\t```\n- 单例 -- 单例模式 -- 只需要为类创建一个实例。更多设计模式可参考：\n\n\t[Android 设计模式之实践与案例 ( 笔记 + 速记手册 )](https://www.kofes.cn/2018/01/Design-Pattern-Based-on-Android.html)\n\n#### 异常和异常处理\n- 设计异常机制，应遵循下述良好的做法：\n\t- 异常也是对象，即考虑要在异常中存储什么额外状态；\n\t- Exception 类有四个公开构造。一般情况，自定义异常类需要实现这四个构造方法，可用于初始化额外的状态，定制异常消息；\n\t- 不要捕获异常而不处理；  \t\n\t- 不要捕获异常，记录日志后再次抛出异常.  \n\t\n\t```Java\n\t// 不要捕获异常而不处理\n\ttry {\n\t    SomeMethodThatMightThrow();\n\t} catch(Exception e) {\n\t    // 处理异常的细节\n\t}\n\t\n\t// 不要捕获异常，记录日志后再次抛出异常\n\ttry {\n\t    SomeMethodThatMightThrow();\n\t} catch(SpecificException e) {\n\t    log(e);\n\t    throw e; // 不要再异常处理中再抛出异常\n\t}\n\t```\n\n## 陆 Java 实现内存管理和并发编程的方式\n\n### Java 内存管理的基本概念\nJava 中，对象占用的内存在不需要使用对象时会 `自动回收` (自动内存管理)。即减少内存泄露的发生机率。\n\n#### Java 中的内存泄露\n既使自动回收机制减少了内存泄露的发生机率，但任然后发生内存泄露。\n\n[例如] 某个方法运行时间很长 (或一直运行)，那么这个方法中的局部变量会一致保存对象的引用。\n\n```Java\npublic static void main(String args[]) {\n    int bigArray[] = new int[10000];\n    int result = compute(bigArray);\n\t\n    // 手动销毁引用\n    bigArray = null;\n}\n```\n\n如果没有引用指向 bigArray，就会被垃圾回收。而 bigArray 是局部变量，在方法返回之前始终指向哪个数组，而 main() 并不会立即返回，而是直至程序运行结束，故我们要手动销毁引用。\n\n#### 标记清除算法\n- 分配表：JVM 确切知道它分配了哪些对象和数组，且这些对象数组存储 `allocation table` 在某种内部数据结构中。\n- 活性对象 / 可达对象\n\t- JVM 还能区分每个栈帧 (Stack frame) 里的局部变量指向堆 (Heap) 里哪个对象或数组，再者追踪堆中对象和数组保存的引用。\n\t- 在应用线程的堆栈追踪中，从其中一个方法的某局部变量开始，沿着引用链，`最终能找到一个对象`。若没有对象引用，则将其内存回收。\n\n#### 基本标记清除算法\n> 回收垃圾的简单栈。\n\n- 垃圾回收过程经常使用的算法是标记清除，整个过程分三步：\n\t- 1) 迭代分配表：把每个对象标为 `已死亡`。\n\t- 2) 从 `指向堆的局部变量` 开始，顺着遇到的 `每个对象的全部引用` 向下，遇到之前没有见过的对象或数组，就把它标为 `存活`，一直向下，直到找到能从 `局部变量到达的所有引用` 为止。\n\t- 3) 再次迭代分配表，回收所有没有标记为 `存活` 的对象在堆中占用的内存，再把这些内存放回可用可用内存列表中，最后把这些对象从分配表中删除。\n\n### JVM 优化垃圾回收的方式\n引入：根据上述的情况，这一节将介绍一些优化措施。\n\n- 因为所有对象的内存由分配表分配，故用完堆内存之前会触发垃圾回收程序。\n- 垃圾回收程序需互斥存取整个堆，因应用代码一直运行，会不断创建和修改对象，导致结果腐化。\n- 避免发生此种情况，垃圾回收过程中，应用线程会停顿一下 (Stop-The-World，STW)，执行垃圾回收，再恢复执行应用线程。\n\t\n\t开发者担心这种 STW，但针对大多数主流应用场景来说，Java 都运行在操作系统之上，进程会不断交替进出处理器内核，因此一般无需担心这些短暂的额外停顿。HotSpot 会做大量工作来优化垃圾回收，减少 STW 时间。\n\n#### 弱化假设\n- HotSpot JVM 有一 `垃圾回收子系统`，专门利用弱代假设。\n\n\t> `垃圾回收子系统`：分代垃圾回收程序 (分别是新生代和老年代)。\n\n- 弱 `代` 假设：对象的生命周期非常短 (瞬时对象)，不久会被当作垃圾回收。然而有少量对象会存在久一些，因此注定会成为程序长期状态的一部分。\n\n\t> `代`：预期生命周期，即对象常常处于少数几个预期生命周期之一。\n\n#### 筛选回收\n在标记清理算法的清理阶段，一个个回收对象，再把每个对象占用的空间放回可用内存列表。然而，若弱代假设成立，且在任何一个垃圾回收循环中大多数对象都已经 `死亡`，那么使用另一种方式回收空间似乎更合理。\n\n新的回收方式把堆内存分成多个独立的内存空间，每次回收垃圾时，只为活性对象分配空间，并把这些对象移动另一个内存空间。这个过程称为筛选回收 (Evacuation)。\n\n执行该过程的回收程序叫 `筛选回收程序`，其回收完毕后会清理整个内存空间，供以后重复使用。\n\n> 使用筛选回收程序的话，每个线程都可以单独分配内存，即每个应用线程都有一块连续的内存 (线程私有的分配缓冲区)，专供这个线程分配新对象。为新对象分配内存时，只需把指针指向分配缓冲区即可。\n\n### Java 对并发编程的支持\n线程的作用是提供一个轻量级执行单元，属于 `进程`，进程的 `地址空间` 在组成该进程的 `所有线程之间共享`，即每个进程可独立调度，且有自己的栈和程序计数器 ( 会和 `同一个进程中的其他线程共享内存和对象` )。\n\n#### 线程的生命周期\n![线程的生命周期](/images/illustration/Programme/2017/09/Java_in_a_Nutshell_6-1.png)\n<center>图 6-1 线程的生命周期</center>\n\n- `New`：已经创建线程，但还没在线程对象上调用 start() 方法。所有线程一开始处于这个状态。\n- `Runnable`：线程正在运行，或当操作系统调度线程时可以运行。\n- `Blocked`：线程终止运行，因为它在等待获得一个锁，以便进入声明为 Synchronized 的方法或者代码块。\n- `Waiting`：线程终止运行，因为它调用了 Object.wait() 或 Thread.join() 方法。\n- `Timed.Waiting`：线程终止运行，因为它调用了 Thread.sleep() 方法，或者调用了 Object.wait() 或 Thread.join() 方法，而且传入超时时间。\n- `Terminated`：线程执行完毕，线程对象的 run() 方法正常退出，或抛出异常。\n\n\t[注意] Thread.sleep(2000);  \n\t参数中指定的休眠时长是对操作系统的 `请求`，而不是 `要求`。休眠的时间可能比请求的长，具体休眠多久，取决于负载和运行环境相关的其他因素。\n\t\n#### 可见性和可变性\nJava 应用线程都有自己的栈 (和局部变量)，这些线程共用一个堆，因此可以较易在线程间共享对象，即需要做的只是把引用从一个线程传到另一个线程。\n\n由此引入 Java 的设计原则：\n\n- 对象默认可见 (跨线程可见性)：指向内存中的一个位置，而所有线程都共用同一地址空间。\n- 对象是可变的 (对象可变性)：对象的内容 (实例字段的值) 一般都可修改。\n\n\t> `final` 关键字把 `变量或引用` 声明为 `常量`，但这种字段 不属于对象的内容。\n\n#### 互斥和状态保护\n\n互斥和状态保护 --  声明 `synchronized 关键字`\n\n只要修改或读取对象过程中，对象的状态可能不一致，这段代码就要受到保护。假若一个方法包含一连串操作，若在操作过程中中断，就可能导致 `某个对象处于不一致或非法状态`。如 `这个非法状态对另一个对象可见`，代码的行为就会`错乱`。\n\n#### Volatile 关键字\n应用代码使用字段或变量前，必须重新以主内存读取值。同理，修改使用 volatile 修饰的值，在写入变量之后，必须存回主内存。\n\n#### Thread 类中常用的方法\n- `getId()`：这个方法 `返回线程的 ID 值`，类型为 `long` 型，线程的 ID 在线程的整个生命周期中都不变。\n- `getPriority()` 和 `setPriority()`：控制线程的 `优先级`。线程的优先级使用 `1 ~ 10 之间的整数` 表示。\n- `setName()` 和 `getName()`：使用这两个方法设定或取回单个线程的名称。\n- `getState()`：返回一个 Thread.state 对象，说明 `线程处于什么状态`。\n- `isAlive()`：测试线程是否还 “活着”。\n- `start()`：创建一个新应用线程，然后调用 run() 方法调度这个线程开始执行。正常情况，执行到 run() 方法中的一个 return 语句后，线程结束运用。\n- `interrupt()`：\n\t- 调用 sleep()、wait()、join() 阻塞了线程，在表示这个线程的 Thread 对象上再调用 interrupt()，会让线程抛出 InterruptedException 异常 (并把线程唤醒)\n\t- 线程中涉及可中断 I/O 操作，那么 I/O 操作会终止，线程会收到 closedByInterruptException 异常。既使线程没有从事任何中断操作，线程中断状态会被设为 true。\n- `join()`：可理解为一指令，在其他线程结束前，当前线程不会继续向前运行。\n- `setDaemon()`：一个线程是用户线程还是守护线程，由其决定。\n\t- 用户线程：`只要线程还 “活着”，进程就无法退出。` (线程默认行为)\n\t- 守护线程：线程不阻止进程退出。\n- `setUncaughtExceptionHandler()`：线程因抛出异常而退出时，默认的行为是打印 `线程的名称`、`异常的类型`、`异常消息` 和 `堆栈跟踪`。\n\n\t自定义处理程序，处理未捕获的异常。\n\n\t```Java\n\t// 这个线程直接抛出一个异常\n\tThread handledThread = new Thread(\n\t    () -> {throw new UnsupportedOperationException();}\n\t);\n\t\n\thandledThread.setName(\"My Broken Thread\"); // 给线程起名，便于调试\n\thandledThread.setUncaughtExceptionHandler(\n\t    (t, e) -> { // 处理异常的程序\n\t        System.out.println(\n\t            \"Exception in thread %d%s: %s at line %d of %s\",\n\t            t.getId(),\t\t// 线程 ID\n\t            t.getName(),\t// 线程名称\n\t            e.toString(),\t// 异常名称和消息\n\t            e.getStackTrace()[0].getLineNumber(),\n\t            e.getStackTrace()[0].getFileName();\n\t        );\n\t    }\n\t);\n\thandledThread.start();\n\t```\n\n### 使用线程\n- 监视器和锁的基本知识\n\n\t> 监视器，即 Java 平台会为它创建的每个对象记录一个特殊的标记。\n\n\t- 同步保护的是对象的状态和内存，不是代码。\n\t- 获取监视器只能避免其他线程再次获取这个监视器，而不能保护对象。\n\t- 接口中声明的方法不能使用 `synchronized` 修饰。\n\t- 内部类是语法糖，因此内部类的锁对外层类无效 (反过来亦然)。\n\t- 锁定 Object[] 对象，不会锁定其中的单个对象。\n\t- 基本类型的值不可变，因此不能锁定 (也无需锁定)。\n\n### 总结\nJava 的线程模型是基于三个基本概念：\n\n- 状态是共享的，可变的，而且默认可见。\n- 抢先式线程调度。\n- 对象的状态只能由锁保护。\n\n## 柒 编程和文档约定\n\n### 命名和大小写约定\n- `包`：小写字母，常见做法是把公司的网站域名倒过来。\n\n\t> 例如：cn.kofes.javanutshell\n\n- `引用类型`：`类` 的名称应大写字母开头，混用小写字母；若名称中有部分是 `简称`，则简称全大写。\n\t- 类和枚举类型，表示对象，名称多使用 `名词`。如 `Thread`、`FormatConvertor`。\n\t- 接口，为实现这个接口的类提供额外信息，接口名称一般使用 `形容词`。如 `Runnable`、`Cloneable`。\n- `方法`：`名词 + 名词`；`动词 + 名词` 且遵循 `驼峰式` 命名规则。\n\n\t> 例如：ListenerCollection()、insertObjectA()\n\t\n- `字段和常量`：声明为 `static final` 的常量，名称使用 `全大写形式`，若常量名词包含多个单词，单词之间应使用下划线分割。枚举类型定义的常量往往也全部使用大写字母。\n- `参数`：尽量清楚表明参数作用的名称，尽量使用一个单词命名参数。\n\n\t> 例如：`WidgetProcessor widget;`、`ImageLoader image;`\n\n### Java 文档注释\n文档注释是普通的多行注释，即 `/* 块注释的内容. */`。文档包含简单的 Html 格式化标签，还可以包含其他特殊关键字，提供额外信息。\n\nJavadoc 程序会把文档注释提取出来，自己转换成 Html 格式的在线文档。\n\n```Java\n/**\n * 创建一个新 Complex 对象，表示复数 <i> x + y * i </i>\n * @param x 复数的实部\n * @param y 复数的虚部\n */\n public Complex(double x, double y) {\n \tthis.x = x;\n \tthis.y = y;\n }\n```\n\n- 文档注释标签\n\t- `@author name` 声明作者，例如 `@author BenEvans`。\n\t- `@version text`，声明版本信息，例如 `@version 1.3.2，08/26/2017`。\n\n\t> 这个标签常和支持自动排序版本号的版本控制系统一起使用，如：git、son。\n\t\n\t- `@param parameter-name description`，声明参数信息。例如 `@param circle Circle 类实例化的对象`。\n\t- `@return description`，声明返回信息。\n\t\n\t> @return `<code>true</code>` 成功插入对象。  \n\t> @return `<code>false</code>` 列表中已包含要插入的对象。\n\n\t- `@exception full-classname description` 或 `@throw full-classname description`，声明异常。例如 `@exception java.io.FileNotFoundException 如果找不到指定的文件`。\n \n- 关于 Html 标签的使用说明\n\t- `<i></i>`：用于强调文字内容。\n\t- `<code></code>`：用于显示类、方法和字段的名称。\n\t- `<pre></pre>`：用于显示多行代码示例。\n\n## 捌 使用 Java 集合\n\n### 介绍集合 API\n\n#### 两种基本数据结构\n- Collection：对象的集合，如图 8-1 所示。 \n- Map：对象间的一系列映射或关联关系，即 `键值对`，如图 8-2 所示。 \n\n![Collection数据结构](/images/illustration/Programme/2017/09/Java_in_a_Nutshell_8-1.png)\n<center>图 8-1 Collection 数据结构</center>\n\n![Map数据结构](/images/illustration/Programme/2017/09/Java_in_a_Nutshell_8-2.png)\n<center>图 8-2 Map 数据结构</center>\n\n- 关于图 8-1 中，部分数据结构的说明：  \n\t- `Set`、`List` 是 `Collection`。Set 没有重复对象，Set 实现都不会对元素排序；List 可能有重复，且其元素按顺序排列。\n\t- `SortedSet` 和 `SortedMap` 是特殊的集合映射，其中的元素按顺序排序。\n\n#### Collection 接口\n- `Collection<E>`，参数化接口，表示由泛型 E 对象组成的集合。\n- 该接口定义了很多方法，如：集合中添加、删除、遍历对象，测试对象是否存在集合中，集合中的元素转换成数组，返回集合大小。\n\n#### Set 接口\n- 无重复对象组成的集合\n\t- 不可能有两个引用指向同一对象；\n\t- 不可能有两个指向 Null 的引用；\n\t- `a.equals(b)`，即 a，b 两对象不能同时出现在集合中.\n- 多数通用的 Set 实现 `都不会对元素排序`，但并不禁止使用 `有序集`。\n\n\t> `有序集`：例如 SortedSet、LinkedHashSet。\n\t\n- 实现 Set 接口的类\n\n| 类 | 内部表示 | 元素排序 | 成员限制 | 基本操作 | 迭代性能 | 备注 |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| HashSet | 哈希表 | 无 | 无 | O(1) | O(capacity) | 无 |\n| LinkedHashSet | 哈希链表 | 插入顺序 | 无 | O(1) | O(n) | 无 |\n| EnumSet | 位域 | 枚举声明 | 枚举类型的值 | O(1) | O(n) | 枚举值不能为 null |\n| TreeSet | 红黑树 | 升序排列 | 可比较 | O(lgn) | O(n) | 元素所需要的类型要实现 Comparable 接口或 Comparator 接口 |\n| CopyOnWriteArraySet | 数组 | 插入顺序 | 无 | O(n) | O(n) | 不使用同步方法也能保证线程安全 |\n\n#### List 接口\n- List 是一组 `有序` 的对象集合。\n- 列表中的每个元素都有特定的位置，且 List 接口定义了一些方法，用于查询或设定特定位置 (或叫索引) 的元素。从这个角度看，`List 对象和数组类似`，不过`列表的大小能按需变化`。\n- 和集不同，列表允许出现重复的元素。\n- 遍历循环和迭代，即依次处理每个元素。\n\n```Java\nListCollection<String> c = new ArrayList<String>();\nfor( String word : c ) {\n\tSystem.out.println(word); // 遍历循环\n}\n\n// for 循环迭代判断是否还有下一个值\nfor( Iterator<String> i = c.iterator(); i.hasNext(); ) {\n\tSystem.out.println( i.next() );\n}\n\nIterator<String> iterator = c.iterator();\nwhile( iterator.hasNext() ) {\n\tSystem.out.println( iterator.next() );\n}\n```\n\n- 实现 List 接口的类\n\n| 类 | 表示方式 | 随机访问 | 备注 |\n| :---- | :---- | :---- | :---- |\n| ArrayList | 数组 | 能 | 无 |\n| LinkedList | 双向链表 | 否 | 高效插入和删除 |\n| CopyOnWriteArrayList | 数组 | 能 | 线程安全；遍历快；修改慢 |\n\n#### Map 接口\n- 映射，一系列键值对，一个键对应一个值。\n- Map 是参数化类型，即 `Map<k,v>`，`k` 表示映射中键的类型，`v` 表示键对应的值，如：`Map<String, Integer>`\n- 实现 Map 接口的类\n\n| 类 | 表示方式 | Null 键 | Nul 值 | 备注 |\n| :--- | :---- | :---- | :---- | :---- |\n| HashMap | 哈希表 | 是 | 是 | 无 |\n| ConcurrentHashMap | 哈希表 | 否 | 否 | 线程安全 (详情请参阅 JDK API) |\n| ConcurrentSkipListMap | 哈希表 | 否 | 否 | 线程安全 (详情请参阅 JDK API)  |\n| EnumMap | 数组 | 否 | 是 | 键为何枚举类型 |\n| LinkedHashMap | 哈希表 + 列表 | 是 | 是 | 保留插入或访问顺序 |\n| TreeMap | 红黑树 | 否 | 是 | 按照键排序 |\n| IdentityHashMap | 哈希表 | 是 | 是 | 比较使用 `==`，而非 `equal()` |\n| WeakHashMap | 哈希表 | 是 | 是 | 不会阻止垃圾回收键 |\n\n#### Queue、BlockingQueue 接口\n- 队列是一组有序的元素，提取元素时按顺序从对头读取。队列插入元素的顺序实现，可分类为：\n\t- FIFO：先进先出，队列。\n\t- LIFO：后进先出，栈。\n- 把元素添加队列中：\n\t- `add()`：Collection 接口定义，常规的方式添加元素。对有界的队列来说，若队列已满，这个方法会抛出异常。\n\t- `offer()`：Queue 接口中定义，若有界的队列已满，这个方法返回 false。\n\t- `put()`：BlockingQueue 接口中定义，会 `阻塞操作`。即队列已满，而无法插入元素，put() 方法会一直等待，直至其他线程从队列中移除元素，有空间插入新元素为止。\n- 把元素从队列中移除：\n\t- `remove()`：\n\t\t- Collection 接口定义，把指定元素从队列中移除。\n\t\t- Queue 接口中定义，则是没有参数的 remove()，移除并返回对头元素 (出队)，若队为空，则抛出 `NoSuchElementException` 异常。\n\t- `poll()`：Queue 接口中定义，移除并返回对头元素，若队列为空，则返回 null。\n\n\t> BlockingQueue 接口中定义了超时版的 poll()，指定时间内等待元素添加到空队列中。\n\t\n\t- `take()`：BlockingQueue 接口定义，用于删除并返回队头元素 (出队)，若队为空，`这个方法会等待`，直到其他线程把元素添加到队列中为止。\n\t- `drainTo()`：BlockingQueue 接口定义，把队列中的所有元素都移除，再把这些元素添加到指定的 Collection 对象中。这个方法不会阻塞操作。\n- 查询：就队列而言，查询时访问队头元素，但不将其从队列中移除。\n\t- `element()`：Queue 接口中定义，作用时返回队头元素，但不将其从队列中移除，若队为空，则抛出 `NoSuchElementException` 异常。\n\t- `peek()`：Queue 接口中定义，作用和 element() 类似，但队为空时返回 null。\n- 特别说明：  \n\t- 如果想在操作成功前一直阻塞，应选 put() 与 take()。  \n\t- 如果想检查方法返回值，应选 offer() 和 poll()。  \n\n#### 实现方法\n`java.util.Collections` 类定义了一些静态实用方法，用于处理集合。\n\n- `包装集合`：把集合本身没有提供的功能绑定到集合上。即包装集合能提供的功能有：线程安全性、写保护和运行时类型检查。\n\t- 为包装集合提供线程安全性。\n\t- 不能修改底层集合，即得到的集合只读。\n\n\t```Java\n\t// 为包装集合提供线程安全性\n\tList<String> list = Collections.sychronizedList( \n\t\tnew ArrayList<String>() );\n\tSet<Integer> set = Collections.sychronizedSet( \n\t\tnew HashSet<Integer>() );\n\tMap<String, Integer> map = Collections.sychronizedMap( \n\t\tnew HashMap<String, Integer>() );\n\t\n\t// 不能修改底层集合，即得到的集合只读\n\tList<Integer> primes = new ArrayList<Integer>();\n\tList<Integer> readonly = Collections.unmodifiableList(primes);\n\tprimes.add( Arrays.asList(2, 3, 4, 5) ); // 正常\n\treadonly.add(23); // 抛出 UnsupportedOperationException 异常\n\t```\n\n- `操作集合`\n\n\t```Java\n\t// 二分查找前，必须使列表变有序\n\tCollections.sort(list);\n\tint pos = Collections.binarySearch(list, \"key\");\n\t\n\t// 把 list2 的元素复制到 list1，覆盖 list1\n\tCollections.copy(list1, list2); \t\n\t\n\t// 使用对象 obj 去填充 list\n\tCollections.fill(list, obj); \n\t\n\t// 找出集合 list 中最大、小的元素\n\tCollections.max(list);\n\tCollections.min(list);\n\t\n\t// 反转列表\n\tCollections.reverse(list); \n\t\n\t// 打乱列表\n\tCollections.shuffle(list);\n\t```\n\n- `返回集合`：若方法需返回一个集合，若返回值为空，建议返回空集合，代替返回 null。\n\n\t```Java\n\tSet<Integer> set_list = Collections.emptySet();\n\tList<String> list = Collections.emptyList();\n\tSet<String, Integer> map_list = Collections.emptyMap();\n\t``` \n\n#### 数组和辅助方法\n- 对象组成的数组和集合的作用类似，二者间可相互转换。\n\t\n\t```Java\n\tString[] str = {\"this\", \"is\", \"a\", \"sample\"}; // 数组\n\t\n\t// 数组转换成大小不可变的列表\n\tList<String> list = Array.asList(str); \n\t\n\t// 创建一个大小可变的副本\n\tList<String> list2 = new ArrayList<String>(list); \n\t```\n- Array 类还定义了一些静态方法\n\n\t```Java\n\tArray.sort(array); // 原地排序数组\n\tArray.binary(array, 7); // 在 Array 中找 7\n\tArray.equals(array1, array2); // 比较两个数组是否相等\n\t```\n\n## 玖 处理常见的数据格式\n\n### 文本\n#### 字符串的特殊句法\n- 字符串字面量：Java 允许把一系列字符放在双引号中创建字面量字符串对象。\n\n\t```Java\n\tString pet = \"Cat\";\n\tsystem.out.println(\"Dog\",.length());\n\t```\n\n- toString()：作用是方便把任何对象转换成字符串。\n- 字符串连接：\"StringA\" + \"StringB\"。  \n连接字符串时，先创建一个使用 StringBuilder 对象表示的一个工作区 (暂存区)，其内容和原始字符串中的字符序列一样。然后更新 StringBuilder 对象，把另一个字符串中的字符源加到末尾。最后，在 StringBuilder 对象上调用 toString() 得到一个新字符串。\n\n#### 字符串的不可变性\nString1 + String2 => StringBuilder对象 (暂存区) => toString()，则输出的字符串为 `String1 + String2`。\n\n#### 正则表达式 \n- 正则表达式，用于扫描和匹配文本的搜索模式。\n- Java 使用 Pattern 类表示正则表达式。\n\n\t> `?` 为元字符。\n\t\n\t```Java\n\tPattern p = Pattern.compile(\"honou?r\");\n\tString caesarUK = \"For Brutus is an honourable man.\";\n\tMatcher mUK = p.matcher(caesarUK);\n\t\n\tString caesarUS =\"For Brutus is an honorable man.\";\n\tMathcher mUS = p.matcher(caesarUS);\n\tSystem.out.println(\"Matches.UK Spelling?\" + mUK.find());\n\tSystem.out.println(\"Matches.US Spelling?\" + mUS.find());\n\t```\n\n- 正则表达式元字符\n\n| 元字符 | 意义 | 备注 |\n| :---- | :--- | :--- |\n| ? | 可选字符出现0或1次 |  |\n| * | 前一个字符出现0或多次 |  |\n| + | 前一个字符出现1或多次 |  |\n| {m, n} | 前一个字符出现m到n次 |  |\n| \\d | 一个数字 |  |\n| \\D | 一个不是数字的字符 |  |\n| \\w | 一个组成单词的字符 | 数字、字母和 _ |\n| \\W | 一个不能组成单词的字符 |  |\n| \\s | 一个空白字符 |  |\n| \\S | 一个不是空白的字符 |  |\n| \\n | 换行符 |  |\n| \\t | 制表符 |  |\n| . | 任意一个字符 | 在 Java 中不包括换行符 |\n| [] | 方括号中的任意字符 | 叫作字符组 |\n| [^] | 不在方括号中的任意一字符 | 叫作排除字符组 |\n| () | 构成一组模式元素 | 叫作组 (捕获组) |\n| 或的符号 | 定义可选值 | 实现逻辑或 |\n| ^ | 字符串的开头 |  |\n| $ | 字符串的末尾 |  |\n\n{% note success %} 工欲善其事，必先利其器。为更快速、准确上手正则，这些现成的、实用的表达式助你一臂之力。\n[技匠. 知道这20个正则表达式能让你少写 1,000 行代码. 2016. jianshu.com](https://www.jianshu.com/p/e7bb97218946)\\\\(^{[2]}\\\\) {% endnote %}\n\n\n\n### 数字和数学运算\n#### Java 表示整数类型的方式\n以 Java 的 Byte 类型为例，说明 Java 是如何表示整数的。Byte 类型的数字占8位，设定 Byte 类型数字的最高位用于表示正、负号。故有128个正数，128个负数。\n\n```Java\nbyte b = 0b0000_0001; // 1\nbyte b = 0b0111_1111; // 127\n\n// 负数是以补码形式存储的，而正数，原码、反码、补码一致\nbyte b = 0b1111_1111; // -1\nbyte b = 0b1111_1111; // -2\n```\n\n## 拾 处理文件和 I/O\n\n### 网络\nJava 对网络支持的核心 API 在 java.net 包中，其他扩展 API 则由 javax.net 包提供，尤其是 `java.net.ssl`。\n\n#### 超文本传输协议 (HTTP)\n- URL 是关键的类，其原生支持 `http://`、`https://`、`ftp://`、`file://` 形式的 URL。\n\n```Java\n// 下载指定 URL 对应页面的内容\nURL url = new URL(\"http://www.baidu.com\");\ntry( InputStream in = url.openStream() ) {\n    File.copy(in, Paths.get(\"output.txt\"));\n} catch( IOException ex ) {\n    ex.printStackTrace();\n}\n\n// 深入低层控制，可使用 URLConnection 类\ntry {\n    URLConnection conn = url.openConnection();\n    String type = conn.getContectType();\n    int length = conn.getContentLength();\n    InputStream in = conn.getInputStream();\n} catch( IOException e ) {\n    // TODO\n}\n```\n\n- HTTP 定义了多个“请求方法”，客户端使用这些操作远程资源。这些方法有：`GET`、`POST`、`HEAD`、`PUT`、`DELETE`、`OPTIONS`、`TRACE`。\n\t- GET：用于取文档，不能执行任何副作用；\n\t- HEAD：与 GET 的作用一样，但不返回主体，用于检查 URL 对应的网址的页面是否有变化。\n\t- POST：把数据发给服务器处理。\n\n#### 传输控制协议 (TCP)\n- TCP具有下列特征 (特性)\n\t- 基于连接：数据属于单个逻辑流 (连接)。\n\t- 保证送达：`三次握手`，如果未收到数据包，会一直重新发送，知道送达为止。\n\t- 错误检查：能检测到网络传输导致的损坏，并自动修复。\n\n- Java 使用 Socket 和 ServerSocket 类表示 TCP\n\n\t- 例1：我们既要从客户端套接字中读取数据，也要把数据写入客户端套接字，且构建请求时要遵守 HTTP 标准 (RFC 2616)。\n\n\t```Java\n\tString hostname = \"www.example.com\";\n\tint port = 80;\n\tString filename = \"/index.html\";\n\t\n\ttry(\n\t    Socket socket = new Socket(hostname, port);\n\t    BufferedReader from = new BufferedReader(\n\t        new InputStreamReader( socket.getInputStream() )\n\t    );\n\t    PrintWriter to = new PrintWriter(\n\t        new OutputStreamWriter( socket.getOutputStream() )\n\t    );\n\t) {\n\t    to.print(\"GET\" + filename + \n\t        \"HTTP/1.1\\r\\nHost:\" + hostname + \"\\r\\n\\r\\n\");\n\t    to.flush();\n\t    \n\t    for( String l = null; (l = from.readLine()) != null; ) {\n\t        System.out.println(l);\n\t    }\n\t}\n\t```\n\n\t- 例2：在服务器端，可能需要处理多个连入连接。编写一个服务器的主循环，使用 `accept()` 从操作系统中接收一个新连接。随后，要迅速把这个新连接传给单独的类处理，好让服务器主循环继续监听新连接。\n\n\t```Java\n\t// 处理连接的类\n\tprivate static class HTTPHandler implements Runnable { \n\t    private final Socket socket;\n\t    HTTPHandler(Socket client) {\n\t        this.socket = client;\n\t    }\n\t    public void run() {\n\t        try(\n\t            Buffered in = new BufferedReader(\n\t                new InputStreamReader( socket.getInputStream() )\n\t            );\n\t            PrintWriter out = new PrintWriter(\n\t                new OutputStreamWriter( socket.getOutputStream() )\n\t            );\n\t        ) {\n\t            out.print(\"HTTP/1.0 200 /r/nContent-Type:text/plain\");\n\t            String line;\n\t            while( (line = in.readLine()) != null ) {\n\t                if( 0 == line.length()) break;\n\t                out.println(line);\n\t            }\n\t        } catch( Exception e ) {\n\t            // TODO\n\t        }\n\t    }\n\t}\n\t\n\t// 服务器主循环\n\tpublic static void main(String[] args) {\n\t    try{\n\t        int port = Integer.parseInt( args[0] );\n\t        ServerSocket ss = new ServerSocket(port);\n\t        for(;;) {\n\t            Socket client = ss.accept();\n\t            HTTPHandler handler = new HTTPHandler(client);\n\t            new Thread(handler).start();\n\t        }\n\t    } catch( Exception e ) {\n\t        // TODO\n\t    }\n\t\n\t}\n\t```\n\t\n#### 互联网协议 (IP)\n- 传输数据的最低层标准，抽象了把自己从 A 设备移动到 B 设备的物理网络技术。\n- 与 TCP 不同，IP 数据包不能保证送达，在传输路径中，任何过载系统都可能会丢掉数据包。\n- Java 使用 `DatagramSocket` 类实现这种功能。\n\n## 参考资料\n[[1] 周志明. 深入理解 Java 虚拟机(第2版)[M]. 机械工业出版社, 2013](https://book.douban.com/subject/24722612/)  \n[[2] 技匠. 知道这20个正则表达式能让你少写 1,000 行代码. 2016. jianshu.com](https://www.jianshu.com/p/e7bb97218946)","tags":["java"],"categories":["Programme"]},{"title":"笔记 | C语言复习框架 ( 应试篇 )","url":"/2017/04/C-Programming-Design-Learning.html","content":"\n## 序言\n\n从标题中透漏的信息可知，本系列文章是围绕 “C语言” 展开学习的笔记总结，且目的很明确，笔记内容偏应试，适用于计算机等级考试、考研专业课(C语言)等的复习使用。文章推崇总结性、比对性的学习方法，对于模糊的知识模块需自行查阅参考书目，深化理解或可达到理想的效果。\n\n<!-- More -->\n\n针对C语言程序，推荐几本辅导复习的书目：\n\n> 基础篇\n\n- 《谭浩强:C语言程序设计》: 必不可少的经典教程，权威性的标准答案源。( 因讨论条件而异，如编译系统不同，部分题目的答案就具有了争议性 )\n- 《明解C语言》: 入门基础教学。值得称赞的是，每个知识模块都符有实例，且实例的源码结构清晰，代码规范及注释到位，非常适合入门使用。\n\n> 进阶篇\n\n- 《征服C指针》: C语言的学习过程中，指针的运用是最大的难关。无论是在实际应用、应试中都是不可忽视的。对于作者前桥和弥，其一针见血的文风，在掌握一定基础之后，是深入了解C语言的一位不可多得 “良师益友” ( 书中有不少作者交谈式的独白，别有一番阅读风味 )。\n\n\n## 总览\n\n- [壹 程序设计和C语言](#1-壹-程序设计和C语言)\n- [贰 程序之魂：算法](#2-贰-程序之魂：算法)\n- [叁 简单的C语言程序设计](#3-叁-简单的C语言程序设计)\n- [肆 选择结构程序设计](#4-肆-选择结构程序设计)\n- [伍 循环结构程序设计](#5-伍-循环结构程序设计)\n- [陆 数组](#6-陆-数组)\n- [柒 函数](#7-柒-函数)\n- [捌 指针](#8-捌-指针)\n- [玖 构造类型：用户自己建立数据结构](#9-玖-构造类型：用户自己建立数据结构)\n- [拾 文件处理](#10-拾-文件处理)\n\n\n## 1 壹 程序设计和C语言\n### 1.1 计算机程序与语言\n程序：计算机能识别和执行的指令。  \n语言：人和计算机交流、人和计算机能识别的语言。\n计算机语言发展阶段：   \n \n| 机器语言 | 符号语言 | 高级语言 ( 面向过程、面向对象 ) |\n| :----: | :----: | :----: |\n| 0和1指针 | 英文、数字表示指令 | 人类自然语言和数字语言 |\n\n### 1.2 C语言\n- 特点\n\t- 语言简洁、紧凑，使用方便、灵活\n\t- 运算符丰富 ( 单目、双目、三目运算符 )\n\t- 数据类型丰富 ( 整型、浮点型、字符型、数组类型、指针类型、结构体类型、共用体类型、枚举型 )\n\t- 结构体控制语句\n\t- 直接访问物理地址 ( 对硬件直接操作 )\n\t- 可移植性好\n\n- 结构\n\t- 以程序由一个或着多个 `源文件` 组成。 \n\t\n\t> 源文件中包括：  \n\t> 预处理命令 ( #include、#define、#typedef等 )  \n\t> 全局声明 ( 全局变量、局部变量 )  \n\t> 函数定义 ( 参考函数原型 )\n\t\n\t- 函数是C程序的主要组成部分。\n\t- 一函数包括 `函数首部` 和 `函数体`。  \n\t\n\t> 函数体包括：  \n\t> 声明部分和执行部分。\n\t \n\t- 程序总是从main函数开始执行的。  \n\t\n\t> main函数有且仅有一个。\n\t\n\t- C程序对计算机的操作有C语言完成。\n\t- 数据声明和语句必须有分号 ( 作为结束 )。\n\t- C本身不提供输入输出语句。\n\n### 1.3 程序设计的任务\n1. 问题分析  \n2. 设计算法  \n3. 编写程序  \n4. 对源文件编辑、编译 ( \\*.obj ) 和连接 ( \\*.exe )  \n5. 运行程序并分析结果  \n6. 编写程序文档 \n\n\t[注] 对于编译，预编译和连接的概念及比对： \n\n\t- 编译：检索语言错误；把源程序转为二进制形式的目标程序。\n\t- 预编译：通过预处理得到的信息与程序其他部分一起，组成完整的、可以正式编译的源程序。\n\t- 连接：与函数库相连接。\n \n \n## 2 贰 程序之魂：算法\n### 2.1 引入\n- 对数据的描述：所用数据的类型和数据的 `组织形式`。 \n \n\t> 组织形式：数据结构 -- 特定关系的数据元素的集合\n\n- 对操作的描述：计算机进行操作的步骤 -- 算法\n\n- 从简理解：`数据结构 + 算法 = 程序`\n\n\n### 2.2 算法\n- 概念：对特定问题求解的方法和描述。\n\n- 特征  \n\t- 有穷性：`有穷时间` 执行结束；\n\t- 确定性：算法 `唯一执行路径`，既相同输入执行相同路径；\n\t- 可行性：`有限次`；\n\t- 零或一个以上的 `输入`；\n\t- 一个或以上的 `输出`；\n\n- 要求  \n\t- 正确性；\n\t- 可读性；\n\t- 健壮性；\n\t- 效率与低存储量需求 ( 时间复杂度和空间复杂度 )  \n\n- 时间复杂度\n\t- 时间复杂度：也称渐进时间复杂度，即算法执行时间的增长率和 f(n) 的增长率相同。  \n\t- 渐进时间复杂度：`T(n) = Big O(f(n))`  \n\t- f(n)为问题规模n的某个函数。  \n\t- 算法中的基本运算( 最深层循环内的语句 )的频度与T(n)同数量级。  \n\n- 空间复杂度\n\t- 空间复杂度：算法所需存储空间的量度。  \n\t- 渐进空间复杂度：`S(n) = Big O(f(n))`  \n\t- 原地工作：额外空间相对输入的数据量来说是常数。\n\t\n### 2.3 三种基本结构和改进流程图\n- 三种基本结构\n\t- 顺序结构；\n\t- 选择结构；\n\t- 循环结构：当型循环结构 / 直到型循环结构；\n- 改进的流程图：N-S流程图\n\n### 2.4 结构化程序设计方法\n- 自顶向下；\n- 逐步细化；\n- 模块化设计：`分而治之`；\t`注意模块独立性`\n- 结构化编码；\n\n\n## 3 叁 简单的C语言程序设计\n### 3.1 数据的表现形式及运算\n#### 3.1.1 常量\n- 概念：程序运行期间，其值不能改变。\n- 类型    \n\t- 整型常量  \n\t- 字符常量 ( 与常变量作比对 **[注释1]** )\n\t\t- 普通字符  \n\t\t- 转移字符：\\n, \\t, \\012 (8进制), \\x41 (16进制)\n\t\t- 符号常量：`#define PI 3.14159`\n\t- 实型常量\n\t\t- 10进制小数形式：3.14L\n\t\t- 指数形式(科学计数法):  \n\t\t8.7e-25(正确);  \n\t\t8.7e-2.5(错误)；  \n\t\t87e+25(正确);  \n\n#### 3.1.2 变量\t\n\n> 先定义，后使用\n\n- 包含属性\n\t- 数据类型 ( 整型、浮点型、字符型 )  \n\t- 存储类别 ( 自动变量，静态变量 )  \n- 概念：程序运行期间，其值可以改变。\n- 类型\n\t- 常变量：变量存在期间其值不能改变。 `const int a = 10`  \n\t- 自动变量与静态变量  \n\t- 全局变量与局部变量  \n\t\n\t> 从存储位置、生存周期、作用区域讨论差异性。**[注释2]**\n\t\t\n- 标识符  \n一个对象的名称。除关键字外，字符、数字和下划线组成。且要求只能是字母或下划线开头。\t\n\n> [注释1] 符号常量与常变量的比较。\n\n| 符号常量 | 常变量 |\n| :---- | :---- |\n| 不占内存单元，预编译后符号不复存在 | 占存储单元 |\n| 不能重新赋值 | 不能改变其值 |\n\n> [注释2] 局部变量与全局变量，自动变量与静态变量，内部函数与外部函数的比较。\n\n| 局部变量 | 全局变量 |  |\n| :---- | :---- | :---- |\n| 存放于动态存储区 | 存放于静态存储区 | 位置 |\n| 在定义函数内起作用 | 自定义位置开始，本文件起作用 | 作用域 |\n| 函数调用完释放内存 | 程序结束时释放内存 | 生存期 |\n\n- 静态的局部变量，存放于静态存储区，程序结束时释放内存。\n- 静态的全局变量，不是因声明static，而误解全局变量才存放于静态存储区。\n- 局部变量，声明存储类型指变量存储区以及产生的生存期问题。  \n- 全局变量，声明存储类型指变量作用域的扩展问题。\n\t\n| 自动变量 | 静态变量 |\n| :---- | :---- |\n| 1. 声明该变量的语句块被执行结束释放内存(**栈**) | 1. 程序结束时才释放内存 |\n| 2. 每次函数调用时赋值 | 2. 保留上一步的赋值 |\n|  | 3. 在编时赋予初值0或'\\0' | \n\n[注] 对比malloc()函数分配的内存，需调用free()函数释放内存。(**堆**)\n\n| 内部函数 | 外部函数 (default) |\n| :---- | :---- |\n| 本文件内使用(不限位置) | 可供其他文件使用(不限位置) |\n| 定义：static 函数类型 函数名 | 定义：(extern) 函数类型 函数名 |\n\t\n#### 3.1.3 数据类型\n\n- 基本类型\n\n|  | 关键字 | 字节 | 取值范围 |\n| :---- | :---- | :---- | :---- |\n| 整型 | int | 2/4 | $-2^{15}$ ~ $-2^{15}-1$ / $-2^{31}$ ~ $2^{31}-1$ |\n|      | unsigned int | 2/4 | 0 ~ $-2^{16}-1$ / 0 ~ $-2^{32}-1$ |\n| 字符型 | char | 1 | $-2^7$ ~ $2^7-1$ |\n|  | unsigned char | 1 | 0 ~ $2^8-1$ |\n| 单浮点 | float (有效小数：6) | 4 | -- |\n| 双浮点 | double (有效小数：15) | 8 | -- |\n\n- 关于基本类型的特别说明： \n\t- 字符是按其ASCII形式存储的。\n\t- 单浮点定义：float a = 3.14f\n\t- 双浮点定义：double a = 3.14\n\t- 长浮点定义：long double a = 3.14L\n\n- 派生类型\n\t- 指针类型：指向函数的指针、多重指针\n\t- 数组类型：指针数组\n\n- 构造类型\n\t- 结构体类型\n\t- 共同体类型\n\t- 枚举类型  \n\t\n\t> [详情见第玖章：构造类型](#9-玖-构造类型：用户自己建立数据结构)\n\t\n- 类型转换：  \n\t- 低精度向高精度转换；  \n\t- 强制转换括号加类型；   `int a = (int)3.14`  \n\t- 多类型变量混合运算，取最高精度的类型；\n  \n\n## 4 肆 选择结构程序设计\n### 4.1 关系运算符及其优先次序\n- 各类运算符的优先级：\n\t- 单目运算符 > 双目运算符 (算术、关系、逻辑) > 三目运算符\n\t\n\t- 优先级由高到低排序：  \n\t初等运算符：`()，[]，->，.`  \n\t单目运算符：`!，++，--，~`  \n\t算术运算符：`*，/，%`，`+，-`  \n\t关系运算符：`>，<，>=，<=`，`!=，==`  \n\t逻辑运算符：`&&，||`  \n\t条件运算符：`a > b : a : b`  \n\t赋值运算符：`a += 1`  \n\t逗号运算符：`(a,b)`  \t\n\t\n\t- 结合方式  \n\t自左向右：`初等、单目、关系、逻辑、逗号运算符`\n\t自右向左：`条件、赋值运算符`  \n\t\n\t> 同一级的运算符，由结合方式决定优先级。\n\n### 4.2 表达式\n- 算术表达式：先乘除模，后加减，再由“自左向右”原则运算。\n\n- 混合运算\n\t- 优先级：遵循各运算符的优先次序。\n\t- 结合性：算术运算符 (自左向右)；赋值运算符 (自右向左)。\n\t- 不同类型的混合运算：结果的类型为**最高精度**的数据类型。\n\n### 4.3 运算符与表达式\n- 关系运算符和关系表达式 ( a+b>c ) -> True or False?  \n\n\t> 0表示假，!0表示真。\n\n- 逻辑运算符和逻辑表达式\n\t- 逻辑运算：5 && 4 => 1；5 && 0 => 0；  \n\t- 按位逻辑：5 & 4 => 4；  \n\t\n\t> [注] 关于逻辑运算与按位逻辑的比较  \n\t> \n\t> * 优先级：按位逻辑运算 > 逻辑运算  \n\t> * max = a & b；min = a | b    \n\n- 条件运算符和条件表达式：a > b ? a : b\n\n### 4.4 选择结构的嵌套 \n- if语句只有两个分支可供选择，else总是与它上面最近的未配对的if()配对。\n\n\t```C\n\tif(express1){\n\t\tif(express2){\n\t\t\t...\n\t\t} else {\n\t\t\t...\n\t\t}\n\t} else {\n\t\tif(express3){\n\t\t\t...\n\t\t} else {\n\t\t\t...\n\t\t}\n\t}\n\t```\n\t\n- switch语句实现多分支选择结构\n\n\t```C\n\tswitch(express1){ // 整型、字符型\n\t\tcase 常量/常量表达式:语句1；break; // break为拦截作用\n\t\tcase 常量/常量表达式:语句2；break;\n\t\tdefault: 语句3;\n\t}\n\t```\n\n## 5 伍 循环结构程序设计\n### 5.1 while 语句实现\n```C\nexpress1;\nwhile(express2){\n\texpress3;\n\t...\n}\n```\n### 5.2 for 语句实现循环\n```C\nfor(express1; express2; express3){\n\t...\n}\n```\n### 5.3 do...while() 语句实现循环\n```C\nexpress1;\n\ndo{\n\texpress3;\n} while(express2);\n```\n### 5.4 break、continue与goto语句\n- break：从循环体内跳出循环体。多层嵌套循环，跳出相邻一层循环。\n- continue：提前结束本次循环。\n- goto：跳出多层循环。\n\n\n## 6 陆 数组\n### 6.1 概念\n- 一组有序数据的集合。\n- 数组中每一元素同属一个数据类型。\n- sname[0] <=> *(p+0) <=> 第一个数组元素。  \n\n### 6.2 定义\n#### 6.2.1 一维数组\n- 定义  \n类型符 数组名[常量表达式]\t --> 正确  \n类型符 数组名[变量] --> 错误，不能为变量\n \n- 初始化  \n\n\t```C\n\tint array[] = {1, 2, 3, 4, 5};  \n\tin array[5] = {0}; // 5个元素都为0。\n\t```\n\n- 引用 \n \n\t```C\n\tint *p = &array[0];\t// 等同于 int *p = array;\n\tp++;\t// 指针运算\n\t*(p+i);\t// 取第i位元素\n\t```\n\n#### 6.2.2 二维数组\n- 定义：类型符 数组名[常量表达式][常量表达式]\n\n- 初始化\n \n\t```C\n\tint array[2][2] = { {1, 2}, {3, 4} };\n\tint array[2][2] = { 1, 2, 3, 4 };\n\tint array[][2] = { {1, 2}, {3, 4} };\t// 既只允许最外层元素个数定义时为空\n\t\n\tint array[][2] = { {0}, {3, 4} };\t// 正确 \n\tint array[][2] = { {}, {3, 4} };\t// 错误\t```\n\t\n- 引用\n\n\t```C\n\tint num = array[1][1];\n\tint *p = array;\n\t*(*(p+j)+j); // 等同于array[i][j];\n\t```\n\n#### 6.2.3 字符数组\n- 定义：char array[10]; <=> int array[10];\n\n\t> 字符型数组是以整型形式存放的 (ASCII)。\n  \t\n- 初始化  \n\t- 字符串常量不可以数组形式取具体位置进行元素修改。\n\t- ( array == \"Hello\" ) => True or False ? \n\t\n\t> False，array 与字符串常量比较的是内存地址。\n\n\t```C\n\tchar array[0] = 'A';\n\n\tchar array[] = {\"Hello\"};\n\t// 字符数组的存储情况：| H | e | l | l | o | \\0 |\n\t// sizeof() -- 6\n\t// strlen() -- 5\n\n\tchar array[] = {'H', 'e', 'l', 'l', 'o'};\n\t// sizeof() -- 5\n\t// strlen() -- 5\n\t\t\n\tint array[] = {\"Hello\"};\n\t// sizeof() -- 4\n\t// strlen() -- 1\n\t\t\n\tint array[] = {'H', 'e', 'l', 'l', 'o'};\n\t// sizeof() -- 20\n\t// strlen() -- 4\n\t\t\n\tchar *array = \"Hello\"; // 字符串常量\n\t```\n \n- 引用 \n\t- 若字符数组中，存在'\\0'两个或以上，系统则以第一次出现的位置提前终止字符输出。  \n\t- stdin 和 gets() 搭配，可获得换行符、空格等字符。 (需结束标记符来终止输入)\n  \n\t```C\n\tscanf(\"%c\", &array[0]);\n\tprintf(\"%c\", array[0]);\n\n\tscanf(\"%s\", array);\n\tprintf(\"%s\", array);\n\t```\n\n- 应用  \n\t- gets(字符数组) -- 输入一字符串到字符数组中\n\t- puts(字符数组) -- 输出一字符串到终端\n\t- strlen(字符数组) -- 测一字符串的实际长度\n\t- strcat(char \\*src1, const char \\*src2);\n\t\n\t> 数组src2后接于src1，src1中的'\\0'被覆盖。且数组src1必须足够大，以容纳数组src2。\n\t\n\t- strcpy(char \\*src1, const char \\*src2);\n\t\n\t> 数组src1必须足够大，以容纳数组src2。\n\t\n\t- strcmp(const char \\*src1, const char \\*src2);\n\t\n\t> 实际为ASCII的比较，其返回值为 <0、==0，>0 的情况。\n\t\n\t- strlwr(字符串) -- 将字符串中大写字母转为小写字母\n\t- strupr(字符串) -- 将字符串中小写字母转为大写字母\n\t- atoi(字符串) -- 字符串转int型\n\t- atol(字符串) -- 字符串转long型\n\t- atof(字符串) -- 字符串转double型   \n\n\t> [注]  \n\t> 1) 字符串处理函数需加入头文件：`#include <string.h>`.   \n\t> 2) 需掌握字符串函数自定义方法实现。  \n\t> 3) 大部份字符串处理函数多数以标记量'\\0'为临界点，若字符数组中含两个或或以上，需注意实际的结果。  \n\t> 4) 引用atoi()、atol()、atof()函数需引用`#include <stdlib.h>`\n\n## 7 柒 函数\n### 7.1 为什么要用函数\n- 模块化程序设计：每一函数实现一特定的功能，函数的名称既反映功能。\n- 更好地代码复用：使用库函数；使用自己编写的函数。 \n \n\t> 代码复用：减少重复编码程序段的工作量。 \n\t>  \n\t> [说明]  \n\t> \n\t> 对于所有完成相同功能的组件，应抽象出一个接口，它们都实现该接口。  \n\t> 具体在Java中，所有完成相同功能的组件都 `实现该接口` 或 `从该抽象类中的继承`。\n\t\n### 7.2 定义函数  \n\n> 建立存储空间的声明\n\n- 定义函数：`函数返回类型` `函数名` `函数参数` `函数体` (变量定义、声明，执行语句)\n\t- 函数返回类型：基本数据类型 / void型；  \n\t- 函数名：驼峰式命名法；  \n\t- 函数参数：实参、形参.  \n\n### 7.3 函数声明\n\n> 不需要建立存储空间的声明\n\n- 函数原型 (Prototype)：函数返回类型、函数名、参数类型、参数个数、参数顺序\n\n- 函数声明的方法\n\t- 使用函数原型；\n\t- 同一源文件，在调用该函数的前面定义 (可打包到自定义头文件中).\n\n### 7.4 函数调用\n- 嵌套调用、递归调用 (直接或间接调用该函数本身)\n- 实参和形参\n\t- 概念  \n\t实参：常量、变量或表达式、函数 (返回值)  \n\t形参：函数调用期间临时分配内存，值从实参中获得，调用结束后释放内存空间。\n\t- 实质：值传递、地址传递\n\n\n## 8 捌 指针\n### 8.1 指针是什么\n- 指针变量：保存变量地址的变量。\n- 指针类型\n\t- 指针类型的变量：存放地址\n\t- 指针类型的值：对应内存地址存放的值\n\t  \n\t> 在 swap(int \\*a, int \\*b); 的案例中可以形象说明两者的区别。\n\n### 8.2 指针移动 (运算：加、减)\n对指针加一、减一运算，即地址会增加或减少一单位长度。单位长度具体具体指当前指针所指向数据类型的所占空间大小。\n\n### 8.3 指针类型\n#### 8.3.1 空指针\n确保没有指向任何一个对象的指针。通常以宏定义NULL(0)表示空指针的常量值。\n\n关于NULL、0和'\\0'，大部分情况都为零。特别地，  \n\n```C\nint *p = 0;\t// 正确，编译器将指针指向内存地址为0处。 \nint *p = 3;\t// 错误，赋值的数据类型不相符。\n```\n\n#### 8.3.2 指针类型的派生\n- 指向函数的指针  \n\n\t```C\n\tvoid (*func(int));\n\t```\n\n- 指向数组的指针(多重指针)  \n\n\t```C\n\tint (*p)[5];\n\t```\n\n#### 8.3.3 数组类型的派生\n- 指针数组\n\n\t```C\n\tint *p[5]; // 存放5个指向int类型的指针。\n\t```\n\n- 用英语解读各种各样的C语言声明\n\n| C语言 | 英语表示 | 中文表示 |\n| :---- | :---- | :---- |\n| int huge; | huge is int | hoge是int型 |\n| int huge[10]; | huge is array[10] of int | hoge是int型的数组 |\n| int huge[2][4]; | huge is array[2] of array[4] of int | hoge是int型的数组的数组 |\n| int \\*huge[10]; | huge is array[10] of point to int | hoge是指向int型的指针的数组(存放指针变量) |\n| int (\\*huge)[10]; | hoge is pointer to array[10] of int | hoge是指向int型的数组的指针 |\n| int func(int a); | func is function(int a) returning int | func是返回int型的函数 |\n| int (*func)(int a); | func is pointer to function(int a) returning int | func是指向返回int型值的函数的指针 |\n\n\n### 8.4 指针的应用\n#### 8.4.1 指针与数组\n- 一维  \n\n\t```C\n\tp[i]\t// 等同于 *(p+i)\n\ti[p]\t// 等同于 *(i+p)\n\t&p[i]\t// 等同于 (p+i)，即第i个元素的地址\n\t```\n- 二维  \n\n\t```C\n\thuge[i]\t\t// 等同于 *(huge+i)，即第i行的首地址\n\t*(huge+i)[j]\t// 等同于 *(*(p+j)+j)，即 huge[i][j]\n\t```\n\n#### 8.4.2 指针与字符串\n##### 8.4.2.1 字符指针变量\n- 定义\n\n\t```C\n\tchar *array = \"World\";\n\tarray = \"hello\";\t// 改变指向\n\t\t\n\tchar array[] = \"Hello\";\n\tarray = \"World\";\t// 错误的做法\n\t\n\tchar *array = \"Hello World\";\n\tarray += 6;\t\t// 改变指向 (首地址改变)\n \t```\n \n##### 8.4.2.2 字符数组\n- 定义: int array[] = \"Hello\";\n\n- 使用：printf(\"%c\", array[0]);\n\n\t> 字符指针变量的值是不能改变的，即已是字符串常量。\n\n\t```C\n\tchar *array = \"Hello\";\n\tarray[0] = 'W';\n\t```\n\n#### 8.4.3 指针与函数\n##### 8.4.3.1 作为参数\n即传递的是指向初始元素的指针。\n\n- 数组名作函数参数\n\t- int func( int array[] ); \n\t- int func( int \\*array );\n- 多维数组作函数参数\n\t- int func( int (\\*huge)[10] );\n\t- int func( int huge[2][4] );\n- 指向函数的指针作函数参数\n\t- int func( int (\\*p)(int) ); \n- 指针数组作main函数形参\n\t- int func( int argc, char \\*argv[] );\n\t   \n\t> argv: 文件名 + 其他参数\n\t\n- 字符指针作函数参数\n\n##### 8.4.3.2 作为返回值\n返回指针值的函数，即返回的是地址。\n\n> [如] 返回的指针指向结构体变量、字符变量等。\n\n\n## 9 玖 构造类型：用户自己建立数据结构\n### 9.1 结构体类型\n- 定义\n\n\t```C\n\tstruct Name {\n\t\tint num;\n\t\tchar word[59];\n\t} *p, name[5];\n\t```\n\n- 初始化：所有成员一起赋值。\n\n- 使用\n\n\t```C\n\tname[i].num;\n\tp->word[i];\n\t(*p).num;\n\t\n\tstruct Name *tmp;\n\ttmp = name;\n\t(tmp++)->num;\t// 先'++'操作，后'->'操作\n\t```\n\t\n- 大小：成员变量所占内存长度总和。\n\n### 9.2 共用体类型\n- 定义\n\n\t```C\n\tunion Name {\n\t\tint num;\n\t\tdouble digital;\n\t\tchar word;\n\t} *p, name[5];\n\t```\n\n- 初始化：只允许给一个成员变量赋值。\n\n\t```C\n\tunion Name tmp = {10};\n\tunion Name tmp = {.word = 'Y'};\n\tt.digital = 2.0;\n\tt.word = 'N';\t// 最终的赋值\n\t```\n\n- 使用\n\n\t```C\n\tname[i].num;\n\tp->word[i];\n\t(*p).num;\n\t```\n\t\n- 大小：成员变量所占内存长度最大者。\n\n> [注] 关于结构体、共用体类型的内存长度问题，遵循4字节倍数的原则进行内存布局对齐。  \n> [如]  \n> sizeof(struct Name) = 64 (63)  \n> sizeof(union Name) = 4 (4)\n\n### 9.3 枚举类型\n- 定义\n\t\n\t```C\n\tenum Week {\n\t\tsun, mon, tue, wed, thu, fir, sat // 默认参数从0开始\n\t} week;\n\t```\n\t\n- 初始化\n\n\t```C\n\tenum Week {\n\t\tmon = 1, tue = 2, wed = 3, thu = 4, fir = 5, sat = 6，sun = 7 // 默认参数从0开始\n\t} week;\n\t```\n\n- 使用：week.mon;\n\n### 9.4 Typedef 声明新类型名\n- 含义：引入变量别名，而不是另外地给变量分配空间。\n- 使用\n\t\n\t```C\n\ttypedef int Integer;\n\ttypedef long Integer;\t// 若编译器中，int为2字节，满足移值需求可以long型替换。\n\tInterger num = 1;\n\t```\n\n- 与 #define 宏定义的区别  \n\t- \\#typedef：编译阶段处理  \n\t- \\#define：预编译阶段处理，实质是字符串替换 \n\t\n## 10 拾 文件处理\n### 10.1 文件与流\n- stdin -- 标准输入流 -- 用于读取普通输入的流，在大多数环境中为键盘输入。scanf()与getchar()等函数会从这个流中读取字符。\n\n- stdout - 标准输入流 -- 用于写入普通输入的流，在大多数环境中为输出至显示器界面。printf()、puts()与putchar()等函数会向这个流写入字符。\n\n- stderr -- 标准错误流 -- 用于写出错误的流，在大多数环境中为输出至显示器界面。\n\n### 10.2 文件分类\n- ASCII文件 (文本文件)：每一字节存放一字符的ASCII代码。\n- 二进制文件\n\t- 优：节约存储空间\n\t- 劣：精度有限\n\n\t> [如] 整数10000  \n\t> ASCII形式存储空间为 5 字节   \n\t> 二进制形式存储空间为 4 字节  \n\t\n### 10.3 文件类型指针：FILE型\n- 需引用 `#include <stdio.h>`\n\n> [注] 指向文件的指针变量并不是指向外部介质上的数据文件开头，而是指向内存中的文件信息区的开头。\n\n### 10.4 打开文件\n- 原型：FILE \\*fopen(const char \\*filename, const char \\*mode);\n- 定义：FILE \\*fp = fopen(\"example.txt\", \"r\");\n\n| 文件类型 | 文本文件 | 二进制文件 |\n| :---- | :---- | :---- |\n| 模式 | r   w   a | rb   wb   ab |\n|  | 只读；只写(文件存在，则长度清零)；追加 | 只读；只写(文件存在，则长度清零)；追加 |\n|  | r+   w+   a+ | rb+   wb+   ab+ |\n|  | 读和写(打开文件)；读和写(建立文件；文件存在，则长度清零)；读和写(打开文件) | 读和写(打开文件；文件存在，则长度清零)；读和写(建立文件)；读和写(打开文件) |\n\n### 10.5 关闭文件\n- 原型：int fclose(FILE *stream);\n\t- 返回值 ( True：0；False：EOF(-1) )  \n\t- 数据存储的过程：数据 --> 缓存区 (充满) --> 文件\n\t- 若不关闭文件，将会造成数据丢失。 \n\t- 若突然关闭文件，缓存区传输到文件的过程给中断，造成数据丢失。\n\n### 10.6 顺序读写数据文件\n- 格式化读取文件\n\n\t```C\n\tint fscanf(FILE *stream, const char *format, ...);\n\t// 返回值：\n\t// Ture - 返回成功赋值的输入项数\n\t// False - 返回文件结束标记EOF(-1)\n\t\n\t// 使用实例\n\tfscanf(fp, \"%s%lf%lf\", name, &height, &weight);\n\t```\n\t\n- 格式化写入文件\n\n\t```C\n\tint fprintf(FILE *stream, const char *format, ...);\n\t// 返回值：\n\t// Ture - 返回发送的字符数\n\t// False - 返回文件结束标记EOF(-1)\n\t\n\t// 使用实例：获得当前运行时间，并存入文本中\n\ttime_t current = time(NULL);\n\tstruct tm *timer = Localtime(&current);\n\t\n\t// 将日历时间time_t型的值转换为分解时间tm结构体类型的值\n\t// 其中，tm结构体为：\n\tstruct tm {\n\t\tint tm_sec;\t// 秒(0 - 61)\n\t\tint tm_min;\t// 分 (0 - 59)\n\t\tint tm_hour;\t// 时 (0 - 24)\n\t\tint tm_mday;\t// 日 (1 - 31)\n\t\tint tm_mon;\t// 月 (0 - 11)\n\t\tint tm_year;\t// 从1900至今，经历了多少年\n\t\tint tm_wday;\t// 星期 (0 - 6)\n\t\tint tm_yday;\t// 经历天数 (从1月1日计起)\n\t\tint tm_tm_isdst;\t// 夏时令 (夏季时间将提前1小时)\n\t};\n\t\n\tfprintf(fp, \"%d %d %d %d %d\", \n\t\ttimer->tm_year + 1900, timer->tm_mon + 1,\n\t\ttimer->tm_day, timer->tm_hour, \n\t\ttimer->tm_min, timer->tm_sec);\n\tfclose(fp);\n\t```\n\n- 读入／写入一个字符\n\n\t```C\n\tint fgetc(FILE *stream);\t// 读入一个字符\n\t\n\tint fputc(FILE *stream);\t// 写入一个字符\n\t// 返回值：\n\t// Ture - 返回所读的字符数\n\t// False - 返回文件结束标记EOF(-1)\n\t```\n\t\n- 用二进制方式向文件读写一组数据\n\n\t```C\n\tsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\n\t// 从ptr指向的数组中将最多nmemb个长度为size的元素写入stream指向的流中。\n\t\n\tsize_t fread(const void *ptr, size_t size, szie_t nmemb, FILE *stream);\n\t// 从stream流中读取nmemb个长度为size的元素写入到ptr数组。\n\t```\n\n### 10.7 随机读写数据文件\n#### 10.7.1 文件位置标记及其定位\n- 文件位置标记：文件头、读写当前位置、文件尾\n\n- 文件位置标记的定位：fseek(文件类型指针, 位移量, 起始点);\n\t- 文件开始位置 -> SEEK_SET -> 0  \n\t- 文件当前位置 -> SEEK_CUR -> 1  \n\t- 文件末尾位置 -> SEEK_END -> 2  \n\n#### 10.7.2 随机读写\n结合fseek()与fread()函数实现。\n\n> [如] 读取第1，3，5，7，9个学生数据并输出。\n\n```C\nfor(i = 0; i<10; i+=2){\n\tfseek(fp, i*sizeof(struct Student), 0);\n\tfread(&student[i], sizeof(struct Student), 1, fp);\n}\n```","tags":["考试"],"categories":["Programme"]}]