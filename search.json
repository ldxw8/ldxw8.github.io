[{"title":"读书笔记 - Android 源码设计模式","url":"%2F2018%2F01%2FDesign-Pattern-Based-on-Android.html","content":"\n* 更新进度\n\t* 2018.01.30 - 完成序言；\n\t* 2018.01.31 - 更新第壹章；\n\t* 2018.02.05 - 更新第贰章，共 18 / 23 种设计模式；\n \n## 序言\n\n在你接触过的安卓项目当中，如监听器、适配器、迭代器等并不陌生，然而它们无不体现着设计模式的精髓。设计与模式的结合，往往与设计能力与代码质量息息相关。同理，逆过来思考此类问题，对于一些优秀项目、源码的理解障碍往往是对其设计 (逻辑、性能、解耦等) 的理解，而非源码本身。而作为开发者，知其然知其所以然，这也正是我们深入学习设计模式的理由之一。\n\n当然，我们还要正视学习设计模式的心态。掌握了各种设计模式，并不代表你的设计能力与代码质量就会突飞猛进，同样在项目中运用设计模式也不是生搬硬套就解决问题了，在《 [Head First 设计模式](https://book.douban.com/subject/2243615/) 》一书中，则把设计模式的使用心智分为：初学者、中级人员和悟道者，虽有“玄学”的味道，但也恰当。即没有最好的模式，而是你综合众多因素，根据经验、方法来筛选合适的设计模式与你的项目结合，运用。\n\n最后，对于设计模式的学习，不要局限于《 [Android 源码设计模式](https://book.douban.com/subject/26644935/) 》本身，你可以搭配一些经典论文、综述，或者书籍，以至于怀疑一个问题的正误，多比对、多思考，以得到最精确的理解。\n\n<!-- more -->\n\n- 推荐书目：\n\t- 《 设计模式之禅 》：待补充\n\t- 《 设计模式（可复用面向对象软件的基础）》：待补充\n\n\n## 总览\n\n- [零 本书架构](#零-本书架构)\n- [壹 面向对象编程六大原则](#壹-面向对象编程六大原则)\n- [贰 二十三种设计模式解析](#贰-二十三种设计模式解析)\n- [叁 MVC 与 MVP 模式](#叁-MVC与MVP模式)\n\n\n## 零 本书架构\n\n### 面向对象六大原则\n\n- 单一职责原则\n> 优化代码第一步。即就一个类而言，应该有且仅有一个引起它变化的原因。\n\n- 开闭原则\n> 让程序更稳定，更灵活。即软件中的对象（类、模块、函数等）应该对于扩展是开放的，但对于修改是封闭的。\n\n- 里氏替换原则\n> 构建扩展性更好的系统。\n\n- 依赖倒置原则  \n> 让项目拥有变化能力，即依赖抽象，不依赖具体实现。\n\n- 接口隔离原则\n> 系统拥有更高灵活性。\n\n- 迪米特原则\n> 也称为「最少知识原则」。即一个对象应对其他对象有最少的了解。\n\n### 二十三种设计模式\n\n| 模式名称 | 一句话描述 |\n| :--- | :--- |\n| 单例模式 | 一个类只有一个实例 |\n| Build 模式 | 自由拓展你的项目 |\n| 原型模式 | 使程序运行更高效 |\n| 工厂方法模式 | 生成复杂对象 |\n| 抽象工厂模式 | - |\n| 策略模式 | 时势造英雄 |\n| 状态模式 | 随遇则安 |\n| 责任链模式 | 使编程更有灵活性 |\n| 解释器模式 | 化繁为简的翻译机 |\n| 命令模式 | 让程序畅通执行 |\n| 观察者模式 | 解决、解耦的钥匙 |\n| 备忘录模式 | 编程中的后悔药 |\n| 迭代器模式 | 解决问题的第三者 |\n| 模块方法模式 | 抓住问题的核心 |\n| 访问者模式 | 数据结构与操作分离 |\n| 中介者模式 | 调解者模式或调停者模式 |\n| 代理模式 | 委托模式 |\n| 组合模式 | 物以类聚 |\n| 适配器模式 | 得心应手粘合剂 |\n| 装饰模式 | 动态给对象添加额外职责 |\n| 享元模式 | 对象共享，避免创建多对象 |\n| 外观模式 | 统一编程接口 |\n| 桥接模式 | 连接两地的交通枢纽 |\n\n### MVC 与 MVP 模式\n\n\n## 壹 面向对象编程六大原则\n\n### 单一职责原则\n\n- Single Responsibility Principle，SRP.\n- 即就一个类而言，应该仅有一个引起它变化的原因。\n\n> 如何划分一个类，一个函数的职责？每个人的经验不同，观点看法也不同，故视具体任务而定。但它也有一些基本的知道原则：  \n> \n> * 两个完全不一样的功能就不应该放到同一个类中。\n> * 一个类中应该是一组相关性很高的函数、数据的封装。\n\n### 开闭原则\n\n- Open Close Principle，OCP.\n- 即软件中的对象（类、模块、函数等）应该对于扩展是开放的，但对于修改是封闭的。\n- 勃兰特·梅耶. 《面向对象软件构造》中提倡：\n\t- 新的或改变的特性应通过新建不同的类实现，新建的类可通过 `继承` 的方式来重用原类的代码。\n\t- 已存在的实现类对于修改是封闭的，但新的实现类可通过 `覆写父类的接口` 应对变化。\n\n> 开闭原则知道我们，当软件需变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。\n\n### 里氏替换原则\n\n> **往往开闭原则与里氏替换原则是生死相依、不离不弃的。**\n\n\n- Liskov Substitution Principle，LSP。\n- 所有引用基类的地方必须能透明地使用其子类的对象。\n\n```Java\npublic abstract class View {\n\tpublic abstract void draw();\n\tpublic void measure(int width, int height) {\n\t\t// 测量视图的大小\n\t}\n}\n\npublic class Button extends View {\n\tpublic draw() {\n\t\t// 绘制按钮\n\t}\t\n}\n\npublic class Windows {\n\tpublic show(View child) {\n\tchild.draw();\n\t}\n}\n```\n\n> 上述例子中，任何继承自 View 类的子类都可以设置给 show 方法，即里氏替换。这样千变万化的 View 传递给 Window，Window 只管组织 View，并显示在屏幕上。\n\n### 依赖倒置原则\n\n- Dependence Inversion Principle，DIP.\n- 一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节。\n- 依赖倒置原则的几个关键点：\t\n\t- 高层模块不应该依赖低层模块，两者都应以来其抽象（接口或抽象类）\n \n\t> 高层模块指调用端，低层模块指实现类。\n\t\n\t- 抽象不应该依赖细节\n\t- 细节应依赖抽象\n- 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系。一句话概括：`面向接口编程，面向抽编程`\n\n```Java\n/*\n * 设计一款实现图片缓冲功能的接口，具体的缓冲实现方式、细节，根据实际情况编写。\n */\n\npublic interface ImageChache {\t// ImageCache 缓存抽象\n\tpublic Bitmap get(String url);\n\tpublic void put(String url, Bitmap bmp);\n}\n\npublic class MemoryCache implements ImageCache {\n\t// 根据实际需求，再实现具体细节\n}\n\npublic class ImageLoader {\n\t// 图片缓存类，依赖抽象，不依赖细节\n\tImageCache mCache = new MemoryCache();\n\t\n\tpublic void displayImage(String url, ImageView imageView) {\n\t\tBitmap bmp = mCache.get(url);\n\t\tif(null == bmp){\n\t\t\tdownloadImageAsync(url, imageView);\n\t\t} else {\n\t\t\timageView.setImageBitmap(bmp);\n\t\t}\n\t}\n\t\n\tpublic void setImageCache(ImageCache cache) {\n\t\tmCache = cache;\n\t}\n}\n```\n\n### 接口隔离原则\n\n- Interface Segregation Principles，ISP.\n- 类间的依赖关系应建立在最小的接口上。ISP 将非常庞大、臃肿的接口拆分成更小的和更具体的接口。IPS的目的是系统解开耦合。\n\n> 如上例中，ImageLoader 中的 ImageCache，ImageLoader 只需要知道该缓存对象有存、取缓存图片的接口即可，其他一概不管。\n\n### 迪米特原则\n\n- 一个对象应对其他对象有最少的了解、即类的内部如何实现与调用者、依赖者没关系，调用者或依赖者之需知道它需要的方法即可，其他一概不管。\n\n- 图 1-1 展示了租客、中介与房间相互之间的需求关系。\n\n\t![租客、中介与房间关系](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_1-1.png )\n\t<center>图 1-1 租客、中介与房间关系</center>   \n\n\t因为租客只需要房子，即把需求转达中介，对房子具体的租金、维修、签约等交由中介处理，租客不需要再了解细节。改进效果见图 1-2。\n\n\t![租客、中介与房间关系](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_1-2.png )\n\t<center>图 1-2 改进：租客、中介与房间的关系</center>  \n\n## 贰 二十三种设计模式解析\n\n### 单例模式\n#### 单例模式的定义\n- 确保某 `一个类只有一个实例` ，而且自行实例化并向整个系统提供这个实例。\n\n\t> `一个类只有一个实例` ：避免产生多个对象消耗过多资源，如访问 I/O 和数据库等资源。\n\n\n#### 单例模式 UML 类图\n![单例模式示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-1.png )\n<center>图 2-1 单例模式示意图</center> \n\n- 实现单例模式主要有如下几个关键点：\n\t- `构造函数` 不对外开放，一般设为 `私有` ；\n\t- 通过一个 `静态方法` 或者 `枚举返回` 单例类对象；\n\t- 确保单例类的对象有且只有一个，尤其多线程环境下；\n\t- 确保单例类对象在 `反序列化` 时不会重新构建对象；\n\t\n\t> 序列化：将对象的状态信息转换为可以存储或传输的形式的过程。一般将一个对象存储至一个储存媒介，例如档案或是记亿体缓冲等。在网络传输过程中，可以是字节或是XML等格式。  \n\t> \n\t> 反序列化：而字节的或XML编码格式可以还原完全相等的对象。这个相反的过程又称为反序列化。\n \n#### 单例模式的简单示例\n例如一个公司只有一个 CEO，一个应用只有一个 Application 对象等。下面以公司里的 CEO 为例来简单演示，即一个公司可有几个 VP，无数个员工，但 CEO 只有一个。\n\n```Java\n// 员工的基类\npublic class Staff { \n\tpublic void work(){\n\t\t// 忽略执行细节\n\t}\n}\n\n// 副总裁类\npublic class VP extends Staff {\n\tpublic void work() {\n \t\t// 覆写执行细节\n\t}\n}\n\n// 饿汉单例模式：声明静态对象时已初始化\npublic class CEO extends Staff { // 公司保证只有一个 CEO\n\tprivate static final CEO mCeo = new CEO();\n\tprivate CEO(){}\n\tpublic static CEO getCeo() {\n\t\treturn mCeo;\n\t}\n\tpublic void work() {\n\t\t// 覆写执行细节\n\t}\n}\n\n/*\n * 实际中使用：\n * CEO 类不能通过 new 的形式构造对象，只能通过 CEO.getCeo() 函数获取。\n * CEO 对象是静态对象，并在声明时已初始化，保证 CEO 对象的唯一性。\n */\n \nStaff ceo1 = CEO.getCeo();\t\nStaff ceo2 = CEO.getCeo();\n```\n\n#### 单例模式的其他实现方式\n##### 懒汉模式\n- 声明一静态对象；\n- 调用 getInstance() 方法初始化 ( 用时才初始化，即惰性处理机制 )\n\n```Java\n// 懒汉单例模式：用时才初始化，即惰性处理机制\npublic class Singleton {\n\tprivate static Singleton instantce;\n\tprivate Singleton() {}\n\t\n\t// 添加 synchronized 关键字，即 getInstance() 是一个同步方法\n\tpublic static synchronized Singleton getInstance() {\n\t\tif( null == instance ) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n- 懒汉单例模式的优缺点：  \n\t- 优点 - 使用时才实例化，一定程度上节约资源。  \n\t- 缺点 - 每次调用 getInstance() 都进行同步，造成不必要同步开销。\n\n##### Double CheckLock (DCL)\n\n```Java\npublic class Singleton {\n\t// private static Singleton sInstance = null;\n\tprivate volatile static Singleton sInstance = null; // 保证 sInstance 对象每次都是从主内存存、读取。\n\t\n\tprivate Singleton() {}\n\t\n\tpublic void doSomething() {\n\t\tSystem.out.println(\"do sth.\");\n\t}\n\t\n\tpublic static Singleton getInstance() {\n\t\tif( null == sInstance ) { // 避免不必要同步\n\t\t\tsynchronized(Singleton.class) {\n\t\t\t\tif( null == sInstance ) { // 此处判空操作，是因为 Java 编译器允许处理器乱序执行，具体解析见注解\n\t\t\t\t\tsInstance = new Singleton();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sInstance;\n\t}\n}\n```\n\nDCL 又称「丑陋的优化」？  \n\nDCL 虽一定程度解决了资源消耗，多余同步、线程安全等问题，但某种情况下还是会出现失效问题 ( 双重检查锁定(DCL) )，即称「丑陋的优化」。\n\n- 线程A，执行 `sInstance = new Singleton();`，编译器会编译成多条汇编指令，具体汇编指令的分工为：  \n\t- Step.01 给 Singleton 实例分配内存；  \n\t- Step.02 调用 Singleton() 的构造函数；  \n\t- Step.03 将 sInstance 对象指向分配的内存空间；  \n\t\n- 然而 Java 编译器允许处理器乱序执行，即有「1-2-3」或「1-3-2」的执行顺序。\n- 若执行「1-3-2」的顺序，这样会使 DCL 的优化失效，即第三步执行完毕，sInstance 非空，线程B取走 sInstance。再使用时就会报错。\n\n##### 静态内部类单例模式\n\n```Java\npublic class Singleton {\n\tprivate Singleton() {}\n\tpublic static Singleton getInstance() {\n\t\treturn SingletonHolder.sInstance;\n\t}\n\tprivate static class SingletonHolder { // 静态内部类\n\t\tprivate static final Singleton sInstance = new Singleton();\n\t}\n}\n```\n\n第一次加载 Singleton 的 getInstance() 方法才会使 sInstance 被初始化。因此，第一次调用 getInstance() 方法会导致虚拟机加载 SingletonHolder 类.\n\n> 内部类是延时加载的，只会在第一次使用时加载，不使用不加载。这样，即保证了线程安全，又保证单例对象唯一性，同时也延迟单例的实例化。\n\n##### 枚举单例\n\n```Java\n// 默认枚举实例的创建是线程安全的，并且在任何情况下它都是一个单例。\npublic enum SingletonEnum {\n\tINSTANCE;\n\tpublic void doSomething() {\n\t\tSystem.out.println(\"do sth.\");\n\t}\n}\n```\n\n#### 总结\n- 不管以哪种形式实现单例模式，它们的核心原理都是将 `构造函数私有化` ，并通过 `静态方法获取一个唯一的实例` 。\n\n\t> 获取实例的过程须保证线程安全，防止反序列化导致重新生成实例对象等。\n\n- 选择哪种实现形式取决项目本身，如是否是复杂的并发环境、JDK 版本是否过低、单例对象的资源消耗等。\n- 单例模式的优缺点\n\t- 优点  \n\t1) 只生成一个实例，减少系统的性能开销；  \n\t2) 当一对象的产生需要较多资源时，如读取配置、产生其他依赖对象时，可通过应用启动时直接产生一个单例对象，永久驻留内存。  \n\t- 缺点  \n\t1) 单例模式一般没有接口，扩展性难；  \n\t2) 单例对象若持有 Context，那么很容易引发内存泄漏，此时需注意传递给单例对象的 Context 应该是 `Application.Context` 。\n \n### Bulider 模式\n#### Bulider 模式的定义\n- 创建型设计模式。\n- 将一个复杂对象的 `构建` 与它的 `表示` 分离，使得同样的构建过程可以创建不同的表示。\n- Builder 模式是一步步创建一个复杂对象的，它允许用户在不知内部构建细节的情况下，可以更精细地控制对象的构造流程。\n\n#### Builder 模式的使用场景\n- 产品类非常复杂，或产品类中调用顺序不同产生不同的作用，这时需要使用 Builder 模式。\n- 初始化一个对象特别复杂，如参数多，且很多参数都具有默认值。\n\n#### Builder 模式的UML类图\n![Builder模式示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-2.png )\n<center>图 2-2 Builder 模式示意图</center> \n\n#### Builder 模式的简单实现\n\n便于理解，本示例的 UML 类图见图 2-3。\n\n![计算机组装过程](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-3.png )\n<center>图 2-3 计算机组装过程</center> \n\n```Java\n/*\n * 下述程序以计算机组装过程简化为：构建主机，设置操作系统，设置显示器。\n */\n \n// 计算机抽象类，即 Product 角色\npublic abstract class Computer {\n\tprotected String mBoard;\n \tprotected String mDisplay;\n \tprotected String mOS;\n \tprotected Computer() {}\n \tpublic void setBoard(String board) { // 设置 CPU 核心数\n \t\tmBoard = board;\n \t}\n \tpublic void setDisplay(String display) { // 设置内存\n \t\tmDisplay = display;\n \t}\n \tpublic abstract void setOS();\n \t@override\n \tpublic String toString() {\n \t\treturn \"Computer[...]\";\n \t}\n }\n \n// 具体的 Computer 类 - MacBook\npublic class Macbook extends Computer {\n \tprotected Macbook() {}\n \t@override\n \tpublic void setOS() {\n \t\tmOS = \"MAC OSX 10.10\";\n\t}\n}\n \n// 抽象 Builder 类\npublic abstract class Builder {\n \tpublic abstract class Builder {\n \t\tpublic abstract void buildBoard(String board); // 设置主机\n \t\tpublic abstract void buildOS(); // 设置操作系统\n \t\tpublic abstract void buildDisplay(String display); // 设置显示器\n \t\tpublic abstract Computer create(); // 创建 Computer\n\t}\n}\n \n// 具体的 Builder 类 - MacbookBuilder\npublic class MacbookBuilder extends Builder {\n \tprivate Computer mComputer = new Macbook();\n \tpublic void buildBoard(String board){\n \t\tmComputer.setBoard(board);\n \t}\n \tpublic void buildDisplay(String display) {\n \t\tmComputer.setDisplay(display);\n \t}\n \tpublic void buildOS() {\n \t\tmComputer.setOS();\n \t}\n \tpublic Computer create() {\n \t\treturn mComputer;\n \t}\n}\n \n// Director 类，负责构造 Computer\npublic class Director {\n \tBuilder mBuilder = null;\n \tpublic Director(Builder builder) {\n \t\tmBuilder = builder;\n \t}\n \tpublic void construct(String board, String display) {\n \t\tmBuilder.buildBoard(board);\n \t\tmBuilder.buildDisplay(display);\n\t\tmBuilder.buildOS();\n \t}\n}\n\n// 客户端实现\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tBuilder builder = new MacbookBuilder(); // 构造器\n \t\tDirector pcDirector = new Director(builder); // Director\n \t\t// 封装构建过程\n \t\tpcDirector.construct(\"英特尔主板\", \"Retina 显示器\");\n \t\tSystem.out.println(\"Computer Info: \" + builder.create().toString());\n \t}\n}\n```\n\n#### Builder 模式实战\n```Java\n/*\n * 知名图片加载库：Universal-Image-Loader\n */\n\nImageLoaderConfiguration config = new ImageLoaderConfiguration\n.Builder(context) // 用户只能通过 Builder 对象构建 ImageLoaderConfiguration 对象，这就是构建和表示相分离\n.threadPriority(Thread_NORM_PRIORITY_2)\n.denyCacheImageMultipleSizesInMemory()\n.discCacheFileNameGenerator( new MD5FileNameGenerator() )\n.tasksProcessingOrder(QueueProcessingType.LIFO)\n.bulider();\n\nImageLoader.getInstance().init(config);\n```\n\n#### 总结\n- Builder 模式，通过作为配置类的构建器将配置的构建和表示分离开来，同时也将配置从目标类中隔离出来，避免过多的 Setter 方法暴露在目标类当中。\n- Builder 模式的优缺点\n\t- 优点  \n\t1) 良好的封装性，不必知道产品内部组成的细节；  \n\t2) 建造者独立，易于扩展。\n\t- 缺点  \n\t1) 产生多余 Builder 对象及 Director 对象，消耗内存。\n\n### 原型模式\n#### 原型模式的定义\n- 创建性的模式。\n- 定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。\n\t- 原型拥有样板实例，可克隆内部属性一致的对象。\n\t- 原型模式多用于创建复杂的或构建耗时的实例，即复制一个已经存在的实例可使程序运行更高效。\n\n#### 原型模式的使用场景\n- 类初始化需消耗非常多的资源 ( 数据、硬件资源等 )。\n- 通过 new 产生一个对象需要非常繁琐的数据准备或访问权限。\n- 一个对象需提供其他对象访问，且各调用者可能都需修改其值时，可考虑用原型模式或拷贝多个对象以供调用者使用，即 `保护性拷贝` 。\n\n#### 原型模式的 UML 类图\n![Builder模式示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-4.png )\n<center>图 2-4 原型模式的 UML 类图</center> \n\n#### 原型模式的简单实现\n便于理解，本示例的 UML 类图见图 2-5。\n\n![WordDocument文档编辑器](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-5.png )\n<center>图 2-5 WordDocument 文档编辑器</center> \n\n```Java\n/*\n * WordDocument 具有文字、图片编辑功能的简单文档处理类。且为保护源文件，其可在克隆对象上作内容修改。\n */\n\npublic class WordDocument implements Cloneable {\n\t// WordDocument 扮演 ConcretePrototype 角色\n\t// Cloneable 扮演 Prototype 角色\n\tprivate String mText; // 文本\n\tprivate ArrayList<String> mImages = new ArrayList<String>(); // 图片名列表\n\tpublic WordDocument() {\n\t\t// 忽略实现细节\n\t}\n\t@Override\n\tprotected WordDocument clone() {\n\t\ttry {\n\t\t\tWordDocument doc = (WordDocument) super.clone();\n\t\t\tdoc.mText = this.mText;\n\t\t\tdoc.mImages = this.mImages;\n\t\t\treturn doc;\n\t\t} catch(Exception e) {\n\t\t}\n\t\treturn null;\n\t}\n\tpublic String getText() {\n\t\treturn mText;\n\t}\n\tpublic void setText(String mText) {\n\t\tthis.mText = mText;\n\t}\n\tpublic List<String> getImage() {\n\t\treturn mImages;\n\t}\n\tpublic void addImage(String img) {\n\t\tthis.mImages.add(img);\n\t}\n\tpublic void showDocument() {\n\t\tSystem.out.println(\"Text:\" + mText);\n\t\tSystem.out.println(\"Images List:\");\n\t\tfor(String imgName:mImages) {\n\t\t\tSystem.out.println(\"image name:\" + imgName);\n\t\t}\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tWordDocument originDoc = new WordDocument();\n\t\t\n\t\t/* Partion A start */\n\t\toriginDoc.setText(\"This is a Aircle\");\n\t\toriginDoc.addImage(\"Image A\");\n\t\t/* Partion A end */\n\t\toriginDoc.showDocument();\n\t\t\n\t\tWordDocument secDoc = originDoc.clone();\n\t\tsecDoc.showDocument();\n\t\tsecDoc.setText(\"This is a Paper\"); // 只是改变了引用指向\n\t\tsecDoc.showDocument();\n\t\toriginDoc.showDocument(); // 还是输出 Partion A 的结果\n\t}\n}\n```\n\n> 注：通过 clone() 拷贝对象时并不会执行构造函数。如果在构造函数中需要一些特殊的初始化操作类型，在使用 Cloneable 实现拷贝时，注意构造函数不会执行的问题。\n\n#### 浅拷贝和深拷贝\n- 浅拷贝：上述例子实际上只是一个浅拷贝，也称 `影子拷贝`，即只是副本文档引用原始文档的字段。\n\n ![浅拷贝示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-6.png )\n <center>图 2-6 浅拷贝示意图</center> \n\n ```Java\n secDoc.setText(\"This is a Paper.\");\n secDoc.addImage(\"Image B\");\n secDoc.showDocument(); // Case 1\n originDoc.showDocument(); // Case 2\n\n // Case 1，2 都增加了图片 “Image B”，原因是 secDoc 只是单纯指向了 this.mImages\n ```\n\n- 深拷贝：为了解决浅拷贝所带来的“问题” ( 视具体问题而定 )，引入深入拷贝。\n\n ```Java\n @Override\n protected WordDocument clone() {\n \ttry {\n \t\tWordDocument doc = (WordDocument) super.clone();\n \t\tdoc.mText = this.mText;\n \t\t// doc.mImages 指向 mImages 的一份拷贝，而不是 this.mImages 本身\n \t\tdoc.mImages = (ArrayList<String>) this.mImages.clone();\t\t\n \t\treturn doc;\n \t} catch(Exception e) {\n \t}\n \treturn null;\n }\n ```\n\n#### 原型模式实战\n```Java\n/*\n * 在线用户信息修改 (需登录后修改用户信息)\n */\n\n// 用户实体类\npublic class User {\n\tpublic int age;\n\tpublic String name;\n\tpublic String phoneNum;\n\tpublic Adress,adress;\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"User[age=...]\";\n\t}\n}\n\n// 登录接口\npublic interface Login (\n\tvoid login();\n)\n\npublic class LoginImpl implements Login {\n\t@Override\n\tpublic void login() {\n\t\tUser loginedUser = new User(); // 登录服务器，获取用户信息\n\t\tloginedUser.age = 12;\n\t\tloginedUser.name = \"Mr.Sample\";\n\t\tloginedUser.address = new Address(\"BeiJing\", \"HaiDing\", \"Garden Rd\");\n\t\t\n\t\t// 登录完成后，将用户信息设置到 Session:\n\t\tLoginSession.getLoginSession()\n\t\t\t.setLoginedUser(loginedUser)\n\n\t}\n}\n\n// 登录 Session\npublic class LoginSession {\n\tstatic LoginSession sLoginSession = null;\n\tprivate User longinedUser; // 已登录用户\n\tprivate LoginSession() {}\n\tpublic static LoginSession getLoginSession() {\n\t\tif(null == sLoginSession) {\n\t \t\tsLoginSession = new LoginSession();\n\t \t}\n\t \treturn sLoginSession;\n\t}\n\t\n\t// 包级私有：即不加任何修饰符，该模式(默认访问模式)下，只允许在同一包中进行访问\n\tvoid setLoginedUser(User user) { // 设置已登录用户信息，不对外开放\n\t\tloginedUser = user;\n\t}\n\t\n\tpublic User getLoginedUser() {\n\t\treturn loginedUser;\n\t}\n}\n\n/* Partion A : 以下是实际执行部分，可能在不同包的某个类下执行 */\n\n// 获取已登录的 User 对象\nUser newUser = LoginSession.getLoginSession().getLoginedUser();\n// 更新用户信息\nnewUser.address = new Adress(\"BeiJing\", \"ChaoYang\", \"DaWang Rd\");\n```\n\n用户信息的更新，限定于与 LoginSession 类在同一包下才能执行，即 Partion A 的操作，使这样的限定失效。我们可作以下改进：\n\n- 在 User 类中实现 Cloneable 接口。\n- 在 LoginSession 中将 getLoginedUser() 改为 `return loginedUser.clone()` ，即在任何地方调用，获得的都是用户拷贝的对象，修改只是作用于拷贝的对象。\n\n\n```Java\n// 实现 Cloneable 接口\npublic class User implements Cloneable { // 用户实体类\n\tpublic int age;\n\tpublic String name;\n\tpublic String phoneNum;\n\tpublic Adress,adress;\n\t\n\t@Override\n\tpublic User clone() {\n\t\tUser user = null;\n\t\ttry {\n\t\t\tuser = (User) super.clone();\n\t\t} catch(CLoneNotSupportedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn user;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"User[age=...]\";\n\t}\n}\n\npublic class LoginSession { \n\t// 即管在任何地方调用，获得的都是用户拷贝的对象\n\tpublic User getLoginedUser() {\n\t\treturn loginedUser.clone();\n\t}\n}\n```\n#### 总结\n- 原型模式的优缺点\n\t- 优点 - 原型模式是在内存中二进制的拷贝，比 new 一个对象性能更优。\n\t- 缺点 - 内存中拷贝，构造函数是不会执行的。\n\n### 工厂方法模式\n#### 工厂方法模式的定义\n- 创建型设计模式。\n- 定义一个用于创建对象的接口，让子类决定实例化哪个类。\n\n#### 工厂方法模式的使用场景\n- 复杂对象的创建，而用 New 就可以完成创建的对象则不必使用工厂方法了。\n\n#### 工厂方法模式的 UML 类图\n工厂方法模式的 UML 如图 2-7 所示。\n\n![浅拷贝示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-7.png )\n<center>图 2-7 工厂方法模式 UML 类图</center> \n \n```Java\npublic abstract class Product {\n\tpublic abstract void method();\n}\npublic class ConcreteProductA extends Product { // 具体产品 A\n\t@Override\n\tpublic void method() {\n\t\tSystem.out.println(\"我是具体的产品A.\");\n\t}\n}\npublic class ConcreteProductB extends Product { // 具体产品 B\n\t@Override\n\tpublic void method() {\n\t\tSystem.out.println(\"我是具体的产品B.\");\n\t}\n}\n\npublic abstract class Factory { // 抽象工厂类\n\t/*\n\t * @return 具体的产品对象\n\t */\n\t public abstract Product createProduct();\n}\npublic class ConcreteFactory extends Factory {\n\t@Override\n\tpublic Product createProduct() {\n\t\t// 返回具体产品 A 或者具体产品 B\n\t\t// return new ConcreteProductA();\n\t\t// return new ConcreteProductB();\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tFactory factory = new ConcreteFactory();\n\t\tProduct p = factory.createProduct();\n\t\tp.method();\n\t}\n}\n```\n\n另外，我们可以利用反射的方式实现多工厂方法模式，具体见下述代码。\n\n```Java\npublic abstract class Factory {\n\n\t/*\n \t* 具体生产什么由子类去实现\n \t* @param clz 产品对象类类型\n \t* @return 具体的产品对象\n \t*/ \t\n \tpublic abstract<T extends Product> T createProduct(class<T> clz);\n}\n\npublic class ConcreteFactory extends Factory {\n\t@Override\n\tpublic <T extends Product> T createProduct(class<T> clz) {\n\t\tProduct p = null;\n\t\ttry {\n\t\t\tp = (Product) class.forName(clz.getName()).newInstance();\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn (T) p;\n\t}\n}\n\n// 客户端中实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tFactory factory = new ConcreteFactory();\n\t\tProduct p = factory.createProduct(ConcreteProductA.class);\n\t\tp.method();\n\t}\n}\n```\n\n#### 工厂方法模式的简单实现\n某汽车厂主要就是组装某款 SUV 车型，比如 Q3、Q5、Q7，对于这类车型来说，内部结构差异并不是很大，因此一条生产线足以应付 3 种车型，对于该类生产线可提供一抽象类定义。\n\n便于理解，本示例的 UML 类图见图 2-8。\n\n![某工厂生产某车型的工厂方法](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-8.png )\n<center>图 2-8 某工厂生产某车型的工厂方法</center> \n \n```Java\npublic abstract class AudiFactory {\n\n\t/*\n\t * 某工厂生产某种车型的工厂方法\n\t * @param clz 具体的 SUV 型号类型\n\t * @return 具体型号的 SUV 车对象\n \t */\n\tpublic abstract<T extends AudiCar> T createAudiCar(class<T> clz);\n}\n\npublic class AudiCarFactory extends AudiFactory {\n\t@Override\n\tpublic <T extends AudiCar> T createProduct(class<T> clz) {\n\t\tProduct p = null;\n\t\ttry {\n\t\t\tp = (AudiCar) class.forName(clz.getName())\n\t\t\t\t.newInstance(); \n\t\t} catch() {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn (T) p;\n\t}\n}\n\n// 汽车的抽象产品类\npublic abstract class AudiCar {\n\tpublic abstract void drive();\n\tpublic abstract void selfNavigation();\n}\n\n// 具体车型：Q3\npublic class AudiQ3 exntends AudiCar {\n\t@Override\n\tpublic void drive() {\n\t\tSystem.out.println(\"Q3 Launched!\");\n\t}\n\t@Override\n\tpublic void selfNavigation() {\n\t\tSystem.out.println(\"Q3 starts a auto-navigation!\");\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tAudiFactory factory = new AudiFactory();\n\t\tAudiQ3 audiQ3 = factory.createProduct(AudiQ3.class);\n\t\taudiQ3.dirve();\n\t\taudiQ3.selfNavigation();\t\n\t}\n}\n```\n#### 工厂方法模式的实战\nAndroid 数据持久化有很多方式，如 SharedPreferences (XML)、SQLite (关系数据库)。对数据操作的方法无非就是增、删、改、查，若我们将每种数据储存的方式作为一个产品类，在抽象产品类中定义对数据操作的方法，即我们宏观层面把握操作的逻辑，具体的实现逻辑由储存数据的方式决定。\n\n```Java\npublic abstract class IOHandler {\n\tpublic abstract void add(String id, String name);\n\tpublic abstract void remove(String id);\n\tpublic abstract void update(String id, String name);\n\tpublic abstract String query(String id);\n}\n\npublic class FileHandler extends IOHandler { // 普通文件存储\n\t@Override\n\tpublic void add(String id, String name) {\n\t\t/* 业务逻辑 */ }\n\t@Override\n\tpublic void remove(String id) {\n\t\t/* 业务逻辑 */ }\n\t@Override\n\tpublic void update(String id, String name) {\n\t\t/* 业务逻辑 */ }\n\t@Override\n\tpublic String query(String id) {\n\t\t/* 业务逻辑 */ \n\t\treturn \"AigeStudio\";\n\t}\n}\n\npublic class XMLHandler extends IOHandler { // XML 文存储\n\tpublic void add(String id, String name) {\n\t\t/* 业务逻辑 */ }\n\tpublic void remove(String id) {\n\t\t/* 业务逻辑 */ }\n\tpublic void update(String id, String name) {\n\t\t/* 业务逻辑 */ }\n\tpublic String query(String id) {\n\t\t/* 业务逻辑 */\n\t\treturn \"SMBrother\";\n\t}\n}\n\npublic class DBHandler extends IOHandler { // SQLite 数据库存储\n\tpublic void add(String id, String name) {\n\t\t/* 业务逻辑 */ }\n\tpublic void remove(String id) {\n\t\t/* 业务逻辑 */ }\n\tpublic void update(String id, String name) {\n\t\t/* 业务逻辑 */ }\n\tpublic String query(String id) {\n\t\t/* 业务逻辑 */\n\t\treturn \"Android\";\n\t}\n}\n\npublic class IOFactory {\n\t\n\t/*\n\t * 获取 IO 处理者\n\t * @param clz IOHandler 类型的类类型\n\t * @return IOHandler 对象\n\t */\n\t \n\tpublic static <T extends IOHandler> T getIOHandler(class<T> clz) {\n\t\tIOHandler handler = null;\n\t \ttry {\n\t \t\thandler = (IOHandler) class.forName(clz.getName())\n\t \t\t\t.newInstance();\n\t \t} catch(Exception e) {\n\t \t\te.printStackTrace();\n\t \t}\n\t\treturn (T) handler;\n\t}\n}\n\n// 客户端实现\npublic class FactoryActivity extends Activity {\n\t@override\n\tprotected void onCreate(Bundle saveInstanceState) {\n\t\tsuper.onCreate(saveInstanceState);\n\t\tsetContentView(R.layout.activity_factory);\n\t\t\n\t\t// 获取显示查询内容的 TextView 对象\n\t\tfinal TextView tvContent = (TextView) this.findViewById(R.id.factory_content_tv);\n\t\t// 获取查询普通文件数据的按钮对象，并设置监听\n\t\tButton btnFile = (Button) this.findViewById(R.id.factory_file_btn);\n\t\tbtnFile.setOnClickListener(new View.OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tIOHandler handler = IOFactory.getIOHanHandler(FileHandler.class);\n\t\t\t\tLog.d(\"AigeStudio\", handler.query(\"4455645646\"));\n\t\t\t\ttvContent.setText(handler.query(\"4455645646\"));\n\t\t\t}\n\t\t});\n\t}\n}\n```\n\n### 抽象工厂模式\n#### 抽象工厂模式的定义\n- 创建型设计模式。\n- 为创建一组相关或者是相互依赖的对象 提供一个 `接口` ，而不需要指定它们的具体类。\n\n#### 抽象工厂模式的使用场景\n一个对象族有相同约束时可以使用抽象工厂模式。如：  \nAndroid、iOS、Window Phone 下都有短信软件和拨号软件，两者属于软件范畴，但由于操作系统平台不一样，其代码实现细节也是有差异的，则我们可考虑使用抽象工厂方法模式去产生不同平台下的同款软件。\n\n#### 抽象工厂模式的 UML 类图\n抽象工厂方法模式的 UML 如图 2-9 所示。\n\n![抽象工厂方法模式UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-9.png )\n<center>图 2-9 抽象工厂方法模式 UML 类图</center> \n\n```Java\npublic abstract class AbstractProductA { // 抽象产品类 A\n    public abstractvoid method();\n}\n \npublic abstract class AbstractProductB { // 抽象产品类 B\n    public abstractvoid method();\n}\n \npublic class ConcreteProducxtA1 extends AbstractProductA { // 具体产品类 A1\n    @Override\n    public void method() {\n        System.out.println(\"具体产品 A1 的方法.\");\n    }\n}\n \npublic class ConcreteProducxtA2 extends AbstractProductA { // 具体产品类 A2\n    @Override\n    public void method() {\n        System.out.println(\"具体产品 A2 的方法.\");\n    }\n}\n \npublic class ConcreteProducxtB1 extends AbstractProductB { // 具体产品类 B1\n    @Override\n    public void method() {\n \t    System.out.println(\"具体产品 B1 的方法.\");\n    }\n}\n \npublic class ConcreteProducxtB2 extends AbstractProductB { // 具体产品类 B2\n    @Override\n    public void method() {\n        System.out.println(\"具体产品 B2 的方法.\");\n    }\n }\n \npublic abstract class AbstractFactory { // 抽象工厂类\n \n    /**\n     * 创建产品 A 的方法\n     * @return 产品 A 的对象\n     */\n    public abstract AbstractProductA createProductA();\n \t \n    /**\n     * 创建产品 B 的方法\n     * @return 产品 B的对象\n     */\n    public abstract AbstractProductB createProductB();\n}\n \npublic class ConcreteFactory1 extends AbstractFactory { // 具体工厂类1\n    @Override\n    public abstract AbstractProductA createProductA1() {\n        return new ConcreteProductA1();\n    };\n    @Override\n    public abstract AbstractProductB createProductB1() {\n        return new ConcreteProductB1();\n    };\n}\n \npublic class ConcreteFactory2 extends AbstractFactory { // 具体工厂类2\n    @Override\n    public abstract AbstractProductA createProductA2() {\n        return new ConcreteProductA2();\n    };\n    @Override\n    public abstract AbstractProductB createProductB2() {\n        return new ConcreteProductB2();\n    };\n}\n```\n\n#### 抽象工厂模式的简单实现\n在简单工厂模式的简单实现中，我门以车厂生产汽车为例。虽 Q3、Q5、Q7 同为一车系，但三者之间的零部件产别却很大，如 Q3、Q7 当中，Q3 装配的是国产发动机，普通轮胎和普通制动系统；Q7 则装配的是进口发动机，全尺寸越野轮胎和制动性能极好的制动系统。\n\n即同为一系列车，大家共有部件有发动机、轮胎和制动系统等，由于具体的部件品质不同，装配的细节又不同。故我们可将抽象工厂模式应用当中，化繁为简。具体的架构如图 2-10 的 UML 类图所示。\n\n![车厂生产同系列汽车的抽象工厂模式](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-10.png )\n<center>图 2-10 车厂生产同系列汽车的抽象工厂模式</center>\n \n```Java\npublic abstract class CarFactory {\n\t/**\n\t * 生产轮胎\n\t * @return ITire 轮胎\n\t */\n \tpublic abstract ITire createTire();\n \t\n\t/**\n\t * 生产发动机\n\t * @return IEngine 发动机\n\t */\n \tpublic abstract IEngine createEngine();\n \t\n\t/**\n\t * 生产制动系统\n\t * @return IBrake 制动系统\n\t */\n\tpublic abstract IBrake createBrake();\n}\n \npublic interface ITire { // 轮胎\n\tvoid tire();\n}\n \npublic class NormalTire implements ITire {\n\t@Override\n\tpublic void tire() {\n\t\tSystem.out.println(\"普通轮胎\");\n\t}\n}\n \npublic class SUVTire implements ITire {\n\t@Override\n\tpublic void tire() {\n\t\tSystem.out.println(\"越野轮胎\");\n\t}\n}\n \npublic interface IEngine() { // 发动机\n\tvoid engine();\n}\n \npublic class DomesticEngine implements IEngine {\n\t@Override\n\tpublic void engine() {\n\t\tSystem.out.println(\"国产发动机\");\n\t}\n}\n \npublic class ImportEngine implements IEngine {\n\t@Override\n\tpublic void engine() {\n\t\tSystem.out.println(\"进口发动机\");\n\t}\n}\n \npublic interface IBrake { // 制动系统\n\tvoid brake();\n}\n \npublic class NormalBrake implements IBrake {\n\t@Override\n\tpublic void brake() {\n\t\tSystem.out.println(\"普通制动\");\n\t}\n}\n  \npublic class SeniorBrake implements IBrake {\n\t@Override\n\tpublic void brake() {\n\t\tSystem.out.println(\"高级制动\");\n\t}\n}\n\npublic class Q3Factory extends CarFactory { // Q3工厂类\n\t@Override\n\tpublic ITire createTire() {\n\t\treturn new NormalTire();\n\t}\n\t@Override\n\tpublic IEngine createEngine() {\n\t\treturn new Domestic Engine();\n\t}\n\t@Override\n\tpublic IBrake createBrake() {\n\t\treturn new NormalBrake();\n\t}\n}\n \npublic class Q3Factory extends CarFactory { // Q3工厂类\n\t@Override\n\tpublic ITire createTire() {\n\t\treturn new NormalTire();\n\t}\n\t@Override\n\tpublic IEngine createEngine() {\n\t\treturn new DomesticEngine();\n\t}\n\t@Override\n\tpublic IBrake createBrake() {\n\t\treturn new NormalBrake();\n\t}\n}\n \npublic class Q7Factory extends CarFactory { // Q7 工厂类\n\t@Override\n\tpublic ITire createTire() {\n\t\treturn new SUVTire();\n\t}\n\t@Override\n\tpublic IEngine createEngine() {\n\t\treturn new ImportEngine();\n\t}\n\t@verride\n\tpublic IBrake createBrake() {\n\t\treturn new SeniorBrake();\n\t}\n}\n \n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t// 构造一个生产 Q3 的工厂\n\t\tCarFactory factoryQ3 = new Q3Factory();\n\t\tfactoryQ3.createTire().tire();\n\t\tfactoryQ3.createEngine().engine();\n\t\tfactoryQ3.createBrake().brake();\n \t\t\n\t\t// 构造一个生产 Q7 的工厂\n\t\tCarFactory factoryQ7 = new Q7Factory();\n\t\tfactoryQ7.createTire().tire();\n\t\tfactoryQ7.createEngine().engine();\n\t\tfactoryQ7.createBrake().brake();\n\t}\n}\n```\n\n#### 总结\n- 抽象工厂方法模式的优缺点\n\t- 优点 - 分离接口与实现，即客户端使用抽象工厂的创建对象，客户端不知具体实现是谁，客户端只是面向产品的接口编程而已，使其从具体的产品实现中解耦。\n\t- 缺点  \n\t1) 类文件的爆炸性增加。  \n\t2) 不太容易扩展新的产品类，因为每当增加一个产品类，就需修改抽象工厂，故所有具体工厂类均会被修改。\n\n### 策略模式\n#### 策略模式的介绍\n实现某功能，可以有多种算法或策略选择，例如排序算法，有插入排序、归并排序、冒泡排序等。\n\n> 思考：多种排序算法，可以写在一个类中，一个方法对应一种具体排序。但是缺点也是很明显，即臃肿；维护成本高，且容易引发错误；每增加一种排序需修改封装类的源码。  \n> \n> 改进：提供一个统一接口，不同的算法或策略有不同的实现类。\n\n\n#### 策略模式的使用场景\n- 针对同类问题的多种处理方式，仅仅是 `具体行为` 有差别。\n- 需要安全地封装多种 `同类型` 的操作。\n- 出现同一抽象类，有多个子类，而又需使用 `if-else` 或 `switch-case`  来选择具体子类。\n\n\t> 但缺点也明显，耦合性高；代码臃肿难维护。\n\n#### 策略模式的 UML 类图\n策略模式的 UML 如图 2-11 所示。\n\n![策略模式UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-11.png )\n<center>图 2-11 策略模式 UML 类图</center> \n\n#### 策略模式的简单实现\n下面以在北京乘坐公共交通工具的费用计算来演示一简单示例。在 2014 年 12 月 20 号之后，北京提高公交价格，不在是单一票价制，而是分段计费。显然，公交车和地铁的价格计算方式是不一样的。但是，我们的示例中是需要计算乘不同出行工具的成本，故我们采用策略模式进行设计、编码。\n\n便于理解，本示例的 UML 类图如图 2-12 所示。\n\n![交通方案UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-12.png )\n<center>图 2-12 交通方案的 UML 类图</center> \n\n```Java\npublic interface CalculateStragety {\n\t/**\n\t * 按距离来计算价格\n\t * @param km 公里\n\t * @return 返回价格\n\t */\n\tint calculatePrice();\n}\n\npublic class BusStragety implements CalculateStragety {\n\t@Override\n\tpublic int calculatePrice(int km) {\n\t\t// 公交车价格计算策略\n\t}\n}\n\npublic class SubwayStragety implements CalculateStragety {\n\t@Override\n\tpublic int calculatePrice(int km) {\n\t\t// 地铁价格计算策略\n\t}\n}\n\n// 客户端实现: 出行价格计算器\npublic class TranficCalculator {\n\tCalculateStrategy mStrategy = null;\n\t\n\tpublic static void main(String[] args) {\n\t\tTranficCalculator calculator = new TranficCalculator();\n\t\t// 设置计算策略\n\t\tcalculator.setStrategy( new BusStrategy() );\n\t\t// 计算价格\n\t\tSystem.out.println(\"公交车乘16公里的价格: \" + calculator.calculatePrice(16));\n\t}\n\t\n\tpublic void setStrategy(CalculateStrategy mStrategy) {\n\t\tthis.mStrategy = mStrategy;\n\t}\n\t\n\tpublic int calculatePrice(int km) {\n\t\treturn mStrategy.calculatePrice(km);\n\t}\n}\n```\n\n#### 策略模式的实战应用\n对于默认情况下，ImageLoader 会按照先后顺序加载图片，但在实际算法当中，相反顺序加载图片也是有可能的，即反序列加载图片。当然加载方式可看作多种策略，共同的目标是实现加载图片。图 2-13 是 ImageLoader 的 UML 类图。\n\n![ImageLoader的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-13.png)\n<center>图 2-13 ImageLoader 的 UML 类图</center>\n\n```Java\npublic interface LoadPolicy { // 加载策略接口\n\tpublic int compare(BitmapRequest request1, BitmapRequest request2);\n}\n\n/**\n * 顺序加载策略\n */\npublic class SerialPolicy implements LoadPolicy {\n\t@Override\n\tpublic int compare(BitmapRequest request1, BitmapRequest request2) {\n\t\t// 按照添加到队列的序列号顺序来执行\n\t\treturn request1.serialNum - request2.serialNum;\n\t}\n}\n\n/**\n * 逆序加载策略，即从最后加入队列的请求进行加载\n */\npulbic class ReversePolicy implements LoadPolicy {\n\t@Override\n\tpublic int compare(BitmapRequest request1, BitmapRequest request2) {\n\t// 注意: Bitmap 请求要先执行最晚加入队列的请求，ImageLoader 的策略 \n\treturn request2.serialNum - request1.serialNum;\n\t}\n}\n\n/** \n * 因每个请求都有一序列号，序列号以递增形式增加，越晚加入队列的请求序列号越大。\n * 而请求队列是优先级队列，因此我们需要在图片加载请求类中实现 Comparable 接口，以实现对这些请求的排序处理。\n */\npublic class BitmapRequest implements Comparable<BitmapRequest> { // 加载策略\n\tLoadPolicy mLoadPolicy = new SerialPolicy();\n\t@Override\n\tpublic int compareTo(BitmapRequest another) {\n\t\t// 委托给 LoadPolicy 进行处理，实现按照策略模式\n\t\treturn mLoadPolicy.compare(this, another);\n\t}\n}\n\n/**\n * 用户在配置 ImageLoader 时可以设置加载策略，\n * 这个策略会被设置给每个图片加载请求对象，具体如下：\n */\npublic void displayImage(final ImageView imageView, final String uri, final DisplayConfig config, final ImageListener listener) {\n\tBitmapRequest request = new BitmapRequest(imageView, uri, config, listener);\n \t\n\t// 加载的配置对象，如果没有设置则使用 ImageLoader 的配置\n\trequest.displayConfig = request.displayConfig != null ?\n\t\trequest.displayConfig : mConfig.displayConfig;\n \t// 设置加载策略\n \trequest.setLoadPolicy(mConfig.loadPolicy);\n \t// 添加到队列中\n\tmImageQueue.addRequest(request);\n}\n```\n\n#### 总结\n- 策略模式的优缺点\n\t- 优点  \n\t1) 很好地演示了开闭原则，也就定义了抽象。  \n\t2) 耦合度相对较低，扩展方法。\n\t- 缺点 - 随着策略的增加，子类会变得繁多。\n\n### 状态模式\n- 状态模式和策略模式和结构几乎一样，但它们的目的本质完全相异。\n\t- 状态模式：行为是平行的，不可替换的。\n\t- 策略模式：行为彼此独立，可相互替换。\n\n#### 状态模式的定义\n当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。\n\n#### 状态模式的使用场景\n代码中包含大量与对象状态有关的条件语句。如操作中含有庞大的多分支语句 ( `if-else` 或 `switch-case` )，且这些分支依赖与该对象的状态。\n\n若使用状态模式来优化架构，即每一条件分支放于独立的类。\n\n#### 状态模式的 UML 类图\n![状态模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-14.png)\n<center>图 2-14 状态模式的 UML 类图</center> \n\n#### 状态模式的简单示例\n下面以电视遥控器为例演示状态模式的实现。便于理解，本示例的 UML 类图如图 2-15 所示。\n\n![电视遥控器UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-15.png)\n<center>图 2-15 电视遥控器 UML 类图</center> \n\n#### 状态模式实战\n在新浪微博中，用户在未登录的情况下点击转发按钮，此时会先让用户登录，然后再执行转发操作；如果已登录的情况下，那么用户输入转发的内容后就可以直接进行操作。\n\n![新浪微博用户状态管理UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-16.png)\n<center>图 2-16 新浪微博用户状态管理 UML 类图</center> \n\n#### 总结\n- 状态模式的优缺点\n\t- 优点 - 将所有与一个特定的状态相关的行为都放入一个状态对象中，它提供了一个更好的方法来组织与特定状态相关的代码，将繁琐的状态判断转为结构清晰的状态类族。\n\t- 缺点 - 必然增加系统类和对象的个数。\n\n### 责任链模式\n#### 责任链模式的定义\n- 行为型设计模式。\n- 通俗定义：每个节点看作一对象，每一对象拥有不同的处理逻辑，将一请求从链式的首端发出，沿着链的路径一次传递每个节点对象，直至有对象处理这个请求为止。\n- 标准定义：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成链，并沿着这条链传递该请求，直至有对象处理它为止。\n\n#### 责任链模式的使用场景\n- 多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动态决定。\n- 在请求处理者不明确的情况下向多个对象中的其一提交一个请求。\n- 需要动态指定一组对象处理请求。\n\n#### 责任链模式的 UML 类图\n责任链模式的 UML 类图如图 2-17 所示。\n\n![责任链模式UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-17.png)\n<center>图 2-17 责任链模式 UML 类图</center>\n\n```Java\n// 抽象处理者\npublic abstract class Handler {\n\tprotected Handler successor; // 下一节点的处理者\n\t/**\n\t * 请求处理\n\t * @param condition 请求条件\n\t */\n\tpublic abstract void handleRequest(String condition);\n}\n\n// 具体的处理者1\npublic class ConcreteHandler1 extends Handler {\n\t@Override\n\tpublic void handleRequest(String condition) {\n\t\tif(condition.equals(\"ConcreteHandler1\")) {\n\t\t\tSystem.out.println(\"ConcreteHandler1 handled\");\n\t\t\treturn;\n\t\t} else {\n\t\t\tsuccessor.handleRequest(condition);\n\t\t}\n\t}\n}\n\n// 具体的处理者2\npublic class ConcreteHandler1 extends Handler {\n\t@Override\n\tpublic void handleRequest(String condition) {\n\t\tif(condition.equals(\"ConcreteHandler2\")) {\n\t\t\tSystem.out.println(\"ConcreteHandler2 handled\");\n\t\t\treturn;\n\t\t} else {\n\t\t\tsuccessor.handleRequest(condition);\n\t\t}\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t// 构造一个 ConcreteHandler1 对象\n\t\tConcreteHandler1 handler1 = new ConcreteHandler1();\n\t\t// 构造一个 ConcreteHandler2 对象\n\t\tConcreteHandler2 handler1 = new ConcreteHandler2();\n\t\t// 设置 handler1 的下一个节点\n\t\thandler1.successor = handler2;\n\t\t// 设置 handler2 的下一个节点\n\t\thandler2.successor = handler1;\n\t\t// 处理请求\n\t\thandler1.handleRequest(\"ConcreteHandler2\");\n\t}\n}\n```\n\n#### 责任链模式的简单实现\n在公司中报销费用中，审批的流程其实就是一个类似责任链的实例。例如，小明是请求的发起者，而处理者有组长、部门主管、经理和老板，对于不同额度的报销费用需要不同级的处理者审批，准确地说，每一类人代表这条链上的一个节点。\n\n例如小民是请求的发起者，而老板则是处于链条顶端的类，小民从链的底端开始发出一个申请报账的请求，首先由组长处理该请求，组长比对后发现自己权限不够于是将该请求转发给位于链中下一个节点的主管，主管比对后发现自己权限不足又将该请求转发给经理，经理也基于同样的原因将请求转发给老板，这样层层转达直至请求被处理。即至始至终小民关心的是报账结果，而不用在乎处理者是谁。责任链模式在这里很好地将请求的发起者与处理者解耦。\n\n便于理解，本示例的 UML 类图如图 2-18 所示。\n\n![报账审核机制UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-18.png)\n<center>图 2-18 报账审核机制 UML 类图</center>\n\n```Java\n// 抽象领导者\npublic abstract class Leader {\n\tprotected Leader nextHandler; // 上一级领导处理者\n\t\n\t/**\n\t * 处理报账请求\n\t * @param money 能批复的报账额度\n\t */\n\tpublic final void handleRequest() {\n\t\tif( money < limit() ) {\n\t\t\thandle(money);\n\t\t} else {\n\t\t\tif( null != nextHandlder ) {\n\t\t\t\tnextHandler.handleRequest(money);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * 自身能批复的额度权限\n\t * @return 额度\n\t */\n\tpublic abstract int limit();\n\t\n\t/**\n\t * 处理报账行为\n\t * @param money 具体金额\n\t */\n\tpulbic abstract void handle(int money);\n}\n\npublic class GroupLeader extends Leader {\n\t@Override\n\tpublic int limit() {\n\t\treturn 1000;\n\t}\n\t@Override\n\tpublic void handle(int money) {\n\t\tStsten.out.println(\"组长批复报销\" + money + \"元\");\n\t}\n}\n\npublic class Director extends Leader {\n\t@Override\n\tpublic int limit() {\n\t\treturn 5000;\n\t}\n\t@Override\n\tpublic void handle(int money) {\n\t\tStsten.out.println(\"主管批复报销\" + money + \"元\");\n\t}\n}\n\npublic class Manager extends Leader {\n\t@Override\n\tpublic int limit() {\n\t\treturn 10000;\n\t}\n\t@Override\n\tpublic void handle(int money) {\n\t\tStsten.out.println(\"经理批复报销\" + money + \"元\");\n\t}\n}\n\npublic class Boss extends Leader {\n\t@Override\n\tpublic int limit() {\n\t\treturn Integer.MAX_VALUE;\n\t}\n\t@Override\n\tpublic void handle(int money) {\n\t\tStsten.out.println(\"老板批复报销\" + money + \"元\");\n\t}\n}\n\n// 小民从组长开始发起请求申请报账\npublic class XiaoMin {\n\tpublic static void main(String[] args) {\n\t\t// 构造各个领导对象\n\t\tGroupLeader groupLeader = new GroupLeader();\n\t\tDirector director = new Director();\n\t\tManager manager = new Manager();\n\t\tBoss boss = new Boss();\n\t\t\n\t\t// 设置上一级领导处理者对象\n\t\tgroupLeader.nextHandler = director;\n\t\tdirector.nextHandler = manager;\n\t\tmanager.nextHandler = boss;\n\t\t\n\t\t// 发起报账申请\n\t\tgroupLeader.handleRequest(50000);\n\t}\n}\n```\n\n#### 责任链模式实战\nAndroid 中我们可以借鉴责任链模式的思想来优化 BroadcastReceiver 使之成为一个全局的责任链处理者。\n\n我们知道 Broadcast 可以被分为两种:\n\n- Normal Broadcast：普通广播，异步广播，发出时可被所有的接收者收到。\n- Ordered Broadcast：有序广播，依优先级依次传播的，直到有接收者将其终止或所有接收者都不终止它。\n\n有序广播这一特性与我们的责任链模式很相近，通过它可实现一种全局的责任链事件处理。\n\n```Java\n// 具体的实现思路是，通过 Intent 的限制值来限定最终的广播权归谁所有\npublic class FirstReceiver extends BroadcastReceiver {\n\t@Override\n\tpublic void onReceive(Context context, Intent intent) {\n\t\t// 获取 Intent 中附加的限制值\n\t\tint limit = intent.getIntExtra(\"limit\", -1001);\n\t\t\n\t\t// 如果限定值等于 1000 则处理，否则继续转发给下一个 Receiver\n\t\tif( 1000 == limit ) {\n\t\t\t// 获取 Intent 中附加的字符串消息并 Toast\n\t\t\tString msg = intent.getStringExtra(\"msg\");\n\t\t\tToast.makeText(context, msg, Toast.LENGTH_SHORT).show();\t\t\n\t\t\t// 终止广播\n\t\t\tabortBroadcast();\n\t\t} else {\n\t\t\t// 添加信息发送给下一个 Receiver\n\t\t\tBundle b = new Bundle();\n\t\t\tb.putString(\"new\", \"Message from FirstReceiver\");\n\t\t\tsetResultExtras(b);\n\t\t}\n\t}\n}\n\npublic class SecondReceiver extends BroadcastReceiver {\n\t@Override\n\tpublic void onReceive(Context context, Intent intent) {\n\t\t// 获取 Intent 中附加的限制值\n\t\tint limit = intent.getIntExtra(\"limit\", -1001);\n\t\t\n\t\t// 如果限定值等于 100 则处理，否则继续转发给下一个 Receiver\n\t\tif( 100 == limit ) {\n\t\t\t// 获取 Intent 中附加的字符串消息\n\t\t\tString msg = intent.getStringExtra(\"msg\");\n\t\t\t\n\t\t\t// 获取上一个 Receiver 增加的消息\n\t\t\tBundle b = getResultExtras(true);\n\t\t\tString str = b.getString(\"new\");\n\t\t\t\n\t\t\tToast.makeText(context, msg + str, Toast.LENGTH_SHORT).show();\t\t\n\t\t\t// 终止广播\n\t\t\tabortBroadcast();\n\t\t} else {\n\t\t\t// 添加信息发送给下一个 Receiver\n\t\t\tBundle b = new Bundle();\n\t\t\tb.putString(\"new\", \"Message from FirstReceiver\");\n\t\t\tsetResultExtras(b);\n\t\t}\n\t}\n}\n\npublic class ThirdReceiver extends BroadcastReceiver {\n\t@Override\n\tpublic void onReceive(Context context, Intent intent) {\n\t\t// 获取 Intent 中附加的限制值\n\t\tint limit = intent.getIntExtra(\"limit\", -1001);\n\t\t\n\n\t\t// 如果限定值等于 10 则处理，否则继续转发给下一个 Receiver\n\t\tif( 10 == limit ) {\n\t\t\t// 获取 Intent 中附加的字符串消息\n\t\t\tString msg = intent.getStringExtra(\"msg\");\n\t\t\t\n\t\t\t// 获取上一个 Receiver 增加的消息\n\t\t\tBundle b = getResultExtras(true);\n\t\t\tString str = b.getString(\"new\");\n\t\t\t\n\t\t\tToast.makeText(context, msg + str, Toast.LENGTH_SHORT).show();\t\t\n\t\t\t// 终止广播\n\t\t\tabortBroadcast();\n\t\t} else {\n\t\t\t// 添加信息发送给下一个 Receiver\n\t\t\tBundle b = new Bundle();\n\t\t\tb.putString(\"new\", \"Message from FirstReceiver\");\n\t\t\tsetResultExtras(b);\n\t\t}\n\t}\n}\n\n// 客户端实现\npublic class OrderActivity extends Activity {\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_order);\n\t\t\n\t\tButton btnSend = (Button) findViewById(R.id.order_send_btn);\n\t\tbtnSend.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tIntent i = new Intent();\n\t\t\t\ti.setAction(\"com.aigestudio.action.ORDER_BROADCAST\");\n\t\t\t\ti.putExtra(\"limit\", 100);\n\t\t\t\ti.putExtra(\"msg\", \"Message from OrderActivity\");\n\t\t\t\tsendOrderedBroadcast(i, null);\n\t\t\t}\n\t\t});\n\t}\n}\n\n// 这里我们设置 limit = 100，即只有 SecondReceiver 才会处理它。\n```\n\n#### 总结\n- 责任链模式的优缺点\n\t- 优点 - 对请求者和处理者关系解耦，提高代码灵活性。\n\t- 缺点 - 递归调用。特别是处理者太多，那么遍历定会影响性能。\n\n### 解释器模式\n\n#### 解释器模式的定义\n- 行为型设计模式。\n- 概念：给定一个语言，定义它的 `文法` 的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。\n- 文法：例如我们熟悉的「主谓宾结构」，通过下述短语举例，我们可把短语抽象看作：I am a/an [noun.]\n\n| 主语 | 谓语 | 宾语 |\n| --- | --- | --- |\n| I | am | a designer |\n| I | am | a teacher |\n\n- 再举例：假设有如以 ab 开头 ef 结尾，中间排列 N(N>=0) 个 cd 的字符串。\n> abcdcd...cdef\n\n 在计算机科学中，我们将上述字符串中的 “a”、“b”、“c”、“d”、“e” 和 “f” 这 6 个字符称为一种形式语言的 `字符表`。\n\n 而这些字符组成的集合，如 “abcdcd...cdef” 这样由字符表构成的字符串则称为 `形式语言`。注意这里的语言不是文法。\n\n 假设定义一个符号 S，从符号 S 出发推导上述字符串，即可得到如下推导式：\n\n ```Java\n S ::= abA*ef  \n A ::= cd\n ```\n \n - `::==` 称为推导；  \n - `*` 表示闭包，上述推导式中意思是，符号 A 可以有 0 或 N 个重复；  \n - 非终结符号：`S` 和 `A` 则称非终结符号，即它们能推导出式子右边的表达式；  \n - 终结符号：\"pqmn\"，“ab”，“ef”，即无法再推导；\n\n#### 解释器模式的使用场景\n- 某个 `简单语言` 需要解释执行且可将该语言中的语句表示为 `抽象语法树` 时可考虑使用解释器模式。\n\n\t> 如：有非终结符号 p+q+m-n，即该数学表示式可表示为一棵抽象语法树。如图 2-19 所示。\n\n![p+q+m-n的抽象语法树](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-19.png)\n<center>图 2-19 p+q+m-n 的抽象语法树</center>\n\n- 某些特定的领域出现不断重复的问题时，可将该领域的问题转化为一种语法规则下的语句，然后构建解释器来解释该语句。\n\n\t> 英文字母的大小写转换；阿拉伯数字转为中文的数字...   \n\t> 即它们都是一个个终结符，不同的只是具体内容。\n\t\n#### 解释器模式的 UML 类图\n解释器模式的 UML 类图如图 2-20 所示。\n\n![解释器模式UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-20.png)\n<center>图 2-20 解释器模式 UML 类图</center>\n\n```Java\npublic abstract class AbstractExpression {\n\t/**\n\t * 抽象的解析方法\n\t * @param ctx 上下文环境对象\n\t */\n\tpublic abstract void interpret(Context ctx);\n}\n\n// 终结符表达式\npublic class TerminalExpression extends AbstractExpression {\n\t@Override\n\tpublic abstract void interpret(Context ctx) {\n\t\t// 实现文法中与终结符有关的解释操作\n\t}\n}\n\n// 非终结符表达式\npublic class NonterminalExpression extends AbstractExpression {\n\t@Override\n\tpublic abstract void interpret(Context ctx) {\n\t\t// 实现文法中与非终结符有关的解释操作\n\t}\n}\n\npublic class Context {\n\t// 包含解释器之外的全局信息\n}\n\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t// 根据文法对特定句子构建抽象语法树后解释\n\t}\n}\n```\n\n#### 总结\n- 解释模式的优缺点\n\t- 优点 - 灵活的扩展性，即我们想对文法规则进行扩展延伸时，只需增加相应的非终结符解释器，并在构建抽象语法树时，使用到新增的解释器对象进行具体的解释即可。\n\t- 缺点  \n\t1) 对于每一条文法对应至少一个解释器，其会生成大量的类，导致后期维护困难； \n\t2) 构建其抽象语法树会显得异常繁琐，甚至可能出现需要构建多棵抽象语法树的情况。\n\n### 命令模式\n\n#### 命令模式的定义\n- 行为型设计模式。\n- 介绍：将一系列的方法调用封装，用户只需调用一个方法执行，那么所有这些被封装的方法就会被挨个执行调用。\n- 定义：\n - 将一个请求封装成一个对象，从而让用户使用不同的请求把客户端参数化。\n - 对请求排队或者记录请求日志，以及支持可撤销的操作。\n\n#### 命令模式的使用场景\n- 需要抽象出待执行的动作，然后以参数的形式提供处理 (类似过程设计中的回调机制)。\n- 在不同的时刻指定、排列和执行请求。一个命令对象可以有与初始请求无关的生存期。\n- 需要支持取消操作。\n- 需要支持事务操作。\n- 支持修改日志功能，若系统崩溃，这些修改可重做一遍。\n\n#### 命令模式的 UML 类图\n命令模式的 UML 类图如图 2-21 所示。\n\n![命令模式UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-21.png)\n<center>图 2-21 命令模式 UML 类图</center>\n\n```Java\n// 接收者类\npublic class Receiver {\n\t/**\n\t * 真正执行具体命令逻辑的方法\n\t */\n\tpublic void action() {\n\t\tSystem.out.println(\"执行具体操作\");\n\t}\n}\n\n// 抽象命令接口\npublic interface Command {\n\t/**\n\t * 执行具体操作的命令\n\t */\n\tvoid execute();\n}\n\n// 具体命令类\npublic class ConcreteCommand implements Command {\n\tprivate Receiver receiver; // 持有一个对接受者对象的引用\n\tpublic ConcreteCommand(Receiver receiver) {\n\t\tthis.receiver = receiver;\n\t}\n\t@Override\n\tpublic void execute() {\n\t\t// 调用接收者的相关方法来执行具体逻辑\n\t\treceiver.action();\n\t}\n}\n\n// 请求者类\npublic class Invoker {\n\tprivate Command command; // 持有一个对应命令对象的引用\n\t\n\tpublic Invoker() {\n\t\tthis.command = command;\n\t}\n\t\n\tpublic void action() {\n\t\t// 调用具体命令对象的相关方法，执行具体命令\n\t\tcommand.execute();\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t// 构造一个接受者对象\n\t\tReceiver receiver = new Receiver();\n\t\t// 根据接收者对象构造一个命令对象\n\t\tCommand command = new ConcreteCommand(receiver);\n\t\t// 根据具体的对象构造请求者对象\n\t\tInvoker invoker = new Invoker(command);\n\t\t// 执行请求方法\n\t\tinvoker.action();\n\t}\n}\n```\n\n**Receiver：接收者角色**  \n该类负责具体实施或执行一个请求，通俗地说，执行具体逻辑的角色。\n\n**Command：命令角色**  \n定义所有具体命令类的抽象接口。\n\n**ConcreteCommand：具体命令角色**  \n该类实现了 Command 接口，在 execute() 方法中调用接收者角色的相关方法，在接收者和命令执行的具体行为之间加以弱耦和。\n\n**Invoker：请求者角色**  \n该类的职责就是调用命令对象执行具体的请求，相关的方法我们称为行动方法。\n\n这里其实大家可以看到，命令模式的应用其实可用一句话概述，就是将行为调用者与实现者解耦。\n\n#### 命令模式的简单实现\n这里以古老的俄罗斯方块游戏为例，在命令模式下如何操控俄罗斯方块变换。游戏中含有 4 个按钮，即上下左右。设定玩游戏的人相当于我们的客户端，游戏上的 4 个按钮相当于请求者，而执行具体按钮命令的逻辑方法可看作命令角色。\n\n便于理解，本示例的 UML 类图如图 2-22 所示。\n\n![命令模式实现俄罗斯方块游戏](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-22.png)\n<center>图 2-22 命令模式实现俄罗斯方块游戏</center>\n\n```Java\n// 接收者角色\npublic class TetrisMachine {\n\n\tpublic void toLeft() { // 真正处理 “向左” 操作的逻辑代码\n\t\tSystem.out.println(“向左”);\n\t}\n\t\n\tpublic void toRight() { // 真正处理 “向右” 操作的逻辑代码\n\t\tSystem.out.println(“向右”);\n\t}\n\t\n\tpublic void fastToBottom() { // 真正处理 “快速落下” 操作的逻辑代码\n\t\tSystem.out.println(“快速落下”);\n\t}\n\t\n\tpublic void transform() { // 真正处理 “改变形状” 操作的逻辑代码\n\t\tSystem.out.println(“改变形状”);\n\t}\t\n}\n\n// 命令者抽象\npublic interface Command {\n\t/**\n\t * 命令执行方法\n\t */\n\tvoid execute();\n}\n\n// 具体命令者：向左移的命令类\npublic class LeftCommand implements Command {\n\t// 持有一个接收者俄罗斯方块游戏对象的引用\n\tprivate TetrisMachine machine;\n\tpublic LeftCommand(TetriMachine machine){\n\t\tthis.machine = machine;\n\t}\n\t@Override\n\tpublic void execute() {\n\t\t// 调用游戏机里的具体方法执行操作\n\t\tmachine.toLeft();\n\t}\n}\n\n// 具体命令者：向右移的命令类\npublic class RightCommand implements Command {\n\t// 持有一个接收者俄罗斯方块游戏对象的引用\n\tprivate TetrisMachine machine;\n\tpublic RightCommand(TetriMachine machine){\n\t\tthis.machine = machine;\n\t}\n\t@Override\n\tpublic void execute() {\n\t\t// 调用游戏机里的具体方法执行操作\n\t\tmachine.toRight();\n\t}\n}\n\n// 具体命令者：快速落下的命令类\npublic class FallCommand implements Command {\n\t// 持有一个接收者俄罗斯方块游戏对象的引用\n\tprivate TetrisMachine machine;\n\tpublic FallCommand(TetriMachine machine){\n\t\tthis.machine = machine;\n\t}\n\t@Override\n\tpublic void execute() {\n\t\t// 调用游戏机里的具体方法执行操作\n\t\tmachine.fastToBottom();\n\t}\n}\n\n// 具体命令者：改变形状的命令类\npublic class TransformCommand implements Command {\n\t// 持有一个接收者俄罗斯方块游戏对象的引用\n\tprivate TetrisMachine machine;\n\tpublic TransformCommand(TetriMachine machine){\n\t\tthis.machine = machine;\n\t}\n\t@Override\n\tpublic void execute() {\n\t\t// 调用游戏机里的具体方法执行操作\n\t\tmachine.transform();\n\t}\n}\n\n// 请求者类：命令由按钮发起\npublic class Buttons {\n\tprivate LeftCommand leftCommand; // 向左移动的命令对象引用\n\tprivate RightCommand rightCommand; // 向右移动的命令对象引用\n\tprivate FallCommand fallCommand; // 快速落下的命令对象引用\n\tprivate TransformCommand transformCommand; // 变换形状的命令对象引用\n\t\n\t/**\n\t * 设置向左移动的命令对象\n\t * @param leftCommand 向左移动的命令对象\n\t */\n\tpublic void setLeftCommand(LeftCommand leftCommand) {\n\t\tthis.leftCommand = leftCommand;\n\t}\n\t\n\t/**\n\t * 设置向右移动的命令对象\n\t * @param rightCommand 向右移动的命令对象\n\t */\n\tpublic void setRightCommand(RightCommand rightCommand) {\n\t\tthis.rightCommand = rightCommand;\n\t}\n\t\n\t/**\n\t * 设置快速落下的命令对象\n\t * @param fallCommand 向左移动的命令对象\n\t */\n\tpublic void setFallCommand(FallCommand fallCommand) {\n\t\tthis.fallCommand = fallCommand;\n\t}\n\t\n\t/**\n\t * 设置变换形状的命令对象\n\t * @param transformCommand 向左移动的命令对象\n\t */\n\tpublic void setTransformCommand(TransformCommand transformCommand) {\n\t\tthis.leftCommand = leftCommand;\n\t}\n\t\n\tpublic void toLeft() { // 按下按钮向左移动\n\t\tleftCommand.execute();\n\t}\n\t\n\tpublic void toRight() { // 按下按钮向右移动\n\t\trightCommand.execute();\n\t}\n\t\n\tpublic void fall() { // 按下按钮快速落下\n\t\tfallCommand.execute();\n\t}\n\t\n\tpublic void transform() { // 按下按钮改变形状\n\t\ttransformCommand.execute();\n\t}\n}\n\n// 客户端实现\npublic class Player {\n\tpublic static void main(String[] args) {\n\t\t// 首先要有俄罗斯方块游戏\n\t\tTetrisMachine machine = new TetrisMachine();\n\t\t\n\t\t// 根据游戏我们构造 4 种命令\n\t\tLeftCommand leftCommand = new LeftCommand(machine);\n\t\tRightCommand rightCommand = new RightCommand(machine);\n\t\tFallCommand fallCommand = new FallCommand(machine);\n\t\tTransformCommand transformCommand = new TransformCommand(machine);\n\t\t\n\t\t// 按钮可以执行不同的命令\n\t\tButtons buttons = new Buttons();\n\t\tbuttons.setLeftCommand(leftCommand);\n\t\tbuttons.setRightCommand(rightCommand);\n\t\tbuttons.setFallCommand(fallCommand);\n\t\tbuttons.setTransformCommand(transformCommand);\n\t\t\n\t\t// 具体按下哪个按钮玩家决定\n\t\tbuttons.toLeft();\n\t\tbuttons.toRight();\n\t\tbuttons.fall();\n\t\tbuttons.transform();\n\t}\n}\n```\n\n对于大部分开发者来说，更愿意接受的形式：\n\n```Java\nTetrisMachine machine = new TetrisMachine();\n\n// 实现怎样的控制方式，直接调用相关函数\n// machine.toLeft();\n// machine.toRight();\n// machine.fastToBottom();\n// machine.transform();\n\nmachine.toLeft();\n```\n\n调用逻辑做得如此复杂，其实是为了开发起来方便，即每次我们增加或修改游戏功能只需修改 TetrisMachine 类即可。\n当然，其实这样做是有原因的，即设计模式种有一条重要的原则：对修改关闭对扩展开放。具体好处是：\n\n- 如修改功能、代码的具体逻辑，以上例为例，即修改 TetrisMachine 类即可。\n- 此外，命令模式还可以实现命令记录的功能，如在 Buttons 里使用数据结构存储执行过的命令对象，需要时可恢复。\n\n#### 总结\n- 命令模式的优缺点\n\t- 优点 - 更灵活的控制性以及更好的扩展性；更弱的耦合性。\n\t- 缺点 - 类的膨胀，大量衍生类的创建。\n\n### 观察者模式\n\n#### 观察者模式的定义\n定义对象间一种 `一对多` 的 `依赖关系`，使得每当一个对象改变状态，则所有依赖与它的对象都会得到通知并被自动更新。\n\n#### 观察者模式的使用场景\n- 关联行为场景，即关联行为是可拆分的，而不是“组合”关系。\n- 事件多级触发场景。\n- 跨系统的消息交换场景，如消息队列、事件总线的处理机制。\n\n#### 观察者模式的 UML 类图\n观察者模式的 UML 类图如图 2-23 所示。\n\n![观察者模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-23.png)\n<center>图 2-23 观察者模式的 UML 类图</center>\n\n#### 观察者模式实战\n\n#### 总结\n- 观察者模式主要的作用就是对象解耦，将观察者与被观察者完全隔离，只依赖于 Observer 和 Obserable 抽象。\n\n> 如：ListView 就是运用了 Adapter 和观察者模式，使之它的扩展性、灵活性增强，且耦合度却很低。\n\n- 观察者模式的优缺点\n\t- 优点  \n\t1) 增强系统灵活性、可扩展性；  \n\t2) 将观察者与被观察者之间是抽象耦合，应对业务变换。\n\t- 缺点 - 应用观察者模式，需考虑开放效率和运行效率问题 (一般考虑采用异步的方式)\n\n### 备忘录模式\n\n#### 备忘录模式的介绍\n- 行为型设计模式。\n- 用于保存对象当前状态，并在之后可再次恢复到此状态。\n- 保证被保存的对象状态不能被对象从外部访问，目的是为了保护好被保存对象状态的完整性及内部实现不向外暴露。\n\n#### 备忘录模式的定义\n在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原生保存的状态。\n\n#### 备忘录模式的 UML 类图\n备忘录模式的 UML 类图如图 2-24 所示。\n\n![备忘录模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-24.png)\n<center>图 2-24 备忘录模式的 UML 类图</center>\n\n**Originator**  \n负责创建一个备忘录，可以记录、恢复自身的内部状态。同时 Originator 还可以根据需要决定 Memoto 存储自身的哪些内部状态。\n\n**Memoto**  \n备忘录角色，用于储存 Originator 的内部状态，并且可以防止 Originator 以外的对象访问 Memoto。\n\n**Caretaker**\n负责储存备忘录，不能对备忘录的内容进行操作和访问，只能够将备忘录传递给其他对象。\n\n#### 备忘录模式的简单实例\n对于备忘录模式来说，比较贴切的场景应该是游戏中的存档功能，该功能就是将游戏进度存储到本地文件系统或者数据库中，下次再次进入时从本地加载进度，使得玩家能够继续上一次的游戏之旅。下面我们以“使命召唤”这款游戏为例简单演示备忘录模式的实现。\n\n首先我们建立游戏类 CallOfDuty，备忘录类 Memoto 和负责管理 Memoto 的 CareTaker 类。玩游戏到某个节点对游戏进行存档，然后退出游戏，再重新进入时从存档中读取进度，并且进入存档时的进度。\n\n便于理解，本示例的 UML 类图如图 2-25 所示。\n\n![使命召唤的存储功能实现](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-25.png)\n<center>图 2-25 使命召唤的存储功能实现</center>\n\n```Java\n// ”使命召唤“ 游戏 ( 简化的数据模型，仅供简单演示 )\npublic class CallOfDuty {\n\tprivate int mCheckPoint = 1;\n\tprivate int mLifeValue = 100;\n\tprivate String mWeapon = \"沙漠之鹰\";\n \n\tpublic void play() { // 玩游戏\n\t\t// 忽略实现细节\n\t}\n \n\tpublic void quit() { // 退出游戏\n\t\t// 忽略实现细节\n\t}\n \n\tpublic Memoto createMemoto() { // 创建备忘录\n \t\tMemoto memoto = new Memoto();\n \t\tmemoto.mCheckPoint = mCheckPoint;\n \t\tmemoto.mLifeValue = mLifeValue;\n \t\tmemoto.mWeapon = mWeapon;\n \t\treturn memoto;\n\t}\n \n \tpublic void restore(Memoto memoto) { // 恢复游戏\n \t\tthis.mCheckPoint = memoto.mCheckPoint;\n \t\tthis.mLifeValue = memoto.mLifeValue;\n \t\tthis.mWeapon = memoto.mWeapon;\n \t\tSystem.out.println(\"恢复后的游戏属性: \" + this.toString());\n\t}\n \n \t@Overrride\n\tpublic String toString() {\n\t\treturn \"CallOfDuty[mCheckPoint=..., mLifeValue=..., mWeapon=...]\"\n\t}\n}\n\n// 备忘录类\npublic class Memoto {\n\tpublic int mCheckPoint;\n\tpublic int mLifeValue;\n\tpublic String mWeapon;\n}\n\n// Caretaker，负责管理 Memoto\npublic class Caretaker {\n\tMemoto memoto = null;\n\t\n\tpublic void archive(Memoto memoto) { // 存档\n\t\tthis.memoto = memoto;\n\t}\n\t\n\tpublic Memoto getMemoto() { // 读取存档\n\t\treturn memoto;\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tCallOfDuty game = new CallOfDuty();\n\t\t\n\t\t// Step.01 游戏开始\n\t\tgame.play();\n\t\t\n\t\t// Step.02 游戏存档\n\t\tCaretaker caretaker = new Caretaker();\n\t\tcaretaker.archive( game.createMemoto() );\n\t\t\n\t\t// Step.03 退出游戏\n\t\tgame.quit();\n\t\t\n\t\t// Step.04 恢复游戏\n\t\tCallOfDuty newGame = new CallOfDuty();\n\t\tnewGame.restore( caretaker.getMemoto() );\n\t}\n}\n```\n\n#### 总结\n- 备忘录模式是在不破坏封装的条件下，通过备忘录对象 (Memoto) 存储另外一个对象内部状态的快照，在需求的时候把对象还原到存储的状态。\n- 备忘录的优缺点\n\t- 优点 - 恢复状态机制；信息封装\n\t- 缺点 - 消耗内存 \n \n### 迭代器模式\n\n#### 迭代器模式的介绍\n- 又称游标 (Cursor) 模式，行为型设计模式。\n- 迭代器模式源于对容器的访问，若我们将遍历的方法封装在容器中，则存在问题：\n\t- 不仅维护自身内部数据且要对外提供遍历的接口方法。\n\t- 不能对同一个容器同时进行多个遍历操作。\n\t- 不提供遍历方法，而让使用者自行实现，必暴露内部细节。  \n \n\t解决方案：在客户访问类与容器直接插入一个第三者 `迭代器`。\n\n#### 迭代器模式的定义\n提供一种方法顺序访问一个容器对象中的各个元素，而不需暴露该对象内部细节。\n\n#### 迭代器模式的 UML 类图\n迭代器模式的 UML 类图如图 2-26 所示。\n\n![迭代器模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-26.png)\n<center>图 2-26 迭代器模式的 UML 类图</center>\n\n```Java\n// 迭代器接口\npublic interface Iterator<T> {\n\t/**\n\t * 是否还有下一个元素\n\t * @return true 表示有，false 表示没有\n\t */\n\tboolean hasNext();\n\t\n\t/**\n\t * 返回当前位置的元素并将位置移至下一位\n\t * @return T 返回当前位置的元素\n\t */\n\tT next();\n}\n\n// 具体迭代器类\npublic class ConcreteIterator<T> implements Iterator<T> {\n\tprivate List<T> list = new ArrayList<T>();\n\tprivate int cursor = 0;\n\t\n\tpublic ConcreteIterator(List<T> list) {\n\t\tthis.list = list;\n\t}\n\t\n\t@Override\n\tpublic boolean hasNext() {\n\t\treturn cursor != list.size();\n\t}\n\t\n\t@Override\n\tpublic T next() {\n\t\tT obj = null;\n\t\tif( this.hasNext()) {\n\t\t\tobj = this.list.get(cursor++);\n\t\t}\n\t\treturn obj;\n\t}\n}\n\n// 容器接口\npulbic interface Aggregate<T> {\n\t/**\n\t * 添加一个元素\n\t * @param obj 元素对象\n\t */\n\tvoid add(T obj); \n\t\n\t/**\n\t * 移除一个元素\n\t * @param obj 元素对象\n\t */\n\tvoid remove(T obj);\n\t\n\t/**\n\t * 获取容器的迭代器\n\t * @return 迭代器对象\n\t */\n\tIterator<T> Iterator();\n}\n\n// 具体容器类\npublic class ConcreteAggregate<T> implements Aggregate<T> {\n\tprivate List<T> list = new ArrayList<T>();\n\t\n\t@Override\n\tpublic void add() {\n\t\tlist.add(obj);\n\t}\n\t\n\t@Override\n\tpublic void remove() {\n\t\tlist.remove(obj);\n\t}\n\t\n\t@Override\n\tpublic Iterator<T> iterator() {\n\t\treturn new ConcreteIterator<T>(list);\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tAggregate<String> aggregate = new ConcreteAggregate<>();\n\t\t\n\t\taggregate.add(\"Aige \");\n\t\taggregate.add(\"Studio\\n\");\n\t\taggregate.add(\"SM \");\n\t\taggregate.add(\"Brother\\n\");\n\t\t\n\t\tIterator<String> iterator = aggregate.iterator();\n\t\twhile( iterator.hasNext() ) {\n\t\t\tSystem.out.println(iterator.next());\n\t\t}\t\n\t}\n}\n```\n\n**Iterator：迭代器接口**  \n迭代器接口，负责定义、访问和遍历元素的接口。\n\n**ConcreteIterator：具体迭代器类**  \n具体迭代器类，实现迭代器接口，并记录遍历的当前位置。  \n\n**Aggregate：容器接口**  \n容器接口，负责提供创建具体迭代器角色的接口。\n\n**ConcreteIterator：具体容器类**\n具体容器类，具体迭代器角色与该容器相关联。\n\n#### 总结\n- 迭代器模式的优缺点\n\t- 优点 - 支持以不同的方式遍容器对象，也可以有多个遍历，弱化了容器类与遍历算法之间的关系。\n\t- 缺点 - 类文件的增加。  \n- 当然几乎每一种高级语言都有相应的内置迭代器实现，故本章的内容在于了解而非应用。\n\n### 模板方法模式\n\n#### 模板方法模式的介绍\n若我们知道一个算法所需的关键步骤，并确定了这些步骤的执行顺序，但某些步骤的具体实现是未知的，或实现是随着环境变化的。\n\n> 例如，执行程度的流程大致为：  \n> Step.01：检查代码正确性  \n> Step.02：链接相关类库  \n> Step.03：编译  \n> Step.04：执行程序  \n> 即上述步骤不一样 ( 实现细节 )，但执行流程是固定的。\n\n#### 模板方法模式的定义\n- 定义一个操作的 `算法框架`。\n- 将步骤延迟到子类，使子类不改变算法结构即可重定义该算法的某些特定步骤。\n\n#### 模板方法模式的使用场景\n- 多个子类有公有的方法，且逻辑基本相同。\n- 重要复杂的算法，可把核心算法设计为模板方法，周边细节功能则由各个子类实现。\n- 重构时，使用模板方法，即相同代码抽取到父类中，然后通过 `钩子函数` 约束其行为。\n\n\t> 钩子函数：普通的抽象类多态，即它在模板方法模式中提供了改变原始逻辑的空间。\n\n#### 模板方法模式的 UML 类图\n模板方法模式的 UML 类图如图 2-27 所示。\n\n![模板方法模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-27.png)\n<center>图 2-27 模板方法模式的 UML 类图</center>\n\n#### 总结\n- 模板方法模式：流程封装，即把某个固定的流程封装到一个 final 函数中，并让子类能够定制这个流程中的某些或者所有步骤。\n\n\t> 要求父类提供共同代码，即提高代码复用性、可扩展性。\n\n- 模板方法的优缺点\n\t- 优点  \n\t1) 封装不变部分，扩展可变部分。  \n\t2) 提取公共部分代码。  \n\t- 缺点：代码阅读有难度？\n\n### 访问者模式\n\n#### 访问者模式的介绍\n- 将 `数据操作` 与 `数据结构` 分离的设计模式。\n- 软件系统拥有由许多对象构成的对象结构，这些对象类拥有一 accept() 方法接受访问者对象访问。\n- 访问者是一接口，拥有一 visit() 方法对访问到的对象结构中不同类型的元素作出不同的处理。\n\n\t> * 在对象结构的一次访问中，遍历整个对象结构，对每个元素实施 accept() 方法。  \n\t> * 每一元素的 accept() 方法会调用访问者的 visit() 方法，即访问者可针对对象结构设计不同的访问类来完成不同操作。\n\n#### 访问者模式的定义\n封装用于某种数据结构中各元素操作，且在不改数据结构的前提下定义这些元素的新操作。\n\n#### 访问者模式的使用场景\n- 对一对象结构中的对象进行不同且不相关的操作。\n- 需避免操作“污染”对象的类。\n- 增加新操作是不修改这些类。\n- 对象结构稳定，但经常需在对象结构上定义新操作。\n\n#### 访问者模式的 UML 类图\n访问者模式的 UML 类图如图 2-28 所示。\n\n![访问者模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-28.png)\n<center>图 2-28 访问者模式的 UML 类图</center>\n\n#### 访问者模式的简单示例\n公司给员工进行业绩考核，评定由公司高层负责。但不同领域的管理人员对与员工的评定标准不一样。即我们把员工分为工程师和经理，评定员工分为 CTO 和 CEO。\n\n假定 CTO 关注工程师的代码量，经理的新产品数量；CEO 关注工程师的 KPI，经理的 KPI 及新产品数量。\n\n便于理解，本示例的 UML 类图如图 2-29 所示。\n\n![公司员工业绩考核](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-29.png)\n<center>图 2-29 公司员工业绩考核</center>\n\n```Java\n// 员工基类\npublic abstract class Staff {\n\tpublic String name;\n\tpublic int kpi; // 员工 KPI\n\tpublic Staff(String name) {\n\t\tthis.name = name;\n\t\tkpi = new Random().nextInt(10); // 随机生成 10 内的值.\n\t}\n\t\n\t// 接受 Visitor 的访问\n\tpublic abstract void accept(Visitor visitor);\n}\n\n// 工程师类型\npublic class Engineer extends Staff {\n\tprivate int codes; // 代码量\n\t\n\tpublic Engineer (String name) {\n\t\tsuper(name);\n\t\tcodes = new Random().nextInt(100000)\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic int getCodeLines() { // 工程师一年内写的代码量\n\t\treturn codes;\n\t}\n}\n\n// 经理类型\npublic class Manager extends Staff {\n\tprivate int products; // 产品数量\n\t\n\tpublic Manager (String name) {\n\t\tsuper(name);\n\t\tproducts = new Random().nextInt(10);\n\t}\n\t\n\t@Override\n\tpublic void accept(Visitor visitor) {\n\t\tvisitor.visit(this);\n\t}\n\t\n\tpublic int getProducts() { // 经理一年内做的产品数量\n\t\treturn products;\n\t}\n}\n\npublic interface Visitor {\n\t// 访问工程师类型\n\tpublic void visit(Engineer engineer); \n\t\n\t// 访问经理类型\n\tpublic void visit(Manager leader); \n}\n\n// CEO 访问者\npublic class CEOVisitor implements Visitor {\n\t@Override\n\tpublic void visit(Engineer engineer) {\n\t\tSystem.out.println(\"Name:..., KPI:...\");\n\t}\n\t\n\t@Override\n\tpublic void visit(Manager mgr) {\n\t\tSystem.out.println(\"Name:..., KPI:..., Products:...\");\n\t}\n}\n\n// CTO 访问者\npublic class CTOVisitor implements Visitor {\n\t@Override\n\tpublic void visit(Engineer engineer) {\n\t\tSystem.out.println(\"Name:..., Codes:...\");\n\t}\n\t\n\t@Override\n\tpublic void visit(Manager mgr) {\n\t\tSystem.out.println(\"Name:..., Products:...\");\n\t}\n}\n\npublic class BusinessReport {\n\tList<Staff> mStaffs = new LinkedList<Staff>();\n\t\n\tpublic BusinessReport() {\n\t\tmStaffs.add(new Manager(\"Manager Wang.\"));\n\t\tmStaffs.add(new Manager(\"Manager Lin.\"));\n\t\tmStaffs.add(new Manager(\"Engineer Kael.\"));\n\t\tmStaffs.add(new Manager(\"Engineer Chaos.\"));\n\t}\n\t\n\t/**\n\t * 为访问者展示报表\n\t * @param visitor 公司高层，如 CEO、CTO\n\t */\n\tpublic void showReport(Visitor visitor) {\n\t\tfor( Staff staff : mStaffs ) {\n\t\t\tstaff.accept(visitor);\n\t\t}\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tBusinessReport report = new BusinessReport();\n\t\treport.showReport( new CEOVisitor() );\n\t\treport.showReport( new CTOVisitor() );\n\t}\n}\n```\n\n#### 总结\n- 对象结构足够稳定，需在对象结构上经常定义新操作，且需对对象结构中的对象进行很多不同且不相关的操作，考虑访问者模式。\n- 访问者模式的优缺点\n\t- 优点  \n\t1) 单一职责原则，即各角色职责分离。  \n\t2) 数据结构和作用于该结构上的操作解耦。  \n\t- 缺点  \n\t1) 具体元素对访问者公布细节。  \n\t2) 具体元素变更导致修改成本大。  \n\t3) 违反依赖倒置原则，即为了“区别对待”而依赖了具体类，没有依赖抽象，如上例中的 Engineer 与 Manager。  \n\t\n### 中介者模式\n\n#### 中介者模式的介绍\n- 又称为调节者模式或调停者模式，行为型设计模式。\n\n#### 中介者模式的定义\n- 包装一系列对象相互作用的方式，使这些对象不必相互明显作用。\n- 将多对多的相互作用转化为一对多的相互作用。\n- 将对象的行为和协作抽象化。\n\n#### 中介者模式的使用场景\n- 对象间交互操作较多且每个对象的行为操作都依赖彼此时，为防止修改其中一对象的行为同时涉及修改很多其他对象的行为。\n- 该模式将对象之间的多对多关系变成一对多关系。\n- 中介者对象将系统从网状结构变成以调停者为中心的星形结构，以降低系统复杂性，提高可扩展性作用。\n\n#### 中介者模式的 UML 类图\n中介者模式的 UML 类图如图 2-30 所示。\n\n![中介者模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-30.png)\n<center>图 2-30 中介者模式的 UML 类图</center>\n\n```Java\n// 抽象中介者\npublic abstract class Mediator {\n\tprotected ConcreteColleagueA colleagueA; // 具体同事类 A\n\tprotected ConcreteColleagueB colleagueB; // 具体同事类 B\n\t\n\t// 抽象中介方法、子类实现\n\tpublic abstract void method();\n\t\n\tpublic void setColleagueA(ConcreteColleagueA colleagueA) {\n\t\tthis.colleagueA = colleagueA;\n\t}\n\t\n\tpublic void setColleagueB(ConcreteColleagueB colleagueB) {\n\t\tthis.colleagueB = colleagueB;\n\t}\n}\n\n// 具体中介者\npublic class ConcreteMediator extends Mediator {\n\t@Override\n\tpublic void method() {\n\t\tcolleagueA.action();\n\t\tcolleagueB.action();\n\t}\n}\n\n// 抽象同事\npublic abstract class Colleague {\n\tprotected Mediator mediator; // 中介者对象\n\t\n\tpublic Colleague(Mediator mediator) {\n\t\tthis.mediator = mediator;\n\t}\n\t\n\t// 同事角色的具体行为，由子类去实现\n\tpublic abstract void action();\n}\n\n// 具体同事 A\npublic class ConcreteColleagueA extends Colleague {\n\tpublic ConcreteColleagueA(Mediator mediator) {\n\t\tsuper(mediator);\n\t}\n\t\n\t@Override\n\tpublic void action() {\n\t\tSystem.out.println(\"Colleague A 将信息递交给中介者处理.\");\n\t}\n}\n\n// 具体同事 B\npublic class ConcreteColleagueB extends Colleague {\n\tpublic ConcreteColleagueB(Mediator mediator) {\n\t\tsuper(mediator);\n\t}\n\t\n\t@Override\n\tpublic void action() {\n\t\tSystem.out.println(\"Colleague B 将信息递交给中介者处理.\");\n\t}\n}\n```\n\n#### 中介者模式的简单实现\n便于理解，本示例的 UML 类图如图 2-31 所示。\n\n![电脑内部硬件的交互](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-31.png)\n<center>图 2-31 电脑内部硬件的交互</center>\n\n中介者模式就是用来协调多个对象之间的交互，就像上例中的主板，没有主板这个中介者，那么电脑里的每一个零部件都要与其他零部件建立关联。\n\n比如 CPU 要与内存交互，与显卡交互以及与 IO 设备交互，那么这样一来就会构成一个错综复杂的网状图，而中介者模式即将网状图变成一个结构清晰的星形图。\n\n#### 中介者模式实战\n协调多个交互的对象，Android 中这么多形形色色控件也算是交互对象。其中社交、网商等应用的用户登录模块，账号框、密码框、登录按钮之间的相互制约、联系，正是中介者模式的表现，具体的实例样式可自行尝试。\n\n#### 总结\n- 中介者模式的优缺点\n\t- 优点 - 将网状般的依赖关系转化为以中介者为中心的星形结构，即使用中介者模式可对这种依赖关系进行解耦使逻辑结构清晰。\n\t- 缺点 - 若几个类间的依赖关系并不复杂，使用中介者模式反而会使原本不复杂的逻辑结构变得复杂。\n\n### 代理模式\n\n#### 代理模式的定义\n- 结构型设计模式。\n- 为其他对象提供一种代理以控制对这个对象的访问。\n\n#### 代理模式的使用场景\n- 无法或不想直接访问某个对象或访问某对象存在困难。\n- 为保证客户端使用的透明性，委托对象与代理对象需实现相同的接口。\n\n#### 代理模式的 UML 类图\n代理模式的 UML 类图如图 2-32 所示。\n\n![代理模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-32.png)\n<center>图 2-32 代理模式的 UML 类图</center>\n\n```Java\n// 抽象主题类\npublic abstract class Subject {\n\t// 一个普通的业务方法\n\tpublic abstract void visit();\n}\n\n// 实现抽象主题的真实主题类\npublic class RealSubject extends Subject {\n\tpublic void visit() {\n\t\tSystem.out.println(\"Real Subjetc!\");\n\t}\n}\n\n// 代理类\npublic class ProxySubject extends Subject {\n\tprivate RealSubject mSubject; // 持有真实主题的引用\n\t\n\tpublic ProxySubject(RealSubject mSubject) {\n\t\tthis.mSubject = mSubject;\n\t}\n\t\n\t@Override\n\tpublic void visit() {\n\t\tmSubject.visit();\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String args) {\n\t\t// 构造一个真实主题对象\n\t\tRealSubject real = new RealSubject();\n\t\t// 通过真实主题对象构造一个代理对象\n\t\tProxySubject proxy = new ProxySubject(real);\n\t\t// 调用代理的相关方法\n\t\tproxy.visit(); \n\t}\n}\n```\n\n**Subject：抽象主题类**  \n该类主要职责是声明真实主题与代理的共同接口方法，其可是抽象类或接口。\n\n**RealSubject：真实主题类**  \n该类也被称为被委托类或者被代理类，该类定义了代理所表示的真实对象，由其执行具体的业务逻辑方法，而客户类则通过代理类间接地调用真实主题类中定义的方法。\n\n**ProxySubject：代理类**  \n该类也称为委托类或者代理类，该类持有一个对真实主题类的引用，在其所实现的接口方法中调用真实主题类中相应的接口方法执行，以起到代理的作用。\n\n#### 代理模式的简单实现\n以生活中常有的例子，老板拖欠工资甚至克扣工资的情况，而最恰当的途径就是通过法律诉讼解决问题。一旦选择走法律途径解决该纠纷，那么不可避免地需请一个律师来作为自己的诉讼代理人。\n\n便于理解，本示例的 UML 类图如图 2-33 所示。\n\n![律师作为诉讼代理人](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-33.png)\n<center>图 2-33 律师作为诉讼代理人</center>\n\n```Java\n// 诉讼接口类\npublic interface ILawsuit {\n\tvoid submit(); // 提交申请\n\tvoid burden(); // 进行举证\n\tvoid defend(); // 开始辩护\n\tvoid finish(); // 诉讼完成\n}\n\n// 具体诉讼人\npublic class XiaoMin implements ILawsuit {\n\t@Override\n\tpublic void submit() {\n\t\tSystem.out.println(\"老板拖欠工资，特此申请仲裁!\");\n\t}\n\t@Override\n\tpublic void burden() {\n\t\tSystem.out.println(\"这是合同书和过去一年的银行工资流水!\");\n\t}\n\t@Override\n\tpublic void defend() {\n\t\tSystem.out.println(\"证据确凿!\");\n\t}\n\t@Override\n\tpublic void finish() {\n\t\tSystem.out.println(\"诉讼成功!\");\n\t}\n}\n\n\n// 代理律师\npublic class Lawyer implements ILawsuit {\n\tprivate ILawsuit mLawsuit; // 持有一个具体被代理者的引用\n\t\n\tpublic Lawyer(ILawsuit lawsuit) {\n\t\tmLawsuit = lawsuit;\n\t}\n\t@Override\n\tpublic void submit() {\n\t\tmLawsuit.submit();\n\t}\n\t@Override\n\tpublic void burden() {\n\t\tmLawsuit.burden();\n\t}\n\t@Override\n\tpublic void defend() {\n\t\tmLawsuit.defend();\n\t}\n\t@Override\n\tpublic void finish() {\n\t\tmLawsuit.finish();\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\n\t\tILawsuit xiaomin = new XiaoMin();\n\t\tILawsuit lawyer = new Lawyer(xiaomin);\n\n\t\tlawyer.submit();\n\t\tlawyer.burden();\n\t\tlawyer.defend();\n\t\tlawyer.finish();\n\t}\n}\n```\n\n- 静态代理  \n\t代码由程序员自己或者通过一些自动化工具生成固定的代码再对其进行编译，即说在我们的代码运行前代理类的 Class 编译文件就已经存在。上述例子即为静态代理的实现模式。\n\n- 动态代理  \n\t通过反射机制动态地生成代理者的对象，即我们在编译阶段不需要知道代理者是谁，代理谁我们将在执行阶段决定。Java 提供了便捷的动态代理接口 InvocationHandler。  \n\t同样，以动态代理方式实现上述例子，本示例的 UML 类图如图 2-34 所示。\n\t\n![动态代理的实现案例](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-34.png)\n<center>图 2-34 动态代理的实现案例</center>\n\n```Java\npublic class DynamicProxy implements IncocationHandler {\n\tprivate Object obj; // 被代理的类引用\n\t\n\tpublic DynamicProxy(Object obj) {\n\t\tthis.obj = obj;\n\t}\n\t@Override\n\tpublic Object invoke(\n\tObject proxy, Method method, Object[] args) throws Throwable {\n\t\tObject result = method.invoke(obj, args);\n\t\treturn result;\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tILawsuit xiaomin = new XiaoMin();\n\t\tDynamicProxy proxy = new DynamicProxy(xiaomin);\n\t\t\n\t\t// 获取被代理类小民的 ClassLoader\n\t\tClassLoader loader = xiaomin.getClass().getClassLoader();\n\t\t// 动态构造一个代理者律师\n\t\tILawsuit lawyer =(ILawsuit) Proxy.newProxyInstance(loader,\n\t\t\tnew Class[] {ILawsuit.class}, proxy);\n\t\t)\n\t\t// 律师提交诉讼申请\n\t\tlawyer.submit();\n\t\t// 律师进行举证\n\t\tlawyer.burden();\n\t\t// 律师代替小民进行辩护\n\t\tlawyer.defend();\n\t\t// 完成诉讼\n\t\tlawyer.finish();\n\t}\n}\n```\n\n#### 总结\n- 代理模式的优缺点\n\t- 优点 - 代理模式可看作一种针对性优化。\n\t- 缺点 - 暂没有明显的缺点。\n\n### 组合模式\n\n#### 组合模式的介绍\n- 又称部分整体模式，结构型设计模式。\n- 它将一组相似的对象看作一个对象处理，并根据一个树状结构来组合对象，然后提供一个统一的方法去访问相应对象。\n\n\t例如公司组织结构的树状图，如图 2-35 所示。\n\n\t![公司组织结构的树状图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-35.png)\n<center>图 2-35 公司组织结构的树状图</center>\n\n\t在组合模式中，我们将这样的一个拥有分支的节点称之为枝干构件，位于树状结构顶部的枝干结构比较特殊，我们称为根结构件，因其为整个树状图的始端。同样对于像行政部和研发部这样没有分支的结构，我们称之为叶子结构，这样的一个结构就是组合模式的雏形。如图 2-36 所示。\n\n\t![组合模式的雏形](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-36.png)\n<center>图 2-36 组合模式的雏形</center>\n\n#### 组合模式的定义\n将对象组合成 `树状结构` 以表示 \"部分-整体\" 的 `层次结构`，使得用户对单个对象和组合对象的使用具有一致性。\n\n#### 组合模式的使用场景\n- 表示对象的 `部分-整体` 层次结构时。\n- 从一个整体中能够独立出部分模块或功能的场景。\n\n#### 组合模式的 UML 类图\n组合模式的 UML 类图如图 2-37 所示。\n\n![组合模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-37.png)\n<center>图 2-37 组合模式的 UML 类图</center>\n\n上述所讲与依赖倒置原则相违背，既然是面向接口编程，则我们就该把焦点放在接口设计上，即在 Composite 的一些实现方法定义到 Component 中。\n\n这样，我们会得到一个不一样的组合模式，也称为安全的组合模式，该安全组合模式的 UML 类图见图 2-38 所示。\n\n透明组合模式不管是叶子还是枝干节点都有相同的结构，那么意味着不能单一的 getChildren() 方法得到子字节的类型 (已是叶子节点)，则必须在方法实现的内部进行判断。\n\n![安全的组合模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-38.png)\n<center>图 2-38 安全的组合模式的 UML 类图</center>\n\n```Java\n// 透明的组合模式抽象根节点\npublic abstract class Component {\n\tprotected String name; // 节点\n\t\n\tpulbic Component(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\t/**\n\t * 具体的逻辑方法由子类实现\n\t */\n\tpublic abstract void doSomething();\n\t\n\t/**\n\t * 添加子节点\n\t * @child 子节点\n\t */\n\tpublic abstract void addChild(Component child);\n\t\n\t/**\n\t * 移除子节点\n\t * @child 子节点\n\t */\n\tpublic abstract void removeChild(Component child);\n\t\n\t/**\n\t * 获取子节点\n\t * @param index 子节点对应下标\n\t * @return 子节点\n\t */\n\tpublic abstract Component getChildren(int index);\n}\n\n// 透明的组合模式具体枝干节点\npublic class Composite extends Component {\n\n\t// 存储节点的容器\n\tprivate List<Component> components = new ArrayList<>();\n\t\n\tpublic Composite(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t@Override\n\tpublic void doSomething() {\n\t\tSystem.out.println(name);\n\t\tif( null != components ) {\n\t\t\tfor(Component c : components) {\n\t\t\t\tc.doSomething();\n\t\t\t}\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void addChild(Component child) {\n\t\tcomponents.add(child);\n\t}\n\t\n\t@Override\n\tpublic  void removeChild(Component child) {\n\t\tcomponents.remove(child);\n\t}\n\t\n\t@Override\n\tpublic Component getChildren(int index) {\n\t\treturn components.get(index);\n\t}\n}\n\n// 透明的组合模式叶子节点\npublic class Leaf extends Component {\n\tpublic Leaf(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t@Override\n\tpublic void doSomething() {\n\t\tSystem.out.println(name);\n\t}\n\t\n\t@Override\n\tpublic void addChild(Component child) {\n\t\tthrow new UnsupportedOperationException(\"叶子节点没有子节点\");\n\t}\n\t\n\t@Override\n\tpublic  void removeChild(Component child) {\n\t\tthrow new UnsupportedOperationException(\"叶子节点没有子节点\");\n\t}\n\t\n\t@Override\n\tpublic Component getChildren(int index) {\n\t\tthrow new UnsupportedOperationException(\"叶子节点没有子节点\");\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t// 构造一个根节点\n\t\tComponent root = new Composite(\"Root\");\n\t\t\n\t\t// 构造两个枝干节点\n\t\tComponent branch1 = new Composite(\"Branch1\");\n\t\tComponent branch2 = new Composite(\"Branch2\");\n\t\t\n\t\t// 构造两个叶子节点\n\t\tComponent leaf1 = new Leaf(\"Leaf1\");\n\t\tComponent leaf2 = new Leaf(\"Leaf2\");\n\t\t\n\t\t// 将叶子节点添加至枝干节点中\n\t\tbranch1.addChild(leaf1);\n\t\tbranch2.addChild(leaf2);\n\t\t\n\t\t//将枝干节点添加到根节点中\n\t\troot.addChild(branch1);\n\t\troot.addChild(branch2);\n\t\t\n\t\t// 执行方法\n\t\troot.doSomething();\n\t}\n}\n```\n\n#### 组合模式的简单实现\n在操作系统中，文件系统其实就是一种典型的组合模式例子。\n\n具体地，文件系统中文件就是可被具体程序执行的对象，文件夹就是可存放文件和文件夹的对象。文件系统的组合模式表示如图 2-39 所示。\n\n![文件系统的组合模式表示](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-39.png)\n<center>图 2-39 文件系统的组合模式表示</center>\n\n便于理解，本实例的 UML 类图如图 2-40 所示。\n\n![文件系统的组合模式实现](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-40.png)\n<center>图 2-40 文件系统的组合模式实现</center>\n\n```Java\n// 表示文件或文件夹的抽象类\npublic abstract class Dir {\n\t/**\n\t * 声明一个 List 成员变量存储文件夹下的所有元素\n\t */\n\tprotected List<Dir> dirs = new ArrayList<>();\n\tprivate String name; // 当前文件或文件夹的名称\n\tpublic Dir(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\t/**\n\t * 添加一个文件或文件夹\n\t * @param dir 文件或文件夹\n\t */\n\tpublic abstract void addDir(Dir dir);\n\t\n\t/**\n\t * 移除一个文件或文件夹\n\t * @param dir 文件或文件夹\n\t */\n\tpublic abstract void rmDir(Dir dir);\n\t\n\t/**\n\t * 清空文件夹下所有元素\n\t */\n\tpublic abstract void clear();\n\t\n\t/**\n\t * 输出文件夹目录结构\n\t */\n\tpublic abstract void print();\n\t\n\t/**\n\t * 获取文件夹下所有的文件或文件夹\n\t * @return 文件夹下所有的文件或文件夹\n\t */\n\tpublic abstract List<Dir> getFiles();\n\t\n\t/**\n\t * 获取文件或文件夹的名称\n\t * @return 文件或文件夹的名称\n\t */\n\tpublic String getName() {\n\t\treturn name;\n\t}\n}\n\n// 表示文件夹的类\npublic class Folder extends Dir {\n\tpublic Folder(String name) {\n\t\tsuper(name);\n\t}\n\t@Override\n\tpublic void addDir(Dir dir) {\n\t\tdirs.add(dir);\n\t}\n\t@Override\n\tpublic void rmDir(Dir dir) {\n\t\tdirs.remove(dir);\n\t}\n\t@Override\n\tpublic void clear() {\n\t\tdirs.clear();\n\t}\n\t@Override\n\tpublic void print() {\n\t\tSystem.out.println( getName() + \"(\" );\n\t\tIterator<Dir> iterator = dirs.iterator();\n\t\twhile( iterator.hasNext() ) {\n\t\t\tDir dir = iterator.next();\n\t\t\tdir.print();\n\t\t\tif( iterator.hasNext() ) {\n\t\t\t\tSystem.out.println(\",\\t\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\")\");\n\t}\n\t@Override\n\tpublic List<Dir> getFiles() {\n\t\treturn dirs;\n\t} \n}\n\n// 表示文件的类\npublic class File extends Dir {\n\tpublic File(String name) {\n\t\tsuper(name);\n\t}\n\t@Override\n\tpublic void addDir(Dir dir) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\"文件类不能作为文件夹类来使用，即文件不支持添加也不支持删除\");\n\t}\n\t@Override\n\tpublic void rmDir(Dir dir) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\"文件类不能作为文件夹类来使用，即文件不支持添加也不支持删除\");\n\t}\n\t@Override\n\tpublic void clear() {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\"文件类不能作为文件夹类来使用，即文件不支持添加也不支持删除\");\n\t}\n\t@Override\n\tpublic void print() {\n\t\tSystem.out.println(getName());\n\t}\n\t@Override\n\tpublic List<Dir> getFiles() {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\"文件类不能作为文件夹类来使用\");\n\t} \n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t// 构造一个目录对象表示 C 盘根目录\n\t\tDir diskC = new Folder(\"C\");\n\t\t\n\t\t// C 盘根目录下有一个文件 FileLog.txt\n\t\tdiskC.addDir( new File(\"Filelog.txt\") );\n\t\t\n\t\t// C 盘根目录下有3个子目录 windows、perflogs 和 Program File\n\t\tDir dirWin = new File(\"windows\");\n\t\tDir dirPerf = new File(\"perflogs\");\n\t\tDir dirProg = new File(\"Program File\");\n\t\t\n\t\t// windows 目录下有文件 explorer.exe\n\t\t// perflogs 目录下有文件 perflogs.txt\n\t\t// Program File 目录下有文件 syslogs.txt\n\t\tdirWin.addDir( new File(\"explorer.exe\") );\n\t\tdirPerf.addDir( new File(\"perflogs.txt\") );\n\t\tdirProg.addDir( new File(\"syslogs.txt\") );\n\t\t\n\t\tdiskC.add(dirWin);\n\t\tdiskC.add(dirPerf);\n\t\tdiskC.add(dirProg);\n\t\t\n\t\tdiskC.print();\n\t}\n}\n```\n\n#### 总结\n- 组合模式与解释器模式有一定的类同，两者在迭代对象时都涉及递归的调用，但组合模式所提供的属性层次结构使我们能 `一视同仁` 对待单个对象的对象集合。\n- 组合模式的优缺点\n\t- 优点  \n\t1) 清楚定义分层次的复杂对象，表示对象的全部或部分层次，让高层模块忽略了层次差异，方便对整个层次结构进行控制。  \n\t2) \u0010高层模块可一致地使用一个组合结构或其中单个对象。  \n\t3) 在组合模式中增加新的枝干结构和叶子构件很方便，无须对类库进行修改。  \n\t4) 通过叶子对象和枝干对象的递归组合，形成复杂的树形结构，但对其控制却非常简单。\n\t- 缺点  \n\t1) 新增构件时，不好对枝干中的构件类型进行限制，不能依赖类型系统来施加这些约束，因为大多数情况下他们来自相同的抽象层。  \n\t2) 因此必须进行类型检查来实现。\n\n## 叁 MVC与MVP模式\n待补充。","tags":["设计模式"],"categories":["Reading"]}]