[{"title":"读书笔记 - Android 源码设计模式","url":"%2F2018%2F01%2FDesign-Pattern-Based-on-Android.html","content":"\n* 更新进度\n * 2018.01.30 - 完成序言；\n * 2018.01.31 - 更新第壹章；\n * 2018.02.05 - 更新第贰章，共 5 / 23 种设计模式；\n \n\n## 序言\n\n在你接触过的安卓项目当中，你所接触过的，如监听器、适配器、迭代器等并不陌生，然而它们无不体现着设计模式的精髓。\n\n<!-- more -->\n\n- 推荐书目：\n - 《 设计模式之禅 》\n - 《 设计模式（可复用面向对象软件的基础）》\n\n\n## 总览\n\n- [零 本书架构](#零-本书架构)\n- [壹 面向对象编程六大原则](#壹-面向对象编程六大原则)\n- [贰 二十三种设计模式解析](#贰-二十三种设计模式解析)\n- [叁 MVC 与 MVP 模式](#叁-MVC与MVP模式)\n\n\n## 零 本书架构\n\n### 面向对象六大原则\n\n- 单一职责原则\n> 优化代码第一步。既就一个类而言，应该有且仅有一个引起它变化的原因。\n\n- 开闭原则\n> 让程序更稳定，更灵活。既软件中的对象（类、模块、函数等）应该对于扩展是开放的，但对于修改是封闭的。\n\n- 里氏替换原则\n> 构建扩展性更好的系统。\n\n- 依赖倒置原则  \n> 让项目拥有变化能力，既依赖抽象，不依赖具体实现。\n\n- 接口隔离原则\n> 系统拥有更高灵活性。\n\n- 迪米特原则\n> 也称为「最少知识原则」。既一个对象应对其他对象有最少的了解。\n\n### 二十三种设计模式\n\n| 模式名称 | 一句话描述 |\n| :--- | :--- |\n| 单例模式 | - |\n| Build 模式 | 自由拓展你的项目 |\n| 原型模式 | 使程序运行更高效 |\n| 工厂方法模式 | - |\n| 抽象工厂模式 | - |\n| 策略模式 | 时势造英雄 |\n| 状态模式 | 随遇则安 |\n| 责任链模式 | 使编程更有灵活性 |\n| 解释器模式 | 化繁为简的翻译机 |\n| 命令模式 | 让程序畅通执行 |\n| 观察者模式 | 解决、解耦的钥匙 |\n| 备忘录模式 | 编程中的后悔药 |\n| 迭代器模式 | 解决问题的第三者 |\n| 模块方法模式 | 抓住问题的核心 |\n| 访问者模式 | - |\n| 中介者模式 | - |\n| 代理模式 | - |\n| 组合模式 | 物以类聚 |\n| 适配器模式 | 得心应手粘合剂 |\n| 装饰模式 | - |\n| 享元模式 | 对象共享，避免创建多对象 |\n| 外观模式 | 统一编程接口 |\n| 桥接模式 | 连接两地的交通枢纽 |\n\n### MVC 与 MVP 模式\n\n\n## 壹 面向对象编程六大原则\n\n### 单一职责原则\n\n- Single Responsibility Principle，SRP.\n- 既就一个类而言，应该仅有一个引起它变化的原因。\n\n> 如何划分一个类，一个函数的职责？每个人的经验不同，观点看法也不同，故视具体任务而定。但它也有一些基本的知道原则：  \n> \n> * 两个完全不一样的功能就不应该放到同一个类中。\n> * 一个类中应该是一组相关性很高的函数、数据的封装。\n\n### 开闭原则\n\n- Open Close Principle，OCP.\n- 既软件中的对象（类、模块、函数等）应该对于扩展是开放的，但对于修改是封闭的。\n- 勃兰特·梅耶. 《面向对象软件构造》中提倡：\n - 新的或改变的特性应通过新建不同的类实现，新建的类可通过 `继承` 的方式来重用原类的代码。\n - 已存在的实现类对于修改是封闭的，但新的实现类可通过 `覆写父类的接口` 应对变化。\n\n> 开闭原则知道我们，当软件需变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。\n\n### 里氏替换原则\n\n> **往往开闭原则与里氏替换原则是生死相依、不离不弃的。**\n\n\n- Liskov Substitution Principle，LSP。\n- 所有引用基类的地方必须能透明地使用其子类的对象。\n\n```Java\npublic abstract class View {\n\tpublic abstract void draw();\n\tpublic void measure(int width, int height) {\n\t\t// 测量视图的大小\n\t}\n}\n\npublic class Button extends View {\n\tpublic draw() {\n\t\t// 绘制按钮\n\t}\t\n}\n\npublic class Windows {\n\tpublic show(View child) {\n\tchild.draw();\n\t}\n}\n```\n\n> 上述例子中，任何继承自 View 类的子类都可以设置给 show 方法，既里氏替换。这样千变万化的 View 传递给 Window，Window 只管组织 View，并显示在屏幕上。\n\n### 依赖倒置原则\n\n- Dependence Inversion Principle，DIP.\n- 一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节。\n- 依赖倒置原则的几个关键点：\t\n - 高层模块不应该依赖低层模块，两者都应以来其抽象（接口或抽象类）\n \n\t > 高层模块指调用端，低层模块指实现类。\n\t\n - 抽象不应该依赖细节\n - 细节应依赖抽象\n- 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系。一句话概括：`面向接口编程，面向抽编程`\n\n```Java\n/*\n * 设计一款实现图片缓冲功能的接口，具体的缓冲实现方式、细节，根据实际情况编写。\n */\n \npublic interface ImageChache {\t// ImageCache 缓存抽象\n\tpublic Bitmap get(String url);\n\tpublic void put(String url, Bitmap bmp);\n}\n\npublic class MemoryCache implements ImageCache {\n\t// 根据实际需求，再实现具体细节\n}\n\npublic class ImageLoader {\n\t// 图片缓存类，依赖抽象，不依赖细节\n\tImageCache mCache = new MemoryCache();\n\t\n\tpublic void displayImage(String url, ImageView imageView) {\n\t\tBitmap bmp = mCache.get(url);\n\t\tif(null == bmp){\n\t\t\tdownloadImageAsync(url, imageView);\n\t\t} else {\n\t\t\timageView.setImageBitmap(bmp);\n\t\t}\n\t}\n\t\n\tpublic void setImageCache(ImageCache cache) {\n\t\tmCache = cache;\n\t}\n}\n```\n\n### 接口隔离原则\n\n- Interface Segregation Principles，ISP.\n- 类间的依赖关系应建立在最小的接口上。ISP 将非常庞大、臃肿的接口拆分成更小的和更具体的接口。IPS的目的是系统解开耦合。\n\n> 如上例中，ImageLoader 中的 ImageCache，ImageLoader 只需要知道该缓存对象有存、取缓存图片的接口即可，其他一概不管。\n\n### 迪米特原则\n\n- 一个对象应对其他对象有最少的了解、即类的内部如何实现与调用者、依赖者没关系，调用者或依赖者之需知道它需要的方法即可，其他一概不管。\n\n- 图 1-1 展示了租客、中介与房间相互之间的需求关系。\n\n\t![租客、中介与房间关系](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_1-1.png )\n\t<center>图 1-1 租客、中介与房间关系</center>   \n\n\t因为租客只需要房子，既把需求转达中介，对房子具体的租金、维修、签约等交由中介处理，租客不需要再了解细节。改进效果见图 1-2。\n\n\t![租客、中介与房间关系](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_1-2.png )\n\t<center>图 1-2 改进：租客、中介与房间的关系</center>  \n\n## 贰 二十三种设计模式解析\n\n### 单例模式\n#### 单例模式的定义\n- 确保某 `一个类只有一个实例` ，而且自行实例化并向整个系统提供这个实例。\n\n\t> `一个类只有一个实例` ：避免产生多个对象消耗过多资源，如访问 I/O 和数据库等资源。\n\n\n#### 单例模式 UML 类图\n![单例模式示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-1.png )\n<center>图 2-1 单例模式示意图</center> \n\n- 实现单例模式主要有如下几个关键点：\n - `构造函数` 不对外开放，一般设为 `私有` ；\n - 通过一个 `静态方法` 或者 `枚举返回` 单例类对象；\n - 确保单例类的对象有且只有一个，尤其多线程环境下；\n - 确保单例类对象在 `反序列化` 时不会重新构建对象；\n \n#### 单例模式的简单示例\n```Java\npublic class Staff { // 员工的基类\n\tpublic void work(){\n\t\t// 忽略执行细节\n\t}\n}\n\npublic class VP extends Staff { // 副总裁类\n\tpublic void work() {\n \t\t// 覆写执行细节\n\t}\n}\n\n// 饿汉单例模式：声明静态对象时已初始化\npublic class CEO extends Staff { // 公司保证只有一个 CEO\n\tprivate static final CEO mCeo = new CEO();\n\tprivate CEO(){}\n\tpublic static CEO getCeo() {\n\t\treturn mCeo;\n\t}\n\tpublic void work() {\n\t\t// 覆写执行细节\n\t}\n}\n\n/*\n * 实际中使用：\n * CEO 类不能通过 new 的形式构造对象，只能通过 CEO.getCeo() 函数获取。\n * CEO 对象是静态对象，并在声明时已初始化，保证 CEO 对象的唯一性。\n */\n \nStaff ceo1 = CEO.getCeo();\t\nStaff ceo2 = CEO.getCeo();\n```\n\n#### 单例模式的其他实现方式\n##### 懒汉模式\n- 声明一静态对象；\n- 调用 getInstance() 方法初始化 ( 用时才初始化，既惰性处理机制 )\n\n```Java\n// 懒汉单例模式：用时才初始化，既惰性处理机制\npublic class Singleton {\n\tprivate static Singleton instantce;\n\tprivate Singleton() {}\n\t\n\t// 添加 synchronized 关键字，即 getInstance() 是一个同步方法\n\tpublic static synchronized Singleton getInstance() {\n\t\tif( null == instance ) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n- 懒汉单例模式的优缺点：  \n - 优点 - 使用时才实例化，一定程度上节约资源。  \n - 缺点 - 每次调用 getInstance() 都进行同步，造成不必要同步开销。\n\n##### Double CheckLock (DCL)\n\n```Java\npublic class Singleton {\n\t// private static Singleton sInstance = null;\n\tprivate volatile static Singleton sInstance = null; // 保证 sInstance 对象每次都是从主内存存、读取。\n\t\n\tprivate Singleton() {}\n\t\n\tpublic void doSomething() {\n\t\tSystem.out.println(\"do sth.\");\n\t}\n\t\n\tpublic static Singleton getInstance() {\n\t\tif( null == sInstance ) { // 避免不必要同步\n\t\t\tsynchronized(Singleton.class) {\n\t\t\t\tif( null == sInstance ) { // 此处判空操作，是因为 Java 编译器允许处理器乱序执行，具体解析见注解\n\t\t\t\t\tsInstance = new Singleton();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sInstance;\n\t}\n}\n```\n\nDCL 又称「丑陋的优化」？  \n\nDCL 虽一定程度解决了资源消耗，多余同步、线程安全等问题，但某种情况下还是会出现失效问题 ( 双重检查锁定(DCL) )，既称「丑陋的优化」。\n\n- 线程A，执行 `sInstance = new Singleton();`，编译器会编译成多条汇编指令，具体汇编指令的分工为：  \n - Step.01 给 Singleton 实例分配内存；  \n - Step.02 调用 Singleton() 的构造函数；  \n - Step.03 将 sInstance 对象指向分配的内存空间；  \n\t\n- 然而 Java 编译器允许处理器乱序执行，既有「1-2-3」或「1-3-2」的执行顺序。\n- 若执行「1-3-2」的顺序，这样会使 DCL 的优化失效，既第三步执行完毕，sInstance 非空，线程B取走 sInstance。再使用时就会报错。\n\n##### 静态内部类单例模式\n\n```Java\npublic class Singleton {\n\tprivate Singleton() {}\n\tpublic static Singleton getInstance() {\n\t\treturn SingletonHolder.sInstance;\n\t}\n\tprivate static class SingletonHolder { // 静态内部类\n\t\tprivate static final Singleton sInstance = new Singleton();\n\t}\n}\n```\n\n第一次加载 Singleton 的 getInstance() 方法才会使 sInstance 被初始化。因此，第一次调用 getInstance() 方法会导致虚拟机加载 SingletonHolder 类.\n\n> 内部类是延时加载的，只会在第一次使用时加载，不使用不加载。这样，既保证了线程安全，又保证单例对象唯一性，同时也延迟单例的实例化。\n\n##### 枚举单例\n\n```Java\n// 默认枚举实例的创建是线程安全的，并且在任何情况下它都是一个单例。\npublic enum SingletonEnum {\n\tINSTANCE;\n\tpublic void doSomething() {\n\t\tSystem.out.println(\"do sth.\");\n\t}\n}\n```\n\n#### 总结\n- 不管以哪种形式实现单例模式，它们的核心原理都是将 `构造函数私有化` ，并通过 `静态方法获取一个唯一的实例` 。\n\n\t> 获取实例的过程须保证线程安全，防止反序列化导致重新生成实例对象等。\n\n- 选择哪种实现形式取决项目本身，如是否是复杂的并发环境、JDK 版本是否过低、单例对象的资源消耗等。\n- 单例模式的优缺点\n - 优点  \n 1) 只生成一个实例，减少系统的性能开销；  \n 2) 当一对象的产生需要较多资源时，如读取配置、产生其他依赖对象时，可通过应用启动时直接产生一个单例对象，永久驻留内存。  \n - 缺点  \n 1) 单例模式一般没有接口，扩展性难；  \n 2) 单例对象若持有 Context，那么很容易引发内存泄漏，此时需注意传递给单例对象的 Context 应该是 `Application.Context` 。\n \n### Bulider 模式\n#### Bulider 模式的定义\n- 创建型设计模式。\n- 将一个复杂对象的 `构建` 与它的 `表示` 分离，使得同样的构建过程可以创建不同的表示。\n- Builder 模式是一步步创建一个复杂对象的，它允许用户在不知内部构建细节的情况下，可以更精细地控制对象的构造流程。\n\n#### Builder 模式的使用场景\n- 产品类非常复杂，或产品类中调用顺序不同产生不同的作用，这时需要使用 Builder 模式。\n- 初始化一个对象特别复杂，如参数多，且很多参数都具有默认值。\n\n#### Builder 模式的UML类图\n![Builder模式示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-2.png )\n<center>图 2-2 Builder 模式示意图</center> \n\n#### Builder 模式的简单实现\n\n便于理解，本示例的 UML 类图见图 2-3。\n\n![计算机组装过程](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-3.png )\n<center>图 2-3 计算机组装过程</center> \n\n```Java\n/*\n * 下述程序以计算机组装过程简化为：构建主机，设置操作系统，设置显示器。\n */\n \n// 计算机抽象类，既 Product 角色\npublic abstract class Computer {\n\tprotected String mBoard;\n \tprotected String mDisplay;\n \tprotected String mOS;\n \tprotected Computer() {}\n \tpublic void setBoard(String board) { // 设置 CPU 核心数\n \t\tmBoard = board;\n \t}\n \tpublic void setDisplay(String display) { // 设置内存\n \t\tmDisplay = display;\n \t}\n \tpublic abstract void setOS();\n \t@override\n \tpublic String toString() {\n \t\treturn \"Computer[...]\";\n \t}\n }\n \n// 具体的 Computer 类 - MacBook\npublic class Macbook extends Computer {\n \tprotected Macbook() {}\n \t@override\n \tpublic void setOS() {\n \t\tmOS = \"MAC OSX 10.10\";\n\t}\n}\n \n// 抽象 Builder 类\npublic abstract class Builder {\n \tpublic abstract class Builder {\n \t\tpublic abstract void buildBoard(String board); // 设置主机\n \t\tpublic abstract void buildOS(); // 设置操作系统\n \t\tpublic abstract void buildDisplay(String display); // 设置显示器\n \t\tpublic abstract Computer create(); // 创建 Computer\n\t}\n}\n \n// 具体的 Builder 类 - MacbookBuilder\npublic class MacbookBuilder extends Builder {\n \tprivate Computer mComputer = new Macbook();\n \tpublic void buildBoard(String board){\n \t\tmComputer.setBoard(board);\n \t}\n \tpublic void buildDisplay(String display) {\n \t\tmComputer.setDisplay(display);\n \t}\n \tpublic void buildOS() {\n \t\tmComputer.setOS();\n \t}\n \tpublic Computer create() {\n \t\treturn mComputer;\n \t}\n}\n \n// Director 类，负责构造 Computer\npublic class Director {\n \tBuilder mBuilder = null;\n \tpublic Director(Builder builder) {\n \t\tmBuilder = builder;\n \t}\n \tpublic void construct(String board, String display) {\n \t\tmBuilder.buildBoard(board);\n \t\tmBuilder.buildDisplay(display);\n\t\tmBuilder.buildOS();\n \t}\n}\n\n// 客户端实现\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tBuilder builder = new MacbookBuilder(); // 构造器\n \t\tDirector pcDirector = new Director(builder); // Director\n \t\t// 封装构建过程\n \t\tpcDirector.construct(\"英特尔主板\", \"Retina 显示器\");\n \t\tSystem.out.println(\"Computer Info: \" + builder.create().toString());\n \t}\n}\n```\n\n#### Builder 模式实战\n```Java\n/*\n * 知名图片加载库：Universal-Image-Loader\n */\n\nImageLoaderConfiguration config = new ImageLoaderConfiguration\n.Builder(context) // 用户只能通过 Builder 对象构建 ImageLoaderConfiguration 对象，这就是构建和表示相分离\n.threadPriority(Thread_NORM_PRIORITY_2)\n.denyCacheImageMultipleSizesInMemory()\n.discCacheFileNameGenerator( new MD5FileNameGenerator() )\n.tasksProcessingOrder(QueueProcessingType.LIFO)\n.bulider();\n\nImageLoader.getInstance().init(config);\n```\n\n#### 总结\n- Builder 模式，通过作为配置类的构建器将配置的构建和表示分离开来，同时也将配置从目标类中隔离出来，避免过多的 Setter 方法暴露在目标类当中。\n- Builder 模式的优缺点\n - 优点  \n 1) 良好的封装性，不必知道产品内部组成的细节；  \n 2) 建造者独立，易于扩展。\n - 缺点  \n 1) 产生多余 Builder 对象及 Director 对象，消耗内存。\n\n### 原型模式\n#### 原型模式的定义\n- 创建性的模式。\n- 定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。\n - 原型拥有样板实例，可克隆内部属性一致的对象。\n - 原型模式多用于创建复杂的或构建耗时的实例，既复制一个已经存在的实例可使程序运行更高效。\n\n#### 原型模式的使用场景\n- 类初始化需消耗非常多的资源 ( 数据、硬件资源等 )。\n- 通过 new 产生一个对象需要非常繁琐的数据准备或访问权限。\n- 一个对象需提供其他对象访问，且各调用者可能都需修改其值时，可考虑用原型模式或拷贝多个对象以供调用者使用，既 `保护性拷贝` 。\n\n#### 原型模式的 UML 类图\n![Builder模式示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-4.png )\n<center>图 2-4 原型模式的 UML 类图</center> \n\n#### 原型模式的简单实现\n便于理解，本示例的 UML 类图见图 2-5。\n\n![WordDocument文档编辑器](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-5.png )\n<center>图 2-5 WordDocument 文档编辑器</center> \n\n```Java\n/*\n * WordDocument 具有文字、图片编辑功能的简单文档处理类。且为保护源文件，其可在克隆对象上作内容修改。\n */\npublic class WordDocument implements Cloneable {\n\t// WordDocument 扮演 ConcretePrototype 角色\n\t// Cloneable 扮演 Prototype 角色\n\tprivate String mText; // 文本\n\tprivate ArrayList<String> mImages = new ArrayList<String>(); // 图片名列表\n\tpublic WordDocument() {\n\t\t// 忽略实现细节\n\t}\n\t@override\n\tprotected WordDocument clone() {\n\t\ttry {\n\t\t\tWordDocument doc = (WordDocument) super.clone();\n\t\t\tdoc.mText = this.mText;\n\t\t\tdoc.mImages = this.mImages;\n\t\t\treturn doc;\n\t\t} catch(Exception e) {\n\t\t}\n\t\treturn null;\n\t}\n\tpublic String getText() {\n\t\treturn mText;\n\t}\n\tpublic void setText(String mText) {\n\t\tthis.mText = mText;\n\t}\n\tpublic List<String> getImage() {\n\t\treturn mImages;\n\t}\n\tpublic void addImage(String img) {\n\t\tthis.mImages.add(img);\n\t}\n\tpublic void showDocument() {\n\t\tSystem.out.println(\"Text:\" + mText);\n\t\tSystem.out.println(\"Images List:\");\n\t\tfor(String imgName:mImages) {\n\t\t\tSystem.out.println(\"image name:\" + imgName);\n\t\t}\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tWordDocument originDoc = new WordDocument();\n\t\t\n\t\t/* Partion A start */\n\t\toriginDoc.setText(\"This is a Aircle\");\n\t\toriginDoc.addImage(\"Image A\");\n\t\t/* Partion A end */\n\t\toriginDoc.showDocument();\n\t\t\n\t\tWordDocument secDoc = originDoc.clone();\n\t\tsecDoc.showDocument();\n\t\tsecDoc.setText(\"This is a Paper\"); // 只是改变了引用指向\n\t\tsecDoc.showDocument();\n\t\toriginDoc.showDocument(); // 还是输出 Partion A 的结果\n\t}\n}\n```\n\n> 注：通过 clone() 拷贝对象时并不会执行构造函数。如果在构造函数中需要一些特殊的初始化操作类型，在使用 Cloneable 实现拷贝时，注意构造函数不会执行的问题。\n\n#### 浅拷贝和深拷贝\n- 浅拷贝：上述例子实际上只是一个浅拷贝，也称 `影子拷贝`，既只是副本文档引用原始文档的字段。\n\n ![浅拷贝示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-6.png )\n <center>图 2-6 浅拷贝示意图</center> \n\n ```Java\n secDoc.setText(\"This is a Paper.\");\n secDoc.addImage(\"Image B\");\n secDoc.showDocument(); // Case 1\n originDoc.showDocument(); // Case 2\n\n // Case 1，2 都增加了图片 “Image B”，原因是 secDoc 只是单纯指向了 this.mImages\n ```\n\n- 深拷贝：为了解决浅拷贝所带来的“问题” ( 视具体问题而定 )，引入深入拷贝。\n\n ```Java\n @override\n protected WordDocument clone() {\n \ttry {\n \t\tWordDocument doc = (WordDocument) super.clone();\n \t\tdoc.mText = this.mText;\n \t\t// doc.mImages 指向 mImages 的一份拷贝，而不是 this.mImages 本身\n \t\tdoc.mImages = (ArrayList<String>) this.mImages.clone();\t\t\n \t\treturn doc;\n \t} catch(Exception e) {\n \t}\n \treturn null;\n }\n ```\n\n#### 原型模式实战\n```Java\n/*\n * 在线用户信息修改 (需登录后修改用户信息)\n */\n\npublic class User { // 用户实体类\n\tpublic int age;\n\tpublic String name;\n\tpublic String phoneNum;\n\tpublic Adress,adress;\n\t\n\t@override\n\tpublic String toString() {\n\t\treturn \"User[age=...]\";\n\t}\n}\n\npublic interface Login ( // 登录接口\n\tvoid login();\n)\n\npublic class LoginImpl implements Login {\n\t@override\n\tpublic void login() {\n\t\tUser loginedUser = new User(); // 登录服务器，获取用户信息\n\t\tloginedUser.age = 12;\n\t\tloginedUser.name = \"Mr.Sample\";\n\t\tloginedUser.address = new Address(\"BeiJing\", \"HaiDing\", \"Garden Rd\");\n\t\t\n\t\t// 登录完成后，将用户信息设置到 Session:\n\t\tLoginSession.getLoginSession()\n\t\t\t.setLoginedUser(loginedUser)\n\n\t}\n}\n\npublic class LoginSession { // 登录 Session\n\tstatic LoginSession sLoginSession = null;\n\tprivate User longinedUser; // 已登录用户\n\tprivate LoginSession() {}\n\tpublic static LoginSession getLoginSession() {\n\t\tif(null == sLoginSession) {\n\t \t\tsLoginSession = new LoginSession();\n\t \t}\n\t \treturn sLoginSession;\n\t}\n\t\n\t// 包级私有：既不加任何修饰符，该模式(默认访问模式)下，只允许在同一包中进行访问\n\tvoid setLoginedUser(User user) { // 设置已登录用户信息，不对外开放\n\t\tloginedUser = user;\n\t}\n\t\n\tpublic User getLoginedUser() {\n\t\treturn loginedUser;\n\t}\n}\n\n/* Partion A : 以下是实际执行部分，可能在不同包的某个类下执行 */\n\n// 获取已登录的 User 对象\nUser newUser = LoginSession.getLoginSession().getLoginedUser();\n// 更新用户信息\nnewUser.address = new Adress(\"BeiJing\", \"ChaoYang\", \"DaWang Rd\");\n```\n\n用户信息的更新，限定于与 LoginSession 类在同一包下才能执行，既 Partion A 的操作，使这样的限定失效。我们可作以下改进：\n\n- 在 User 类中实现 Cloneable 接口。\n- 在 LoginSession 中将 getLoginedUser() 改为 `return loginedUser.clone()` ，既在任何地方调用，获得的都是用户拷贝的对象，修改只是作用于拷贝的对象。\n\n\n```Java\n// 实现 Cloneable 接口\npublic class User implements Cloneable { // 用户实体类\n\tpublic int age;\n\tpublic String name;\n\tpublic String phoneNum;\n\tpublic Adress,adress;\n\t\n\t@override\n\tpublic User clone() {\n\t\tUser user = null;\n\t\ttry {\n\t\t\tuser = (User) super.clone();\n\t\t} catch(CLoneNotSupportedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn user;\n\t}\n\t\n\t@override\n\tpublic String toString() {\n\t\treturn \"User[age=...]\";\n\t}\n}\n\npublic class LoginSession { \n\t// 既管在任何地方调用，获得的都是用户拷贝的对象\n\tpublic User getLoginedUser() {\n\t\treturn loginedUser.clone();\n\t}\n}\n```\n#### 总结\n- 原型模式的优缺点\n - 优点 - 原型模式是在内存中二进制的拷贝，比 new 一个对象性能更优。\n - 缺点 - 内存中拷贝，构造函数是不会执行的。\n\n### 工厂方法模式\n#### 工厂方法模式的定义\n- 创建型设计模式。\n- 定义一个用于创建对象的接口，让子类决定实例化哪个类。\n\n#### 工厂方法模式的使用场景\n- 复杂对象的创建，而用 New 就可以完成创建的对象则不必使用工厂方法了。\n\n#### 工厂方法模式的 UML 类图\n工厂方法模式的 UML 如图 2-7 所示。\n\n![浅拷贝示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-7.png )\n <center>图 2-7 工厂方法模式 UML 类图</center> \n \n```Java\npublic abstract class Product {\n\tpublic abstract void method();\n}\npublic class ConcreteProductA extends Product { // 具体产品 A\n\t@override\n\tpublic void method() {\n\t\tSystem.out.println(\"我是具体的产品A.\");\n\t}\n}\npublic class ConcreteProductB extends Product { // 具体产品 B\n\t@override\n\tpublic void method() {\n\t\tSystem.out.println(\"我是具体的产品B.\");\n\t}\n}\n\npublic abstract class Factory { // 抽象工厂类\n\t/*\n\t * @return 具体的产品对象\n\t */\n\t public abstract Product createProduct();\n}\npublic class ConcreteFactory extends Factory {\n\t@override\n\tpublic Product createProduct() {\n\t\t// 返回具体产品 A 或者具体产品 B\n\t\t// return new ConcreteProductA();\n\t\t// return new ConcreteProductB();\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tFactory factory = new ConcreteFactory();\n\t\tProduct p = factory.createProduct();\n\t\tp.method();\n\t}\n}\n```\n\n另外，我们可以利用反射的方式实现多工厂方法模式，具体见下述代码。\n\n```Java\npublic abstract class Factory {\n\n\t/*\n \t* 具体生产什么由子类去实现\n \t* @param clz 产品对象类类型\n \t* @return 具体的产品对象\n \t*/\n \t\n \tpublic abstract<T extends Product> T createProduct(class<T> clz);\n }\n\npublic class ConcreteFactory extends Factory {\n\t@override\n\tpublic <T extends Product> T createProduct(class<T> clz) {\n\t\tProduct p = null;\n\t\ttry {\n\t\t\tp = (Product) class.forName(clz.getName()).newInstance();\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn (T) p;\n\t}\n}\n\n// 客户端中实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tFactory factory = new ConcreteFactory();\n\t\tProduct p = factory.createProduct(ConcreteProductA.class);\n\t\tp.method();\n\t}\n}\n```\n\n#### 工厂方法模式的简单实现\n便于理解，本示例的 UML 类图见图 2-8。\n\n![某工厂生产某车型的工厂方法](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-8.png )\n<center>图 2-8 某工厂生产某车型的工厂方法</center> \n \n```Java\npublic abstract class AudiFactory {\n\n\t/*\n\t * 某工厂生产某种车型的工厂方法\n\t * @param clz 具体的 SUV 型号类型\n\t * @return 具体型号的 SUV 车对象\n \t */\n\n\tpublic abstract<T extends AudiCar> T createAudiCar(class<T> clz);\n}\n\npublic class AudiCarFactory extends AudiFactory {\n\t@override\n\tpublic <T extends AudiCar> T createProduct(class<T> clz) {\n\t\tProduct p = null;\n\t\ttry {\n\t\t\tp = (AudiCar) class.forName(clz.getName())\n\t\t\t\t.newInstance(); \n\t\t} catch() {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn (T) p;\n\t}\n}\n\npublic abstract class AudiCar {\t// 汽车的抽象产品类\n\tpublic abstract void drive();\n\tpublic abstract void selfNavigation();\n}\n\npublic class AudiQ3 exntends AudiCar { // 具体车型：Q3\n\t@override\n\tpublic void drive() {\n\t\tSystem.out.println(\"Q3 Launched!\");\n\t}\n\t@override\n\tpublic void selfNavigation() {\n\t\tSystem.out.println(\"Q3 starts a auto-navigation!\");\n\t}\n}\n\n// 客户端实现\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tAudiFactory factory = new AudiFactory();\n\t\tAudiQ3 audiQ3 = factory.createProduct(AudiQ3.class);\n\t\taudiQ3.dirve();\n\t\taudiQ3.selfNavigation();\t\n\t}\n}\n```\n#### 工厂方法模式的实战\nAndroid 数据持久化有很多方式，如 SharedPreferences (XML)、SQLite (关系数据库)。对数据操作的方法无非就是增、删、改、查，若我们将每种数据储存的方式作为一个产品类，在抽象产品类中定义对数据操作的方法，既我们宏观层面把握操作的逻辑，具体的实现逻辑由储存数据的方式决定。\n\n```Java\npublic abstract class IOHandler {\n\tpublic abstract void add(String id, String name);\n\tpublic abstract void remove(String id);\n\tpublic abstract void update(String id, String name);\n\tpublic abstract String query(String id);\n}\n\npublic class FileHandler extends IOHandler { // 普通文件存储\n\t@override\n\tpublic void add(String id, String name) {\n\t\t/* 业务逻辑 */ }\n\t@override\n\tpublic void remove(String id) {\n\t\t/* 业务逻辑 */ }\n\t@override\n\tpublic void update(String id, String name) {\n\t\t/* 业务逻辑 */ }\n\t@override\n\tpublic String query(String id) {\n\t\t/* 业务逻辑 */ \n\t\treturn \"AigeStudio\";\n\t}\n}\n\npublic class XMLHandler extends IOHandler { // XML 文存储\n\tpublic void add(String id, String name) {\n\t\t/* 业务逻辑 */ }\n\tpublic void remove(String id) {\n\t\t/* 业务逻辑 */ }\n\tpublic void update(String id, String name) {\n\t\t/* 业务逻辑 */ }\n\tpublic String query(String id) {\n\t\t/* 业务逻辑 */\n\t\treturn \"SMBrother\";\n\t}\n}\n\npublic class DBHandler extends IOHandler { // SQLite 数据库存储\n\tpublic void add(String id, String name) {\n\t\t/* 业务逻辑 */ }\n\tpublic void remove(String id) {\n\t\t/* 业务逻辑 */ }\n\tpublic void update(String id, String name) {\n\t\t/* 业务逻辑 */ }\n\tpublic String query(String id) {\n\t\t/* 业务逻辑 */\n\t\treturn \"Android\";\n\t}\n}\n\npublic class IOFactory {\n\t\n\t/*\n\t * 获取 IO 处理者\n\t * @param clz IOHandler 类型的类类型\n\t * @return IOHandler 对象\n\t */\n\t \n\t public static <T extends IOHandler> T getIOHandler(class<T> clz) {\n\t \tIOHandler handler = null;\n\t \ttry {\n\t \t\thandler = (IOHandler) class.forName(clz.getName())\n\t \t\t\t.newInstance();\n\t \t} catch(Exception e) {\n\t \t\te.printStackTrace();\n\t \t}\n\t \treturn (T) handler;\n\t }\n}\n\npublic class FactoryActivity extends Activity {\n\t@override\n\tprotected void onCreate(Bundle saveInstanceState) {\n\t\tsuper.onCreate(saveInstanceState);\n\t\tsetContentView(R.layout.activity_factory);\n\t\t\n\t\t// 获取显示查询内容的 TextView 对象\n\t\tfinal TextView tvContent = (TextView) this.findViewById(R.id.factory_content_tv);\n\t\t// 获取查询普通文件数据的按钮对象，并设置监听\n\t\tButton btnFile = (Button) this.findViewById(R.id.factory_file_btn);\n\t\tbtnFile.setOnClickListener(new View.OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tIOHandler handler = IOFactory.getIOHanHandler(FileHandler.class);\n\t\t\t\tLog.d(\"AigeStudio\", handler.query(\"4455645646\"));\n\t\t\t\ttvContent.setText(handler.query(\"4455645646\"));\n\t\t\t}\n\t\t});\n\t}\n}\n```\n\n### 抽象工厂模式\n#### 抽象工厂模式的定义\n- 创建型设计模式。\n- 为创建一组相关或者是相互依赖的对象 提供一个 `接口` ，而不需要指定它们的具体类。\n\n#### 抽象工厂模式的使用场景\n一个对象族有相同约束时可以使用抽象工厂模式。如：  \nAndroid、iOS、Window Phone 下都有短信软件和拨号软件，两者属于软件范畴，但由于操作系统平台不一样，其代码实现细节也是有差异的，则我们可考虑使用抽象工厂方法模式去产生不同平台下的同款软件。\n\n#### 抽象工厂模式的 UML 类图\n抽象工厂方法模式的 UML 如图 2-9 所示。\n\n![抽象工厂方法模式UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-9.png )\n <center>图 2-9 抽象工厂方法模式 UML 类图</center> \n \n ```Java\n public abstract class AbstractProductA { // 抽象产品类 A\n \tpublic abstractvoid method();\n }\n \n public abstract class AbstractProductB { // 抽象产品类 B\n \tpublic abstractvoid method();\n }\n \n public class ConcreteProducxtA1 extends AbstractProductA { // 具体产品类 A1\n \t@override\n \tpublic void method() {\n \t\tSystem.out.println(\"具体产品 A1 的方法.\");\n \t}\n }\n \n  public class ConcreteProducxtA2 extends AbstractProductA { // 具体产品类 A2\n \t@override\n \tpublic void method() {\n \t\tSystem.out.println(\"具体产品 A2 的方法.\");\n \t}\n }\n \n public class ConcreteProducxtB1 extends AbstractProductB { // 具体产品类 B1\n \t@override\n \tpublic void method() {\n \t\tSystem.out.println(\"具体产品 B1 的方法.\");\n \t}\n }\n \n  public class ConcreteProducxtB2 extends AbstractProductB { // 具体产品类 B2\n \t@override\n \tpublic void method() {\n \t\tSystem.out.println(\"具体产品 B2 的方法.\");\n \t}\n }\n \n public abstract class AbstractFactory { // 抽象工厂类\n \n \t/*\n \t * 创建产品 A 的方法\n \t * @return 产品 A 的对象\n \t */\n \t public abstract AbstractProductA createProductA();\n \t \n \t /*\n \t  * 创建产品 B 的方法\n \t  * @return 产品 B的对象\n \t  */\n \t public abstract AbstractProductB createProductB();\n }\n \n public class ConcreteFactory1 extends AbstractFactory { // 具体工厂类1\n \t@override\n \tpublic abstract AbstractProductA createProductA1() {\n \t\treturn new ConcreteProductA1();\n \t};\n \t@override\n \tpublic abstract AbstractProductB createProductB1() {\n \t\treturn new ConcreteProductB1();\n \t};\n }\n \n  public class ConcreteFactory2 extends AbstractFactory { // 具体工厂类2\n \t@override\n \tpublic abstract AbstractProductA createProductA2() {\n \t\treturn new ConcreteProductA2();\n \t};\n \t@override\n \tpublic abstract AbstractProductB createProductB2() {\n \t\treturn new ConcreteProductB2();\n \t};\n }\n ```\n\n#### 抽象工厂模式的简单实现\n在简单工厂模式的简单实现中，我门以车厂生产汽车为例。虽 Q3、Q5、Q7 同为一车系，但三者之间的零部件产别却很大，如 Q3、Q7 当中，Q3 装配的是国产发动机，普通轮胎和普通制动系统；Q7 则装配的是进口发动机，全尺寸越野轮胎和制动性能极好的制动系统。\n\n既同为一系列车，大家共有部件有发动机、轮胎和制动系统等，由于具体的部件品质不同，装配的细节又不同。故我们可将抽象工厂模式应用当中，化繁为简。具体的架构如图 2-10 的 UML 类图所示。\n\n![车厂生产同系列汽车的抽象工厂模式](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-10.png )\n <center>图 2-10 车厂生产同系列汽车的抽象工厂模式</center>\n \n ```Java\n // P109 ~ 112，案例源码不上\n ``` \n\n#### 总结\n- 抽象工厂方法模式的优缺点\n - 优点 - 分离接口与实现，既客户端使用抽象工厂的创建对象，客户端不知具体实现是谁，客户端只是面向产品的接口编程而已，使其从具体的产品实现中解耦。\n - 缺点  \n 1) 类文件的爆炸性增加。  \n 2) 不太容易扩展新的产品类，因为每当增加一个产品类，就需修改抽象工厂，故所有具体工厂类均会被修改。\n\n### 策略模式\n#### 策略模式介绍\n#### 策略模式的使用场景\n#### 策略模式的 UML 类图\n#### 策略模式的简单实现\n#### 策略模式的实战应用\n#### 总结\n\n## 叁 MVC与MVP模式\n待补充。","tags":["设计模式"],"categories":["Reading"]}]