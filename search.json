[{"title":"冯友兰：中国哲学简史","url":"/2023/03/a-short-history-of-chinese-philosophy.html","content":"\n哲学源于西方的概念名词，各哲学家对于“哲学”的定义亦有不同，中国哲学无不例外。中国哲学，实质上是各思想家学问主张，比如儒家学说、道家学说等。从古至今，中国哲学家特别注重人事之故，极力追求 “内圣外王” 之道，对于宇宙论的研究亦甚简略，若是以西方哲学形式上的系统来定义，那么中国无哲学可言。究竟是对标西方哲学（宇宙论、人生论、认知论），还是自成中国哲学体系，或许这就是冯友兰先生撰写中国哲学史的用意所在，即哲学史要义是找出中国实质的哲学系统。\n\n我们如何学习中国哲学？冯老先生的《[中国哲学史](https://book.douban.com/subject/25899663/)》给出了启示。哲学是对人生终极问题的系统反思，哲学与哲学家出生年代、出生经历、政治背景等有着强相关关系，即哲学具备鲜明个人特点，个人欣赏某一类哲学与他本人的体质、年纪、环境、遭遇等有关系。在思辨过程中，希望你我都能辩证接纳每一种学派思想，无用之用，将来为我所用。\n\n<!-- More -->\n\n## 结构\n- 01 - 02 章：中国哲学的精神、中国哲学的背景。\n- 03 - 16 章：讨论不同思想家的主张，即孔子及之后兴起的一批哲学家及其哲学思想。\n- 17 - 18 章：儒家或道家。汉帝国统治时期，与政治统一伴随而来的便是思想统一，周朝的诸子百家不再以单独学派存在，而是把他们的思想融入儒家或道家中。\n- 19 - 21 章：新道家和佛家。四百年间中国南方、北方分裂，五胡乱华，民众遭受了许多苦难。在哲学上，儒家思想暂时消沉，代之而起的是新道家和佛家思想。\n- 22 - 22 章：禅宗。隋唐唐朝在政治上重建了中国的统一，国力得到空前发展，文化也登上发展高峰。佛家也获得空前发展。\n- 23 - 25 章：新的儒家，主张柏拉图式理念的理学。佛家在中国渐趋没落，儒家再度兴起，并在思想界建立起主导地位。\n- 26 - 26 章：新的儒家，主张宇宙心学。\n- 27 - 28 章：现代世界中国哲学。\n\t- 民国革命推翻了世界最古老王权体制，中华民国成立。此后十几年间，中国在社会、政治、经济等方面亟待改革。改革短时间内纷至沓来，势必造成内部在政治思想上的动荡。\n\t- 天下为空思想（参考 16 - 21 章）。\n\n## 第壹章 中国哲学的精神\n### 哲学在中国文化的地位\n- 哲学是对人生的系统的反思。把人生、宇宙以及知识作为思考的对象，有关人生、有关宇宙以及有关知识的学说就是由这样的思考中产生的。\n\n- 人生、生命、宇宙、知识的概念，都是反思的产物。\n\t- 人无论是自己思索或与别人谈论，都在人生之中反思。\n\t- 我们对宇宙进行思索或与人谈论，都在宇宙其中反思。\n\t\n\t\t> 哲学家所言的“宇宙”有别与物理学家的宇宙，它指代一切存在的整体。中国古代哲学家惠施所说的“大一”，乃是“至大无外”。\n\t\n\t- 我们对知识进行思索或与人谈论，思索和谈论本身也是知识，即亚里士多德所言“关于思索的思索”。\n\n- 宗教也和人生有关联，任何一种大型宗教它的核心必然是哲学。事实上，大型宗教是某种哲学加上一定的上层建筑，包括迷信、教义、礼仪和体制。\n\n\t> 儒家、道家、佛家不是一种宗教。比如道家是一种哲学，而道家才是宗教。道家哲学教导人顺应自然，道教却教导人你逆乎自然。举例来讲，老庄思想“万物有生必有死，人对于死应顺应自然”，而道教宗旨是教导长生术，反乎自然。\n\n- 中国文化的精神基础不是宗教（至少不是有组织形式的宗教），而是伦理（儒家伦理）。\n\n\t> Q：对于世界许多人来说，宗教信仰和宗教活动是基本要求之一，何以中国人成为例外呢？难道中国人不曾意识到，在道德伦理之上还有更高的价值？\n\n- 比伦理道德更高的价值可称为超伦理道德的价值。爱人是一个道德价值，爱神是一个超越道德的价值（宗教价值）。冯老认为，人不满足于现实世界而追求超越现实世界，这是人类内心深处的一种渴望。中国人不那么关切宗教，而是哲学。\n\t- 宗教提供有关实际的正面知识（客观事物），但它于科学提供的不同。在西方出现宗教与科学的冲突，科学每进一步，宗教便后退一步，宗教的权威在科学前进历程中不断被削弱。\n\t- 根据中国哲学传统，哲学的功能不是为了增进正面知识，而是为了提高人的心灵。\n\t- 中国哲学，不需要宗教的祈祷和仪式，也不掺杂想象和迷信，也可达到最高价值。\n\n### 中国哲学的精神和问题\n- 做人最高成就是什么？按照中国哲学说法便是成圣，成圣最高成就则是个人和宇宙合而为一。\n\n\t> Q：如果人追求天人合一，是否需要抛弃社会，更甚否定人生呢？\n\n\t- 出世哲学：主张人应该从物质败坏的世界中解脱出来。\n\n\t\t> 出世哲学过于理想化，不切实际，因而是消极的。\n\n\t- 入世哲学：强调社会中的人际关系和人事。它只谈道德价值，对于超越道德的价值觉得无从谈起，也不愿去探讨。\n\n\t\t> 入世哲学过于实际，过于肤浅。入世哲学诚然积极，但更像走错了方向的人，走得越快，在歧途上就走得越远。\n\n- 中国哲学无论是出世派，还是入世派，都直接或间接关切**政治**和**伦理道德**。\n\t- 中国哲学主要关心社会，而不是宇宙。\n\t- 中国哲学关心人际关系的日常功能，而不是地狱与天堂。\n\t- 中国哲学关心人的今生，而不是关系它的来生。\n\n- 中国哲学它即是入世的，又是出世的。它既是理想主义的，又是现实主义的。在理论上且行动中综合理想与实际，而非两极对立，他就是圣人。圣人的品格可以用“内圣外王”来刻画。\n\t- 内圣：内心深处是致力于心灵的修养。\n\t- 外王：社会活动中积极承担最大责任。\n\n- 哲学家终身持久不懈地操练自己，生活在哲学体验之中，超越了自私和自我中心，以求与天合一。这种心灵的操练一刻也不能停止，一旦停止，自我就会抬头，内心的宇宙意识将会丧失。\n\n### 中国哲学家表达思想方式\n- 中国哲学家惯于用格言、警句、比喻、事例等形式表述思想。\n\t\n\t> 比如《老子》全书都是以格言形式写成。《庄子》充满寓言和故事。\n\n- 一首好诗往往是“言有尽而意无穷”。读书时能从诗句之外去会意，读书时能从字里行间去会意。这就是中国艺术所追求的情趣，也成为中国哲学家表述思想时的风格。\n- 中国艺术的这种风格是有其哲学背景的。比如道家的思想，道不可道，只能暗示。\n\t- 语言的作用不在于它的固定含义，而是在于它的暗示，引发人们去领悟道。\n\t- 一旦语言已完成它的暗示作用，就应该忘掉语言本身，为何要让自己被非必要的语言所拖累呢？\n\n## 第贰章 中国哲学的背景\n### 中华民族的地理环境\n- 中国是一个大陆国家，对于古人而言世界就是他们生活的这片土地。在中文表述中，“普天之下”、“四海之内”通常被用来表述“世界”。\n\n### 中华民族的经济背景\n- 在一个农业国家里，财富的首要基础是土地。因此，在中国历史上，一切社会、经济思想、政府政策措施都以**土地的分配和利用**为中心。\n- 中国哲学家们的社会经济思想都强调要区别“本”和“末”，农业生产是立国之根本，商业则是立国之末端。\n\n\t> 中国历史上，各个社会、经济的理论和政策都 `重农轻商`。\n\n- 读书人通常并不亲自耕地，但他们一般出身于地主家庭，家庭的兴衰和农业生产的好坏联系在一起。因此，他们的宇宙观和人生观都反映了农民的思想，这种表达在中国就采取了哲学、文化、艺术等形式。\n\n#### 反者道之动\n- 在比较儒道两家不同思想前，我们先认识两家共同的理论思想 -- 反者道之动\n- 无论自然、人生领域里，任何事物发展到极端，就有一种趋向，朝反方向的一极端移动。\n\n\t> 借用黑格尔的哲学术语，任何事物都包含了对它自己的否定。\n\n- 这个理论对中华民族有着巨大的影响，帮助中华民族在漫长的历史中克服了无数困难。\n\t- 我们要时常提醒自己要**居安思危**。\n\t- 即使处于极端困难之中也不要失望。\n\t- 处事宁愿不及，也不要过甚，行事过分将适得其反。\n\n#### 自然理想化\n- 儒道两家思想不同，是因为他们对农民生活中的不同方面加以理论化。\n- 农民生活简单、思想纯真。道家基于此点出发，谴责文明，鼓吹返璞归真。道家这种思想最后发展到“天人合一”，即人与自然合一、与宇宙合一。\n\n#### 家族制度\n- 农民靠土地生活，土地无法挪动，即使地主阶级出身的读书人也无法离开土地。一个人若非有特殊才能，否则他无法离开祖辈生活的这片土地，以及他的子孙也生活在这片土地。\n- 由此发展起来的家族制度，它的复杂性和组织性是世界少有的。儒家思想很大程度上便是这种 `家族制度的理性化`。\n- 中国的社会制度便是家庭制度，传统中国把社会关系归纳成君臣、父子、兄弟、夫妇和朋友五种。\n\n\t> 中国的祖先崇拜也是这样发展起来的，时代居住在一个地方的一族人，他们追溯首先在这个地方定居的祖先，敬拜他。祖先成为家族的共同象征，就一个巨大复杂的组织（家族），这样的象征是必不可少的。\n\n- 儒家思想中的一大部分是这种给社会制度的理论论证。\n\n#### 入世出世\n- 儒家“游方之内”，显得比道家入世；道家“游方之外”，显得比儒家出世。\n- 中国哲学既是入世的，又是出世的。\n\t- 在 3、4 世纪间，有一批道家试图使道家思想靠近儒家思想，后世称他们为“新道家”。\n\t- 在 11、12 世纪间，也有一批儒家试图使儒家思想靠近道家思想，后世称他们为“新儒家”。\n\n\n#### 艺术诗歌\n- 儒家把艺术看作是道德教育的工具。\n- 道家对艺术没有正面提出系统的见解，但他们追求心灵的自由流动，把自然看为最高理想，这给中国的伟大艺术家无穷的灵感。\n\n\t> 中国美术作品中的许多杰出作画的都是山水、花鸟、树木、竹枝。在许多山水画里，山脚下、溪水边，往往能看到一个人静坐沉醉与天地的大美之中，从中领会超越于自然和人生之上的妙道。\n\n#### 中国哲学方法论\n- 诺斯洛普教授提出：概念可分两种，一种来自直觉，一种来自假定。\n\t- 直觉的概念指向某个事物，它的完整意义可立即从某个事物中领会到。\n\t- 假设得到的概念，它的完整意义是根据一个假设，演绎法推演，从而认定的。\n\n- 诺斯洛普教授指出 `直觉的概念` 又可分为三种：\n\t- 在连续审视中已予区分的概念\n\t- 连续审视还未予区分或不确定的概念\n\t- 区分的概念\n\n- 由 `假设观念` 出发的哲学家喜欢明确的东西；而由 `直觉` 出发，则需要重视 `不明确` 的东西。\n\n- 结合诺斯洛普教授所讲的：在连续审视中已予区分的概念，由它衍生出还未区分的概念和分辨的概念，基本上是农民的概念。\n\t- 农民与之打交道的，诸如田地和庄稼，都是他们日常接触、认识的东西。\n\t- 他们处于原始和纯真的心态之中，把直接认知的东西看为宝贵的东西，见惯不怪反映他们思想的哲学家们也同样把直接认知的东西看作哲学思维的出发点。\n\n- 这足以解释何以认识论在中国哲学里从未得到发展的原因。\n\t- 中国哲学家对于眼前的这张桌子究竟是真实的，抑或只是幻觉存在，从不认真对待。\n\t- 认识论问题之所以产生，是由于主客观已有了明确的界限。在一个连续审视过程之中，还没有明确区分主客观之间的界限，导致认识的主体与客体还是浑然一体的。\n\n- 这也说明中国哲学的语言何以是提示性的、非明晰的。因为它不代表用理性演绎得出的概念。\n\t\n\t> 哲学家只告诉人们他看到了什么，他们所述简练但内容却很丰富。\n\n#### 海洋与大陆国家\n- 希腊人生活在海洋国家，靠着贸易维持繁荣，他们以商人为先。\n\t- 商人活动要求他们在城镇聚居，因此他们的社会组织更多放映城镇的共同利益，而非家族的共同利益。\n\t- 希腊人以城邦为中心组织社会。中国社会制度或许可称为”家邦“，因为中国是通过家族来理解国家的。\n\n- 组织社会的形式不同\n\t- 在一个城邦里，社会组织难以形成专制独裁统治，因为在同一等级的城镇居民中，难以论证谁更重要、应该享受更高社会地位。\n\t- 在一个家邦里，社会组织是按人生来的地位、等级式地形成的。在一个家庭里，父亲的权威天然高于孩儿的权威。\n\n- 面对创新的态度不同\n\t- 农民的生活方式倾向于顺乎自然，他们爱慕自然，谴责认为；他们不喜欢变革，也无法想象事物会变化。\n\t- 商人有更多机会见到语言、风俗不同的他族人民，他们习惯于变化，对新奇事物并不惧怕。而且为了销售货物，他们必须不断创新制作新货物。\n\n#### 中国哲学常与变\n- 疑问：既然中国哲学产生于过去中国的经济环境之中，它的内容是否只对过去的中国才有意义？\n- 解答：\n\t- 任何民族在任何时代的哲学里，总有一些内容只对处于当时经济条件下的大众有用；除此之外，还会有一部分哲学思想具有持久的价值。\n\t- 我们在学习哲学史时，应当对其中哪些具有永久价值，哪些时可以改变的，进行合乎逻辑的分析。","tags":["儒家","道家","冯友兰","内圣外王","人生","宇宙"],"categories":["Reading"]},{"title":"回顾 2022，启航 2023","url":"/2022/12/2022-Reviews-2023-Plans.html","content":"\n不管走得多快多远，都要回望走过的路。给过去一年复盘，用过往经验武装自己，以最佳状态迎战 2023！\n\n<!-- More -->\n\n## 读书\n- 追求质量再求数量：按照年初书单计划推进，但平时忙于工作，读书速度会有所放缓，所以进度低于预期值。但也只能一点一滴积累基础通识，以后遇到类似内容才能略过，以提升阅读速度。\n- 涉猎广但要有聚焦：阅读类型可以广泛，但阶段性要有所聚焦。与其同时，学科知识跨度也可大一些（同一时间只学习同类型的知识很容易疲倦），以此充分利用大脑高效学习。\n- `已读`：14本\n\t- [技术]《[华为数据之道](https://book.douban.com/subject/35228141/)》\n\t- [心理]《[被讨厌的勇气](https://book.douban.com/subject/26369699/)》\n\t- [其他]《[人间修炼指南](https://book.douban.com/subject/35873836/)》\n\t- [感情]《[爱的博弈](https://book.douban.com/subject/25809012/)》\n\t- [传记]《[曾国藩传](https://book.douban.com/subject/30377678/)》\n\t- [社科]《[马克思主义、毛泽东主义与乌托邦主义](https://book.douban.com/subject/26335271/)》\n\t- [启发]《[软技能：代码之外的生存指南](https://book.douban.com/subject/36044253/)》\n\t- [传记]《[小米创业思考](https://book.douban.com/subject/36057097/)》\n\t- [社交]《[别独自用餐](https://book.douban.com/subject/27074753/)》| [读书笔记](https://www.kofes.cn/2022/10/never-eat-alone.html)\n\t- [启发]《[纳瓦尔宝典](https://book.douban.com/subject/35876121/)》\n\t- [社科]《[工作、消费主义和新穷人](https://book.douban.com/subject/35593780/)》\n\t- [设计]《[事理学方法论](https://book.douban.com/subject/30442146/)》\n\n\t\t> 事理学，类似以第一性原理去研究事物本质。以人为本，循环再生，去设计、创造、表现我们的产品、体验或服务。\n\n\t- [启发]《[认知驱动](https://book.douban.com/subject/35548280/)》\n\t- [投资]《[价值投资实战手册第二辑](https://book.douban.com/subject/35898229/)》\n- `精读`：3本\n\t- [技术]《[大型网站技术架构](https://book.douban.com/subject/25723064/)》| [读书笔记](https://www.kofes.cn/2022/02/mega-web-site-architecture.html)\n\t- [佛法]《[次第花开](https://book.douban.com/subject/5450660/)》| [读书笔记](https://www.kofes.cn/2022/10/blooming-flowers-in-turn.html)\n\t- [设计]《[任天堂的体验设计](https://book.douban.com/subject/35643201/)》| [读书笔记](https://www.kofes.cn/2022/10/nintendo-experience-design.html)\n\t- [技术]《[微服务架构设计模式](https://book.douban.com/subject/33425123/)》\n- `在读`：精读 + 视频课程，需要掌握的知识密度比较高\n\t\n\t- [财务]《[肖星的财务思维课](https://book.douban.com/subject/35033236/)》50%\n\t- [经济]《[认知世界的经济学](https://book.douban.com/subject/35779459/)》25%\n\t- [心理]《[认知心理学及其启示](https://book.douban.com/subject/7067149/)》35%\n\t- [社科]《[毛澤東的中國及其後](https://book.douban.com/subject/1382324/)》10%\n\t- [心理]《[社会工程](https://book.douban.com/subject/35711062/)》25%\n\n## 课堂\n- [经济] 马红漫：行为经济学通识课\n\n\t> 行为经济学，启示我们如何面对不确定性，得从了解自己的行为开始。本课程以股票投资中的非理性行为为例，讲解了一些现象背后的行为经济学原理以及应对之策。\n\n- [通识] 洪兰：脑科学课堂\n\n\t> 改变大脑的三要素：学习、运动、情绪。我们可利用这种机制训练大脑，以更高效沉迷于学习、更有效调控情绪、更从容应付压力等。\n\n## 启示\n\n\n- [纪录]《[富豪谷底求翻身第二季](https://www.bilibili.com/bangumi/play/ep468598?from_spmid=666.25.episode.0&from_outer_spmid=333.337.0.0)》：学习大佬们的街头智慧\n\t\n\t- 有需才有供：调研需求，创造销售条件\n\t- 情绪化管理：负面对自身或他人毫无意义\n\t- 仆人式领导：专业人做专业事，懂得尊重、包容、激励、激发人才\n\t- 小目标大局观：不忘初心和使命；两点论和重点论结合\n\t- 先他人后个人：自己想赚钱，先给别人先赚钱\n\t- 多开口大胆问：争取优惠、折扣、福利，可以利用自身行头/优势去获取资源，比如身份、美貌、人缘等，特别是线下交易场景会有明显效果。\n\t- 同理共情示弱：不管是表演还是真情流露，要懂得主动示弱承认自身不足、主动理解对方立场及体会、诚意做出承诺并且达成诺言。\n\t\n\t\t> 观察很多成功博主，他们会主动示弱、激发观众同理心，拉近观众距离。另一方面，也会让观众产生“优越感” 和欢乐感。正如张国荣先生讲的“我们的快乐建筑在观众的快乐之上，只有观众快乐我们才可能拥有”。\n\t\n- [纪录]《[暴富人生](https://www.bilibili.com/bangumi/play/ep256277)》\n\t- 与其说“暴富”人生，更准确说是主人公们借助意外财力帮助自己过渡了艰难的人生阶段，往后以一种积极态度去生活。\n\t- 提高认知水平除了防止被骗外，也可以让你在富足时也懂得节制，或是有能力利用这笔钱开启“钱生钱”事业。\n\n- [书籍]《[软技能](https://book.douban.com/subject/36044253/)》\t\n\t- 番茄工作法：聚焦于任务，间歇性休息，大任务要分包成小任务执行。通过提升效率节省出超额时间，而这部分时间是奖励给我们的，请不要耗尽它继续学新知识、完成新任务，而是利用它给当日复盘，让碎片化内容联络起来，巩固记忆形成经验。\n\t- 定位并认识到自己的短板，把任务分解到自己愿意付诸行动的小任务，落实于行动。\n\t- 训练我们的并发、并行能力，但不要让自己长期处于并发工作状态，这是非常耗费精神力的行为，毕竟我们的大脑就一个。\n\t- 教学相长可能是最有效果的学习方法（参详费曼学习法）。\n\t\n- [书籍]《[肥尾效应](https://book.douban.com/subject/35989414/)》\t\n\t- 大数定律固然好，但是活在时间长河里，普通人不一定能触达收敛结果。况且还有数据样本不足、收敛速度慢等现实问题。\n\t- 薄尾关注概率事件，肥尾注重事件的影响结果。既然后者是小概率发生事件，发生过后不要沉迷于概率游戏，好的方面那就享受结果，坏的方面尽量控制影响。\n\t\n- [书籍]《[小米创业思考](https://book.douban.com/subject/36057097/)》\t\n\t- 创业精髓在于专注，特别是高速发展期，要有意识地进行收敛性思考。不然对公司品牌资产是一种稀释和浪费。\n\t- 创业要精确定位、瞄准目标客群，少即是多，单独突破，迭代发展。别老想着第一款产品就要惊天动地、全面胜出，找尽可能发挥自身能力的最小执行单元行动出击。\n\t- “加号改乘号”战略，首突出核心业务，其他业务围绕核心业务添枝散叶，发挥乘法效应。思考是“互联网+”模式，还是“互联网x”模式，比如 “手机xAIoT”。\n\t- 运营公司不要忘根，发展过程有没积淀，有没有强化根形成的优势或壁垒。再有，发展有没有给用户带来真实价值，或是对自身有没有提效或增益。\n\t- 经济学思维理解，企业的目标是实现利润最大化；财务学思维理解，效率与效益决定了投资回报；无论溢价模式还是性价比模式，都可以赚取“消费者剩余/生产者剩余”。\n\t- 第一性原理：透过现象看本质，从事物基本原理出发推理，不依照已有认知和经验进行研究、解决问题。\n\t- 逆向性拷问：做决策，相较于必要性论证，不如多找找不去做的理由，从而反证不得不去做的原因。\n\n## 习惯\n- 个人精气神塑造计划：围绕 `运动`、`睡眠`、`戒糖` 三方面开展的微习惯养成计划，每周对三项指标进行考核，不达成 `周目标` 将会受到惩罚（锁定灵活取用资金、延迟愿望实现时间等）。当然，累计达成 `月目标` 后也要给自己奖励（老友相聚大吃一顿、刷一整天的电影等），张弛有度才会长久持续。\n\n\t- 说明\n\n\t\t<table>\n\t\t<thead>\n\t\t<tr>\n\t\t\t<th width=15%>项目</th>\n\t\t\t<th>说明</th>\n\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t<tr>\n\t\t\t<td>💪 运动</td>\n\t\t\t<td>\n\t\t\t1. 周工作日，争取一次 Keep 简训<br>\n\t\t\t2. 周五六日，一主一辅 Keep 简训\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>😪 睡眠</td>\n\t\t\t<td>1. 周工作日，23:30 停掉所有强制休息<br>2. 周五六日，01:30 停掉所有强制休息</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>🥤 戒糖</td>\n\t\t\t<td>每周仅允许两次主动摄入</td>\n\t\t</tr>\n\t\t    </tbody>\n\t\t</table>\n\n\t- 规则\n\n\t\t<table>\n\t\t<thead  align=center>\n\t\t<tr>\n\t\t\t<th width=15% >项目</th>\n\t\t\t<th>规则</th>\n\t\t\t<th>备注</th>\n\t\t</tr>\n\t\t</thead>\n\t\t<tbody align=center>\n\t\t<tr>\n\t\t\t<td>💪 运动</td>\n\t\t\t<td>+ 奖励最高 4 次，- 惩罚最高 3 次</td>\n\t\t    <td>周一至周四自由，周五六日必须锻炼<br>（提示：<b>一周至少运动三天）</b></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>😪 睡眠</td>\n\t\t\t<td>+ 奖励最高 7 次</td>\n\t\t\t<td>严格遵守作息规律，不能自我放纵！</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>🥤 戒糖</td>\n\t\t\t<td>+ 奖励最高 2 次，- 惩罚不设限</td>\n\t\t\t<td>指喝奶茶/饮料的次数，惩罚无上限！</td>\n\t\t</tr>\n\t\t</tbody>\n\t\t</table>\n\n- 各项计划执行状况：\n\n\t{% echarts 400 100% %}\n\t{\n\ttooltip: {\n\t\ttrigger: 'axis',\n\t\taxisPointer: {\n\t\t\ttype: 'cross',\n\t\t\tlabel: {\n\t\t\t\tbackgroundColor: '#6a7985'\n\t\t\t}\n\t\t}\n\t},\n\tlegend: {\n\t\tdata: ['运动指标', '睡眠指标', '戒糖指标']\n\t},\n\ttoolbox: {\n\t\tfeature: {\n\t\t\tsaveAsImage: {}\n\t\t}\n\t},\n\tgrid: {\n\t\tleft: '3%', right: '4%', bottom: '3%',\n\t\tcontainLabel: true\n\t},\n\txAxis: [\n\t\t{\n\t\t\ttype: 'category',\n\t\t\tboundaryGap: false,\n\t\t\talignWithLabel: true,\n\t\t\taxisLabel: {\n\t\t\t\tinterval: 2,\n\t\t\t\trotate: 45\n\t\t\t},\n\t\t\tdata: [\n\t\t\t\t'0103-0109','0110-0116','0117-0123',\n\t\t\t\t'0124-0130','0201-0206','0207-0213',\n\t\t\t\t'0214-0220','0221-0227','0228-0306',\n\t\t\t\t'0307-0313','0314-0320','0321-0327',\n\t\t\t\t'0328-0403','0404-0410','0411-0417',\n\t\t\t\t'0418-0424','0425-0501','0502-0508',\n\t\t\t\t'0509-0515','0516-0522','0523-0529',\n\t\t\t\t'0530-0605','0606-0612','0613-0619',\n\t\t\t\t'0620-0626','0627-0703','0704-0710',\n\t\t\t\t'0711-0717','0718-0724','0725-0731',\n\t\t\t\t'0801-0807','0808-0814','0815-0821',\n\t\t\t\t'0822-0828','0829-0904','0905-0911',\n\t\t\t\t'0912-0918','0919-0925','0926-1001',\n\t\t\t\t'1003-1009','1010-1016','1017-1023',\n\t\t\t\t'1024-1030','1031-1106','1107-1113',\n\t\t\t\t'1114-1120','1121-1127','1128-1204',\n\t\t\t\t'1205-1211','1212-1218','1219-1225'\n\t\t\t]\n\t\t}\n\t],\n\tyAxis: [\n\t\t{\n\t\t\ttype: 'value',\n\t\t\tname: '达标',\n\t\t\tmin: -3, max: 7,\n\t\t\tposition: 'left',\n\t\t\tsplitNumber: 14,\n\t\t\taxisLabel: {\n\t\t\t\tformatter: '{value} 次'\n\t\t\t}\n\t\t}\n\t],\n\tseries: [\n\t\t{\n\t\t\tname: '运动指标',\n\t\t\ttype: 'line',\n\t\t\tsmooth:true,   // 为 true 是不支持虚线的，实线就用true\n\t\t\titemStyle:{\n\t\t\t\tnormal:{\n\t\t\t\t\tlineStyle:{width:2, type:'solid'},\n\t\t\t\t\tcolor: '#F1485B'\n\t\t\t\t}\n\t\t\t},\n\t\t\tdata: [\n\t\t\t\t'1','1','0','0','-1','0','2','0','0','-2',\n\t\t\t\t'-1','-2','0','1','-1','0','0','1','2','0',\n\t\t\t\t'0','0','0','-1','-1','0','3','1','2','1',\n\t\t\t\t'1','1','1','-1','0','-1','1','0','0','3',\n\t\t\t\t'1','0','-1','1','0','2','0','0','1','-1',\n\t\t\t\t'2'\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\tname: '睡眠指标',\n\t\t\ttype: 'line',\n\t\t\tsmooth:true,\n\t\t\titemStyle:{\n\t\t\t\tnormal:{\n\t\t\t\t\tlineStyle:{width:2,type:'solid'},\n\t\t\t\t\tcolor: '#6795A0'\n\t\t\t\t}\n\t\t\t},\n\t\t\tdata: [\n\t\t\t\t'2','3','4','1','4','3','3','2','1','0',\n\t\t\t\t'2','2','2','1','4','3','3','4','1','3',\n\t\t\t\t'3','3','1','3','1','4','1','2','3','3',\n\t\t\t\t'2','2','1','5','1','0','4','3','2','5',\n\t\t\t\t'3','3','5','4','1','4','5','3','4','5',\n\t\t\t\t'7'\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\tname: '戒糖指标',\n\t\t\ttype: 'line',\n\t\t\tsmooth:true,\n\t\t\titemStyle:{\n\t\t\t\tnormal:{\n\t\t\t\t\tlineStyle:{width:2,type:'solid'},\n\t\t\t\t\tcolor: '#ECB172'\n\t\t\t\t}\n\t\t\t},\n\t\t\tdata: [\n\t\t\t\t'2','-1','0','-1','-1','0','0','0','-1','-1',\n\t\t\t\t'-1','-1','0','0','0','0','-1','-1','-1','-2',\n\t\t\t\t'-1','-1','-1','0','-1','-1','-1','-1','-1','-1',\n\t\t\t\t'-1','2','-2','-1','1','-1','-1','0','0','-2',\n\t\t\t\t'0','0','-1','0','0','0','-2','-2','0','0',\n\t\t\t\t'0'\n\t\t\t]\n\t\t}\n\t]\n\t};\n\t{% endecharts %}\n\n- 精气神计划复盘：纵观全年度，运动、睡眠、戒糖三项指标执行到位，自我感觉个人精气神改造效果不错。但是，个别指标在某阶段会有明显下滑趋势，其中缘由是值得深究反思的。\n\t- `总评价`：运动指标 $\\color{green}{优秀}$，戒糖指标 $\\color{blue}{良好}$，睡眠指标 $\\color{red}{不合格}$。\n\t- `运动指标`：享受内啡肽带来的愉悦感，2022年度每周运动量基本达标。但是，第一季度末、第三季度初迎来了两波低谷（结合睡眠指标更明显）。这两段时间印象很深刻，主要是工作方面压力加上职业规划焦虑影响，两度陷入迷惘期，经常睡不着、人整体很疲惫。\n\n\t\t> 当今社会形势，很容易把人整得焦燥急，但冷静想想这些情绪并不会给你带来任何好处。仔细想想，我所拥有的特长能力还没发挥呢，只是资产（财富+知识）积累过程是需要时间的，把达成某些目标的战线拉长，该来的还是会来的，继续以积极心态工作、生活、学习。\n\n\t- `睡眠指标`：整一个年度一半时间的睡眠都是不及格的，然而，我给自己安的理由是工作忙碌，没时间学习新知识，只能下班发奋图强。\n\n\t\t> 一直以来，我只停留在睡眠对身体不好层面的认知，而总是主观性地忽略了睡眠这件事能带给我们的恶性影响（推荐阅读马修·沃克《[我们为什么要睡觉](https://book.douban.com/subject/35332778/)》| 所长林超《[生理学重要模型](https://www.kofes.cn/2022/01/Interdisciplinary-Thinking.html#生理学重要模型)》）。明年开始，不妨给自己做一个实验，坚持一个月早睡早起，但读书、写代码等投入时间还是相等的，一个月后自我验收效果，并观察精神面貌变化如何？大道理一定要身体力行才能领悟呀...\n\n\t- `戒糖指标`：中规中矩，外出聚餐频率有些偏高，然而聚餐少不了喝酒或者饮料。但是每周都刻意去控制糖分摄入，下半年体验指标还不错。\n\t\t\n\t\t- 不戒糖的后果会比较严重，比如内脏脂肪堆积、神态显老、皮肤变差等，想想这些是不是自己想要的，贪图一时的多巴胺快感，带来后悔莫及的后果呀！\n\t\t- 今年年底尝试了一些新办法来改变坏习惯，其一是增加坏习惯的执行成本，比如没有大额优惠券绝不喝奶茶（不喝便宜奶茶）、平时清淡饮食以减轻想喝柠檬茶的欲望等；其二是坏习惯冲动涌上心头时，通过冥想让自己先冷静下来。\n\n## 消费\n- 效果：对比 2021 年度，2022 消费降级后的消费支出情况如图（b）所示。以前可谓数码狂热爱好者，既浪费钱也浪费精力！\n\n| ![](/images/project/2022-Reviews-2023-Plans/2021-Consumer-spending.jpg) |  ![](/images/project/2022-Reviews-2023-Plans/2022-Consumer-spending.jpg) |\n|:---: | :---: |\n| (a) 2021 年消费支出情况 | (b) 2022 年消费支出情况 |\n\n- 剖析原因：\n\t- 轻易给自己创造需求，如果花钱确实能节省时间、提高生产力确实是值得的，只是现实需求并没有实际那么强烈。\n\t- 经常看科技博主评测，毕竟吸引消费者注意力、提升消费者购买欲就是他们的工作本分，需警惕这样的消费陷阱。\n\t- 除工作生活之外，空闲时光一定要有精神寄托，比如读书、绘画、练琴、跳舞、发展副业等。回忆起上学时光，总是会闲不住找事折腾，与其随机游走还不如提早计划、刻意为之。\n\n\t\t> 工作忙碌不是好理由，如果一直持有这种信念，那永远发生不了改变。\n\n- 尝试改变：提升认知水平，提升财务理念水平，让沉溺于迷幻消费主义的你赶紧清醒过来！\n\t- 要改变自己的消费习惯，首先要改变自己的财务理念。\n\t- 认识什么是资产，什么是负债？买物之前多想想它的价值，不能为你带来财富、知识增殖的少买。\n\t\t> 我们恋物不是因为物有价值，而是物辅助我们达成某件事，事情结果赋予经历意义。\n\n\t- 要避免用隐形负债，主动获取了劣质的、无法产生被动收入的资产。比如随着升职加薪而消费升级，表面上光鲜亮丽，实际负债累累。\n\t- 努力学习、拼命工作也是为了过上自由人生活，努力储蓄，活用储蓄投资获取更多收益的工具，成为高产低债者！\n\n\t\t> 收益工具包括金融资产、固定资产、无形资产。\n","tags":["总结","读书","心理"],"categories":["Journal"]},{"title":"任天堂的体验设计：创造不由自主动人心弦的体验","url":"/2022/10/nintendo-experience-design.html","content":"\n本书的架构就很贴切地阐述了直觉、惊喜以及故事的设计逻辑。开篇时，留空不全的体验设计框架流程图给读者留下了悬念，让我们产生了往下探索的兴趣。然后，通过我们对任天堂经典游戏的直觉认知，徐徐道来讲熟悉的案例故事，引出观点并总结方法论，当我们掌握了一种方法论就相当于补全了一份缺失的流程地图，边学习边游戏，边收集边成长，由此产生愉悦的、惊喜的有趣体验。\n\n继续发散思维，体验设计不仅仅应用于游戏领域，也可以运用到各类生活场景中。比如策划一项活动、团体讨论方案、传达演示幻灯片、设计一款产品或是培养人才等。想想谁是你要打动的对象，客户、同事、家人、恋人、朋友？寻找一个目标为出发点，跟随本书开启一场体验设计之旅，你将学习到绝妙体验的设计方法论。\n\n- `直觉设计`：让人不由自主地行动\n- `惊喜设计`：让人不由自主地沉迷\n- `故事设计`：让人不由自如地叙述\n\n<!-- More -->\n\n## 理论篇\n### 不由自主行动\n- 直觉设计的本质\n\t- 让用户/玩家自发性地体验认知过程。\n\t- 让用户/玩家直观理解体验本身。\n\t- 符合条件反射的设计。\n- 直觉设计的结构\n\t- 假设：自发建立“我要xx”的假设。此时玩家不知道假设是否正确。\n\t- 尝试：自发发起“试试xx”的行动。此时玩家不知道尝试是否正确。\n\t- 高兴：自发确认“事实xx” 是对的。此时玩家第一次确信假设和尝试，由此产生愉悦体验。\n\n\t{%centerquote%}\n\t![](/images/Reading/Nintendo-experience-design/ExperienceDesign-Intuitive-Design.svg) 直觉设计的结构\n\t{%endcenterquote%}\n\n- 比有趣更重要的事情：游戏一开始，玩家并不是因为有趣才玩的，而是不由自主想到了才玩起来的。我们的大脑总是在寻找假设，并尝试进行验证。这种思考方式，可引用认知心理学的“示能”与“能指”来解释。\n\t- 示能（Affordance）：环境赋予动物的意义，即 `主动去想`。通俗解释就是当你看到某些东西时，脑海中浮现出要做什么的念头。\n\t- 能指（Signifiers）：为传达示能而被特别处理的信息，即 `被动联想`。比如《超级马里奥》中，马里奥的样子、所处位置、山、云朵等，正是设计师想要传达“向右走”这一示能。\n\n\t{%centerquote%}\n\t![](/images/Reading/Nintendo-experience-design/ExperienceDesign-Signifiers-Affordance.svg) 能指传达示能\n\t{%endcenterquote%}\n\n- 比起有趣，让玩家知道游戏规则更重要。让玩家迈出冒险第一步，并让 `直觉设计` 始终引导玩家通往前方冒险。\n- 直觉设计的延续，是设计游戏体验的基本战略，也是游戏的基本构造。\n\t- 直觉设计必定包含高兴，所以玩家的情绪才会通过直觉体验一点点地提高。情绪超过某一临界值，此时玩家才会意识到 `有趣`。\n\t- 不是因为有趣，玩家才会高兴。而是体验产生高兴而觉得有趣。\n- 为了达到以上目标，需要将直觉设计连接起来。设计 `连接` 的要领：\n\t- 用多久时间让玩家意识到有趣，请用直觉设计填补该段时间，让玩家不断产生高兴情绪。\n\n\t\t> 思考：玩家会对直觉设计产生疲劳和厌倦，如何弥补直觉设计的缺陷？\n\t\n\t- 每个直觉设计都是简短的。\n\t- 提高玩家获得愉悦体验的概率。\n\t\t- 让体验本身变得简单、容易是绝对的条件。\n\t\t- 因为简单、容易，玩家才愿意假设、尝试。\n\n- 另一个直觉设计起点：玩家的 `共同记忆`，将直觉学习与玩家的生活体验连接起来。每当玩家在游戏中解开谜题，就有一种人生得到肯定的感觉。\n- 利用人们的共同点进行直觉设计：\n\t- 神经反射（先天性）：人们大脑和心灵的特性\n\t- 共识常识（后天性）：人们共同的记忆\n\n### 不由自主着迷\n- 初始效应：在体验或学习开始之时，人们的注意力和学习效率是最高的。\n\n\t> 启示：活用初始效应，可以有效传达规则信息。\n\n- 不断地学习指令或者专业知识，就像被迫无休无止地学习一样，玩家必然会感到疲劳和厌倦。\n\t- “假设”和“尝试”的体验会给玩家带来压力，即不知道假设的正确性，尝试时会感到不安。所以玩家在体验直觉设计时，心情总是在“不安”与“高兴”之间摇摆。\n\t- 对于大脑而言，相同的刺激重复多次，反应会慢慢变弱。心理学称之为“心理饱和”或“心理适应”。\n- 回答上述问题：连续的直觉设计让人产生疲劳和厌倦，那么如何弥补直觉设计的缺陷？“惊喜刺激”正式登场！\n\t- 惊喜刺激只是在玩家特定心理状况下发挥作用，比如涉及一些 `禁忌` 话题。\n\t- 惊喜刺激本质在于出乎意料的体验，即意料之中的情节变成意料之外的结果，玩家会被吸引、情绪变得兴奋。\n- 出乎玩家意料的体验设计：有意识背叛两种坚信，让意料之外的强烈体验打动玩家的心，消除疲惫与厌倦，让玩家更沉浸游戏当中。\n\t- 要点1：对前提的坚信，事先让玩家做出明确的预测，让玩家做出错误预测。 \n\t- 要点2：对日常的坚信，坚信日常生活中“禁忌不会出现”。\n\n\t{%centerquote%}\n\t![](/images/Reading/Nintendo-experience-design/ExperienceDesign-Surprise-Design-Breach-Belief.svg) 惊喜刺激的原理\n\t{%endcenterquote%}\n\n- 惊喜设计的结构\n\t- 误解：自发做出“要做xx”的假设。让玩家坚信假设是正确的。\n\t- 尝试：自发发起\"尝试xx\"的行动。让玩家坚信尝试是正确的。\n\t- 惊讶：自发发现\"xx错误\"的结果，大吃一惊，此刻玩家才意识到假设、尝试是错误的。\n\n\t{%centerquote%}\n\t![](/images/Reading/Nintendo-experience-design/ExperienceDesign-Surprise-Design.svg) 惊喜设计的结构\n\t{%endcenterquote%}\n\t\n- 惊喜设计的步骤\n\t- Step.01：掌握玩家疲劳和厌倦的时机\n\t- Step.02：事先构建让玩家产生误解的游戏主题\n\t\t- 实操难点：让对方对前提产生误解，就必须花很长时间不断地说谎。让玩家对前提的坚信反复落空，适得其反会让玩家失去耐心，因此要注意惊喜设计的节奏。\n\t\t- 有效方法：不要颠覆对前提的坚信，而是打破对日常的坚信，用“禁忌主题”就能令人振奋惊讶。\n\t- Step.03：设计包含“禁忌主题”的游戏剧情。\n\n- 10 种的禁忌主题\n\t- 积极主题：这个体验，描绘的是人类本能欲望吗？\n\n\t{%centerquote%}\n\t![](/images/Reading/Nintendo-experience-design/ExperienceDesign-Surprise-Design-Tabu-Positive.svg) 积极的禁忌主题\n\t{%endcenterquote%}\n\n\t- 消极主题：这个体验，是人们想要回避的东西吗？\n\n\t{%centerquote%}\n\t![](/images/Reading/Nintendo-experience-design/ExperienceDesign-Surprise-Design-Tabu-Negative.svg) 消极的禁忌主题\n\t{%endcenterquote%}\n\n\t- 侥幸和偶然：这个体验是否让用户下注并祈祷？\n\n\t\t> 为了延长游戏时间，需要有意识地 `剥夺` 不断努力、一边学习一边冒险的玩家的 `认真感`。比如让玩家不知不觉追求幸运的心情，在游戏界被称作 “侥幸”。\n\n\t- 个人隐私：这个体验能否体验出个性？\n\n\t\t{%centerquote%}\n\t![](/images/Reading/Nintendo-experience-design/ExperienceDesign-Surprise-Design-Tabu-Lucky&Privacy.svg) 侥幸偶然与个人隐私\n\t{%endcenterquote%}\n\n- 惊喜设计，一边描绘人类出于本能想要的东西或想要回避的东西，又一边让玩家下注、祈祷，最后让玩家彰显个性或荣誉。\n\n\t> 通俗来讲，惊喜设计就是让体验持续下去的必要之恶！\n\n- 最后，为了让玩家持续体验下去，必然要在连续的直觉设计中穿插惊喜设计。并且，为了讲述怎样的内容、营造绝妙的体验，惊喜穿插的顺序、比例都是需要反复考量与刻意设计的。\n\n### 不由自主叙述\n- 如果游戏有意义，应该怎样设计它的体验，以及体验的意义究竟是什么？接下来便有了故事设计。\n- 首先，我们得弄明白什么是故事？故事，又被称为叙事，由内容情节与故事叙事两个要素构成。\n\t- 内容情节：发生什么\n\t- 故事叙述：如何表达，比如文章、声音、影像等表现形式，语言选择，表达顺序等，它们都会影响故事的趣味性。\n\n#### 吸引\n- 运用 `五感` 和 `思考` 来叙述故事，这对大脑来说是一种很充实的体验，本书把这种体验称之为 `吸引`。\n- 故事叙述方式探究\n\t- 片段式叙述：\n\t\t- 环境故事：玩家自发地收集分布在环境中的信息，构筑故事。 \n\t\t- 叙述本能：大脑是讲故事的器官，从眼睛、 鼻子、耳朵等感觉器官收集信息片段进行整合加工，与自己的人生经历对照，推测眼前正在发生什么，然后连接上下文，讲述故事。\n\t- 波浪式叙述：\n\t\t- 在故事场景中，用折线图描述信息量多少与趋势变化。信息过多的被动场景，折线上升，反之下降。\n\t\t- 在每个场景中，包含的信息量、主动性与被动性，两种要素构成了 `波浪`。如此以来，它让叙述的本能对未来的预测变得简单容易，达到与直觉设计相似的效果。\n\t\t- 所有故事内容都应具备这样的结构，被称之为 `节奏和对比` 的主题。那么用该主题制作波浪的理由是什么？\n\t\t\t- 1）信息量越少，故事越容易被理解\n\t\t\t- 2）发展容易预想到，很快形成节奏 \n\t\t\t- 3）让玩家忘记时间，体验就像一连串波浪一样，愉快地摇摆\n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Nintendo-experience-design/ExperienceDesign-Story-Design-Wave-Rhythm-and-Contrast.svg) 沿时间轴呈现出节奏与对比的波浪\n\t\t{%endcenterquote%}\n\n\t- 未来式叙述：在不知道某个信息的真正含义情况下，先提示，然后利用时间差让对方注意到其真实含义。\n\n\t\t> 隐藏真正含义，埋下暗示内容，称为 `伏笔`。\n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Nintendo-experience-design/ExperienceDesign-Story-Design-Foreshadowing.svg) 伏笔\n\t\t{%endcenterquote%}\n\n#### 成长\n- 思考体验的意义是什么？在游戏中，主人公只是虚构的角色，无论主人公成长多少，对玩家对自身都没有任何影响。所以让玩家的成长，才是游戏的意义所在。\n- 收集和重复\n\t- 让玩家意识到空缺，然后引导玩家收集、重复。\n\t- 在收集过程中，玩家多次重复同样的体验，就会自然而然地成长起来。\n\t- 让玩家不厌其烦地重复某种行为，即有节奏地重复，乐此不疲地收集。\n\t- 让问题处于未解决状态，保持紧张感。 \n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Nintendo-experience-design/ExperienceDesign-Stoty-Design-Grow-Collect&Repeat.svg) 收集和重复\n\t\t{%endcenterquote%}\n\n- 选择和斟酌\n\t- 富贵险中求：低风险低回报，高风险高回报\n\t- 依靠直觉进行选择和斟酌，完成自己的冒险\n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Nintendo-experience-design/ExperienceDesign-Stoty-Design-Grow-Approach.svg) 选择和斟酌\n\t\t{%endcenterquote%}\n\n- 成长最佳体验\n\t- 玩家可调整游戏难度，这是不可或缺的要素。\n\t- 游戏让玩家觉得“失败是你的错”是必要的。\n\t\t\n\t\t> 玩家根据自身能力做出选择，尽自己最大努力，得到最大限度成长。\n\n\t- 游戏只是用巧妙的方法来表扬或贬低玩家，即虚拟世界中被认可尊重或无成本试错。 \n\t- 对玩家行为好坏给予评价，在游戏业界被称为 `反馈`。正是有了反馈，玩家才会体会到选择与斟酌的意义。\n\n- 逆转和共鸣：麻烦的同行者\n\n\t{%centerquote%}\n\t![](/images/Reading/Nintendo-experience-design/ExperienceDesign-Stoty-Design-Grow-Reversal&Empathy.svg) 逆转和共鸣\n\t{%endcenterquote%}\n\n\t- 同行者行为会给玩家带来某种共同的情感，称之为 `共鸣`。而同行者往往是闹心的主，不时惹麻烦、不断惹恼玩家。为什么麻烦的同行者会让玩家产生共鸣？\n\t- 首先，我们要明白共鸣到底是怎样的一种状态。\n\t\t- 1）玩家对主人公感兴趣\n\t\t- 2）主人公和自己有同样的想法\n\t\t- 3）用憎恨以外的情感产生共鸣\n\t- 故事一开始，玩家只能通过游戏画面观察主人公，此时两者几乎没有建立联系。\n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Nintendo-experience-design/ExperienceDesign-Stoty-Design-Grow-Rresonance-1.svg) 游戏世界的主人公与现实世界的玩家\n\t\t{%endcenterquote%}\n\t\t\n\t- 而共鸣的第一条件是引起玩家感兴趣，通过做法是比较“残酷”的，给主人公带来麻烦，使其不幸并遭受打击 。\n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Nintendo-experience-design/ExperienceDesign-Stoty-Design-Grow-Rresonance-2.svg) 引起玩家感兴趣\n\t\t{%endcenterquote%}\n\t\t\n\t- 通过打击主人公，游戏成功地引起了玩家的兴趣。事实上，玩家和主人公各有各的感受。\n\t\t- 玩家：客观感受“主人公很痛苦、悲伤”\n\t\t- 主人公：主观感受“我很痛苦、很悲伤”\n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Nintendo-experience-design/ExperienceDesign-Stoty-Design-Grow-Rresonance-3.svg) 主观与客观感受不统一\n\t\t{%endcenterquote%}\n\n\t- 主观与客观不统一，心情的方向可能是相反的，更不用说达到共鸣效果。不满足共鸣第二条件，所以玩家的心情必须从客观向主观转变。\n\t\t- 此时，麻烦的同行者该登场了！麻烦的同行者会妨碍主人公进行冒险、总是做出不可思议的行动。即麻烦的同行者让玩家与主人公的注意力集中于一个点上，更甚情感绑在一起。 \n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Nintendo-experience-design/ExperienceDesign-Stoty-Design-Grow-Rresonance-4.svg) 统一主观与客观感受\n\t\t{%endcenterquote%}\n\n\t\t- 为什么同行者要制作麻烦呢？理由有两个：\n\t\t\t- 1）同行者有着不断给主人公制作麻烦的宿命，主人公与玩家都不得不关注他。\n\t\t\t- 2）共鸣的第三条件，用憎恨以外的情感产生共鸣。喜欢上你讨厌的人，这种超越讨厌的情感，产生共鸣、真正成长。\n\n\t\t\t\t> 体谅他人的烦恼，为什么会做出令他人憎恨的事，通过化解这种矛盾以建立情感。\n\n#### 意志\n- 游戏叙述的是虚拟故事，一切都是为玩家拥有自己意志的体验，换言之，就是让玩家去书写自己的故事。\n- 故事有始有终，为什么故事最后要回到起点？\n\t- 这种模式通常以“英雄之旅”模型来进行故事设计。\n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Nintendo-experience-design/ExperienceDesign-Stoty-Design-Hero-Travel.svg) 英雄之旅\n\t\t{%endcenterquote%}\n\n\t- 旅行的本质就是关于旅行的体验。通过旅行这种体验，你会成长变成另外一个人，这是旅行的意义。\n\t- 玩家通过游戏体验发生改变才有意义，比如游戏过程中遇到逆境和混乱也能冷静应对并生存下去、即使偶发性相遇也会互相体谅、温柔相待等，那么请思考此刻回到起点的我与以前的我还是一样的吗？\n\n### 体验设计本质\n- 再次回顾三种体验设计\n\t- `直觉设计`：让人不由自主地行动，假设 -> 尝试 -> 高兴\n\t- `惊喜设计`：让人不由自主地沉迷，误解 -> 尝试 -> 惊讶\n\t- `故事设计`：让人不由自如地叙述，吸引 -> 成长 -> 意志\n- 体验设计的本质：每一种体验设计都传达出情感（喜怒哀乐悲恐惊），一边营造当时情境，一边打动玩家的心。\n- 对三种体验设计的总结\n\n\t{%centerquote%}\n\t![](/images/Reading/Nintendo-experience-design/ExperienceDesign-Stoty-Total.svg) 三种体验设计总结\n\t{%endcenterquote%}\n\n\t- 直觉设计是最基本的体验设计方法\n\t\t- 它将老一套体验变成自发性体验，帮助用户凭直觉行动、学习。\n\t\t- 它利用人们的共识常识，以及神经反射，实现设计简易容易的体验。\n\t\t- 让所有用户都抱有假设，并进行尝试；让用户自身发现假设是正确的，从而感到高兴。\n\t- 然而，连续的直觉体验会给用户带来疲劳和厌倦，让体验嘎然而止。为此，为设计让人“不由自主着迷”的体验，就需要惊喜设计。利用对前提的坚信、对日常的坚信，通过改变用户的预期，让用户大吃一惊。\n\t- 结合直觉设计与惊喜设计设计方式，刻意创造直观且不让人倦怠的长时间体验之旅。但是，如果体验没有意义，则不会打动用户的心，由此引入故事设计。故事设计吸引想了解情况的用户， 引导其创造自己的故事，使其成长，赋予体验意义。\n\n### 体验设计应用\n- 体验就是随时间不断流逝的过程，设计过程就是体验设计本身，而非直接创造出“有趣”的结果。\n- 观察无聊的体验、不顺畅的体验，发现降低体验价值的心理脉络后，重新设计体验，\n- 如何选择一种体验设计方式\n\t- 如果问题令人费解，请运用直觉设计。\n\t- 如果问题让人疲倦，请运用惊喜设计。\n\t- 如果问题没有价值，请运用故事设计。\n\n#### 思考/策划\n\n> 问题：如何想出好点子？\n\n- 对所有人保密、思考哪些话是不能在别人面前讲的。越是暴露个人隐私、越能让自己或者他人感到惊讶和兴奋。\n- 从思考碎片的共同点中发现对你来说重要的事情。\n- 讲述一个你失去重要东西、陷入危机的事情。\n\n#### 讨论/引导\n\n> 问题：气氛沉重，谁也说不出话来？\n\n- 不谈好的策划，谈没用的策划。\n\n\t> 启示：逆向思维，众多没有用的策划，更加印证好的策划。\n\n- 把团队的自我认识当作“我们自己的事情”来谈。\n- 回顾过去发言，提出深层含义是什么。\n\t- 从成员提出的意见中、一度被忽略的主张中找出意义，将其作为伏笔，这就是创造故事的引导技巧。\n\t- 从成员过去意见中找出重要性，让该成员成为英雄。\n\n#### 传达/演示\n\n> 问题：听众注意力下降如何破解？\n\n- 如何在演示中保持专注？反过来思考，在演示过程中，什么时候听众的注意力最不集中？\n\n\t> 无论内容多么充实，无聊的演示都是无聊的。在故事论中，故事内容不是重点，而是故事叙述。\n\n- 预告下一张幻灯片的方法：\n\t- 提出疑问\n\t- 故意把话说到一半\n\t- 告诉对方进入总结阶段\n\t- 使用连接词\n- 定期插入禁忌主题，或者沉默片刻。\n- 最后，再展示演示刚开始时放映的幻灯片。让听众获得 **成长的实在感**。\n\n####  设计产品\n- 优先考虑用户的第一次使用，让其觉得产品简单、易用。\n- 通过回归日常的情节设计，将用户从产品中抽离出来。\n\n\t> 刻意让体验停止的设计，产品只不过是用户人生变得更美好的配角，使用与否都是用户的自由。\n\n- 提供作弊选项，让用户自由选择。\n- 总言之，无论使用什么产品，用户都能凭直觉使用产品，可随时停止，甚至刻意作弊。\n\n#### 培养/管理\n- 故意试错、体验错误。\n- 教授与被教一起体验未知的事情。\n\n## 实践篇\n- 项目背景：以本博客 2.0 升级改造为例，围绕核心内容、个人品牌（独家内容）以及阅读体验三大方面，审视本博客对于个人意义、对于他人的价值，以体验、服务、交互等多种设计思维重新定义及发布个人的博客品牌。\n- 指导思想：\n\t- 一目了然了解核心内容是什么（直观、亮点）\n\t- 为什么他人愿意阅览分享博文（价值、吸引）\n\t- 怎么留住读者读下去或读更多（有用、关联）\n- 独家内容：\n\t- 开源项目：暂定计划是幻灯片演讲助手，只需设定好台词，便可一键实现自动演讲、AI 配音、视频录屏的智能化演讲程序。\n\t- 产品服务：记事类 App / 记账类 App\n\t- 个人相关：计划发布共同成长相关内容，建立深交关系，以激励自身与他人积极前行。\n- 引流计划：不同类别的内容，受众不一样，引流平台、引流方法都应该区别对待。","tags":["直觉","惊喜","故事","任天堂","体验"],"categories":["Reading"]},{"title":"次第花开：藏人精神保持愉悦的秘密","url":"/2022/10/blooming-flowers-in-turn.html","content":"\n痛苦是因为我执，我执源于缺乏对痛苦的认识，以及时间长河中无法看清事物的无常无我，使得我们心生烦恼、内心焦虑。而上师给我们的开示是，减轻痛苦先从认识烦恼及远离烦恼的因开始，以及修行我们的出离心、菩提心、四无量心，以缓释我执，抗战烦恼。另一层面，事物无常无我，修行之路无止境，我们不要过于功利化去追寻一个确定的答案，不稳定是常态，不然适得其反跌入另一个我执当中，循环往复、徒增烦恼。\n\n简言之，因上努力，果上随缘；但行好事，莫问前程。感受世间细微事，积极心态修心修德，善良心地终究能开出安乐之花。\n\n<!-- More -->\n\n## 序言\n- 佛法中，最幽深的理论与我们当下的身心活动紧密联结，给我们现实人生遇到的问题提供方案或心灵指导。\n- 人们在极度焦虑不安时，通常会把希望寄托于佛法当中，以寻得一种 `解脱` 的途径。\n\t- 事实：事实上我们无法从外界寻得一颗清净的心移植到自己身上。\n\t- 启示：我们唯一能做的只有面对当下，回归内心，与烦恼开战。\n- 远离烦恼，从认识烦恼开始，必须认识及远离烦恼的 `因`。\n\t- 对境：感官感受到的障碍。\n\t- 串习：不断修炼？\n\t- 随学恶友：物以类聚，人以群分。近朱者赤近墨者黑，接触善友便学善法，接触恶友便学恶法。\n\t- 颠倒作意：好坏颠倒，也可用在晨昏颠倒、无限制享乐上。\n\t- 听闻不正确的法教\n\t- 潜伏在心田的烦恼种子\n- 远离前五因，阻止烦恼现前，所谓 `出离`。\n\n\t> 警惕一种矫枉过正的做法，就是刻意追求所谓的 \"出离的出离\"。我们要明白，主要矛盾是烦恼，而不在于出离的形式。 \n\n- 过生活不是修行，修行是在悲欢离合中体认无常、缘会、因果；在生病中认识到与生俱来的脆弱、忧苦，由此生起出离心，推己及人，再生起悲悯之心。\n\n\t> 生活本身不一定是修行，如果你能把生命经验，顺境、逆境、苦乐，用于巩固你的出离心、菩提心、空性的见解，才是修行。\n\n- 反转无始以来的惯性思维，我们以烦恼为契机去勘悟世间万象的本质，从烦恼入手实现止息烦恼的最终目的。换角度理解，这样一个充满烦恼的人生就是我们解脱的最好机缘。\n\n## 珍宝人生\n\n{%centerquote%}\n![](/images/Reading/Blooming-flowers-in-turn/blooming-flowers-pain.svg) 认识痛苦\n{%endcenterquote%}\n\n- 无我\n\t- 事物不具有绝对的自性，也并非虚无主义。\n\t- 无我讲空性，无我也讲因果。\n- 无常\n\t- 事物普通具有的特性，即事物变化的普遍性。\n\t- 不要害怕它，也不要抵触它，因为我们阻止不了它的发生。 \n\n### 痛苦\n- 因果一旦成熟，任何行动都无法阻止果报的显现。 若痛苦、尴尬在所难免，我们最好让自己有所准备。\n- 解脱从认识痛苦开始。\n- 痛苦可分为三大类：苦苦、变苦、行苦\n\t- 苦苦：显而易见，不折不扣的痛苦，比如身体和心灵的创伤、病痛、恐惧、生离死别。\n\t- 变苦：由快乐变成痛苦。\n\n\t\t>  比如现在的富贵病，多吃少运动，身心健康变差；相聚终有分别苦；相爱相随相守苦；岁月不饶人之苦等。\n\n\t- 行苦：更深刻细微的痛苦，它指限于轮回的众生整个存在状态的无奈和不圆满，身受到业力牵制，被种种烦恼束缚。\n\n- 人间的痛苦又分为八种\n\t- 生、老、病、死\n\t- 怨憎会、爱别离、求不得、不欲临\n\n- 防患于未然：利用对痛苦的熟知，通过破坏其形成的条件去阻止某项痛苦的产生。\n\n### 无我无常\n- 对痛苦的了解越深入、越全面，被激励着就会去实践 `离苦得乐` 的方法。\n- 痛苦和快乐不是凭空而来的，它们都有各自形成的原因和条件。\n\t\n\t> 一切痛苦的根源在于我们长期以来对自身及外部世界根深蒂固的误解，执幻为实。\n\n- 实际造成痛苦的不是无常，而是对无常的恐惧。\n- 克服恐惧的两个方法\n\t- 熟悉无常，了解无常的原因。\n\t- 事物变化具有普遍性，因此不要害怕变化。\n\n### 亲证无我\n- 如果我们不去努力证悟无我，而只是把无我的观点当作一种知识储备在脑子里，就好比一个病人把医生开出来救命的药方当文章欣赏，而不去按方抓药、治病救命。\n- 我们倾向于把当下纯粹的苦受扩大，演绎成悲惨的故事，甚至是连续剧，掺进去太多不相干的情节、评判以及谈论。\n\n\t> 启示：运用无我的观点思考问题，辩证看待已发生的事物；并结合目的论的思维模式，尽可能往有用、积极的方向考量问题。\n\n- 因果律：事物无我，却能随缘显象。\n- 行善积德却遭遇不幸，我们为什么还要行善？\n\t- 改变心态，看待事物的角度会不一样。\n\t- 帮助他人能更好地实现自身价值。\n\n### 菩提心\n- 忆苦思甜\n\t- 因为不知道可贵，所以不知道希求。\n\t- 生活得太安逸，不知痛苦匮乏为何物，又对安乐富足习以为常，很难生起求解脱之心。当痛苦来临时不知所措，此时刻意四处求得解脱之法。\n\n### 总结\n- 若解脱之道不是远离贪嗔痴，不是诸恶莫作、众善奉行，我们很容易迷失再对贫穷、蔑视、责难、羞辱得恐惧和对富贵、尊崇、荣耀、赞美向往中。\n- 反转无始以来的惯性思维，我们以烦恼为契机去勘悟世间万象的本质，从烦恼入手实现止息烦恼的最终目的。换角度理解，这样一个充满烦恼的人生就是我们解脱的最好机缘。\n\n## 寻得安乐\n- 痛苦消失，快乐显现。\n- 痛苦源自于我执和法执，即对自己的执着以及对周遭事物的执着。\n- 正视情绪的价值，即使是负面情绪。\n\n\t> 安住负面情绪，而非压制它，也能帮助我们培养菩提心。\n\n- 不了解自己的另一个表现是不知道如何正确对待自己。\n\n\t> 对世界认知不浅，但对自己却知之甚少。\n\n- 快乐人生从接受缺憾开始，接受一个不那么完美的自己。\n\n\t> 启示：因上努力，果上随缘；但行好事，莫问前程。任何有意义付出，对我们来说是经验积淀，会让下一次成功概率更大一些。\n\n- 把快乐寄托在向外驰求上，就像喝盐水一样，得到的越多越不满足。\n\n## 玉树开示\n### 无常\n- 一切有为法如梦幻泡影，凡因缘和合的事物都会耗尽，都是无常的，没有例外。\n\n### 因果\n- 每一件事的发生都是因果关系共同作用的结果。\n- 由于认知能力的局限，往往只是看到无限因果相续中有限的某个片段。\n\n\t> 当事物的来龙去脉在空间或者时间的跨度上超过了目前的认识范围，人们很自然会怀疑是否凡事都由因果导向。\n\n### 共存\n- 相信自己与万物是分离的，这样一个错觉强化了人心的冷漠，让人不觉得自己应该对他人、对社会以及整个世界承担什么责任。\n- 在追求幸福过程中，我们要以时空为维度，考虑当今生活在地球上的人，还包括以后生活在地球上的人，以及我们共存的动植物，留出足够的空间和可能性，实现它们的幸福生活。\n\n\t> 启示：以什么样的思维对待世界，会潜移默化影响我们的价值观念，并在创造价值中产生什么样的结果。\n\n### 自律\n- 修行是修养仁爱、宽容、谦让，与人为善等能给自己或他人带来安乐的精神品质。\n- 不可或缺的修行：替众生着想，为此转化内心实际行动起来。\n- 从长远来看，我们真心替别人着想，首先须做到自律。\n\n\t> 启示：己所不欲勿施于人。\n\n### 慈悲\n- 布施：让我们发觉给予是让人感到丰足而不是贫乏的。\n- 布施的关键不是要解决他人多大问题才去做，而更重要的是我们能借此学习放下我执。\n\n\t> 启示：外在行为久而久之会影响心态，习惯布施的人比较容易让事情离去。\n\n## 修行误区\n### 皈依\n- 无常不是人生的一段过渡期，而是整个人生。\n- 相信因果不等于相信宿命，否则，我们不会那么精进修行、忏悔罪障。\n\n\t> 好比佛洛依德的原因论与阿德勒的目的论，前者看起来很精彩，但对改变自己并无多大用处。\n\n\t- 我们的一言一行，起心动念都会产生相应的后果。\n\t- 事实上，从头到尾都是我们自己对自己负责。\n\n- 忍辱指遇到情况不急于做出反应，不急于逃避不安、寻找安慰，而是放慢整个事情的节奏，给自己留一点空间去观察和感受，让自己可以看清事情原貌，不之致于迷失在流言蜚语中。\n\n### 出离心\n\n{%centerquote%}\n![](/images/Reading/Blooming-flowers-in-turn/blooming-flowers-disencumber.svg) 出离心\n{%endcenterquote%}\n\n- 放松是修行的第一课。\n- 趋利避害大概是所有众生最根深蒂固的一个习惯。\n\t- 对趋利避害上瘾，只要一感觉不舒服马上就另外寻找慰藉，不给自己留一点时间去认知和体验。有人称之为 \"纵欲\"，只要条件允许人们都愿意纵欲，因为这是他们逃避不安的习惯模式。\n\t- 我们一般认为灯红酒绿、纸醉金迷才是纵欲。其实躺平也是一种逃避现实的纵欲。\n\n\t\t> 启示：坦然接受不稳定的因素，世间是无常的，适度放松、迎接挑战。\n\n- 我们的初衷是让自己免于痛苦，得到安适，而实际做的只是以一种痛苦替代一种痛苦。如此循环往复，更强化了我们的恐惧。\n\n\t> 启示：内心空虚也是因为物质丰富后，拥有更多逃避痛苦的选择。你可以频繁地变换安慰的方式，只是结果会让你感受到更多挫败感和不满足。\n\n- 把自己看得太重是我们另一个顽强的习惯。\n- 只有不排斥别人才能接受自己。\n\n###  菩提心\n\n{%centerquote%}\n![](/images/Reading/Blooming-flowers-in-turn/blooming-flowers-bodhi-heart.svg) 菩提心\n{%endcenterquote%}\n\n- 缺少对自己的慈悲，很难真正对他人慈悲。\n- 不往内观照，无法消除迷惑；不心怀温柔，修行只剩下受苦。\n\n\t> 慈、悲、喜、舍都是从内心的温柔中生起的。\n\n- 亲密相处的两层含义\n\t- 诚实地察觉自己的身、语、意所有活动\n\t- 柔和对待自己\n\n- 不否认自己的缺点和过失，也不认为自己一无是处而失去内心的庄严。\n- 即使面对自己的狭隘、冷漠、混乱，依然不忘记知足和感恩。\n- 只有尊重自己内心的感受，才会愿意去体念他人的感受。\n\n### 四无量心\n- 慈心：愿诸众生永具安乐及安乐因。可理解为内心毫无偏见的友爱之情。\n- 悲心：愿诸众生远离痛苦及痛苦因。可理解为同理心。\n\n- 我们喜欢夸大内心的感受，尤其是负面的感受。虽然这样会加重自己的痛苦，可能是我们不想把心打开，不想原谅某人，或不想面对某些真相。\n\n\t> 宁愿相信自己深受痛苦，让自己心碎比宽恕要容易、痛快得多。每个人都会有自卑的一面，这是正常的，但不要发展到自卑情结的地步。\n\n- 某些情况下，我们会发现对亲近的人反而更难以无条件地爱。亲密的人之间太多执着，我们心里会有许多的期待和要求，不仅要求对方理解、欣赏、领受，且要符合我们的心意，不然便感觉失落、痛苦。\n\t- 启示1：对亲近的人，我们并不缺少爱，而是缺少宽容和放松。\n\t- 启示2：对伤害过我们的人、与我们作为的人、让我们难堪讨厌的人，要学会体念他们的烦恼，也是检验我们宽容和开放的能力。\n\n- 有悲心自然会远离嗔恨心，但实践中某些人的悲心会引发嗔恨心。比如放生者对杀生者产生强烈的偏见。\n- 为别人的成功、健康、善举、快乐等而高兴，所谓随喜。\n\n\t> 启示：即使自己未曾拥有，不要心生嫉妒，就要相信将有一天我们也可以争取拥有，以此激励自己。\n\n- 嫉妒表面是对别人不满，实际反映对自己不满，因为我们意识到自己的不足。","tags":["烦恼","辩证","无常","无我","出离心","菩提心","四无量心"],"categories":["Reading"]},{"title":"别独自用餐","url":"/2022/10/never-eat-alone.html","content":"\n人作为群居性动物，自然演变过程让我们有强烈的归属需求。我们既害怕被他人孤立，又有被群体认同的诉求，矛盾对立存在，所以难免会心生焦虑、恐惧社交，但又渴望与人交往。人非孤岛，既然无法逃避人际交往，那么通过 “教科书式” 方法论，刻意练习我们的社交能力很有必要。\n\n但书本教条终究是冷冰冰的，极大可能掌握了方法技巧，社交能力依然没多少精进。归根结底，任何科学方法都得付诸行动。亲身实践、真诚交友、获得友谊，循环往复积累你的人脉。再具体些，从关系最熟悉的朋友开始吧，思考我能为他人提供什么，动之以情召唤人心，愿你我都能成为受欢迎的人。\n\n> 补充：推荐一本书籍《[心花怒放的人生](https://book.douban.com/subject/35145635/)》，本书在 \"幸福人际\" 章节阐述了一些幸福人际交往的价值观念与行动方法，建议互为补充阅读，另外附上 [思维导图](https://www.kofes.cn/2022/07/Live-a-happy-life.html) 作为参考。\n\n<!-- More -->\n\n## 思想篇\n- 人们合作互助，与所谓的操纵与索取没有半点关系，很少人会计算付出多少或获得多少回报。一旦用这种观点看待人脉的重要性，与他人建立关系便会成为你生活的主旋律。\n- 在零和游戏中，虽然一方占据了所有利益，但长远来看双方都得不到好处。双赢才是这个联系着的世界不可或缺的东西。\n- 向企业贡献忠诚，企业回馈我们生活保障，这是一种美化了的旧时代奴隶关系。\n\n\t> 启示：寻求一种不是对公司的盲目忠诚，而是更私人化的忠诚与慷慨，一种对同事、团队、朋友、客户的忠诚与慷慨。\n\n- 关系像是肌肉，使用越频繁，它就越健壮。\n- 对社交资产的运用才会增加社交资产的价值，即关系是需要人为刻意的情感去运营的。\n- 索取前适度慷慨。\n\n\t> 启示：索取前先给予适度慷慨，互相之间帮助则欠下了人情，还人情过程便建立起私交。实际上也是帮助你在跨越社交圈或者阶层时最有力的武器。\n\n- 以他人角度谈及一些话题，让双方快速熟络起来，也让对方感受到你的诚意。\n- 有机会一定要结识各行各业的人脉，比如饭店老板、房产中介、教培老师等。\n\n\t> 启示：强联结/弱联结理论，有人的地方就有江湖，不要小看任何人脉的力量！\n\n- 付诸行动：承认恐惧、个人并非个例，每一次都努力做到最好。\n- 克服恐惧方法\n\t- 以社牛为榜样\n\t- 学会说话：思想内涵、街头智慧、专业知识都需要修炼提升\n\t- 接受心理治疗\n- 与陌生人交流箴言\n\t- 表明立场：冷静了当告诉对方你的想法\n\t- 表达情感\n\t- 告知目的\n\t- 开放问题：把要求包装成一个问题；一般对方是对立面，尽量找一些反对或者不行动的理由，从而反证必须赞同的必要性。\n- 避免成为 \"社交傻瓜\"\n\t- 蜻蜓点水式社交。\n\t- 豪不掩饰自己的野心，只与上级结交，而忽视同级。\n\t- 把员工同事当作可随意差遣、帮你完成任务的下属。\n\t\n\t\t> 仆人式领导，对员工怀有同理心、拥有共情时刻、适时适机示弱。毕竟需要专业的人才成就伟大事业，只要愿景目标一致，其他都是小事。\n\t\n\t- 不要捧高踩底。\n\t- 不要追求高效率，类似群发节日祝福、群发朋友圈的行为，显得多没有诚意，还不如不发！\n\n## 技巧篇\n- 了解一个人，避免不了去了解他遇到的问题和他的需求，获取答案的途径就是提问与倾听。\n- 与陌生人建立交情第一步，尝试谈论双方或者对方感兴趣、产生共鸣的话题。\n- 拜访或初识对方，即使吃了闭门羹不要紧，有机会再见面时要积极心态去面对。\n- 用你的热情做向导，引领你找到正苦苦寻找的活动或项目，用你的爱好去联系新朋友、维系老朋友。\n- 时刻了解最新时事；培养合适的兴趣，某些冷门的兴趣会给你带来意想不到的巨大收获。\n- 强联结 v.s. 弱联结\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/SocialNetworking-Weak-ties.svg) 强联系 V.S. 弱联系\n\t{%endcenterquote%}\n\n\t- 强联结：与你做同样的事、跟你待同样环境、获取的信息不相上下的人。\n\t- 弱联结：身处不同环境的各色人群，可获得大量不同领域的知识及信息。\n\t- 启示：如果高效发展弱联系，让社交边际效用最大化？\n\t\t- 1）不要蜻蜓点水般认识人\n\t\t- 2）结识 \"结构洞\" 类型的人\n\n- 学会运用非言语交流\n\t- 面带微笑\n\t- 保持相对平衡的眼神交流\n\t- 舒展手臂，不要交叉手臂相对人家\n\t- 点头，身体稍向前倾\n\t- 学会与对方肢体接触，比如击掌、握手、拍拍肩膀\n\n- 不要将对话变得无趣，更甚变成个人垄断式的独白。要分享你的热情，但不要将它变成说教。\n- 成功的沟通取决于与自己联盟的程度以及和我们聊天对象匹配的 `乔哈里窗` 的大小。\n\n\t> 乔哈里窗理论：对人们公开自己程度大小的归纳整理。\n\n- 人性最深处的准则就是希望得到别人的赏识。\n\n\t> 启示：毫不吝啬对对方的赞美之词，并开口邀请对方继续聊天或见面（是我的荣幸）。\n\n## 把交情由浅变深\n- 世界有三种东西可以让友情变得更深厚，它们就是 `健康`、`孩子` 及 `财富`。\n\n\t> 理论依据：马斯洛需求层次模型\n\n\t- 只有在满足了必须物品、安全和性这类处于金字塔底端的需求后，人们才有精力集中于高层次的需求之上。\n\t- 低层次需求就涵盖了健康、孩子与财富。\n\n- 帮助他人实现最基本需求，让它们有机会在金字塔上更上一层楼，相当于帮助他人完成了两件大事。\n\n\t> 比如：关注他人健康、关注他人孩子的读书状况、或是给别人一份赚钱机会。\n\n- 面对陌生人，或者许久没有联系的朋友，生日或者纪念日，是破冰行动或者营造交谈话题的灵药。\n\n\t> 即使口头不说，人们还是很在意自己的生日。\n\n## 数字时代的联系\n- 信任 = 包容度 + 脆弱性 + 责任心 + 公正度\n\t- 包容度：不要对某事或个人打磨成光滑的平面，边缘最好保持粗糙。即还原事情本身、或表现真实自己。\n\t- 脆弱性：学会适时适机示弱；敢于把失败暴露在公众面前。\n\t- 责任心：\n\t\t- 对自己负责：坚持吾日三省吾身，时刻反省以追求更完善自我。\n\t\t- 对他人负责：你要对任何带有你名字的事物负 100% 的责任，没有借口！\n\n- 要给自己的计划留点空白，即留出适当放松的时间，去公园散步、约下老同学老同事喝茶等，总之做一些平日少做或者不会去做的事，即使当时看起来在做无用功，但长期来看受益匪浅。\n\n## 付出就会有回报\n- 终身学习，无限进步。让别人在组织边界内重新定义你以及你的工作。但前提是你得重新审视、重新定义自己，不要给固定的要求限制你。\n- 工作做得再优秀，要学会营销自己。\n- 创建个人品牌，营销自己，也树立了一种个人事业。\n\t- 别人听到或者看到你名字时会想起什么？\n\t- 你能提供什么服务？\n\t- 找一个最大化发挥它们作用的地方。\n- 你所拥有的这一切思想、经历都是由所接触的人共同促进而成的，即使这些东西是我们亲身经历所得，或通过书籍、电影、音乐、绘画等获得，它们背后都是由人创造出来的。\n- 下定决心，社交可赋予我们更多，开始积累你的知识、经验以及人脉，为理想目标努力前行吧！","tags":["职场","同理心","人脉","社牛"],"categories":["Reading"]},{"title":"图文并茂详解 JVM 核心技术","url":"/2022/08/Thinking-in-JVM.html","content":"\n- JVM 的知识体系包括内存管理机制、虚拟机执行子系统、程序编译与代码优化等，即使它们各部分相互独立、没有必然前后依赖关系，但作为初学者通篇学习难度还是较大的。\n- 知识既成体系，那么总有它的躯干主线及枝叶部分。本笔记作用是对 JVM 建立一种宏观认知，比如运行时数据区域特征、内存分配、内存回收、垃圾收集算法、垃圾收集器以及类加载机制等，是我们必要掌握的。深入学习 JVM 底层执行原理，有助于我们了解 Java 程序运行本质，对于编译优化以及虚拟机调优也具有启发性意义。\n- 最后，温馨提示各位朋友，本文大部分内容是基于周志明老师的《深入理解 Java 虚拟机（第三版）》总结整理的，若有讲解含糊或者错误之处请参阅原书（错误之处也请朋友帮忙指正哈）。\n\n<!-- More -->\n\n## JVM运行时数据区域\n- Java 虚拟机（Java Virtual Machine，JVM）在执行 Java 程序过程中会把它所管理的内存划分为若干不同的数据区域。\n- 这些区域各有用途以及各自创建和销毁的时间。比如，有的区域随着虚拟机进程的启动而存在，有些区域以用户线程的启动而创建、结束而销毁。\n\n\t{%centerquote%}\n\t![](/images/CS/JVM/CS-Notes-JVM-Runtime-DataArea.svg)  JVM 运行时数据区域（JDK 1.7)\n\t{%endcenterquote%}\n\n### 程序计数器\n- 程序计数器，可看作是当前线程所执行字节码的行号指示器。若执行的是 Java 方法，则记录正在执行的虚拟机字节码指令的地址；若执行的是本地方法则为空。\n- Java 的多线程是通过线程轮流切换并分配处理器执行时间的方式实现的，任何时刻一个处理器 （多核心处理器是内核）只会执行一条线程中的指令，当某个线程的时间片消耗完毕会自动切换至下一个线程继续执行。\n- 为此，确保线程切换后能恢复正确的执行位置，每条线程都需要拥有一个独立的程序计数器，以保存当前线程的执行位置，我们称这类内存区域为 `线程私有的内存`。\n\n### 虚拟机栈\n- Java 虚拟机栈：`线程的私有内存`。每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。\n\n\t{%centerquote%}\n\t![](/images/CS/JVM/CS-Notes-JVM-Runtime-DataArea-Frame.svg) Java 方法执行时内存模型\n\t{%endcenterquote%}\n\n- 栈帧结构\n\t- 操作数栈：字节码执行时使用的栈结构。\n\t- 局部变量表：用于定义方法中的局部变量，实际上局部变量表在 class 文件中就已定义好了。\n\t- 常量池引用：当前方法调用其他方法时，能够从运行时常量池中找到对应的符号引用，然后将符号引用转换为直接引用，以调用对应方法。这也叫做动态链接。\n\t- 方法出口：方法该如何结束（抛出异常或是正常返回）。\n\n- 模拟虚拟机栈的运作流程\n\t\n\t{%centerquote%}\n\t![](/images/CS/JVM/CS-Notes-JVM-Runtime-DataArea-Frame-Demo.svg) 虚拟机栈运作流程\n\t{%endcenterquote%}\n\t\n\t```java\n\t// 主方法执行后会依次执行三个方法再返回结果\n\t// a() -> b() -> c() -> 返回结果\n\tpublic class Main {\n\t\tpublic static void main(String[] args) {\n\t\t\tint res = a();\n\t\t\tSystem.out.println(res);\n\t\t}\n\t\t\n\t\tpublic static int a(){ return b(); }\n\t\tpublic static int b(){ return c(); }\n\t\t\n\t\tpublic static int c(){\n\t\t\tint a = 10;\n\t\t\tint b = 20;\n\t\t\treturn a + b;\n\t\t}\n\t}\n\t```\n\n- 该区域可能抛出以下异常：\n\t- 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常。\n\n\t\t> 比如无限递归。\n\n\t- 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。\n- 可以通过 `-Xss` 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：\n\n\t```shell\n\tjava -Xss2M HackTheJava\n\t```\n\n### 本地方法栈\n- 本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。\n- 本地方法一般是用其它语言（C / C++  / 汇编语言）编写的，且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。\n\n### 堆\n- 所有线程共享的内存区域，虚拟机启动时创建。\n- `所有对象` 和 `数组` 都在这里分配内存，是垃圾收集的主要区域（GC 堆，Garbage Collected Heap）。\n- 现代的垃圾收集器基本都是采用 `分代收集算法`，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：\n\t- 新生代（Young Generation）\n\t- 老年代（Old Generation）\n- 堆不需要连续内存（不要求物理上连续的内存空间，逻辑连续即可），并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。可通过 `-Xms` 和 `-Xmx` 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。\n\n\t```shell\n\tjava -Xms1M -Xmx2M HackTheJava\n\t```\n\n### 方法区\n- 所有线程共享的内存区域，用于存放已被加载的 `类信息`、`常量`、`静态变量`、`编译时生成的常量池` 等数据。\n\n\t{%centerquote%}\n\t![](/images/CS/JVM/CS-Notes-JVM-Runtime-DataArea-Method.svg) 方法区结构\n\t{%endcenterquote%}\n\n- 在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等则放入堆中。\n\t- 为了更容易管理方法区，从 JDK 1.8 开始，移除永久代并把方法区移至元空间，它位于本地内存中，而非虚拟机内存。\n\t- 方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。\n- 和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。\n- HotSpot 虚拟机把它当成 `永久代` 来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。\n\n### 元空间\n- 类的元信息被存储在元空间（Metaspace）中，元空间没有使用对堆内存，而是使用与堆内存不相连的本地内存区域。\n- 理论上，系统可使用内存有多大，元空间就有多大，为此不会出现永久代存在时的内存溢出问题。\n\n\t{%centerquote%}\n\t![](/images/CS/JVM/CS-Notes-JVM-Runtime-DataArea-MetaArea.svg) JVM 运行时数据区域（JDK 1.8）\n\t{%endcenterquote%}\n\n### 运行时常量池\n- 运行时常量池是方法区的一部分。\n- Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。\n- 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。\n\n\t```java\n\t// String.intern() -- JDK 1.8\n\tif 判断这个常量是否存在于常量池 { // 存在\n\t    if 判断存在内容是引用还是常量 {\n\t        如果是引用，返回引用地址指向堆空间对象\n\t    } else {\n\t        如果是常量，直接返回常量池常量\n\t    }\n\t} else { // 不存在\n\t    将当前对象引用复制到常量池,并且返回的是当前对象的引用\n\t}\n\t```\n\n- [举例] String 类利用常量池进行优化\n\n\t```java\n\tpublic class Main {\n\t\tpublic static void main(String[] args) {\n\t\t\t// Case.01: str1、str2 被存放于常量池中\n\t\t\tString str1 = \"Hello World\";\n\t\t\tString str2 = \"Hello World\";\n\t\t\tString str3 = str1 + str2; // 思考 str3 又是如何形式的？\n\t\t\t\n\t\t\tSystem.out.println(str1 == str2);\t// true, 地址比较\n\t\t\tSystem.out.println(str1.equals(str2));\t// true, 字符串比较\n\t\n\t\t\t// Case.02: 新建对象 str4、str5 存放于堆中（实参还是存放于常量池中）\n\t\t\tString str4 = new String(\"Naive\");\n\t\t\tString str5 = new String(\"Naive\");\n\t\t\t// false, 对象不同内存地址不同\n\t\t\tSystem.out.println(str1 == str2);\n\t\t\t\n\t\t\t// Case.03\n\t\t\t// 第一次调用 intern 方法会把堆中字符串复制并放入常量池 \n\t\t\t// JDK 1.7 之后不进行复制操作，而是直接修改指向堆中引用\n\t\t\t// 第二次调用 intern 方法会直接返回常量池中字符串的地址\n\t\t\tString str6 = new String(\"ab\") + new String(\"c\");\n\t\t\tString str7 = new String(\"ab\") + new String(\"c\");\n\t\t\t// true, 对象不同内存地址不同\n\t\t\tSystem.out.println(str6.intern() == str7.intern());\n\t\t}\n\t}\n\t```\n\n\n### 直接内存\n- 直接内存（也称堆外内存）并不是虚拟机运行时数据区的一部分，也不是 JVM 规范中定义的内存区域。\n- 在 JDK 1.4 中新引入了 `NIO`（New Input/Output）类，它可以使用 Native 函数库直接分配堆外内存，本质上就是 JVM 通过 C/C++ 调用 malloc 函数申请、释放内存。避免了在堆内存和堆外内存之间来回拷贝数据，在一些场景中显著提高性能。\n\n\t```java\n\tpublic final class Unsafe {\n\t\n\t\tprivate Unsafe() {}\n\t\n\t\tprivate static native void registerNatives();\n\t\t\n\t\tstatic {\n\t\t\tregisterNatives();\n\t\t\tsun.reflect.Reflection\n\t\t\t\t.registerMethodsToFilter(Unsafe.class, \"getUnsafe\");\n\t\t}\n\t\t\n\t\t// 饿汉模式\n\t\tprivate static final Unsafe theUnsafe = new Unsafe();\n  \n\t\t@CallerSensitive\n\t\tpublic static Unsafe getUnsafe() {\n\t\t\tClass<?> caller = Reflection.getCallerClass();\n\t\t\tif ( !VM.isSystemDomainLoader(caller.getClassLoader()) )\n\t\t\t\t// 不是 JDK 的类不让用\n\t\t\t\tthrow new SecurityException(\"Unsafe\");   \n\t\t\treturn theUnsafe;\n\t\t}\n\t}\n\t\n\tpublic class Main {\n\t\tpublic static void main(String[] args) throws IllegalAccessException {\n\t\t\tField unsafeField = Unsafe.class.getDeclaredFields()[0];\n\t\t\tunsafeField.setAccessible(true);\n\t\t\tUnsafe unsafe = (Unsafe) unsafeField.get(null);\n\t\t\t\n\t\t\t// 申请 4 字节大小的内存空间并返回地址\n\t\t\tlong address = unsafe.allocateMemory(4);\n\t\t\t// 在对应地址上设定 int 值\n\t\t\tunsafe.putInt(address, 123);\n\t\t\t// 获取对应地址上的 int 值\n\t\t\tSystem.out.println(unsafe.getInt(address));\n\t\t\t// 释放内存\n\t\t\tunsafe.freeMemory(address);\n\t\t}\n\t}\n\t```\n\t\n- 直接内存虽然不受 Java 堆大小限制，但是作为内存还是受限于载体机器的内存大小。配置堆内存最大值时，注意不要大于物理内存的大小限制，不然会导致动态扩展时抛出 OutOfMemoryError 异常。\n\n## 垃圾收集算法与工具\n- 区别于 C/C++ 手动管理内存，Java 会自动管理和释放内存，JVM 提供了一套全自动的内存管理机制。为此，我们学习 JVM 需要关注的问题：\n\t- 对象所占内存何时被回收\n\t- 如何判定对象可以被回收\n\t- 如何进行回收工作\n- 垃圾收集（Garbage Collection, GC）主要是针对 `堆` 和 `方法区` 进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，随线程结束就会消失，因此不需要对这三个区域进行垃圾回收。\n\n### 对象存活判定算法\n#### 引用计数法\n- 为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。\n- 判断一个对象是否还需要被使用：\n\t- 每个对象包含一个引用计数器，用于存放引用计数。\n\t- 每当有一个地方引用此对象时，引用计数 +1。\n\t- 当引用失效，引用计数 -1，比如离开了局部变量的作用域或是引用被设定为 `null`。\n\t- 当引用计数为 0 时，表示此对象不可再被使用，即没有任何方法可得到此对象的引用。\n- 在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行 GC。正是因为循环引用的存在，为此 JVM 不使用引用计数算法。\n\n\t```java\n\tpublic class Test {\n\t\n\t\tpublic Object instance = null;\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tTest a = new Test();\n\t\t\tTest b = new Test();\n\t\t\ta.instance = b;\n\t\t\tb.instance = a;\n\t\t\ta = null;\n\t\t\tb = null;\n\t\t\t\n\t\t\t// 假设在此时发生 GC，a 和 b 能否被回收？\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\t```\n\n\t> 答案是否定的。在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，即使我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。\n\n#### 可达性分析法\n- 以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。\n\n\t> 以图论角度解释，即没有一条路径可以让 GC Roots 达到这个对象。\n\n\t{%centerquote%}\n\t![](/images/CS/JVM/CS-Notes-JVM-GC-Reachability-Analysis.svg) 可达性分析算法判断对象是否可回收\n\t{%endcenterquote%}\n\n- JVM 使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：\n  - 虚拟机栈中局部变量表中引用的对象， 栈帧的局部变量表，即方法得局部变量 。\n  - 本地方法栈中 JNI 中引用的对象。\n  - 方法区中类静态属性引用的对象。\n  - 方法区中的常量引用的对象。\n\n#### 存活最终判断\n- 类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。\n- 当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现 \"自救\"。\n\n\t> 自救只能进行一次，若回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。\n\n#### 方法区的回收\n- 方法区回收：对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但比较难实现且性价比不高。\n\t- 因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。\n\t- 对常量池的回收和对类的卸载。\n\n\t\t> 为了避免内存溢出，在大量使用反射和动态代理的场景都需虚拟机具备类卸载功能。\n\n- 类的卸载条件很多，需要满足以下三个条件：\n\n\t> 注意：满足了条件也不一定会被卸载。\n\n\t- 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。\n\t- 加载该类的 ClassLoader 已经被回收。\n\t- 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。\n\n### 再谈引用类型\n- 无论是通过引用计数法判断对象的引用数量，还是通过可达性分析算法判断对象引用链是否可达，判定对象是否存活都与 `引用` 有关。\n- 四种 `引用强度` 依次逐渐减弱：\n\t- 强引用：被强引用关联的对象不会被回收。当 JVM 内存空间不足时，宁愿抛出 OutOfMemoryError 使得程序异常终止，也不随意回收具备强引用的存活对象。\n\n\t\t```java\n\t\t// 使用 new 一个新对象的方式来创建强引用\n\t\tObject obj = new Object();\n\t\t```\n\n\t- 软引用：被软引用关联的对象只有在 JVM 内存不足的情况下才会被回收。\n\n\t\t```java\n\t\t// 使用 SoftReference 类来创建软引用\n\t\tObject obj = new Object();\n\t\tSoftReference<Object> sf = new SoftReference<Object>(obj);\n\t\tobj = null;  // 使对象只被软引用关联\n\t\t```\n\n\t- 弱引用：被弱引用关联的对象一定会被回收，即它只能存活到下一次 GC 发生之前。\n\n\t\t```java\n\t\t// 使用 WeakReference 类来创建弱引用\n\t\tObject obj = new Object();\n\t\tWeakReference<Object> wf = new WeakReference<Object>(obj);\n\t\tobj = null;\n\t\t\n\t\t// [小知识] WeakHashMap：若 Map 中 Key 没有其他引用，则自动丢弃此键值对。\n\t\tWeakHashMap<String, String> w = new WeakHashMap<>();\n\t\tString key = \"Hello\";\n\t\tw.put(key, \"World\");\n\t\tSystem.out.println(w);\t// {Hello=World}\n\t\tkey = null;\n\t\tSystem.gc();\n\t\tSystem.out.println(w);\t// {}\n\t\t```\n\n\t- 虚引用：又称为幽灵引用或者幻影引用，可以随时被回收。一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。\n\n\t\t> 为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。\n\n\t\t```java\n\t\t// 使用 PhantomReference 来创建虚引用\n\t\t// 类似于 new Object()，并不以任何对象接受它\n\t\tObject obj = new Object();\n\t\tPhantomReference<Object> pf = new PhantomReference<Object>(obj, null);\n\t\tobj = null;\n\t\t```\n\n### 垃圾收集算法\n#### 分代收集机制\n- 思考：对堆中每一对象都依次判断是否存活再回收，显然效率是很低的，那么是否有更高效的回收机制？\n- 方案：对堆中的对象进行分代管理。\n\n\t{%centerquote%}\n\t![](/images/CS/JVM/CS-Notes-JVM-GC-Generational-Recycling.svg) JVM 堆内存\n\t{%endcenterquote%}\n\n\t- JVM 将堆内存划分为 `新生代`、`老年代` 和 `永久代`。\n\t\t- 新生代：对象存活率低，使用 `复制算法`。\n\t\t- 老年代：对象存活率高、没有额外空间对它进行分配担保，使用 `标记-清除` 算法或 `标记-整理` 算法。\n\t\t- 永久代：HotSpot 虚拟机的特有概念，在 JDK 1.8 之前方法区是采用永久代作为实现的；JDK 1.8 之后，方法区由元空间实现，并使用本地内存，容量大小取决于物理机实际大小。\n\n\t- 不同分代内存回收机制也存在一些不同之处，以 HotSpot 虚拟机为例，新生代划分为三块，一块较大的 Eden 空间和两块较小的 Survivor 空间（默认比例为 8:1:1）。\n\n- 运作原理：对于在多次垃圾回收时都未被判定为可回收对象，可将这部分对象放在一起，让垃圾收集器减少此区域对象的回收频率。\n\t- 首先，所有新创建的对象在一开始都会进入新生代的 Eden 区，若为大对象则放入老年代。对新生代区域进行垃圾回收时，对所有新生代区域的对象进行扫描，并回收那些不再使用对象。\n\t- 接着，在一次 GC 之后，Eden 区域没有被回收的对象会放入 Survivor 区。一开始 From 和 To 都是空的，在一次 GC 中，所有 Eden 区域存活的对象都会直接被放入到 From 区。最后，From 和 To 会发生一次交换，即目前存放对象的 From 区变为 To 区，而 To 区变为 From 区。\n\t- 依次类推，下一次 GC 与上面是一样的，只是此时 From 区域中已存在对象了。因此，在 Eden 区的存活对象复制到 From 区域之后，所有 To 区域中的对象会进行年龄判定，每经历一轮 GC 年龄 + 1，如果对象的年龄大于 15（默认值）则直接进入到老年代，否则移动到 From 区。\n\t- 新创建对象 -> Eden -> Survivor，并交换 To 与 From 区，不断重复以上步骤。\n\n\t{%centerquote%}\n\t![](/images/CS/JVM/CS-Notes-JVM-GC-Generational-Recycling-Demo.svg) 分代收集运作原理\n\t{%endcenterquote%}\n\n- 实现细节：根据 JVM 堆内存的各年代特点，采用最适当的垃圾收集算法。\n\n\t{%centerquote%}\n\t![](/images/CS/JVM/CS-Notes-JVM-GC-Generational-Recycling-Implement.svg) 分代收集算法\n\t{%endcenterquote%}\n\n#### 标记-清除算法\n\n{%centerquote%}\n![](/images/CS/JVM/CS-Notes-JVM-GC-Mark-Clear.svg) 标记-清除算法\n{%endcenterquote%}\n\n- 在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。\n- 在清除阶段，会进行对象回收并取消标志位。另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 `空闲链表` 的单向链表，之后进行分配时只需要遍历这个空闲链表，找到分块即可。\n- 在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。\n- 不足：\n\t- 标记和清除过程效率都不高；\n\t- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。\n\t\n#### 标记-整理算法\n\n{%centerquote%}\n![](/images/CS/JVM/CS-Notes-JVM-GC-Mark-Compact.svg) 标记-整理算法\n{%endcenterquote%}\n\n- 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n- 优点：不会产生内存碎片。\n- 不足：需要移动大量对象，处理效率比较低。\n\n#### 标记-复制算法\n\n{%centerquote%}\n![](/images/CS/JVM/CS-Notes-JVM-GC-Mark-Copying.svg) 复制算法\n{%endcenterquote%}\n\n- 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间全部清理。\n- 不足：只使用了内存的一半。\n- 现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。\n\t- 在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。\n\t- HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。我们没有办法保证每次回收都只有不多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。\n\n### HotSpot 算法实现\n#### 根节点枚举\n- 使用可达性分析算法，从一系列 GCRoot 对象开始，向下搜索引用链，若一个对象没有与任何 GCRoot 对象关联，这个对象就会被判定为可回收对象。\n\n\t这一过程称为 `根节点枚举`，也就是垃圾回收中的 `标记过程`。当前所有的垃圾收集器，在标记阶段都必须停止所有 Java 执行线程（Stop the wrold, STW），以保证对象引用状态不会发生变化。\n\n- HotSpot 虚拟机使用的是准确式 GC，当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，而是维护了一个专门的映射表 `OopMap` 记录哪些地方存放着对象引用，来快速完成根节点枚举过程。\n\n\t在类加载完成时，HotSpot 就会把对象内某个偏移位置是否为对象引用记录下来，JIT 编译过程中，也会在特定的位置记录下栈和局部变量表中哪些位置是引用。\n\n#### 安全点 SafePoint\n- 在 OopMap 协助下，HotSpot 可快速且准确地完成 GC Roots 枚举。但是 OopMap 内容变化的指令非常多，如果为每一条指令都生成对应的 OopMap，那么将需要大量的额外空间。为每一个操作记录 OopMap 不现实，为此 HotSpot 虚拟机引入了安全点（SafePoint）的概念。\n\n- SafePoint 是程序中的某些位置，线程执行到这些位置时，线程中的某些状态是确定的，在 SafePoint 可以记录 OopMap 信息，线程在 SafePoint 停顿，虚拟机进行 GC。\n\n- 对于一个线程来说，可处于 SafePoint 上，也可不处于 SafePoint 上。一个线程在 SafePoint 时，它的状态可以安全地被其他 JVM 线程所操作和观测。\n\n- SafePoint 如何在 GC 发生时让所有线程（不包括执行 JNI 调用的线程）能执行在最近的安全点上停顿下来，这里有两种方案可供选择：\n\t- 抢先式中断（Preemptive Suspension）：JVM 需要 GC 时，中断所有线程，让没有到达 SafePoint 的线程继续执行至 SafePoint 并中断。\n\t- 主动式中断（Voluntary Suspension）：在内存中设置标志位，各线程执行时主动式去轮询这个标志，发现中断标志为真时就自己中断挂起。\n\n#### 安全区 SafeRegion\n- SafePoint 无法解决线程未达到 SafePoint 并处于休眠或等待状态的情况，此时引入安全区域（SafeRegion）的概念。\n- SafeRegion 是代码中的一块区域或线程的状态。在 SafeRegion 中，线程执行与否不会影响对象引用的状态。线程进入 SafeRegion 会给自己加标记，告诉虚拟机可以进行GC；线程准备离开 SafeRegion 前会询问虚拟机 GC 是否完成。\n\n### 垃圾收集器的实现\n> 以下垃圾收集器是基于 JDK 1.7 展开介绍的。\n\n{%centerquote%}\n![](/images/CS/JVM/CS-Notes-JVM-GC-HotSpot-Grabage-Collectors.svg) HotSpot 虚拟机的垃圾收集器\n{%endcenterquote%}\n\n- 若 `垃圾收集算法` 是内存回收的 `方法论`，则 `垃圾收集器` 就是内存回收的 `具体实现`。\n- 上图展示了 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以 `配合使用`。\n\n\t> `配合使用`：指的是在限定的使用场景，`新生代` 和 `老年代` 各有垃圾收集器专职负责工作。\n\n- 开始讨论垃圾收集器的语境中，我们需要了解一些名词概念：\n\t- 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程。\n\t- 串行（Serial）：指垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集时需要停顿用户程序。\n\t- 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。\n\t- 并发（Concurrency）：指的是垃圾收集器和用户程序同时执行，用户程序继续运行，垃圾收集器运行于另一个 CPU 上。但不一定是并行，可能交替执行。\n\n\t\t> 除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。\n\n#### Serial 收集器\n\n{%centerquote%}\n![](/images/CS/JVM/CS-Notes-JVM-GC-HotSpot-Serial&SerialOld.svg) Serial + Serial Old 收集器运行示意图\n{%endcenterquote%}\n\n- Serial 翻译为串行，也就是说它以串行的方式执行。\n- 它是 `单线程` 的收集器，只会使用一个线程进行垃圾收集工作。\n- 它是 `Client` 场景下默认的新生代收集器，因为在该场景下内存一般来说不会很大。它收集 100-200 MB 垃圾的停顿时间可以控制在 100 毫秒内，只要不太频繁停顿，时间是可接受的。\n- 优点：简单高效，在单个 CPU 环境下，由于没有线程交互开销，因此拥有最高的单线程收集效率。\n\n#### ParNew 收集器\n\n{%centerquote%}\n![](/images/CS/JVM/CS-Notes-JVM-GC-HotSpot-ParNew.svg) ParNew + Serial Old 收集器运行示意图\n{%endcenterquote%}\n\n- 它是 Serial 收集器的 `多线程` 版本。\n- 它是 `Server` 场景下默认的新生代收集器，除性能原因外，它还能与 CMS 收集器配合使用。\n\n#### Parallel Scavenge 收集器\n\n{%centerquote%}\n![](/images/CS/JVM/CS-Notes-JVM-GC-HotSpot-ParallelScavenge.svg) Parallel Scavenge + Parallel Old 收集器运行示意图\n{%endcenterquote%}\n\n- 与 ParNew 一样是 `多线程` 收集器。\n\n- 其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为 `吞吐量优先` 收集器。吞吐量本质是求得 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值。\n\n\t$$\n吞吐量 = \\frac{运行用户代码的时间}{(运行用户代码时间 + 垃圾收集时间)}\n\t$$\n\n- 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。\n\t\n\t> 若需要缩短停顿时间，是以牺牲吞吐量和新生代空间来换取的。新生代空间变小，回收目标减少，但回收变得频繁，间接导致吞吐量下降。 \n\n- 通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小、Eden 区与 Survivor 区的比例、晋升老年代对象年龄等细节参数了。JVM 会根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间或最大吞吐量。\n\n#### Serial Old 收集器\n- Serial 收集器的老年代版本，也是给 `Client` 场景下的虚拟机使用。\n- 在 Server 场景下：\n\t- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）与 Parallel Scavenge 收集器搭配使用。\n\t- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。\n\n#### Parallel Old 收集器\n- Parallel Scavenge 收集器的老年代版本。\n- 在注重吞吐量以及 CPU 资源敏感的场合，可优先考虑 Parallel Scavenge + Parallel Old 组合。\n\n#### CMS 收集器\n\n{%centerquote%}\n![](/images/CS/JVM/CS-Notes-JVM-GC-HotSpot-CMS.svg) CMS 收集器运行示意图\n{%endcenterquote%}\n\n- CMS：Concurrent Mark Sweep，Mark Sweep 指的是 `标记-清除` 算法。\n- CMS 运作过程可分为以下四个流程：\n\t- `初始标记`：仅是标记一下 GC Roots 能直接关联到的对象，需要停顿用户线程，但速度很快。\n\t- `并发标记`：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿用户线程。\n\t- `重新标记`：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿用户线程。\n\t- `并发清除`：不需要停顿。\n\t\n\t\t> 在整个过程中耗时最长的并发标记和并发清除过程中，支持并发，收集器线程与用户线程一起工作。\n\n- 缺点：\n\t- 吞吐量低：低停顿时间以牺牲吞吐量为代价的，导致 CPU 利用率不够高。\n\t- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure，触发 Full GC。\n\n\t\t> `浮动垃圾`：指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，为此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，此时 JVM 将临时启用 Serial Old 来替代 CMS。\n\t\t> `Concurrent Mode Failure`：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。\n\n\t- 标记-清除算法导致的空间碎片，往往出现老年代空间有剩余，但无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC。\n\n#### G1 收集器\n\n{%centerquote%}\n![](/images/CS/JVM/CS-Notes-JVM-GC-HotSpot-G1.svg) G1 收集器运行示意图\n{%endcenterquote%}\n\n- G1：Garbage-First，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。\n- G1 把堆划分成多个大小相等的独立区域（Region），继续保留新生代和老年代的概念，但新生代和老年代不再 `物理隔离`。\n\t- Region：从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。\n\n\t\t{%centerquote%}\n\t\t![](/images/CS/JVM/CS-Notes-JVM-GC-G1-Region.svg) Region 角色扮演\n\t\t{%endcenterquote%}\n\n\t\t- 垃圾回收分为 Minor GC、Major GC 以及 Full GC，它们分别对应新生代、老年代和整个堆内存的垃圾回收。\n\t\t- G1 巧妙绕开这些约定，将 Java 堆内存划分为 2048 个大小相同且独立的 Region 块，每个块实际大小根据堆内存大小而定，整体控制在 [1 MB, 32 MB] 且满 $2^n$。\n\t\t- 每个 Region 根据需要自由决定扮演哪个角色（Eden / Survivor / 老年代），然后根据对应角色采用不同回收策略。\n\t\t- 此外，G1 还额外存在一个 Humongous 区域，专门用于存放大对象（其大小一般超过 Region 容量一半）。\n\t- 这种划分方法带来了很大的灵活性，使得 `可预测的停顿时间模型` 成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个 `优先列表`，每次根据允许的收集时间，优先 `回收价值最大` 的 Region。\n\t\n\t\t> Tips：Garbage-First 名称的由来。\n\t\n\t- 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做 `可达性分析` 的时候就可以 `避免全堆扫描`。\n\n- 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：\n\t- `初始标记`：仅是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。\n\t- `并发标记`：从 GC Root 开始对堆中对象进行 `可达性分析`，找出存活对象，该阶段耗时较长，但可与用户程序并发执行，不需要停顿。\n\t- `最终标记`：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。\n\t- `筛选回收`：首先对各个 Region 中的 `回收价值和成本进行排序`，根据用户所期望的 GC 停顿时间来制定回收计划。可自由选择任意、多个 Region  构成回收集合，然后将回收集合中存活对象复制到空 Region 中，在对回收集合执行全部清理。此阶段涉及存活对象移动，必须暂停用户线程，且由多个收集器线程并行完成。\n\t\n- 具备如下特点：\n\t- `分代收集`：堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代。而 G1 可以不依赖其他收集器，直接对新生代和老年代一起回收。\n\t- `空间整合`：整体来看是基于 `标记-整理算法` 实现的收集器，从局部 (两个 Region 之间) 上来看是基于 `复制算法` 实现的，这意味着运行期间不会产生内存空间碎片。\n\t- `可预测的停顿`：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。\n\n#### 垃圾收集器总结\n- 综上所述，7 种垃圾收集器大致的细节差异，如下表所示：\n\n\t<table>\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<th>收集器</th>\n\t\t\t\t<th>架构模式</th>\n\t\t\t\t<th>分代收集</th>\n\t\t\t\t<th>运行方式</th>\n\t\t\t\t<th>线程环境</th>\n\t\t\t\t<th>适用场景</th>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<td>Serial</td>\n\t\t\t\t<td>Client</td>\n\t\t\t\t<td>新生代</td>\n\t\t\t\t<td>串行</td>\n\t\t\t\t<td>单线程</td>\n\t\t\t\t<td>--</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>ParNew</td>\n\t\t\t\t<td>Server</td>\n\t\t\t\t<td>新生代</td>\n\t\t\t\t<td>并行</td>\n\t\t\t\t<td>多线程</td>\n\t\t\t\t<td>--</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>Parallel Scavenge</td>\n\t\t\t\t<td>--</td>\n\t\t\t\t<td>新生代</td>\n\t\t\t\t<td>并行</td>\n\t\t\t\t<td>多线程</td>\n\t\t\t\t<td>吞吐量优先<br>CPU 资源敏感场合</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>Serial Old</td>\n\t\t\t\t<td>Client</td>\n\t\t\t\t<td>老年代</td>\n\t\t\t\t<td>串行</td>\n\t\t\t\t<td>单线程</td>\n\t\t\t\t<td>--</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>Parallel Old</td>\n\t\t\t\t<td>--</td>\n\t\t\t\t<td>老年代</td>\n\t\t\t\t<td>并行</td>\n\t\t\t\t<td>多线程</td>\n\t\t\t\t<td>吐量优先<br>CPU 资源敏感场合</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>CMS</td>\n\t\t\t\t<td>Server</td>\n\t\t\t\t<td>老年代</td>\n\t\t\t\t<td>并发</td>\n\t\t\t\t<td>多线程</td>\n\t\t\t\t<td>并发收集、低停顿；<br>会产生内存空间碎片</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>G1</td>\n\t\t\t\t<td>Server</td>\n\t\t\t\t<td>新 / 老</td>\n\t\t\t\t<td>并发</td>\n\t\t\t\t<td>多线程</td>\n\t\t\t\t<td>并发收集、低停顿；<br>会产生内存空间碎片</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n\n## 内存分配与回收策略\n### 内存分配策略\n#### 对象优先在 Eden 分配\n- 大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。\n\n#### 大对象直接进入老年代\n- 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。\n- 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。\n- `-XX:PretenureSizeThreshold`：大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。\n\n#### 长期存活对象进入老年代\n- 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。\n- `-XX:MaxTenuringThreshold`：用来定义年龄的阈值。\n\n#### 动态对象年龄判定\n- 虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。\n\n#### 空间分配担保\n- 思考：一种极端情况，在一次 GC 后新生代 Eden 区仍然存在大量的对象，然而存活对象会进入到一个 Survivor 区，但此时极有可能超出 Survivor 区的容量，如何处理？\n- 方案：空间分配担保机制，把 Survivor 区无法容纳的对象直接送到老年代，让老年代进行分配担保。前提是老年代也得装得下才行，为此会发生一次 Minor GC。\n- 在发生 Minor GC 之前，JVM 先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果：\n\t- 条件成立，Minor GC 可确认是安全的。\n\t- 条件不成立，JVM 会查看 HandlePromotionFailure 的值是否允许担保失败，若允许则继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。\n\t\t- 如果大于，将尝试着进行一次 Minor GC；\n\t\t- 如果小于，或者 HandlePromotionFailure 的值不允许冒险，则直接进行一次 Full GC。\n\n### 内存回收策略\n#### Minor / Major / Full GC\n- `Minor GC`·：次要垃圾回收，回收新生代。因新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行速度也比较快。\n\t\n\t- 触发条件：新生代的 Eden 区容量已满时。\n- `Major GC`：主要垃圾回收，回收老年代。\n- `Full GC`：完全垃圾回收，回收老年代和新生代，因老年代对象存活时间长，因此 Full GC 很少执行，执行速度较 Minor GC 慢很多。\n\t- 触发条件 1：每次晋升到老年代的对象平均大小大于老年代剩余空间。\n\t- 触发条件 2：Minor GC 后存活的对象超过了老年代剩余空间。\n\t- 触发条件 3：永久代内存不足（JDK 1.8 之前）。\n\t- 触发条件 4：手动调用 System.gc() 方法。\n\n#### System.gc()\n- `System.gc()`：调用 System.gc() 只是 `建议` 虚拟机执行 Full GC，但虚拟机不一定真正去执行。\n\n\t> 不建议使用这种方式，而是让虚拟机管理内存。\n\n#### 老年代空间不足\n- 老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。\n- 为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。\n- 除此之外，可以通过 `-Xmn` 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。\n- 还可以通过` -XX:MaxTenuringThreshold` 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。\n\n#### 空间分配担保失败\n- `空间分配担保失败`：使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面 [空间分配担保](#空间分配担保)。\n\n#### 永久代空间不足\n- 在 JDK 1.7 以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放着 Class 类信息、常量、静态变量等数据。\n- 当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。\n- 为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。\n- `Concurrent Mode Failure`：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。\n\n## 虚拟机类加载机制\n### 类的生命周期\n- Java 类的加载过程指的是加载、验证、准备、解析和初始化这 5 个阶段。\n- Java 类的生命周期指的是一个 class 文件从加载到卸载的全过程。\n\n\t{%centerquote%}\n\t![](/images/CS/JVM/CS-Notes-JVM-ClassLoading-Lifecycle.svg) Java 类的生命周期\n\t{%endcenterquote%}\n\n### 类的加载过程\n- 类是在运行期间第一次使时才动态加载的，而不是一次性加载所有类。比如，加载主类才能运行主类的 main 方法；通过反射数据库驱动类以加载数据库驱动。\n- 类会被触发自动完成加载的情况：\n\t- 使用 new 创建对象\n\t- 使用某个类的静态成员（变量或方法）\n\n\t\t> 注意：final 声明的静态变量，在编译时被放到当前类的常量池中，此种情况不会触发自动加载的。\n\n\t- 使用反射获取类信息\n\t- 加载一个类的子类时\n\n\t\t> 子类或者匿名类会另外创建一个 class 文件，以各自存储类的信息。比如 Main\\$Solution.class、Main\\$1.class。\n\t\t\n\t\t```java\n\t\tpublic class Main {\n\t\t\tpublic static void main(String[] args) {\n\t\t\t\t// 对应 Main$1.class\n\t\t\t\tnew Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() { ... }\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 对应 Main$Solution.class\n\t\t\tpublic static Solution { ... }\n\t\t}\n\t\t```\n\n#### 加载\n- Java 代码编译和加载过程\n\n\t{%centerquote%}\n\t![](/images/CS/JVM/CS-Notes-JVM-ClassLoading-Processing.svg) Java 代码编译和加载过程\n\t{%endcenterquote%}\n\n- 加载是类加载过程的一个阶段，加载过程 JVM 需要完成以下三件事：\n\t- 通过 `类的完全限定名称` 获取定义该类的 `二进制字节流`。\n\t- 将该字节流表示的静态存储结构转换为 `方法区运行时数据结构`。\n\t- 在堆内存中生成一个代表该类的 Class 对象，作为方法区中该操作类中各种数据的访问入口。\n\n#### 验证\n- 确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。\n\n#### 准备\n- 为类变量（static 修饰）分配内存并设置初始值，使用的是 `方法区` 的内存。\n\n\t> 区分各种概念变量：\n\t> `类变量`：独立于方法之外的变量，用 static 修饰。也称为静态成员变量。\n\t> `实例变量`：独立于方法之外的变量，不过没有 static 修饰。\n\t> `局部变量`：类的方法中的变量。\n\n- 实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在 `堆` 中。实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。\n\n- 初始值一般为 0 值，例如下面的 `类变量` value 被初始化为 0 而不是 123。\n\n\t```java\n\tpublic static int value = 123;\n\t```\n\n- 如果 `类变量` 是 `常量`，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。\n\n\t```java\n\tpublic static final int value = 123;\n\t```\n\n#### 解析\n- 将常量池的 `符号引用` 替换为 `直接引用` 的过程。\n- 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。\n\n#### 初始化\n\n- 在准备阶段，类变量已经赋过一次系统要求的初始值；而在初始化阶段，开发人员通过程序制定的主观计划去初始化类变量和其它资源。\n\n\t> 初始化阶段才真正开始执行类中定义的 Java 程序代码。\n\n- 初始化阶段是虚拟机执行类构造器 <clinit> 方法的过程。\n- <clinit> 方法是由编译器自动收集类中所有 `类变量的赋值语句` 和 `静态语句块` 中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。\n\n\t```java\n\tpublic class Test {\n\t\tstatic {\n\t\t\ti = 0;                // 给变量赋值可以正常编译通过\n\t\t\tSystem.out.print(i);  // 这句编译器会提示 “非法向前引用”\n\t\t}\n\t\tstatic int i = 1;\n    }\n\t```\n\n- 由于父类的 <clinit> 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。\n\n\t```java\n\tstatic class Parent {\n\t\tpublic static int A = 1;\n\t\tstatic {\n\t\tA = 2;\n\t\t}\n\t}\n\t\n\tstatic class Sub extends Parent {\n\t\tpublic static int B = A;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(Sub.B);  // 2\n\t}\n\t```\n\n### 类初始化时机\n#### 主动引用\n- 虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了 `有且只有` 下列五种情况必须对类进行初始化 (加载、验证、准备都会随之发生)：\n\t- 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。生成这 4 条指令的常见场景是：\n\t\t- 使用 new 关键字实例化对象时；\n\t\t- 读取或设置一个类的静态字段时 (被 final 修饰、已在编译期把结果放入常量池的静态字段除外)；\n\t\t- 以及调用一个类的静态方法时。\n\t- 使用 java.lang.reflect 包的方法对类进行 `反射调用` 时，如果类没有进行初始化，则需要先触发其初始化。\n\t- 当初始化一个类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。\n\t- 当虚拟机启动时，用户需要指定一个要执行的主类 (包含 main() 方法的类)，虚拟机会先初始化这个主类；\n\t- 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；\n\n#### 被动引用\n- 以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：\n\t- 通过子类引用父类的静态字段，不会导致子类初始化。\n\n\t\t```java\n\t\t// value 字段在 SuperClass 中定义\n\t\tSystem.out.println(SubClass.value);\n\t\t```\n\n\t- 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。\n\n\t\t```java\n\t\tSuperClass[] sca = new SuperClass[10];\n\t\t```\n\n\t- 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。\n\n\t\t```java\n\t\tSystem.out.println(ConstClass.HELLOWORLD);\n\t\t```\n\n### 类与类加载器\n- 两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。因为每一个类加载器都拥有一个独立的 `类名称空间`。\n- 这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的判定结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。\n\n### 类加载器分类\n- 从 JVM 角度，只存在两种类加载器：\n\t- 启动类加载器：使用 C++ 实现，是 JVM 自身一部分；\n\t- 所有其它类的加载器：使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。\n- 从 Java 开发人员角度，类加载器可划分为：\n\t- 启动类加载器（Bootstrap ClassLoader）\n\t\t- 此类加载器负责将存放在 `<JRE_HOME>\\lib` 目录中的，或者被 `-Xbootclasspath` 参数所指定的路径中的，并且是虚拟机识别的 `类库` 加载到虚拟机内存中。\n\n\t\t\t> 仅按照文件名识别，比如 rt.jar。名字不符合的类库即使放在 lib 目录中也不会被加载。\n\t\t\n\t\t- 启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。\n\t- 扩展类加载器（Extension ClassLoader）\n\t\t- 这个类加载器是由 ExtClassLoader (sun.misc.Launcher$ExtClassLoader) 实现的。\n\t\t- 它负责将 `<JAVA_HOME>/lib/ext` 或者被 `java.ext.dir` 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。\n\t- 应用程序类加载器（Application ClassLoader）\n\t\t- 这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。\n\t\t- 由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n\n### 双亲委派模型\n#### 概念\n- 如下图所示，展示了类加载器之间的层次关系，即一个类加载器首先将类加载请求转发到父类加载器，只有当顶级加载器加载失败时，则逐级原路交还调用者完成加载，称之为双亲委派模型（Parents Delegation Model）。\n- 应用程序是由三种类加载器互相配合从而实现类加载，此外也可以加入自定义的类加载器。\n\n\t{%centerquote%}\n\t![](/images/CS/JVM/CS-Notes-JVM-ClassLoader-ParentsDelegationModel.svg) 类加载器间的层次关系\n\t{%endcenterquote%}\n\n\t- 该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。\n\t- 这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。\n\n#### 好处\n- 防止同一个 class 文件重复被加载，且确保了任意一个类在 JVM 中的唯一性。\n\n\t> 原理：两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。\n\n- 使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。比如 java.lang.Object 存放在 rt.jar 中，若编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以通过编译。\n\t- 由于双亲委派模型的存在，在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高。\n\t- 因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。\n\t- rt.jar 中的 Object 优先级更高，保证了程序中所有的 Object 都是这个 Object。\n\n#### 实现\n\n- 以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：\n\t- 先检查类是否已经加载过，如果没有则让父类加载器去加载。\n\t- 当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。\n\n\t```java\n\tpublic abstract class ClassLoader {\n\t\t// The parent class loader for delegation\n\t\tprivate final ClassLoader parent;\n\t\n\t\tpublic Class<?> loadClass(String name) \n\t\t\tthrows ClassNotFoundException {\n\t\t\treturn loadClass(name, false);\n\t\t}\n\t\n\t    protected Class<?> loadClass(String name, boolean resolve) \n\t\t\tthrows ClassNotFoundException {\n\t\t\tsynchronized ( getClassLoadingLock(name) ) {\n\t\t\t\t// First, check if the class has already been loaded\n\t\t\t\tClass<?> c = findLoadedClass(name);\n\t\t\t\tif (c == null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (parent != null) {\n\t\t\t\t\t\t\tc = parent.loadClass(name, false);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tc = findBootstrapClassOrNull(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t\t// ClassNotFoundException if class not found\n\t\t\t\t\t\t// from the non-null parent class loader\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (c == null) {\n\t\t\t\t\t\t// If still not found, then invoke findClass \n\t\t\t\t\t\t// in order to find the class.\n\t\t\t\t\t\tc = findClass(name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (resolve) {\n\t\t\t\t\tresolveClass(c);\n\t\t\t\t}\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\n\t\tprotected Class<?> findClass(String name) \n\t\t\tthrows ClassNotFoundException {\n\t\t\tthrow new ClassNotFoundException(name);\n\t\t}\n\t}\n\t```\n\n### 自定义类加载器\n\n- 继承自 java.lang.ClassLoader，用于加载文件系统上的类。\n\t- 它首先根据类的全名在文件系统上查找类的字节代码文件 (.class 文件)；\n\t- 然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。\n\n- java.lang.ClassLoader 的 loadClass 方法实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass 方法。\n\n\t```java\n\tpublic class FileSystemClassLoader extends ClassLoader {\n\t\n\t\tprivate String rootDir;\n\t\n\t\tpublic FileSystemClassLoader(String rootDir) {\n\t\t\tthis.rootDir = rootDir;\n\t\t}\n\t\t\n\t\t@Override\n\t\tprotected Class<?> findClass(String name) \n\t\t\tthrows ClassNotFoundException {\n\t\t\tbyte[] classData = getClassData(name);\n\t\t\tif (classData == null) {\n\t\t\t\tthrow new ClassNotFoundException();\n\t\t\t} else {\n\t\t\t\treturn defineClass(name, classData, 0, \n\t\t\t\t\tclassData.length);\n\t\t\t}\n\t\t}\n\t\n\t    private byte[] getClassData(String className) {\n\t\t\tString path = classNameToPath(className);\n\t\t\ttry {\n\t\t\t\tInputStream ins = new FileInputStream(path);\n\t\t\t\tByteArrayOutputStream baos = \n\t\t\t\t\tnew ByteArrayOutputStream();\n\t\t\t\tint bufferSize = 4096;\n\t\t\t\tbyte[] buffer = new byte[bufferSize];\n\t\t\t\tint bytesNumRead;\n\t\t\t\twhile ((bytesNumRead = ins.read(buffer)) != -1) {\n\t\t\t\t\tbaos.write(buffer, 0, bytesNumRead);\n\t\t\t\t}\n\t\t\t\treturn baos.toByteArray();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn null;\n\t    }\n\t\n\t    private String classNameToPath(String className) {\n\t\t\treturn rootDir + File.separatorChar\n\t\t\t\t+ className.replace('.', File.separatorChar) \n\t\t\t\t+ \".class\";\n\t    }\n\t}\n\t```\n\t\n## 参考资料 \n- [周志明. 深入理解 Java 虚拟机 [M]. 第三版. 机械工业出版社, 2019](https://book.douban.com/subject/34907497/)\n- [周志明. 深入理解 Java 虚拟机 [M]. 第二版. 机械工业出版社, 2013](https://book.douban.com/subject/24722612/)\n- [Cyc2018. Java 虚拟机 [OL]. www.cyc2018.xyz](http://www.cyc2018.xyz/Java/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.html)\n- [青空の霞光. Java JVM [OL]. bilibili.com](https://www.bilibili.com/video/BV1Er4y1r7as)","tags":["JVM","GC","G1","类加载","垃圾回收","垃圾收集"],"categories":["Project"]},{"title":"别因名字错过一本好书：活出心花怒放的人生","url":"/2022/07/Live-a-happy-life.html","content":"\n- 积极心理学，人类的幸福课，让没有疾病的普通人过上更有活力、更有创造力、更加发挥自己潜力的生活。\n- 事实上，我们总会在内心、人际、职场、爱情、家庭等方面遇到闹心事，负面情绪很大程度导致了不开心，甚至内心痛苦。就像《[次第花开](https://book.douban.com/subject/5450660/)》所启示的，我们之所以痛苦，是因为痛苦源自于对痛苦的无知，解脱应该从认识痛苦开始。生活亦是如此，既然阻止不了必然发生的糟心事，那就改变面对不幸的心态。发挥人的主观能动性，敢于承认客观事实，着力解决当下问题，获得短暂安宁以感受幸福快乐。\n\n\t> 推荐一部电影《[祝你好运](https://movie.douban.com/subject/30471496/)》：影片对于“积极心态”、“幸运厄运”、“好坏两面性”的诠释挺有意思的，即好/坏事物带给我们的情绪价值都是有意义的，积极心态影响着我们的认知，又反指导着我们改造世界。\n\n- 当然，积极心理学并不是 \"免死金牌\"，未来我们同样会不断遭遇痛苦与不幸。认识痛苦不幸的普遍性，即阻止不了它的显现，也无法预测它的变化，为此我们要积极心态、坦然面对、付诸行动。另外，任何心理问题最终都需自身去顿悟解决，条件允许之下再去影响他人、援助他人，如此循环往复，成为一位内心强大的人。\n\n<!-- More -->\n\n- 方便您阅读，附上思维导图的矢量稿：[PDF Download](/pdf/Live_a_happy_life.pdf)\n\n\t{%centerquote%}\n\t ![](/images/Reading/Live-a-happy-life/Live-a-happy-life.svg) 《活出心花怒放的人生》思维导图\n\t{%endcenterquote%}\n\n","tags":["积极心理学","内卷","心流","福流","职场","育儿"],"categories":["Reading"]},{"title":"扛得住的 MySQL 数据库性能优化","url":"/2022/06/mysql-architect.html","content":"\n遵循“先抽象后具体，先软件后硬件”原则，通过数据库结构设计、SQL 优化、存储引擎、操作系统以及服务器硬件等方面，设计方案以优化数据库性能。\n\n<!-- More -->\n\n## 数据库性能分析\n- 数据库性能优化顺序：原则是先抽象后具体，先软件后硬件。\n\t- Case.01：数据库结构设计与 SQL 优化\n\t- Case.02：存储引擎选型\n\t- Case.03：操作系统选型\n\t- Case.04：服务器硬件升级\n\n### 数据库结构设计\n- 过分的范式化设计会造成太多表关联，影响查询效率。过分的反范式化设计会造成表中太多冗余列。在项目当中要以实际场景出发合理设计数据表。\n- 避免在 OLTP 环境中使用不恰当的分区表。\n- 使用外键保证了数据完整性，但对于表维护等操作的效率影响是尤为明显的。\n\n### 数据库存储引擎\n- 围绕事务、备份、锁粒度等方面选择合适的数据库存储引擎。\n\n\t> MySQL 如何选择合适的存储引擎：[存储引擎](#存储引擎)\n\n### 服务器硬件\n#### CPU 方案\n- 对于高并发场景，CPU 多核心数量比 CPU 单核心频率更重要。\n- 对于复杂 SQL 以及 CPU 密集型场景，CPU 单核心频率更重要。\n\n#### 内存方案\n- 理论上，内存大小、内存频率的选型方案以硬件支持的最大性能输出最好。\n\n#### 磁盘方案\n- 使用 RAID 增强传统机械硬盘性能：磁盘冗余阵列（RAID），利用多块磁盘实现数据的并发读写和数据备份，主要为了改善磁盘的访问延迟，增加磁盘的可用性和容错能力。\n\n\t{%centerquote%}\n\t![](/images/CS/MySQL-Architect/MySQL-Architecture-RAID.svg)  RAID\n\t{%endcenterquote%}\n\n\t- RAID 0：根据磁盘将数据分为 n 份，数据同时并发写入 n 快磁盘，使得数据整体写入速度是一块磁盘的 n 倍。同理，RAID 0 也具有极速的读速度。\n\n\t\t> 但 RAID 0 不做数据备份，n 块硬盘中只要有一块损坏，数据完整性即被破环，所有磁盘的速度都会损坏。\n\t\n\t- RAID 1：一份数据同时写入两块硬盘，这样任何一块硬盘损坏都不会导致数据丢失，插入一块新磁盘可通过复制数据方式自动修复。\n\n\t- RAID 10：将所有磁盘平均分成两份，数据同时在两份磁盘写入（相当与 RAID 1）。但每一份数据在 n/2 块磁盘上，利用 RAID 0 技术并发读写。\n\n\t\t> 结合 RAID 0 和 RAID 1 两种方案，但 RAID 10 磁盘利用率较低（一半磁盘用来备份数据）。\n\n\t- RAID 3：一般情况，一台服务器不会同时损坏两块磁盘的情况（物理因素除外），假设在只损坏一块磁盘情况下，利用其他磁盘的数据回复损坏磁盘的数据，即保证了可靠性和性能，同时提升了磁盘利用率。\n\n\t\t将数据分成 n-1 份，并发写入 n-1 块磁盘，并在第 n 块磁盘记录校验数据，任何一块磁盘损坏（包含校验数据磁盘），都可利用其他 n-1 块磁盘恢复数据。\n\n\t- RAID 5：原理与 RAID 3 相似，但校验数据不是写入第 n 块磁盘，而是螺旋式地写入所有磁盘中。即检验数据也平均到所有磁盘上，避免了频繁写坏一块磁盘。\n\t\n\t- RAID 6：原理与 RAID 3 相似，数据写入 n-2 块磁盘中，并螺旋式地在两块磁盘中写入校验信息（使用不同算法生成）。\n\n- 使用固态存储 SSD 与 PCIe 卡\n\t- 较于机械磁盘有较好随机读写性能\n\t- 解决单线程负载 I/O 性能瓶颈问题\n\n- 使用网络存储 NAS 与 SAN：两种外部文件存储设备加载到服务器上的方法\n\t- NAS（Network-Attached Storage）：NAS 设备使用标准以太网连接，NAS 通过基于文件协议来访问数据，比如 NFS / SMB 协议。\n\t- SAN（Storage Area Network）：SAN 设备通过光纤连接，SAN 在块级别存储数据。\n\n\t\t> 通俗理解，SAN 是网络上的硬盘，NAS 则是网络上的文件系统。\n\n## 数据库结构设计\n### 设计的目的\n- 尽量避免数据维护中出现更新、插入以及删除异常。\n\n\t<table>\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<th>学号</th>\n\t\t\t\t<th>姓名</th>\n\t\t\t\t<th>年龄</th>\n\t\t\t\t<th>课程号</th>\n\t\t\t\t<th>课程</th>\n\t\t\t\t<th>学分</th>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<td>1</td>\n\t\t\t\t<td>张三</td>\n\t\t\t\t<td>20</td>\n\t\t\t\t<td>C1</td>\n\t\t\t\t<td>马克思基本原理概论</td>\n\t\t\t\t<td>3.0</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>2</td>\n\t\t\t\t<td>张三</td>\n\t\t\t\t<td>20</td>\n\t\t\t\t<td>C2</td>\n\t\t\t\t<td>数据结构</td>\n\t\t\t\t<td>5.0</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>3</td>\n\t\t\t\t<td>李四</td>\n\t\t\t\t<td>21</td>\n\t\t\t\t<td>C3</td>\n\t\t\t\t<td>高等数学</td>\n\t\t\t\t<td>5.0</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>4</td>\n\t\t\t\t<td>王五</td>\n\t\t\t\t<td>19</td>\n\t\t\t\t<td>C2</td>\n\t\t\t\t<td>数据结构</td>\n\t\t\t\t<td>5.0</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n\n\t- 插入异常：表中某个实体随着另一个实体而存在。\n\n\t\t> 比如：插入一门新课程 (C4, 论文写作, 2.0)，但此课程并暂没有学生选修，此时会报 \" '学号' doesn't have a default value\" 异常。\n\n\t- 更新异常：更改表中某个实体的单独属性时，需对多行进行更新。\n\n\t\t> 比如：修改课程 \"数据结构\" 的学分为 4.5，则多条数据更新异常。\n\t\n\t- 删除异常：删除表中某一实体则会导致其他实体消失。\n\n\t\t> 比如：删除 \"学号=4\" 的记录，\"高等数学\" 这门课随之删除。\n\n- 减少数据冗余\n\n- 提高查询效率\n\n- 节省存储空间\n\n### 设计的步骤\n- 需求分析：存储需求、数据处理需求、数据的安全性以及完整性\n- 逻辑设计：设计数据的逻辑存储结构\n\t- 数据实体之间的逻辑关系，解决数据冗余和数据维护异常\n\t- 范式设计准则\n- 物理设计：根据所使用的数据库特征进行表结构设计\n- 维护优化：索引、存储结构优化等\n\n### 范式设计\n#### 范式化设计\n- 第一范式（1NF）：\n\t- 属性不可分，即数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。\n\t- 单一属性列由基本的数据类型所构成。\n- 第二范式（2NF）：\n\t- 表中只具有一个主键。\n\t- 每个非主属性完全函数依赖于键码，而不能存在非主属性部分依赖于键码。\n\n\t\t> 比如，复合主键中常包括两种实体，如上述例子中的学生实体与课程实体，它们各自的属性依赖于各实体的主键。\n\n- 第三范式（3NF）：\n\t- 非主属性即不部分依赖，也不传递函数依赖于键码。\n\n\t\t> 简而言之，第三范式就是属性不依赖于其它非主属性。\n\n\t- 上述的关系中存在以下传递函数依赖：学号 $\\to$ 课程 $\\to$ 学分。\n\n#### 反范式设计\n- 反范式化：鉴于性能和读取效率考量，适当违反数据库范式设计要求，允许少量数据冗余。\n- 优劣比较\n\n\t<table>\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<th>优劣</th>\n\t\t\t\t<th>范式化</th>\n\t\t\t\t<th>反范式化</th>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<td>优势</td>\n\t\t\t\t<td>1) 可尽量减少数据冗余<br>2) 更新操作较反范式化快</td>\n\t\t\t\t<td>1) 减少表关联查询<br>2) 更好进行索引优化</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>劣势</td>\n\t\t\t\t<td>1) 多表关联查询<br>2) 难以进行索引优化</td>\n\t\t\t\t<td>1) 存在数据冗余及数据维护异常</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n\t\n### 物理设计\n#### 存储引擎\n- 选择合适的存储引擎\n\n\t<table>\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<th>存储引擎</th>\n\t\t\t\t<th>事务</th>\n\t\t\t\t<th>锁粒度</th>\n\t\t\t\t<th>忌用</th>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<td>MyISAM</td>\n\t\t\t\t<td>不支持</td>\n\t\t\t\t<td>支持并发插入的表级锁</td>\n\t\t\t\t<td>读写操作频繁</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>Innodb</td>\n\t\t\t\t<td>支持</td>\n\t\t\t\t<td>行级锁</td>\n\t\t\t\t<td>--</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>Archive</td>\n\t\t\t\t<td>不支持</td>\n\t\t\t\t<td>支持并发插入的表级锁</td>\n\t\t\t\t<td>随时读取、更新、删除</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>Ndb Cluster</td>\n\t\t\t\t<td>支持</td>\n\t\t\t\t<td>行级锁</td>\n\t\t\t\t<td>--</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n\n- InnoDB\n\t-  MySQL 默认的事务型存储引擎，只有在它不支持某些特性时，才考虑其它存储引擎。\n\t- 实现了四个标准的隔离级别，默认级别是可重复读 (REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制 (MVCC) + Next-Key Locking 防止幻影读。\n\t- 主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。\n\n\t\t> 聚簇与非聚簇的区别在于：数据文件与索引文件是否分开存储。比如非聚簇索引，索引文件的叶子节点的 data 域仅保存数据记录地址。\n\n\t- 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。\n\t- 支持真正的 `在线热备份`。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。\n\n- MyISAM\n\t- 管理非事务表，是 ISAM (Indexed Sequential Access Method，有索引的顺序访问方法) 的扩展格式。\n\t- 不是事务安全的，且不支持外键。\n\t- 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入。\n\t- 可手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。\n\n#### 数据类型\n- 整数类型\n\n  <table>\n  \t<thead>\n  \t\t<tr>\n  \t\t\t<th>描述</th>\n  \t\t\t<th>列类型</th>\n  \t\t\t<th>存储空间</th>\n  \t\t\t<th width=30%>显示宽度（默认值 M）</th>\n  \t\t\t<th width=30%>取值范围</th>\n  \t\t</tr>\n  \t</thead>\n  \t<tbody>\n  \t\t<tr>\n  \t\t\t<td>标准整型</td>\n  \t\t\t<td>int</td>\n  \t\t\t<td>4 字节</td>\n  \t\t\t<td>int(11)</td>\n  \t\t\t<td>有符号：[-2^{31},  2^{31}-1]<br>无符号：[0,  2^{32}]</td>\n  \t\t</tr>\n  \t\t<tr>\n  \t\t\t<td>大整型</td>\n  \t\t\t<td>bigint</td>\n  \t\t\t<td>8 字节</td>\n  \t\t\t<td>int(20)</td>\n  \t\t\t<td>有符号：[-2^{63},  2^{63}-1]<br>无符号：[0,  2^{64}]</td>\n  \t\t</tr>\n  \t</tbody>\n  </table>\n\n\n  - 显示宽度和数据类型的取值范围是没有任何关系的，显示宽度指 MySQL 最大可能显示的数字个数，数值位数小于指定宽度时由空格填充。\n  - 若插入大于显示宽度的值，只要该值不超过该类型的取值范围，数值依然可以插入。\n\n- 浮点类型\n\n  <table>\n  \t<thead>\n  \t\t<tr>\n  \t\t\t<th>描述</th>\n  \t\t\t<th>列类型</th>\n  \t\t\t<th width=25%>存储空间</th>\n  \t\t\t<th width=25%>显示宽度（默认值 M）</th>\n  \t\t\t<th>取值范围</th>\n  \t\t</tr>\n  \t</thead>\n  \t<tbody>\n  \t\t<tr>\n  \t\t\t<td>定点数</td>\n  \t\t\t<td>decimal</td>\n  \t\t\t<td>9 个数 / 4 字节<br>小数点占 1 字节</td>\n  \t\t\t<td>decimal(10, 0)</td>\n  \t\t\t<td>--</td>\n  \t\t</tr>\n  \t</tbody>\n  </table>\n\n\n  - 整个数字长度 M = 小数点左边位数 + 小数点右边位数 D，但不包括负号\n\n- 字符类型\n\n\t<table>\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<th>描述</th>\n\t\t\t\t<th>列类型</th>\n\t\t\t\t<th>存储空间</th>\n\t\t\t\t<th>取值范围</th>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<td>固定长度字符串</td>\n\t\t\t\t<td>char</td>\n\t\t\t\t<td>255 字符</td>\n\t\t\t\t<td>[0, 2^8-1]</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>可变长度字符串</td>\n\t\t\t\t<td>text</td>\n\t\t\t\t<td>65535 字符</td>\n\t\t\t\t<td>[0, 2^{16}-1</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>非二进制字符串</td>\n\t\t\t\t<td>varchar</td>\n\t\t\t\t<td>65535 字符</td>\n\t\t\t\t<td>[0, 2^{16}-1</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>二进制大对象</td>\n\t\t\t\t<td>blob</td>\n\t\t\t\t<td>--</td>\n\t\t\t\t<td>[0, 2^{16}-1</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n\t\n\t- 使用比较运算符比较 char 值时，MySQL 不会考虑尾随空格，例如：=，<>，>，< 等。\n\t- 当使用模式匹配检索 char 值时，LIKE 运算符会考虑尾随空格。\n\n- 日期类型\n\n\t<table>\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<th>列类型</th>\n\t\t\t\t<th>存储空间</th>\n\t\t\t\t<th>取值范围</th>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<td>date</td>\n\t\t\t\t<td>3 字节</td>\n\t\t\t\t<td>[0000-01-01, 9999-12-31]</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>datetime</td>\n\t\t\t\t<td>8 字节</td>\n\t\t\t\t<td>YYYY-MM-DD HH:MM:SS</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n\t\n\t- [注意] 原则上不要使用字符串类型存储日期/时间数据！\n\n## 数据库索引优化\n### 索引的数理基础\n#### B-Tree & B+Tree\n##### 引入背景\n- 区别于动态查找算法，它们都是在内存中进行的，适用于小规模文件查找。B-Tree/B+Tree 则适用于磁盘等直接存取的设备上组织动态查找。\n- B-Tree/B+Tree 多应用于数据库索引中，而数据库索引是存储在磁盘的索引文件上的。\n\t- 当数据量较大时，整个索引无法全部加载至内存中，只能逐一加载每一个磁盘页（对应索引树的节点）。\n\t- 换句话说，数据库索引利用磁盘预读原理，把一个 B-Tree/B+Tree 节点大小刚好设为一个页的大小，这样一个树结点只需一次 I/O 即可完成加载。为此，检索目标一次最多需要访问 h 个结点（h 次 I/O 操作）。\n\t\n\t> 对于 B-Tree/B+Tree 的数据结构来说，树的高度可代表 I/O 次数，而 “矮胖” 就是 B-Tree/B+Tree 的阶，阶的大小取决于磁盘页的大小。\n\n\t{%centerquote%}\n\t![](/images/CS/MySQL-Architect/MySQL-Architecture-BTree-B+Tree.svg) B 树与 B+树\n\t{%endcenterquote%}\n\n##### 参考资料\n- [维基百科. B+树. zh.wikipedia.org]()\n- [Nullzx. B 树和 B+ 树的插入删除图文详解. cnblogs.com](https://www.cnblogs.com/nullzx/p/8729425.html)\n- [CodingLabs. MySQL索引背后的数据结构及算法原理. CodingLabs.org](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)\n\n##### B-Tree\n- B-Tree（Balanced Tree），一种 `平衡` 的多路查找树，它或是一棵空树，或满足下列特性的 m 叉树（$m \\geq 3$）：\n\t- 树中每个结点至多有 m 棵子树；\n\t- 树中非叶子结点至少有两棵子树；\n\t- 除根结点与叶子结点外，至少有 $\\lceil m/2 \\rceil$ 棵子树；\n\t- 每个结点的关键字个数 = $\\{ n \\, | \\, \\lceil m/2 \\rceil \\leq n \\leq m-1 \\}$；\n\n\t\t> 1) 根结点至少可以有一个关键字，即关键字个数 = $\\{ n \\, | \\, 1 \\leq n \\leq m-1 \\}$。  \n\t\t> 2) 当结点的关键字数量大于等于 m-1 时，则触发结点分裂过程，以结点中间的关键字为中心分裂成左右两部分。\n\n\t- 每个结点中的关键字都按照从小到大排序，每个结点的关键字的左子树中所有关键字都小于它，而右子树中所有关键字都大于它。\n\t- 所有叶子结点都位于同一层，或者说根到每个叶子结点的长度都相同。\n\n\t\t> 在实际应用中，B-Tree 的阶数 m 通常很大（$m \\geq 100$），即使存储大量数据 B-Tree 高度仍然很小。\n\n##### B+Tree\n- B+Tree 是 B-Tree 的一种变形形式，一棵 m 阶的 B+Tree 定义如下： \n  \n  - 树中每个结点至多有 m 棵子树；\n  - 若根结点而非叶子结点，则至少有两棵子树；\n  - 除根结点与叶子结点外，至少有 $\\lceil m/2 \\rceil$ 棵子树；\n\t- 每个结点的关键字个数比它的孩子结点个数少 1；\n  \n\t\t> 各种资料上对于 B+Tree 结点的关键字个数定义不同，这里取 Wikipedia 的定义（也可以同步 B-Tree 的关键字个数定义）。\n  \n  - 所有叶子结点包含了全部关键字及相应记录的存储地址，按照从小到大的顺序排序，并存放在同一层的叶子节点中，而且叶子节点以指针进行链接。\n  - 所有 `非叶子结点` 仅起到 `索引作用`，即结点中的每一个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。\n\n##### 两者比较\n- 对于 `范围查找` 来说，B+Tree 只需 `遍历叶子节点链表` 即可，B-Tree 却需要重复地 `中序遍历整棵树`。\n- B+Tree 只有叶子结点存储数据，非叶子结点只起到索引作用；B-Tree 的所有结点都存储数据。\n\n#### 索引的数据结构\n- B-Tree (平衡树, Balance Tree)：也称为 `多路平衡查找树`，并且所有叶子节点位于同一层。\n- B+Tree：\n\t- 它不仅具有 B-Tree 的平衡性，并且可通过 `顺序访问指针` 来提高 `区间查询` 的性能。\n\t- 在 B+Tree 中，一个节点中的 key 从左到右非递减排列，若某个指针的 $key_i$ 左右相邻分别是 $key_{i-1}$ 和 $key_{i+1}$，且不为 null，则该指针指向节点的所有 key 满足 $key_{i-1} \\leq key_i \\leq key_{i+1}$。\n\t- B+Tree 与 B-Tree 最大区别是，B+Tree 的非叶子结点不保存数据，只用于索引，所有数据都保存在叶子结点中。而且叶子结点间按照从小到大顺序链接起来。如图 3-1 (b) 所示的为一棵 B+Tree。\n\n\t{%centerquote%}\n\t![](/images/CS/MySQL-Architect/MySQL-Architecture-BTree-B+Tree.svg) B 树与 B+树\n\t{%endcenterquote%}\n\n- B-Tree/B+Tree 的增删改查：\n  - `查找操作`：首先在`根节点`进行 `二分查找`，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在 `叶子节点` 上进行 `二分查找`，找出 key 所对应的 data。\n\n    > 二分查找要求表有序，正好 B-Tree 和 B+Tree 结点中的 key 从左到右非递减有序排列。\n\n  - `增删操作`：会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。\n\n#### 红黑树方案考量\n同样是平衡树，红黑树（自平衡的二叉树）也可以用来实现索引。但在文件系统及数据库系统中，普遍采用 B+Tree 作为索引结构，主要有以下两个原因：\n\n- `更少的查找次数`：平衡树查找操作的时间复杂度和树高 $h$ 相关，$O(h)=O(log_dN)$，其中 d 为每个节点的出度，即 `d叉树的阶`。红黑树的出度 d 为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大，查找的次数也就大。\n\n- `利用磁盘预读特性`：\n\t\n\t> 存储器原理解释推荐阅读：[小土刀. 读薄CSAPP-内存与缓存. wdxtub.com](https://wdxtub.com/csapp/thin-csapp-3/2016/04/16/#概念学习)\n\t\n\t- 索引本身也很大，不可能全部存储在内存中，为此索引往往以索引文件的形式存储的磁盘上。索引查找过程中就要产生磁盘I/O消耗，即索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。\n\t- 为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会 `预读`。\n\t- 预读过程中，即使只需一个字节，磁盘也是从这个位置开始，向后 `顺序读取` 一定长度的数据放入内存 (预读的长度一般为页的整倍数)。\n\n\t\t> 顺序读取不需要进行 `磁盘寻道`，只需要很短的磁盘旋转时间。\n\n\t- 操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。\n\n\t\t> 页是计算机管理存储器的逻辑块。\n\n\t- 数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。这样一来，最多花费 h 次 I/O 操作即可检索到目标。\n\n#### 索引的存取原理\n- 磁盘存取原理\n- 局部性原理与磁盘预读\n\n### MySQL 索引\n- 索引，在 MySQL 也称为键（Key），是 `存储引擎` 快速找到记录的一种 `数据结构`。相当于图书的目录，可根据目录中的页码快速找到所需的内容。\n- 索引，是 `存储引擎层` 的概念，所以不同存储引擎具有不同的索引类型和实现。下文主要以 MyISAM 和 InnoDB 两个存储引擎的索引实现方式展开讨论。\n\n####  索引结构类型\n##### B+Tree 索引\n- B+Tree 索引是大多数 MySQL 存储引擎的默认索引类型。\n- InnoDB 的 B+Tree 索引分为 `主索引`（Primary key）和 `辅助索引`（Secondary key）。而且 InnoDB 的主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为 `聚簇索引`。\n\n\t> MyISAM 的索引方式也叫做 `非聚集` 的。MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。\n\n- 因为 B+ Tree 的 `有序性`，因此可用于 `部分查找`、`范围查找`、`排序` 和 `分组`。\n- 适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。若不是按照索引列的顺序进行查找，则无法使用索引。\n\n##### Hash 索引\n- Hash 索引能以 O(1) 时间进行查找，但是失去了有序性。因此无法用于排序与分组，无法用于部分查找和范围查找，只支持 `精确查找`。\n\n\t> Hash 索引仅满足 `=`，`IN` 和 `<=>` 查询，不能使用范围查询。因为 Hash 索引比较的是 Hash 运算后的 Hash 值，所以它只能用于等值的过滤。\n\n- InnoDB 存储引擎有一个特殊的功能叫 `自适应哈希索引`，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。\n\n##### 全文索引\n- MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。\n- 查找条件使用 `MATCH AGAINST`，而不是普通的 `WHERE`。\n- 全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。\n- InnoDB 存储引擎在 `MySQL 5.6.4` 版本中也开始支持全文索引。\n\n##### 空间数据索引\n- MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。\n- 必须使用 GIS 相关的函数来维护数据。\n\n#### MyISAM 索引实现\n- MyISAM 引擎可使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址\n- MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。如图所示，为 MyISAM 的 B+Tree 主索引结构：\n\n\t{%centerquote%}\n\t![](/images/CS/MySQL-Architect/MySQL-Architecture-MyISAM-MainIndex.svg) MyISAM 的 B+Tree 主索引结构\n\t{%endcenterquote%}\n\n\t> 这里假设表一共有三列，以 Col1 为主键，则上图是一个主索引示意图。\n\n- 在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复，比如在 Col2 上建立一个辅助索引，如图所示：\n\n\t{%centerquote%}\n\t![](/images/CS/MySQL-Architect/MySQL-Architecture-MyISAM-SecondaryIndex.svg) MyISAM 的 B+Tree 辅助索引结构\n\t{%endcenterquote%}\n\n- MyISAM 的索引检索方法是按照 B+Tree 搜索算法实现的，若指定的 key 存在，则取出其 data 域的值，然后以 data 域的值为地址，再以地址读取相应数据记录。\n\n#### InnoDB 索引实现\n- InnoDB 引擎也可使用 B+Tree 作为索引结构，在 InnoDB 中数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点 data 域保存了完整的数据记录。\n- InnoDB 的 B+Tree 主索引结构：索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引结构的。\n\t- 因 InnoDB 的数据文件本身要按主键聚集的，为此 InnoDB 要求表必须有主键。\n\t- 若没有显式指定，则 MySQL 会自动选择一个可以唯一标识数据记录的列作为主键。\n\t- 若不存在这种列，则 MySQL 会自动生成一个隐含字段作为主键（字段长度为 6 个字节，类型为长整型）。\n\n\t{%centerquote%}\n\t![](/images/CS/MySQL-Architect/MySQL-Architecture-InnoDB-MainIndex.svg) InnoDB 的 B+Tree 主索引结构\n\t{%endcenterquote%}\n\n- InnoDB 的 B+Tree 辅助索引结构：索引 data 域存储相应记录主键的值而不是地址。换句话说，InnoDB 的所有辅助索引都引用主键作为 data 域。如图所示在 Col3 上的一个辅助索引：\n\n\t> 使用辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。\n\n\t{%centerquote%}\n\t![](/images/CS/MySQL-Architect/MySQL-Architecture-InnoDB-SecondaryIndex.svg) InnoDB 的 B+Tree 辅助索引结构\n\t{%endcenterquote%}\n\n### 索引的优点缺点\n#### 优点\n- 大大减少了服务器需要扫描的数据行数。\n- 避免服务器进行排序和分组操作，以避免创建 `临时表`。\n\n\t> B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表。\n\t\n- 将 `随机 I/O` 变为 `顺序 I/O`。\n\n\t> B+Tree 索引是有序的，会将相邻的数据都存储在一起。\n\n#### 缺点  \n- 索引并不是越多越好，索引固然可以提高相应的 SELECT 的效率，但同时也降低了 INSERT 及 UPDATE 的效率，因为 INSERT 或 UPDATE 时有可能会 `重建索引`。\n\n### 索引的设计原则\n\n> 从索引的优、缺点考虑索引的设计原则。\n\n- `忌过度索引`：索引需要额外的磁盘空间，而且会降低写操作的性能。\n\t- 在修改表内容时，索引会进行更新甚至重构，索引列越多花销时间越长。为此优化检索性能，只保持需要的索引即可。\n\t- 经常用在 `排列`、`分组` 和 `范围搜索` 的列适合创建索引，因为索引是有序的。\n\t- 经常出现在 `WHERE` 子句的列，或是 `JOIN` 连接子句中指定的列适合创建索引。\n- `使用短索引`：若对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间。\n\n### 索引的优化策略\n- `独立的列`：在进行查询时，索引列不能是 `表达式` 的一部分，也不能是 `函数参数`，否则无法使用索引。例如下面的查询不能使用 actor\\_id 列的索引：\n\n\t```SQL\n\tSELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;\n\t```\n\n- `多列索引`：在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor\\_id 和 film\\_id 设置为多列索引。\n\n\t```SQL\n\tSELECT film_id, actor_id FROM sakila.film_actor\n\tWHERE actor_id = 1 AND film_id = 1;\n\t```\n\n- `索引列的顺序`：让选择性最强的索引列放在前面。\n\n\t> 索引的选择性：不重复的索引值和记录总数的比值最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。\n\n\t例如，从下面显示的结果中可知，customer\\_id 的选择性比 staff\\_id 更高，因此最好把 customer_id 列放在多列索引的前面。\n\n\t```sql\n\tSELECT \n\t\tCOUNT(DISTINCT staff_id)/COUNT(*) AS StaffId,\n\t\tCOUNT(DISTINCT customer_id)/COUNT(*)  AS CustomerId,\n\t\tCOUNT(*)\n\tFROM payment;\n\t\t\n\t-- StaffId: 0.0001\n\t-- CustomerId: 0.0373\n\t-- COUNT(*): 16049\n\t```\n\n- `前缀索引`：对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。前缀长度的选取需要根据索引选择性来确定。\n- `覆盖索引`：索引包含所有需要查询的字段的值。具有以下优点：\n\t- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。\n\t- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。\n\t- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。\n\n### 索引的使用场景\n- 对于 `非常小的表`：大部分情况下简单的 `全表扫描` 比建立索引更高效；\n- 对于 `中大型的表`：`建立索引` 非常有效；\n- 对于 `特大型的表`：建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配。例如可以使用 `分区技术`。\n\n### 创建与删除索引\n- 创建表时：\n\n\t```sql\n\tCREATE TABLE 表名 (\n\t\t字段名1 数据类型 [完整性约束条件…],\n\t\t字段名2 数据类型 [完整性约束条件…],\n\t\t[UNIQUE | FULLTEXT | SPATIAL] INDEX | KEY\n\t\t[索引名] (字段名[(长度)] [ASC | DESC])\n\t);\n\t```\n\n- CREATE 在已存在的表上创建索引：\n\n\t```sql\n\tCREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX 索引名 \n\tON 表名 (字段名[(长度)] [ASC | DESC]) ;\n\t```\n\n- ALTER TABLE 在已存在的表上创建索引：\n\n\t```sql\n\tALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL] INDEX\n\t索引名 (字段名[(长度)] [ASC | DESC]) ;\n\t```\n\n- 删除索引：\n\n\t```sql\n\tDROP INDEX 索引名 ON 表名字;\n\t```\n\n## SQL 大查询优化\n### 使用 EXPLAIN 分析性能\n- 使用 EXPLAIN 关键字可以模拟执行 SQL 查询语句，从而知道 MySQL 是如何处理 SQL语句的，分析查询语句可知道查询语句的性能瓶颈。\n\t\n\t```sql\n\tEXPLAIN SELECT * FROM mytable\n\t```\n\n- 通过 EXPLAIN 可以分析出以下结果：\n\t- 表的读取顺序\n\t- 数据读取操作的操作类型\n\t- 哪些索引可以使用\n\t- 哪些索引被实际使用\n\t- 表之间的引用\n\t- 每张表有多少行被优化器查询\n\n\n- 执行计划中较重要字段含义 ( 详细可参考另一篇文章 [MySQL 查询优化之 Explain](https://m.jb51.net/article/38357.htm) )：\n\t- select_type : 查询类型，有简单查询、联合查询、子查询等\n\t- key : 使用的索引类型\n\t- rows : 扫描的行数\n\n### 优化数据访问\n- `减少请求的数据量`：\n\t- 只返回必要的列：最好不要使用 `SELECT *` 语句。\n\t- 只返回必要的行：使用 `LIMIT` 语句来限制返回的数据。\n\t- 缓存重复查询数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。\n\n- `减少服务器端扫描的行数`：最有效的方式是使用索引来覆盖查询。\n\n### 重构查询方式\n#### 切分大查询\n- 一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小而重要的查询任务。\n\n\t```sql\n\t# 大查询 SQL：删除历史数据的任务\n\t# Delete from messages Where created_time < DATE_SUB(NOW(), INTERVAL 3 MONTH);\n\t```\n\n- 解决方案：\n\n\t```sql \n\t# 1）一次删除一万行一般来说是一个比较高效而且对服务器影响也最小的方案\n\t# 2）执行一次删除任务建议暂停一会再执行任务，还可以大大减少删除时锁的持有时间。\n\trows_affected = 0\n\tdo {\n\t\trows_affected = do_query(\n\t\t\t\"Delete from Messages created_time < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000\"\n\t\t)\n\t} while rows_affected > 0\n\t```\n\n#### 分解大连接\n- 将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：\n\t- 减少锁的竞争\n\t- 缓存效率更高\n\n\t\t> 对于连接查询，若其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然不影响使用。\n\t\t\n\t- 减少冗余记录的查询：单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。\n\t- 高性能和可拓展查询：在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可拓展。\n\n\t\t> 例如，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机连接要更高效。\n\t\t\n\t\t```sql\n\t\t# 大连接查询示例\n\t\tSELECT * FROM tag\n\t\t\tINNER JOIN tag_post ON tag_post.tag_id = tag.id\n\t\t\tINNER JOIN post ON tag_post.post_id = post.id\n\t\tWHERE tag.tag = 'mysql';\n\t\t\n\t\t# 分解大连接\n\t\tSELECT * FROM tag WHERE tag = 'mysql';\n\t\tSELECT * FROM tag_post WHERE tag_id = 1234;\n\t\tSELECT * FROM post WHERE post.id IN (123, 456, 567, 9098, 8904);\n\t\t```\n\t\t\n#### 巧用临时表\n- 临时表：顾名思义，临时表只是在当前连接可见，当关闭连接时，MySQL 会自动删除临时表并释放存储空间。\n\n\t```sql\n\t# 创建临时表：表结构与数据存放于内存\n\tCreate Temporary Table tmp_user (\n\t\tusername VARCHAR(16) NOT NULL\n\t\tage int(3) NULL\n\t\tuser_status char(2) NOT NULL DEFAULT '1'\n\t) ENGINE = MyISAM DEFAULT CHARSET=utf8;\n\tinsert into tmp_user values('Kofe', 26, 1);\n\t\n\t# 创建内存表：表结构存放于磁盘上，数据存放于内存\n\tCreate Temporary Table tmp_user (\n\t\tSelect * from t_user\n\t) TYPE ＝ HEAP ENGINE=MEMORY DEFAULT CHARSET=utf8；\n\t\n\t# 查询直接创建临时表\n\tCreate Temporary Table tmp_user (\n\t\tSelect * from t_user\n\t)；\n\t\n\t# 删除临时表\n\tDROP TABLE tmp_user;\n\t```\n\t\n- 使用场景：大查询或者关联查询频繁关联一些中间大结果集的子集，使用临时表可提高此类场景的查询效率。\n\n## 高可用架构设计\n### 切分\n#### 参考资料\n- [美团技术团队. 大众点评订单系统分库分表实践 [OL]. tech.meituan.com](https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html)\n- [CrossoverJie. 一次难得的分库分表实践 [OL]. crossoverjie.top](https://crossoverjie.top/2019/07/24/framework-design/sharding-db-03/)\n- [Doocs. 面试题:为什么要分库分表 [OL]. github.com](https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/database-shard.md)\n\n#### 水平切分\n- 水平切分：将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，水平切分是必然选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。\n\n\t{%centerquote%}\n\t![](/images/CS/MySQL-Architect/MySQL-Architecture-Sharding-Horizontal.svg) 水平切分\n\t{%endcenterquote%}\n\n- 切分方式\n\t- Range：根据一定范围进行分发。比如：根据时间范围，一个月内的数据存储为一张表，或者根据用户 ID 这种自增序列，用户 ID 在 000001 至 100000 范围的存一张表、100001 至200000 范围的存一张表等。\n\t\t- 优势是数据扩容时方便。\n\t\t- 不足是容易产生数据热点问题。\n\t- Hash：通过一次哈希运算然后取余（分表数量-1）的方式确定数据要存的表位置。\n\t\t\n\t\t> 比如：根据用户姓名进行 Hash 分发。用户姓名小明，计算 hashcode，得到754703，预先确定分表数量为 8，再取余 7 得到 3，即分发到索引为 3 表位置上。\n\t\t\n\t\t- 优势是数据分发均匀，不会产生数据热点问题。\n\t\t- 不足是扩容时候非常不方便，还需要重新计算数据的哈希值。\n\n#### 垂直切分\n- 垂直切分：将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分。\n\t- 利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中，让数据库可以以更少字段缓存更多的行，进而带来性能的提升。\n\t- 数据库的三大范式设计其实也是一种垂直切分。\n- 在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中。\n\n\t{%centerquote%}\n\t![](/images/CS/MySQL-Architect/MySQL-Architecture-Sharding-Vertical.svg) 垂直切分\n\t{%endcenterquote%}\n\n#### 分表分库中间件\n> 不同的分库分表（包括水平以及垂直切分）中间件都有什么优点和缺点？\n\n- Mycat：基于 java 语言编写的数据库中间件，是一个实现了 MySQL 协议的服务器。\n\t- 基于 Cobar 改造的、同属于 proxy 层方案。\n\t- 前端用户可以把它看作是一个数据库代理，用 MySQL 客户端工具和命令行访问。\n\t- 后端使用 MySQL 原生协议与多个 MySQL 服务器通信，也可以用 JDBC 协议与大多数主流数据库服务器通信，其核心功能是分库分表。配合数据库的主从模式还可实现读写分离。\n- Sharding-jdbc：属于 ShardingSphere 的 client 层方案。ShardingSphere 还提供 proxy 层的方案 Sharding-Proxy。因为 SQL 语法支持也比较多，没有太多限制，支持分库分表、读写分离、分布式 ID 生成、柔性事务（最大努力送达型事务、TCC 事务等）。\n\n### 复制\n#### 主从复制\n- 主从复制：主要涉及三个线程\n\t- Binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。\n\n\t\t> 二进制日志：记录了所有对 MySQL 数据库修改，不限于数据增删改查、表结构修改等事件。\n\n\t- I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。\n\t- SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。\n\n- 二进制日志格式：比如同一 SQL 修改 1000 条数据\n\t- 基于行 `binlog_format = ROW`，日志记录 1000 条执行语句。\n\t- 基于段 `binlog_format = STATEMENT`，日志只记录该 SQL 语句。\n\t- 混合日志格式 `binlog_format = MIXED`，由系统决定是基于端还是基于行方式记录日志。\n\n#### 读写分离\n- 主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。\n- 读写分离能提高性能的原因在于：\n\t- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；\n\t- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；\n\t- 增加冗余，提高可用性。\n\t- 读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。","tags":["数据库","MySQL","架构","索引"],"categories":["Project"]},{"title":"大型网站技术架构","url":"/2022/02/mega-web-site-architecture.html","content":"\n相较于现阶段微服务、网格服务以及无服务等架构，本书介绍的架构模式略显朴素，但是模式本质上是一种思想模式、一种抽象化解决方案，面对系统不同发展阶段以及不同使用场景，每种技术架构都有它的落地场景与参考价值。以演变思维模式看待技术架构的迭代升级，深刻理解高性能、可用性、伸缩性、拓展性、安全性架构特性的核心原理，让我们能够站在较高角度俯瞰全局、权衡利弊、选择取舍，并以全生命周期思维方式设计、开发、部署、运维大型网站系统。\n\n<!-- More -->\n\n## 本书框架\n- 第一篇章：演化、模式、要素三维度，以描述网站整体架构\n- 第二篇章：高性能、可用性、伸缩性、拓展性、安全性五要素，详细介绍网站架构的核心原理\n\n\t> 其中负载均衡、异步处理、分布式缓存等技术方案分章节进行详细描述。\n\n- 第三篇章：具体案例讲解网站技术架构\n- 第四篇章：以架构师角度复盘技术架构\n\n## 第1篇 概述\n### 01 大型网站架构演化\n\n#### 网站架构演化发展历程\n- 初始阶段的网站架构：应用程序、数据库、文件等所有资源都集中于一台服务器上。\n\t\n- 应用与数据服务分离：\n\t- 应用和数据分离后，整个网站使用三种服务器，即 `应用服务器`、`文件服务器` 和 `数据库服务器`。\n\t- 三种服务器对硬件资源的要求不同：\n\t\t- 应用服务器：处理大量业务逻辑，偏向于 CPU 算力。\n\t\t- 数据库服务器：磁盘检索和数据缓存，偏向于硬盘读写能力和内存容量。\n\n\t\t\t> 存在问题：随着用户逐渐增多，数据库读写瓶颈导致访问延迟，从而拖垮整个网站性能。\n\n\t\t- 文件服务器：存储大量用户上传的文件，偏向于硬盘容量。\n\n- 缓存改善网站的性能：\n\t- 二八定律：80% 的业务集中在 20% 的数据上。将业务访问集中的小部分数据缓存在内存中，可减少数据库的访问压力。\n\t- 缓存类型\n\t\t- 缓存于应用服务器的 `本地缓存`\n\t\t- 缓存于分布式缓存服务器的 `远程缓存`\n\t\n\t\t> 存在问题：使用缓存使得数据访问压力问题得到有效缓解，但单一应用服务器能够处理的请求连接数有限，应用服务器成为整个的瓶颈。\n\n- 应用服务器集群改善网站的并发处理能力\n\t\n\t- 负载均衡：将用户请求分发到应用服务器集群中任何一台服务器上。若有更多用户加入，在集群中通过增加应用服务器即可（系统可伸缩性）。\n\t\n- 数据库读写分离\n\t- 存在问题：当网站使用缓存后，使得绝大部分数据读操作可不通过数据库即可完成访问，但仍有部分读操作（缓存访问不命中、缓存过期）和写操作需访问数据库，同样会因数据库负载压力过高成为网站瓶颈。\n\t- 解决方案\n\t\t- 数据库的 `主从热备份` 得以实现数据库读写分离功能。当应用服务器写数据时，访问主数据库；\n\t\t- 主数据库通过 `主从复制机` 机制将数据更新同步至从数据库。当应用服务器读数据时，访问从数据库即可获得数据。\n\n- 反向代理和 CDN 加速网站响应：它们的基本原理都是 `缓存`，区别在于：\n\t- `CDN`：部署在网络提供商的机房，用户在请求服务时，可从距离最近的网络提供商机房获取数据。\n\t- `反向代理`：部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器是反向代理服务器。若反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。\n\n- 分布式文件系统和分布式数据库系统\n\t\n\t- 分布式数据库：在单表规模非常庞大时使用，通常数据库拆分手段是 `业务分库`，将不同业务的数据库部署于不同物理服务器上。\n\t\n- NoSQL 和搜索引擎\n\t- 非关系型数据库技术，比如 NoSQL\n\t- 非数据查询技术，比如搜索引擎\n\n- 业务拆分\n\t- `分而治之` 的指导思想，将完整网站业务分成不同的产品线，以产品线开发应用，各位单独部署及维护。\n\t- 应用之间可通过消息队列进行数据分发，通过访问同一个数据存储系统来构成一个关联的完整系统。\n\n- 分布式服务：每个应用系统都需执行许多相同的业务操作，比如用户管理、商品管理等，将相同公用的业务抽象成可复用的业务、独立部署。\n\n\t{%centerquote%}\n\t![](/images/CS/Website-Tech-Framework/distributed-server.svg) 分布式服务架构图\n\t{%endcenterquote%}\n\n#### 网站架构演化的价值观\n- 核心价值：随网站所需要灵活应对\n- 驱动发展：技术发展源于业务发展\n\n#### 网站架构设计误区\n\n- 一味追随大公司的解决方案\n- 为了技术而技术\n- 企图用技术解决所有问题：技术解决业务问题，业务问题还需业务手段解决。\n\n### 02 大型网站架构模式\n- 模式：来自建筑学的定义，模式描述了一个在我们周围不断重复发生的问题及该问题解决方案的核心，当遇到适用场景复用该方案即可。\n- 为解决大型网站面临的 `高并发访问`、`海量数据处理`、`高可靠运行` 等问题与挑战，大型互联网公司在实践中提出了许多解决方案，以实现网站 `高性能`、`高可用`、`易伸缩`、`可拓展`、`安全` 等各种技术架构目标。\n\n#### 分层\n- 在横向维度将系统切分成几个部分，每个部分负责一部分相较单一的职责，然后通过上下层的依赖和调用组成一个完整系统。\n- 分层可更好地将一个庞大软件系统切分为不同的部分，便于分工合作开发和维护；各层之间具有一定的独立性，只要维持调用接口不变，各层可根据具体问题独立演化发展，其他层不需要做出相应调整。\n\n\t> [例如] 计算机硬件、操作系统、应用软件分层结构；网络的七层协议；网站软件系统抽象为应用层、服务层、数据层，具体如下表所示。\n\n\t<table>\n\t\t<thead>\n\t\t\t<th>层级</th>\n\t\t\t<th>功能</th>\n\t\t\t<th>举例</th>\n\t\t</thead>\n\t\t<tbody>\n\t\t<tr>\n\t\t\t<td>应用层</td>\n\t\t\t<td>负责具体业务和视图展示</td>\n\t\t\t<td>网站首页、内容检索、数据统计等</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>服务层</td>\n\t\t\t<td>为应用层提供服务支持</td>\n\t\t\t<td>用户管理服务、购物车服务等</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>数据层</td>\n\t\t\t<td>提供数据存储访问服务</td>\n\t\t\t<td>数据库、缓存、文件、搜索引擎等</td>\n\t\t</tr>\n\t\t</tbody>\n\t</table>\n\n- 挑战：合理规划层次边界和接口，开发中必须严格遵循分层架构约束，禁止跨层次调用（应用层直接调用数据层）或是逆向调用（数据层调用服务层等）。\n- 实践\n\t- 大的分层结构可细化继续分层，比如应用层细分为视图层和业务逻辑层（前端和后端）。\n\t- 分层架构是逻辑层面的，实际上是可以部署于同一台物理机器上。但随着网站业务发展，必须对已分层模块分离部署，即三层结构分别部署在不同服务器上，使得网站拥有更多计算资源以应对越来越多的用户访问。\n\n#### 分割\n- `分层` 是将软件在 `横向` 方面进行切分；`分割` 就是在 `纵向` 方面对软件进行切分。\n- 将网站不同的 `功能` 和 `服务` 分割开来，包装成高内聚低耦合的模块单元，有助于：\n\t- 软件开发和维护；\n\t- 不同模块分布式部署，提高网站并发处理能力以及功能拓展能力。\n\n#### 分布式\n- 分层、分割的主要目的之一是让切分后的模块便于 `分布式部署`。\n- 分布式意味着可以使用更多计算机硬件资源完成同样的功能，即处理并发访问量和承载数据量更大，进而为更多用户提供服务。\n- 分布式解决高并发问题，同时也存在其他问题：\n\t- 服务调用必须通过网络，网络会成为性能瓶颈口；\n\t- 服务器越多，服务器宕机概率越大，部分服务器宕机造成的服务不可用可能会导致很多应用不可用；\n\t- 数据在分布式环境中保持数据一致性非常困难，同样分布式事务也难以保证。\n- 在网站应用中，常用的分布式方案：\n\t- `分布式应用和服务`：将分层 / 分割后的应用和服务的模块分布式部署。\n\t- `分布式数据和存储`：除了传统关系型数据库外，为分布式网站应用而生的各种非关系型数据库，比 如 NoSQL。\n\t- `分布式静态资源`\n\t\t\n\t\t- 动静分离，静态资源（HTML、JS、CSS）分布式部署可减轻应用服务器的负载压力；\n\t\t- 通过独立域名访问加快浏览器并发加载的速度；\n\t\t- 可由独立前端团队负责界面开发、用户体验维护。\n\t- `分布式计算`：严格意义上，应用、服务、事实数据处理都是计算，网站除了在线业务要处理，还有后台业务也要处理，比如搜索引擎索引构建、数据仓库的数据分析统计等。\n\t\n\t\t> 目前网站普遍使用 Hadoop 及其 MapReduce 分布式计算框架进行批处理计算，其特定是移动计算（非移动数据），即将计算程序分发至数据所处位置，以实现加速计算、分布式计算。\n\n#### 集群\n- 多台服务器部署相同应用以构成一个集群，通过负载均衡设备（比如 F5）共同对外提供服务。\n\n\t> 对于用户访问集中的模块（网站首页等），还需要集群以提供更好的并发特性。\n\n- 由于一个应用由多台服务器提供服务，当某台服务器发生故障时，`负载均衡设备` 或 `系统实效转移机制` 会将请求转发到集群其他服务器上，使得服务器故障不影响用户正常使用，提高 `系统可用性`。\n\n#### 缓存\n- `缓存`：将数据存放在距离计算最近的位置以加快处理速度。\n- `CDN`：内容分发网络，部署于距离终端用户最近的网络服务商，用户网络请求总是先达到他的网络服务商。此处会缓存网站的静态资源（较少变化的数据），可就近以最快速度返回给用户。\n- `反向代理`：属于网站前端架构一部分，当用户请求到达网站数据中心时，最先访问的是反向代理服务器。此处缓存网站的静态资源，无需将请求继续转发应用服务器就能返回给用户。\n- `本地缓存`：在应用服务器本地缓存数据，应用程序可在本机内存中直接访问数据，而无需访问数据库。\n- `分布式缓存`：数据缓存于分布式缓存集群，应用程序通过网络通信访问缓存数据。\n- 使用缓存需满足以下前提条件：\n\t- 数据访问热点不均衡，某些数据会被频繁访问；\n\t- 数据在某时间段内有效，不会短时间过期，否则缓存的数据会因失效而产生脏读，影响结果正确性。\n\n#### 异步\n- 异步是系统解耦合的重要手段，业务间的消息传递不是同步调用，而是将一个业务操作分成多个阶段，每阶段之间通过共享数据方式异步执行、进行协作。\n- 单一服务器，内部通过 `多线程共享内存队列` 实现异步；分布式系统，多个服务器集群通过 `分布式消息队列` 实现异步。\n- 异步架构是典型的 `生产者-消费者` 模式，两者不存在直接调用，只需保持数据结构不变，彼此功能实现可随意变化而不相互影响。使用异步消息队列拥有以下特性：\n\n\t> 生产者：把数据放到消息队列；消费者：从消息队列里边取数据\n\n\t- 提高系统可用性：消费者服务器故障宕机，数据会在消息队列服务器中存储堆积，生产者服务器可继续处理业务请求。\n\t- 消除并发访问高峰：生产者服务器将突然增加的访问请求数据放入消息队列，等待消费者服务器依次，以缓解网站负载压力过大问题。\n\t- 加快网站响应速度\n\n#### 冗余\n- 服务器冗余运行、数据库冗余备份，当其中某台服务器宕机时，可将其实的服务和数据访问转移至其他机器上。\n\t- 冷备份：数据库定期备份，存档保存。\n\t- 热备份：数据库进行主从分离，实时同步实现热备份。\n\t- 部署灾备数据中心。\n\n#### 自动化\n- 发布过程自动化\n- 自动化代码管理：代码版本控制、代码分支创建/合并等过程自动化\n- 自动化测试：代码部署至测试环节，自启用测试用例进行测试\n- 自动化安全测试：代码静态安全扫描、部署到安全测试环节进行安全攻击测试\n- 自动化部署\n- 自动化监控：服务器心跳检测\n- 自动化报警：异常 / 阈值报警\n- 自动化失效转移：自动隔离失效服务器\n- 自动化失效恢复：重启服务，同步数据保证数据一致性。\n- 自动化降级\n- 自动化分配资源\n\n### 03 大型网站架构要素\n- 架构：通俗说法，高层次的规划，难以改变的决定。\n- 软件架构：有关软件整体结构与组件的抽象描述，用于指导大型软件系统各方面的设计。\n\n\t> 系统各个重要组成部分及其关系构成了系统的架构，这些组成部分可以是具体功能模块，也可以是非功能性设计于决策。它们之间相互关联组成一个整体，共同构成软件系统的架构。\n\n- 软件架构设计：除了满足当前系统功能需求之外，额外关注 `性能`、`可用性`、`伸缩性`、`拓展性` 和 `安全性` 的架构要素。\n\n#### 高性能\n- 代码层面：使用多线程、改善内存管理等手段优化性能。\n- 浏览器端\n\t- 通过浏览器缓存、使用页面压缩、合理布局页面、减少 Cookie 传输等手段改善性能。\n\t- 使用 CDN 将网站静态内容分发至距离用户最近的网络服务商机房，使得用户以最短访问路径获取数据。在网站机房部署反向代理服务器，缓存热点文件，加快请求响应速度，减轻应用服务器负载压力。\n- 应用服务器端\n\t- 缓存：使用服务器本地缓存和分布式缓存，通过缓存在内存中的数据处理用户请求，加快请求处理过程，减轻数据库负载压力。\n\t- 异步：通过异步操作将用户请求发送至消息队列等待后续任务处理，而当前请求直接返回响应给用户。\n\t- 集群：将多台应用服务器组成一个集群共同对外服务，提高整体处理能力。\n- 数据库服务器端\n\t- 关系型数据库：索引、缓存、SQL 优化。\n\t- 非关系型数据库：NoSQL 数据库通过优化数据模型、存储结构、伸缩性等手段提高性能。\n- 衡量网站性能有一系列指标，如响应时间、TPS、系统性能计数器等。通过监控这些指标，可以分析系统瓶颈、预测网站容量，并对异常指标进行报警，以保证系统可用性。\n\n#### 可用性\n- 高可用性的主要手段是冗余，应用程序部署于多台服务器上同时提供访问，数据存储在多台服务器上相互备份。\n- 对于应用服务器：多台应用服务器通过负载均衡设备组成一个集群共同对外提供服务，任何一台服务器宕机，只需把请求切换到其他服务器即可实现应用的高可用。\n- 对于存储服务器：实时备份数据。\n\n#### 伸缩性\n- 衡量网站架构伸缩性的主要标准：\n\t- 是否可以多台服务器构建集群；\n\t- 是否容易向集群中添加新的服务器；\n\t- 加入新服务器后是否可提供原来无差别的服务；\n\t- 集群中可容纳的总服务器数量是否有限制。\n- 对于应用服务器：服务器上不保存数据，所有服务器都是对等的（无状态），通过负载均衡设备向集群不断加入服务器。\n- 对于缓存服务器集群：加入新的服务器会导致缓存路由失效（虽然缓存数据可通过数据库重新加载），需改进缓存路由算法以保证缓存数据的可访问性，比如分布式缓存的一致性 Hash 算法。\n- 关系数据库的集群伸缩性必须在数据库之外实现，通过 `路由分区` 等将部署有多个数据库的服务器组成一个集群。\n\n#### 拓展性\n- 衡量网站架构拓展性的主要标准：\n\t- 是否可以对现有产品透明无影响，不需要任何改动或很少改动现有业务功能就可以上线新产品。\n\t- 不同产品之间强内聚、弱耦合。\n- 网站可拓展架构主要手段：`事件驱动架构` 和 `分布式服务`。\n\t- `事件驱动架构`：利用 `消息队列` 实现，将用户请求和其他业务事件构造成消息发布到消息队列，消息消费者从消息队列中获取消息并进行处理。分离消息产生和消息处理过程，可透明地增加新的消息生成者任务或新的消息消费者任务。\n\t- `分布式服务`：将业务和可复用服务分离开来，通过分布式服务框架调用。\n\n## 第2篇 架构\n### 04 网站高性能架构\n\n#### 网站性能测试\n\n##### 不同视角的网站性能\n\n- 用户：网站响应速度快慢，由用户计算机与服务器通信时间、网站服务器处理时间、用户浏览器构造请求、解析响应数据时间所决定。\n\n\t> 优化手段：前端架构优化、调整浏览器缓存策略、CDN 服务、反向代理等。\n\n- 开发人员：关注应用程序本身及其相关子系统的性能，包括响应延迟、系统吞吐量、并发处理能力、系统稳定性等指标。\n\n\t> 优化手段：缓存加速数据读取、使用集群提高吞吐、使用异步消息加快请求响应及 “削峰”。\n\n- 运维人员：关注基础设施和资源利用率，比如网络运营商带宽、服务器硬件配置、数据中心网络结构、服务器和网络贷款的资源利用率。\n\n\t> 优化手段：建设优化骨干网、利用虚拟化技术优化资源利用等。\n\n##### 性能测试指标\n- `性能测试指标`：不同人员视觉有不同的性能衡量指标，以开发与测试人员为例，网站性能测试的主要指标有响应时间、并发数、吞吐量、性能计数器。\n\n- `响应时间`：从发出请求开始，到最后响应数据所需要的时间。\n\t- 测试程序通过模拟应用程序，记录收到响应和发出请求之间的时间差来计算系统响应时间。\n\t- 若测试目标操作本身花费时间较少，则可以通过重复请求，通过求均值方式计算得单次请求的响应时间。\n\n- `并发数`：系统能够同时处理请求的数量。\n\t- 对于网站而言，并发数即网站并发用户数，指同时提交请求的用户数目。\n\t- 相对应的还有网站在线用户数和网站系统用户数（注册用户），其数量关系为：\n\n\t\t> 网站系统用户数 >> 网站在线用户数 >> 网站并发用户数\n\n\t- 网站产品设计初期需要规划不同发展阶段的网站系统用户数，根据产品特性和运营手段，推算在线用户数和并发用户数。\n\t- 通过多线程模拟并发用户，以测试系统的并发处理能力。为模拟真实用户行为，不仅仅是启用多线程不断发送请求，而是在请求之间加入一个随机等待时间（也称作 `思考时间`），以还原真实的高并发场景。\n\n- `吞吐量`：单位时间内系统处理的请求数量，体现系统的整体处理能力。\n\t- TPS（每秒事务数）；HPS（每秒 HTTP 请求数）；QPS（每秒查询数）\n\t- 系统并发数由小逐渐增大过程中，当中过程也伴随着服务器系统资源消耗逐渐增大，系统吞吐量逐渐增加，但达到一定极限值时随着并发数增长而下降，系统资源耗尽达到系统崩溃点，吞吐量为零。\n\n\t\t> 系统吞吐量、系统并发数和响应时间的关系可理解为：高速公路的通行情况，吞吐量表示每天通过收费站的车辆数（等价于高速费），正在行驶的车辆数记作并发数，响应时间记作车数。当行驶车辆少时，车数行驶较快，收取高速费相对较少；随着行驶车辆数增加，车速会变慢，但收到的高速费会逐渐增加；行驶车辆数增加超过某极限值后，任何偶然因素都会导致高速路瘫痪，车走不动、收费停滞（资源耗尽）。\n\n- `性能计数器`：描述服务器或者操作系统性能的数据指标，包括 System Load、对象与线程数、内存使用、CPU使用、磁盘与网络 I/O 等。对指标设定目标阈值，当监控系统发现性能计数器超过阈值时，就向运维及开发人员报送系统异常警报。\n\t\n\t- System Load：系统负载，当前正被 CPU 执行和等待 CPU 执行的进程数目总和，反映系统忙闲程度的指标。Load 值等于 CPU 核W数为理想值，表示系统资源被充分利用。\n\n##### 性能测试方法\n- 性能测试：以系统设计初期规划的性能指标为预期目标，对系统不断施压，验证系统再资源可接受范围内。\n- 负载测试：对系统不断增加并发请求，直到系统某项或者多项性能指标达到安全临界值。若某种资源已呈饱和状态，继续对系统施加压力，系统处理不但不提高反而下降。\n- 压力测试：超过安全负载的情况下，对系统不断施加压力直至系统崩溃或不能再处理任何请求，以测量得系统最大压力承受能力。\n- 稳定性测试：不同生产环境、不同时间点的请求压力是不均匀的、呈波浪特性的，为更好地模拟生产环境，稳定性测试过程中也应该不均匀地对系统施加压力。\n\n#### Web 前端性能优化\n##### 浏览器访问优化\n- 减少 HTTP 请求：每次 HTTP 请求都需建立通信链路进行数据传输，在服务端需要启动独立线程处理每个 HTTP 请求。减少 HTTP 请求，降低通信、服务器线程开销，可有效提高访问性能的有效手段。\n\n\t> 例如：合并 CSS、合并 JavaScript、合并图片等，即减少文件请求加载次数。\n\n- 使用浏览器缓存：\n\t- CSS、JavaScript、图标等静态资源文件的更新频率都较低，而他们几乎是每次 HTTP 请求都需要的，将文件缓存在浏览器中，可极好地改善性能。\n\n\t\t> 若静态资源文件变化需要及时生效、应用至客户端浏览器，可通过改变文件名实现。\n\n\t- 通过 HTTP Header 中的 Cache-Control 和 Expires 属性来设定浏览器缓存。\n\n- 启用压缩：在服务端启用 GZIP 对 HTML、CSS、JavaScript 文件进行压缩，有效减少通信传输的数据量。\n- CSS 前置、JavaScript 后加载：\n\t- 遵循浏览器自上而下的页面渲染机制，CSS 先行加载渲染页面；\n\t- JavaScript 在加载完成后即执行，有可能会造成阻塞而页面加载显示缓慢，一般后置。\n\n\t\t> 当然具体问题要具体分析，若页面解析需用到 JavaScript 时，代码后置就不合适了。\n\n##### CDN 加速\n- 内容分发网络（Content Distribute Network, CDN）\n\t- 网络访问第一跳，即数据缓存在距离用户最近的地方，得以最快速度获取数据。\n\t- CDN 部署在网络运营商机房，同时运营商又是终端用户的网络服务提供商，为此用户请求路由的第一跳即达到 CDN 服务器。\n\t- CDN 缓存了浏览器请求的资源时，CDN 直接返回给浏览器，实现最短路径返回响应。\n\n\t\t> CDN 缓存的一般是静态资源，比如图片、 CSS、JavaScript 脚本等。\n\n##### 负载均衡\n\n- 负载均衡：通过负载均衡构建的应用集群以提高系统总体处理能力、改善网站高并发性能。\n- 正向代理 v.s. 反向代理\n\t- 正向代理：客户端代理，隐藏的是客户。客户端为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。\n\t- 反向代理：服务端代理，隐藏的是服务器。以代理服务器来接受 Internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 Internet 上请求连接的客户端。\n\n\t\t{%centerquote%}\n\t\t![](/images/CS/Website-Tech-Framework/Hight-Performance-Forward&Reverse-Proxy.svg) 正向代理 v.s. 反向代理\n\t\t{%endcenterquote%}\n\n#### 应用服务器性能优化\n##### 分布式缓存\n\n- 网站性能优化第一定律：使用缓存（数据缓存、文件缓存、页面片段缓存）\n- 缓存的基本原理\n\t- 存储在访问速度相对较高的存储介质中。\n\t- 缓存的数据是经过计算处理得到的，被缓存的数据无需重复计算即可直接使用，例如统计类数据。\n\t- 缓存本质是一个哈希表（HashTable），以 Key-Value 形成存储在内存 Hash 表中。\n\t\t-  通过 HashCode(Key) 计算 Key 的 HashCode，即对象的唯一标识符。\n\t\t-  通过 HashCode 获得 HashTable 的索引下标，对 Hash 表数组长度求模（余数法），余数即为索引下标。\n\t\t-  通过索引下标在 Hash 表数组即可取得 Key-Value 键值对。\n\n\t\t{%centerquote%}\n\t\t![](/images/CS/Website-Tech-Framework/hashtable-sample.svg) HashTable 存储实例\n\t\t{%endcenterquote%}\n\n- 分布式缓存架构\n\t- 以集群方式提供缓存服务，架构方式有两种：\n\t\t- JBoss Cache：需要更新同步的分布式缓存\n\t\t- Memcached：不互相通信的分布式缓存\n\t- JBoss Cache 架构\n\t\t- JBoss Cache 通常将应用程序与缓存部署于同一台服务器上。\n\t\t- 在集群中所有服务器中保存相同的缓存数据。\n\t\t- 当某台服务器有缓存数据更新时，会通知集群中其他机器更新缓存数据或清除缓存数据。\n\n\t\t{%centerquote%}\n\t\t![](/images/CS/Website-Tech-Framework/JBoss-Cache.svg) JBoss Cache 之间的更新同步\n\t\t{%endcenterquote%}\n\n\t- Memcached 架构\n\t\t- 应用程序与缓存分离部署于不同服务器上。\n\t\t- 应用程序通过一致性 Hash 等路由算法选择缓存服务器远程访问缓存数据，缓存服务器之间不通信。\n\n\t\t{%centerquote%}\n\t\t![](/images/CS/Website-Tech-Framework/Memcached.svg) 互不通信的 Memcached\n\t\t{%endcenterquote%}\n\n- Memcached\n\t- 简单的通信协议\n\t\t- 通信协议：TCP 协议、UDP 协议\n\t\t- 通信序列化协议：基于文本的自定义协议，以一个命令关键字 + 一组命令操作数，例如读取数据的命令协议 `get <key>`。\n\n\t\t\t> 通信序列化协议：数据传输的两端必须使用彼此可识别的数据序列化方式才能使通信得以完成，比如 XML、JSON 等文本序列化协议、Google Protobuffer 等二进制序列化协议。\n\n\t- 丰富的客户端程序：C/C++、Java、Python、Perl、Ruby 等。\n\t- 高性能的网络通信：基于 [Libevent](https://baike.baidu.com/item/libevent/2492112?fr=aladdin) 的通信模块，支持事件触发的网络通信程序库。\n\n\t\t> Libevent：一个用 C 语言编写的、轻量级的开源高性能事件通知库。\n\n\t- 高效的内存管理：固定空间分配 ---- 内存管理 ----> 内存碎片管理\n\t\t- 将内存空间分为一组 Slab，其中又包含一组 Chunk。同一 Slab 的每个 Chunk 的大小是固定的，拥有相同大小 Chunk 的 Slab 被组织在一起，称为 Slab_class。\n\n\t\t\t{%centerquote%}\n\t\t\t![](/images/CS/Website-Tech-Framework/Memcached-memory-manager.svg) Memcached 内存管理\n\t\t\t{%endcenterquote%}\n\n\t\t- 存储数据根据数据大小，寻找一个最小 Chunk 将数据写入，且内存的分配与释放都以 Chunk 为单位。\n\n\t\t\t> 数据只能存入一个比它大的 Chunk，且一个 Chunk 只能存一个数据，造成其他内存空间被浪费了。\n\n\t\t- 采用 LRU 算法是否最近最久未被访问数据占用的空间，并标记释放的 Chunk 为未用。\n\n\t- 互不通信的服务器集群架构\n\n##### 异步操作\n- 使用 `消息队列` 将调用 `异步化`，改善网站的扩展性，也可提升网站系统的性能。 \n- 消息队列的 `削峰作用`：通过异步处理，将短时间高并发产生的事务消息存储再消息队列中，从而削平高峰期的并发事务。\n- 消息队列与业务异步处理注意事项\n\t- 存在问题：数据写入消息队列即返回用户，数据的业务校验、写数据操作可能失败。\n\t- 业务流程调整：订单数据写入消息队列，不能立即返回用户订单提交成功，需在消息队列的订单消费者进程真正处理完该订单，甚至业务出库后再通知订单成功，避免交易纠纷。\n\n##### 使用集群\n- 使用 `负载均衡` 技术为一个应用构建一个由多台服务器组成的服务器集群，将 `并发访问请求` 分发到多台服务器处理。\n\n##### 代码优化\n- 多线程：I/O 阻塞、多 CPU 利用、线程安全\n- 资源复用：减少系统资源的创建和销毁，比如数据库连接、网络通信连接、线程、复杂对象等。\n\t- 单例模式（Singleton）：\n\t- 对象池模式（Object Pool）：复用对象实例，减少对象创建和资源消耗。\n- 数据结构：不同场景中，灵活组合各种数据结构改善数据读写和计算特性。\n- 垃圾回收：Young GC、Full GC\n\n#### 存储性能优化\n- 缓存解决一部分数据的读压力，但磁盘仍然是系统最严重的瓶颈，磁盘可用性和容错性也是改善网站性能的重要因素。\n\n##### HDD / SSD\n- 硬盘驱动器（Hard Disk Drive）：也称机械硬盘。\n\t- 其通过马达驱动磁头臂，带动磁头到指定的磁盘位置访问数据。\n\t- 由于每次访问数据都需移动磁头臂，为此在数据连续访问和随机访问时，移动磁头臂的次数相差巨大，致使性能表现差别也大。\n\n\t\t> `连续访问`：访问数据存储在连续磁盘空间上；`随机访问`：访问数据存储在不连续磁盘空间上\n\n- 固态驱动器（Solid State Disk）：也称固态硬盘。数据存储在可持久记忆的硅晶体上，为此可像内存一样快速随机访问。\n\n##### B+ Tree / LSM Tree\n- 文件系统或数据库系统通常会对数据排序后存储，以加快数据检索速度。若需要保证数据在不断更新、插入、删除后依然有序，索引的数据结构也有讲究：MySQL 多数采用 B+ 树；NoSQL 多数采用 LSM 树。\n- B+ 树：N 叉排序树，以树的节点为单位存储数据，从根开始查找所需数据所在节点编号和磁盘位置，将其加载到内存中。\n- LSM 树：N 阶合并树，数据写操作（增/删/改）都在内存中进行。\n\t- 数据写操作都会创建一个新记录，修改则记录新的数据值，删除则记录一个删除标记。\n\t- 数据在内存仍然是一颗排序树，当数据量超过设定内存阈值后，会将该棵排序树和磁盘上最新的排序树合并。\n\t- 当数据量也超过设定阈值后，将和磁盘上下一级的排序树合并。\n\t- 合并过程中，新数据会覆盖旧数据，或者记录为不同版本。\n\t\n\t\t> LSM 树上进行更新不需磁盘访问，在内存即可完成。同理，读操作也总是从内存的排序树开始搜索，若没有找到再从磁盘上的排序树顺序查找。\n\n##### RAID / HDFS\n- 廉价磁盘冗余阵列（RAID）：利用多块磁盘实现数据的并发读写和数据备份，主要为了改善磁盘的访问延迟，增加磁盘的可用性和容错能力。\n- 常见 RAID 技术，其技术原理如下图所示：\n\n\t{%centerquote%}\n\t![](/images/CS/Website-Tech-Framework/RAID.svg) 常见 RAID 的技术原\n\t{%endcenterquote%}\n\t\n\t- RAID 0：根据磁盘将数据分为 n 份，数据同时并发写入 n 快磁盘，使得数据整体写入速度是一块磁盘的 n 倍。同理，RAID 0 也具有极速的读速度。\n\n\t\t> 但 RAID 0 不做数据备份，n 块硬盘中只要有一块损坏，数据完整性即被破环，所有磁盘的速度都会损坏。\n\t\n\t- RAID 1：一份数据同时写入两块硬盘，这样任何一块硬盘损坏都不会导致数据丢失，插入一块新磁盘可通过复制数据方式自动修复。\n\n\t- RAID 10：将所有磁盘平均分成两份，数据同时在两份磁盘写入（相当与 RAID 1）。但每一份数据在 n/2 块磁盘上，利用 RAID 0 技术并发读写。\n\n\t\t> 结合 RAID 0 和 RAID 1 两种方案，但 RAID 10 磁盘利用率较低（一半磁盘用来备份数据）。\n\n\t- RAID 3：一般情况，一台服务器不会同时损坏两块磁盘的情况（物理因素除外），假设在只损坏一块磁盘情况下，利用其他磁盘的数据回复损坏磁盘的数据，即保证了可靠性和性能，同时提升了磁盘利用率。\n\n\t\t将数据分成 n-1 份，并发写入 n-1 块磁盘，并在第 n 块磁盘记录校验数据，任何一块磁盘损坏（包含校验数据磁盘），都可利用其他 n-1 块磁盘恢复数据。\n\n\t- RAID 5：原理与 RAID 3 相似，但校验数据不是写入第 n 块磁盘，而是螺旋式地写入所有磁盘中。即检验数据也平均到所有磁盘上，避免了频繁写坏一块磁盘。\n\t\n\t- RAID 6：原理与 RAID 3 相似，数据写入 n-2 块磁盘中，并螺旋式地在两块磁盘中写入校验信息（使用不同算法生成）。\n\n- Hadoop 分布式文件系统（HDFS）：在整个存储集群的多台服务器上进行数据并发读写和备份。\n\t- HDFS 以块（Block）为单位管理文件内容，一个文件被分割成若干 Block。\n\t- 当应用程序写文件时，每写完一个 Block，HDFS 就将其自动复制至另外两台机器上，以保证每个 Block 有三个副本。\n\n\t\t> 相当于 RAID 1 的数据复制功能。\n\n\t- 当对文件进行处理计算时，通过 MapReduce 并发计算任务框架，启动多个计算子任务（MapReduce Task）同时读取文件的多个 Block。\n\n\t\t> 相当于 RAID 0 的数据并发访问功能。\n\n- HDFS 包括两个重要服务器角色：名称服务节点（NameNode）和数据存储节点（DataNode）\n\t- NameNode 在整个 HDFS 只部署一个实例，提供` 元数据` 服务。相当于操作系统中的文件分配表（FAT），管理文件名 Block 的分配，维护整个文件系统的目录树结构。\n\t- DataNode 部署在 HDFS 集群的单独服务器上，可以部署多个实例，提供 `数据存储` 服务。\n\t- 应用程序（Client）需要写文件时，首先访问 NameNode，请求分配数据块，NameNode 根据管理的 DataNode 服务器的磁盘空间，按照一定的负载均衡策略，分配若干数据块以供 Client 使用。\n\n### 05 网站高可用架构\n> 事物总是先求存后发展，保证网站可用、万无一失，任重道远。\n\n#### 可用性度量\n- 网站不可用也称 `网站故障`，业界通常用 `多少个9` 来衡量网站的可用性。\n\n\t> 例如 QQ 的可用性是 4 个 9，即 99.99%。表示 QQ 服务要保证其在所有运行时间中，只有 0.01% 的时间不可用，大约一年当中最多 53 分钟不可用。\n\t\n\t- 2个9 为基本可用，网站年度不可用时间小于 88 小时；\n\t- 3个9 为较高可用，网站年度不可用时间小于 9 小时；\n\t- 4个9 为具有自动恢复能力的高可用，网站年度不可用时间小于 53 分钟；\n\t- 5个9 为极高可用，网站年度不可用时间小于 5 分钟；\n\n- 网站不可用时间（故障时间）= 故障修复时间点 - 故障发现（报告）时间点\n- 网站年度可用指标 = (1 - 网站不可用时间 / 年度总时间) * 100%\n\n#### 高可用架构\n- 高可用架构主要手段是：数据和服务的 `冗余备份`及 `失效转移`。\n\t- 冗余备份：磁盘损坏，则从备份的磁盘读取数据。\n\t- 失效转移：服务器宕机，将服务切换至其他可用服务器上。\n- 网站架构基本分层模型：\n\n\t{%centerquote%}\n\t![](/images/CS/Website-Tech-Framework/web-hierarchical-model.svg) 网站架构基本分层模型\n\t{%endcenterquote%}\n\n\t> 对于中小型网站，通常应用层和服务层部署在一起；数据层另外部署。\n\n- 复杂大型网站结构中，划分力度会更小、更细：\n\n\t{%centerquote%}\n\t![](/images/CS/Website-Tech-Framework/web-hierarchical-model-details.svg) 网站架构基本分层模型\n\t{%endcenterquote%}\n\t\n\t- 位于 `应用层` 的服务器：为应对高并发的访问请求，通过负载均衡设备将一组服务器组成一个集群共同对外提供服务。\n\t\t- 负载均衡设备通过 `心跳检测` 等手段监控应用服务器是否可用。\n\t\t- 遇到不可用的应用服务器时，将其从集群中剔除，并将请求分发到集群其他服务器。\n\t- 位于 `服务层` 的服务器：应用层通过分布式服务调用框架访问该些服务器。\n\t\t- 分布式服务调用框架会在应用层客户端中实现软件负载均衡。\n\t\t- 并且通过 `服务注册中心` 对提供服务的服务器进行心跳检测，当发现服务不可用时，通知客户端修改服务访问列表，提出不可用服务器。\n\t- 位于 `数据层` 的服务器：\n\t\t- 数据写入时进行数据同步复制，将数据写入多台服务器上，实现数据冗余备份。\n\t\t- 当数据库服务器宕机时，应用程序将访问切换至有备份数据的服务器。\n\n- 网站的可用性架构设计，不仅要考虑 `实际硬件故障` 引起的宕机，而且也要考虑 `网站升级发布` 引起的宕机。\n\n#### 高可用应用\n- 应用层也称业务逻辑层，用于处理网站应用的业务逻辑。\n- 应用层中，应用的显著特定是应用无状态性。\n\t- 无状态的应用指应用服务器不保存业务的 `上下文信息`，仅根据每次请求提高的数据进行相应的数据进行相应的业务逻辑处理。\n\t- 多个服务器实例（服务器）之间 `完全对等`，请求提交到任意服务器，处理结果都是完全一样的。\n\n##### 负载均衡进行无状态服务的失效转移\n- 所有服务器完全对等，当任意一台或多台服务器宕机，请求可提交集群中任意一台可用机器处理。\n- 实现服务器可用状态实时监测、自动转移失败任务的机制是负载均衡。\n\n\t{%centerquote%}\n\t![](/images/CS/Website-Tech-Framework/Hight-Availability-with-Load-Balancing.png) 利用负载均衡实现高可用\n\t{%endcenterquote%}\n\n##### 应用服务器集群的 Session 管理手段\n- Web 应用中将多次请求修改使用的上下文对象称作 `会话`（Session）。\n\t- 单机环境：Session 可由部署在服务器上的 Web 容器管理，如 JBoss。\n\t- 集群环境 ：Session 复制；Session 绑定；利用 Cookie 记录 Session；Session 服务器\n- Session 复制\n\n\t{%centerquote%}\n\t![](/images/CS/Website-Tech-Framework/Hight-Availability-Session-Coping.png) 利用 Session 复制实现应用服务器共享 Session\n\t{%endcenterquote%}\n\n\t- 服务器开启 Web 容器的 Session 复制功能，在集群中几台服务器之间同步 Session 对象，使得每台服务器上都保存所有用户的 Session 信息。\n\t- 存在问题：\n\t\t- 1) 集群规模较大时，集群服务器需大量通信进行 Session 复制，占用服务器和网络资源；\n\t\t- 2) 所有用户的 Session 在每台服务器都拥有备份，当出现大量用户访问时会致使服务器内存不够 Session 开销。\n- Session 绑定\n\n\t{%centerquote%}\n\t![](/images/CS/Website-Tech-Framework/Hight-Availability-Session-Binding.png) 利用负载均衡的会话黏滞机制将请求绑定到特定服务器\n\t{%endcenterquote%}\n\n\t- 利用负载均衡的源地址 Hash 算法实现，负载均衡服务器总是将来源于同一 IP 的请求分发到同一台服务器上，或根据 Cookie 将同一用户的请求总是分发到同一台服务器上。\n\t- Session 绑定于某台特定服务器上，保证 Session 总能从这台服务器上获取，这种方法又称作 `会话黏滞`。\n\t- 存在问题：当某台服务器宕机，存在于机器上的 Session 就不复存在，用户请求切换至其他机器因没有 Session 而无法完成业务处理。\n- 利用 Cookie 记录 Session\n\n\t{%centerquote%}\n\t![](/images/CS/Website-Tech-Framework/Hight-Availability-Session-Cookie.png) 利用 Cookie 记录 Session 信息\n\t{%endcenterquote%}\n\n\t- Session 记录在客户端；网站则利用浏览器 Cookie 记录 Session。\n\t- 存在问题：\n\t\t- 1) 受 Cookie 大小限制，记录信息有限。\n\t\t- 2) 每次请求响应都需传输 Cookie。\n\t\t- 3) 用户关闭 Cookie，访问会不正常。\n- Session 服务器\n\n\t{%centerquote%}\n\t![](/images/CS/Website-Tech-Framework/Hight-Availability-Session-Server.png) 利用 Session 服务器共享 Session\n\t{%endcenterquote%}\n\n\t- 独立部署 Session 服务器（集群）统一管理 Session，应用服务器每次读写 Session 时都访问 Session 服务器。\n\t- 该方案事实上是将应用服务器的状态分离，即 `无状态应用服务器` 和 `有状态 Session 服务器`，然后针对这两种服务器的不同特性分别设计其架构。\n\n\t\t> 有状态 Session 服务器的应用场景：单点登录（SSO）、用户服务等。\n\n#### 高可用服务\n> 可复用的服务和应用一样，也是无状态的服务，可使用类似负载均衡的失效转移策略实现高可用服务。\n\n- `分级管理`\n\t- 运维上将服务器进行分级管理。\n\t- 服务器部署时进行必要隔离，避免故障的连锁反应。\n- `超时设置`：由于服务器宕机、线程死锁等会导致应用程序对服务端的调用失去响应，用户长时间得不到响应，同时还占用应用程序的资源，不利于及时将访问请求转移到正常服务器上。\n\t\n\t- 在应用程序中设置服务调用的超时时间，一旦超时通信框架就抛出异常。\n\t- 应用程序根据服务调度策略，可继续重试或将请求转移到提供相同服务的其他服务器上。\n- `异步调用`：应用对服务的调用通过消息队列等异步方式完成。\n\t\n\t> 注意：并不是所有服务调用都适用异步调用，对于获取用户信息此类调用，异步方法会延长响应时间；对于必须确认服务调用成功才能继续下一步操作的应用也不适合使用异步调用。\n\n- `服务降级`：拒绝服务和关闭服务\n\t- 拒绝服务：\n\t\t- 拒绝低优先级应用的调用，减少服务调用并发数，确保核心应用正常使用。\n\t\t- 随机拒绝部分请求调用，让部分请求成功，避免大家一起死的 \"惨状\"。\n\t- 关闭服务：关闭部分不重要的服务或者服务内部不重要的功能，以节约系统开销。 \n\n\t\t> 淘宝在每年双十一促销中，会在系统最繁忙时段关闭 ”评价“、”确认收货“ 等非核心服务。\n\n- `幂等性设计`：服务层保证服务重复调用和调用一次产生的结果相同，即服务具有幂等性。\n\n#### 高可用数据\n- CAP 原理：数据一致性（Consistency）、数据可用性（Availibility）、数据伸缩性（Partition Tolerance）。\n\t- 高可用数据的含义\n\t\t- 数据持久性：写入数据持久性存储，数据多份副本存放在不同物理设备上。\n\t\t- 数据可访问性：一个数据存储设备损坏，切换访问数据源，时间要足够短即终端用户无感知性。\n\t\t- 数据以一致性：多份数据副本，由于网络、服务器或者软件故障导致部分副本写入成功、部分写入失败，造成各副本间的数据不一致。\n\t- CAP原理认为，一个提供数据服务的存储系统无法同时满足以上三个条件。\n\t\n\t\t> 通常在大型网站中会强化分布式存储系统的可用性 (A) 和伸缩性 (P)，某程度弱化或放弃一致性 (C)。\n\n- 数据备份\n\t- 冷备份：定期拷贝数据至某种存储介质上物理存档保管。\n\t- 热备份：异步热备、同步热备\n\t\n\t{%centerquote%}\n\t![](/images/CS/Website-Tech-Framework/Hight-Availibility-Async-Backup.svg) ![](/images/CS/Website-Tech-Framework/Hight-Availibility-Sync-Backup.svg) 异步热备 v.s. 同步热备\n\t{%endcenterquote%}\n\n- 失效转移\n\t- 失效确认：心跳检测和应用程序访问失败报告\n\t- 访问转移\n\t\t- 完全对等存储的服务器：应用程序根据配置直接切换到对等服务器上。\n\t\t- 不对等存储的服务器：重新计算路由，重新选择服务器。\n\t- 数据恢复：服务器宕机，为此数据存储副本数减少，必须将副本数目恢复至系统设定值。\n\n#### 软件质量保证\n> 为了保证网站线上系统的可用性，需要采取有别于传统软件开发的 `质量保证手段`。\n\n- 网站发布：事实上，网站发布过程和服务器宕机效果相当，即关闭应用再重新部署启动应用。\n\n- 自动化测试\n\t- 引入原因：代码上线前需进行严格测试；为保证系统没有引入始料未及的 BUG，还需对整个网站系统（至少上下文关联的系统模块）进行全面回归测试。\n\n\t\t> 使用人工测试，基于成本、时间、效果以及测试覆盖率都不尽理想。\n\n\t- 解决方案：为此，引入 Web 自动化测试工具。\n\n\t\t> 比如 Selenium 可在浏览中模拟用户操作进行测试。\n\n- 预发布验证\n\t- 引入原因：即使通过严格的测试，应用部署到线上服务器仍然会出现各种问题，更甚无法启动服务器。主要原因是生产与测试环境不一致导致的，比如数据库、缓存、第三方服务接口等。\n\t- 解决方案：在预发布服务器上预发布验证。预发布服务器与正式服务器都部署在相同的物理环境，同一数据源、相同生产配置、依赖 相同外部服务等。区别于正式服务器， 唯一区别是没有配置在负载均衡服务器上，外部用户无法访问。\n\t\n\t\t> 注意：预发布服务器连接的是真实生产环境、真实数据库，所有预发布验证操作都是真实有效的数据，这些操作也许会引起不可预期的问题。\n\n- 代码控制：代码控制核心问题是代码管理，既保证代码发布版本稳定正确，同时保证不同团队开发互不影响。\n\t- 主干开发，分支发布：一个分支一个发布版本，该版本有BUG继续在该分支上修改发布，待验证稳定时合并回主干。\n\t- 分支开发，主干发布：开发新功能或修复BUG，从主干拉取一个分支进行，开发测试通过后合并回主干，由主干进行发布。主干上的代码永远是最新发布版本。\n\n- 自动化发布：火车发布模型\n\t\n\t> 很多网站选择周四作为发布日，这样周一至周三准备上线工作，周五留有余地以挽回错误。而选择周五发布，发现问题周末就得凉凉了。\n\n- 灰度发布\n\t- 将服务器分成若干部分，每天只发布一部分服务器，观察运行是否稳定无故障。\n\t- 持续几天逐渐把整个集群全部发布完毕。\n\t- 期间若发现问题，只需要回滚已发布的部分服务器。\n\n\t> 灰度发布也常用于用户测试（AB测试），即部分服务器上新版本应用，其余服务器保持老版本。然后监控用户操作行为，收集用户体验报告，比较用户对两个版本的满意度，以确定最终发布版本。\n\n#### 网站运行监控\n> 盲人骑瞎马，夜半临深池。不允许没有监控的系统上线，没有指标可循，提高可用性、减少故障率就无从做起了。\n\n##### 数据采集\n- 用户行为日志收集：用户在浏览器的所有操作、操作系统与浏览器版本信息、IP 地址、页面访问路径、页面停留时间等。\n\n\t> 获得以上数据，可用于 PV/UV 指标、分析用户行为、优化网站设计、个性化推荐与营销等。\n\n\t- 客户端浏览器日志收集：利用页面嵌入 JavaScript 脚本收集用户真实的操作行为，比如百度统计、腾讯统计等。\n\t- 服务端日志收集：Web 服务器的日志记录功能。 \n\n- 服务器性能监控：内存占比、磁盘I/O、网络 I/O 等。\n\n##### 监控管理\n- 系统报警：给监控指标设定报警阈值。\n- 失效转移：主动通知应用，应用及时进行失效转移。\n- 自动优雅降级：访问高峰期间，主动关闭部分非核心功能，释放部分系统资源。\n\n###  06 网站伸缩性架构\n- 网站伸缩性：不需要改变网站的软硬件设计，仅通过改变部署的服务器数量就可扩大或缩小网站的服务处理能力。\n\n#### 网站架构的伸缩性设计\n- 网站伸缩性设计分类\n\t- 不同功能进行物理分离实现伸缩：即按照不同服务分类，比如应用部署、数据存储、数据缓存等。\n\n\t\t- 纵向分离（服务分层后分离）：系统服务分离，将业务处理流程的不同部分分离部署，实现伸缩性。\n\t\t- 横向分离（业务分割后分离）：业务模块分离，将不同业务模块分离部署，实现伸缩性。\n\t- 单一功能通过集群规模实现伸缩：集群内多台服务器部署相同的服务。\n\n\t{%centerquote%}\n\t![](/images/CS/Website-Tech-Framework/Scalability-Server-Physical-Separation.svg) 网站伸缩性实现方式\n\t{%endcenterquote%}\n\n- 一个具有良好伸缩性架构设计的网站，其架构设计必定走在业务发展前面。当业务剧增时，只需要购买服务器，简单部署实施即可。\n\n#### 应用服务器集群的伸缩性设计\n- 实现思路：负载均衡（HTTP 重定向、DNS 域名解析、反向代理）\n- 前提条件：应用服务器应该设计成无状态的，每次用户请求都可以送达集群中任意一台服务器上处理。\n- 负载均衡服务器：实现应用服务器的伸缩性。\n\t- 可感知、可配置集群的服务器数量\n\t- 向服务器分发请求\n\n- HTTP 重定向负载均衡\n\t- 优势：实现简单\n\t- 劣势：两次服务器请求完成一次访问；重定向服务器自身处理能力可能成为瓶颈。\n\n\t\t{%centerquote%}\n\t\t![](/images/CS/Website-Tech-Framework/Scalability-LoadBalancing-HTTP-Redirection.png) HTTP 重定向负载均衡\n\t\t{%endcenterquote%}\n\n- DNS 域名解析负载均衡：配置多个 @ 记录，DNS 根据 @ 记录和负载均衡算法计算得到 IP 地址。\n\t- 优势：将负载均衡的任务转移至 DNS。\n\t- 劣势：DNS 是多级解析，每一级 DNS 都可能缓存 @ 记录。当下线某台服务器，即使修改了 DNS 的 @ 记录，但由于生效时间限制，若此时域名解析到下线的服务器，将导致用户访问失败。\n\n\t\t{%centerquote%}\n\t\t![](/images/CS/Website-Tech-Framework/Scalability-LoadBalancing-DNS-Domain.png) DNS 域名解析负载均衡\n\t\t{%endcenterquote%}\n\n- 反向代理负载均衡：在应用程序中分发数据\n\t- 优势：缓存资源，改善网站性能。\n\t- 劣势：所有请求和响应的中转站，代理服务器性能会成为瓶颈。\n\n\t\t{%centerquote%}\n\t\t![](/images/CS/Website-Tech-Framework/Scalability-LoadBalancing-Reverse-Agent.png) 反向代理负载均衡\n\t\t{%endcenterquote%}\n\n- IP 负载均衡\n\t- 优势：在内核进程中完成数据分发，较反向代理负载均衡有更好性能。\n\t- 劣势：集群中最大响应数据吞吐量受限制于负载均衡服务器的网卡带宽。\n\n\t\t{%centerquote%}\n\t\t![](/images/CS/Website-Tech-Framework/Scalability-LoadBalancing-IP-Load.png) IP 负载均衡\n\t\t{%endcenterquote%}\n\n- 数据链路层负载均衡：在通信协议的数据链路层修改 MAC 地址进行负载均衡，又称作直接路由方式。\n\t- 优势：不需要通过负载均衡服务器进行地址转换，响应数据包直接返回浏览器，以避免负载均衡服务器网卡带宽成为瓶颈。\n\n\t\t> 直接路由方式是目前较为广泛使用的负载均衡手段，相关开源产品 LVS（Linux Virtual Server）。\n\n\t\t{%centerquote%}\n\t\t![](/images/CS/Website-Tech-Framework/Scalability-LoadBalancing-Data-Link.png) 数据链路层负载均衡\n\t\t{%endcenterquote%}\n\n#### 分布式缓存集群的伸缩性设计\n- 实现目标：因缓存请求必须找到缓存有数据的服务器才能访问，该特点会严重制约分布式缓存集群的伸缩性设计。为此，新加入的缓存服务器应使得整个缓存服务器集权已缓存的数据尽可能还被访问到，这是分布式缓存集群伸缩性设计的主要目标。\n\n- 路由算法：分布式缓存的一致性 Hash 算法\n\t- 算法过程\n\t\t- Step.01：先构造一个长度为 $2^{32}$ 的整数环（二叉排序树实现，且二叉树的最左叶子节点与最右叶子节点相连接构成环）；\n\t\t- Step.02：根据节点名称的 Hash 值（Hash $\\in [0, 2^{32}-1]$）将缓存服务器节点放置于 Hash 环上；\n\t\t- Step.03：计算缓存数据的 Key 值得到 Hash 值，然后在 Hash 环上顺时针查找距离 Key 的 Hash 值最近的缓存服务器节点；\n\t\t- Step.04：完成 Key 到服务器的 Hash 映射查找。\n\t- 实操演示\n\n\t\t{%centerquote%}\n\t\t![](/images/CS/Website-Tech-Framework/Scalability-Hash-Cricle.svg) 一致性 Hash 算法\n\t\t{%endcenterquote%}\n\n\t\t- 假设 Node1 的 Hash = 3594963423，Node2 的 Hash  = 1845328979，而 Key0 的 Hash = 2534256785，那么 Key0在环上顺序针查找最近的节点就是 Node1。\n\t\t- 当缓存服务器集群需要扩容时，只需将新加入节点 Node3 的 Hash 值放入一致性 Hash 环中。由于 Key 是顺时针查找距离最近邻节点，因此新加入的节点只影响整个环中的一小段。\n\n#### 数据服务器集群的伸缩性设计\n\n- 缓存的目的是加速数据读取并减轻数据存储服务器的负载压力，部分缓存数据丢失不影响业务的正常运作。\n- 数据存储服务器必须保证数据的可靠存储，任何情况都必须保证数据的可用性与正确性。\n\n##### 关系数据库集群\n- 主从模式\n\t- 数据写操作都在主服务器上，主服务器将数据同步到集群中其他从服务器。\n\t- 数据读操作及数据分析等离线操作在从服务器上进行。\n- 业务分割模式：不同业务数据表部署于不同的数据库集群上、同一张表分片储存于多个数据库，及数据库的 `分库分表`。\n\n##### NoSQL 数据库\n- 引言：先设计数据库然后设计程序，从而导致关系模型绑架对象模型，引申出旷日持久的对象贫血模型与充血模型之争。\n\t- 贫血模型：业务对象仅包含数据而不包含行为，其作用只是数据载体或数据传递介质。系统的业务逻辑全部放到业务逻辑层，会导致业务逻辑层比较庞大。\n\t- 充血模型：业务对象既包含数据又包含行为，他的作用不再只是数据的载体而是一个真正有行为的对象。\n- 问题：关系数据库难以克服的缺陷，即糟糕的海量数据处理能力以及僵硬的设计约束。\n- 方案：Not Only SQL（NoSQL），指非关系的、分布式数据库设计模式。但 NoSQL 只是关系数据库的补充而非替代方案。\n- HBase\n\n\t{%centerquote%}\n\t![](/images/CS/Website-Tech-Framework/Scalability-HBase-Architecture.svg) HBase 架构\n\t{%endcenterquote%}\n\n\t- 其伸缩性主要依赖于分裂的 HRegion 以及可伸缩的分布式文件系统 HDFS。\n\t- HRegion：数据以 HRegion 为单位进行管理，当应用程序访问数据时，必须先找到 HRegion，然后将读/写操作提交给 HRegion，由 HRegion 完成存储层面的数据操作。\n\t\t- 每个 HRegionServer 上启用多个 HRegion 实例；\n\t\t- 每个 HRegion 中存储一段 Key 值区间的数据，比如 [key1, key2) ；\n\t\t- 每当 HRegion 写入数据达到配置阈值时，触发分裂机制变成两个 HRegion，并在集群中进行迁移使得 HRegionServer 负载均衡。\n\t- HMaster：用于存储 HRegion 信息（Key 值区间、所在 HRegionServer 地址、访问端口等）。\n\t\t- 为提高高可用性，HBase 启用多个 HMaster，并通过 Zookeeper 管理（需选出一个主服务器）。\n\t\t- 通过 Zookeeper 获得主 HMaster 地址，输入 Key 值获得所在 HRegionServer 地址，最后请求 HRegionServer 上的 HRegion 获得数据。\n\n### 07 网站可扩展架构\n- 扩展性与伸缩性的误用\n\t- 扩展性（Extensibility）：软件层面，基础设施稳定不需要经常变更，应用之间较少依赖耦和耦合，对需求变更可敏捷响应。\n\t- 伸缩性（Scalability）：硬件层面，能够通过增加或减少自身资源规模的方式增强或减少自己计算处理事务的能力。\n\n\t\t> 在网站架构设计中，通常指利用集群方式增加服务器数量，以提高系统的整体事务吞吐能力。\n\n- 网站可扩展性架构的核心思想是模块化，在此基础上降低模块间的耦合性，提高模块的复用性。\n- 利用分层和分割方式将应用系统分割为若干个低耦合的独立组件模块，组件模块间通过消息传递及依赖调用方式聚合成一个完整系统。模块分布式部署后具体聚合方式有 `分布式消息队列` 与 `分布式服务`。\n\n#### 利用分布式消息队列降低系统耦合性\n> 通过消息对象来降低系统耦合性。\n\n- 事件驱动架构（Event Driven Architecture）：在低耦合的模块之间传输事件消息，并借助事件消息的通信完成模块间合作。常用实现手段是分布式消息队列。\n\n\t> 典型 EDA 架构就是生产者-消费者模式。\n\n- 分布式消息队列：发布-订阅模式，类似 \"队列\" 的数据结构，先进先出（FIFO）对消息进行存取操作；应用程序通过远程访问接口实现分布式的异步调用。\n\t\n\t> 常见的消息队列产品有 Kafka、RabbitMQ 等，理论上使用数据库也可以实现分布式消息队列的，消息生产者程序将消息记录写入库并为记录附上时间戳。\n\n#### 利用分布式服务打造可复用业务平台\n> 通过系统接口来降低系统耦合性。\n\n- 巨无霸应用系统困境\n\t- 新增业务困难\n\t- 编译部署困难\n\t- 数据库连接耗尽\n\t- 代码分支管理困难\n\n- 解决方案：拆分模块，独立部署\n\t- 纵向拆分：大应用拆成小应用。\n\t- 横向拆分：可复用的业务独立部署为分布式服务。\n\n#### 可扩展数据结构\n- 问题：传统关系数据库为保证关系运算的正确性，则需要指定表的字段及数据类型，并遵循特定的范式要求设计数据表。僵硬的数据结构难以面对需求变更带来的挑战，虽可通过冗余字段来应对变化，但糟糕的数据库设计总会有不灵之时。\n- 解决：如何做到可扩展的数据结构设计，无需修改表结构扩展数据字段？\n\n\t> NoSQL 数据库：使用列簇设计（ColumnFamily），一种面向列簇的稀疏矩阵存储格式。它在创建表时，只需指定 ColumnFamily 的名字即可，无须指定字段（Column），在写入数据时再指定。\n\n### 08 网站的安全架构\n#### 网站应用攻击与防御\n- XSS 攻击：跨站点脚本攻击（Cross Site Script），篡改网页注入 HTML 脚本，在用户浏览网页时控制用户浏览器进行恶意操作。\n\t- 反射性：攻击者诱使用户点击一个嵌入恶意脚本的链接，达到攻击目的。\n\t- 持久性：攻击者提高含有恶意脚本的请求，保存在被攻击的 Web 站点的数据库中，用户浏览网页时，恶意脚本包含在正常的内容页上。\n\t- 消毒手段\n\t\t- 对 HTML 危险字符转义，比如 `>` 转换为 `&gt;`、`<` 转换为 `&lt;`。\n\t\t- 浏览器禁止页面 JavaScript 访问带有 HttpOnly 属性的 Cookie。\n\n- 注入攻击\n\t- SQL 注入：在 HTTP 请求中注入恶意 SQL，服务器用请求参数构造数据库 SQL 时被一起构造并执行。\n\n\t\t> 注：关注错误回显功能，即服务器内部 500 错误回显，容易暴露数据库表结构。\n\n\t- OS 注入：OS 命令\n\t- 消毒手段：SQL 预编译和参数绑定\n\n- CSRF 攻击：跨站点请求伪造（Cross Site Request Forgery），核心是利用了浏览器 Cookie 或者服务器 Session 策略，盗取用户身份进行跨站请求、非法操作。常见防范手段：\n\t- Token 校验：每次请求都需附带时效性 Token 发起请求，且通过注册机制获得 Token。\n\t- 验证码校验：人机交互方式。\n\n- 错误码： 服务端未处理异常堆栈信息，而是直接输出客户端浏览器，该方式虽然对调试和错误报告友好但对攻击者提供了可乘之机。\n\n\t> 拦截异常要处理、对错误码进行拦截处理。\n\n- 文件上传：建立文件白名单机制，限制文件类型。\n\n- 路径遍历：在请求 URL 中使用相对路径，遍历系统未开放的目录和文件。比如 `../`。\n\n#### 信息加密及密钥管理\n- 单向散列加密：输入不同长度的信息进行散列计算，得到固定长度的输出，具有不可逆性。比如 MD5、SHA 算法。\n\t- 对密码进行单向散列加密，密码密文存入数据库；\n\t- 密码验证时，同样对密码明文散列计算，与数据库比对。\n\n- 对称加密：加密、解密使用同一密钥，比如 DES、RC、SM4 算法。\n\n- 非对称加密：使用两个密钥来进行加密和解密，一个是对外公开的公钥（Public key）和私钥（Private key）。比如 RSA、ECC、SM2 算法。\n\n- 密钥安全管理\n\t- 保证线上线下环境配置不同的密钥，密钥写在配置文件中，且使用密文形式保存。\n\t- 加解密算法放在应用系统，密钥存放于独立服务器，且密钥实际存储时被切割为数片，加密存储于不同存储介质上。","tags":["分布式","缓存","异步","集群","高性能","高可用"],"categories":["Reading"]},{"title":"理财启蒙课：富爸爸穷爸爸","url":"/2022/01/Poor-Dad-Rich-Dad.html","content":"\n- 作者罗伯特·清崎有两位父亲：穷爸爸，亲生父亲，高学历教育官员；富爸爸，他好朋友的父亲，高中没毕业却善于投资理财的企业家。\n- 两位父亲事业都很成功，他们一辈子勤奋上进、且有丰厚收入。穷爸爸终其一生困扰于财务问题，然而富爸爸成为夏威夷最富商人之一。\n- 作者遵从“穷爸爸”为他设计的人生道路：上大学，服兵役，参加越战，走过了平凡的人生初期。直到作者亲眼目睹一生辛劳的“穷爸爸”失了业，“富爸爸”则成了夏威夷最富有的人之一。清崎毅然追寻“富爸爸”的脚步，踏入商界，从此登上了致富快车。\n\n\t> 启示：辩证思维看待两种人生路径，既要走在“穷爸爸”的原始积累道路（知识财富），终生保持学习，也要走“富爸爸”的致富事业道路（财富自由+时间自由），主动争取更多人生选择权。\n\n- 在本书中，作者将以亲身经历的财富故事展示了“穷爸爸”和“富爸爸”截然不同的金钱观和财富观：**穷人为钱工作，富人让钱为自己工作**。\n\n<!-- More -->\n\n## 壹 财务观念\n### 对待金钱\n- 穷爸爸：贪财是万恶之源，人应该懂得节制，不能沉迷于金钱，涉及钱的时候别去冒险。\n- 富爸爸：贫穷是万恶之本，贫穷会放大人之恶，磨灭人之善。相反，财富可帮助更多的人，才能够消灭掉世界上更多的恶。要学会管理风险，一旦风险在控制之内就大胆地投资。\n\n### 对待奢侈\n- 穷爸爸：我可付不起，浇灭一切不切实际的想法。房子是最大的资产和投资。\n- 富爸爸：我怎样才能付得起，利用资产生息以利息购买大件 / 奢侈品。自住的房子是负债。\n\n### 对待纳税\n- 穷爸爸：富人应多缴税多为社会做贡献。\n- 富爸爸：纳税是“惩勤奖懒”。\n\n### 对待学习\n- 穷爸爸：驱动学习的力量是恐惧。好好学习，争取去一家好公司、谋一份好工作好好养活自己。\n- 富爸爸：驱动学习的力量是爱。努力学习，发现一家好公司并收购它，创造更多的就业机会给别人，以帮助更多的人。\n\n### 对待养老\n- 穷爸爸：依赖政府的养老金政策，把自己老年退休的生活依赖于政府身上。认为这是我为政府辛苦工作，应该享受的待遇。\n- 富爸爸：信奉完全的经济自立，反对理所当然的心态，认为正是这种理所当然的心理造成了人们的软弱、贫穷。\n\n### 对待破产\n- 穷爸爸：“我对钱不感兴趣”或者“钱对我来说并不重要”来安慰自己，认为自己永远也不会成为富人了，更甚挣扎于破产漩涡之中。\n- 富爸爸：破产是暂时的，贫穷是永远的。\n\n## 贰 财务知识\n### 不为钱工作\n- 穷人/中产为钱而工作，富人让钱为他工作。\n\n\t> 当今社会一种很讽刺的管理理论：工人付出最大努力以免被解雇，而雇主提供最低工资以防止工人辞职。\n\n- 关于钱，穷人内心充满恐惧，富人内心充满激情。\n\t- 希望稳稳当当地挣钱，以获得安全感 。\n\n\t\t> 启示：人们的生活总是被恐惧和贪婪控制。没钱的恐惧，促使努力工作；得到报酬后，欲望和贪婪又让他们用钱购买东西，循环往复、深陷消费主义泥潭。先控制恐惧和欲望，即使获得了高薪，也只不过是金钱的奴隶。\n\n\t- 激情是愤怒（不满）和热爱（投入）的结合体，不满足于现状就得想办法去改变。\n\n\t\t> 启示：应该把时间和精力运用到自己的事业上，珍惜自己的时间和精力，要为自己以后的成长和快乐去工作，而不是为了眼前的生存问题工作。\n\n- 学会在工作中成长，不拘谨于眼前有多少报酬，要从工作中解构需求，有需求就有商机。\n- 保持学习：要想真正富有，既要不吝付出也要学会索取。\n\t- 习得管理技能\n\t\t- 现金流的管理\n\t\t- 个人时间管理\n\t\t\n\t\t\t> 时间管理不等于精力管理\n\t\t\n\t\t- 人事管理\n\t- 学习专业技能\n\t\t- 销售技能\n\t\t- 营销技能\n\t\t- 沟通能力\n\t\t\n\t\t\t> 不限于书面表达能力、口头表达能力或者谈判能力。\n\n### 资产与负债\n- 资产：把钱放进自己口袋的东西，不管我工作与否。\n- 负债：把钱从自己口袋取走的东西。\n- 资产的现金流 v.s. 负债的现金流\n\n\t{%centerquote%}\n\t![](/images/Reading/Poor-Dad-Rich-Dad/CashFlow-Asset-Liabilities.svg)资产现金流 v.s. 负债的现金流\n\t{%endcenterquote%}\n\t\n\t- 资产负债表：表示的是一家公司或者一个家庭在某一时刻的体量。\n\t- 损益表：又称收益表，即收益等于收入减去成本。\n\t- 现金流量表：是一家企业或者一个家庭在财务上生存或死亡的关键“仪表盘”。\n\n- 穷人 / 中产 / 富人的现金流\n\n\t{%centerquote%}\n\t![](/images/Reading/Poor-Dad-Rich-Dad/CashFlow-All-Classes.svg)穷人 / 中产 / 富人的现金流\n\t{%endcenterquote%}\n\n\t- 重要的不是挣了多少钱，而是你能留下多少钱。\n\t- 竭尽全力买入带来收入的资产，降低负债和支出，让更多钱投入资产项。\n\t- 富人买入资产，穷人只有支出，中产阶级购买了自以为是的资产（实际是负债）。\n\n### 财商四要素\n- 会计：会计就是财务知识或者解读数字的能力。\n- 投资：投资是钱生钱的科学。\n- 市场：了解市场是供给与需求的科学。\n- 法律：利用一个具有会计、投资和市场运营的企业会使你的财富实现爆炸性地增长。\n\t- 减税优惠：公司可以做许多个人无法做的事，比如用税前收入支付开支。\n\n\t\t> 个人挣钱、纳税，并靠剩下的钱为生；企业挣钱、花钱（费用），并为剩下的钱纳税。比如：公司配车、员工伙食、员工健身房等福利都是企业支出。\n\t\n\t- 在诉讼中获得保护：用公司和信托来隐藏部分财富以免债主发现。\n\n## 叁 资产事业\n- 尽早起步积累资产，尽早感受到复利的力量。\n- 把额外的收入用来购买可产生收入的资产，你才能获得真正的财务安全。\n- 持续工作同时购买一些房产（投资性质），而不要买负债或一旦被你带回家就没有价值的个人用品。\n- 不需要我到场就可以正常运作的业务，即我拥有它们，但由别人经营和管理。比如：\n\t- 股票\n\t- 债券\n\t- 票据\n\t- 版税：独立 App、音乐、手稿、专利\n\t- 房产：能够产生收入的房地产\n\t- 其他：任何有价值、可产生收入或者增值潜力且有销路的事物\n- 投资者有两类\n\t- 第一类：“一揽子”方式投资的投资者 \n\t- 第二类：自己创造投资机会的投资者\n\n\t\t> 这方面可借鉴街头智慧来自我启发。推荐纪录片《[隐姓亿万富翁](https://www.bilibili.com/bangumi/play/ep337065)》，街头智慧的最佳诠释。\n\n\t\t- 寻找其他人都忽略的机会：寻找被低估的事物，比如海底捞的服务\n\t\t- 筹集资金\n\t\t- 把精明的人（领域专家）组织起来为你工作\n\n## 肆 克服困难\n- 掌握了财务知识，但仍难以积累现金流的原因：恐惧、懒惰、自负、愤世嫉俗、不良习惯。\n- 克服恐惧\n\t- 害怕恐惧是本能反应，顺应本能，直面恐惧，从“小剂量到大剂量”刺激自身对某种恐惧的反应。当刺激次数足够多时，就会产生敢于直面恐惧的勇气。\n\t- 杏仁核本能训练模式：克服恐惧得刻意训练本能反应。\n- 愤世嫉俗\n\t- 我们需要极大得勇气，不让谣言和杞人忧天的怀疑加剧我们的恐惧和疑虑。\n\t- 未经证实的怀疑和恐惧会使人成为愤世嫉俗者。愤世者抱怨现实，成功者分析现实。\n- 克服懒惰：通过忙碌掩饰懒惰，忙碌成为了自己逃避的“挡箭牌”。\n\t- 过分忙于工作而不关心自己财富的人\n\t- 过分忙于工作而不照顾自己身体的人\n- 不良习惯\n- 克服自负\n\t- 许多人用傲慢来掩饰无知。\n\t- 寻找领域专家来当老师，从而对自己的无知做出改进。\n\t\n## 伍 开始行动\n- 精神的力量：找一个超越现实的理由，由“不想要”促成“想要”。\n\n\t> 比如：我不想一辈子都打工、一生都耗在工作上。但我想自由支配自己的时间和生活，我想要金钱为我工作。\n\n- 选择的力量：选择比努力更重要，但原始积累是基础。\n\t- 先学习再投资：投资于教育，我们拥有的唯一真正资产是头脑。\n\t- 新认知新选择：学习新思想，虽然道路会有险阻，但提供了更多的可能性。\n- 关系的力量：慎重地选择朋友\n\t- 结交经济富裕的朋友，目标不是他们的钱财，而是他们得以致富得知识和经验。\n\t- 关注经济困难的朋友，明白什么事情我们避免或不可以去做。\n- 学习的力量：学无止境，当然要习得如何高效学习、快速掌握一门知识的能力。\n- 自律的力量\n\t- 开创事业所必备管理技能\n\t\t- 现金流管理\n\t\t- 人事管理\n\t\t- 时间管理\n\t- 不要陷于”老鼠赛跑“的游戏\n\t\t- 不要背上数额过大的债务包袱，保持低支出。利用资产项产生的现金流来购买大房子或豪车。\n\t\t- 资金短缺时，让压力发挥作用，尽量不要动用你的储蓄或资本。想出新办法挣更多钱，以支付账单。\n\t- 首先支付自己\n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Poor-Dad-Rich-Dad/CashFlow-Payment-Priority.svg) 首先支付自己 v.s. 首先支付他人\n\t\t{%endcenterquote%}\n\n- 建议的力量\n\t- 找一位关系你利益的经纪人，愿意教导你的经纪人，那么他们可能是你得到的最好资产（人力资源）。\n\t- 管理某些领域能力比你强的人，并为他们提供优厚的待遇。\n- 专注的力量：从一项资产中获得现金流的过程是容易的，但拥有正确支付金钱的坚强意志确是困难的。争做金钱的主人，越早感悟收益越大。\n- 给予的力量\n\t- 投资：想要获得，就要先给予。\n\t- 人情：索取前先给予适度慷慨。\n- 无私的力量：让你的初始投资快速回本，投资不是做善事不求回报。\n- 偶像的力量：信仰的力量\n\n## 陆 启示总结\n- 目标：平衡生活开支，竭尽全力购入能带来收入的资产。\n- 目标：降低负债支出，延迟消费，争取更多钱投入资产。\n- 起步：尽力兼顾兴趣工作带来收入。\n- 提升：投入资产接受教育自我增值。\n- 教育：不限投资经验、技能谋生树。\n\n## 参考资料\n- [楠悦读.《富爸爸穷爸爸》读书笔记导图分享 [OL]. douban.com. 2020](https://www.douban.com/note/748524341)\n- [王维东. 为什么要记账 [OL]. Pixiu记账. 2021](https://mp.weixin.qq.com/s/ODkub9sqt6SdLSD6VYZl6g)","tags":["财务","财商","资产","负债"],"categories":["Reading"]},{"title":"所长林超的跨学科思维课：打破精神内耗的方法启示","url":"/2022/01/Interdisciplinary-Thinking.html","content":"\n- 感谢 [@所长林超](https://space.bilibili.com/520155988) 的《跨学科工具箱》思维课程，长达六个月的精神陪伴，愿称其为个人 2021 年度最具价值投资也不为过。学习常伴随着实践与反思，也许会有人不认同此形式的课程，会觉得课程内容泛泛而谈、道理都懂实践很难、付费课程等同割韭菜等。\n- 而个人见解，本通识课的核心价值更多是培养一种跨学科思维模式，启发我们要不断地储备不同学科的知识，不要割裂每个课堂所学的知识，要运用跨学科思维分析问题、解决问题。思维碰撞会激发自身更深刻的元认知，循环往复、不断提升我们认知维度、认知水平，促使着我们更深入理解世界。\n- 其次，方法论提供了一种非常虚幻的 \"我学到了\" 的感觉，我们不要止步于启发阶段，建议对感兴趣的学科系统化深入学习，储备相关领域知识，以打造属于自己的跨学科工具箱。就如《认知心理学重要模型》一课所启示的，类比认知的形成过程，只有把掌握的知识运用起来才能掌握智慧。为此，本笔记不会照搬课程内容，在基线之下融合更多个人见解及知识补充完成总结。但也因能力有限，若有不正确之处还请伙伴们帮忙指正。\n\n<!-- More -->\n\n## 更新进程\n\n| 更新日期 | 更新内容 |\n| :---: | :--- |\n| 20221231 | 《回到真实世界》笔记初稿 |\n| 20221218 | 《自我管理重要模型》笔记初稿 |\n| 20221217 | 《生理学重要模型》笔记初稿 |\n| 20221211 | 《投资大师的思维模型》笔记初稿 |\n| 20221210 | 《会计学重要模型》笔记初稿 |\n| 20221204 | 《现代哲学重要模型》笔记初稿 |\n| 20221127 | 《古代哲学重要模型》笔记初稿 |\n| 20221126 | 《历史学重要模型》笔记初稿 |\n| 20221115 | 《营销学重要模型》笔记初稿 |\n| 20221030 | 《信息论重要模型》笔记初稿 |\n| 20221029 | 《人类学重要模型》笔记初稿 |\n| 20221028 | 《经济学重要模型》笔记初稿 |\n| 20220220 | 《概率统计学重要模型》笔记初稿 |\n| 20220220 | 《语言表达领域重要模型》笔记初稿 |\n| 20220116 | 《心理学重要模型》笔记初稿 |\n| 20220115 | 《金融学重要模型》笔记初稿 |\n| 20211226 | 《社会网络学重要模型》笔记初稿 |\n| 20211225 | 《认知心理学重要模型》笔记初稿 |\n| 20211220 | 《复杂性科学重要模型》笔记初稿 |\n| 20211119 | 《脑科学重要模型》笔记初稿 |\n| 20211112 | 《函数重要模型》笔记初稿 |\n| 20211109 | 《工程学重要模型》笔记初稿 |\n| 20211105 | 《系统论重要模型》笔记初稿 |\n| 20211104 | 《热力学重要模型》笔记初稿 |\n\n## 资料分享\n\n- [书籍] 斯科特·佩奇. 模型思维 [M]. 浙江:浙江人民出版社, 2019\n- [课堂] 陈平教授. 陈平的跨学科思维课 [OL]. Bilibili 付费课堂. 2021\n\n## 热力学重要模型\n\n- 熵：热力学中表征物质状态的参量之一，用符号 S 表示，其物理意义是体系混乱程度的度量。 \n\n\t> S 跟物体或者系统可能的状态数成正相关关系。\n\n- 熵与时间的关系：在封闭系统中，熵会随着时间推移而增加。\n\n\t> 补充几个概念：`孤立系统` 是没有物质交换且没有能量交换的系统。`封闭系统` 是没有物质交换但有能量交换的系统，比如年久失修的游泳池。`耗散结构` 可以从外界不断吸收能量、信息及物质，自身也可以不断地排出熵，比如河流。\n\n- 混乱是常态，有序是需要 `刻意营造` 的。`感知和选择` 是可以让系统变得更有序的。在系统中，感知和选择需要输入能量、信息（以及物质），然后排除熵。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Energetics-Perception-Choice.svg) 系统有序运作的原理\n\t{%endcenterquote%}\n\n- 人本身就是典型的耗散结构。生物学上，人是可以彻底重塑自己的，只不过需要的时间比预想的要长（四到七年）。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Energetics-People-DissipativeStructure.svg) 人的耗散结构\n\t{%endcenterquote%}\n\t\n\t- 启示1：管吃不管拉、管睡不管醒。因上努力，果上随缘。接纳熵的存在，不要阻止排出熵。\n\t- 启示2：依靠决心和自责是过不好这一生的，我们需要刻意改变耗散结构的输入。\n\t- 启示3：接纳抱怨、撒谎、懒惰、拖延，这些都是结果，关键在于改变系统输入，从而影响原因。\n\t- 启示4：已跌入封闭系统，如何减少熵？方法是 `感知和选择`。\n\n## 系统论重要模型\n\n- 系统：很多的实体他们通过相互联系，形成一个有运作规律的整体。\n\n\t> 比如生物系统、社会系统、机械系统、生态系统\n\n- 系统包含三大组件：`要素`、`关系`、`作用`，排列组合得到四种系统模型，分别是良性循环、恶性循环、贤者时刻、回归平庸。\n\n\t<table>\n\t<thead align=\"center\">\n\t<tr>\n\t\t<th>组件</th>\n\t\t<th>要素</th>\n\t\t<th>关系</th>\n\t\t<th>作用</th>\n\t</tr>\n\t</thead>\n\t<tbody align=\"center\">\n\t<tr>\n\t\t<td>正向</td>\n\t\t<td>正要素</td>\n\t\t<td>正关系</td>\n\t\t<td>快作用</td>\n\t</tr>\n\t<tr>\n\t\t<td>负向</td>\n\t\t<td>负要素</td>\n\t\t<td>负关系</td>\n\t\t<td>慢作用</td>\n\t</tr>\n\t</tbody>\n\t</table>\n\n\t- 正要素：正信息（让世界减少不确定性）、正能量、资产\n\t- 负要素：负信息（让世界变得更加混乱）、负能量、负债\n\t- 快作用：干一件事情立马得到反馈。\n\t- 慢作用：在实际生活当中，作用侧重关注慢作用，它具有 `滞后效用`。\n\n- 四种系统模型（构建系统论的根基）：\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/SysTheroy-Elements-Permutation-Combination.svg) 四种系统现象\n\t\n\t![](/images/Reading/Interdisciplinary-Thinking/SysTheroy-Elements-Permutation-Combination-Scene.svg) 均值回归现象\n\t{%endcenterquote%}\n\n\t- 良性循环：正要素 + 正关系，欧皇模式\n\t- 恶性循环：负要素 + 正关系，非酋模式\n\n\t\t> 破解恶性循环，方法是寻找杠杆解。\n\n\t- 贤者时刻：负要素 + 负关系\n\t- 回归平庸：正要素 + 负关系\n\n\t\t> 其中，贤者时刻、回归平庸两者属于均值回归现象。\n\n- 每个系统都存在一个 `命门/胜负手/关键变量`。\n\t- 突破：寻找杠杆解（抓主要矛盾的主要方面）\n\t- 闭环：利用杠杆解改善系统，让系统进入良性循环体系\n- 利用杠杆解改善系统：建立仪式，想法落实行动。其中仪式指代 `微习惯`，即从最小单元、最少起步成本的习惯做起；其次，是非意志力驱动做事，减少大脑意识消耗。\n\n\t> 利用 \"工程学重要模型\" 的拆解思维，微习惯也可以拆解成小目标，小目标还可以继续拆解成最小单元的 `Todo List`。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/SysTheroy-LeverageSolution.svg) 杠杆解改善系统\n\t{%endcenterquote%}\n\n- 一个拥有 `储蓄机制` 的良好系统，具备适应力、自组织与层次性三大特征。\n\t- 适应力：可理解为鲁棒性。\n\n\t\t> 模拟攻击：不断地主动让自己受小伤，留出时间让伤口恢复，再循环往复以训练适应力。比如健身、跳出舒适圈等。\n\n\t- 自组织：非必要干预系统，而是控制系统的输入。\n\t- 层次性：封装大大小小的子系统，模块化、标准化构建子系统。\n\n\t\t> 封装子系统：大事情分解成小事情，实现模块化管理；每一个模块拥有标准化的解决方案（类似设计模式中的模版方法），调度模块时无须再动脑即可执行。\n\n\t> 启示：一个人能长期坚持做自己觉得正确的事情，如何扛过漫长的滞后效应，真实情况并非决心、毅力、打鸡血，而是精神、情感、金钱上未雨绸缪的储蓄池。\n\n## 工程学重要模型\n\n- 艺术的核心是 `表达`，科学的核心是 `发现`，工程的核心就是 `实现`。\n\n- 工程学共通的方法论：\n\t- 行胜于言\n\t- 分解思维\n\t- 量化思维\n\t- 清单思维\n\t- 取舍思维\n\n### 行胜于言\n- 行胜于言，行胜于断（不在大方向做判断）\n\t- 工程学的搬砖思维：战术正确 >> 战略正确\n\t- 投资学的风口思维：战术正确 << 战略正确\n\n### 解构思维\n- 任何复杂事情都可拆分成易于操作的简单模块，然后逐项破解。\n- 纵观全局建立全局观（大目标），然后分解并聚焦局部（小目标），高度聚焦让我们更有把握完成事情。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Engineering-Deconstruction-Thinking.svg) 知行合一\n\t{%endcenterquote%}\n\n### 量化思维\n- 关键在于应该计算什么，而不是执着于计算结果。\n\n\t> 比如，开一家奶茶店能否盈利？我们可以从假设一个目标开始，先找 `最容易` 想到的变量（店租、工资、运营成本、售价等），通过 `叙事继续找` 更多变量（加盟费、设备、原料等），将所有变量构建模型，通过简单 `四则运算` 即可量化该事情。\n\n- OKR（Object and Key Results）工作法：结合了工程学分解与量化的思想，OKR 模型从上而下分解，大目标越分解越具体；从左到右则是不断做量化，目标就是让它变得可跟踪、可追溯。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Engineering-OKR.svg) OKR 工作法\n\t{%endcenterquote%}\n\n- 比如，构建个人精气神塑造计划，我们可设立关键结果 KR1 每周运动、KR2 每天按时睡觉、KR3 每周戒糖。KR1 可细分为工作日一次 Keep 简训，周六日有氧无氧结合训练。KR2 可细分工作日 23:45 前强制休息，周六日 01:45 前强制休息。KR3 可细分每周限定主动摄糖机会为两次。当然，实际操作中为了让目标收敛，我还设立了 “惩罚因子\"。\n\t\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Engineering-OKR-sample.png) OKR 工作法-个人实例\n\t{%endcenterquote%}\n\n### 清单思维\n- 清单思维（Check List）\n\t- 呈现优先级\n\t- 让人专注 -- 激光聚焦原理\n\t- 利于推敲\n\t- 节省脑资源：让费力不讨好的记忆 “外包” 出去\n\n- 个人列清单经验：将日常事务区分为动态清单与静态清单。\n\t- 动态清单：又细分为期限清单与周期清单，即有截止期限的任务也有周而复始的任务依时间顺序分布于时间线，区分期限时间与周期时间是方便归档与回顾，我们侧重把精力放于优先次序上，有条不紊地执行时间线任务即可。\n\t- 静态清单：更像是不考虑时间因素的 Todo list。\n\n- 当然，列清单是一种思维方法，更多列清单的方法论可参考 [子弹笔记：书写别样精彩的笔记自传](https://www.kofes.cn/2020/11/bullet-journal.html)\n\n### 取舍思维\n- 两点论（主要矛盾与次要矛盾，矛盾的主要方面与次要方面）与重点论（把握主要矛盾的主要方面）\n- 不可能三角：时间、质量、成本\n\t- 工程师：偏向于低成本与响应快\n\t- 艺术家：偏向于高质量\n\n## 函数重要模型\n- 函数：把一个变量跟另外一个变量一一对应起来的 `图`。\n\n\t> 数无形时少直觉，几何图形真好用。\n\n- 时间函数（时间序列）：提供我们穿透时间，预测未来的上帝视角。\n\n\t> 启示：一叶障目，不见泰山。普通人在生活中遇到的最大挑战是短视，近况会极大影响我们对未来的判断。\n\n\t- 高德纳曲线（Gartner Curve, Hipercircle 模型）：一项新技术出现，世界会因为这个技术过度乐观，但当项目落地一刻大家又会重新陷入过度悲观。随着时间推移，技术逐渐淡出人们视线但它又会逐渐成长起来。\n\n\t\t> 启示：诸如机器学习、区块链等新兴技术，坚信它们对生产力的提升是有帮助的，虽然技术不能一蹴而就、落地马上运作起来，但我们可以拉长战线、长期保持学习。\n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Interdisciplinary-Thinking/Fuction_Garther_Default.png) 新兴技术成熟度曲线\n\t\t{%endcenterquote%}\n\n\t- 社会毒打曲线\n\n\t\t> 启示：不要高估短期能发生的变化，不要低估长期能发生的变化。\n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Interdisciplinary-Thinking/Fuction_Garther_Social_Temper.png)  社会毒打曲线\n\t\t{%endcenterquote%}\n\n\t- 正（余）弦函数：波动是时间的伴侣，纵观时间线，发现黎明前的黑暗或者黑夜前的黄昏。\n\n- 指数函数：$y = a^x, a>0, a \\neq 1$\n\t- 开始缓慢，突然爆发。早期发展极其迷惑性。\n\t- 若其中一个 `关键链路` 断掉，整个增长模型即崩溃。\n\n- 对数函数：指数函数的反函数，$y=log_{a^x}, a>0, a \\neq 1$\n\t- 先快后慢，出道既巅峰。\n\t- 玻璃顶效应\n\t\t- 时间约束：外卖行业\n\t\t- 空间约束：共享单车行业\n\t\t- 青春约束：模特行业\n\t\t- 内在价值约束： 保健品行业\n\n- 四大人生职业类型：指数函数、对数函数、凸幂函数、凹幂函数\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Fuction_Career.png) 四大人生职业类型\n\t{%endcenterquote%}\n\t\n\t- 短期职业境遇：对数型，比如网红\n\t- 中期职业境遇：指数型，比如风口创业者\n\t- 长期职业境遇：凹凸幂律型，比如学者、专家\n\n## 脑科学重要模型\n- 三元脑模型：爬行脑、哺乳脑、人类脑\n\n\t<table>\n\t<thead align=\"center\">\n\t<tr>\n\t\t<th>三层模型</th>\n\t\t<th>结构</th>\n\t\t<th>功能</th>\n\t\t<th>备注</th>\n\t</tr>\n\t</thead>\n\t<tbody align=\"center\">\n\t<tr>\n\t\t<td>爬行脑</td>\n\t\t<td>脑干+小脑</td>\n\t\t<td>自动驾驶</td>\n\t\t<td>呼吸 (唯一可自主控制)、心跳、体温、情感、习惯、上瘾</td>\n\t</tr>\n\t<tr>\n\t\t<td>哺乳脑</td>\n\t\t<td>边缘系统</td>\n\t\t<td>快决策</td>\n\t\t<td></td>\n\t</tr>\n\t<tr>\n\t\t<td>人类脑</td>\n\t\t<td>新皮质</td>\n\t\t<td>慢决策<br>分析推理</td>\n\t\t<td></td>\n\t</tr>\n\t</tbody>\n\t</table>\n\t\n- 刻意练习：知行合一和不断进步的关键，在于利用更加容易控制的人类脑去驯化不可控的哺乳脑过程。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Neuroscience-Practise-on-Purpose.svg)  刻意练习\n\t{%endcenterquote%}\n\n### 宏观层面理解大脑\n- 人类脑：人类新皮质四大脑区，额叶、顶叶、枕叶、颞叶\n\t- `额叶`（Front lobe）：智慧、分析、判断、推理、社交、自控、学习、语言、洞察\n\n\t\t- `前额叶皮质`：计划、分析、判断、专注、社交、自控\n\t\t\t\n\t\t\t- 大器晚成：一定年龄才能发育成熟（15~25岁高速发展阶段）\n\t\t\t- 此消彼涨：\n\t\t\t\t- 人类前额叶皮质变得越来越专注优先发展更高维度的信息处理能力，为了更快更多处理信息，即有大量的神经元被用于理解信息、分析信息、判断信息。\n\t\t\t\t- 该区域发展自控的神经元资源就会被削减。\n\t\t\t\t\n\t\t\t\t\t> 启示：自控力发展慢，成熟就晚，越晚成熟对世界理解的维度也就越高。\n\t\t\t\n\t\t- `布洛卡区`：语言表达\n\n\t\t\t> 启示：布洛卡区也存在大量镜像神经元， 换一维度理解学习语言的本质就是模仿和社交。\n\t\t\n\t\t- `威尔尼克尔区`：理解语言\n\t\t\n\t\t- `前运动皮质` / `初级运动皮质`：运动区，直接控制脊柱。镜像神经元直接控制运动区。\n\t\t\n\t- `顶叶`（Parietal lobe）：统筹协调、整合信息、空间想象力、数学\n\t\n\t\t> 具备突然性和天然性，类似开窍、醍醐灌顶、大师我悟了。\n\t\n\t- `枕叶`（Occipital lobe）：视觉处理\n\n\t\t> 比如后脑勺被猛敲一下，马上感觉到眼前一黑。\n\t\n\t- `颞叶`（Temporal lobe）：语言理解、面部识别、洞察力、学习记忆\n\n\t\t<table>\n\t\t<thead align=\"center\">\n\t\t<tr>\n\t\t\t<th>部位</th>\n\t\t\t<th>功能</th>\n\t\t</tr>\n\t\t</thead>\n\t\t<tbody align=\"center\">\n\t\t<tr>\n\t\t\t<td>颞上回</td>\n\t\t\t<td>听觉处理和记忆</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>颞中回</td>\n\t\t\t<td>语言捕捉和记忆</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>颞下回</td>\n\t\t\t<td>人脸识别和记忆</td>\n\t\t</tr>\n\t\t</tbody>\n\t\t</table>\n\t\t\n\t\t- 启示1：人类大脑处理视觉的区域有枕叶和颞叶（颞下回），听觉的区域有颞叶（颞上回）。给别人讲大道理是很难听进去的，人言传不如身教，一图胜千言。\n\t\t- 启示2：唤醒脑区域越多，知识掌握越深刻，比如 `费曼学习法`（想要习得某项知识，可以学习教会别人）。\n\t\t\n\t\t\t{%centerquote%}\n\t\t\t![](/images/Reading/Interdisciplinary-Thinking/Neuroscience-Feynman.svg) 费曼学习法\n\t\t\t{%endcenterquote%}\n\t\n- 哺乳脑：边缘系统，负责长期记忆、情绪管理、性唤醒、嗅觉\n\t- `扣带回`：情感、焦虑、痛苦、自我调节、负面想象\n\t- `杏仁核`：恐惧、愤怒、兴奋、战/逃\n\n\t\t- 连接着人类脑、哺乳脑以及爬行脑，三大脑区的交汇点，是 \"理性\" 和 \"本能\" 的中转站。\n\t\t- 遇到恐惧时会切断人类脑的联系，只留下本能在发挥作用，即恐惧会让一个聪明人瞬间变成 “白痴”。改善方式只能是通过身临其境体验去训练杏仁核的反应模式，别无他法。\n\n\t\t\t> 比如要向学会炒股，可以先交学费，即亏后不清仓不急于止损（最好是亏到冒冷汗、背脊发凉恐惧的地步），直至熬回本并赚钱。\n\n\t- `基底神经节`：操作技巧、习惯养成、奖赏系统、上瘾系统\n\t- `下丘脑`：出汗、体温、口渴、血压、心率、饥饿、性、颤抖、养育本能、生物钟\n\n- 爬行脑 --> 小脑：条件反射、保持平衡、身体协调\n\t- `小脑`：条件反射、保持平衡、身体协调\n\t- `脑干`：睡意、警报、呼吸、消化、体温\n\n### 微观层面理解大脑\n- 神经元：神经元细胞，是神经系统最基本的结构和功能单位，分为细胞体（细胞核、细胞膜、细胞质）和突起（树突和轴突）两部分。\n- 髓鞘质：如果把大脑突触的轴突部分比喻成导线，那么髓鞘质就好像包裹在导线外层的绝缘体。\n- 已知神经元之间传递信号实际上是一种脉冲状的电化学信号，信号传递会随着距离逐渐衰减。髓鞘质能够大大减少信号的衰减，从而保证信号的传递稳定快速。\n\n\t> 若绝缘体越厚，神经元间电信号就能传播得越稳越快。反之，绝缘体破损 “漏电”，神经元间传递信号会漏电，也是造成 `注意力不足` 的生理因素。\n\n- 做一件事情会激发相关联的一批神经元，如果只激活一次则是一次连接而已。若要形成新的技能和习惯，必须不断重复，这样才能让一起被激活的神经元逐渐链接起来，最终形成稳固的链路。\n\t- 启示 1：刻意练习，有针对性的重复练习，并且关键步骤放慢速度。原理就是调度更多脑区，观察事物有利形成新的髓鞘质。\n\t- 启示 2：富兰克林训练法（自我训练方法）-- 横轴表示重复程度，纵轴表示选择专注。个人经验，在原方法的表格上多加入一个维度，即当完成某项能力训练时使用圆点打卡，圆点颜色深浅表示完成程度或者满意度，时刻警醒自我既要有量也要有质，防止后期陷入 \"计划绑架\" 的窘境，纯粹为了打卡而打卡。\n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Interdisciplinary-Thinking/Neuroscience-Franklin-Training.svg) 富兰克林训练法\n\t\t{%endcenterquote%}\n\n## 复杂性科学重要模型\n- 复杂系统：大量个体 `聚集` 后，通过个体简单运作产生群体复杂行为，并且能通过 `进化` 产生适应性的一种系统。\n- 复杂性科学：复杂性科学是运用跨学科方法，研究不同 `复杂系统` 之中的 `涌现` 行为和 `统一性` 规律。\n\n### 聚集\n- 聚集并不一定产生复杂系统，但复杂系统必定出现聚集现象。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Complexity-Science-Accumulation.svg)  复杂系统的聚集现象\n\t{%endcenterquote%}\n\n- 什么样的聚集行为不能产生复杂系统？\n\t- 集体智慧（ \"1+1>2\" 效果 ）：单体简单、规则简单深刻，多元化（互补）从而集体和谐。\n\t- 集体愚蠢（ \"1+1<2\" 效果 ）：单体复杂、各有想法，规则复杂肤浅，同质化（内耗）从而集体内卷。\n\n\t\t> 比如塞车现场、大学生求职等。\n\n- 蚁群算法：单体简单 -> 集体智慧，即简单规则不断重复，一定时间后聚集在最短路径上。\n\t- 数量为王：派大量蚂蚁\n\t- 规则简单：释放信息素\n\t- 行为简单：跟踪信息素\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Complexity-Ant-Colony-Algorithms.svg) 蚁群算法运作原理\n\t{%endcenterquote%}\n\t\n- 聚焦四段论：\n\t- Step.01：清理念头 `半小时`\n\t- Step.02：忘我聚焦 `两小时` -- 心流状态\n\t- Step.03：刻意休息 -- 来之不易的娱乐时刻，好好规划尽情放松\n\t- Step.04：惯性工作 $x$ 小时\n\t\n### 涌现\n- 涌现：随着成员数量增加，链接数会不断增加，而增加的链接度超过某一临界值时，就会出现涌现。\n\t- 单体数量够多，单体之间有链接，链接数足够多时，才会出现涌现。\n\n\t\t> 比如，大脑中的足够多的神经元（单体）聚集起来，并相互链接，从而产生意识/智慧。\n\t\t\n\t- 涌现具有层次性，逐层递进，逐层涌现。\n\n- 启示：最小内核决策模型\n\t- 投入产出比\n\t- 成本收益比\n\n### 迭代\n- 迭代：任何复杂事情，不能一蹴而就，理性接受从一个相对粗糙的版本不断优化变成一个相对完美的版本。\n\n\t> 软件开发模式中的快速原型模式。\n\n\t- 最小可用产品\n\t- 产品市场契合点\n\n- 启示：坚毅的本质和精髓\n\t- 钢笔写目标，铅笔画道路\n\t- 道路很灵活，目标很坚定\n\n- 启示：现今很多人在画道路的过程中会放弃（原地踏步），理解真实情况的迭代很重要。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Complexity-Iteration.svg) 真实情况的迭代\n\t{%endcenterquote%}\n\n- 迭代的相反面：顶层设计、大力出奇迹、集中精力办大事\n\n\t> 比如中国芯片卡脖子问题。\n\n### 适应性\n\n- 适应性循环：伤害 -> 恢复 -> 变强，比如锻炼身体、锻炼意志，甚至锻炼一个国家。\n\t- 走出舒适圈但别走太远：\n\n\t\t- 厚积薄发：成果圈远小于能力圈\n\t\t- 适度挑战：成长圈大于能力圈，即跳出舒适圈\n\t\t- 不要作死：不要越过死亡圈，面临多种挑战，遭受多重失败打击（杠杆过大）\n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Interdisciplinary-Thinking/Complexity-Adt-Comfort-Zone.svg) 适度走出舒适圈\n\t\t{%endcenterquote%}\n\n\t- 周而复始寻找涌现时刻：人生就是不断在寻找擅长、喜欢以及在市场赚钱的事物，三种事物交汇点就是人生当中既能让你爽又能赚钱，且能发挥自身能力的最佳生活体验。但艰难的是，绝大部分时间我们都在三种状态下左右横条，历经艰辛、不下牌桌，我们终究会将找到最佳平衡状态。\n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Interdisciplinary-Thinking/Complexity-Skills-Enjoy-Earning.svg) 人生需要一个涌现时刻\n\t\t{%endcenterquote%}\n\n## 认知心理学重要模型\n\n> 参考书籍：罗伯特·索尔所.《认知心理学》[M]. 上海人民出版社, 2019\n\n- 认知心理学：对于自我和世界认知的感觉、记忆、理解以及思考的全过程进行研究的学问。\n\n- 分析框架：人类记忆处理过程模型，人类在接受刺激与产生回应之间的一系列内在处理过程的步骤分解。\n\t- 首先，一个外部刺激会通过人类感觉器官进入 `短时记忆存储器`。\n\t- 然后，短时记忆在短时间内得到复述，那么这个记忆有可能进一步保留到 `长时记忆存储器`；相反，不在短时记忆存储被及时复述，它将进入 `消退记忆存储库`。\n\t- 整个过程又受到 `控制处理器` 的监工，我们的意识、反思以及注意力分配全部都在该功能区域实现的。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/CognitivePsychology-Human-memory-proc.svg) 人类记忆处理过程模型\n\t{%endcenterquote%}\n\t\n\t> 通常地，长时记忆认为是永久的，短时记忆不超过 30 秒，感觉记忆只有几百毫秒。\n\n### 感觉存储\n- 记忆存储大漏斗\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/CognitivePsychology-Feel-storage.svg) 感觉存储大漏洞\n\t{%endcenterquote%}\n\n- 语义屏蔽：即选择性充耳不闻、带着有色眼镜看世界\n\n\t> 启示：进入新行业、新公司，多使用它们日常生活的常用词汇。比如互联网行业（日活月活转化率、痛点赋能最小闭环）、金融行业（北上南下）等。其中，日常生活词汇可以从行内人士聚会中习得。\n\n### 短时记忆\n- 詹姆斯记忆系统模型\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/CognitivePsychology-James-memory-model.svg) 詹姆斯记忆系统模型\n\t{%endcenterquote%}\n\t\n\t> 启示：过脑子极简原理，自身不太在意但又不得不记住的事情，可尝试 3 秒内默默进行 1 次复述，然后 12 秒内默默进行 2 次复述。\n\n- 首因近因效应 / 雷斯多夫效应：比如背单词\n\t- 首因近因效应：总是记住字母表开头（或结束）开头的几个单词，比如 abandon\n\t- 雷斯多夫效应：词汇表中较怪异的单词容易被记住\n\n- 峰终定律\n\t- 人们对一段体验的评价（好/坏）由两个因素决定，一个是过程中的最强体验，一个是结束前的最终体验。\n\t- 本质不是平均发力，而是力气要用在刀刃上，营造巅峰体验，同时保证过程中不要捅娄子留下差印象。\n\n\t> 启示：安排约会、组织活动、做好一款产品等，侧重设计开头和结尾的仪式感和惊喜感，以及避免中间过程中出现极糟糕的体验。\n\n### 控制处理器\n- 选择性注意：`意识控制` 着你的感觉系统，`刻意聚焦` 在一些你关注的东西上的最好表现。\n\n\t> 启示：团队管理中如何帮助下属成长 `16字要诀`。我说你听，你说我听，我做你看，你做我看。\n\n- 刻意选择 V.S. 随意选择\n\n\t> 启示：每个都可拥有一种 \"探照灯\" 模式，有人的随处乱摆，也有人类似激光一样长时间、高度聚焦某一处，产生惊人效果。不同探照灯模式很大程度决定了人生效率。\n\n- 意识的研究\n\t- 意识的组成：`AWAREness` 模型，分别由注意、觉醒、构筑、知识以及感情五个层面构成。\n\t\t\n\t\t- 注意（Attention）：类似 \"探照灯\"，即有聚焦程度区分（激光聚焦对标刻意选择，远光灯照射对标模糊选择）、也有照射范围的区分（内观、外观）\n\t\t- 觉醒（Wakefulness）：大脑觉醒、清醒的程度\n\t\t- 构筑（Architecture）：承载我们意识的具体大脑位置\n\t\t- 知识（Recall of Knowledge）\n\t\t\t- 自我知识：自我觉察、自我认知（年轻时侧重关注）\n\t\t\t- 世界知识：除了我以外的所有知识\n\n\t\t\t> `现象`：学生时代世界知识越丰富、涉猎范围越广，自我知识相对显得匮乏。\n\t\t\t> `启示`：真实的高手不需要什么都知道，他只需非常清晰地知道自己能干好什么以及干不好什么，然后保持高度聚焦。\n\t\t\n\t\t- 感情（Emotion）：意识通常掺杂着情感的底色，我们观察任何事物时都会带着一种原始的厌恶和喜欢的感情在里面，为此情感是意识最不为人知的组成部分。\n\t\n\t- 意识的功能\n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Interdisciplinary-Thinking/CognitivePsychology-Awareness-function.svg) 意识的功能\n\t\t{%endcenterquote%}\n\t\n\t\t- 自我监视：元认知（自省），可以无限叠加层次性（套娃 Buff）。系统的每一层次提升就是一次维度的提升，每叠加一个层次都能产生巨大的升级威力。\n\n\t\t\t[例] 研究做一张桌子 -> 研究做一张桌子的方法 -> 研究做桌子的方法的方法\n\n\t\t\t{%centerquote%}\n\t\t\t![](/images/Reading/Interdisciplinary-Thinking/CognitivePsychology-Metacognition.svg) 元认知模型\n\t\t\t{%endcenterquote%}\n\n\t\t\t> 启示：提升自省能力的方法 -> 丰田5WHY分析法，了解一件事情发生背后的原因可连问多个为什么（刨根问底）。\n\n### 长时记忆\n\n{%centerquote%}\n![](/images/Reading/Interdisciplinary-Thinking/CognitivePsychology-Long-term-memory.svg) 长时记忆\n{%endcenterquote%}\n\n- 外显记忆：陈述性记忆，通常存留在大脑新皮质区域，只能通过实际去做才能知道如何操作。\n\t- 情景记忆：该类记忆细节很容易改变、容易遗失，随着时间推移，我们有时候会不自觉地替换其中的元素。\n\n\t\t> 启示：经验主义，调度情景记忆，会随着时间推移而越发不靠谱。\n\n\t- 语义记忆：对词汇、概念以及抽象概念的记忆。\n\n\t\t> 启示：凭借方法论做事，调度语义记忆，随着时间推移但一直保持稳定发挥。\n\n- 内显记忆：非陈述性记忆，通常存留在大脑的边缘系统和小脑。\n\n- 记忆的漏洞：眼见不一定为实，我们会 \"篡改世界\"，这也是我们难以客观理解世界的根本原因。\n\n\t- 省略（Dmission）：本能地把不合逻辑或者不符合我们预期的信息省略，比如推卸责任。\n\t- 合理化（Rationalization）：不自觉添加信息来帮助解释某些不协调的地方。\n\t- 信息转换：把不熟悉的词汇替换成熟悉的词汇。\n\t- 顺序转换：把印象深刻的事情提前，把不太熟悉的事情置后了。\n\t- 个人态度：个人价值观决定回忆的情节。\n\n\t\t> TVB剧集《大时代》中丁蟹，把该特性表现得淋漓尽致。\n\t\n\t- 自我记忆图式：记忆偏差，跟 “我” 有关的记忆难度最低。\n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Interdisciplinary-Thinking/CognitivePsychology-PersonalMemoryDiagram.png) 自我记忆图式\n\t\t{%endcenterquote%}\n\n\t\t> 启示：想要让自己（对方）记住一个知识点，就要思考怎么把这个知识跟自己（对方）联系在一起。\n\n- 遗忘\n\t- 艾宾浩曲线\n\t- 耶克斯道森法则：倒 U 型曲线，适度承压是唤醒大脑机能的最佳法则。\n\n### 认知系统\n- 认知系统的形成：人类从接触事物到产生智慧中间会出现以下层级\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/CognitivePsychology-CognitiveSys.svg) 认知系统的形成\n\t{%endcenterquote%}\n\t\n\t- 启示1：清晰辨别是一切的基础，注意力不集中、诅丧、焦虑、懒散、空虚等，都是我们大脑丧失了清晰辨别的能力，而陷入一种 `大脑模糊状态`。\n\t- 启示2：如何让大脑变得清晰：会谈使人敏捷，书写使人精确。\n\t\t- 会谈不局限于跟别人谈，也可以跟自己谈\n\t\t- 书写不局限于文字书写，也可以边写边画边记忆（费曼学习法）\n\n## 社会网络学重要模型\n- 三种人类通讯网络模式 -- Paul Baran\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/SocialNetworking-Communication-network.svg) 人类通讯网络模式\n\t{%endcenterquote%}\n\n\t- 中心时网络：所有节点指向一个核心节点的网络构成模式。\n\t- 分散式网络：所有节点都会指向一个局部中心节点，局部节点再指向最终的中心节点的模式。\n\t- 分布式网络\n\n### 结构洞\n-  结构洞（Structural hole）：两个群体之间缺少联系，中间会出现一种空洞。若有一个人把两团体联系在一起补充该空洞，这个人即占据了结构洞的位置。\n\n\t> 启示：作为刚入职的年轻人，有能力、有机会占据传统大机构里面向年轻人沟通的位置，在该机构里会比同龄人得到更多晋升机会。比如中国联通、招商银行的 Bilibili 运营媒体人。\n\n### 中心度\n- 中心度（Centrality）：衡量节点重要性指标\n\t- 度中心度：联系数量\n\t- 特征向量中心度：联系质量\n\n\t\t> 比如：某人 A 中微信好友 100 个都是贷款中介，某人 B 中微信好友 50 个都是私人银行客户，两人链接的财富程度，A 的特征向量中心度较 B 高。\n\n\t- 传播中心度：影响范围\n\n\t\t> 比如：自己是 B 站 Up 主或者认识众多 Up 主，那么后者的传播中心度更大。\n\n\t- 中介中心度：类似结构洞，处于协调网络的独特位置。\n\n\t\t> 比如：黑帮的管理模式，幕后大佬 --> 大头目 --> 小头目。幕后大佬的连接数虽少，但连接质量及影响范围很大。\n\t\n- 中心度的具体量化方法\n\n  {%centerquote%}\n  ![](/images/Reading/Interdisciplinary-Thinking/SocialNetworking-Centrality-Quantification.svg) 中心度的具体量化方法\n  {%endcenterquote%}\n\n  <table>\n  <thead align=\"center\">\n  \t<tr>\n  \t<th width=\"25%\">度量方式 \\ 节点</th>\n  \t<th>A</th>\n  \t<th>B</th>\n  \t<th>C</th>\n  \t<th>D</th>\n  \t<th>E</th>\n  \t</tr>\n  </thead>\n  <tbody align=\"center\">\n        <tr>\n  \t<td>度中心度</td>\n  \t<td>8</td>\n  \t<td>2</td>\n  \t<td>4</td>\n  \t<td>3</td>\n  \t<td>2</td>\n        </tr>\n  \t<tr>\n  \t<td>特征向量中心度</td>\n  \t<td>8</td>\n  \t<td>2</td>\n  \t<td>4</td>\n  \t<td>$\\color{green}{11}$</td>\n  \t<td>$\\color{green}{10}$</td>\n  \t</tr>\n  \t<tr>\n  \t<td>传播中心度</td>\n  \t<td>8</td>\n  \t<td>12</td>\n  \t<td>7</td>\n  \t<td>6</td>\n  \t<td>2</td>\n  \t</tr>\n  </tbody>\n  </table>\n\n  - 特征向量中心度：将某节点相邻连接的节点权重相加起来。\n  - 即传播中心度：将某节点的一二度联系人的数量相加起来。\n\n\t> A -> B：即 A 是 B 的一度联系人；A 的子节点 -> B：A 的子节点是 B 的二度联系人。\n\n- 启示：面对同样的人群，从不同需求的角度来看，对人群中不同人重要性评估也是不一样的。比如加入 xx 微信群，目标不同服务人群也不同。\n\t- 发言质量高 <-- 了解信息\n\t- 最有钱的人 <-- 寻找理财客户\n\t- 群主 / 位高权重的人 <-- 结交人脉\n\t- `?` <-- 寻找工作机会\n\n\t\t> 思考：结识什么样的人，对寻找工作有帮助？ -- `弱联系`\n\n### 弱联系\n\n{%centerquote%}\n![](/images/Reading/Interdisciplinary-Thinking/SocialNetworking-Weak-ties.svg) 强联系 V.S. 弱联系\n{%endcenterquote%}\n\n- 弱联系：认识但不熟（思想、思维碰撞）\n\n\t> 关系不强，力量不弱\n\n- 强联系：认识且很熟（价值观趋同、亲朋戚友、同事同学）\n\n\t> 物以类聚，人以群分\n\n- 启示：如何高效发展弱联系，使得边际效用最大化\n\t- 不要 \"蜻蜓点水\" 般认识人\n\t- 多结识 \"结构洞\" 类型的人\n\n### 人际网络\n- 小世界网络：正是由于小世界现象的发生，结构洞的人才显得尤为重要。\n\n\t> 比如，学术圈、币圈、潮玩圈\n\n- 无尺度网络：链接呈现幂率分布，而非正态分布，即赢家通吃效应。\n\t- 正态分布：大多数节点拥有相同链接数，不存在拥有大量链接的节点。\n\t- 幂率分布：大多数节点只拥有少数链接，少数枢纽拥有大量链接。\n\n- 无尺度网络现象的出现条件\n\t- 处于不断扩张的状态\n\t\n\t\t> 比如，高速扩张的公司会不断招人、人们领域会不断有论文出现等。\n\t\n\t- 逐渐链接：新加入的节点会自发性地向高质量节点链接\n\n\t\t> 思考：先发优势节点会成为最大受益方，如何打破赢家通吃的诅咒？\n\t\t> 方案：`适应度模型` / `价值网络模型`\n\n- 适应度模型：进入一个行业想要打破论资排辈的现象、弯道超车，则需要：\n\t- 跟前辈维度完全不同的玩法，带来全新吸引力。也就是网络中吸引新进节点，让它们放弃追逐旧节点链接的王者。\n\t- 这种创新不必从头来过，可跨界融合。\n\n\t\t> 比如，剧本杀=狼人杀+编剧；文和友=餐饮业+博物馆\n\n- 价值网络模型：很多成熟的公司在面临技术变革时会遭受失败，其原因是成熟的上下游关系，越成熟它们的自我保护效应愈加明显。\n\n\t> 启示：改变一个节点难以改变整个网络形态，需要同时改变很多重要节点。\n\n- 启示：当我们 `从无到有` 创造新事物来逆袭时\n\t- 适应度模型，在微观层面创造体验来逆袭。\n\t- 价值网络模型：在宏观层面抓住红利（技术变革、市场变革等）来逆袭。\n\n### 基本再生数\n- 比如疾病传播，感染者会让多少其他人受到新的感染，若基本再生数：\n\t- 大于 1，则疾病会蔓延\n\t- 小于 1，则疾病会消亡\n\n### 差序格局\n- 差序格局：把中国传统社会每个人的社交关系比作一个水波纹、涟漪式扩散的同心圆，越接近中心越亲密，反之则越疏远。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/SocialNetworking-Diff-Order-Pattern.svg) 差序格局\n\t{%endcenterquote%}\n\t\n\t- 家人连带关系，遵循需求原则\n\t- 熟人关系，遵循人情原则\n\n\t\t> 启示：现代城市年轻人日常关系里占比最大的一层关系，比如同学关系、同事关系等。处理这一层的关系技巧在于，既要把账算清楚，也要讲情感以兄弟姐妹相称，互相之间相互帮助则欠下了人情，还人情过程便建立起私交。\n\n\t- 认识关系，遵循公平原则\n\n- 启示：\n\t- 从陌生人发展到认识关系，可遵循公平则，讲究对等交换。\n\t- 从认识关系发展到熟人关系，超出公平原则，给予对方超额回报，留下人情债。\n\t\n\t\t> 人情债：`索取前` 先给予 `适度慷慨`，实际上是帮助你在跨越社交圈或者阶层时最有力的武器。\n\t\n### 非正式组织\n- 非正式组织：以情感、兴趣、爱好和需求为中心，没有正式文件规定的自发形成的社会组织。组织成员会自觉维护非正式组织的声誉。\n\n\t> 启发：既要看到组织的阳面，也要留意组织的阴面。比如校友群、健身群、没有老板的群等。\n\n\n## 金融学重要模型\n### 宏观经济\n- 宏观经济学入门推荐短片：《[经济机器是怎样运行的](https://www.bilibili.com/video/av6496369)》\n\n- 本章节更偏向于 \"非专业人士\" 的金融入门课\n\n\t<table>\n\t<thead align=\"center\">\n\t\t<tr>\n\t\t<th>专业人士</th>\n\t\t<th>非专业人士</th>\n\t\t</tr>\n\t</thead>\n\t<tbody align=\"center\">\n\t\t<tr>\n\t\t<td>金融机构如何运作<br>金融工具如何开发<br>给专业人士听的课</td>\n\t\t<td>日常生活的金融行为<br>我们所处的金融环境<br>我们应具备的金融思维</td>\n\t\t</tr>\n\t</tbody>\n\t</table>\n\n#### 经济增加要素\n- 经济增加的组成三要素\n\t- 生产率的提高\n\t- 短期债务周期：5 ~ 8 年\n\t- 长期债务周期：75 ~ 100 年\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/BankingScience-Economic-Composition.png) 瑞达利欧增长曲线\n\t{%endcenterquote%}\n\n#### 经济运作单元\n- 经济运行的最小单位是 `交易`\n\t- 购买方：货币、信用 \n\t- 服务方：服务、商品、金融产品 \n- 众多 `交易` 聚合成 `市场`，不同市场又聚合在一起形成 `经济体`。比如医疗市场、教育市场、股票市场、能源市场、消费市场等。\n\t- 它们犹如齿轮，一环扣一环，牵一发动全身\n\t- 市场运作经常会出现 `过冷或过热` 的现象，或者出现 `大量资金分配失衡` 的现象\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/BankingScience-Market-Regulation.svg) 市场调控\n\t{%endcenterquote%}\n\n#### 市场调控\n- 税收：政府减税，企业压力变小、人民可支配收入增多、政府减少基建的投入\n- 国债：卖给人民、卖给其他国家（美国卖国债实质是剥削全世界的方式之一）\n- 利率\n\t- 降低：市场上流通的钱变多，经济过热\n\t- 升高：市场上流通的钱变少，经济过冷\n- 发行货币：俗称 `放水`。比如央行降低利率；大量印钞，市场钱变多，借钱相对更容易。为此，吸引更多人借贷，进行投资消费和扩大产能。\n\n\t> 低息借贷，用来投资高息生意。比如投资房地产，稳赚不赔。\n\t\n\t- 虚假繁荣：拿到贷款的企业拼命贷款到处花钱，导致 \"虚假繁荣\" 现象。\n\t- 推动创业：投资人手头的钱也有很多，有利于推动创业。\n\t- 乐观预期：创业更容易拿到投资，做事不在乎成本，更在乎将来收益，形成 \"乐观预期\"。\n\t- 过度加杠杆：\"乐观预期\" 现象更让企业过度借债、过度融资。别人借了我不借就会落下，导致消费和投资的 `军备竞赛`，群体透支未来，往往超出生产力发展一大截。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/BankingScience-Excessive-leverage.png) 过度加杠杆\n\t{%endcenterquote%}\n\n#### 杠杆\n- 杠杆：金融工具对于实体经济最大作用是加上杠杆（加倍数），使得四两可以拨千金，让具备生产力的人在短时间内加速发展、弯道超车比自己资本多很多的人。\n\n\t> 比如：贷款买房、买车，消费贷款，融资，招帮手做事情，造势等。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/BankingScience-Leverage.svg) 杠杆\n\t{%endcenterquote%}\n\t\n- 用途：\n\t- 不良杠杆：没有提高生产力，无法在未来增加你的收入\n\t- 良性杠杆：扩大生产力，换取远高于利息的收益\n- 支点：\n\t- 好的支点：一个能够稳定地低风险地获得收益的资产或能力\n\t- 不好支点：看似拥有但实际上能力支配不了\n\n\t\t> 比如：买了某公司的股票，但对于公司的业务逻辑、潜在风险、实际控制人的想法/性格一无所知，最终凭运气赚的钱会凭实力亏回去。\n\n- 长度：加杠杆的倍数\n\n- 启示\n\t- 不要让债务的增长速度超过自己的收入。\n\t- 不要让收入的增长速度超过生产率。\n\t- 不要拿远超自己能力之外的薪资收入，让薪资收入永远比自己的能力增长慢一拍。\n\t\n\t\t> 这不就是我们追求的：钱多事少离家近？\n\t\t\n\t\t- 原因：收入=货币+信用，花钱并不全是我们的钱，还有信用。比如刷信用卡，公司的隐性福利，房价上涨、股票上涨的钱，以为自己赚到但实际没有变现的钱。\n\t\t\t\n\t\t- 后果：加在我们身上的杠杆，若自身实力不足（支点不牢固），会使得君子立于为危墙之下。\n\t\t\n\t- **尽一切努力提交生产率**。\n\n### 微观经济\n- 个人与金融系统之间最简单的关系\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/BankingScience-Person&FinancialSys.svg) 个人与金融系统之间的关系\n\t{%endcenterquote%}\n\n- 金融合约内在运作过程\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/BankingScience-Financial-Contract-OperProcess.svg) 金融合约内在运作过程\n\t{%endcenterquote%}\n\n\t- 风险\n\t\t- A 与 B 之间的金融合约：股权类型 / 债券类型？\n\t\t- A 使用的杠杆是否超出了自身的能力承受范围？\n\t- 风险时间补偿：资金 2 > 资金 1\n\n- 金融三要素：杠杆、时间、风险\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/BankingScience-Finance-3elems.svg) 金融三要素\n\t{%endcenterquote%}\n\t\n\t- 启示1：金融可实现 `时间轴上移动我们的财富`。\n\t\t- 没钱的时候，从未来更有钱的自己那里借钱，比如 `信用卡`。\n\t\t- 让现在赚钱能力很强的自己，从现在开始就给未来即将退休的自己存钱，比如 `养老保险`。\n\t- 启示2：金融工具可把时间带来的风险和未来的收益进行计价，再打包融进金融合约以加速社会资金在时间轴上流动。 \n\t- 启示3：现在有能力或宣称自己有能力的人，可运用杠杆把自己未来的信用投射到现在，让现在可拥有加倍的资源发展。\n\t\n- 折现值（Present Value, PV）/ 复利：如何给未来定价，即风险和未来收益计价方法。\n\n\t$$PV = \\frac{CF_{1}}{(1+r)^1} + \\frac{CF_{2}}{(1+r)^2} + \\text{...} + \\frac{CF_{n}}{(1+r)^n}$$\n\t\n\t- CF：未来某段时间的净现金收入\n\t- r：现在的利率\n\t- n：对应时间段\n\n- 风险：风险收益流动性 -- `投资不可能三角`\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/BankingScience-Risk-return-Liquidity.svg) 投资不可能三角\n\t{%endcenterquote%}\n\t\n- 风险收益模型\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/BankingScience-Risk-Return-Model.png) 风险收益模型\n\t{%endcenterquote%}\n\n\t- $\\color{gray}{灰线}$：描述做任何事情，随着风险提高，对应市场通常会给出更高收益。\n\t- $\\color{green}{绿线}$：每一处 `正态分布曲线` 表示处在金融系统中的人，实际的收益分布概率。\n\t\t- 高风险高收益是概率问题\n\t\t- 低风险不一定低收益，高风险不一定高收益。极端情况下，A、B 承担风险与收益不匹配\n\n- 实际投资中的风险收益模型：金融市场核心玩家高度垄断\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/BankingScience-Act-Risk-Return-Model.png) 实际投资中的风险收益模型\n\t{%endcenterquote%}\n\n## 心理学重要模型\n### 原因论\n- 原因论（弗洛依德）：个人成长环境，决定了身上坏习惯、个人性格特点\n\t- 弊端：回忆童年寻找问题根源，促使您探索原生家庭有什么问题、研究自己的成长环境有什么问题等。\n\t- 启示：看起来很精彩，但对改变自己并无多大用处。\n\n### 目的论\n- 目的论（阿德勒）：每个人现在的问题之所以会发生，其实是因为它符合你的某种内在目的。\n\n\t> 推荐岸见一郎的《被讨厌的勇气》，本书详细讲解了阿德勒的主要思想。\n\n\t- 比如：社交恐惧症 --> 找工作不顺利\n\t\t- 原因论认为，小时候父母没有提供足够的社交环境、在学校被孤立、老师没有正面引导等。\n\t\t- 目的论认为，社恐是为了实现某种目的（逃避失败）。这样就能名正言顺宅在家里，不用面对求职被拒绝的痛苦，朋友、家人坦然接受，成为自己推脱责任的 \"挡箭牌\"。\n\t- 局限：太过强调主观能动性，忽略了客观环境的影响。\n\t- 启示：任何经历本身不是成功或者失败的原因，我们并非因所谓的心理创伤而痛苦，事实上我们会从 **经历中发现符合自己目的的因素**。决定我们的不是过去的经历，而是 **自我赋予经历的意义**。\n- 自卑感：广义的不满足 --> 推动人类社会进步的动力\n\t- 类型多种多样。\n\t- 当我们意识到自己没有其他事物那么强大时，自卑感就会产生。\n\t- 自卑会产生不满（现状），不满就会产生改变现状的可能性。\n- 自卑情结：一个人面对棘手问题时，感觉自身再努力也没用。顺利成章 `逃避`，转而把 `精力转移` 至鸡皮蒜毛的事情上获得 `优越感`。比如偶像打榜、网上键盘侠、杠精。\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Psychology-Life-Process.svg) 自卑感 & 自卑情结\n\t{%endcenterquote%}\n\t\n- 启示：一个人如何改变自己行为，超越自卑，尤其不要变成自卑情结。--> 人类可创造性地重新解读自己 `过往经历`，改变自己的思想，从而改变自己的行为。\n\t- 起点很低，历经磨难更容易产生向上动力。\n\t- 困扰我们的并不是客观事实，而是我们主观上的解释（发挥主观能动性）。\n\n\t\t> Tips：人类记忆并不是客观的，而是主观的。相由心生，心念一变或许对同一件事的解读就不一样。\n\n- 延伸：身体疾病都有它的目的，比如我有 a 所以我无法做到 b、想到我有 c 对自己有什么 `好处` 等，即 **人无完人，事无完美**，可理解为一种释怀。\n\n\t> 所有 `好处` 归纳一个共同点：避免在与他人的关系中受伤。\n\n- 人际关系：人际关系是一切烦恼和不良情绪的源头。\n\n\t> 解决方案：赋予被讨厌的勇气，成为 `自由独立` 的人，主要代价就是承受被人讨厌的勇气。\n\n- 切割人生课题模型\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Psychology-Life-Subject.svg) 切割人生课题模型\n\t{%endcenterquote%}\n\t\n\t- 比如：男生向女生表白，男生关注点 100% 放在是否表白上，100% 忽略对方是否接受的要素。\n\t\t- 表白是男方的课题，接受是女方的课题。\n\t\t- 男生特别在意女方是否接受表达，即等于试图干预别人的人生课题。\n\t\t\n\t\t> 启示：干预别人的人生课题，注定会给自己带来烦恼。\n\t\n\t- 人生要获得安宁，必须绕过一个 `大闭环`。然而，他人影响的因素过大，大闭环形成的概率极低。\n\n\t\t> 启示：自己的幸福由自己来闭环。\n\t\t\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Interdisciplinary-Thinking/Psychology-Happiness-Self-Circulation.svg) 幸福由自己来闭环\n\t\t{%endcenterquote%}\n\n\t- 判断是谁的课题：`最终后果由谁承担`\n\n\t\t> 比如：孩子不好好读书是谁的责任，直接责任是孩子，间接责任是父母。\n\n- 共同体：个人跟世界的关系\n\n\t- 原则：以直报怨，以德报德。以 `公平合理方式` 回报别人对你的 `恶行`，以 `善行` 回报别人对你的 `善行`。\n\t- 同理心：天然信任感，基于共同体产生的联系感。\n\n\t\t> 启示：既有被讨厌的勇气，也需要敢于信任的勇气。信任他人，持有同理心，可缓解切割课题带来的孤立感。\n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Interdisciplinary-Thinking/Psychology-Human-Community.svg) 共同体\n\t\t{%endcenterquote%}\n\n### 马斯洛需求金字塔\n\n{%centerquote%}\n![](/images/Reading/Interdisciplinary-Thinking/Psychology-Hierarchical-theory-of-needs.svg) 马斯洛需求层次模型\n{%endcenterquote%}\n\n- 自我实现者特征：辩证统一思维\n\t- 对现实的感知（洞察力）\n\t- 对现实的接受：对于自然现象的坦然接受。\n\t- 以问题为中心：生活中总是充斥着需要解决的任务、问题。\n\t- 独处能力\n\t- 高峰体验\n\t- 自主性：独处能力强，强大的内心，不怕孤独感。\n\t- 幽默感：喜欢拿自己开玩笑。\n\t- 初心\n\n- 启示：正确的反面是谬误，但一种深刻真理的反面，可能是另一种深刻的真理。\n\n\t> 衡量一个人是否拥有成熟大脑的最关键标志。\n\n### 积极心理学\n- 积极心理学：让没有疾病的普通人，可以过上更有活力、更有创造力、更加发挥自己潜力的生活。\n\n\t> 积极心理学 -- 人类的幸福课\n\n- 积极心理学领域鱼龙混杂，选择入门的教材非常重要！\n\t- 马丁塞利格曼《真实的幸福感》、《活出最乐观的自己》\n\t- 米哈里·切克森米哈赖《心流》\n\t- 本·沙哈尔《哈佛幸福课》\n\t- 彭凯平《活出心花怒放的人生》\n\n- 心流：适度承压，适度发挥\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Psychology-Onflow.svg) 心流模型\n\t{%endcenterquote%}\n\n\t- 彭凯平\n\t\t- `毫无章法` 的不闭环工作很难产生心流\n\t\t- `有头有尾` 的能闭环工作可能产生心流\n\t\t- 启示\n\t\t\t- 事情再多也要把它们切割成块，设定清晰目标，一个时间只闭环一件事。\n\t\t\t- 压力再大也不要想着一次性搞定所有艰难工作。\n\n\t- 米哈里\n\t\t- 精神熵：信息时代对人类最大影响是大量信息冲击，使得失去了内心秩序。\n\t\t- 心流状态：心流状态就是人类大脑进入一种持续创造 `负精神熵` 的状态。\n\n\t\t\t> 负精神熵：物我两忘，伴随高度兴奋感与充实感。\n\n## 语言表达领域重要模型\n### 金字塔模型\n\n- 金字塔模型：如何分，而非总分总\n\t- 最关键信息（中心）\n\t- 支撑的项目（论据）\n\t- 数据 / 图表 / 例子 / 比喻\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Linguistics-Pyramid-Model.svg) 金字塔模型\n\t{%endcenterquote%}\n\t\n- 启示1：将所有语言浓缩为一个记忆项目（`中心思想`），并不断对这个核心记忆项目进行 `解释和重复`，通过 `更换角度复述` 让它得到强化。\n\n\t> 符合大脑固有的理解习惯。\n\n- 启示2：金字塔重要原则，先说结论并强调这一结论，然后整场谈话围绕这个核心展开论述，以 `显得有逻辑`。\n\n\t> 注：显得有逻辑，并不一定有逻辑（需要逻辑证明）。\n\n- 实操\n\t- 拿起纸笔将 `零散想法` 记录下来；\n\t- 思路整理、逻辑推敲，将 `混乱信息` 分门别类、归纳总结为 `有序信息`；\n\t- 排列组合过程中，通常会发现自己没想到的 `逻辑漏洞` 或提炼出 `新主题`。\n\n- 金字塔第三层：让谈话和写作显得丰富、内涵的关键部分\n\t- 数据：高度凝练、有美感的内容\n\t- 图表：一图胜千言\n\t- 例子：搞明白对象是谁，用例子走进他们的世界\n\n\t\t> 让对方成为故事的角色，更会加深印象。\n\t\n\t- 比喻：深入浅出、隐喻\n\n\t\t> 尤其是对方不懂得专业领域，不通过打比方，他人听不懂也听不进去。此方法可借鉴：<br> [是俗不可耐. EUV 光刻机是如何造出来的 [OL]. bilibili.com. 2021](https://www.bilibili.com/video/BV1K54y1n7sM)\n\n###  表达顺序\n\n- 金字塔第二层：支撑的项目（论据）\n\n- 意群承上启下模型： 12 秒内新概念的 `咬合` 和 `重复`，这也符合《认知心理学》的短期记忆运作原理。\n\n\t> 疫情创造历史 情况 **严重**\n\t> 有多 **严重**\n\t> 别的不管用  只有 **隔离** 管用\n\t> **隔离** 打击 **服务业**\n\t> **服务业** 对 **经济** 很重要\n\t> 越发达地区 服务业占比越大 **经济** 打击越大\n\t> 结论：第三次世界大战（**严重**）\n\n- 铺垫转折模型 -- 源自于《手把手教你玩脱口秀》\n\t- 铺垫让这个古是似乎要往一个方向走，以产生一个原先的预期。\n\t- 笑点通常是故事的结尾，给了一个跟预期完全不同的结局。而且结局往往带有 `自嘲性质`，以显得 `主角很悲惨`。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Linguistics-Turning-Point.svg) 铺垫转折模型\n\t{%endcenterquote%}\n\t\n- 时间顺序模型：回忆过去，复盘现在，展望未来\n\n\t> 给人一种宏大感。\n\n- 空间顺序模型：从南到北，从大到小，从内到外\n\t- 微观-宏观-宇观 / 微观-中观-宏观\n\t- 漫画剖析模型：源自于《理解漫画》，可用于解释任何一个产品的层次结构，比如影视作品、短视频、APP 等。\n\t\t- 概念：一种核心理念/观念、待解决痛点问题\n\t\t- 形式：文章、图文、视频\n\t\t- 风格：诙谐、严肃、宏大\n\t\t- 结构：内容的骨架、演绎的先后顺序\n\t\t- 工艺：演员会如何演、角色如何画、音乐如何配等\n\t\t- 外观：视觉包装和呈现\n\n- 升级递进模型\n\t- 比如研究一个人的行为，可从 `身体 > 情感 > 思想 > 精神` 层面依次逐层递进研究。\n\t- 比如研究负油价成因，可从 `需求 > 供给 > 库存 > 产业 > 金融 > 政治` 方面逐层递进研究。\n\n- 翻转模型：论述证明的事物，作出一个反面论据，同时提出一个疑问然后跳回正面解答该疑问，最后反过来提出新的反面论据。\n\n\t> 推荐观看 Bilibili UP 老番茄的视频，他的视频运用翻转技巧可娴熟了 [传送门](https://space.bilibili.com/546195)\n\n- 英雄之旅模型：缘起 -> 危机 -> 高潮 --> 结尾\n\n- 因果模型：图文并茂\n\n## 概率统计学重要模型\n- 为什么概率这么重要？因为世界充满不确定性，而概率论提供了量化不确定性的科学方法。\n\n\t> 比如人工智能领域的统计学习、机器学习等。\n\n- 概率论是非常反直觉的，归因是人类进化速度太慢，我们的大脑结构适合解释古代环境里生存成长环境，相反不太适应这个日新月异的现代社会。\n\t- [引例] 享延顿舞蹈症：大概每 10 万人会有 4~8 人的病，误诊率 1%\n\n\t\t> 10 人真有病 + 999 人被误诊患病 => 1009 被诊断有病。张三真实得病概率为 10 / 1009 < 1‰\n\t\n\t- 启示：`幸存者偏差`，在很小概率事情上做推断，一定关注推断的错误率。\n\n### 贝叶斯公式\n- 贝叶斯公式：也称 `逆概率公式`，已知第二阶段反推第一阶段 ( 执果索因 )。\n\n\t$$P(B_i|A) = \\frac{\n\tP(A|B_i)P(B_i)\n\t}{\n\t\\sum_{i=1}^{n} P(A|B_i)P(B_i)\n\t}$$\n\t\n\t- 引例：检查运动员是否使用违禁药\n\t\n\t\t- $P(B=使用禁药|A=阳性) = \\frac{\n\t\t\tP(A=阳性|B=使用禁药)P(B=使用禁药)\n\t\t\t}{\n\t\t\tP(A=阳性|B=使用禁药)P(B=使用禁药) + \n\t\t\tP(A=阳性|B=非使用禁药)P(B=非使用禁药)\n\t\t\t}$\n\t\t\n\t\t- 使用禁药检查为阳性概率 $P(A|B_i)=0.95$，使用禁药的基础概率 $P(B)=0.001$\n\t\t\t- 0.95 x 0.001 / (0.95 x 0.001 + 0.05 x 0.999) ≈ `0.009`\n\t\t\t- 0.95 x `0.009` / (0.95 x `0.009` + 0.05 x 0.991) ≈ `0.079`\n\t\t\t- 0.95 x `0.079` / (0.95 x `0.079` + 0.05 x 0.921) ≈ `0.45`\n\t\t- 即使检查了 3 次，但概率仍小于一半。\n\t\n\t- 启示：看到没见很罕见的事情连续发生两次，媒体吹嘘世界变了？而我们要有自我的角度思考问题。\n\t\t- 这个事情被误判的可能性有多大\n\t\t- 这个事情在真实世界里面发生的概率有多小 \n\n- 简化贝叶斯公式：$P(B|A)=P(A|B)P(B)/P(A)$\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Probability-Simplied-Bayes.svg) 简化贝叶斯公式\n\t{%endcenterquote%}\n\t\n\t- 启示：选择比努力更重要，基础概率会放大你的努力。比如选城市、选学校、选专业、选公司、选赛道等。\n\n### 均值异常值\n- 均值：正态分布\n- 异常值：与均值偏差超过两倍标准差的数值。\n\t- 处理方式\n\t\t- 舍弃最值：世界是稳定的、平均的（基础假设）-> 去掉最高分、最低分\n\t\t- 一视同仁：它们跟其他数值一视同仁\n\t\t- 单独集合：世界是不稳定的、不均匀的（基础假设）-> 单独作为一个特别集合研究\n\t- 启示：结合贝叶斯公式，观察 2020 疫情年后，整个世界变动的基础概率变高了，过去几十年习以为常的秩序都在发生变化。在基础概率逐渐变大的趋势下，异常值影响我们最终判断的程度变高。\n\n### 大数定律\n- 启示：在小数据阶段，大道理可能毫无参考价值。\n\t- 保持耐心、保持身心健康 -> 目标是 `康庄大道`\n\t- 取得更多数据时慢慢总结经验，不要过早给事情贴标签 -> 避免走入 `羊肠小道`\n\n## 经济学重要模型\n\n- 经济基础（生产力）决定上层建筑（政治制度、法律制度、经济制度等），所以经济学是具有政治目的和政治属性的。选择经济学入门教材很重要，这里分享一门自己学过的、认可的经济学课程，感兴趣的同学可以借鉴学习。\n\t- [视频] [珍大户.认知世界的经济学 [OL]. bilibili.com. 2022](https://www.bilibili.com/cheese/play/ep18504)\n\t- [书籍] [珍大户.认知世界的经济学 [M]. 江苏凤凰文艺出版社. 2021](https://book.douban.com/subject/35779459/)\n- 微观经济学与宏观经济学都有一套赚钱方法：\n\t- 微观经济学：洗脑需求、控制供给\n\t- 宏观经济学：经济危机、暴涨暴跌\n\n### 供需\n- 供给需求模型：前提市场是可以自由定价的。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Economics-Supply-and-demand-models.svg) 供给需求模型\n\t{%endcenterquote%}\n\n\t> 启示：如何提高自己的收入，找到能 `灵活定价` 的市场，在其中做一个 `稀缺供给者`。 \n\n### 边际\n- 边际成本：多投入一个单位的增量，会产生新增成本或者收益。比如：\n\t- 共享单车、付费软件行业，有相对固定的边际成本。\n\t- 发型师行业，新增用户，边际服务成本也随之增加。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Economics-Marginal-cost.svg) 投入产出模型\n\t{%endcenterquote%}\n\n- 边际收益：比如水与钻石的价格\n\t- 水便宜，每增加一杯水，对个人的边际收益较小\n\t- 钻石贵，每增一颗钻石，对个人的边际收益较高\n\n### 成本\n- 机会成本：放弃的最高价值。但是，现实生活中没有这么清晰的、容易的选型，让我们选择与舍弃。比如：\n\t- 眼界问题\n\t- 洗脑问题\n\t- 预见性问题：取决于你的想象力、预见性、规划能力，以及你的胆量和野心。\n- 沉没成本：也称为赌徒效应，非经济学的分析方法，表示投入的成本打水漂了。正确分析方法还是机会成本。\n- 给我们的启示：\n\t- 启示1：决策底线，明白一件事上的机会成本是多少。\n\t- 启示2：可选择权，比如陷入完全没有储蓄状况、过早背上房贷等。年轻时过早丧失可选择权是非常可怕的。\n\t- 启示3：沉没成本表示我们已经失去的东西，过去是无法改变的，所以没必要盯着过去看。\n\n### 选优\n- 投入产出模型（ROI）：辩证思考法\n- 比较优势 v.s. 绝对优势\n\t- 比较优势：社会分工的真实原理，团队合作以实现利益最大化。\n\t- 绝对优势：个人、公司或国家在投入相同单位时间下生产更多数量的商品或服务的能力。\n\n- 激励：人类对经济激励做出了反应，才会产生一系列的经济行为。\n\t- 改变绩效考核方式，即可改变人的行为，比如按时/按件计费生产模式是不一样。\n\t- 办健身卡激励自己运动，因为人不希望自己的金钱浪费掉。而新经济社会学则认为，即使把金钱压力拿掉，社会压力（私交关系）也会起到督促作用。\n\n### 新经济社会学\n- 孤立人假设：人类大多数决策都不是独立完成的，而是被身边很多人影响着完成的。\n- 嵌入式关系：\n\t- 个人行为是紧密嵌入到人际网络关系中的，要理解一个人的经济行为，就必须理解他身边的各种人。\n\t- 从小群到亚文化，再到国家文化、民族文化，都跟个人行为有着很大关系。\n\n### 中国国情\n- 中国国情：重视科技、开放学习、实用为王、不断改革。\n- 现阶段国情对年轻人的启示：\n\t- 对于出生在小城小镇的同学来讲，学习理工科是突破 `圈层` 最好的武器。\n\t- 大家应该多接触已被证明的、成功的方法论，研究其中可取或者不可取的。\n\t- 立足自己实际情况做决策，不要生搬硬套别人的成功经验。\n\n## 人类学重要模型\n### 想象与共识\n\n- 灵活协作四象限图\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Humanics-Collaboration-quadrant.svg) 灵活协作四象限图\n\t{%endcenterquote%}\n\t\n\t- 蚂蚁：超大规模写作，但模式缺乏变通性，不能与时俱进。\n\t- 人类：成千上万人规模协作，还能够不断改变协作规则的物种。\n\n- 人类通过想象达成共识，从古至今贯穿了整个文明史。换句话说，整个人类世界其实是构筑在集体的想象基础，一个很多人都认可的抽象共识。比如，人们为什么相信数学概念、科学技术能改变世界。\n\n\t> 启示：实从虚中来，无虚便无实。\n\t\n- 我们对抽象事物的抗拒，以人类进化过程角度解释，人类身体与飞速发展时代之间存在着一个巨大的矛盾，即 \"远古的身体，现代的认知\"。\n\t- 进化迟滞：人类身躯是通过 20 万年原始生活漫长时间筛选出来的，我们的肉身跟不上信息时代发展。\n\t- 进化心理：研究人类原始时代的生活状态，可找到现代人行为的内在原因。\n- 一个细分心理学学科，推荐戴维·巴斯写的《进化心理学》，有助于我们更好认知人的行为内因。\n\t- 比如原始生活中，高热量和甜食是非常罕见的，在自然界中通常供不应求，而当遇到水果、蜂蜜这种不易保存的甜食，于是第一时间就想摄入甜食的行为与欲望便深深地被刻到我们的本能当中。这样解释 “明知吃糖太多不好偏好吃糖” 的逻辑便通了。\n\t- 远古人类本能是现代人痛苦的根源之一。比如远古时代长期食物稀缺，造成人类对脂肪的强烈偏爱，即使食物丰盛的现代，人们还是长期过度摄入脂肪从而引起心血管疾病等。\n\n\t\t> 解决恶习的方法：了解原理，建立意识，刻意练习\n\n###  幼态持续\n- 晚熟\n\t- 一个社会保持儿童时期好奇心状态的能力是这个社会发达程度的一个指标。\n\t- 一个成年人保持好奇心和探索欲的能力是决定其能否延长寿命的重要因素。\n\n### 文化人类学\n- 文化：是一群人通过 `习得` 对其行为和身边事物意义的 `共同认识`。\n\n\t> 比如东方文化与西方文化差异，西方家庭领养的亚洲孩子长大后的思想行为都是西化的。表明文化是通过后天习得的，文化和人种的生物学特性是解耦的。\n\n- 亚文化：一些群体拥有的相对独特的共识。亚文化来源于特定的语言、意见领袖、行为以及符号，比如哔哩哔哩的亚文化圈。\n\t- 特定语言：爷青结、高质量男性、芜湖起飞\n\t- 特定意见领袖：罗翔老师、老番茄、何同学、稚晖君\n\t- 特定行为：一键三连\n\t- 特定符号：233 娘、小电视\n- 文化具备的特征\n\t- 文化是历史的产物\n\t- 亚文化刻意迅速变迁\n\t- 社会价值观会影响亚文化\n\n### 基因与模因\n- 基因（Gene）：生物体遗传的基本单位。\n- 模因（Meme）：指社会中可被传播和复制的观念、名言与时尚元素。\n\t- 文化的基本单位\n\t- 通过模仿得到传递\n- 基因与模因的共同特征：遗传性、变异性、选择性\n\n\t> 启示：人类延续自己的方式可通过文化创造和传承给下一代。\n\n## 信息论重要模型\n### 信息熵\n- 信息熵：描述一个东西的不确定程度的量。\n- 信息量：用来把信息熵消除掉的信息所需要的能量。衡量信息量的基本单位为比特（Bit）。\n- 信息熵越大（越小），消除它需要提供的信息量越大（越小）。比如外出约饭，双方不知道吃什么、吃什么菜系或者特殊要求，不确定性依次降低、信息熵越小。\n\n\t> 启示：不做选择、随波逐流或平均分配注意力，就会增加整个系统的无序性。如何聪明地分配我们的资源和注意力，引入 `哈夫曼编码` 与 `奥卡姆提刀`。\n\n### 哈夫曼编码\n- 哈夫曼编码（Huffman coding）：把较短的编码分配给高配出现的词汇，把较长的编码分配给低频出现的词汇。\n\n\t> 理解哈夫曼编码，少不了哈夫曼树的构造过程的认识，推荐文章 [一文搞懂如何构造哈夫曼树](https://zhuanlan.zhihu.com/p/113389819)。\n\n- 奥卡姆剃刀（Occam's Razor）：如无必要，勿增实体，即简单有效原理。\n\n\t> 启示：大刀阔斧低做减法，围绕关键领域饱和配置。\n\n### 帧间压缩算法\n- 帧：影像动画最小单位是单幅静止画面，把它们连续播放起来即形成动画。\n- 以一部 2 个小时、25 帧、1080P 的影片为例，不压缩存储所占空间是巨大的。\n\n\t> 2 hour \\* 60 minutes \\* 60 seconds \\* 25 frames \\* (1920\\*1080) \\* 3 = 1042.84 GB\n\t> 其中：RGB 三原色，一个像素占用  3 字节；1B = 8bit，1 KB = 1024 B, 1 MB = 1024 KB...\n\n- 启示1：通过关注 `信息增量`，而不是关注 `信息存量`，来极大 `提升效率`。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/InformationTheory-Interframe-compression.svg) 帧间压缩算法\n\t{%endcenterquote%}\n\n- 启示2：关注变化，忽略重复，使得我们学习效率提升数倍，但起步时先花时间把基本功练扎实也是很重要的。\n\n### 互信息\n- 互信息：一个随机变量中包含的关于另一个随机变量的信息量，或者说是一个随机变量由于已知另一个随机变量而减少的不确定性。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/InformationTheory-Mutual-information.svg) 互信息示例\n\t{%endcenterquote%}\n\t\n\t> 信息论解释：信春哥到底给不挂科这件事消除多大的不确定性，减少多少信息熵。两个独立事件的相关性可通过严格计算可得，若它们互信息比较高则表可确信它们具有相关性。但是，相关性并不等于因果性。\n\n- 信息等价：知道 A 发生的信息，就等同于知道 B 发生的信息。\n\n\t> 比如：说废话，今日天气真好 ≈ 蓝条白云、风和日丽、阳光明媚\n\n### 冗余度\n- 冗余度：资源的重复性，不一定是坏东西，也可以理解为故意安排的策略。\n\n\t> 比如：桥墩、大厦的防火安全通道、飞机上的双引擎设计、标点符号等。\n\n- 启示1：冗余并不一定是坏东西。\n\t- 在工程领域，它可保障系统安全运作。\n\t- 在表达层面，它能更好服务于人类的认知习惯。\n- 启示2：时代在进步，人类习惯接受的冗余度也在减少，所以我们越来越需要掌握去除冗余度的方法 -- `分析框架法`。\n\t- 先把关键概念零散罗列出来\n\t- 寻找概念卡片间的关联关系\n\t- 套用和矫正\n\n## 营销学重要模型\n- 物理世界：由物质与能量组成\n- 商业世界：由生产与营销组成\n- 在商业社会中，我们总是因一些负面情绪而对营销产生偏见（比如安利、传销），从而选择性地忽视了它的正向价值。请摘掉有色眼镜，以下将从三个线索认识、了解营销学：\n\t- 需求 v.s. 供给\n\t- 微观 v.s. 宏观\n\t- 国外 v.s. 中国\n\n### 需求\n- 不管是什么职位，绝大部分人在刚起步阶段总会本能地忽略别人的内在需求，比如不懂老师、同事、老板内心深处需要什么，总是把自己的需求当作别人的需求。\n\n\t> 启示：懂得换位思考，理解对方的需求。比如写报告、写简历等，首要知道受众是谁，然后多提出一些问题、多做一些调查，需求自然会逐渐明了起来。很多刚出社会的同学（包括自己）都不明白这个道理，活在自己世界里自嗨式工作。\n\n- 需求分类：痛点与痒点/爽点\n\t- 痛点：利用人们的恐惧，因为恐惧可立即激活人脑的杏仁核，劫持整个大脑，让人进入本能行动模式。\n\n\t\t> 比如，教培行业懂得抓住家长恐惧心理，影响孩子一辈子的事情，即使花再多钱也愿意买单。\n\n\t- 痒点：缓解压力带来的动力。比如打游戏、喝奶茶等，目的是缓解身体的压力。\n\n- 需求的产生过程\n\t- 需要（Need）：生活中需要完成的生存任务。\n\t- 想要（Want）：需要找到可以满足它的供给物时，需要变成想要。\n\t- 需求（Demand）：想要的东西，待我们有能力获得时才会变成需求。\n\n\t> 比如：小艾大叔带你看豪宅，大家都需要房子，大豪宅更是想要，但它是大多数人的需求吗？\n\n- 启示：以个人升职加薪为例\n\t- 思考公司、老板现阶段想要什么？\n\t- 确保自己能展现出满足这种需要的能力和潜力，把公司的想要转变成需求。\n\t- 搞清楚公司有没有实力支付你想要的薪酬、有没有资源支撑你以后想取得的更大成就。\n\n\t\t> 不然自己努力争取半天，发现不是自己不行，而是公司不给力。\n\n### 供给\n- 定位理论：`占据心智生态位`。把一个品牌与一个品类或者一个动作直接画上等号，比如今天中国用户想要搜索就想到百度、外卖就想到美团/饿了么、汉堡就想到麦当劳/肯德基、便宜奶茶就想到蜜雪冰城等。\n\n\t> 对于人类大脑而言，通常能记住一个细分市场里，特定品类的第一名及第二名，称之为 `二元法则`。\n\n- 二元法则：市场上任何一个细分市场里，只能留下第一名和第二名，第三名以外就难以被消费者记住了。\n\t- 依据：人类大脑追求节省能量，为此对于生活中各种事情通常只会用耗费少量脑资源去处理小事情，比如用什么软件点外卖、网购等。\n\t- 影响：用户不怎么关心次要、无足轻重的小事情，一旦养成习惯就不会轻易去改变它们。如此以来，便造就品牌在细分领域 `赢家通吃` 的局面。\n\n- 打造品牌四步法\n\t- Step.01：看清竞争对手是谁，它们提供的价值是什么？\n\t- Step.02：避开竞争对手的优势领域，找到一个相对空白（蓝海市场）、自身有优势的差异化定位。\n\t- Step.03：围绕这个定位打造一系列的支撑点。\n\t- Step.04：重复再重复，不断向受众呈现第三步打造的支撑点。\n\n- 启示：现代社会人获得内心安宁的一种方式，即找到 `独特生态位`，它是对抗内卷最好的解药。\n\n\t> 独特生态位，个人理解是将自身专长运用到工作实践中的一种能力，比如设计天赋+汇报能力，让做的事情更容易获得客户、领导、同事认可。我们常说的“做得好不如讲 PPT 的好”，其实能说会道也是一种能力、一种优势呢！\n\n### 微观\n- 引用《[影响力](https://book.douban.com/subject/35637771/)》的六大核心心理模型：互惠、承诺、从众、喜好、权威、稀缺\n\n\t> 这正是电商直播刺激消费的法宝呀！比如，看直播产生购物冲动，加上商品的限时限量优惠诱惑，赶紧买了再说，大不了改天退货罢了。其实，这里就利用了群众的从众、稀缺心理。\n\t\n\t- 稀缺：稀缺直接含义是供不应求，稀缺商品价格自然贵。但营销领域，稀缺与稀缺感是两种不同的概念，后者是利用了人的恐惧故意营造出来的，比如限量款、截止日期等。\n\t- 从众：人以类聚、物以群分。同类人也会对我们产生影响。\n\t\n\t\t> 小众：小圈子文化、细分领域市场\n\t\n\t- 喜好：投其所好\n\t- 互惠：接受别人的赠予，会本能想要回报对方。\n\t\n\t\t> 互欠网：适应机制，人类得以实现劳动分工、交换不同形态的商品和服务、让个体相互依赖、凝结成高效率单位。\n\n\t- 承诺：人类会本能地对自己做出的承诺负责。比如，公开你的目标或者公开承诺，之后你会很自然想去完成承诺。 还有，团队管理中让你写下工作目标，并且让同事看到它，之后你就会自然而然地履行承诺、完成任务。\n\n\t- 权威：人类会下意识服从来自权威任务的指令。\n\t\t- 对于医生的健康建议我们会莫名信赖、觉得大学教授、博士的观点更加可靠等。从人类学角度来看，权威崇拜更像是一种文化现象而非生物本能。\n\t\t- 在一个文明社会里，一个热衷于对抗权威的人，通常生活得比较艰辛。权威服从大多数更多是节约生存成本。\n\n\t\t> 启示：避免权威服从天性被人利用，比如欧美品牌的制高点效应带来得权威溢价、利用公安局的权威实施诈骗等。\n\n### 宏观\n- 弱传播假说，舆论世界越弱得东西越好传输，就类似自然界中：\n\t- 弱点可用于信号传导，强电可成为动力能源\n\t- 风好传播，山不好传播\n\t- 花粉好传播，大树不好传播\n\n- 现代舆论世界四条规则 -- 邹振东教授\n\t- 弱者优势：弱者多，传播广\n\t- 情感强势：大众的情绪高于理智\n\t- 轻者为重：轻量的信息更好传播\n\t- 次者为主：非主流、非正统的内容更引人瞩目。《[任天堂体验设计](https://www.kofes.cn/2022/10/nintendo-experience-design.html#不由自主着迷)》中惊喜设计原理正是如此，打破人们对日常生活的坚信，从而让人获得超出预期的惊喜体验。\n\n- 举例：把《咱当兵的人》改成《咱当官的人》，还会有人传唱吗？毕竟在舆论世界里自吹自擂、表现自己很厉害，是很让人反感的。相反，讨人喜欢的 Up 主总是表现的很弱势，他们会羞涩、会自嘲、无攻击性、会搞砸事情，这是符合弱传播假说原理的。\n\n- 为什么现代舆论世界的运作原理是这样的？ -- 现代性\n\t- 人类远古的身体并未完全适应现代社会的运行节奏，我们的身体既不是为了 996 高强度、高压力的工作，也不是应对各种考试而进化出来的，现在竞争压力会让身体系统产生大量的熵。\n\t- 比如观看马保国、蔡坤坤、高质量男性、鬼畜视频，娱乐八卦通常是解压的、可以熵减的，并且在过程中得到优越感。\n\n### 品牌\n- 品牌是一种心理符号，跟特定国家民族、社会文化、符号资源、语言体系等息息相关的。\n\n#### 国内方法论\n- 《[超级符号就是超级创意](https://book.douban.com/subject/26870611/)》：打造国货品牌，利用集体潜在意识的符号去创造，而非创新。\n\n\t> 好比设计方法中的借物喻意。\n\n- 在观念传播过程中，假设传播现代的信号为 1，而传输损耗变成 0.7。通过潜意识设计，而非刻意教授用户，让用户潜意识发生共鸣、激发强烈情感，让 0.7 放大成 10 倍效果。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Marketing-Subconscious-Design.svg) 潜意识共鸣放大传播效果\n\t{%endcenterquote%}\n\n\t> 启示：无论是正式沟通、推销想法或是申请项目，了解清楚  `谈话对象的文化背景`，其实作用是非常大的。因为传播的信息若是能够跟对方已有的记忆产生共鸣，通过潜意识发挥作用，便会大大增加传播效果。\n\n#### 国外方法论\n- 品牌共鸣金字塔：从下而上、由简入繁\n\t- 第一层：`认知`，解答你是谁的问题。用户只需看一眼就知道你是属于什么品类的。\n\t- 第二层：`联想`，解答你是什么的问题。左边是理性，阐述品牌的功效；右边是感性，表达品牌的形象。\n\t- 第三层：`态度`，我认为你如何。即消费者对品牌的评价问题。左边是理性，表示消费者对品牌的质量、信誉、优势、风险的心理评估；右边是感性，就是品牌给消费者自己的整体感觉如何。\n\t- 第四层：`忠诚`，你和我的关系。这一层能达到的最高境界是，消费者愿意用品牌来代表自己。\n\n\t\t> 比如，不少奢侈品牌达到类似高度，类似瑜伽服界的 lululemon、数码界的 apple 等。\n\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Interdisciplinary-Thinking/Marketing-Resonating-Pyramid-of-Brand.svg) 品牌共鸣金字塔\n\t\t{%endcenterquote%}\n\n\n## 历史学重要模型\n\n{%centerquote%}\n以铜为镜，可以正衣冠。以史为镜，可以知兴替。——《旧唐书·魏徵传》\n{%endcenterquote%}\n\n- 拼图模型\n\t- 人类历史发展并不像马路一样笔直向前开，更像拼图东拼一块西拼一块。\n\t- 当拼图接近完整时，会突然出现某种清晰脉络，仿佛这个趋势或转折点是瞬间到来的。\n\n\t> 比如为了实现共同富裕这个目标，精确扶贫、反腐败、限制货币扩张、完善社保机制等不同方面、不起眼的”拼图碎片“早已出现。\n\n- 动静循环模型\n\t- 静态文明：一个文明繁荣稳定下来就会成为静态文明。\n\t\t- 处于静态文明之下，生产力水平通常会提高，从而创造出相对丰富的文化成果。\n\t\t- 既得利益者会安逸保守、阶层会固化，文化开始失去活力。\n\t- 动态文明：一个上升不稳定的文明出现，作为静态文明的挑战者。\n\t\t- 然而双方不会马上发生你死我活的冲突，而是会共存很长一段时间。\n\t\t- 动态文明总是有抢占静态文明生态位的欲望，但由于自身发展程度不及静态文明，所以难有作为并持续该状态很长时间，这种状态也称之为文明对峙。\n\t- 动静循环：待双方强弱逐渐均衡，一旦静态文明出现某种失误，从而一举扭转双方强弱对比进入下一阶段，并开启新的动静循环。\n\n\t> 启示：未雨绸缪早当先，居安思危谋长远。\n\n- 竞争与选择模型：历史只是生物学的片段，历史学会受到生物学基本法则支配。生命即竞争，人类和国家之间不再流行使用暴力，而是以产业主导权、贸易规则、技术标准、媒体话语权等，进行无硝烟的对战。\n\t- 启示1：人类竞争比合作更底层更稳定，以心理维度解释就是恐惧驱动竞争、渴望驱动合作。\n\t- 启示2：合作的底色是竞争，竞争的结果是选择。差异是自然的底色，公平并不是。\n\t\n\t\t> 如果社会追求放任自由主义运作规则，那么最终结果一定是社会达尔文主义，强者俞强，弱者愈弱，贫富悬殊，赛博朋克！所以国家要以顶层设计维护稳定，即试图维持自己存续的文明，需不断地刻意调节贫富差距、刻意引导社会秩序。\n\n- 技术文明因果模型：科技进步是文明发展的结果而不是原因，因为技术进步或新的科学理论都是一个叠加性的、社会性的、具有创造特点的现象。而非某一个英雄任务单打独斗、孤军奋战的结果。\n\n\t> 所谓发明其实是发明家在一个合适社会环境里，找到一项新技术最后一块拼图而已。——《创新的神话》\n\n- 未来主义 v.s. 过度未来主义\n- 复古主义 v.s. 过度复古主义\n\n\t> 启示：做决策不宜急转弯，建议让错误酝酿一会、让子弹飞一会，再做决定。比如换工作、换城市、换专业、投资等。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/History-futurism&Retroism.svg) 未来（复古）主义 v.s. 过度未来（复古）主义\n\t{%endcenterquote%}\n\n## 古代哲学重要模型\n### 无用之用\n- 哲学：对人生终极问题的系统性反思。但哲学与哲学家所处的时代、国家、财富、成长经历、高矮肥瘦、基因特点有着强相关关系。\n\t- 伊比鸠鲁：自由享受快乐\n\t- 斯多葛：自律忍受痛苦\n\t- 王守仁：世间万物，心外无物。心外无理，心即是理。\n\t- 曾国潘：立志做圣人，把人生智慧总结为 \"诚、敬、静、谨、恒\"。\n\t\n\t> 启示：哲学具备鲜明的个人特点，个人会很欣赏某一类哲学，与本人的特质体制、特定年纪、特定环境、特定遭遇都有关系。即存在哲学与个人禀赋环境匹配问题，所谓“彼之蜜糖，吾之砒霜”。\n\n### 内圣外王\n- 内圣：内心深处是致力于心灵的修养\n- 外王：社会活动中积极承担最大责任\n\n\t{%centerquote%}\n\t能力越大，责任越大。—— 《蜘蛛侠》彼得·本杰明·帕克\n\t{%endcenterquote%}\n\n\t> 启示：兼顾以上两种选项，即不逃避权力和金钱，也不逃避获得世俗的成就。\n\n- 哲学修养是可以用来应对人生的重大命题，比如巨大风险、境遇突变、重大挫折或是亲人离世等，这些事情总是和一些更加永恒的、超过自身控制范围的主题联系在一起。\n\n### 停止思考\n- 你不等于你的大脑，在人生重大考验到来之前的时刻，最好的方法是放空自己，停下思绪，让大脑恢复至最佳状态。\n\t- 启示1：放空大脑的方法，比如停止思考、冥想、数呼吸（腹式呼吸，吐气防空后开始倒计时）。\n\t- 启示2：活在当下，过去不悔，未来不追。\n\n### 正反合三段论\n- 一切事务的发展过程都可分为三个有机联系着的阶段。\n\t- 正题：发展的起点\n\t- 反题：正题会孕育自己的对立面\n\t- 合题：正题与反题两者最终会在相互对抗中形成统一\n\n\t\t> 合题也可以看作是新的正题，它又孕育了更高层次的对立面。\n\n- 正反合思考法：站在完全相反立场思考同一问题，产生巨大的思维张力，让人更加客观地看待世界。\n\t- 战略上藐视敌人，战术上重视敌人。敌进我退，地驻我扰，敌疲我打，敌退我追。—— 毛主席\n\t- 正确的反面是谬误，但一个深刻真理的反面，很可能是另一种深刻的真理。—— 波尔\n\n### 反者道之动\n\n{%centerquote%}\n反着道之动，弱者道之用。天下万物生于有，有生于无。——《道德经》40 章\n{%endcenterquote%}\n\n- 任何事物发展到极端，都有一种朝相反方法移动的倾向。\n- 任何事物都包含了对它自己的否定。\n- 启示：\n\t- 每当陷入困境时，尝试一些反人性的做法，比如让自己变得更慷慨、更喜欢跟人交际、更喜欢请客吃饭，或许这样会帮你在困惑时渡过难关。\n\t- 人身顺境时，避免陷入亢龙有悔的状况。\n\n### 斯多葛哲学\n- 消极想象策略：做一件事先去想象发生最坏情况，以及思考如何面对的做法。\n\n\t> 注意：消极想象与负面情绪的区别，前者是建设性的，后者是破坏性的。\n\n- 身边的坏事不管如何阻止，它都会发生，则我们身处两种情况：\n\t- 预想最糟糕状态，想好应对策略，把伤害降至最低。\n\t- 预想最好的状态，从未为意外做准备，发生坏事则完全丧失行动能力。\n\n- 享乐适应：注定让人归于平淡和无趣的巨大牵引力。比如：\n\t- 中大彩票的人最快乐的时光就是他知道中将的那一刻，兴奋度会逐渐降低，即使金钱上拥有很多，但幸福程度并没有显著增加。\n\t- 婚姻也类似如此，新婚兴奋感会维持一段时间，就会进入一个平淡的适应期，即使对方是天使或王子也避免不了。\n\n\t> 运用消极想象策略，刻意去阻止适应过程，但要张弛有度。\n\n- 控制二分法：可结合阿德勒的”人生课题分割模型“来分析问题。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Psychology-Life-Subject.svg) 切割人生课题模型\n\t{%endcenterquote%}\n\n\t- 能控制：100% 精力专注\n\t- 不能控制：彻底忽视\n\t- 包含能控制与不能控制：要保持头脑清醒，提炼可控的区域\n\n### 价值剥夺模型\n- 快乐建立在不牢固的地基之上，发生动荡时很容易失去这一份快乐。\n\n\t> 不牢固的地基：取悦他人、社会比较、消费恋物等身外之物，这也是大多数人焦虑的根本原因。\n\n- 启示：要像获得内心的安宁，可以把人生的锚点建立在那些更稳定的事物上。比如拓展认知水平、\n\n追求人生智慧、为人民服务（获得前得成就他人）等。\n\n## 现代哲学重要模型\n\n### 马克思·韦伯\n- 人的理性\n\t- 工具理性：完成某件事情最有效的方法，即不关心目的，只关心达到目的的手段是否最优。\n\t\t\n\t\t> 比如研究两人打架什么攻击最有效；如何提升学习效率；如何避免割韭菜等。\n\n\t- 价值理性：考虑意义和价值。\n\n\t\t> 比如人与国家的关系、人与世界的关系、社会意义等。\n\n\t- 工具理性有最优答案，价值理性没有标准答案。\n\n### 侯世达\n- 哥德尔不完全性原理：任何一形式系统，只要包括了简单的 `初等数论` 描述，而且是 `自洽的`，它必定包含某些系统内所允许的方法既不能证明真，也不能证明伪的命题。\n\t- 人话：每个数学系统自身都存在无法被自证的部分。\n\n\t\t> 人类通过自身意识不断自我反思（元认知），发展到最后存在一个永远无法触达的盲区。\n\n\t- 启示：如果我们想要理解某一个维度上的信息全貌，仅靠同一维度的认知水平是永远不可能实现的。需要维度之外解决维度之内的问题。同理，降维打击也是如此。\n\n- 大脑的台球桌模型：大脑类比一张绝对光滑没有摩擦的台球桌，桌上有 860 亿个（类比大脑神经元的数量）带有磁性的 `小球` 横冲直撞，若角度和速度满足条件：\n\t\n\t> 小球：代表一系列表征世界的符号、概念、规则以及所有相关集合体。\n\n\t- 小球会粘在一起积累成大球，也会撞击使大球解体。\n\t- 好比人类形成认知过程，从辨别到掌握智慧的过程。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Modern-Philosophy-Human-Cognition.svg) 人类形成认知的过程\n\t{%endcenterquote%}\n\n### 巴拉巴西\n- 能力驱动成功，当能力无法被衡量时，社会网络驱动成功。\n\t- 能力驱动：跟个人能力强相关，比如代码工程师、赛跑运动员。\n\t- 社会网络驱动：产出被嵌入一个大型网络中，结果不容易被衡量，个人成就不见得与实力高度相关。比如：\n\t\t- 公务员的能力表现，取决于所处部门、区域、城市、国家大方向和时代的需求\n\t\t- 基金经理的能力表现，很大程度取决于整个市场行情、基金规模\n\t- 启示：选择职业时，评估自己的禀赋和资源很重要。\n\t\t- 从事金融、艺术类职业，产出特性就决定了校友关系、家族背景的加持比自身能力更重要。\n\t\t- 毫无背景但却容易逆袭的职业，比如工程师、运动员、销售员、自媒体。\n\n- 初始成功 x 社会适应度 = 未来成功\n\t- 初始成功：成功才是成功之母，失败只是成功它爸的前女友。\n\t- 社会适应度：也称为资源吸引度，社会适应度并不完全等同于能力。\n\t\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Modern-Philosophy-Success.svg) 初始成功 x 社会适应度 = 未来成功\n\t{%endcenterquote%}\n\n\t> 通常来说，表示社会资源密集度的箭头会在赛道层面影响大局，比如移动互联网时代、新能源汽车时代。\n\n### 亚里士多德\n- 第一性原理：系统性地怀疑你可能怀疑的一切事物，直到你获得无可置疑的珍惜。 —— 勒内·笛卡尔\n\t- 为什么要系统性地怀疑？因为人类本能地习惯用归纳法认识理解世界，但归纳法是经验主义的产物，而人类的经验永远是有边界的，即归纳法的根基不牢靠。\n\t- 根基要牢靠，需要从物理学、数学、化学等一些定理、定律触发，一步步推导出一个推论。这种方法也称之为演绎法。\n- 路径依赖：很多默认的习俗和制度都未必是最好的设计，他们有可能只是路径依赖。比如，Apple 的圆角设计，遵循的是黄金分割原则。\n- 启示：当一个国家或者一个行业，面临底层重构需要从 0 到 1 的情况，需要以第一性原理的思考方法指导工作。\n\n## 会计学重要模型\n- 财务状况越糟糕，赌性就越强，越是想一把翻盘。然而，财务知识能帮助我们打破这一种 `恶性循环`。\n\n- 公司最基本的运作要素：人、事、钱\n\t- 人：人力资源（公司）、个人能力（个人）\n\t- 事：业务管理（公司）、职业发展（个人）\n\t- 钱：财务管理（公司）、综合财力（个人）\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Accountancy-Company-3Elems.svg) 公司三要素\n\t{%endcenterquote%}\n\n### 资产负债表\n- 资产负债表：一个公司或一个家庭在某一时刻的体量。\n\t- 资产：表示家底有多厚\n\t- 负债和所有者（股东）权益：表示家底从哪里来\n\n\t<table>\n\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<th colspan=4><center>\n\t\t\t\t资产负债表（2022年12月10日）单位：万元\n\t\t\t\t</center></th>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td colspan=2>资产</td>\n\t\t\t\t<td colspan=2>负债及所有者（股东）权益</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td colspan=2><b>流动资产</b></td>\n\t\t\t\t<td colspan=2><b>负债</b></td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>货币资金</td>\n\t\t\t\t<td>70</td>\n\t\t\t\t<td>短期借款</td>\n\t\t\t\t<td>50</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>应收账款</td>\n\t\t\t\t<td>40</td>\n\t\t\t\t<td>应付账款</td>\n\t\t\t\t<td>150</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>存货</td>\n\t\t\t\t<td>20</td>\n\t\t\t\t<td>应付职工薪酬</td>\n\t\t\t\t<td>20</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>其他流动资产</td>\n\t\t\t\t<td>40</td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td colspan=2><b>非流动资产</b></td>\n\t\t\t\t<td colspan=2><b>所有者权益</b></td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>固定资产</td>\n\t\t\t\t<td>100</td>\n\t\t\t\t<td>股本</td>\n\t\t\t\t<td>80</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>无形资产</td>\n\t\t\t\t<td>50</td>\n\t\t\t\t<td>其他综合收益</td>\n\t\t\t\t<td>20</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td><b>合计</b></td>\n\t\t\t\t<td>320</td>\n\t\t\t\t<td><b>合计</b></td>\n\t\t\t\t<td>320</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n\n- 资产 = 负债 + 所有者权益\n\t\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Accountancy-Asset&Debt&Equity-Equation.svg) 资产 = 负债 + 所有者权益\n\t{%endcenterquote%}\n\t\n\t- 资产负债表两边一定是等额的\n\t- 所有者权益小于零时表示资不抵债\n\t\n\t> 比如，我们贷款买房子，房贷（负债）不会随着房价下跌而下降。\n\n### 现金流量表\n- 现金流量表：一个企业或一个家庭在财务上 `生死存亡` 的关键仪表盘。\n\t- 期末现金 = 期初现金 + 本期流入现金 - 本期流出现金\n\t- 下一起期初的现金 = 上一期期末现金\n\n\t<table>\n\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<th></th>\n\t\t\t\t<th>七月</th>\n\t\t\t\t<th>八月</th>\n\t\t\t\t<th>九月</th>\n\t\t\t\t<th>十月</th>\n\t\t\t\t<th>十一月</th>\n\t\t\t\t<th>十二月</th>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>月初现金</td>\n\t\t\t\t<td>3000000</td>\n\t\t\t\t<td>2640000</td>\n\t\t\t\t<td>2222000</td>\n\t\t\t\t<td>1792000</td>\n\t\t\t\t<td>1352000</td>\n\t\t\t\t<td>1433000</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>月末现金</td>\n\t\t\t\t<td>2640000</td>\n\t\t\t\t<td>2222000</td>\n\t\t\t\t<td>1792000</td>\n\t\t\t\t<td>1352000</td>\n\t\t\t\t<td>1433000</td>\n\t\t\t\t<td>1494000</td>\n\t\t\t</tr>\n\t\t\t<tr style=\"color: red\">\n\t\t\t\t<td><b>现金流入</b></td>\n\t\t\t\t<td>0</td>\n\t\t\t\t<td>0</td>\n\t\t\t\t<td>0</td>\n\t\t\t\t<td>0</td>\n\t\t\t\t<td>521000</td>\n\t\t\t\t<td>521000</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>收入项目1</td>\n\t\t\t\t<td>0</td>\n\t\t\t\t<td>0</td>\n\t\t\t\t<td>0</td>\n\t\t\t\t<td>0</td>\n\t\t\t\t<td>20000</td>\n\t\t\t\t<td>20000</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>收入项目2</td>\n\t\t\t\t<td>0</td>\n\t\t\t\t<td>0</td>\n\t\t\t\t<td>0</td>\n\t\t\t\t<td>0</td>\n\t\t\t\t<td>500000</td>\n\t\t\t\t<td>500000</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>收入项目3</td>\n\t\t\t\t<td>0</td>\n\t\t\t\t<td>0</td>\n\t\t\t\t<td>0</td>\n\t\t\t\t<td>0</td>\n\t\t\t\t<td>1000</td>\n\t\t\t\t<td>1000</td>\n\t\t\t</tr>\n\t\t\t<tr  style=\"color: green\">\n\t\t\t\t<td><b>现金流出</b></td>\n\t\t\t\t<td>360000</td>\n\t\t\t\t<td>418000</td>\n\t\t\t\t<td>430000</td>\n\t\t\t\t<td>440000</td>\n\t\t\t\t<td>440000</td>\n\t\t\t\t<td>460000</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>支出项目1</td>\n\t\t\t\t<td>15000</td>\n\t\t\t\t<td>20000</td>\n\t\t\t\t<td>20000</td>\n\t\t\t\t<td>30000</td>\n\t\t\t\t<td>30000</td>\n\t\t\t\t<td>50000</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>支出项目2</td>\n\t\t\t\t<td>200000</td>\n\t\t\t\t<td>253000</td>\n\t\t\t\t<td>120000</td>\n\t\t\t\t<td>120000</td>\n\t\t\t\t<td>120000</td>\n\t\t\t\t<td>120000</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>支出项目3</td>\n\t\t\t\t<td>145000</td>\n\t\t\t\t<td>145000</td>\n\t\t\t\t<td>290000</td>\n\t\t\t\t<td>290000</td>\n\t\t\t\t<td>290000</td>\n\t\t\t\t<td>290000</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td><b>现金变动</b></td>\n\t\t\t\t<td style=\"color: green\">-360000</td>\n\t\t\t\t<td style=\"color: green\">-418000</td>\n\t\t\t\t<td style=\"color: green\">-430000</td>\n\t\t\t\t<td style=\"color: green\">-440000</td>\n\t\t\t\t<td style=\"color: red\">81000</td>\n\t\t\t\t<td style=\"color: red\">61000</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n\n### 损益表\n- 损益表：收入 - 成本 = 利润\n\n\t> 深入了解利润的计算方法，推荐阅读《[肖星的财务思维课](https://book.douban.com/subject/35033236/)》、《[手把手教你读财报](https://book.douban.com/subject/35299355/)》\n\n- 启示：资产负债表、现金流量表、损益表都是判断公司经营状况的依据。\n\t\n\t> 比如对于股票投资来讲，研读不同公司的年报，通过三张表的财务数据分析判断公司的经营状况，比看 K 线图、技术面分析、行业大趋势拥有更大优势。\n\n### 收支资产负债模型\n- 收支资产负债模型：以不同资金的流向，将个人财务状况划分为以下模型。\n\t- 无产无债者：月光族，破局之道是努力开源节流。\n\t- 无产有债者：避免陷入消费贷的泥潭，无法自拔！\n\t- 有产有债者：中产阶级，用隐形负债，主动获取了劣质的、无法产生被动收入的资产。\n\n\t\t> 注意：随着升职加薪而消费升级，表面上光鲜亮丽，实际负债累累。\n\n\t- 高产低债者：收入用来投资获取更多收益的工具，让自己越过越好。\n\t\n\t\t> 收益工具：金融资产、固定资产、无形资产\n\n\t- 家底相同、起跑线相同的两个家庭，财务理念不同，数十载后资产可能产生几倍甚至十几倍的差异。\n\t\t- 有产有债者，收入是用来让自己越过越好的工具。\n\t\t- 高产低债者，收入是用来投资取更多收益的工具。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Accountancy-Personal-Financial-Model.svg) 收支资产负债模型\n\t{%endcenterquote%}\n\n- 启示1：贷款购买自住房产是很多人生的分水岭，自住房产买的越贵，贷款越多就越容易把人锁死在中产者的行列。\n- 启示2：延迟满足感，把存款优先用来打造无形资产或购买投资房产用来出租。\n\t- 无形资产：音乐、绘画、摄影、书籍、自媒体、进修新学位\n\n\t\t<table>\n\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<td>营销领域</td>\n\t\t\t\t<td>商标、互联网域名</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>数据领域</td>\n\t\t\t\t<td>客户数据、生产经验数据</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>版权领域</td>\n\t\t\t\t<td>文章、书籍、电影、音乐、短视频</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>合同领域</td>\n\t\t\t\t<td>建筑许可、特许经营权、土地使用权</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>技术领域</td>\n\t\t\t\t<td>软著、专利</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t\t</table>\n\t\t\n\t\t> 当代年轻人要刻意留意获得无形资产的机会，当然前期得着重提升三类能力：\n\t\t> 写作能力、美学创造能力、新生产业的理解能力\n\n\t- 劣质资产：消费品\n\n- 启示3：多余收入的配置问题\n\t- 比如购买一辆豪车，如果是经常跑业务需要，豪车就是优质资产，反之则是劣质资产。\n\t- 比如不全身心工作，留置空窗期去写一本书、修读一个学位，积累无形资产。\n\n\t\t> 注意：积累无形资产也有风险，比如书籍无人问津、修读 MBA 课程对自己用处不大等。\n\n## 投资大师的思维模型\n- 投资大师们的投资哲学\n\t- 巴菲特：正统流派，符合常识，长期价值投资\n\t- 索罗斯：反正统流派，挑战常识，强调短期获胜\n\t- 塔勒布：不确定性，但理论体系最为系统全面\n\n\t\t> 代表作：《黑天鹅》、《反脆弱》、《随机生存的智慧》、《随机漫步的傻瓜》\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Investment-WarrenBuffett-GeorgeSoros-Taleb.svg) 投资大师们的投资哲学\n\t{%endcenterquote%}\n\n### 索罗斯\n- 反身性理论：任何一个系统里，只要参与者是有思维能够进行认知的个体，那么思维和现实之间就一定存在一种相互营销的关系。\n\n\t> 一方面思考者努力了解现实，另一方面现实又在不断因为思考者的了解而发生改变，这种变化又会改变思考者的行动，循环往复、导致一种纠缠现象。\n\n- 启示：不要太迷信过去的数据来预测股票、基金的价格，记住风险无处不在。\n\n### 巴菲特\n- 能力圈模型：充足调研，等待机会，待在能力圈内做事情。\n- 安全边际：支付的价值不能明显低于价值，那么该项投资就没有足够的安全边际。\n\n\t> 启示：留出 Buffer，应对意外风险。\n\n- 护城河：当一个企业可提高售价但销量不会减少，说明该企业拥有护城河。\n\n### 塔勒布\n- 反脆弱：遇到黑天鹅，不但没受损反而赚大发了。\n\n- 遍历性：只有活得足够久的人才可以看到概率世界真正模样。\n\n\t> 时间概率 v.s. 集合概率\n\n- 杠铃策略\n\t- 避免把自己的时间精力投资在中风险中收益的东西上。\n\t- 研究最危险的东西，同时研究最安全的东西。\n\t- 了解冒险的本质：J 型曲线 v.s. 倒 J 型曲线\n\t\t- J 型曲线 ：付出有上限，但回报无上限。\n\t\t- 倒 J 型曲线：回报有上限，付出无下限。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Investment-CurveJ-InvertedCurveJ.svg) J 型曲线 v.s. 倒 J 型曲线\n\t{%endcenterquote%}\n\n- 启示：主动试探，不断证伪，接触能力圈外的事情，即能守圈也能破圈。\n\n\t> 小剂量 + 痛苦 + 恢复 = 变强\n\n## 生理学重要模型\n- 健康三要素：睡眠、饮食、运动、情绪\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Physiology-Health-3Elems.svg) 健康三要素\n\t{%endcenterquote%}\n\n- 人生长寿八字箴言：少吃、多动、早睡、静心\n\n### 睡眠\n- 清醒：学习各种知识\n\n- 睡眠：记忆搬运、巩固记忆、缓解压力、充分发散\n\t- 快速眼动睡眠\n\t\t- 积极睡眠，进入此状态脑电波频率变快，同时心率加快、血压升高、肌肉松弛的状态，此阶段特点是眼球不停地左右摆动。\n\t\t- 进入梦乡，跳出逻辑联系，偏向于没有关联的神经元之间建立联系，随机链接优化大脑链接效率，防止大脑僵化。\n\t- 非快速眼动睡眠：记忆巩固\n\n- 缺乏睡眠，会导致\n\t- 免疫力下降、血压升高、新陈代谢失衡、生殖能力减弱\n\t- 内分泌系统失调，情绪调节能力变差\n\t- 容易变胖\n\n\t\t> 睡不好时，身体会降低释放饱腹感信号的瘦素（Leptin）浓度，提高引起饥饿感的胃饥饿素（Ghrelin）浓度。双重信号叠加，产生远超自己摄入能力的食欲。\n\n\t- 长期睡眠少于 6 小时/天，10 天后相当于连续 24 小时没有睡觉。以此类推，有点类似睡眠银行的概念。更严重会让你频繁陷入 `微睡眠` 状态。\n\n- 微睡眠：大白天有几秒钟时间，大脑对外部世界完全没有知觉。当事人难以察觉自己曾陷入过短暂知觉丧失。\n\t- 工作效率降低，注意力涣散，容易犯下低级错误。\n\t- 判断力减弱现象，分不清轻急缓重。\n\n\t> 启示：缺乏睡眠的人，通常会高估自己的清醒程度，只是觉得有些疲惫而已。然后，通过形成新的自我刺激的习惯来弥补注意力缺失，比如喝咖啡、功能饮料等。最终形成恶性循环 ，导致睡眠更差。\n\n- 你可以会反驳，为什么有的人长期少睡，还能保持健康？\n\n\t> 拥有处于表达状态的 BHLHE41基因。\n\n- 怎睡个好觉 — 马修沃博士\n\t- 1) 坚持固定的入睡时间\n\t- 2) 尽量做到每天锻炼\n\t- 3) 睡前 8 小时内不要喝咖啡，睡前不喝酒\n\t- 4) 下午 3 点之后尽量不要午睡\n\t- 5) 千万不要吃宵夜，晚上也别吃太多，因为消化影响入睡效率\n\t- 6) 睡前放松的时间一定要留出来\n\n\t\t> 洗个热水澡、调低灯光、听听音乐，但不是玩电子设备\n\n\t- 7) 实在睡不着不要硬睡\n\n- 内稳态：人体新陈代谢大平衡可纠正局部小失衡\n\n\t> 小剂量 + 痛苦 + 恢复 = 成长，经历痛苦之后，恢复过程身体会产生内啡肽。\n\t\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Physiology-Inner-Steady-State.svg) 小剂量 + 痛苦 + 恢复 = 成长\n\t{%endcenterquote%}\n\n### 神经递质\n- 区别于激素，激素是内分泌腺体分泌出来的，神经递质是神经细胞分泌出来的。\n- 启示：大目标要拆解成小目标，小目标再拆解成最小可执行单元的 Todo List。四大神经递质闭环助你达成做成一件大事。这也是 PDCA 循环模型的生物学底层原理。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Physiology-Neurotransmitters-Approach-Goal.svg) 四大神经递质闭环\n\t{%endcenterquote%}\n\n\t- 每天完成 todo list，获得内啡肽型小快乐。\n\t- todo list 通往小目标，小目标冲刺激发去甲肾上腺素释放 。\n\t- 小目标通往大目标，大目标达成时给自己一个大奖励，以刺激多巴胺分泌。\n\t- 大目标完成后，找时间回顾反思，刺激血清素分泌，以提升我们的客观感知力。\n\n\t\t> 即动用元认知能力，回忆推敲整个做事过程，举一反三，提高效率。\n\n#### 多巴胺\n- 多巴胺型快乐：先甜后苦型快乐，使人快乐、血管扩张，多巴胺消散后会让人感到失落，得重新寻找更多更刺激的多巴胺快乐。\n\n\t> 比如，抽烟、喝酒、打游戏、购物、刷抖音等。\n\n- 内啡肽型快乐：先苦后甜型快乐，身体或精神遭受痛苦之后，身体会分泌内啡肽，它的作用是镇痛和平静、增强免疫力。\n\n\t> 比如，瑜伽、健身、长跑、唱歌、完成一项任务等。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/Physiology-Endorphins-Dopamine.svg) 多巴胺 v.s. 内啡肽\n\t{%endcenterquote%}\n\n#### 催产素\n- 催产素：让人平静，提高同理心\n\n#### 血清素\n- 血清素：\n\t- 缺乏会导致焦虑、抑郁，有暴力倾向。\n\t- 可改善人的睡眠，让人平静，产生幸福感“大爱”的体验。\n\n- 刺激血清素分泌的方法\n\t- 晒阳光\n\t- 有节奏的运动：慢跑、跳舞的、游泳、**有意识的呼吸**\n\t- 冥想\n\t- 咀嚼：分泌唾液帮助消化，也分泌血清素\n\n#### 去甲肾上腺素\n- 去甲肾上腺素：面临压力、惩罚、损失时被激发出来，使得我们注意力更集中。但副作用是刺激过后身体会很疲惫，会有虚脱感。\n\n## 自我管理重要模型\n\n{%centerquote%}\n让自身成效不高的管理者管好他们的同事与下属，那几乎是不可能的事情。管理工作在很大程度上是要言传身教的，若管理者不懂得在工作中做到卓有成效，就会给其他人树立错误榜样。\n—— 德鲁克《卓有成效的管理者》\n{%endcenterquote%}\n\n- 精力管理 v.s. 身价管理 v.s. 企业管理\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/SelfManagment-Vigour-Valuable-Enterprice.svg) 精力管理 v.s. 身价管理 v.s. 企业管理\n\t{%endcenterquote%}\n\n### 精力管理\n- 精力管理不等于时间管理\n\t- 可取：精力充沛干两个小时的成果\n\t- 避免：浑浑噩噩干十二小时的成果\n\n- 全情投入的力量\n\n\t<table>\n\t\t<tbody align=\"center\">\n\t\t\t<tr>\n\t\t\t\t<th><center>旧挂念<center></th>\n\t\t\t\t<th><center>新观念</center></th>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t管理时间<br>\n\t\t\t\t避免压力<br>\n\t\t\t\t生活是一场马拉松<br>\n\t\t\t\t放松是在浪费时间<br>\n\t\t\t\t回报驱动表现<br>\n\t\t\t\t依靠自律<br>\n\t\t\t\t积极思考的力量<br>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t管理精力<br>\n\t\t\t\t适度承压<br>\n\t\t\t\t生活是一系列短跑冲刺<br>\n\t\t\t\t放松时有效产出的时间<br>\n\t\t\t\t目标驱动表现<br>\n\t\t\t\t依靠习惯<br>\n\t\t\t\t全情投入的力量\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n\n- 人类精力金字塔\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/SelfManagment-Vigour-Pyramid.svg) 人类精力金字塔\n\t{%endcenterquote%}\n\t\n- 体能与情绪有着密切关系，与思维没什么大关系。然而，当代年轻人着重思维能力训练，而体能、情绪反而是最少的。\n\n\t{%centerquote%}\n\t![](/images/Reading/Interdisciplinary-Thinking/SelfManagment-PhysicalForce-Emotion.svg) 情绪体能四象限图\n\t{%endcenterquote%}\n\n- 钟摆运动：精力消耗与补充的重要原理\n\t- 将每天的精力抽象划分为无数个小球，从左往右依次消耗，人每天从旺盛状态逐渐精力消耗编程匮乏状态。\n\t- 到达匮乏状态，本能觉得干不动就想休息、补充精力，逐渐恢复到旺盛状态。\n\t- 而现代人总是过度消耗精力，即钟摆摆到 5 号位置，此刻会进入一种迟钝状态（麻木状态）。\n\n\t\t> 迟钝状态之下，工作效率低下而**不自知**。高效工作避免进入该区域。\n\t\n\t\t{%centerquote%}\n\t\t![](/images/Reading/Interdisciplinary-Thinking/SelfManagment-Pendulum-Movement.svg) 钟摆运动\n\t\t{%endcenterquote%}\n\n\t- 启示：我们要刻意安排休息、专注休息。专注休息的方法有提前总结“补充精力”的仪式、设 定时闹钟有节奏地休息（番茄工作法）。\n\n\t\t> 比如，休息时刷短剧、听听歌等。\n\t\n- 建立习惯是精力管理的精髓 —— 詹姆斯·克利尔《掌握习惯》\n\t- 看得见：让建立习惯的过程可视化，即时反馈机制。\n\n\t\t> 比如，打卡次数、频率、完成任务花费时间等。但注意不要陷入为打卡而打卡、为凑时长而凑时长的窘境。\n\n\t- 闻得香：让难以建立的习惯跟轻松愉悦本能联系在一起。\n\n\t\t> 比如，要求自己完成某项打卡任务后，才能娱乐片刻。\n\n\t- 摸得着：建立复杂的习惯从最简闭环做起。\n\n\t\t> 比如，从每天运动 10 分钟，迈出第一步。随时间推移逐渐增加时间，争取每天能运动半小时。\n\n- 同理，杜绝坏习惯也适用该方法，将惩罚与不达标绑定在一起。\n\n### 身价管理\n- 权力分配的基本原理：世界是不公平的\n\n- 公平世界假设\n\t- 假设厉害的人更容易成功，不厉害的人更容易失败。\n\t- 成功是因为他人的优点，失败是因为他人的缺点。\n\n\t\t> 放大效应：成功会放大他的优点，失败也会放大他的缺点。\n\n- 启示：默默积累，打磨能力，把握机会拿到自己第一次关键成功，并且要让大家看到它的重要性。\n\n- 在公司/组织里获得好身价，跟一个产品在市场里卖得好价钱的原理是一样的。\n\t- 打铁还需自身硬：分工链条的某环节做到最好 **不可取代**。\n\t\t- 差异化能力：某项过硬专业能力 + 跟它距离较远的能力。\n\n\t\t\t> 比如从政府跳到互联网的从业者，在政企合作方面有很大跨界优势；经常去养老院当义工的产品经理，要开发一款老年人的电子产品。\n\n\t\t- 差异化生态位： 独特的供给，特别客户需求。\n\n\t\t\t> 差异化能力 $\\neq$ 差异化生态位\n\t\n\t- 抓住客户需求：理解老板或公司的需求，愿意站在老板角度换位思考。\n\t\t- 问就是了解老板需求最好的方法\n\t\t- 问他接下来哪些方面的工作最关键\n\t\t- 问他如何看待你接下来应该做的事情\n\t\t- 如果老板需求不明确，要告知对方有什么变化请第一时间联系我\n\n\t- 产品包装：不仅要把活干好，还得懂得把成果展现出来。\n\t\t- 把握机会的眼光，冷静细致的头脑，敢于站出来的勇气。\n\t\t- 比如关键报告敢于争取署名的机会、工作群里站出来解决公司关键问题。\n\t\n\t- 保持外界交流，增加流动性，即维持 **弱联系** 的习惯。\n\n## 回到真实世界\n\n### 两条成长路线\n- 两条成长路线：街头智慧 v.s. 书本智慧\n\t- 书本智慧：读万卷书行万里路。走这条路最危险的是读的书还不够多，却自以为已经读了很多书，此时会认为自己有主见但实际对世界的理解又很片面。\n\t- 街头智慧：肉身碰撞世界，依靠长时间肉身去跟残酷概率世界碰撞，用血和泪去沉淀下一种叫经验直觉的体感，这过程中非常考验人的体力、意志力、心理、智力。\n\n\t> 启示：任何知识、智慧和想法，如果没有变成结果，它都只是你的潜力，而不是你的实力。\n\n- 推荐一部记录片《[富豪谷底求翻身](https://www.bilibili.com/bangumi/play/ep337065)》，街头智慧的最佳诠释。比如：\n\t- 自信的力量：表现得自信就已经超过绝大多数人了。\n\t- 有需才有供：调研需求，创造销售条件。\n\t- 情绪化管理：负面对自身或他人毫无意义。\n\t- 仆人式领导：专业人做专业事，懂得尊重、包容、激励、激发人才。\n\t- 勤思考少抱怨：遇到挫折专注清醒思考与计算，而不是抱怨和哀叹。\n\t- 小目标大局观：不忘初心和使命；两点论和重点论结合。\n\t- 先他人后个人：自己想赚钱，先给别人先赚钱。\n\t- 多开口大胆问：争取优惠、折扣、福利，可以利用自身行头/优势去获取资源，比如身份、美貌、人缘等，特别是线下交易场景会有明显效果。\n\t- 同理共情示弱：不管是表演还是真情流露，要懂得主动示弱承认自身不足、主动理解对方立场及体会、诚意做出承诺并且达成诺言。\n\t\n\t\t> 观察很多成功博主，他们会主动示弱、激发观众同理心，拉近观众距离。另一方面，也会让观众产生“优越感” 和欢乐感。正如张国荣先生讲的“我们的快乐建筑在观众的快乐之上，只有观众快乐我们才可能拥有”。\n\n- 街头智慧，需要不断跟世界碰撞，正因为这种碰撞太疼，很多人被撞过后就会放弃。特别是很疼之时，能抓住一根救命稻草就再也不愿意放手，阶层突破到此为止。而他们还会不自觉地攻击其他还在尝试突破现状的人。\n\n### 跨越阶层武器\n- 代价：为了获得什么，想清楚自己愿意付出什么样的代价。\n\t- 获取更好的精力，是否愿意付出更多刷视频或玩游戏的时间来锻炼。\n\t- 想挣脱旧的社交环境，是否准备好跟之前的亲人朋友疏远。\n\t- 冲入一个陌生的行业，是否准备好在一个无人认可你的环境硬着头皮向所有人请教。\n\t- 积极储蓄未雨绸缪，是否能忍受长期节约低消费的痛苦。\n\n\t> 提示：付出代价不一定能成功跨越阶层。\n\n- 时间：遍历性原理，只有活得足够久，才可能看到概率世界真正的模样。\n\n- 环境：选择环境，其实是选择基础概率（先验概率），基础概率大概率决定成败。\n\t- 选择权：先高后低，先难后易、先动后静\n\t- 机会量：涌现，比如更多亚文化、小众职业、小圈子市场\n\n\t> 启示 1：选择城市和行业重要程度远远大于公司和职位，因为它们不属于一个量级的比较。\n\t> 启示 2：如果承受了大城市的成本，必须充分挖掘大城市带来的收益。\n\n### 职业选择问题\n\n{%centerquote%}\n![](/images/Reading/Interdisciplinary-Thinking/RealWorld-Life-Order.svg) 四种职业目标\n{%endcenterquote%}\n\n- 四种职业目标\n\t- 势：看宏观、看长期、顺应国家发展潮流\n\t- 爽：看微观、看长期、顺应自己内心召唤\n\t- 钱：看机会、看短期、目标锁定积累金钱\n\t- 安：回归生活、远离竞争、进入安稳生活状态\n\n- 不同成长区域，不同职业路线\n\t- 2 号区：能不能忍受长期待在一个行业里，很长时间做一个不完美规则的跟随者，慢慢忍耐积累实力。\n\t\t- 启示1：关注势，而非去尝试发挥潜力，在短时间内一飞冲天。也不要高估自己，在没有积累足够势能下跳出秩序域，过早开创自己的规则。\n\t\t- 启示2：也请不要忽略人脉的价值。因为能力驱动成功，当能力无法被衡量时，社会网络驱动成功，比如通过员工内推找工作。\n\t\t- 启示3：追求安，大城市多年打拼，不想再承受大城市的压力，选择考家乡公务员、进入家乡大企业，但得谨防进入过度封闭导致僵化的状态，我们要不断创造信息和能量交换。\n\t- 3 号区：两种稳定态\n\t\t- 钱：先集中精力解决金钱的原始积累问题。很多情况属于起步没有进入正循环，若循规蹈矩不做任何突破，将与 2 号区的差距愈来愈大（马太效应）。\n\t\t\n\t\t\t> 启示：猥琐发育，抓住小机会，在边缘市场赚辛苦钱。\n\t\t\n\t\t- 爽：再去追求一份自己乐此不彼的事业。比如自媒体、个人开发者、个人作家、健身教练等。\n\n\t\t\t> 提示：有的爽离钱很近，但有的爽离钱很远。比如有的人喜欢收集旧游戏机，开了一间复古游戏机商店，而市场需求决定了它很大机率要凉凉了。\n\n### 投资理财问题\n- 适应人群\n\t- 2 号区里有稳定工作的同学，奉行长期主义，理财规划要趁早。\n\t- 2、3 号区同学因为一些特殊机缘，已经获得第一桶金。\n\n- 理财建议\n\t- 货币基金替代银行存款。\n\t- 一二线城市房屋出租市场应该会呈现 `供需两旺` 的现象，比如投资公寓用于出租（只要年化租金收入超过房价 4% 就是划算的）。\n\n\t\t> 注意：公寓不限购，首付高，贷款利率高，没有学区，不能落户。\n\n\t- 中国在不动产资产证券化领域应该有不少的机会，比如 REITs 基金、不动产投资信托资金。\n\t- 长期定投中国未来 30 年持续增长赛道行业的 ETF 基金（指数基金）。 ","tags":["内卷","职场","熵","效率","考研","创业"],"categories":["Reading"]},{"title":"回顾 2021，启航 2022","url":"/2022/01/2021-Reviews-2022-Plans.html","content":"\n不管走得多远、多快，都要回头望一望走过的路。复盘过去，深刻反思，总结经验，探索未来。\n\n<!-- More -->\n\n## 读书\n\n- 已阅\n\t- [技术]《深入浅出区块链》\n\t- [设计]《设计入门教室：设计的基本规则》\n\t- [财务]《富爸爸穷爸爸》\n\t- [心理] 《活出心花怒放的人生》\n- 精读：费曼学习法\n\t- [技术]《软件设计师》\n\t- [效率]《子弹笔记》\n- 未达成目标\n\t- [财务]《肖星的财务思维课》[20%]\n\t- [技术]《大型网站技术架构》[60%]\n\t- [物理]《上帝掷骰子吗》[15%]\n\t- [心理]《被讨厌的勇气》[20%]\n\t- [效率]《OKR工作法》[20%]\n\t- [社科]《去依附》[0%]\n- 计划\n\t- [心理]《放弃的艺术》\n\t- [心理]《别独自用餐》\n\t- [生理]《大脑帝国》\n- 总结\n\t- 涉猎类型窄，以兴趣为点拓宽自身阅读面。\n\t- 阅读量太少，充分利用好碎片时间多读书。\n\t- 阅读先通读，再通过费曼学习法记录读书笔记（精读）。\n\n## 课堂\n\n- [通识] 所长林超《[跨学科的思维课](https://www.bilibili.com/cheese/play/ss298)》：跨学科思维模式训练\n- [经济] 珍大户《[认识世界的经济课](http://zhendahu.duanshu.com/#/course/c1cb5f2585fa4f68a7f34b5bcb23fb9a)》：强逻辑思维的微观经济学课程 + 接地气的生活案例课\n- [财务] 肖星《[肖星的财务思维课](https://book.douban.com/subject/35033236/)》：财务小白的入门书籍\n- [技能] 张策《[张策的短视频创作课](https://www.bilibili.com/cheese/play/ep5662)》：新时代斜杆青年，纵观市场千篇一律具备专业技能的 “人力资源”，习得稀缺性能力，比如拍好小视频的能力或许会获得独特的生态位，毕竟眼睛看得到、耳朵听得到的是最直观的。\n\n## 启发\n- 《富爸爸穷爸爸》：财商理财启蒙\n\t- 目标：平衡生活开支，竭尽全力购入能带来收入的资产。\n\t- 目标：降低负债支出，延迟消费，争取更多钱投入资产。\n\t- 起步：尽力兼顾兴趣工作带来收入。\n\t- 提升：投入资产接受教育自我增值。\n\t- 教育：不限投资经验、技能谋生树。\n\n\t\t> 不仅仅财富是资产，知识更像是\"元\"资产。\n\n- 《[隐姓亿万富翁](https://www.bilibili.com/bangumi/play/ep337065)》：街头智慧的最佳诠释\n\t- 有需才有供：调研需求，创造销售条件\n\t- 情绪化管理：负面对自身或他人毫无意义\n\t- 仆人式领导：专业人做专业事，懂得尊重、包容、激励、激发人才\n\t- 小目标大局观：不忘初心和使命；两点论和重点论结合\n\n- 《[大空头](https://movie.douban.com/subject/26303622/)》《[商海通牒](https://movie.douban.com/subject/4888853/)》《[大而不倒](https://movie.douban.com/subject/6013501/)》：金融题材电影，更通俗易懂地了解金融危机、次贷危机。\n\n- 《[经济机器是怎样运行的](https://www.bilibili.com/video/BV1oJ411K7mR)》：宏观经济学入门推荐短片。\n\n## 习惯\n\n- 个人精气神塑造计划：围绕 `运动`、`睡眠`、`戒糖` 三方面开展的微习惯养成计划，每周对三项指标进行考核，不达成目标将会受到惩罚（锁定灵活取用资金、延迟愿望实现时间等）。\n\n\t- 说明\n\n\t\t<table>\n\t\t<thead>\n\t\t<tr>\n\t\t\t<th width=15%>项目</th>\n\t\t\t<th>说明</th>\n\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t<tr>\n\t\t\t<td>💪 运动</td>\n\t\t\t<td>\n\t\t\t1. 周工作日，争取一次 Keep 简训<br>\n\t\t\t2. 周五六日，一主一辅 Keep 简训\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>😪 睡眠</td>\n\t\t\t<td>1. 周工作日，23:45 停掉所有强制休息<br>2. 周五六日，01:45 停掉所有强制休息</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>🥤 戒糖</td>\n\t\t\t<td>每周仅允许两次主动摄入</td>\n\t\t</tr>\n\t\t    </tbody>\n\t\t</table>\n\n\t- 规则\n\n\t\t<table>\n\t\t<thead>\n\t\t<tr>\n\t\t\t<th width=15% >项目</th>\n\t\t\t<th>规则</th>\n\t\t\t<th>备注</th>\n\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t<tr>\n\t\t\t<td>💪 运动</td>\n\t\t\t<td>+ 奖励最高 4 次，- 惩罚最高 3 次</td>\n\t\t\t<td>周一至周四自由选择，周五六日必须要锻炼</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>😪 睡眠</td>\n\t\t\t<td>+ 奖励最高 7 次，- 惩罚最高 7 次</td>\n\t\t\t<td>--</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>🥤 戒糖</td>\n\t\t\t<td>+ 奖励最高 2 次，- 惩罚最高 5 次</td>\n\t\t\t<td>主要指喝奶茶或饮料的次数</td>\n\t\t</tr>\n\t\t</tbody>\n\t\t</table>\n\n\t- 数据\n\n\t\t{% echarts 400 100% %}\n\t\t{\n\n\t\ttooltip: {\n\t\t\ttrigger: 'axis',\n\t\t\taxisPointer: {\n\t\t\t\ttype: 'cross',\n\t\t\t\tlabel: {\n\t\t\t\t\tbackgroundColor: '#6a7985'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tlegend: {\n\t\t\tdata: ['运动奖励', '运动惩罚', '睡眠达标','熬夜惩罚', '戒糖达标', '戒糖惩罚']\n\t\t},\n\t\ttoolbox: {\n\t\t\tfeature: {\n\t\t\t\tsaveAsImage: {}\n\t\t\t}\n\t\t},\n\t\tgrid: {\n\t\t\tleft: '3%', right: '4%', bottom: '3%',\n\t\t\tcontainLabel: true\n\t\t},\n\t\txAxis: [\n\t\t\t{\n\t\t\t\ttype: 'category',\n\t\t\t\tboundaryGap: false,\n\t\t\t\talignWithLabel: true,\n\t\t\t\tdata: [\n\t\t\t\t'0823-0829', '0830-0905', '0906-0912', '0913-0919', \n\t\t\t\t'0920-0926', '0927-1003', '1004-1010', '1011-1017', \n\t\t\t\t'1018-1024', '1025-1031', '1101-1107', '1108-1114', \n\t\t\t\t'1115-1121', '1122-1128', '1129-1205', '1206-1212', \n\t\t\t\t'1213-1219', '1220-1226'\n\t\t\t\t]\n\t\t\t}\n\t\t],\n\t\tyAxis: [\n\t\t\t{\n\t\t\t\ttype: 'value',\n\t\t\t\tname: '奖励',\n\t\t\t\tmin: -7, max: 7,\n\t\t\t\tposition: 'left',\n\t\t\t\tsplitNumber: 14,\n\t\t\t\taxisLabel: {\n\t\t\t\t\tformatter: '{value} 次'\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\tseries: [\n\t\t\t{\n\t\t\t\tname: '运动奖励',\n\t\t\t\ttype: 'line',\n\t\t\t\tsmooth:true,   // 为 true 是不支持虚线的，实线就用true\n\t\t\t\titemStyle:{\n\t\t\t\t\tnormal:{\n\t\t\t\t\t\tlineStyle:{\n\t\t\t\t\t\t\twidth:2,\n\t\t\t\t\t\t\ttype:'solid'\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcolor: '#f87466'\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdata: ['4', '3', '3', '2', '3', '3', '3', '1', '1', '2', '1', '3', '2', '3', '2', '2', '1', '2']\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: '运动惩罚',\n\t\t\t\ttype: 'line',\n\t\t\t\tsmooth:true,\n\t\t\t\titemStyle:{\n\t\t\t\t\tnormal:{\n\t\t\t\t\t\tlineStyle:{\n\t\t\t\t\t\t\twidth:2,\n\t\t\t\t\t\t\ttype:'dotted'  // 'dotted'虚线 'solid'实线\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcolor: '#f87466'\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdata: ['-1', '-2', '-1', '-3', '0', '-1', '-1', '0', '-3', '-2', '-2', '-1',  '-1', '-2', '-2', '-1', '-1', '-2']\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: '睡眠达标',\n\t\t\t\ttype: 'line',\n\t\t\t\tsmooth:true,\n\t\t\t\titemStyle:{\n\t\t\t\t\tnormal:{\n\t\t\t\t\t\tlineStyle:{\n\t\t\t\t\t\t\twidth:2,\n\t\t\t\t\t\t\ttype:'solid'\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcolor: '#3f5d95'\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdata: ['4', '4', '6', '4', '3', '2', '0', '4', '5', '3', '2', '6', '2', '2', '3', '3', '2', '2']\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: '熬夜惩罚',\n\t\t\t\ttype: 'line',\n\t\t\t\tsmooth:true,\n\t\t\t\t\titemStyle:{\n\t\t\t\t\t\tnormal:{\n\t\t\t\t\t\t\tlineStyle:{\n\t\t\t\t\t\t\t\twidth:2,\n\t\t\t\t\t\t\t\ttype:'dotted'  // 'dotted'虚线 'solid'实线\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\tcolor: '#3f5d95'\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdata: ['-3', '-3', '-1', '-3', '-4', '-5', '-7', '-2', '-2', '-4', '-5', '-1', '-5', '-5', '-4', '-4', '-6', '-5']\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: '戒糖达标',\n\t\t\t\ttype: 'line',\n\t\t\t\tsmooth:true,\n\t\t\t\titemStyle:{\n\t\t\t\t\tnormal:{\n\t\t\t\t\t\tlineStyle:{\n\t\t\t\t\t\t\twidth:2,\n\t\t\t\t\t\t\ttype:'solid'\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcolor: '#ffca3a'\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdata: ['0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0', '1', '0']\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: '戒糖惩罚',\n\t\t\t\ttype: 'line',\n\t\t\t\tsmooth:true,\n\t\t\t\titemStyle:{\n\t\t\t\t\tnormal:{\n\t\t\t\t\t\tlineStyle:{\n\t\t\t\t\t\t\twidth:2,\n\t\t\t\t\t\t\ttype:'dotted'  // 'dotted'虚线 'solid'实线\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcolor: '#ffca3a'\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdata: ['-3', '-2', '-1', '-2',  '-1', '-2', '-2', '0', '0', '0', '-1', '-1', '-1', '0', '-2', '-3',  '0', '-1']\n\t\t\t}\n\t\t]\n\t\t};\n\t\t{% endecharts %}\n\t\t\n\t- 总结：精气神塑造计划是从 202106 开始的，省略前期比较杂乱的数据统计，为此统计区间筛选为 202108 ~ 202112。\n\t\t- `总评价`：运动指标 $\\color{green}{优秀}$，戒糖指标 $\\color{blue}{良好}$，睡眠指标 $\\color{red}{不合格}$。\n\t\t- `运动指标`：外在雕塑身材，爱美之心驱使健身上瘾；内在自强自律，适当地挑战极限锻炼自身意志力。2021 年度整体运动表现不错，寄望 2022 年度每周运动的习惯要继续保持下去，与其同时，要主动更多地学习健身知识。\n\t\t- `睡眠指标`：下半年每天入睡时间都比较晚，主要因素是焦虑，下班后忙于学习各种课程。但万事万物讲究平衡，操之过急伴随着不可预知的风险，今年的主题尽可能往 `慢节奏` 中偏移，适当地慢或许有更佳成效。\n\t\t- `戒糖指标`：中规中矩，主要外出聚餐的频率有些偏高，聚餐少不了喝酒或者饮料。更值得反思的是，买奶茶的频率似乎很高，既使知道喝多伤身但就不听使唤，真的道理都懂执行很难。这次尝试把喝奶茶跟痛苦的事情绑在一起，一次不要太狠有成效即可。\n\n## 消费\n- 纵观年度消费清单，一句话总结即深陷消费主义泥潭，但愿早日脱离上岸。\n\n\t<table>\n\t\t<thead>\n\t\t<tr>\n\t\t\t<th width=\"15%\">消费类型</td>\n\t\t\t<th>消费清单</td>\n\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t<tr>\n\t\t\t<td>音乐发烧</td>\n\t\t\t<td>\n\t\t\t\tB&O H95<br>AirPods 3<br>SONY M9 + DUNA 瑾<br>\n\t\t\t\tFiio M11 Plus<br>Oriolus BA20 + BD20\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>电脑发烧</td>\n\t\t\t<td>PVE（AllinOne Server）</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>手机发烧</td>\n\t\t\t<td>iPhone 13 Pro</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>消费升级</td>\n\t\t\t<td>iPad Case + iPhone Case + iPhone Wallet</td>\n\t\t</tr>\n\t\t</tbody>\n\t</table>\n\n- Q1：2021 年度购买过多的数码消费品，大部分算不上“利器”（生产力）而是负债，理性的消费理念是“功能大于意义，简洁替代节约”。但是，我们总会刻意地去创造需求让消费合理化，冠上提升效率、释放压力、享受生活、追求美感等理由，创造“积极需求” 不断消费，更甚消费升级。\n\t- 启示：`4WHY分析法`，凡事多问几个为什么。两个层面要做消费决策：\n\t\n\t\t- 要不要买：购买前先问自己没有必要买？没有它就不能达成目的 / 没有它结果会和预期差很远 / 没有它完成目标时效差很多？\n\t\t- 怎么样买：是否有更低成本的替代方案？是否可延迟满足，等待历史最低价再购买？是否考虑二手商品？\n\t\n\t- 启示：`评分卡模型`，应对消费者渣型心理， 以辅助我们走出 \"决定买时什么都想买\" 的窘境。模型中，每一项指标不同人心中的权重都不一样，购买前给产品打分，再按照权重求得模型总得分。\n\n\t\t> 方法启发于 [半佛仙人.科学的刀打断消费主义的骚.Bilibili.com](https://www.bilibili.com/video/BV1cF411h7aT)\n\n\t\t- 资金占比程度：利用分红资金（奖励金）购买商品，预算占分红资金的比例。\n\t\t- 产品附加效应：功能大于意义。\n\t\t- 紧急等级：等等党永不为奴。\n\t\t- 需求满足递减效应：是否已拥有替代品。\n\t\t- 残值利用可行性：二手回血。\n\t\n- Q2：经济增速下滑大环境之下，现今的心理焦虑问题不容小觑，有时候在学业、工作上得不到的，或者生活上不如意的，总会想方设法在不同方面寻求满足感，加上消费主义当行、商家不断洗脑需求，似乎 ”买买买“ 带来的多巴胺快乐暂且能掩盖所有不愉快的事物。但始终不闭环的过程，只会在消费主义的陷阱中越陷越深。\n\t\n\t- 启示：寻找合适的杠杆解，学业、工作、生活方面的不理想，请按照不同的课题来分析问题、解决问题。比如：\n\t\t- 学业：学习不同学科知识，横向扩宽知识面，纵向提高认知力。焦虑感更多是自身局限的认知导致的。\n\t\t- 工作：差异化建设自身能力圈，并深耕一项专业技能做到不可取代，这也是打破内卷的良方。\n\t\t- 生活：饮食、睡眠、运动、心情。\n\n","tags":["总结","消费","书单"],"categories":["Journal"]},{"title":"技术资格考试：中级软件设计师","url":"/2021/12/Mid-Software-Exam.html","content":"\n- 刚踏足职场，牢固技术功底对我们未来走得多远尤为重要。然而当今工作环境迫使我们 “沉迷” 追逐新概念、新技术，比如机器学习、大数据技术等，难免内心难免会浮躁不安，有时候走得太快反而淡忘了软工知识体系正是当初上学时期指导我们认识软件世界的重要角色。正如设计模式给我们启示，认知不应依赖于具象，而是抽象概念指导认识，学习应是如此，不随波逐流，巩固根基知识更容易让自我渐入一个熵减过程。\n- 软件设计师（中级）所考查的内容正是软件工程体系知识树的缩影，很庆幸能借此机会温故知新，同时复习过程以笔记形式记录在案，即知识输入到输出全过程，以构建起属于自己的计算机科学知识体系。\n- 最后声明一点，知识复盘固然重要，但考试终究要刷题练习。希望笔记内容能帮到有同样备考需要的朋友，若笔记有错误之处，还请您不吝赐教、指正。\n\n<!-- More -->\n\n## 备考调研\n\n### 报名信息\n- 考试名称：[计算机技术与软件专业技术资格  (水平) 考试](https://www.ruankao.org.cn/)\n- 考纲范围：[百度百科 - 考试要求](https://baike.baidu.com/item/软件设计师/8783801?fr=aladdin)\n- 报名时间：第二季度（2-4 月）；第四季度（7-9 月）\n- 考试时间：第二季度（5 月）；第四季度（11 月）\n- 单科满分：`75分`；合格分数：`45分`\n- 考试形式：`客观题` 和 `主观题`，均为 `笔试`\n\n\t> 客观题讲究做题技巧，优先考虑排除法；主观题讲究标准解答，复习以真题为主。 \n\n- 考试科目：中级软考的科目名称\n\n\t<table>\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<th>专业类别</th>\n\t\t\t\t<th>专业类别</th>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<td>计算机软件</td>\n\t\t\t\t<td>软件设计师 ✓<br>软件评测师<br>软件过程能力评估师</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>计算机应用技术</td>\n\t\t\t\t<td>多媒体应用设计师<br>嵌入式系统设计师<br>\n\t\t\t\t计算机辅助设计师<br>电子商务设计师</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>信息系统</td>\n\t\t\t\t<td>系统集成项目管理工程师<br>信息系统监理师<br>\n\t\t\t\t数据库系统工程师 ✓<br>信息系统管理工程师<br>信息安全工程师</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>信息服务</td>\n\t\t\t\t<td>计算机硬件工程师<br>信息技术支持工程师</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n\n### 参考资料\n- 知乎问答：[冯连, faniim 等. 软考中级的软件设计师难考吗. zhihu.com](https://www.zhihu.com/question/35689101)\n\n## 更新进度\n- [ ] 计算机系统导论【※】\n\t- [ ] 计算机系统基础\n\t- [ ] 计算机体系结构\n- [ ] 程序设计语言基础\n\t- [ ] 程序设计语言\n\t- [ ] 语言处理程序：汇编、编译、解释\n- [ ] 数据结构\n\t- [ ] 线性结构\n\t- [ ] 数组 / 矩阵 / 广义表\n\t- [ ] 树\n\t- [ ] 图\n\t- [ ] 查找\n\t\t- [ ] 静态查找表\n\t\t- [ ] 动态查找表\n\t\t- [ ] 哈希查找表\n\t- [ ] 排序：内部排序\n\n\t\t<table>\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<th width=20%>基本类型</th>\n\t\t\t\t<th>细分</th>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<td>插入排序</td>\n\t\t\t\t<td>直接插入排序、折半插入排序、希尔排序</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>交换排序</td>\n\t\t\t\t<td>冒泡排序、快速排序</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>选择排序</td>\n\t\t\t\t<td>选择排序、堆排序</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>归并排序</td>\n\t\t\t\t<td>--</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>基数排序</td>\n\t\t\t\t<td>--</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t\t</table>\n\n- [ ] 算法设计与分析\n\t- [ ] 基本概念\n\t- [ ] 算法分析\n\t- [ ] 分治法\n\t- [ ] 贪心法\n\t- [ ] 回溯法\n\t- [ ] 动态规划法\n\t- [ ] 分支界限法\n- [x] 操作系统【※】：进程管理、存储管理、磁盘管理\n- [ ] 软件工程基础\n\t- [ ] 概述\n\t- [ ] 软件过程模型\n\t- [ ] 需求分析\n\t- [ ] 系统设计【※】\n\t- [ ] 系统测试【※】\n\t- [ ] 运行维护\n\t- [ ] 软件项目管理【※】\n\t- [ ] 软件质量\n\t- [ ] 软件度量\n- [x] 面向对象技术【※】\n\t- [x] UML：类图、用例图、活动图、时序图、状态图\n\t\t\n\t\t> 参考笔记：[Kofe. 高级软件工程与导论. kofes.cn. 2018](https://www.kofes.cn/2018/05/Sofeware-Engineering.html#肆-系统建模)\n\n\t- [x] 设计模式：六大设计原则、二十三种模式\n\n\t\t> 参考笔记：[Kofe. 设计模式之 Android 实践与案例. kofes.cn. 2018](https://www.kofes.cn/2018/01/Design-Pattern-Based-on-Android.html)\n\n- [x] 数据库技术【※】：数据模型（E-R 模型、数据模型、关系模型）、关系代数、SQL、规范化、事务管理、并发控制\n- [ ] 网络技术【※】\n\t- [ ] 网络概述\n\t- [ ] 网络互连硬件\n\t- [ ] 网络协议标准\n- [x] 标准化和软件知识产权【※】：标准化、软件知识产权（软件著作权、商业秘密权、专利权）\n\n## 正文内容\n### 计算机系统导论\n#### 中央处理单元\n- CPU 简化模型\n\n\t{%centerquote%}\n\t![](/images/CS/Mid-Software/mid-software-ComputingIntroduction-CPU-Simple.svg) CPU 简化模型\n\t{%endcenterquote%}\n\n- CPU 组成结构\n\n\t{%centerquote%}\n\t![](/images/CS/Mid-Software/mid-software-ComputingIntroduction-CPU.svg) CPU 基本组成结构\n\t{%endcenterquote%}\n\n- 运算单元\n\t- 算术逻辑单元 ALU：对数据的算术运算和逻辑运算。\n\t- 累加寄存器 AC：为 ALU 提供一个工作区。\n\n\t\t> 注意累加寄存器是通用寄存器之一。\n\n\t- 数据缓冲寄存器 DR：CPU 与内存、外部设备之间的数据传送中转站。\n\t- 状态条件寄存器 PSW：保存由算术指令和逻辑指令运行或测试的结果建立的各种条件码内容。\n\n- 控制单元\n\t- 指令寄存器 IR：当前执行的指令。\n\t- 程序计数器 PC：下一条要执行的指令的地址。\n\t- 地址寄存器 AR：保存当前 CPU 所访问的内存单元的地址。\n\t- 指令译码器 ID：包含操作码与地址码两部分。\n\n#### 总线系统\n- 一条总线系统同一时刻仅允许一个设备发送，但允许多个设备接口。\n- 总线分类\n\t- 数据总线：CPU 与 RAM 之间来回传送需要处理或存储的数据。\n\t- 地址总线：指定在  RAM 之中存储的数据的地址。\n\t- 控制总线：将微处理器控制单元的信号传送到周边设备。\n- 总线的性能指标：带宽 = 位宽 / 工作频率\n\t- 带宽：单位时间传送的数据总量，单位 B/s\n\t- 位宽：数据总线的位数，单位 B\n\t- 工作频率：单位时间振幅的频率，f = 1/t，单位 GHzz、MHz\n- [例] 总线带宽为 32 bit，时钟频率为 200 MHz，若总线上每 5 个时钟周期传送一个 32 bit 字，则该总线的带宽为（B/s）？\n\t- 总线带宽对齐： 32 bit / 8 bit = 4B\n\t- 每个时钟周期： t = 1 / f = 1 / 200\n\t- 该总线的带宽：4 / (5* 1/200) = 160 MB/s\n\n### 数据库技术\n#### 基本概念\n- 数据库管理系统（DBMS）的功能：\n\t- 数据库定义语言（Data Definition Language, DDL）\n\t\t- 外模式、概念模式和内模式的定义\n\t\t- 数据库完整性定义\n\t\t- 安全保密定义（口令、级别和存取权限）\n\n\t\t\t> 这些定义存储在数据字典中。\n\n\t- 数据库操纵语言（Data Manipulation Language, DML）：对数据的基本操作（增删改查）\n\n- 数据库管理系统的分类：\n\t- 关系数据库系统：借助集合代数等概念及方法处理数据库中的数据。\n\t- 面向对象的数据库系统\n\t\t- 面向对象数据模型能完整描述现实世界的数据结构，能表达数据间的嵌套、递归联系\n\t\t- 具有面向对象技术的封装、继承特性\n\t- 对象关系数据库系统：在传统的关系数据库模型基础上，提供元组、数组、集合等更为丰富的数据类型以及其操作方法。\n\n- 数据库系统的体系结构\n\t- 客户端 / 服务器模式（C/S模式）\n\t- 并行式：数据库系统是多个物理上连在一起的处理器（CPU）\n\t- 分布式：数据库系统是多个地理分开的处理器（CPU）\n\n- 数据库三级模式结构\n\t- 外模式：又称用户模式，对应 `用户级`，是某个或某几个用户所看到的数据库的数据视图，可利用 DML 对数据记录进行操作。\n\t- 概念模式：又称逻辑模式，对应 `概念级`，是数据库中全部数据的逻辑结构和特征的总体描述，并以数据库管理系统提供的 DDL 来描述定义。\n\t- 内模式：又称存储模式，对应 `物理级`，是数据库中全体数据的内部表示或底层描述。\n\n\t\t> 例如：记录的存储方式为顺序存储、B/B+ 树结构存储亦或是 Hash 存储；索引的组织方式；数据是否压缩等。\n\n\t- 两级映像：保证数据库的数据具有较高的 `逻辑独立性` 和 `物理独立性`。\n\t\t- 外模式 / 模式映射：外部级与概念级之间。\n\t\t- 模式 / 内模式映像：概念级与内部级之间。\n\n\t\t> 为保证程序正确运作，物理结构 / 逻辑结构改变，需要修改对应模式之间映像。\n\n\t\t<table>\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t<th width=20%>特性</th>\n\t\t\t<th>解释</th>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<td>物理独立性</td>\n\t\t\t\t<td>数据库的内模式发生改变时，数据逻辑结构不变</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>逻辑独立性</td>\n\t\t\t\t<td>用户应用程序与数据的逻辑结构是相互独立的</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t\t</table>\n\n- 数据库系统体系结构示意图：\n\n\t{%centerquote%}\n\t![](/images/CS/Mid-Software/mid-software-database-3layout-model.svg)关系数据库的三级模式结构\n\t{%endcenterquote%}\n\n#### 数据模型\n- 模型三要素\n\t- 数据结构： 所研究的对象类型的集合。\n\t- 数据操作：对数据库中各种对象的实例（值）允许执行的操作集合，包括操作及操作规则。\n\t- 数据的约束条件：完整性规则的集合。\n\n-  实体-联系模型（E-R 模型）\n\t- 实体\n\t- 联系\n\t\t- 一对一（1:1）：实体集 $E_1$ 与实体集 $E_2$ 集最多只有一个实体相联系。\n\n\t\t\t> 任意选择一方，加入对方主键\n\t\t\n\t\t- 一对多（1:n）：实体集 $E_1$ 中一个实体与实体集 $E_2$ 中多个实体相联系。\n\n\t\t\t> 多方加入对方主键\n\t\t\n\t\t- 多对多（m:n）：实体集 $E_1$ 中多个实体与实体集 $E_2$ 中多个实体相联系。\n\n\t\t\t> 联系集中加入双方主键\n\t\n\t- 属性\n\t\t- 简单属性、复合属性\n\n\t\t\t> 简单属性是原子的、不可再分\n\n\t\t- 单值属性、多值属性\n\n\t\t\t> 姓名 -- 单值属性；男/女 -- 多值属性\n\n\t\t- NULL 值：表示无意义或者不知道。\n\t\t- 派生属性：可从其他属性得到。例如，`工作年限` 可以从 `参加工作时间` 计算而得。\n\t- E-R 图中主要构件\n\t\n\t\t{%centerquote%}\n\t\t![](/images/CS/Mid-Software/mid-software-database-e-r.svg) E-R 图中主要构件\n\t\t{%endcenterquote%}\n\t\n\t- 扩充的 E-R 模型\n\t\t- 弱实体：一个实体的存在必须以另一个实体为前提。\n\t\n\t\t\t> 例如：某职工的家属，某家属是属于某职工的。\n\t\n\t\t- 特殊化：实体集具有相同的属性，但实体集可按照某些特征区分为几个子实体。\n\t\n\t\t\t> 例如：学生实体集可区分为：博士生、研究生、本科生、大专生等。\n\t\n- 数据模型\n\t- 层次模型：树型结构表示数据间的联系。在层次模型中，每一结点表示一个记录类型（实体），记录之间的联系用结点之间的连线表示，并且除根节点以外其他结点有且仅有一个双亲结点。\n\t\n\t\t{%centerquote%}\n\t\t![](/images/CS/Mid-Software/mid-software-database-hierarchical-model.svg)层次模型\n\t\t{%endcenterquote%}\n\t\t\n\t- 网状模型：层次模型的特例，即去掉层次结构的限制，允许两个结点之间有多种联系（复合联系）。\n\t\n\t- 关系模型：使用表格结构表达实体以及实体集之间的联系。\n\t\t- S(Sno, Sname, SD, Sage, Sex)：学生S(学号, 姓名, 系, 年龄, 性别)\n\t\t- T(Tno, Tname, Age, Sex)：教师T(工号, 姓名, 年龄, 性别)\n\t\t- C(Cno, Cname, Pcon)：课程C(课程号, 课程名称, 先修课程号)\n\t\t- SC(Sno, Cno, Grade)：选课SC(学号, 课程号, 成绩)\n\t\t\n\t\t{%centerquote%}\n\t\t![](/images/CS/Mid-Software/mid-software-database-relation-model.svg)关系模型\n\t\t{%endcenterquote%}\n\t\t\n\t- 面向对象模型：存储对象是以对象为单位，每个对象包含对象的属性和方法，具有类和继承等特性。\n\n#### 关系代数\n##### 基本概念\n###### 属性和域\n- `属性和域`：描述一个事物常常取若干特征来表示，特征又可称为属性（Attribute）。每个属性取值范围对应一个值的集合，称之为该属性的域（Domain）。\n\n\t> 第一范式：通常要求所有域都应该是原子数据。\n\n###### 笛卡尔积与关系\n- 定义 1：设 $D_1, D_2, ..., D_n$ 为任意集合，定义其笛卡尔积为：\n\n\t$$\n\tD_1 \\times D_2 \\times ... \\times D_n = \\{\n\t\t(d_1, d_2, ..., d_i, ..., d_n) | \n\t\td_i \\in D_i, i = 1, 2, 3, ..., n \n\t\\}\n\t$$\n\n\t- 每一种元素 $(d_1, d_2, ..., d_i, ..., d_n)$ 称为一个 n 元组（包含 n 个属性的元组），元组的每一个值 $d_i$ 称为元组的一个 `分量`。\n\t\n\t\t> 笛卡尔积可用二维表表示，每行表示一个元组，每列表示一种属性，每列的值来源于一个域。\n\t\n\t- 若 $D_i (i = 1, 2, ..., n)$ 为有限集，其基数为 $m_i (i = 1, 2, ..., n)$，则 $D_1 \\times D_2 \\times... \\times D_n$ 的基数为：\n\t\n\t\t$$\n\t\tM = \\prod_{i=1}^n m_i\n\t\t$$\n\t\n\t- [例] 若 $D_1 = \\{ 0, 1 \\}, D_2 = \\{ a, b \\}, D_1 = \\{ c, d \\}$，求 $D_1 \\times D_2 \\times D_3$\n\n\t\t[解] 笛卡尔积中每一个元素应该是一个三元组：\n\n\t\t$$\n\t\tD_1 \\times D_2 \\times D_3 = \\{ \n\t\t\t(0, a, c), (0, a, d), (0, b, c), \n\t\t\t(0, b, d), (1, a, c), (1, a, d), \n\t\t\t(1, b, c), (1, b, d)\n\t\t\\}\n\t\t$$\n\t\t\n\t\t{%centerquote%}\n\t\t![笛卡尔积二维表示](/images/CS/Mid-Software/mid-software-database-cartesian-exp1.svg) 笛卡尔积二维表示\n\t\t{%endcenterquote%}\n\t\n- 定义 2：$D_1 \\times D_2 \\times... \\times D_n$ 的子集称为在域 $D_1, D_2, ..., D_n$ 上的关系，记作 $R(D_1, D_2, ..., D_n)$，称关系 R 为 n 元关系。\n\t- 笛卡尔积是所有可能的组合，参与运算的某属性的取值范围（域）$D_1, D_2, ..., D_n$ 并不会取全部的可能值（组合需要有意义）。\n\t- [例] 姓名的域往往抽取有限个 {张三，李四}，学号的域也是抽取有限个 {00001, 00002, 00003}。但笛卡尔积给出他们所有的可能组合，现实情况是一个有且仅有一个学号。\n\t\t\t\n\t\t```json\n\t\t{\n\t\t\t(张三，100101), (张三，100102), (张三，100103), \n\t\t\t(李四，100101), (李四，100102), (李四，100103) \n\t\t}\n\t\t```\n\n###### 关系的相关名词\n- 目或度：R 表示关系的名字，n 是关系的目或度。\n- 候选码：关系中某一属性或者属性组的值能唯一地标识一个元组。\n- 主码：关系中有多个候选码，选择其一为主码。\n- 主属性：包含在候选码中的属性；不包含在任何候选码的属性称为非主属性。\n- 外码：关系模式 R 中的属性或者属性组非该关系的码，但为其他关系的码，那么该属性集对关系模式 R 而言既外码。\n- 全码：关系模型中所有属性组都为这个关系模式的候选码。\n\n###### 完整性约束\n- `完整性约束`：保证当授权用户对数据库修改时不会破坏 `数据的一致性`。\n\t- 实体完整性：关系 R 的主属性不能取 NULL 值。\n\t- 参照完整性：关系模型中实体间的联系是用关系描述的，故存在关系间的 `引用`。\n\t- 用户定义完整性\n\n##### 关系运算\n- `关系运算`：关系操作的操作对象与结果都是 `集合`。\n\n\t<table>\n\t\t<thead>\n\t\t<tr>\n\t\t\t<th>关系运算</th>\n\t\t\t<th>运算符</th>\n\t\t\t<th>含义</th>\n\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t<tr>\n\t\t\t<td>集合运算</td>\n\t\t\t<td>$\\cup \\\\ - \\\\ \\cap \\\\ \\times$</td>\n\t\t\t<td>并<br>差<br>交<br>笛卡尔积</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>比较运算</td>\n\t\t\t<td>$> \\\\ \\geq \\\\ < \\\\ \\leq \\\\ = \\\\ \\neq$</td>\n\t\t\t<td>大于<br>大于等于<br>小于<br>小于等于<br>等于<br>不等于</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>逻辑运算</td>\n\t\t\t<td>$\\neg \\\\ \\wedge \\\\ \\vee$</td>\n\t\t\t<td>非<br>与<br>或</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>专门的运算</td>\n\t\t\t<td>$\\sigma \\\\ \\pi \\\\ \\bowtie \\\\ \\div$</td>\n\t\t\t<td>选择<br>投影<br>连接<br>除</td>\n\t\t</tr>\n\t\t</tbody>\n\t</table>\n\n##### 基本的关系代数运算\n###### 并（Union）\n- 关系 R 与 S 具有相同的关系模式（R与S的元数相同、结构相同）。\n- 关系 R 与 S 的并属于 R 或属于 S 的元组构成的集合，记作：\n\t\t\n\t$$\n\tR \\cup S = \\{\n\t\tt | t \\in R \\vee t \\in S\n\t\\}，t \\, \\text{为元组变量}\n\t$$\n\n###### 差（Difference）\n- 关系 R 与 S 具有相同的关系模式。\n- 关系 R 与 S 的差由属于 R 但不属于 S 的元组构成的集合，记作：\n\t\n\t$$\n\tR - S = \\{t | t \\in R \\wedge t \\notin S\\}\n\t$$\n\n###### 广义笛卡儿积（Cartesian）\n- 广义笛卡儿积（Extended Cartesian Product）\n\t- 元数分别为 n 和 m 目的关系 R 与 S 的广义笛卡儿积为一个 n+m 列的元组集合。记作：\n\n\t\t$$\n\t\tR \\times S = \\{\n\t\t\tt|t = <t^n, t^m> \\, \\wedge \\, t^n \\in R \\wedge \\, t^m \\in S\n\t\t\\}\n\t\t$$\n\t\n\t\t> <$t^n$, $t^m$> 为元组 $t^n$ 与 $t^m$ 拼接成的一个元组。\n\n###### 投影（Projection）\n- 投影：从关系的 `垂直方向` 进行运算，在关系 R 中选择若干属性列 A 组成新的关系，记作：\n\n\t$$\n\t\\pi_A(R) = \\{  t[A] | t \\in R \\}\n\t$$\n\n###### 选择（Selection）\n- 选择：从关系的 `水平方向` 进行运算，是从关系 R 中选择满足给定条件的诸元组，记作：\n\n\t$$\n\t\\sigma_F(R) = \\{ t | t \\in R \\wedge F(t) = True \\}\n\t$$\n\t\n\t- F 中运算对象是属性名（或列序号）、常数、运算符（算术比较符和逻辑运算符）。\n\t- [例1] $\\sigma_{1 \\geq 6}(R)$ 表示选取 R 关系中第一个属性大于等于第六个属性的元组； \n\t- [例2] $\\sigma_{1 \\geq 6}(R)$ 表示选取 R 关系中第一个属性大于等于 6 的元组。\n\n##### 扩展的关系代数运算\n\n###### 交（Intersection）\n- 关系 R 与 S 具有相同的关系模式。\n- 关系 R 与 S 的交是由属于 R 同时又属于 S 的元组构成的集合，记作：\n\n\t$$\n\tR \\cap S = \\{t | t \\in R \\wedge t \\in S \\}\n\t$$\n\t\n\t> 等价于 $R \\cap S = R-(R-S)$\n\n###### 连接（Join）\n- 无条件连接：笛卡儿积\n- 有条件连接：$\\theta$ 连接 / 等值连接 / 自然连接\n\t- $\\theta$ 连接：从笛卡儿积中选取属性间满足一定条件的元组，记作：\n\n\t\t$$\n\t\tR \\bowtie_{X \\theta Y} S = \\{\n\t\t\tt | t = <t^n, t^m> \\wedge\n\t\t\tt^n \\in R \\wedge t^m \\in S \\wedge\n\t\t\tt^n[X] \\, \\theta \\, t^m[Y]\n\t\t\\}\n\t\t$$\n\t\n\t- $X \\theta Y$ 为连接条件，$\\theta$ 为比较运算符。X、Y 分别是关系 R、S 上度数相等且可比的属性组。\n\t\t- $t^n[X]$ 表示 R 中 $t^n$ 元组对应于属性 X 的一分量。\n\t\t- $t^m[Y]$ 表示 S 中 $t^m$ 元组对应于属性 Y 的一分量。\n\t- 等值连接：当 $\\theta$ 为 `=` 时称作等值连接，记作：\n\n\t\t$$\n\t\tR \\bowtie_{X = Y} S = \\{\n\t\t\tt | t = <t^n, t^m> \\wedge\n\t\t\tt^n \\in R \\wedge t^m \\in S \\wedge\n\t\t\tt^n[X] = t^m[Y]\n\t\t\\}\n\t\t$$\n\n\t- 自然连接\n\t\t- 特殊的 `等值连接`，他要求两个关系中进行比较的分量必须是相同属性组，并且在结果集中将 `重复属性列去掉`。\n\t\t- `一般连接`是从关系的 `水平方向` 运算；自然连接不仅从关系的 `水平方向` 和 `垂直方向` 运算。因此自然会去掉重复属性。\n\n\t\t\t> 没有重复属性，自然连接自然转化为笛卡儿积。\n\t\t\n\t\t- 自然连接可由基本关系运算笛卡儿积和选取运算表示：\n\n\t\t\t$$\n\t\t\tR \\bowtie S = \\prod_{\n\t\t\t\tA_1, A_2, ..., A_{n-k}, \n\t\t\t\tR.B_1, R.B_2, ..., R.B_k,\n\t\t\t\tB_{k+1}, ..., B_m\n\t\t\t}(\n\t\t\t\t\\sigma_{R.B_1 = S.B_1 \\wedge ... \\wedge R.B_k = S.B_k}\n\t\t\t\t(R \\times S)\n\t\t\t)\n\t\t\t$$\n\t\t\n\t\t\t[例] 设有关系 R 与 S，求自然连接 $R \\bowtie S$。\n\n\t\t\t{%centerquote%}\n\t\t\t![](/images/CS/Mid-Software/mid-software-database-join-exp.svg) 自然连接\n\t\t\t{%endcenterquote%}\n\n###### 除（Division）\n- 同时从关系的水平方向和垂直方向进行运算。\n- 给定关系 R(X, Y) 和 S(Y, Z)，X、Y、Z 为属性组。\n- $R \\div S$ 应当满足元组在 X 上的分量值 $x$ 的象集 $Y_x$ 包含在关系 S 在属性 Y 上投影的集合，记作：\n\n\t$$\n\tR \\div S = \\{\n\t\tt^n[X] | t^n \\in R \\wedge \\pi_y(S) \\subseteq Y_x \n\t\\}\n\t$$\n\t\n\t> $Y_x$ 为 $x$ 在 R 中的象集，$x = t^n[X]$，且 $R \\div S$ 的结果集的属性组为 X。\n\t\n- [例] 设有关系 R 与 S，求 $R \\div S$。\n\t- 由定义可得，X 为属性 AB，Y 为属性 CD。\n\t- 关系 S 在 Y 上的投影为 $\\pi_{CD}(S) = \\{(c, d), (e, f)\\}$。\n\t- 关系 R 的属性组 X 可取 3 个值 {(a, b), (b, d), (c, k)}，则它们的象集分别为：\n\t\t- $CD_{(a, b)} = \\{ (c, d), (e, f), (h, k) \\}$\n\t\t- $CD_{(b, d)} = \\{ (e, f), (d, l) \\}$\n\t\t- $CD_{(c, k)} = \\{ (c, d), (e, f) \\}$\n\t- 上述象集包含 $\\pi_{CD}(S)$ 有 (a, b) 和 (c, k)，为此 $R \\div S = \\{ (a, b), (c, k) \\}$。\n\n\t\t{%centerquote%}\n\t\t![](/images/CS/Mid-Software/mid-software-database-division-exp.svg)$R \\div S$\n\t\t{%endcenterquote%}\n\n###### 外连接（Outer Jion）\n- 外连接（Outer Jion）：自然连接时某些属性值不同则会导致这些元组被舍弃，而外连接正是用于处理由于连接运算而信息缺失的问题。\n\t- 左外连接：取出左侧关系中所有与右侧关系中任一元组都不匹配的元组，用空值 NULL 填充所有来自右侧关系的属性，以构成新的元组。\n\t- 右外连接：取出右侧关系中所有与左侧关系中任一元组都不匹配的元组，用空值 NULL 填充所有来自右侧关系的属性，以构成新的元组。\n\t- 全外连接：\n\t\t- 完成左外连接和右外连接操作。\n\t\t- 填充左侧关系中所有与右侧关系中任一元组都不匹配的元组，并填充右侧关系中所有与左侧关系中任一元组都不匹配的元组，产生新元组加入自然连接的结果中。\n- [例] 设有关系 R 与 S，求 R 与 S 的左外连接、右外连接以及全外连接。\n\n\t{%centerquote%}\n\t![](/images/CS/Mid-Software/mid-software-database-outerjoin-exp.svg) 关系 R 与 S 的外连接\n\t{%endcenterquote%}\n\n#### SQL 语言\n##### SQL 基本结构\n- 数据定义语言 (DDL)：Create、Alter 和 Drop\n- 数据操作语言 (DML)：Insert、Update 和 Delete\n- 数据查询语言 (DQL)：Where，Order By，Group By 和 Having\n- 数据控制语言 (DCL)：Grant、Revoke\n\n##### SQL 数据定义\n###### 创建表\n- 创建表：\n\n\t```sql\n\tCREATE TABLE mytable (\n\t\t-- int 类型，不为空，自增\n\t\tid INT NOT NULL AUTO_INCREMENT,\n\t\t-- int 类型，不为空\n\t\tfid INT NOT NULL,\n\t\t-- decimal 类型，不可为空，默认值为 1.0\n\t\t-- 前一个代表整数的位数，后一个代表小数的位数\n\t\tcol1 DECIMAL(10,6) NOT NULL DEFAULT 1.0,\n\t\t-- 变长字符串类型，最长为 45 个字符，可以为空\n\t\tcol2 VARCHAR(45) NULL,\n\t\t-- 日期类型，可为空\n\t\tcol3 DATE NULL,\n\t\t-- 设置主键为 id\n\t\tPRIMARY KEY (id)\n\t\t-- 设置外键为 fid\n\t\tFOREIGN KEY (fid) REFERENCES mytable1(fid)\n\t);\n\t```\n\n###### 修改表\n- 添加列：\n\n\t```sql\n\tALTER TABLE mytable\n\tADD col VARCHAR(20);\n\t```\n\n- 删除列：\n\n\t```sql\n\tALTER TABLE mytable\n\tDROP COLUMN col;\n\t```\n\n- 删除表：\n\n\t```sql\n\tDROP TABLE mytable;\n\t```\n\n###### 建立索引\n- 创建表时创建索引：\n\n\t```sql\n\tCREATE TABLE 表名 (\n\t\t字段名1 数据类型 [完整性约束条件…],\n\t\t字段名2 数据类型 [完整性约束条件…],\n\t\t-- UNIQUE：每一个索引值只对应唯一的数据记录\n\t\t-- CLUSTER：建立聚簇索引\n\t\t[UNIQUE | CLUSTER] INDEX | KEY\n\t\t[索引名] (字段名[(长度)] [ASC | DESC])\n\t);\n\t```\n\n- CREATE 在已存在的表上创建索引：\n\n\t```sql\n\tCREATE [UNIQUE | CLUSTER] INDEX 索引名 \n\tON 表名 (字段名[(长度)] [ASC | DESC]) ;\n\t```\n\n- ALTER TABLE 在已存在的表上创建索引：\n\n\t```sql\n\tALTER TABLE 表名 ADD [UNIQUE | CLUSTER] INDEX\n\t索引名 (字段名[(长度)] [ASC | DESC]) ;\n\t```\n\n###### 删除索引\n- 删除索引：\n\n\t```sql\n\tDROP INDEX 索引名 ON 表名字;\n\t```\n\n###### 创建视图\n- 创建视图：创建视图必须遵循以下规定\n\t- 子查询可以是任意复杂的 SELECT 语句，但通常不允许含有 `ORDER BY` 子句和 `DISTINCT` 短语。\n\t- `WITH CHECK OPTION` 表示对 `UPDATE`、`INSERT`、`DELETE` 操作时保证更新、插入或删除的行满足视图定义中的谓语条件，即子查询中的条件表达式。\n\t- 组成视图的属性列名要么全部省略 / 全部制定。\n\n\t\t> 若全部省略属性列名，则由隐含该视图的 SELECT 子查询目标列的主属性组成。\n\t\n\t\t```sql\n\t\tCREATE VIEW 视图名 (属性列名)\n\t\tAS SELECT 查询子句\n\t\t[WITH CHECK OPTION];\n\t\t```\n\n###### 删除视图\n- 删除视图：\n\n\t```sql\n\tDROP VIEW 视图名\n\t```\n\n##### SQL 数据查询\n###### 基本结构\n- SELECT 基本结构\n\n\t```sql\n\tSELECT [ALL|DISTINCT] <目标列表达式>\n\tFROM <表名或视图名>\n\t[WHERE <条件表达式>]\n\t[GROUP BY <列名> [HAVING <条件表达式>]]\n\t[ORDER BY <列名> [ASC|DESC]]\n\t```\n\n- `SELECT` 子句对应关系代数中的 `投影运算`。\n\t\n\t- 输出结果可以是列名、表达式、聚合函数（COUNT、AVG、SUM、MAX、MIN）\n\t- DISTINCT 确保查询结果集中不存在重复元组，它作用于所有列，也就是说所有列的值都相同才算相同。\n- `FROM` 子句对应关系代数中的 `笛卡儿积`。\n- `WHERE` 子句对应关系代数中的 `选择谓语`， WHERE 子句的表达式中可使用的运算符如下表所示。\n\n\t<table>\n\t\t<thead>\n\t\t<tr>\n\t\t\t<th>操作符</th>\n\t\t\t<th>说明</th>\n\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t<tr>\n\t\t\t<td>=</td>\n\t\t\t<td>等于</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><</td>\n\t\t\t<td>小于</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>></td>\n\t\t\t<td>大于</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><></td>\n\t\t\t<td>不等于</td>\n    </tr>\n    <tr>\n\t\t\t<td>$\\leq$</td>\n\t\t\t<td>小于等于</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>$\\geq$</td>\n\t\t\t<td>大于等于</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>BETWEEN</td>\n\t\t\t<td>在两个值之间</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>IS NULL / IS NOT NULL</td>\n\t\t\t<td>为 NULL / 不为 NULL</td>\n\t\t</tr>\n\t\t</tbody>\n\t</table>\n\t\n\t- 应该注意到 `NULL`、`0` 与 `空字符串` 是不同的概念。\n\t- `AND` 和 `OR` 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 `()` 来决定优先级，使得优先级关系更清晰。\n\t- `IN` 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。\n\t- `NOT` 操作符用于否定一个条件。\n\n###### 连接查询\n- 内连接：又称 `等值连接`，使用普通查询并在 `WHERE` 中将两个表中要连接的列用等值方法连接起来。\n\n\t```sql\n\tSELECT A.value, B.value\n\tFROM tablea AS A, tableb AS B\n\tWHERE A.key = B.key;\n\t```\n\n- 自连接：自连接可以看成内连接的一种，只是连接的表是 `自身` 而已。\n\n\t例如：一张员工表包含员工姓名和员工所属部门，找出与 Jim 处在同部门的所有员工姓名。\n\t\n\t```sql\n\t-- 子查询版本\n\tSELECT name\n\tFROM employee\n\tWHERE department = (\n\t\tSELECT department\n\t\tFROM employee\n\t\tWHERE name = \"Jim\"\n\t);\n      \n\t-- WHERE版本\n\tSELECT e1.name\n\tFROM employee AS e1, employee AS e2\n\tWHERE e1.department = e2.department AND e2.name = \"Jim\";\n\t```\n\n- 自然连接：自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。\n\n\t> 内连接和自然连接的区别：内连接 `提供连接` 的列，而自然连接 `自动连接` 所有同名列。\n\n- 外连接：外连不但返回符合连接和查询条件的数据行，且保留了没有关联的那些行。分为左外连接，右外连接以及全外连接。例如，左外连接就是保留左表没有关联的行。\n\n###### 子查询\n\n> 非相关子查询\n\n- 概念：非相关子查询是独立于外部查询的子查询，**子查询执行完毕后将值传递给外部查询**。子查询中只查询一次并返回一个字段的数据。\n\n- 可以将子查询的结果作为 WHRER 语句的过滤条件：\n\n\t```sql\n\tSELECT *\n\tFROM mytable1\n\tWHERE col1 IN (\n\t\tSELECT col2 FROM mytable2\n\t);\n\t```\n- 下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：\n\n\t```sql\n\tSELECT cust_name, (\n\t\tSELECT COUNT(*)\n\t\tFROM Orders\n\t\tWHERE Orders.cust_id = Customers.cust_id) AS orders_num\n\tFROM Customers\n\tORDER BY cust_name;\n\t```\n\n> 关联子查询\n\n- 概念：关联子查询会引用外部查询中的一列或多列。这种子查询之所以被称为关联子查询，是因为子查询的确与外部查询有关。当问题的答案需要依赖于外部查询中包含的每一行中的值时，通常就需要使用关联子查询 $^{[3]}$。 \n- 相关子查询的执行依赖于外部查询的数据，**外部查询执行一行，子查询就执行一次。并且是外部先查询一次，然后再执行一次内部查询**。\n\n\t> 即内部查询依赖于外部查询。\n\n-  例如，查询部门工资前三高的所有员工 ([Leetcode](https://leetcode-cn.com/problems/department-top-three-salaries/))：\n\n\t```sql\n\tSelect d.Name as Department, e.Name as Employee, e.Salary\n\tFrom Employee as e, Department as d\n\tWhere 1=1 AND e.DepartmentId = d.Id\n\tGroup By e.DepartmentId, e.id\n\tHaving (\n\t\tSelect Count(distinct es.Salary) \n\t\tFrom Employee as es \n\t\tWhere 1=1\n\t\t\tAND e.DepartmentID = es.DepartmentID\n\t\t\tAND es.Salary > e.Salary\n\t) < 3\n\t```\n\n###### 聚合函数\n- 各个 DBMS 的聚合函数都是不相同的，因此聚合函数一般不具备可移植性。SQL 提供的预定义聚合函数：\n\n\t<table>\n\t\t<thead>\n\t\t<tr>\n\t\t\t<th>函 数</th>\n\t\t\t<th>说 明</th>\n\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t<tr>\n\t\t\t<td>AVG( [DISTINCT\\|ALL]<列名> )</td>\n\t\t\t<td>返回某列的平均值</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>COUNT( [DISTINCT\\|ALL]<列名> )<br>COUNT([DISTINCT\\|ALL]*)</td>\n\t\t\t<td>返回某列的行数<br>统计元组个数</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>MAX( [DISTINCT\\|ALL]<列名> )</td>\n\t\t\t<td>返回某列的最大值</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>MIN( [DISTINCT\\|ALL]<列名> )</td>\n\t\t\t<td>返回某列的最小值</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>SUM( [DISTINCT\\|ALL]<列名> )</td>\n\t\t\t<td>返回某列值之和</td>\n\t\t</tr>\n\t\t</tbody>\n\t</table>\n\n\t> 以上聚合函数会忽略 NULL 行，考虑哪些运算不能包含 NULL 即可。\n\n- 使用 ANY 和 ALL 谓语必须同时使用比较运算符，其含义及等价转换关系如下表所示：\n\n\t<table>\n\t\t<thead>\n\t\t<tr>\n\t\t\t<th>谓 语</th>\n\t\t\t<th>语 义</th>\n\t\t\t<th>等价转换关系</th>\n\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t<tr>\n\t\t\t<td>>ANY</td>\n\t\t\t<td>大于子查询结果中某个值</td>\n\t\t\t<td>>MIN</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>>ALL</td>\n\t\t\t<td>大于子查询结果中所有值</td>\n\t\t\t<td>>MAX</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>&lt;ANY</td>\n\t\t\t<td>小于子查询结果中某个值</td>\n\t\t\t<td>&lt;MAX</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>&lt;ALL</td>\n\t\t\t<td>小于子查询结果中所有值</td>\n\t\t\t<td>&lt;MIN</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><>ANY</td>\n\t\t\t<td>不等于子查询结果中某个值</td>\n\t\t\t<td>--</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><>ALL</td>\n\t\t\t<td>不等于子查询结果中任何值</td>\n\t\t\t<td>NOT IN</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>=ANY</td>\n\t\t\t<td>等于子查询结果中某个值</td>\n\t\t\t<td>IN</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>=ALL</td>\n\t\t\t<td>等于子查询结果中任何值</td>\n\t\t\t<td>--</td>\n\t\t</tr>\n\t\t</tbody>\n\t</table>\n\n###### 分组\n- 把具有相同的数据值的行放在同一组中。\n- 指定的分组字段除了能按该字段进行分组，也会按该字段自动进行排序。\n- 可以对同一分组数据使用汇总函数进行处理，例如求分组数据的计数等。\n\n\t```sql\n\tSELECT col, COUNT(*) AS num\n\tFROM mytable\n\tGROUP BY col;\n\t```\n\t\n- GROUP BY 自动按分组字段进行排序，当然可通过 ORDER BY 按要求的汇总字段排序。\n\n\t```sql\n\tSELECT col, COUNT(*) AS num\n\tFROM mytable\n\tGROUP BY col\n\tORDER BY num;\n\t```\n\t\n- WHERE 过滤行，HAVING 过滤分组，**行过滤应当先于分组过滤**。\n\n\t```sql\n\tSELECT col, COUNT(*) AS num\n\tFROM mytable\n\tWHERE col > 2\n\tGROUP BY col\n\tHAVING num >= 2;\n\t```\n\t\n- 分组规定：\n\t- GROUP BY 子句需出现在 WHERE 子句之后，ORDER BY 子句之前；\n\t- 除了汇总字段外，GROUP BY 子句中必须给出 SELECT 语句的字段名称；\n\t- NULL 的行会单独分组；\n\t- 大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。\n\n###### 排序\n- 升序：ASC (默认)\n- 降序：DESC\n- 可以按多个列进行排序，并且为每个列指定不同的排序方式：\n\n\t```sql\n\tSELECT *\n\tFROM mytable\n\tORDER BY col1 DESC, col2 ASC;\n\t```\n\n###### 通配符\n- 通配符也是用在过滤语句中，但它只能用于 `文本字段`。\n\t- `%` 匹配 `>=0` 个任意字符；\n\t- `_` 匹配 `==1` 个任意字符；\n\t- `[]` 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符；\n\t- 模式是大小写敏感的。\n- 使用 `LIKE` 来进行通配符匹配：\n\n\t> 提示：不要滥用通配符，通配符位于开头处匹配会非常慢。\n\n\t```sql\n\tSELECT *\n\tFROM mytable\n\tWHERE col LIKE '[^AB]%'; -- 挑选不以 A 和 B 开头的任意文本\n\t\n\t-- WHERE col LIKE '%AB%'; 挑选包含 AB 的任意文本\n\t-- WHERE col LIKE '%A\\%B%'; 挑选包含 A%B 的任意文本（转义符的使用）\n\t```\n\n##### SQL 数据更新\n- 插入\n\n\t```sql\n\tINSERT INTO 表名 (字段名)\n\tVALUES(常量)\n\n\t-- 省略字段名，则 VALUES 需要补全所有属性作为输入\n\tINSERT INTO 表名\n\tVALUES(常量1, 常量2, ..., 常量 k)\n\t```\n\n- 删除\n\n\t```sql\n\tDELETE FROM 表名\n\t[WHERE 条件表达式]\n\t```\n\n- 修改\n\n\t```sql\n\tUPDATE 表名\n\tSET 列名 = 值表达式\n\t[WHERE 条件表达式]\n\t```\n\n##### SQL 访问控制\n- 常见的操作权限\n\n\t<table>\n\t\t<thead>\n\t\t<tr>\n\t\t\t<th width=15%>对象</th>\n\t\t\t<th width=15%>对象类型</th>\n\t\t\t<th>操作权限</th>\n\t\t</tr>\n\t\t</thead>\n\t\t<tr>\n\t\t\t<td>属性列</td>\n\t\t\t<td>TABLE</td>\n\t\t\t<td>SELECT、INSERT、UPDATE、DELETE<br>ALL PRIVILEGES（包含四种权限）</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>视图</td>\n\t\t\t<td>TABLE</td>\n\t\t\t<td>SELECT、INSERT、UPDATE、DELETE<br>ALL PRIVILEGES（包含四种权限）</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>基本表</td>\n\t\t\t<td>TABLE</td>\n\t\t\t<td>SELECT、INSERT、UPDATE、DELETE、ALTER、INDEX<br>ALL PRIVILEGES（包含四种权限）</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>数据库</td>\n\t\t\t<td>DATABASE</td>\n\t\t\t<td>CREATETAB 建表权限</td>\n\t\t</tr>\n\t</table>\n\n- 授权\n\t- `PUBLIC`：设置该参数可将权限赋给全体用户\n\t- `WITH GRANT OPTION`：指定该语句则表示获得权限的用户还可将权限赋予给其他用户\n\n\t```sql\n\tGRANT <操作权限> [ON <对象类型> <对象名>]\n\tTO <用户>\n\t[WITH GRANT OPTION];\n\t\t\n\t-- [例] 对表 S、P、J 的所有操作权限赋给所有用户\n\t-- GRANT ALL PRIVILEGES ON TABLE S,P,J TO PUBLIC;\n\t```\n\n- 收回权限\n\n\t```sql\n\tREVOKE <操作权限> [ON <对象类型> <对象名>]\n\tFROM <用户>\n\t\n\t-- [例] 将 User1 用户对表 S 的属性 Sno 的修改权限收回\n\t-- REVOKE UPDATE(Sno) ON TABLE S FROM User1;\n\t```\n\n##### SQL 存储过程\n- 游标：一条 SQL 语句可以产生或处理多条记录，而主语言是面向记录的，一组主变量一次只能存放一条记录。引入游标概念，通过游标指针来决定获取哪条记录。\n\n\t```sql\n\t# 定义游标\n\t# 实操当中变量名前缀需要添加 @，比如 DECLARE @Cur CURSOR FOR\n\tDECLARE <游标名> CURSOR FOR\n\t<SELECT 语句>\n\t\n\t# 打开游标\n\t# 实操当中变量名前缀需要添加 @，比如 OPEN @Cur\n\tOPEN <游标名>\n\t\n\t# 推进游标\n\t# 实操当中变量名前缀需要添加 @，比如 FETCH NEXT FROM @Cur INTO @id, @name\n\tFETCH NEXT FROM <游标名>\n\tINTO <变量名>\n\t\n\t# 关闭游标\n\t# 实操当中变量名前缀需要添加 @，比如 CLOSE @Cur\n\tCLOSE <游标名>\n\t\n\t# 释放游标\n\tDEALLOCATE <游标名>\n\t```\n\t\n- 创建存储过程\n\n\t```sql\n\tCREATE PROCEDURE <存储过程名称> (\n\t\t# IN：表示输入参数（默认值）\n\t\t# OUT：表示输出参数\n\t\t# IN OUT：即作为输入参数，也作为输出参数\n\t\tIN | OUT | IN OUT @<参数名称> <参数类型>\n\t) as\n\tBEGIN\n\t\t<SQL 语句>\n\tEND [存储过程名称]\n\t```\n\n##### SQL 触发器\n- 特殊的储存过程，它的执行不是由程序调用，也不需要手工出发，而是由事件触发的。\n\n\t> 触发器功能虽强大，但得谨慎使用。在数据库操作中，我们可以通过关系、触发器、存储过程、应用程序等来实现数据操作，同时规则、约束、缺省值也是保证数据完整性的重要保障。若我们过分依赖于触发器，势必影响数据库结构，同时增加了维护难度。\n\t\n- 创建触发器\n\n\t```sql\n\tCREATE TRIGGER <触发器名称> <BEFORE | AFTER>\n\t\t<INSERT | DELETE | UPDATE [OF 列名清单]>\n\tON <表名>\n\t[REFERENCING <临时视图表>]\n\t[FOR EACH ROW | FOR EACH STATEMENT]\n\t[WHEN <触发条件>]\n\tBEGIN\n\t\t<触发条件>\n\tEND [触发器名称]\n\t```\n\n\t- Referencing：指定临时视图的别名，触发器运行过程中，系统会生成存放更新值（旧值）以及更新后的值（新值）的临时视图。当触发器运行结束后，视图即不存在。\n\n\t\t> 1）行级触发器视图名为 OLD ROW 和 NEW ROW。<br>\n\t\t> 2）语句级触发器默认视图名为 OLD-TABLE 和 NEW-TABLE。\n\n\t- When：指定触发器的触发条件，触发条件须包含临时试图的名称。\n\n- [例] 银行处理透支时，不是将余额设置为负值，而是将账户余额设置为零，并建立一笔贷款（金额为透支金额，贷款号等于该透支账户的账户号），利用触发器实现这一过程。\n\n\t```sql\n\tCREATE TRIGGER overdraft_trigger AFTER UPDATE ON account\n\tREFERENCING NEW ROW as nrow\n\tFOR EACH ROW\n\tWHEN nrow.balance < 0\n\tBEGIN ATOMIC\n\t\tINSERT INTO borrower VALUES (\n\t\t\tSELECT d.customer_name, d.account_number\n\t\t\tFROM depositor as d\n\t\t\tWHERE nrow.account_number = d.account_number\n\t\t)\n\t\tINSERT INTO loan VALUES (\n\t\t\tnrow.account_number,\t# 贷款号\n\t\t\tnrow.balance\t\t# 透支额\n\t\t)\n\t\tUPDATE account SET balance = 0\n\t\tWHERE account.account_number = nrow.account_number\n\tEND\n\t```\n\n#### 规范化\n##### 函数依赖\n- 记 $A \\to B$ 表示 A 函数决定 B，也可以说 B 函数依赖于 A。\n- 若 $\\{A_1，A_2，... ，A_n\\}$ 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是 `最小的`，那么该集合就称为 `键码`。\n- 对于 $A \\to B$，如果能找到 A 的真子集 $A'$，使得 $A' \\to B$，那么 $A \\to B$ 就是 `部分函数依赖`，否则就是 `完全函数依赖`。\n- 对于 $A \\to B$，$B \\to C$，则 $A \\to C$ 是一个 `传递函数依赖`。\n\n##### 异常\n- 如表所示，展示了学生课程关系的函数依赖为 {Sno, Cname} -> {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程后就能确定其它信息。\n\n\t<table>\n\t\t<thead>\n\t\t<tr>\n\t\t\t<th>Sno</th>\n\t\t\t<th>Sname</th>\n\t\t\t<th>Sdept</th>\n\t\t\t<th>Mname</th>\n\t\t\t<th>Cname</th>\n\t\t\t<th>Grade</th>\n\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t<tr>\n\t\t\t<td>1</td>\n\t\t\t<td>学生-1</td>\n\t\t\t<td>学院-1</td>\n\t\t\t<td>院长-1 </td>\n\t\t\t<td>课程-1</td>\n\t\t\t<td>90</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2</td>\n\t\t\t<td>学生-2</td>\n\t\t\t<td>学院-2</td>\n\t\t\t<td>院长-2 </td>\n\t\t\t<td>课程-2</td>\n\t\t\t<td>80</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2</td>\n\t\t\t<td>学生-2</td>\n\t\t\t<td>学院-2</td>\n\t\t\t<td>院长-2</td>\n\t\t\t<td>课程-1</td>\n\t\t\t<td>100</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>3</td>\n\t\t\t<td>学生-3</td>\n\t\t\t<td>学院-2</td>\n\t\t\t<td>院长-2 </td>\n\t\t\t<td>课程-2</td>\n\t\t\t<td>95</td>\n\t\t</tr>\n\t\t</tbody>\n\t</table>\n\n- 不符合范式的关系，会产生很多异常，主要有以下四种异常：\n\t- `冗余数据`：例如 `学生-2` 出现了两次。\n\t- `修改异常`：更改表中某个实体的单独属性时，需对多行进行更新。例如 sdept=''学院-2' 的院长，则需要需改多行记录。\n\t- `删除异常`：删除表中某一实体则会导致其他实体消失。例如删除了 `课程-1` 需要删除第一行和第三行，那么 学生-1 的信息就会丢失。\n\t- `插入异常`：表中某个实体随着另一个实体而存在。例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。\n\n##### 范式\n###### 范式化设计\n- 第一范式（1NF）：\n\t- 属性不可分，即数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。\n\t- 单一属性列由基本的数据类型所构成。\n- 第二范式（2NF）：\n\t- 表中只具有一个主键。\n\t- 每个非主属性完全函数依赖于键码，而不能存在非主属性部分依赖于键码。\n\n\t\t> 比如，复合主键中常包括两种实体，如上述例子中的学生实体与课程实体，它们各自的属性依赖于各实体的主键。\n\n\t- 如上表所示，学生课程关系中 {Sno, Cname} 为键码，有如下函数依赖：\n\t\t- Sno -> Sname, Sdept\n\t\t- Sdept -> Mname\n\t\t- Sno, Cname -> Grade\n\t- 函数依赖状况分析：\n\t\t- Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。 \n\t\t- Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。\n\n- 第三范式（3NF）：\n\n\t> 练习推荐：[Maozhenyu. 候选键/最小依赖集与第三范式的分解 [OL]. bilibili.com. 2020](https://www.bilibili.com/video/BV1CD4y1974g)\n\n\t- 非主属性即不部分依赖，也不传递函数依赖于键码。\n\n\t\t> 简而言之，第三范式就是属性不依赖于其它非主属性。\n\n\t- 上表关系中存在以下传递函数依赖：Sno $\\to$ Sdept $\\to$ Mname。\n\n- Boyce Codd 范式（BCNF）：\n\t- 主属性之间不存在传递依赖关系。\n\n\t\t> 简而言之，BCNF 范式规范主键之间不能存在相互决定的关系。\n\n\t- 3NF 按定义排除了任何非主属性对键码的传递依赖与部分依赖。但该实体未必满足 BCNF 范式。\n\n- 第四范式（4NF）:\n\t- 满足 Boyce Codd 范式基础上，并且没有多值依赖关系。\n\t- 假设上表中 Sdept 包含多个 Mname（一个学院多名院长任职），存在多值依赖性，将导致不必要的数据重复。\n\n###### 反范式设计\n- 反范式化：鉴于性能和读取效率考量，适当违反数据库范式设计要求，允许少量数据冗余。\n- 优劣比较\n\n\t<table>\n\t\t<thead>\n\t\t<tr>\n\t\t\t<th>优劣</th>\n\t\t\t<th>范式化</th>\n\t\t\t<th>反范式化</th>\n\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t<tr>\n\t\t\t<td>优势</td>\n\t\t\t<td>1) 可尽量减少数据冗余\n\t\t\t<td>1) 减少表关联查询<br>2) 更好进行索引优化</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>劣势</td>\n\t\t\t<td>1) 多表关联查询<br>2) 难以进行索引优化</td>\n\t\t\t<td>1) 存在数据冗余及数据维护异常</td>\n\t\t</tr>\n\t\t</tbody>\n\t</table>\n\n#### 事务管理\n- 事务：指满足 `ACID` 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。\n- ACID\n\t- 原子性（Atomicity）\n\t\t- 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。\n\t\t- 回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。\n\t- 一致性（Consistency）：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。\n\t- 隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的。\n\t- 持久性（Durability）：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。\n\t\n\t\t> 使用重做日志来保证持久性。\n\n- ACID 特性概念简单，但不好理解，主要是因为这几个特性不是一种平级关系：\n\t- 只有满足一致性，事务的执行结果才是正确的。\n\t\t- 在无并发情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。\n\t\t- 在并发情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。\n\t- 事务满足持久化是为了能应对数据库崩溃的情况。\n\n\t\t{%centerquote%}\n\t\t![](/images/CS/Mid-Software/mid-software-database-transaction.svg)ACID逻辑关系\n\t\t{%endcenterquote%}\n\n#### 并发控制\n\n{%centerquote%}\n![](/images/CS/Mid-Software/Mid-Software-Database-Transaction-Consistency-Solution.svg) 事务并发环境下保证事务一致性的方法\n{%endcenterquote%}\n\n- 在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。\n- 产生并发不一致性问题的主要原因是破坏了事务的隔离性。\n- 解决方法是通过 `并发控制` 来保证隔离性。\n\t- 并发控制可以通过 `封锁` 来实现，但是封锁操作需要用户自己控制，相当复杂。\n\t- 数据库管理系统提供了事务的 `隔离级别`，让用户以一种更轻松的方式处理并发一致性问题。\n\n##### 并发一致性问题\n- 丢失数据：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。\n\n\t> 简记为 `同时修改`。\n\n- 读脏数据：T1 对一个数据做了修改，T2 读取这一个数据。若 T1 执行 ROLLBACK 操作，则 T2 读取的结果和第一次的结果不一样。\n\n\t> 简记为 `读取修改失败的记录`。最简单的场景是修改完成后，紧接着查询检验结果。\n\n- 不可重复读：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。\n\n\t> 简记为 `读时修改`，重复读取的结果不一样。\n\n- 幻影读：T1 读取某个范围的数据，T2 在这个范围内插入新数据或者删除数据，T1 再次读取这个范围的数据，此时读取结果和第一次读取的结果不一样，事务并没有独立开来。\n\n\t> 简记为 `事务没有独立性，受其他事务插入或者删除影响`。\n\t\n\t{%centerquote%}\n\t![](/images/CS/Mid-Software/Mid-Software-Database-Concurrency-Consistency.svg) 并发一致性问题\n\t{%endcenterquote%}\n\n##### 封锁\n###### 封锁粒度\n- 以 MySQL 为例，它提供了两种封锁粒度：`行级锁` 以及 `表级锁`。\n- 应尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。\n- 但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。\n\n\t> 为此，我们在选择封锁粒度时，需在 `锁开销` 和 `并发程度` 之间做一个 `权衡`。\n\n###### 封锁类型\n- 读写锁\n\t- 排它锁（Exclusive）：写锁，简写为 X 锁\n\t- 共享锁（Shared）：读锁，简写为 S 锁\n\n\t- 有以下两个规定：\n\t\t- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。\n\t\t- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。\n\t- 读写锁之间的兼容关系如表所示：✕ 相互不兼容，✓ 相互兼容\n\n\t\t<table>\n\t\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<td>锁类型</td>\n\t\t\t\t<td>排它锁 X</td>\n\t\t\t\t<td>共享锁 S</td>\n\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<td>排它锁 X</td>\n\t\t\t\t<td>✕</td>\n\t\t\t\t<td>✕</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>共享锁 S</td>\n\t\t\t\t<td>✕</td>\n\t\t\t\t<td>✓</td>\n\t\t\t</tr>\n\t\t\t</tbody>\n\t\t</table>\n\n- 意向锁（Intention Locks）\n\t- 支持多粒度封锁，使得行锁和表锁能够共存。\n\t- 在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。\n\t- 意向锁在原来的 X / S 锁之上引入了 IX / IS 锁（两者都属于表级锁），用来表示一个事务稍后会对表中的某个数据行上加 X 锁或 S 锁。整理可得以下两个规定：\n\t\t- 一个事务在获得某个数据行对象的 S 锁前，必须先获得表的 IS 锁或者更强的锁。\n\t\t- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。\n\n- 读写锁与意向锁的兼容关系如表所示：✕ 相互不兼容，✓ 相互兼容\n\t- 任意 IS / IX 锁之间都是兼容的，因为它们只是表示想要 `对表加锁`，而不是真正加锁。\n\t- S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。\n\n\t\t<table>\n\t\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<td>锁类型</td>\n\t\t\t\t<td>排它锁 X</td>\n\t\t\t\t<td>共享锁 S</td>\n\t\t\t\t<td>意向排它锁 IX</td>\n\t\t\t\t<td>意向共享锁  IS</td>\n\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<td>排它锁 X</td>\n\t\t\t\t<td>✕</td>\n\t\t\t\t<td>✕</td>\n\t\t\t\t<td>✕</td>\n\t\t\t\t<td>✕</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>共享锁 S</td>\n\t\t\t\t<td>✕</td>\n\t\t\t\t<td>✓</td>\n\t\t\t\t<td>✕</td>\n\t\t\t\t<td>✓</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>意向排它锁 IX</td>\n\t\t\t\t<td>✕</td>\n\t\t\t\t<td>✕</td>\n\t\t\t\t<td>✓</td>\n\t\t\t\t<td>✓</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>意向共享锁 IS</td>\n\t\t\t\t<td>✕</td>\n\t\t\t\t<td>✓</td>\n\t\t\t\t<td>✓</td>\n\t\t\t\t<td>✓</td>\n\t\t\t</tr>\n\t\t\t</tbody>\n\t\t</table>\n\t\n##### 封锁协议\n###### 三级封锁协议\n- `一级封锁协议`：事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。\n\n\t> 可解决 \"丢失修改\" 问题，因不能同时有两个事务对同一个数据修改，那么事务的修改就不会被覆盖。\n\n- `二级封锁协议`：在一级封锁基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。\n\n\t> 可解决 \"丢失修改\" 和 \"读脏数据\" 问题，因一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。\n\t\n- `三级封锁协议`：在二级封锁基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。\n\n\t> 可解决 \"丢失修改\" 和 \"读脏数据\" 问题，还进一步防止了 \"不可重复读\" 的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。\n\n\t{%centerquote%}\n![](/images/CS/Mid-Software/Mid-Software-Database-Concurrency-3LevelLockingProtocol.svg) 三级封锁协议示例\n{%endcenterquote%}\n\n###### 两段锁协议\n- 两段锁协议是指每个事务的执行可以分为两个阶段：生长阶段（加锁阶段）和衰退阶段（解锁阶段）。\n- 两段封锁实现方式：\n\t- 事务开始后就处于加锁阶段，一直到执行 ROLLBACK 和 COMMIT 之前都是加锁阶段。\n\t- ROLLBACK 和 COMMIT 使事务进入解锁阶段，即在 ROLLBACK 和 COMMIT 模块中 DBMS 释放所有封锁。\n- 可串行化调度：通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。\n\t- 事务遵循两段锁协议是保证可串行化调度的 `充分条件`。例如以下操作满足两段锁协议，它是可串行化调度。\n\n\t\t```html\n\t\tlock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)\n\t\t```\n\n\t- 但不是 `必要条件`，例如以下操作不满足两段锁协议，但是它还是可串行化调度。\n\n\t\t```html\n\t\tlock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)\n\t\t```\n\n##### 隔离级别\n- 事务指定一个隔离级别，该隔离级别定义了一个事务必须与其他事务进行资源或数据更改相隔离的程度。隔离级别是从 `允许并发一致性问题发生` 的角度进行描述的。例如，脏读、不可重复读或幻影读。如表所示，是关于隔离级别与并发副作用的层级关系。\n\n\t> 图例说明：✕ 是可避免的情况，✓ 是允许发生的情况\n\n\t<table>\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<td>隔离级别 \\ 并发一致性问题</td>\n\t\t\t\t<td>脏读</td>\n\t\t\t\t<td>不可重复读</td>\n\t\t\t\t<td>幻影读</td>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<td>未提交读</td>\n\t\t\t\t<td>✓</td>\n\t\t\t\t<td>✓</td>\n\t\t\t\t<td>✓</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>提交读</td>\n\t\t\t\t<td>✕</td>\n\t\t\t\t<td>✓</td>\n\t\t\t\t<td>✓</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>可重复读</td>\n\t\t\t\t<td>✕</td>\n\t\t\t\t<td>✕</td>\n\t\t\t\t<td>✓</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>串行化读</td>\n\t\t\t\t<td>✕</td>\n\t\t\t\t<td>✕</td>\n\t\t\t\t<td>✕</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n  \n- 实现方式：MySQL 的 InnoDB 存储引擎实现隔离级别的具体方式有：多版本并发控制（MVCC）与 Next-Key Locks。\n- 隔离级别：\n\t- 未提交读（Read uncommitted）：事务中的修改，即使没有提交，对其它事务也是可见的。\n\t- 提交读（Read committed）：一个事务只能读取已经提交的修改事务。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。\n\n\t\t> Oracle 数据库默认的事务隔离级别。\n\n\t- 可重复读（Repeatable Read）：保证一个当前事务读取不会受到另一个事务修改数据（即使已提交或者回滚）的影响，也称为快照读。\n\n\t\t> MySQL 数据库默认的事务隔离级别。\n\n\t- 可串行化（Serialzable）：强制事务串行执行。需要加锁实现，而其它隔离级别通常不需要加锁。\n\n##### 多版本并发控制\n- 多版本并发控制（Multi-Version Concurrency Control, MVCC）：MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现 `提交读` 和 `可重复读` 这两种隔离级别。\n- `未提交读` 隔离级别总是读取最新的数据行，无需使用 MVCC。\n- `可串行化` 隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。\n\n###### 版本号\n- 该版本号是指**事务**的版本号。\n- 系统版本号：是一个递增数字，每开始一个新事务，系统版本号就会自动递增。\n- 事务版本号：事务开始时的系统版本号。\n\n###### 隐藏列\n\n- 该版本号指**数据行快照**的版本号。\n\n- MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：\n\t- 创建版本号：指示创建一个数据行快照时的系统版本号；\n\t- 删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。\n\n###### UndoLog\n- MVCC 使用到的快照存储在 Undo Log 中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。\n\n\t{%centerquote%}\n\t![](/images/CS/Mid-Software/mid-software-database-mvcc-UndoLog.svg) 存储在 Undo日志中的快照\n\t{%endcenterquote%}\n\n###### 实现过程\n- 以下实现过程是针对 `可重复读` 隔离级别的：\n\t- 当开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号，理解这一点很关键。\n\t- 数据行快照的创建版本号是创建数据行快照时的系统版本号，系统版本号随着创建事务而递增，因此新创建一个事务时，这个事务的系统版本号比之前的系统版本号都大，也就是比所有数据行快照的创建版本号都大。\n- SELECT\n\t- 多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。\n\n\t\t> 但也有例外，若一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。\n\n\t- 把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于等于 T 的版本号，因为如果大于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。\n\t- 除此之外，T 所要读取的数据行快照的删除版本号必须是未定义或者大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。\n- INSERT：将当前系统版本号作为数据行快照的创建版本号。\n- DELETE：将当前系统版本号作为数据行快照的删除版本号。\n- UPDATE：将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。\n\t\n\t> 可以理解为先执行 DELETE 后执行 INSERT。\n\n###### 快照读与当前读\n- 快照读：使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。\n\n\t```sql\n\tSELECT * FROM table;\n\t```\n\n- 当前读：读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。\n\n\t```sql\n\tSELECT * FROM table WHERE ? LOCK IN SHARE MODE;\n\tSELECT * FROM table WHERE ? FOR UPDATE;\n\tINSERT ...;\n\tUPDATE ...;\n\tDELETE ...;\n\t```\n\n##### Next-Key Locks\n- MVCC 不能解决 `幻影读` 问题，Next-Key Locks 就是为了解决这个问题而存在的。\n\n\t> 场景复现：可重复读保证了一个事务不会修改已经由另一个事务读取但未提交 (或回滚) 的数据，例如统计某班男生的人数。但此时插入一名男生，而同样的查询操作会导致不一致的查询结果。\n- 在可重复读（REPEATABLE READ）隔离级别下，使用 `MVCC + Next-Key Locks` 可以解决幻读问题。\n- Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种 `锁实现`。\n\n###### Record Locks\n- 锁定一个记录上的索引，而不是记录本身。\n- 如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。\n\n###### Gap Locks\n- 锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。\n\n\t```sql\n\tSELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;\n\t```\n\n###### Next-Key Locks\n- 它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：\n\n\t```sql\n\t(-∞, 10]\n\t(10, 11]\n\t(11, 13]\n\t(13, 20]\n\t(20, +∞)\n\t```\n\n### 操作系统\n#### 进程管理\n\n##### 进程状态\n\n- 进程的五态模型\n\t\n\t{%centerquote%}\n\t![](/images/CS/Mid-Software/mid-software-OS-PCB-5Status-Model.svg) 进程的五态模型\n\t{%endcenterquote%}\n\n\t- `创建进程` 分两个阶段：第一阶段为一个新进程创建必要的管理信息；第二阶段让该进程进入就绪状态。\n\t- `终止进程` 分两个阶段：第一阶段等待操作系统进行善后处理；第二阶段释放主存。\n\n- 具有挂起状态的进程状态及其转换\n\t\n\t{%centerquote%}\n\t![](/images/CS/Mid-Software/mid-software-OS-PCB-5HoldStatus-Model.svg) 细分进程状态及其转换\n\t{%endcenterquote%}\n\t\n\t- 活跃就绪：进程在 `主存` 并且可被调度的状态。\n\t- 静止就绪：就绪进程被对换到 `辅存` 时的状态，它是不能被直接调度的状态，只有当主存中没有活跃就绪态进程，或具有更高优先级的挂起态进程时，系统才会把挂起就绪态进程调回主存并转换为活跃就绪。\n\t- 活跃阻塞：进程在 `主存`，一旦等待的事件产生便进入活跃就绪状态。\n\t- 静止阻塞：阻塞进程对换到 `辅存` 时的状态，一旦等待的事件产生便进入静止就绪状态。\n\n##### 进程通信\n- 进程的同步与互斥\n\t- 同步：多个进程可并发执行，每个进程以各自独立的、不可预知的速度向前推进，但需在某些确定点上协调合作进程间的工作。\n\t- 互斥：系统中多个进程因争用 `临界资源` 而互斥执行。\n- 信号量机制\n\t- 临界资源：进程间需要互斥方式对其进行共享的资源。\n\t- 临界区：每个进程中访问临界资源的那段代码称为 `临界区`。\n\t- 信号量：特殊变量\n- PV 操作\n\t\n\t{%centerquote%}\n\t![](/images/CS/Mid-Software/mid-software-OS-PCB-PA.svg) PV 操作\n\t{%endcenterquote%}\n\n\t- P 操作：S:=S-1，若 $S \\geq 0$ 则执行 P 操作的进程继续执行；若 $S < 0$ 则置该进程为阻塞状态（无资源可用），并将其插入阻塞队列。\n\n\t\t> $S \\geq 0$，S 表示该资源的可用数；$S < 0$，$|S|$ 表示阻塞队列中等待该资源的进程数。\n\n\t\t```java\n\t\tProcedure P(Var S:Semaphore)；\n\t\tBegin\n\t\t\tS:=S-1;\t\t\t\t// S>=0 表示缓冲区为空，可送入产品\n\t\t\tIf S<0 Then Wait(S) // 执行 P 操作的进程插入等待队列\n\t\tEnd;\n\t\t```\n\n\t- V 操作：S:=S+1，若 $S > 0$ 则执行 V 操作的进程继续执行；若 $S \\leq 0$ 则唤醒一个阻塞状态的进程，并将其插入就绪队列，然后执行 V 操作的进程继续。\n\n\t\t> $S > 0$，S 表示正在等待该资源的进程数；$S \\leq 0$，$|S|$表示该资源的可用数。\n\n\t\t```java\n\t\tProcedure V(Var S:Semaphore)；\n\t\tBegin\n\t\t\tS:=S+1;\t\t\t\t\t// S>0 缓冲区有产品\n\t\t\tIf S<=0 Then Resume(S)\t// 从阻塞队列中唤醒进程\n\t\tEnd;\n\t\t```\n\n- 利用 PV 操作实现进程的互斥：令信号量 mutex 初值为 1，当进入临界区时执行 P 操作，退出临界区时执行 V 操作。\n\n\t```java\n\tP(mutex)\n\t\t临界区\n\tV(mutex)\n\t```\n\n##### 死锁\n###### 必要条件\n- `互斥`：资源是独占的且排他使用，进程互斥使用资源。每个资源要么已分配给一个进程，要么就是可用的。\n- `占有和等待`：已经得到的资源的某进程可再请求资源。\n- `不可抢占`：已经分配给进程的资源不可强性被抢占，只能是占有进程显式地释放。\n- `环路等待`：有两个及以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。\n\n\t> 以上给出了导致死锁的四个必要条件，只要系统发生死锁则以上四个条件至少有一个成立。反过来思考，我们可通过破坏四个条件中的任何一个来预防死锁的发生。\n\n###### 处理方法\n- `鸵鸟策略`：把头埋在沙子里，假装根本没发生问题。\n\t- 因解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。\n\t- 大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。\n- `死锁检测`：不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。\n\t- 每种类型一个资源的死锁检测\n\t\t- 下图为资源分配图，其中 `方框表示资源`，`圆圈表示进程`。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。图 (a) 可以抽取出环，如图 (b)，它满足了环路等待条件，因此会发生死锁。\n\t\n\t\t{%centerquote%}\n\t\t![](/images/CS/Mid-Software/mid-software-OS-PCB-deadlock-check.svg) 每种类型一个资源的死锁检测\n\t\t{%endcenterquote%}\n\n\t\t- 每种类型一个资源的死锁检测算法是通过 `检测有向图是否存在环` 来实现。从一个节点出发进行 `深度优先搜索`，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。\n\n\t- 每种类型多个资源的死锁检测\n\t\t- 如图所示，有三个进程四个资源，每个数据代表的含义如下：\n\t\t\t- E 向量：资源总量\n\t\t\t- A 向量：资源剩余量\n\t\t\t- C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量\n\t\t\t- R 矩阵：每个进程请求的资源数量\n\t\t\n\t\t\t{%centerquote%}\n\t\t\t![](/images/CS/Mid-Software/mid-software-OS-PCB-deadlock-check2.svg) 每种类型多个资源的死锁检测\n\t\t\t{%endcenterquote%}\n  \t\t\n\t\t- 进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。\n\t\t- 算法总结如下：每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。\n\t\t\t- `Step.01`：寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。\n\t\t\t- `Step.02`：若找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程并转回 1。\n\t\t\t- `Step.03`：若没找到这样一个进程，算法终止。\n- `死锁恢复`\n\t- 利用抢占恢复\n\t- 利用回滚恢复\n- 通过杀死进程恢复\n- `死锁预防`：在程序运行前预防发生死锁。\t\n\t- `破坏互斥条件`：例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。\n\t- `破坏占有和等待条件`：一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。\n\t- `破坏不可抢占条件`：允许对资源实行抢夺。\n\t\t- 方法一：一个进程不能获得所需全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中，可被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动执行。\n\t\t- 方法二：若一进程请求当前被另一进程占有的一个资源，则操作系统可抢占另一个进程，要求它释放资源。仅在任意两个进程的优先级都不相同的条件下，该方法才能预防死锁。\n\t- `破坏环路等待`：给资源统一编号，进程只能按编号顺序来请求资源。\t\n- `死锁避免`：在程序运行时避免发生死锁。\n\t- 安全状态\n\t\t- 图 (a) 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。\n\t\t- 从图 (a) 开始出发，先让 B 拥有所需的所有资源 (图 b)，运行结束后释放 B，此时 Free 变为 5 (图 c)；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。\n\t\t\n\t\t{%centerquote%}\n\t\t![](/images/CS/Mid-Software/mid-software-OS-PCB-deadlock-avoid1.svg) 证明 (a) 的状态是安全的\n\t\t{%endcenterquote%}\n\n\t\t- 定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种 `调度次序` 能够使得 `每一个进程运行完毕`，则称该状态是安全的。\n\n\t\t\t> 安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。\n\n\t- 单个资源的银行家算法\n\t\t- 一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。\n\t\t- 图 (c) 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 (c) 中的状态。\n\n\t\t{%centerquote%}\n\t\t![](/images/CS/Mid-Software/mid-software-OS-PCB-deadlock-avoid2.svg) 单个资源的银行家算法\n\t\t{%endcenterquote%}\n\t\t\n\t- 多个资源的银行家算法\n\t\t- 如图所示，有五个进程，四个资源。\n\t\n\t\t{%centerquote%}\n\t\t![](/images/CS/Mid-Software/mid-software-OS-PCB-deadlock-avoid3.svg) 多个资源的银行家算法\n\t\t{%endcenterquote%}\n\t\n\t\t- 左边的图表示已经分配的资源，右边的图表示还需要分配的资源。\n\t\t- 下方向量 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源。\n\t\n\t\t\t> 注意这三个为向量，而不是具体数值，例如 A = ( 1 0 2 0 )，表示 4 个资源分别还剩下 1/0/2/0。\n\t\n\t\t- 检查一个状态是否安全的算法如下：\n\t\t\t- Step.01：查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。\n\t\t\t- Step.02：假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。\n\t\t\t- Step.03：重复以上两步，直到所有进程都标记为终止，则状态时安全的。若一个状态不是安全的，需要拒绝进入这个状态。\n\n##### 线程\n- 线程是进程中的一个实体，是被系统 `独立分配` 和 `独立调度` 的基本单位。\n- 一个进程中可以有多个线程，它们共享进程资源。\n\n\t> QQ 和 QQ 浏览器是两个进程，浏览器进程里面有很多线程。例如 HTTP 请求线程、事件响应线程、渲染线程等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。\n\n- 进程与线程的区别：\n\t- `拥有资源`：进程是 `资源分配` 的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。\n\t- `调度`：线程是 `独立调度` 的基本单位，在同一进程中，线程的切换不会引起进程切换。但是从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。\n\t- `系统开销`：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。\n\t- `通信方面`：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助  `IPC`（进程间通信，Inter-Process Communication）。\n\n#### 存储管理\n##### 基本概念\n- 存储器的层次结构\n\t\n\t{%centerquote%}\n\t![](/images/CS/Mid-Software/mid-software-Storage-hierarchical-structure.svg) 存储器的层次结构\n\t{%endcenterquote%}\n\n- 虚拟地址：源程序的地址空间称为符号地址空间，其从 0 号单元开始编址，并顺序分配所有的符号名所对应的地址单元。它不是主存的真实地址，又称为 `相对地址`。\n\n\t> 源程序经过 `汇编` 或者 `编译`后，再经过链接编辑程序加工形成程序的装配模块，即转换为相对地址编址模块。\n\n- 地址空间：程序中由相对地址组成的空间称为逻辑地址空间，相对地址空间通过再定位机构转换到绝对地址空间（物理地址的集合）。\n- 地址重定位：\n\t- 静态重定位：在程序装入主存时，已完成逻辑地址到物理地址的变化，在程序的执行期间将不会再发生变化。\n\t\t- 优点：无须硬件地址变换机构的支持，它只要求程序本身是可重定位的（修改地址部分具有某种标识）。\n\t\t- 缺点： 必须给作业分配一个连续的存储区域。\n\t- 动态重定位：在程序运行期间完成逻辑到物理地址的变化。\n\t\t- 优点：程序在执行期间可换入和缓存主存；不必给程序分配连续的主存空间，把主存中碎片集中起来。\n\n##### 管理方案\n\n###### 分页存储管理\n\n- 分页原理\n\t- 将一个进程的地址空间划分成若干个大小相等的区域，称为页。\n\t- 相应地，将主存空间划分成与页相同大小的若干个物理块，称为块。\n\t- 为进程分配主存时，将进程中若干页分别装入多个不相邻的块中。\n- 地址结构\n\t- 分页地址由两部分组成，前一部分分为页号 P，后一部分为偏移量 W，即页内地址。\n\t- 地址长度为 32 位，0 ~ 11 位为页内地址（每页大小为 $2^{12}B=4KB$）,12 ~ 31 位为页号（$2^{20}B=1MB$）\n\n\t\t{%centerquote%}\n\t\t![](/images/CS/Mid-Software/mid-software-Storage-Paging-Structure.svg) 分页地址结构\n\t\t{%endcenterquote%}\n\t\n- 页表\n\t- 进程的多个页面离散地分配到主存的多个物理块时，系统应保证在主存中找到进程要访问的页面所对应的物理块。\n\t- 为此，系统为每个进程建立了一张页面映射表（页表）。\n\t- 页表的作用是实现从页号到物理块号（页帧号）的地址的映射。\n- 如图所示，逻辑页号为 4，查找页表得到该页的物理块号为 15，与页内地址 256 拼接得到物理地址。\n\t\n\t{%centerquote%}\n\t![](/images/CS/Mid-Software/mid-software-Storage-Paging-Example.svg) 页式存储管理的地址映射\n\t{%endcenterquote%}\n\n- 分页存储优劣\n\t- 优：空间利率高，且产生碎片少\n\t- 劣：增加系统开销，可能产生 [抖动现象](https://baike.baidu.com/item/抖动现象/9220662)。\n\n###### 分段存储管理\n- 分段原理\n\t- 作业的地址空间被划分为若干个段，每段式一组完整的逻辑信号，例如有主程序段、子程序段、数据段以及堆栈段。\n\t- 每个段都拥有自己的名字，从 0 开始编制的一段连续的地址空间，各段长度是可以不等的。\n- 地址结构：逻辑地址由段号和段内地址两部分组成，允许一个作业最多 64KB 个段，每个段最大长度为 64KB。\n\n\t{%centerquote%}\n\t![](/images/CS/Mid-Software/mid-software-Storage-Section-Structure.svg) 分段地址结构\n\t{%endcenterquote%}\n\n- 段表\n\t- 为每个段分配一个连续的分区，而进程中的各个段可里离散地分配到主存的不同分区中。\n\t- 系统为每个进程建立一张段映射表（段表），每个段在表中占有一个表项，其中记录了该段在主存中的起始地址（基址）和段的长度。\n\t- 程序在执行时，通过查段表来找到每个段所对应的主存区。\n\t- 段表实现了从逻辑段到物理主存区的映射。\n- 段式存储的内存空间划分\n\n\t{%centerquote%}\n\t![](/images/CS/Mid-Software/mid-software-Storage-Section-Sample.svg) 段式存储的内存空间划分\n\t{%endcenterquote%}\n\n- 如图所示，分段式存储管理实现从逻辑地址到物理地址的变换功能。\n\n\t{%centerquote%}\n\t![](/images/CS/Mid-Software/mid-software-Storage-Section-Example.svg) 段式存储管理的地址变换机构\n\t{%endcenterquote%}\n\n- 分段存储优劣\n\t- 优：多道程序共享内存\n\t- 劣：内存利用率低，较多内存碎片\n\n###### 段页式存储管理\n- 分页过程由操作系统完成，用户不必关心分页过程，其缺点式不易实现共享；段是信息的逻辑单位，易于实现分段式共享即允许若干进程共享一个或多个段。对两种存储管理方式 “各取所长”，既具有分页系统又能提高主存利用率的存储管理方式 `段页式存储管理`。\n- 段页式原理\n\t- 将整个主存划分成大小相等的存储块，将用户程序按程序的逻辑关系分为若干个段，并为每个段赋予一个段名，再将每个段划分成若干页，存储块为单位离散分配。\n- 地址结构：由段号、段内页号和页内地址组成。\n\t\n\t{%centerquote%}\n\t![](/images/CS/Mid-Software/mid-software-Storage-Paging&Section-Structure.svg) 段页式管理的地址结构\n\t{%endcenterquote%}\n\n- 段页式系统\n\t- 系统必须同时配置段表和页表。\n\t- 对段中的页进行离散地分配，段表中的内容不在式段的主存始址和段长，而是页表始址和页表长度。\n\t- 段表寄存器用于存放段表起始地址和段表长度 TL。\n- 段页式系统中逻辑地址到物理地址的变换过程，如下图所示。\n\t- 根据段号 S 查段表，得到页表的起始地址。\n\t- 根据页号 P 查页表，得到物理块号 b。\n\t- 将物理块号 b 拼页内地址 W 得到物理地址。\n\t\n\t\t{%centerquote%}\n\t\t![](/images/CS/Mid-Software/mid-software-Storage-Paging&Section-Example.svg) 段页式存储管理的地址变换结构\n\t\t{%endcenterquote%}\n\n###### 虚拟存储管理\n- 页面置换算法（页面淘汰算法）\n\t- 请求分页是在纯分页系统基础上增加了请求调页功能、页面置换功能所形成的 `页面虚拟存储系统`。\n\t- 在进程运行过程中，若发生缺页但主存又无空闲块时，为保证进程能正常运行，须从主存中调出一页程序或者数据送到 `磁盘对换区`。\n\t- 究竟将哪个页面调出，需根据一定的页面置换算法来决定。\n- 先进选出置换算法（FIFO）：总是淘汰最先进入主存的页面，即选择在主存中驻留时间最近的页面予以淘汰。\n\n\t> 当分配物理块数量增多时，有缺页次数增加、缺页率提高的异常现象，称之为 `抖动`。\n\n- 最近最少未使用置换算法（Least recently used, LRU）\n\t- 选择最近最少未使用的页面予以淘汰。\n\t- 系统在每个页面设置一个访问字段，用于记录这个页面自上次被访问以来所经历的时间 T，选择 T 最大的页面予以淘汰，但实现时需硬件支持（寄存器或栈）。\n\n- [实例] 在一虚拟存储系统中，进程的内存空间为 3 页，开始内存为空，有以下访问页序列：5 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 5 0 1，分别计算 FIFO 置换算法和 LRU 置换算法的缺页次数。\n\n\t{%centerquote%}\n\t![](/images/CS/Mid-Software/mid-software-Storage-Virtual-Example.svg) FIFO 置换算法和 LRU 置换算法的缺页次数对比\n\t{%endcenterquote%}\n\n#### 磁盘管理\n- 磁盘结构与参数\n\n\t{%centerquote%}\n\t![](/images/CS/Mid-Software/mid-software-DiskManager-Structure.svg) 磁盘结构与参数\n\t{%endcenterquote%}\n\n- 磁盘的性能参数\n\t- 磁盘存取数据时间\n\t- 磁盘容量\n\n- 存取时间 = 寻道时间 + 等待时间\n\t- 等待时间：平均定位时间 + 转动延迟，即等待读写的扇区转到磁头下方所用的时间。\n\t- 寻道时间：磁头移动到磁道所需时间。\n\n- 容量\n\t- 非格式化 = 面数 \\* 磁道数/面 \\* 内圆周长 \\* 最大位密度\n\t- 格式化 = 面数 \\* 磁道数/面 \\* 扇区数/道 \\* 字节数/扇区\n\n\t\t> 格式化 = 面数 \\* 磁道数/面 \\* 单磁道字节数\n\n### 知识产权\n#### 基本概念\n- 知识产权可分为 `工业产权` 和 `著作权` 两类。\n\t- 工业产权：专利、实用新型、工业品外观设计、商标、厂商名称、服务标记、产地标记（或原产地名称）\n\n\t\t> 商业秘密、微生物技术、遗传基因技术也属于工业产权保护对象。\n\n\t- 著作权：作者对其创作的作品享有 `人身权` 和 `财权`。\n\t\t- 人身权：发表权、署名权、修改权、保护作品完整权\n\t\t- 财产权：作品使用权、获报酬权\n\n- 智力成果不限于其一，它们可 `同时` 成为工业产权和著作权保护的客体。\n\n\t> 比如，计算机软件和实用艺术品受著作权保护同时，权利人还可通过申请发明专利和外观设计专利获得专利权。\n\n- 知识产权的特点\n\t- 无形性：\n\t\t- 无形财产权，客体是智力创作性成果（或知识产品）。\n\t\t- 没有形体的精神财富，可脱离其所有者而存在的无形信息，可同时为多个主体使用。\n\t- 双重性：\n\t\t- 某些知识产权具有财产权和人身权。比如著作权。\n\t\t- 商业秘密只有财产权属性；专利权、商标权主要体现为财产权。\n\t- 确认性：智力创作性成果的财产权需要依法审查确认，以得到法律保护。\n\t- 独占性：\n\t\t- 智力成果可同时被多个主体所使用，为此法律授予知识产权一种专用权。\n\t\t- 未经权利人许可，任何单位或个人不得使用，否则构成侵权并承担相应法律责任。\n\t- 地域性：各国主管机关依照本国法律授予的知识产权，只能在其 `本国领域内` 受法律保护。\n\t- 时间性：知识产权具有法定的保护期限，期限届满则权利自行终止，成为社会公众可自由使用的知识。至于期限长短依照各国的法律确定，以下为我国知识产权保护期限的情况：\n\n\t\t- 发明专利：20 年（自专利申请日起计算）\n\t\t- 实用新型专利权和外观设计专利权：10 年（自专利申请日起计算）\n\t\t- 商标权：自核准注册之日起 10 年，可根据所有人需要无限地延长权利期限。\n\n\t\t\t> 在期限届满 6 个月内申请续展注册，每次续展注册有效期为 10 年，续展注册次数不限。\n\t\t\n\t\t- 商业秘密：受法律保护期限是不确定的，秘密一旦被公众所知悉即可成为自由似乎用的知识。\n\n#### 计算机软件著作权\n##### 著作权的主体与客体\n- 软件著作权的主体\n\t- 公民：公民自行独立开发、订立委托合同他人开发（约定著作权归自己享有）、转让取得、继承取得\n\t- 法人\n\t\t- 法人组织并提供创作物质条件所实施的开发（法人承担社会责任）\n\t\t- 接口委托、转让等有效合同关系取得著作权的主体资格\n\t\t- 法人变更而依法成为著作权的主体\n\t- 其他组织\n- 软件著作权的客体：计算机程序及其有关文档\n\n##### 著作权的权利\n- 著作人身权（精神权利）\n\t- 发表权\n\t- 开发者身份权（署名权）\n- 著作财产权（经济权利）：使用权、复制权、修改权、发行权、翻译权、注释权、信息网络传播权、出租权、使用许可权和获得报酬权、转让权。\n- 合法持有人的权利\n\t- 把软件装入计算机等存储信息的装置内。\n\t- 必要的复制。\n\t- 制作备份复制品，复制品不得通过任何方式提供他人使用。\n\t- 不得向第三方提供修改后的软件。\n\n##### 著作权的保护期\n- 自软件开发完成之日起产生，保护期为 50 年。\n- 保护期满，除开发者身份权以外，其他权利终止。软件进入共有领域。\n\n#### 计算机软件商业秘密\n- 商业秘密定义\n\t- 不为公众所知悉的；\n\t- 能为权利人带来经济利益；\n\t- 具有实用性并经权利人采取保密措施的技术信息和经营信息。\n- 商业秘密构成条件\n\t- 未公开性\n\t- 实用性：能给权利人带来经济效益\n\t- 保密性\n\n\t> 缺少上述任一条件时，商业秘密丧失保护。\n\n- 商业秘密权：无形财产权\n\n#### 专利权\n- 对于专利不适用的对象，不授予专利权\n\t- 违法国家法律、社会公德、妨害公共利益的发明创造。\n\t- 科学发现：客观世界存在但未揭示的规律、性质和现象等的认识。\n\n\t\t> 科学发明与科学发现表述的概念是不一样的。\n\n\t- 智力活动的规则和方法：人们进行推理、分析、判断、运算、处理、记忆等思维活动的规则和方法。\n\t- 病的诊断和治疗方法\n\t- 动物和植物品种，但动植物品种的生产方法可依照专利法规定授予专利权。\n\t- 用原子核变换方法获得的物质。\n\n- 授予专利权的条件\n\t- 新颖性\n\t- 创造性\n\t- 实用性：发明或实用新型能够制造或使用，且能够产生积极的效果。\n\n- 专利的申请\n\t- 专利申请权\n\t- 专利申请人：公民、法人、组织\n\t\t- 职务发明创造的单位\n\t\t- 非职务发明创造的专利申请人为完成发明创造的发明人或设计人\n\t\t- 共同发明创造的专利申请人是共同发明人或设计人或其所属单位\n\t\t- 委托发明创造的专利申请人为合同约定的人\n\t\t- 受让人\n\t- 专利申请原则\n\t\t- 一份申请一项发明\n\t\t- 最先申请原则\n\t- 专利申请日（关键日）\n\t\t- 专利申请受理代办处收到完整专利申请文件的日期。\n\t\t- 申请文件为邮寄的，以寄出的邮戳日为申请日。\n\t- 专利申请审批\n\t\t- 初步审查：经初步审查认为符合本法要求的，自申请日起满18个月，即行公布（公布申请）。\n\t\t- 自申请日起三年内，专利局可根据申请人随时提出请求，对其申请进行实质审查。\n\n\t\t\t> 实质审查：对申请专利的新颖性、创造性、实用性等依法审查的法定程序。\n\t\t\n\t\t- 实用新型和外观设计专利申请只进行初步审查，不进行实质审查。","tags":["软件工程","数据库","数据结构","操作系统","软考","CS"],"categories":["Project"]},{"title":"子弹笔记：让每个人都可以笔记方式撰写自传","url":"/2020/11/bullet-journal.html","content":"\n## 零 引言\n- 子弹笔记术：概括描述就是以列表清单的方式，结合其特色符号及方法，以高效性、目的性和功能性地去记录任务、事项以及笔记。最直观感受是本笔记由 Markdown 编写生成，Markdown 所具有的样式特征或多或少正符合着子弹笔记术的思想理念。\n- 本笔记偏向于本书讲述的方法论，不建议生搬硬套交作业，侧重理解子弹笔记的核心思想，勤于思考和练习便可设计创造属于自己的笔记方法论。让我们带着创作的热情，以子弹笔记术为指导方法来开启属于自己的一部自传。\n\n\t> 当然 `子弹笔记术` 不仅有方法论部分，而且还有艺术创作部分（第四章），有兴趣的朋友请参阅原书。\n\n<!-- More -->\n\n## 壹 准备阶段\n\n> 关键词：做什么；为什么\n\n### 指导\n- 初学者指南\n\t- 子弹笔记由两大元素组成：方法和实践。第二章介绍方法（包括要素概念及用途），第三、四章则深入实践。\n\t- 推荐顺序方式阅读本书。\n- 非初学指南\n\t- 书中的章节设计是独立子集，若熟悉子弹笔记的术语，可任意阅读感兴趣的章节。\n\n### 内在因素\n- 意向性地生活：作者认为是一种遵循自己 `信念行动` 的生活方式。\n\n\t> 与之相反的是 `随心所欲` 的生活方式。\n\n\t- 认同自己的行动；\n\t- 关注自己能产生共鸣和兴趣的事物，也需要关注无法产生共鸣和兴趣的事物；\n\t- 视作一部持续更新的 `自传`，不断地追踪，自我回顾与思考。\n\n### 整理想法\n- 选择是有成本的，减少强加于自身的决策，专注于重要的事情。\n- 思想清单：将想法具象化并记录下来，形成思想清单。\n\t- 正在做的\n\t- 应该做的\n\t- 想要做的\n- 遍历测验：对于每一项事情，以是否紧要、是否重要的方式思考问题，剔除没有价值的事情，剩余事情分类：\n\t- 需要做的事情：属于你的责任\n\t- 想要做的事情：属于你的目标\n\n##  贰 结构介绍\n\n> 关键词： 任务单；规划簿；日记本\n\n### 关键概念\n- `索引`：标题 + 页码 --> 定位内容\n- `快速记录`：简单的记号或符号捕捉想法（笔记、时间、任务分门别类），并依据时间/优先级等方式排序。\n- `未来记录`：记录本月意外的任务和事件。\n- `月度记录`： 本月的时间安排和任务（或本月的思想清单）。\n- `每日记录`：一天零碎的想法。\n- `子集`：模块化笔记\n\n\t> 单独项目独立成项，行为子弹笔记的子集，子集中也存在索引、未来记录、月度记录、每日记录以及快速记录。\n\n- `迁移`：每月从笔记中过滤掉无意义内容的过程。\n\n### 快速记录\n- 快速记录法：一言蔽之，就是以不断更新的列表形式，通过特定的符号和结构帮助我们捕捉并管理想法。\n- 笔记、事件和任务的符号表述：\n\n| 样式 | 备注 |\n| :--- | :--- |\n| - 笔记 | `-` 表示为一笔记 |\n| ○ 事件 | `○` 表示为一事件 |\n| ● 任务 | `●` 表示为一任务 |\n| ✕ 已完成任务 | `✕` 表示为已完成的任务 |\n| > 迁移的任务 | `>` 表示为迁移的任务 |\n| < 计划中任务 | `<` 表示为计划中的任务 |\n| ~~● 不相关任务~~ | `--` 表示为不相关的任务 |\n\n### 标题页码\n- 确定标题\n\t- 标题即描述内容\n\t- 阐明意图：具有意向性、目的性\n\t- 内容安排\n\n| 一般形式 | 改造之后 |\n| :---: | :---: |\n| 10月13日-第四次会议笔记 | 10-13.四.艾米克公司.企业网站更新 |\n\n- 页码索引\n\n### 子弹短句\n- 项目分类\n\t- 你需要做的事情 -- `任务`\n\t- 你的经历 -- `事件`\n\t- 你不想遗忘的信息 -- `笔记`\n\n\t\t> 每类子弹短句会被赋予特定的符号，其能够帮助你快速捕捉想法、帮助你通过特定的背景理解想法，也便于定位查找特定的内容。\n\n#### 任务子弹\n- 任务子弹的不同形态\n\n| 形态 | 符号 | 说明 |\n| :--- | :--- | :--- |\n| 任务 | ● 任务 | 需要采取行动的事项 |\n| 完成的任务 | * 完成的任务 | 已完成的任务 |\n| 迁移的任务 |  > 迁移的任务 | 推迟的月度记录或者某个特定的子集 |\n| 计划的任务 | < 计划的任务 | 不在本月范围但被提前前几项的未来记录 |\n| 不相关任务 | ~~不相关任务~~ | 计划赶不上变化，怕影响你的注意力则剔除它 |\n\n- 主任务和次任务\n\t- 次任务从属于某一主任务，可简单地缩进位列于主任务下方。\n\t- 主任务下设过多次任务，建议将该主任务形成独立的子集。\n\n#### 事件子弹\n - 事件子弹：在事件过去后及时记笔记，保留细节且描述保持简洁。\n\n#### 笔记子弹\n- 笔记子弹：包括事实、注意、想法、评论，想要记住但又无须或者无法立刻采取行动的信息。\n\n\t> 适用于会议、讲座、课堂等。\n\n### 特殊符号\n- 特殊符号置于子弹短句前，达到突出短句的目的，方便我们快速定位、浏览。\n- 尽量减少使用特殊符号和个性化子弹，太多规则反而让记事变得复杂，效率变低。\n\n### 每日记录\n- 每日记录之需要写上今天的日期和页码，利用 `快速记录法` 将一天的任务、事件、笔记统统记录下来。\n- 设定目标，但不强求设定期望，毕竟期望是我们无法控制的。\n\n\t> 自己通常的做法是标记目标的完成度（0 - 100%）。\n\n### 月度记录\n- 日历页（时间轴）\n\t- 简短地记述内容，仅供参考所需。\n\t- 可提前在日历页标注事件与任务，但计划不会一成不变，为此建议完成后补充记录。\n\n\t\t> 体验了时间轴的功能，它不仅阐明了事件内容，且交代了发生时间、发生背景。\n\n- 任务页（思想清单）\n\t- 记录每月需要完成的事务，事务优先级\n\t- 回顾上月未完成事务，把重要事务记录到下一个月的任务页\n\n\t\t> 从另一角度思考，这反馈了待完成事务的延期信息（是否可以结合甘特图来制定时间计划表？）。\n\n### 索引\n- 子集索引\n- 专用索引：为某一项计划专门设立的子集，并为之设定索引页。\n\n\t```shell\n\t# 公司新网站计划 1.0\n\n\t头脑风暴 1 - 15\n\t网站设计 16 - 60\n\t\t用户流 16 - 20\n\t\t线框图 21 - 30\n\t\t设计稿 31 - 50\n\t\t用户测试 51 - 60\n\t网站内容 61 - 90\n\t\t内容策略 61 - 70\n\t\t更新后的输入输出系统 / 片段描述 71 - 80\n\t\t产品描述 81 - 90\n\t```\n\n- 引线法\n\n### 任务迁移\n- 定期审视自己的任务，把时间和精力放在真正重要的事情上。\n\n\t> 毕竟计划的初衷就是，我们可以完成某件事，但并不要求我们应该/必须完成某件事（期限性和不可控性）。\n\n- 月度迁移\n- 年度迁移（全书迁移）：建议笔记以年度归档，将子集以及其未完成的项目计入下一笔记本中。\n- 思想清单迁移\n\n## 叁 实际操作\n\n> 关键词：行动；信念\n\n### 反思\n- 每日反思\n\t- 被动回应：受到刺激 --> 被动回应 --> 人通常会感到恐惧、焦虑\n\t- 意向驱使：受到刺激 --> 主动应对 --> 通过选择/方法/目标 --> 人会积极反思\n- 日反思 --> 规划 \n- 夜反思 --> 回顾\n- 通过迁移进行月度反思和年度反思：迁移操作实质上是一种过滤机制，你需要对未完成的任务进行反思，如此迁移才有意向性。\n\n### 意义\n- 思想实验：试想自己站在岔路口，面前有两条路可走，一条人迹更多，另一条人迹更少。待迟暮之年，在个人生活或者专业技术方面会获得什么成就，这样的生活给您带来什么结果？\n\t- `人迹更多的路`：带你走向更熟悉的地方，是目前生活的延续，只追求舒适的进步，不降低现有生活品质，也不改变现状。\n\t- `人迹更少的路`：带你走向不熟悉的地方，冒险多于舒适的生活。敢于追求感兴趣的目标，愿意通过奋斗来提升自己。\n- 身后反思：分别为两条路创建一份 “两种生活” 的子集。选择你喜欢的生活方式，圈出你最骄傲的成就。完成后把这些事项迁移到你的 `目标子集`。\n\n### 目标\n\n#### 概述\n- 适当的目标：带有意向地设定目标。\n- 盗用他人的目标，或许会成为一种诱惑，看似很宏大但相对于自己意义不大。例如：挣它一个亿。\n- 长期的目标：源于自身生活经历，明确意义设定长期目标。\n\n#### 实践\n- `54321倒计时法则`\n\t- 将目标分为短期、中期、长期\n\t- 左边空白两页，左页是你的个人目标，右页是你的职业目标页；每个页面分 5 栏，5 栏依上往下是 5 年内目标、4 月内目标、3 周内目标、2 日内目标以及 1 小时内目标。\n\n\t\t> 可以采纳作为记事应用的一项特色功能来开发。\n\t\t\n| 54321倒计时法则 |\n| :--- |\n| **5 年目标**<br>组建家庭<br>购置房产<br>流利掌握一门语言  |\n| **4 月目标**<br>环岛旅行<br>体脂降低10%<br>拜访研究生导师 |\n| **3 周目标**<br>捐赠衣物<br>志愿活动 |\n| **2 日目标**<br>清理衣柜<br>打扫房间<br>激活社保卡 |\n| **1 时目标**<br>月度记账<br>给父母打电话 |\n\n- `分清目标轻重主次`\n\t- 每一栏都分开考虑个人目标和职业目标\n\t- 每一栏只考虑一项最先考虑的目标\n- `专注于优先事项`：注意力残留原则，一次只专注于一件事，专注于实现目标过程。最具价值的也是实现目标的过程，因它占据了大部分的生活，因此提供了大量信息让你成长。\n- `长期目标为冲刺目标`\n\t- 并不一定要把喜欢的事情变成职业，建议在体验过一段时间后再做决断。\n\t- 将长期目标分解一个短期、独立的冲刺目标。类似软件开发的开发周期，即分阶段设立目标。\n- `设立冲刺目标的要求`\n\t- 初始阶段忌设立大障碍目标\n\t- 具有清晰可行的任务步骤\n\t- 完成时间必须固定在短期内\n- `头脑风暴`：在分解目标前，我们必须认识考虑，思考要做什么和为什么做？\n\t- 目标为什么会激起我的好奇心？\n\t- 是什么鼓励我为这个目标费时费力？\n\t- 我要达成什么目标？\n\t- 有什么要求？\n\t- 在这个目标上，成功的定义是？\n\n### 循序渐进\n- `PDCA 循环`：Plan -> Do -> Check -> Act\n\t- 计划 / Plan：发现机会，制定改进计划\n\t- 执行 / Do：执行计划，测试改进结果\n\t- 检查 / Check：分析测试结果，确认学习成果\n\t- 行动 / Act：按照学习成果行动\n\t\t- 没有改进：换一个计划重新开始，循环上述步骤\n\t\t- 取得改进：结合所学执行新计划，循环上述步骤\n- `达成小成就`：找到任何一种成就，即使微小都无所谓，降低标准保证切实可行，然后以任务子弹的形式写进子弹笔记，完成它以达成成就。\n\n### 时间\n- 时间箱管理：把任务完成时间规定在一定范围内，其意图是把百分百的注意力按照规定的时间限制投入一事物上。\n\t- 两个关键激励因素：条理感和紧迫感\n- 勿拖延请置顶：找出自己最高效、最专注的时候，事情从难到易排序，以制定执行计划。\n- 勿忘死亡：人固有一死，珍惜生命一分一秒。\n\n### 感恩\n- 反思完成一项任务对自己的影响？什么感觉，有何价值？\n- 自我庆祝：根据自己心理预期，对所有事项设定奖励机制，有意识地创造动力以形成良性循环。\n- 感恩子集：创建 `感恩记录`，并每天写下至少一件让你感恩的事，养成习惯。因为你对生活的留心观察，微小的幸福汇将促成更美好的生活。\n\n### 掌控\n- 我们无法掌控外部的世界、人和事，但我们能控制自己的内心世界。\n- 应对与回应：若与他人有冲突之时，冷静分析现状，千万不要有过激行为，毕竟恐惧或愤怒的回应只会加深对方和自身的创伤，失去相互理解、解决问题的机会。因此，需要每日反思重新审视这件事。\n- 过程与结果：\n\t\n\t- 在进行日反思与夜反思以及月度迁移时，遍历一遍任务列表，试着找出在你掌握之内以及之外的事情。\n- 观察这条任务是侧重结果，还是侧重于过程。尽管目标带来方向，若目标过于侧重结果，往往结果是不可控的。\n\t\n\t> 例：减脂 10%、雅思 6.5、做一个很棒的汇报等。\n\t\n\t- 对于过于庞大的目标，尝试把目标分解成一个个可执行的小步骤。\n\n### 辐射力\n- 坚信你的一言一行所带有的能量会改变周遭世界和其中的人。\n- 自我怜悯：自我评判与自我反思。\n- 共同进步：辐射力是双向的，自己与朋友自己都需要时不时接受对方的审视。找一个朋友，两人互相尊重、赏识、关怀，共同成长。\n\n### 忍耐\n- 分析记录：不要把注意力放在干活的痛苦一面，我们更应该关注它带来收获的方面。创建一个 `分析记录`，留意为什么要做这件事情，努力的具体目的是？\n\n\t> 例如：付房租 --> 浪费钱？ <--> 学区房 / 通勤时间短 / 朋友相聚 --> 平衡心中的负面情绪 \n\n- 追踪进度：不要轻易放弃，但一件事情对于自己目前来说毫无价值，或是付诸努力与结果不成正比，这可能是分散注意力的事，暂且放下它吧。\n\n\t> 利用月度迁移定期检查自己的进度。\n\n### 拆解\n- 五问法：分解大问题为小问题，在子弹笔记中创建一个子集，以问题为标题，以不同维度提出问题，并挖掘潜在的价值。\n\n### 无力感\n- 橡皮鸭调试法：如身边无人聆听，你可以向一只玩具橡皮鸭写一份信，在详细叙述事情的过程中，可能你已经找到应对方法了。\n\t- 你遇到的问题\n\t- 出问题的地方\n\t- 出问题的原因\n\t- 尝试过的方法\n\t- 未尝试的方法\n\t- 你想要的结果\n- 停顿目标：\n\t- 时间不可多于两周：在不影响主项目进展情况下，停下来歇歇，可走得更远。\n\t- 困扰你的项目 / 问题无关：你和主要项目都需要空间。停顿目标不是要脱离主项目，而是享受一些 \"自我时光\"。\n\t- 关键点是要有明确的开头、结尾和过程。\n\n### 不完美\n- 练习不完美\n- 良好的改变\n\t- 寻求进步的方法，把答案制成任务或目标，记录在子弹笔记中。\n\t- 可量化的进步：完成一项任务即得到一段经历。 \n\n## 肆 艺术创作\n### 关键概念\n- 利用个性化子集延伸子弹笔记的功能\n\n\t> 注意：个性化子集应具有目的性，不断更新的子集能给你的生活带来价值，提高生产力的关键在于谨慎地投资你的时间。\n\n- 明确你的动机\n- 温故而知新\n\n\t> 研究的不只是你在做的内容，还有这样做的方法。\n\n- 功能大于形式\n- 设计应具有长效保质期\n\n\t> 设计不仅当下浅显易懂，往后回顾也要清晰明白。\n\t> \n\n### 个性化子集\n- 个性化子集的设计意图\n\t- 满足特定的需求\n\t- 特定的子集设计，具有主题性，可引发思考\n- 个性化子集的来源\n\t- 目标：大目标、阶段性目标，需要拆分为 n 个小目标来逐个解决。\n\t- 难题：通过不同维度解读、分析难题，得出不同解决方案，并记录你的进步。\n\t- 任务：大任务、发杂性任务，同样可以细分为小任务。\n\n\t\t> 任务还可以结合甘特图管理时间进度，百分比记录小任务甚至整体任务的完成度。\n\n### 清单\n- 分清主次：每个事项清单都应有优先级别设定。\n- 背景信息：清单中可加入 `参考元素` 以描述背景信息，例如时间维度、空间维度等。\n\t- 时间信息\n\t- 地点信息\n\t- 成本信息\n\t- ...\n\n## 伍 拓展阅读\n- 豆瓣书评：[赖德·卡罗尔. 子弹笔记. 2018. douban.com](https://book.douban.com/subject/30395230/)\n- 知乎问答：[warfalcon, 吴美丽Vase. luluscl 等. 子弹笔记如何高效使用. zhihu.com](https://www.zhihu.com/question/58521083)\n- [maxOS. 子弹笔记 — 你所需要仅仅是笔和本. 2017. sspai.com](https://sspai.com/post/39340)\n- [胡红梅River. 子弹笔记：子弹笔记就是本不断更新的自传. 2019. jianshu.com](https://www.jianshu.com/p/cd79a28c9c4f)","tags":["to-do","手账","规划","备忘"],"categories":["Reading"]},{"title":"论文 | 基于根因分析的报警聚类算法","url":"/2019/08/root-cause-analysis-alarm-clustering.html","content":"\n{% note default %}\n原文：Clustering intrusion detection alarms to support root cause analysis\n作者：Klaus Julisch\n来源：ACM Transactions on Information and System Security, 2003, 6(4):443-471.\n{% endnote %}\n\n## 背景\n- 系统出现故障时，运维人员一般先查看错误日志定位故障原因。\n- 业务流量小、逻辑复杂度低时，应用出现故障时错误日志一般较少，运维人员根据错误日志迅速定位到问题。但随着业务逻辑的迭代，系统接入的依赖服务不断增多、引入的组件不断增多，当系统出现故障时，`错误日志的量级急剧增加`。极端情况下更甚出现 \"疯狂报错\" 的现象，这时错误日志的内容会存在 `相互掩埋`、`相互影响` 的问题，运维人员面对报错一时难以理清逻辑， 失去焦点，没能第一时间解决最核心问题。\n- 若在报警流出现时，通过处理程序将报警进行聚类，整理出一段时间内的报警摘要。运维人员就可以在摘要信息的帮助下，先对当前的故障有一个大致的轮廓，再结合技术知识与业务知识定位故障的根本原因。\n- 围绕上面描述的问题，以及对于报警聚类处理的分析假设，本文主要做了以下事情：  \n\t- `选定算法`：选定聚类算法，简单描述算法基本原理，并给出针对报警日志聚类的一种具体实现方案。  \n\t- `验证算法`：在分布式业务服务的系统下构造了三种不同实验场景，验证了算法的效果，并且对算法的不足进行分析阐述。\n\n<!-- More -->\n\n## 目标\n- 我们希望这些泛化报警既要具有很强的概括性，同时尽可能地保留细节。这样运维人员在收到报警时，便能快速定位故障的大致方向，从而提高故障排查的效率。\n- 对一段时间内的报警进行聚类处理，将具有相同根因的报警归纳为能够涵盖报警内容的泛化报警，最终形成仅有几条泛化报警的报警摘要，如图 1-1 所示。\n\n\t![](/images/illustration/Paper/2019/alarm-clustering_1-1.jpg)\n\t<center>图 1-1 通过聚类算法泛化报警日志</center>\n\n## 概述\n- 如图 1-2 所示，文章主要分三个部分阐述：提取报警特征、算法实现以及展示报警摘要。\n- 首先，是根据根因分析提取报警关键特征，并生成报警信息的泛化层次结构。其次，则是从泛化层次结构中计算得不同报警对象之间的不相似度度量，以确定最具象化的泛化表示、最大程度涵盖原始报警集合的泛化层次结构。最后，经由聚类算法获得泛化报警簇群，以簇群代表某一类报警信息。\n\n\t> 聚类算法还涉及 `min_size` 与 `聚类停止条件` 的调参问题，详情见下文描述。\n\n\t![](/images/illustration/Paper/2019/alarm-clustering_1-2.png)\n\t<center>图 1-2 文章的章节布局</center>\n\n## 正文\n### 泛化初探\n- 将报警信息抽象表达、逐层分解，形成类似于 `树结构` 或者 `有向无环图` 的泛化层次结构。\n\n\t如图 1-3 所示，可将服务器的报警抽象为 “全部服务器 网络调用 故障”，也可以抽象为 “server_room_a 服务器 网络调用 产品信息获取失败” 和 “server_room_b 服务器 RPC 获取产品类型信息失败”。\n\n\t> 前者泛化范围较广、抽象层次较高，细节越少；后者包含的范围较小、抽象层次低，则包含的无用信息可能越多。当然不局限于一种层次关系，你也可以用其他层次的抽象来表达这个报警集群。\n\n\t![](/images/illustration/Paper/2019/alarm-clustering_1-3.jpg)\n\t<center>图 1-3 服务器的报警泛化初探</center>\n\n### 算法定义\n- 为了确定报警聚类泛化的程度，我们需要先了解一些定义：\n\t- `属性` ( Attribute )：构成报警日志的基本信息，如机器、环境、时间等，记作 $A_i$。\n\t- `值域` ( Domain )：属性 $A_i$  的值域 ( 取值范围 )，记作 $Dom(A_i)$。\n\t- `泛化层次结构` ( Generalization Hierarchy )：对于每个属性 $A_i$，都有一个对应的泛化层次结构，记作 $G_i$。\n\t- `不相似度` ( Dissimilarity )：定义为 $d(\\mathcal{a_1}, \\mathcal{a_2})$。它接受两个报警 $\\mathcal{a_1}$、$\\mathcal{a_2}$ 作为输入，并返回一个数值量，表示这两个报警不相似的程度。当 $d(\\mathcal{a_1}, \\mathcal{a_2})$ 较小时，表示报警 $\\mathcal{a_1}$ 和报警 $\\mathcal{a_2}$ 越相似，相反越大则越不相似。为了计算不相似度，则需要用户预先定义好报警信息的 `泛化层次结构`。\n- 计算 $d(\\mathcal{a_1}, \\mathcal{a_2})$，我们先定义两个属性值的不相似度：令 $x_1$、$x_2$ 为 $\\mathcal{a_1}$、$\\mathcal{a_2}$ 某个属性 $A_i$ 的两个不同的值，$x_1、x_2 \\in Dom(A_i)$。\n\t-  在属性 $A_i$ 的泛化层次结构 $G_i$ 中，通过一个公共点父节点 $p$ 连接 $x_1$、$x_2$ 的最短路径长度。$\\delta(·,·)$ 表示两节点的最短路径长度，把它们累加起来以表示两个属性的不相似度。\n\n\t$$\n\td(x_1, x_2) := \\min \\left\\{\n\t\t\\delta(x_1, p) + \\delta(x_2, p) \\mid \n\t\tp \\in G_i, x1 \\trianglelefteq p, x2 \\trianglelefteq p\n\t\\right\\}\n\t\\tag{1}\n\t$$\n\t\t\n\t> 举例：在图 1-3 的泛化层次结构中：  \n\t> d(\"Thrift\", \"Pigeon\") = d(\"RPC\", \"Thrift\") + d(\"RPC\", \"Pigeon\") =  1 + 1 = 2  \n\t\t\n\t- 接下来把警报的所有属性都加入计算，累加报警的所有属性的不相似度，即可表示报警的不相似度。对于两个报警 $\\mathcal{a_1}$、$\\mathcal{a_2}$，其不相似度的计算公式为：\n\n\t$$\n\td(\\mathcal{a_1}, \\mathcal{a_2}) := \n\t\t\\sum_{i=1}^n d(\\mathcal{a_1}[A_i], \\mathcal{a_2}[A_i])\n\t\\tag{2}\n\t$$\n\t\t\n\t> 举例：参考图 1-3 的泛化层次结构：  \n\t> $\\mathcal{a_1}$ = (\"server_room_b-biz_tag-offline02\", \"Thrift\")     \n\t> $\\mathcal{a_2}$ = (\"server_room_a-biz_tag-online01\", \"Pigeon\")  \n\t> \n\t> $d(\\mathcal{a_1}, \\mathcal{a_2})$ =  \n\t> d(\"server_room_b-biz_tag-offline02\", \"server_room_a-biz_tag-online01\") +   \n\t> d(\"Thrift\", \"Pigeon\")  \n\t> \n\t> $d(\\mathcal{a_1}, \\mathcal{a_2})$ =  \n\t> d(\"server_room_b-biz_tag-offline02\", \"服务器\") +  \n\t> d(\"server_room_a-biz_tag-online01\", \"服务器\") +   \n\t> d(\"RPC\", \"Thrift\") +  \n\t> d(\"RPC\",  \"Pigeon\")  \n\t> = 2 + 2 + 1 + 1 = 6\n\n- 对于某个报警聚类来说，我们如何获得既能够涵盖它的集合又有最具象化的泛化表示？回答问题前，我们预先完成一些定义：\n\t- 一个警报对象是 n 维属性空间 $dom(A_1) \\times dom(A_2) ... \\times dom(A_n)$ 上的元组，记作 $\\mathcal{X}_{i = 1}^{n} Dom(A_i)$。\n\t- 我们用 $C$ 表示报警集合，$\\mathbf{g}$ 是 $C$ 的一个泛化表示，满足 $\\forall \\mathcal{a} \\in C, \\mathcal{a} \\trianglelefteq \\mathcal{g}$。\n\n\t\t> 以报警集合 {\"dx-trip-package-api02 Thrift get deal list error\", \"dx-trip-package-api01 Thrift get deal list error\"} 为例，`dx服务器 thrift调用 获取产品信息失败` 是一个泛化表示，`服务器 网络调用 获取产品信息失败` 也是一个泛化表示。\n\t\t\n\t- 定义 $d_i := d(\\mathcal{g}, a_i), i = 1, 2$，$d_i$ 表示在警报 $a_i$ 中需要多少个属性即可让 $\\mathcal{g}$ 泛化表示 $\\mathcal{a_i}$。当 $d_1 + d_2$ 越小，$\\mathcal{g}$ 从警报 $\\mathcal{a_1}、\\mathcal{a_2}$ 中获得泛化表示的步数越少，说明 $\\mathcal{g}$ 对 $\\mathcal{a_1}、\\mathcal{a_2}$ 覆盖越充分。相反，当 $d_1 + d_2$ 越大，由于过于抽象或者未能有效捕获警报 $\\mathcal{a_1}、\\mathcal {a_2}$ 的详细信息，说明当前 $\\mathcal{g}$ 的覆盖效果不好。\n\n\t- 因此，明确我们的目标是计算得 `最小化的报警不相似度` 以获得 `最具象化的泛化表示`。为了解决这个问题，定义以下两个指标：\n\n\t$$\n\t\\overline{d} (\\mathcal{g}, \\mathcal{C}) := \n\t\t1 / | \\mathcal{C} | \n\t\t\\times \\sum _{\\mathcal{a} \\in C} d (\\mathcal{g}, \\mathcal{a})\n\t\\tag{3}\n\t$$\n\t\t\n\t$$\n\tH(C) := \\min \\left\\{\n\t\t\\overline {d}(\\mathcal{g} , C) \\mid\n\t\t\\mathcal {g} \\in \\mathcal{X}_{i = 1}^{n} Dom(A_i),\n\t\t\\forall \\mathcal {a} \\in C : \\mathcal{a} \\trianglelefteq \\mathcal{g}\n\t\\right\\} \\tag{4}\n\t$$\n\t\n\t> $H(C)$ 代表一个报警簇群 $C$ 的相异性度量，$\\overline{d} (\\mathcal{g}, \\mathcal{C})$ 代表一个报警簇群的平均相异性度量。$H(C)$ 值最小时对应的 $\\mathcal{g}$ 就是我们要找的最适合的泛化表示，我们称 $\\mathcal{g}$ 为 $C$ 的覆盖。\n\n- 基于以上的概念，将报警日志聚类问题定义为：\n\t- 定义 $L$ 为一个日志集合，$G_i(i = 1, 2, 3……n)$ 为属性 $A_i$ 的泛化层次结构，min\\_size $ \\in \\mathbb{N}$ 为一个预设的常量。\n\t- 目标是找到一个 $L$ 的子集 $C$，簇群中元素数量满足 $|C| \\geq$ min\\_size，且 $H(C)$ 值最小。\n\t\n\t\t> `min_size` 是用来控制抽象程度的，即一个簇群至少包含的元素个数。若 `min_size` 与 $L$ 集合的大小一样，那么我们只能使用终极抽象了；若 `min_size = 1`，则每个报警日志是它自己的抽象。\n\t\t\n\t- 找到一个聚类之后，我们可以去除这些元素，然后在 $L$ 剩下的集合里找其他的聚类。\n\n- 不幸的是，这是个 NP 完全问题 ( [分团问题](https://en.wikipedia.org/wiki/Clique_problem) )。因此论文 $^{[2]}$ 提出了一种启发式算法，该算法满足 $|C| \\geq$ min\\_size，使 $H(C)$ 值尽量小 ( 并不一定要最小化的 $H(C)$  )。\n\n### 算法描述\n- 启发式 Alarm-Clustering 算法：面向属性归纳的改进算法 (Attribute-oriented induction, AOI) $^{[3]}$。\n\n\t> `面向属性归纳的改进算法`：1) 对比经典的 AOI 算法更保守地概括属性；2) 使用了类似基于密度聚类的聚类终止条件。  \n\n\t- `Step.01`: 算法假设所有的泛化层次结构 $G_i$ 都是树，这样每个报警集群都有一个唯一的、最顶层的泛化结果。\n\t- `Step.02`: 将 $L$ 定义为一个原始的报警日志集合，算法选择一个属性 $A_i$，将 $L$ 中所有报警的 $A_i$ 值替换为 $G_i$ 中 $A_i$ 的父值，通过这一操作不断对报警进行泛化。\n\t- `Step.03`: 持续步骤 2 的操作，直到找到至少可以将原始报警泛化为报警簇群的最小值 min_size。\n\t- `Step.04`: 输出步骤 3 中找到的报警。\n\n- 算法的伪代码描述： \n\t- `Input`：(报警日志集合 $L$，min\\_size，每个属性的泛化层次结构 $G_1、...、G_n$)\n\t- `Output`：(泛化报警日志集合 $L$，min\\_size，每个属性的泛化层次结构 $G_1、...、G_n$)\n\n\t```r\n\t/* 将报警日志集合 L 保存至表 T，且表中每一列代表报警的一项属性 Ai */\n\tT := L\n\t\t\n\t/* count 是统计当前报警记录数量的变量 (可理解为报警簇群的大小)\n\t * count 初始化为 1 可理解为当前报警为一个仅且包含它本身的簇群 */\n\tfor all alarms a in T do a[count] = 1; \n\t\t\n\t/* 开始对报警进行泛化操作 */\n\twhile ∀a∈T:a[count] < min_size do {\n\t\t\n\t\t// Step.1 使用启发算法选择一个属性 Ai\n\t\t\n\t\t// Step.2 对 L 中所有报警进行泛化：\n\t\t// 即把报警的属性 Ai 替换为泛化层次结构 Gi 中 Ai 的父值\n\t\tfor all alarms a in T do {\n\t\t\ta[Ai] := parent of a[Ai] in Gi;\n\t\t}\n\t\t\t\n\t\t// Step.3 如果 a[Ai] == a’[Ai], i = 1, 2, ..., n\n\t\t// 即报警的所有属性 Ai 都相同\n\t\twhile identical alarms a, a' exist do {\n\t\t\t// 合并相同警报于同一个泛化报警 a 中并更新泛化警报的计数\n\t\t\tSet a[count] := a[count] + a'[count];\n\t\t\t// 完成统计后移除报警记录 a'\n\t\t\tDelete a' from T;\n\t\t}\n\t}\n\t```\n\n#### 启发式选择属性泛化报警\n\n> 其中第 11 行的启发算法为:\n\n- 统计在 $A_i$ 属性上值为 $v$ 的报警的数量，记作 $f_i(v)$：\n\n\t```sql\n\tfi(v) := SELECT sum(count) FROM T WHERE Ai = v\n\t```\n\t\n- 让 $F_i$ 记作每个属性 $A_i$ 的最大值函数 ：\n        \n\t$$\n\tF_i := \\max \\left\\{\n\t\tf_i(v) | v \\in Dom(A_i)\n\t\\right\\} \\tag{5}\n\t$$\n\n- 这里的逻辑是：\n\t- 若有一个报警 $\\mathcal{a}$ 满足 $\\mathcal{a}[count] \\geq$ min\\_size，那么对于所有属性 $A_i$ 均能满足 $F_i \\geq f_i(\\mathcal{a}[A_i]) \\geq$ min\\_size。\n\t- 相反，如果有一个属性 $A_i$ 的 $F_i <$ min\\_size，那么 $\\mathcal{a}[count]$ 就不可能大于 min\\_size。所以选择 $F_i$ 值最小的属性 $A_i$ 进行泛化。\n\t\n\t> 类似于木桶定律，装水量由最短的木板决定。\n\n#### DAG 形式的泛化层次结构\n- 当泛化层次结构是一个有向无环图 (Directed Acyclic Graph, DAG)，而不是一颗树时，结构上的任何一个节点都有可能包含多个父节点，那么一个属性值存在多个父节点将其泛化。\n\n\t针对此问题，基于经典的 AOI 提出两种解决策略：\n\n- `选择其一法`：基于用户定义的规则解决歧义问题。例如，考虑运行在同一 IP 下的 HTTP 服务器和 FTP 服务器，我们通过附加端口值进行准确泛化。\n\n\t```r\n\tif a[Destination-port] = 80\n\t\tthen generalize ip to HTTP-server \n\telse generalize ip to FTP-server;\n\t```\n\t\n- `探索所有法`：并行地探索所有可能的泛化结果 (穷举法)。改写上述代码 16 行即可实现：\n\n\t```r\n\t// Step.2 对 L 中所有报警进行泛化\n\tfor all alarms a in T do {\n\t\tT := T \\ {a};\n\t\t// 由属性 Ai 泛化报警的所有可能性都加入 T 中\n\t\tfor all parents p that a[Ai] has in Gi do {\n\t\t\ta' := a; \n\t\t\ta'[Ai] := p; \n\t\t\tT := T ∪ {a'};\n\t\t}\n\t}\n\t```\n\n#### MINSIZE 参数自适应算法\n- 此外，关于 min\\_size 的选择问题，如果选择了一个过大的 min\\_size，那么会迫使算法合并具有不同根源的报警。另一方面，如果过小，那么聚类可能会提前结束，具有相同根源的报警可能会出现在不同的聚类中。\n- 因此，设置一个初始值，可以记作 $ms_0$。定义一个较小的值 $\\varepsilon (0 < \\varepsilon < 1)$，当 min\\_size 取值为 $ms_0$、$ms_0 \\times (1 - \\varepsilon )$、$ms_0 \\times (1 + \\varepsilon )$ 时的聚类结果相同时，我们就说此时聚类是 $ \\varepsilon$-鲁棒的。\n- 如果不相同，则使 $ms_1 = ms_0 * (1 - \\varepsilon)$，重复这个测试，直到找到一个鲁棒的最小值。\n        \n\t> 需要注意的是，$ \\varepsilon$-鲁棒性与特定的报警日志相关。因此，给定的最小值，可能相对于一个报警日志来说是鲁棒的，而对于另一个报警日志来说是不鲁棒的。\n\n## 案例实现\n### 提取报警特征\n- 根据线上问题排查的经验，运维人员通常关注的指标包括时间、机器 ( 机房、环境 )、异常来源、报警日志文本提示、故障所在位置 ( 代码行数、接口、类 )、Case 相关的特殊 ID ( 订单号、产品编号、用户ID ) 等。\n- 在本案例中，实际应用场景都是线上准实时场景，时间间隔短，因此我们不需要关注时间指标；同时，Case 相关的特殊 ID 不符合抽象描述的要求，因此也无需关注此项指标。\n- 综上所述，我们选择的特征包括：`机房`、`环境`、`异常来源`、`报警日志文本摘要`、`故障所在位置` ( 接口、类 )。\n\n### 提取关键特征\n> 我们的数据来源是日志中心已经格式化过的报警日志信息，这些信息主要包含：报警日志产生的时间、服务标记、在代码中的位置、日志内容等。在定义泛化层次结构前夕，我们需要从已知的数据源中梳理出关键特征。\n\n- `机房和环境`：提取这两个指标比较简单，在此不做详细赘述。\n- `异常来源`：获得故障所在位置后，优先使用此信息确定异常报警的来源；若不能获取，则在日志内容中根据关键字匹配。需要说明的是，两者都需要预先定义词典支持。\n- `报警日志文本摘要`：优先查找日志内容中是否有异常堆栈，若存在，则查找最后一个异常 ( 通常为真正的故障原因 )；若不能获取，则在日志中查找是否存在 “code=……, message=……” 这样形式的错误提示；若不能获取，则取日志内容的第一行内容 ( 以换行符为界 )，并去除其中可能存在的 Case 相关的提示信息。\n- `故障所在位置`：优先查找是否有异常堆栈，如存在则查找第一个本地代码的位置； 若不存在，则取日志打印位置。\n\n### 泛化层次结构\n- 泛化层次结构，用于记录属性的泛化关系，是泛化时向上抽象的依据，需要预先定义。\n- 根据实验所用项目的实际使用环境，根据 `关键特性` 定义的 `泛化层次结构` 如下：\n\n\t![](/images/illustration/Paper/2019/alarm-clustering_1-4.png)\n\t<center>图 1-4 机房泛化层次结构</center>\n\t\n\t![](/images/illustration/Paper/2019/alarm-clustering_1-5.png)\n\t<center>图 1-5 环境泛化层次结构</center>\n\t\n\t![](/images/illustration/Paper/2019/alarm-clustering_1-6.png)\n\t<center>图 1-6 异常来源的泛化层次结构</center>\n\t\n\t![](/images/illustration/Paper/2019/alarm-clustering_1-7.png)\n\t<center>图 1-7 报警日志文本摘要的泛化层次结构</center>\n\t\n- `故障所在位置` 此属性无需泛化层次结构，每次泛化时直接按照包路径向上层截断，直到系统包名。\n\n### 报警聚类算法\n- 算法的执行流程，我们以图 1-8 来表述：\n\n\t![](/images/illustration/Paper/2019/alarm-clustering_1-8.png)\n\t<center>图 1-8 报警日志聚类流程图</center>\n\n- `min_size` 参数设定：考虑到日志数据中可能包含种类极多，且根据小规模数据实验表明，min\\_size $= \\frac15 \\times$ 报警日志数量时，算法已经有较好的表现，再高会增加过度聚合的风险，因此我们取 min\\_size $= \\frac15 \\times$ 报警日志数量，$\\varepsilon$ 参考论文中的实验取 0.05。\n\n- `聚类停止条件`：考虑到部分场景下，报警日志可能较少，因此 min\\_size 的值也较少，此时聚类已无太大意义，因此设定聚类停止条件为：聚类结果的报警摘要数量小于等于 20 或已经存在某个类别的 count 值达到 min\\_size 的阈值，即停止聚类。\n\n## 延伸探究\n- 在论文中，警报 $\\mathcal{a_x}$、$\\mathcal{a_y}$ 的不相似度量定义为 $d(\\mathcal{a_x}, \\mathcal{a_y}) := \\sum_{i=1}^n d(\\mathcal{a_x}[A_i], \\mathcal{a_y}[A_i])$，$d(·,·)$ 即把警报 a 中每个属性的不相似度量累加起来。\n\n\t> 在现实条件下，警报对象包含的属性值理应是有主次、重要性之分。我们计算警报的不相似度，具体计算不同的属性的不相似度时，是否考虑加入权重计算系统。\n\n- 关于泛化层次结构的表现形式包括 `有向无环图` 和 `树`。针对有向无环图形式的泛化层次结构，一个结构节点可能存在多个父节点，即一个属性值存在多个父节点将其泛化，故论文基于经典的 AOI 提出两种解决策略，以准确地选择唯一父节点去泛化报警。\n\n\t首先，是结合领域知识的 `选择其一法`，满足基本要求但需要人为因素干预。而现在问题是，若采取 `探索所有法` 将所有的泛化报警都加入集合 T 中，然而存在重复加入泛化报警的可能性，那么由原始方法构建簇群将是不正确的 (上述伪代码 23 行)。\n\t\t\n\t> 原论文描述解决办法：重新扫描原始警报日志，并确定与之匹配的原始警报的数量？细节和意图不明确，是否有替代方案？\n\t\n## 参考资料\n - [1] [美团技术团队. 根因分析初探：一种报警聚类算法在业务系统的落地实施. 2019. tech.meituan.com](https://tech.meituan.com/2019/02/28/root-clause-analysis.html)\n - [2] Julisch K . Clustering intrusion detection alarms to support root cause analysis[J]. ACM Transactions on Information and System Security, 2003, 6(4):443-471.\n - [3] Jiawei Han 等著; 范明等译. 数据挖掘:概念与技术 (原书第3版) [M]. 机械工业出版社., 2012. 111-116.","tags":["数据挖掘","聚类","根因分析"],"categories":["Paper"]},{"title":"Django：Web 框架从入门到应用","url":"/2019/02/Django.html","content":"\nDjango 是基于 MVC 模式，由 Python 写成的开源 Web 应用框架。在 Django 中，控制器接受用户输入的部分由框架自行处理，而 Django 里更关注的是模型 ( Model )、模板 ( Template ) 和视图 ( Views )，为此也称其为 MTV 模式的 Web 框架。\n\n事实上，基于 Python 的 Web 框架不仅这一家，如  flask、tornado、web2py 等。对于任何一款框架都有它自身的亮点和缺陷 $^{[2, 3]}$，综合需求、性能要求等诸多因素考量，选择合适的框架即可。比如，我们要开发一款数据库驱动的内容发布与管理系统，借助 Django 的中间件 [ORM](https://baike.baidu.com/item/对象关系映射) 设计优点，使得在操作业务对象时，不需要和复杂的 SQL 语句打交道，只要像平时一样操作对象即可，以高效率完成轻量级后端系统的开发工作。\n\n<!-- More -->\n\n## 教学资源\n- 📺 | 视频 | [老男孩.Python 全栈: Django 框架入门到应用. 2018. bilibili.com](https://www.bilibili.com/video/av22606568/?p=3)\n- 📄 | 文章 | [Django.Django 快速入门&中文使用文档. djangoproject.com](https://docs.djangoproject.com/zh-hans/2.1/)\n\n## 快速上手\n### 安装与配置\n- 安装：命令行模式安装 ( Mac / Linux 用户注意管理员权限 )\n\n\t```bash\n\tpip install django\n\tpip install django == x.xx.xx\n\t```\n\t\n- 配置：配置 Django 项目并初次启动它。\n\t- 创建项目：可通过命令模式启动项目 ( 多用于部署环境 )，也可通过 PyCharm 启动、运行项目。\n\t\t- 命令模式：`django-admin startproject mysite`\n\t\t- PyCharm：通过 PyCharm 一步到位，即 `新建工程 > Django > ( 建立单独的 Venv ) > mysite`。\n\n\t\t\t> Virtualenv：为一个应用创建一套“隔离”的 Python 运行环境，具体配置方法可参考 [1]。\n\t\t\n\t- 项目目录结构说明\n\t\t- `mysite`：同名目录，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名，比如 mysite.urls。\n\t\t- `__init__.py`：空文件，标识这个目录应识别为 Python 包。\n\t\t- `settings.py`：Django 的项目配置文件。\n\t\t- `urls.py`：Django 项目的 URL 声明。\n\t\t- `wsgi.py`：Web 服务网关接口 ( Socket )。\n\t\t- `manage.py`：对网络所有管理是通过其来实现的。\n\t\t\n\t\t\t```bash\n\t\t\tmysite\n\t\t\t  ├─── mysite\n\t\t\t  │ ├── init__.py\n\t\t\t  │ ├── settings.py\n\t\t\t  │ ├── urls.py\n\t\t\t  │ ├── wsgi.gy\n\t\t\t  └─── manage.py\n\t\t\t```\n\t\n- 使用：以命令模式启动本地服务器为例，当然可以使用 Pycharm 一键运行。\n\t\n\t```bash\n\tpython manage.py runserver 127.0.0.1:8000\n\t```\n\t\n### 请求与响应\n#### 返回内容至页面\n返回内容 ( Html 元素或对象 ) 至页面，代码应包含在 `urls.py` 文件中。\n\n- 下述是返回字符串或 Html 元素的示例代码：\n\n\t```python\n\tfrom django.shortcuts import HttpResponse\n\t'''\n\targuments:\n\t\t@param request 放置用户请求相关的所有信息\n\t@return 响应与返回处理结果\n\t'''\n\tdef info(request):\n\t\t# 1. 可返回字符串\n\t\treturn HttpResponse(\"Hello World!\")\n\t\t# 2. 可返回 Html 元素 (对象)\n\t\t# return HttpResponse(\"<input type='text' />\")\n\t\t\n\t# 访问 Site 根目录\n\turlpatterns = [ url('', info), ]\t\n\t```\n\n#### 返回独立 Html 页面\t\n返回独立 Html 页面，且尝试把数据返回到页面中。\n\n- Html 页面放置 `tempates` 目录下；\n- `settings.py` 中配置模板的路径 ( 告诉程序网页模板在哪个目录下 )；\n\n\t```python\n\tTEMPLATES = [\n\t\t'DIRS': [os.path.join(BASE_DIR, 'templates')]\n\t]\n\t```\n\t\n- `urs.py` 中加入调用代码，绑定请求地址与处理函数；\n\n\t```python\n\tdef info(request):\n\t    # render 能抓取页面全部信息 ( 它也调用了 HttpResponse )\n\t    return render(request, 'info.html')\n\t```\n\t\n- 若要引用资源目录，如存放 images、css 等，则需要在 `settings.py` 中加入声明语句。\n\t\t\n\t引用资源时，需要加入 `static`。例如 `<link rel=\"stylesheet\" href=\"static/style.css\">`。\n\n\t```python\n\tSTATIC_URL = '/static/'\n\tSTATICFILES_DIRS = (\n\t    # '文件名' 是自由命名的，这里取 'static' 是为了统一命名\n\t    os.path.join(BASE_DIR, 'static'), \n\t)\n\t```\n\n### 简单登录功能\n\n> 本实例主要展示的是，在 Django 框架下 Web 前后端的交互过程。\n\n- 首先，我们在 `urls.py` 中配置路由关系，并绑定路由触发的函数以实现功能。\n\n\t```python\n\tfrom django.shortcuts import HttpResponse, render, redirect\n\tfrom django.urls import path\n\t\n\t# 首次加载页面调用的函数\n\tdef login(request):\n\t\t# GET 可通过请求的链接地址传参，如 url?page=1\n\t\tif ('GET' == request.method):\n\t\t\t## render() 是抓取页面全部信息 ( 它也调用了 HttpResponse )\n\t\t\treturn render(request, 'login.html')\n\t\t\t\t\t\n\t# 登录成功后把数据回传到目标页面\n\tdef index(request):\n\t\tuser = request.POST\n\t\treturn render(request, 'index.html', {\n\t\t\t'username': str(user.get('username')),\n\t\t\t'password': {\n\t\t\t\t'origin': user.get('password'),\n\t\t\t\t'encode': base64.b64encode( (user.get('password') + user.get('password')).encode('utf-8') )\n\t\t\t}}\n\t\t)\n    \n\t# path(相对地址, 调用函数)，如请求地址为根目录，故这里填写 '' \n\turlpatterns = [ \n\t    path('', login), \n\t    path('index', index), \n\t]\n\t```\n\t\n- 最后附上相关联的 `login.html` 和 `index.html`。\n\n\t```html\n\t<!-- login.html -->\n\t<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>Information Page</title>\n\t\t<link rel=\"stylesheet\" href=\"static/css/style.css\">\n\t</head>\n\t<body>\n\t\t<h2>Hello World!</h1>\n\t\t<h2>Welcome to use the exhibation page.</h2>\n\t\t<form method=\"POST\" action=\"index\">\n\t\t\t<input name=\"username\" type=\"text\" />\n\t\t\t<input name=\"password\" type=\"password\" />\n\t\t\t<input value=\"login\" type=\"submit\" />\n\t\t</form>\n\t</body>\n\t</html>\n\t\n\t<!-- index.html -->\n\t<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>Home Index</title>\n\t\t<link rel=\"stylesheet\" href=\"static/css/style.css\">\n\t</head>\n\t<body>\t\n\t\t<!-- 1. 模板中接受函数体返回的属性 -->\n\t\t<!-- {{}} 特殊占位符: Django render() 会自动解析它 -->\n\t\t<h2>username</h2> {{ username }}\n\t\t<h2>password</h2> {{ password.origin }} => {{ password.encode }}\n\t\n\t\t<p><!-- 换行 --></p>\n\t\n\t\t<!-- 2. 模板中调用对象的方法和属性，例如循环体 -->\n\t\t<table border=\"1\">\n\t\t\t<tr>\n\t\t\t\t<td>Username</td><td>{{ username }}</td>\n\t\t\t</tr>\n\t\t\t{% for key, value in password.items %}\n\t\t\t<tr>\n\t\t\t\t<td>Password:{{ key }}</td><td>{{ value }}</td>\n\t\t\t</tr>\n\t\t\t{% endfor %}\n\t\t</table>\n\t</body>\n\t</html>\n\t```\n\t\n### 增删改查系统\n\n> 本实例主要展示的是 Python 与数据库的交互过程。\n\n#### 建立数据表\n数据关系：这里以学生 ( Student )、任教老师 ( Teacher ) 和课程 ( Course ) 三个实体为例，构建数据表。\n\n- ER 图，如图 4-1 所示：\n\t- 学生可以选修多门课程，一门课程可以多个学生参与，即多对多关系。\n\t- 老师只能任教一门课程，但是一门课程有多个老师开课，即一对多关系。\n\n![django_1-1](/images/illustration/Programme/2019/02/django_1-1.jpg)\n<center>图 1-1 演示数据库的数据关系</center>\n\n- 关系模式：\n\t- 学生实体(学生序号, 学生姓名) == t_student(_sid_, name)\n\t- 课程实体(课程序号, 课堂名称) == t_course(_cid_, name)\n\t- 老师实体(老师序号, 老师姓名) == t_teacher(_tid_, name, cid)\n\t- 选课关系(学生序号, 课程序号, 成绩) == Student2Course(_sid_, _cid_, score)\n\n#### 前 / 后端交互原理\n- Web 程序的前后端交互原理如图 4-2 所示。\n\n![django_1-2](/images/illustration/Programme/2019/02/django_1-2.jpg)\n<center>图 1-2 Web 程序的前后端交互原理</center>\n\n#### 原生代码操作数据\n- Python 的 MySQL 驱动有 `MySQLdb`、`PyMySQL` 以及 `MySQLClient`。\n- 在 Python 2.7 版本，主要是用 MySQLdb，而 Python 3.x 版本多数使用 PyMySQL 以及 MySQLClient。两者操作风格类似，本文则以 PyMySQL 展开探讨。\n\n\t```python\n\t# 封装连接数据库的信息\n\tdb_infos = {\n\t\t'host': \"IP 地址\",\n\t\t'port': 3306,\n\t\t'user': \"数据库账户\",\n\t\t'password': \"数据库密码\",\n\t\t'db': \"数据库名称\",\n\t\t'charset': \"utf8\",\n\t\t'cursorclass': pymysql.cursors.DictCursor\n\t}\n\t\n\timport pymysql\n\tdb = pymysql.connect(db_infos)\n\t\n\tSQL = \"SELECT * FROM t_student\"\n\t\n\ttry:\n\t\twith db.cursor() as cursor:\n\t\t\tcursor.excute(SQL) # 执行 SQL 语句\n\t\t\tdb.commit() # 提交修改数据请求\n\texcept:\n\t\tdb.rollback() # 回滚\n\tfinally:\n\t\tdb.close() # 关闭数据库连接\n\t```\n\n#### Ajax 方式交互数据\n- 借助 Ajax，实现数据的本地刷新，而不需要重新加载、渲染网页。\n\n\t```js\n\t$.ajax({\n\t    url: '提交地址',\n\t    type: 'POST' // POST / GET\n\t    data: {'key_1': 'value_1', ..., 'key_n': 'value_n' }\n\t    success: function(data){\n\t        // 当前服务端处理数据，自动执行回调函数\n\t    }\n\t})\n\t```\n\n## 框架正文\n\n本章节的内容参考 [Django 官方文档 v2.1](https://docs.djangoproject.com/zh-hans/2.1/) 整理所得，即把模型、模板和视图的概念更加细化，通过一个投票应用的实例以讲述如何搭建一个 `MTV模式` 的 Web 框架，如图 3-1 所示。\n\n![django_2-1](/images/illustration/Programme/2019/02/django_2-1.jpg)\n<center>图 2-1 MTV 模式的 Web 框架</center>\n\n### 数据库配置\n- 编辑 `mysite/settings.py` 文件前，先设置 [TIME_ZONE](https://docs.djangoproject.com/zh-hans/2.1/ref/settings/#std:setting-TIME_ZONE) 为你自己时区，可参考 Wikipedia 的 [List of time zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)。\n\t\n\t> 新建立的项目，默认时区为 `UTC`。\n\n- 打开 `mysite/settings.py`，通常这个配置文件使用 SQLite 作为默认数据库。\n\t- `ENGINE`：选值 `django.db.backends.sqlite3`。\n\t- `NAME`：数据库的名称。若使用 [SQLite](https://baike.baidu.com/item/SQLite/375020?fr=aladdin)，数据库将是你电脑上的一个文件，NAME 应该是此文件的绝对路径 + 文件名，默认值 `os.path.join(BASE_DIR, 'db.sqlite3')` 将会把数据库文件储存在项目的根目录。\n\n\t\t```python\n\t\tDATABASES = {\n\t\t    'default': {\n\t\t        'ENGINE': 'django.db.backends.sqlite3',\n\t\t        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),\n\t\t    }\n\t\t}\n\t\t```\n\n\t- 若使用了 SQLite 以外的数据库，请确认在使用前已经 `创建了数据库`。连接到其他数据库时 ( MySQL，Oracle 或 PostgreSQL )，参考 [ENGINE](https://docs.djangoproject.com/zh-hans/2.1/ref/settings/#std:setting-DATABASE-ENGINE) 的设置来连接其他数据库。例如连接 MySQL 的配置如下所示：\n\n\t\t```python\n\t\tDATABASES = {\n\t\t    'default': {\n\t\t        'ENGINE': 'django.db.backends.mysql',\n\t\t        'NAME': 'mydatabase',\n\t\t        'USER': 'mydatabaseuser',\n\t\t        'PASSWORD': 'mypassword',\n\t\t        'HOST': '127.0.0.1',\n\t\t        'PORT': '3306',\n\t\t    }\n\t\t}\n\t\t```\n\n- 此外，关注一下文件头部的 `INSTALLED_APPS` 设置项。这里包括了项目中启用的所有 Django 应用。应用能在多个项目中使用，也可以打包并且发布应用，让别人使用它们。通常 INSTALLED_APPS 默认包括了以下 Django 的自带应用：\n\n\t```python\n\tINSTALLED_APPS = [\n\t    # 因为 ApplicationConfig 类写在文件 polls/apps.py 中，\n\t    # 所以它的点式路径是 'polls.apps.ApplicationConfig'\n\t    'polls.apps.ApplicationConfig',\t# 激活模型\n\t    'django.contrib.admin',\t\t# 管理员站点\n\t    'django.contrib.auth',\t\t# 认证授权系统\n\t    'django.contrib.contenttypes',\t# 内容类型框架\n\t    'django.contrib.sessions',\t\t# 会话框架\n\t    'django.contrib.messages',\t\t# 消息框架\n\t    'django.contrib.staticfiles',\t# 管理静态文件的框架\n\t]\n\t```\n\t\n- 默认开启的某些应用需要至少一个数据表，故在使用他们前需要在数据库中创建一些表。请执行命令：\n\n\t```shell\n\t# MacOS / Linux\n\tpython manage.py migrate\n\t\n\t# Windows ( 下述代码同理，基本上 \"py\" 对应于 \"python\" )\n\tpy manage.py migrate\n\t```\n\n### 模型和站点管理\n\n#### 创建模型\n- 定义模型 ( Model )，即数据库结构设计和附加的其它元数据。在 Django 中，你只需要定义数据模型，其中的实现代码不用理会，它们会自动从模型生成。\n\n\t> 模型是真实数据的简单明确的描述，它包含了储存的数据所必要的字段和行为。\n\n- 例如，在本案例中 ( 投票应用 )，需要创建两个模型：问题 Question 和选项 Choice。\n\t- Question 模型：包括问题描述和发布时间。\n\t- Choice 模型：包括选项描述和当前得票数。每个选项属于一个问题 ( 一对一关系 )。\n\n- 这些概念可通过 Python 类来描述。按照下面的例子来编辑 `polls/models.py` 文件：\n\t- 每个模型被表示为 `django.db.models.Model` 类的子类。每个模型有一些类变量，它们都表示模型里的一个数据库字段。\n\t- 每个字段都是 `Field` 类的实例，这将告诉 Django 每个字段要处理的数据类型。比如，字符字段被表示为 `CharField`，日期时间字段被表示为 `DateTimeField`。\n\t- 定义某些 Field 类实例需要参数，例如 CharField 需要一个 max_length 参数。\n\t\t\n\t\t> 这个参数的用处不止于用来定义数据库结构，也用于验证数据。\n\n\t- Django 支持所有常用的数据库关系：一对一、一对多和多对多，我们使用外键 `ForeignKey` 定义了一个关系。例如，每个 Choice 对象都关联到一个 Question 对象。\n\t- 数据表最重要的 `主键` 会被自动创建，当然也可以自定义。\n\n\t\t```python\n\t\tfrom django.db import models\n\t\t\n\t\tclass Question(models.Model):\n\t\t    question_text = models.CharField(max_ length=200)\n\t\t    pub_date = models.DateTimeField('date published')\n\t\t    \n\t\t    # Question.objects.all() 返回信息对我们用处不大，如下所示：\n\t\t    # <QuerySet [<Question: Question object (1)>]>\n\t\t    # 可尝试通过 __str__() 方法返回一些字段信息\n\t\t    def __str__(self):\n\t\t    \treturn self.question_text\n\t\t\n\t\tclass Choice(models.Model):\n\t\t    question = models.ForeignKey(Question, on_delete=models.CASCADE)\n\t\t    choice_text = models.CharField(max_length=200)\n\t\t    votes = models.IntegerField(default=0)\n\t\t    def __str__(self):\n\t\t    \treturn self.choice_text\n\t\t```\n\n#### 激活模型\n-  从上述用于创建模型的代码可知，Django 可实现：\n\t- 为这个应用创建数据库 `schema` ( 生成 CREATE TABLE 语句 )。\n\t- 创建与 Question 和 Choice 对象与数据库进行交互的 `API` ( Python 版本 )。\n\n- 但是首先得把 polls 应用安装到我们的项目里。具体地， 在文件 `mysite/settings.py` 中 `INSTALLED_APPS` 子项添加点式路径：\n\n\t```python\n\tINSTALLED_APPS = [\n\t    # 因为 ApplicationConfig 类写在文件 polls/apps.py 中，\n\t    # 所以它的点式路径是 'polls.apps.ApplicationConfig'\n\t    'polls.apps.ApplicationConfig',\t# 激活模型\n\t    'django.contrib.admin',\t\t\t# 管理员站点\n\t    'django.contrib.auth',\t\t\t# 认证授权系统\n\t    'django.contrib.contenttypes',\t# 内容类型框架\n\t    'django.contrib.sessions',\t\t# 会话框架\n\t    'django.contrib.messages',\t\t# 消息框架\n\t    'django.contrib.staticfiles',\t# 管理静态文件的框架\n\t]\n\t```\n- 现在你的 Django 项目会包含 polls 应用。接着通过运行 `makemigrations` 命令，Django 会检测你对模型文件的修改 ( 在这种情况下刚创建的可理解为最新修改的  )，并且把修改的部分储存为一次 `迁移`。\n\n\t> 迁移：Django 对于模型定义，也就是你的数据库结构的变化的储存形式。它们其实也只是一些你磁盘上的文件。\n\n\t```shell\n\tpython manage.py makemigrations polls\n\t```\n\t\n- Django 有一个自动执行 `数据库迁移` 并同步管理你的数据库结构的命令：\n\n\t```shell\n\tpython manage.py migrate\n\t```\n\t\n- 当然，你是否会好奇，迁移是怎样的过程，迁移命令会执行哪些 SQL 语句？那么，`sqlmigrate` 命令接收一个迁移的名称，然后返回对应的 SQL。\n\t\n\t```shell\n\t# sqlmigrate 命令\n\t# 并没有真正在数据库中的执行迁移，它只是把命令输出到屏幕上\n\tpython manage.py sqlmigrate polls 0001\n\t```\n\t\n- 输入以上命令，你将看到如下结果 ( 格式化输出 SQL )：\n\t\n\t```SQL\n\t-- 输出示例使用的是 PostgreSQL / MySQL --\n\tBEGIN;\n\t-- Create model Choice\n\tCREATE TABLE \"polls_choice\" (\n\t    \"id\" serial NOT NULL PRIMARY KEY,\n\t    \"choice_text\" varchar(200) NOT NULL,\n\t    \"votes\" integer NOT NULL\n\t);\n\t-- Create model Question\n\tCREATE TABLE \"polls_question\" (\n\t    \"id\" serial NOT NULL PRIMARY KEY,\n\t    \"question_text\" varchar(200) NOT NULL,\n\t    \"pub_date\" timestamp with time zone NOT NULL\n\t);\n\t-- 省略剩余语句，具体可自行测试 --\n\tCOMMIT;\n\t```\n\n- 从格式化的 SQL 语句可注意到：\n\n\t- 数据库的表名是由应用名 ( polls ) 和模型名的小写形式 ( question 和 choice ) 连接而来。\n\n\t- 主键 ( id ) 会被自动创建，当然你也可以自定义。\n\n\t- 默认 Django 会在外键字段名后追加字符串 \"_id\" ，同样也可以自定义。\n\n\t- 生成的 SQL 语句是为你所用的数据库定制的，所以那些和数据库有关的字段类型，比如 auto_increment ( MySQL )、 serial ( PostgreSQL ) 和 integer primary key autoincrement ( SQLite )，Django 会帮你自动处理。那些和引号相关的事情，比如使用单引号还是双引号，也一样会被自动处理。\n\n- 总结：迁移是非常强大的功能，它能让你在开发过程中持续的改变数据库结构而不需要重新删除和创建表，即它专注于使数据库平滑升级而不会丢失数据。**现在改变模型只需要记住这三步**：\n\n\t- 编辑 `models.py` 文件，改变模型。\n\n\t- 运行 `python manage.py makemigrations` 为模型的改变 `生成` 迁移文件。\n\n\t- 运行 `python manage.py migrate` 来 `应用` 数据库迁移。\n\n#### 数据操作\n- 当完成 `创建模型` ( 定义数据实体和数据关系 ) 与 `激活模型` ( 模型驱动自动生成 SQL 代码 ) 的工作，即表明数据表已建立起来，紧接着便可操作数据库了。\n- 关于操作数据库的 Python API 所有细节可在 [Database API For Python](https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/) 参考文档中找到。\n\n##### 创建对象\n- 假设模型存在于文件中 mysite/polls/models.py：\n\n\t```python\n\tfrom polls.models import Choice, Question\n\t# 使用模型类的关键字参数对其实例化，再调用 save() 以将其保存到数据库中\n\tq = Question(question_text=\"What's new?\", pub_date=timezone.now())\n\t# 创建和保存对象则使用 create() 方法\n\tq.save()\n\t```\n\t\n##### 更新对象\n- UPDATE 在幕后执行 SQL 语句：\n\n\t```python\n\t# 保存对象的更改\n\tq.question = \"What do you think about?\"\n\tq.save()\n\t```\n\t\n- 保存 ForeignKey 字段：更新 ForeignKey 字段的工作方式与保存普通字段的方式完全相同，只需将正确类型的对象分配给相关字段即可。\n\n\t```python\n\t# 一般情况 pk ( Primary Key ) 和 id 是一样的，只有 id 不是主键时才不一样\n\tchoice = Choice.objects.get(pk=1)\n\tquestion = Question.objects.get('What do you think about?')\n\tchoice.question = question\n\tchoice.save()\n\t```\n\t\n-  更新ManyToManyField 工作的方式略有不同 ：使用 add() 字段上的方法向关系添加记录。\n\n##### 检索对象\n- 使用 all() 返回所有对象：例如，返回 Question 数据库中所有对象。\n\n\t```python\n\tall_question = Question.objects.all()\n\t```\n\n- `使用过滤器检索特定对象`：若我们仅需要选择整个对象集的子集，则需要向 QuerySet 添加过滤条件。两种最常见的改进方法：\n\t- `filter(**kwargs)`：返回 QuerySet 包含与给定查找参数匹配的新对象。\n\t- `exclude(**kwargs)`：返回 QuerySet 包含与给定查找参数不匹配的新对象。\n\t\t\n\t\t```python\n\t\t# 例如：获取 2018 年间所有问题记录\n\t\tQuestion.objects.filter(pub_date__year=2017)\n\t\t```\n\t\n- `链接过滤器`：QuerySet 检索结果本身也是 QuerySet 对象，故可使用多个过滤器。作用与 `多条件查询` 类似效果。\n\n\t```python\n\t# 例如：获取以“What”开头，在 2018 年 1 月 1 日至当天前的所有记录\n\tQuestion.objects.filter(\n\t\theadline__startswith='What'\n\t).exclude(\n\t\tpub_date__gte=datetime.date.today()\n\t).filter(\n\t\tpub_date__gte=datetime.date(2018, 1, 1)\n\t)\n\t```\n\t\n- 使用 get() 检索单个对象：\n\n\t```python\n\tone_question = Question.objects.get(pk=1)\n\t# Question 没有主键为 1 的对象，Django 将引发异常 Entry.DoesNotExist。\n\t```\n\t\n- 限制 QuerySet 返回集合的大小：使用 Python 的数组切片语法将限制 QuerySet 为一定数量的结果。这相当于 SQL 中 `LIMIT` 和 `OFFSET` 子句。\n\n\t- 注意 1：`Entry.objects.all()[-1]` 不支持负索引。\n\t- 注意 2：`Entry.objects.all()[:10:2]` 不支持使用步进 ( Step ) 取值。\n\n\t\t```python\n\t\t# 例如：返回前5个对象（）：LIMIT 5\n\t\tQuestion.objects.all()[:5]\n\t\t# 例如：返回第6到第10个对象：OFFSET 5 LIMIT 5\n\t\tQuestion.objects.all()[5:10]\n\t\t```\n\n#### 站点管理\n\n##### 开篇引言\n- 相信你也有过同样的经历，例如为你的员工或客户生成一个用户添加、修改和删除内容的管理后台，即简单的增删改查操作 ( CRUD ) ，但它却是一项缺乏创造性和乏味的工作。因此，Django 全自动地根据模型创建界面化的管理后台。\n- 管理界面不是为了网站的访问者，而是为管理者准备的。需要客制化的后台管理界面还需自行实现。\n\n##### 创建管理员账号\n- 首先，我们得创建一个能登录管理页面的用户。请运行下面的命令：\n\n\t```bash\n\tpython manage.py createsuperuser\n\t# Username: kofe\n\t# Email address: kofe@example.com\n\t# Password: **********\n\t# Password (again): *********\n\t# Superuser created successfully.\n\t```\n\n##### 启动开发服务器\n- Django 的管理界面默认就是启用的。让我们启动开发服务器。当然，你可以通过 PyCharm 启动服务器，也可以通过命令启动：\n\n\t```bash\n\tpython manage.py runserver\n\t```\n\n- 打开浏览器即可访问：`http://127.0.0.1:8000/admin/`\n\n##### 管理页添加应用\n- 在索引页面中，我们并没有看到应用，如本例中的投票应用 `polls`。所以我们得告诉管理页面，问题 `Question` 对象需要被管理。打开 `polls/admin.py` 文件，把它编辑成下面这样：\n\n\t```python\n\tfrom django.contrib import admin\n\tfrom .models import Question\n\tadmin.site.register(Question)\n\t```\n\t\n### 模板和视图\n#### 开篇引言\n- 每个视图必须要做的只有两件事：返回一个包含被请求页面内容的 `HttpResponse` 对象或者抛出一个 `异常`，比如 HTTP 404。\n\n\t> Django 只要求返回的是一个 HttpResponse ，或抛出一个异常。\n\n- 视图可以从数据库里读取记录，可使用一个模板引擎 ( Django 自带或者其他第三方的 )，生成一个 PDF 文件、输出一个 XML、创建一个 ZIP 文件等，你可以使用任何你想用的 Python 库，实现你想做的事。\n- Django 自带的 [Database API](https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/) 很方便，与试图结合使用即可实现数据的基本交互操作。\n\n\t```python\n\t# 在 index() 函数里插入了一些新内容\n\t# 让它能展示数据库里以发布日期排序的最近5个投票问题\n\tfrom django.http import HttpResponse\n\tfrom .models import Question\n\tdef index(request):\n\t\tlatest_question_list = Question.objects.order_by('-pub_date')[0:5]\n\t\toutput = ', '.join([q.question_text for q in latest_question_list])\n\t\treturn HttpResponse(output)\n\t```\n\t\n#### 模板系统\n- 这里有个问题：页面的设计写死在视图函数的代码里的。如果你想改变页面的样子，你需要编辑 Python 代码。我们是否能将此过程相互分离，即 `视图负责处理、组装数据`；`模板则负责样式`。\n\t- 首先，在你的项目根目录里创建一个 `templates` 目录。Django 将会在这个目录里查找模板文件。\n\t- 在 `templates` 目录里，再创建一个目录 `polls`，然后在其中新建一个文件 `index.html`。\n\t- 换句话说，你的模板文件的路径应该是 `mysite/templates/polls/index.html`。因为 Django 会寻找到对应的 `app_directories`，所以你只需要使用 `polls/index.html` 就可引用到这一模板了。\n\n\t\t> `模板命名空间`：虽然可将模板文件直接放在 mysite/templates 目录下，但若有一个模板文件正好和另一个应用中的某个模板文件重名，则 Django 没有办法区分它们，从而选择第一个匹配的模板文件，造成不能准确匹配的状况。\n\t\t\n\t\t> 帮助 Django 正确选择模板，最简单的方法是把他们放入各自的 `命名空间` 中，即把这些模板放入一个和 `自身应用重名` 的子文件夹里，如本例中的 `polls`。\n\n#### 小试牛刀\n- 我们将下面的代码输入到刚刚创建的模板文件中：\n\n\t```html\n\t<!-- mysite/templates/polls/index.html -->\n\t{% if latest_question_list %}\n\t\t<ul>\n\t\t{% for question in latest_question_list %}\n\t\t\t<li><a href=\"/polls/{{ question.id }}/\">\n\t\t\t\t{{ question.question_text }}\n\t\t\t</a></li>\n\t\t{% endfor %}\n\t\t</ul>\n\t{% else %}\n\t\t<p>No polls are available.</p>\n\t{% endif %}\n\t```\n\t\n- 然后，让我们更新一下 polls/views.py 里的 index 视图来使用模板：\n\n\t```python\n\tfrom django.http import HttpResponse\n\tfrom django.template import loader\n\tfrom .models import Question\n\t\n\tdef index(request):\n\t\tlatest_question_list = Question.objects.order_by('-pub_date')[:5]\n\t\ttemplate = loader.get_template('polls/index.html')\n\t\tcontext = {\n\t\t\t'latest_question_list': latest_question_list,\n\t\t}\n\t\treturn HttpResponse(template.render(context, request))\n\t```\n\t\n- 载入模板，填充上下文，再返回由它生成的 HttpResponse 对象，这里引入一个便捷函数 render() 函数。它已经把此过程封装一起，调用即可使用。\n\n\trender() 函数的第一个参数是 request 对象，第二个参数是模板名，第三个参数是字典。它返回给定上下文呈现的给定模板的 HttpResponse 对象。\n\t\n\t```python\n\tdef index(request):\n\t\tlatest_question_list = Question.objects.order_by('-pub_date')[:5]\n\t\tcontext = {'latest_question_list': latest_question_list}\n\t\treturn render(request, 'polls/index.html', context)\n\t```\n\t\n- 用你的浏览器访问 `http://127.0.0.1:8000/polls/`，你将会看见一个无序列表。\n\n#### 使用模板系统\n\n> 使用模板系统的过程，更像是前端与后端信息交互的过程，即前端访问请求地址获取数据的过程。\n\n- 模板系统统一使用 `点符号` 来访问变量的属性。在示例 {% raw %}{{ question.question_text }}{% endraw %} 中，首先 Django 尝试对 question 对象使用字典查找 ( 也就是使用 obj.get(str) 操作 )，如果失败了就尝试属性查找 ( 也就是 obj.str 操作 )，结果是成功了。如果这一操作也失败的话，将会尝试列表查找 ( 也就是 obj[int] 操作 )。\n- 在{% raw %}{% for %}{% endraw %}循环中发生的函数调用：question.choice_set.all 被解释为 Python 代码 question.choice_set.all()，将会返回一个可迭代的 Choice 对象，这一对象可以在 {% raw %}{% for %}{% endraw %} 标签内部使用。\n- 查看 [模板指南](https://docs.djangoproject.com/zh-hans/2.1/topics/templates/) 可以了解关于模板的更多信息。\n\n#### 去除模板中的硬编码 URL\n- 硬编码：硬编码和强耦合的链接，对于一个包含很多应用的项目来说，修改起来是十分困难的。\n\n\t```html\n\t<li><a href=\"/polls/{{ question.id }}/\">\n\t\t{{ question.question_text }}\n\t</a></li>\n\t```\n\n- 软编码：然而，因为你在 polls.urls 的 url() 函数中通过 name 参数为 URL 定义了名字，你可以使用 {% raw %}{% url %}{% endraw %} 标签代替它。\n\n\t```html\n\t<!--\n\t | 具有名字 'detail' 的 URL 在 polls/url.py 中定义为：\n\t | path('<int:question_id>/', views.detail, name='detail')\n\t-->\t\n\t<li><a href=\"{% url 'detail' question.id %}\">\n\t\t{{ question.question_text }}\n\t</a></li>\n\t\n\t<!-- \n\t | 若你想改变投票详情视图的 URL，比如 polls/specifics/12/\n\t | 不用在模板里修改任何东西 (包括模板)，只在 polls/urls.py 稍微修改就行\n\t | path('specifics/<int:question_id>/', views.detail, name='detail')\n\t-->\n\t```\n\n#### 为 URL 名称添加命名空间\n- 在一个真实的 Django 项目中，可能会有多个应用，Django 如何分辨重名的 URL 呢？具体情况则是，{% raw %}{% url %}{% endraw %} 标签到底对应哪一个应用的 URL 呢？\n- 在根 `URLconf` 中添加命名空间。在 polls/urls.py 文件中稍作修改，加上 `app_name` 设置命名空间：\n\n\t```python\n\tfrom django.urls import path\n\tfrom . import views\n\tapp_name = 'polls'\n\turlpatterns = [\n\t\tpath('', views.index, name='index'),\n\t\tpath('<int:question_id>/', views.detail, name='detail'),\n\t\tpath('<int:question_id>/results/', views.results, name='results'),\n\t\tpath('<int:question_id>/vote/', views.vote, name='vote'),\n\t]\n\t```\n\t\n- 修改为指向具有命名空间的详细视图：\n\n\t```html\n\t<li><a href=\"{% url 'polls:detail' question.id %}\">\n\t\t{{ question.question_text }}\n\t</a></li>\n\t```\n\n### 表单和通用视图\n#### 表单\n\n> 在此小节中，通过表单接收数据，再通过 Django 视图来处理提交的数据。此过程，更像是前端打包数据通过 GET/POST 请求，把数据传送到后端，交由后端视图处理数据。\n\n- 编写一个简单的表单：让我们更新一下在上一个教程中编写的投票详细页面的模板  `polls/detail.html`，让它包含一个 HTML `<form>` 元素：\n\n\t```html\n\t<!-- mystie/templates/polls/detail.html -->\n\t<h1>{{ question.question_text }}</h1>\n\t{% if error_message %}\n\t\t<p><strong>{{ error_message }}</strong></p>\n\t{% endif %}\n\t<form action=\"{% url 'polls:vote' question.id %}\" method=\"post\">\n\t<!--\n\t | 跨站点请求伪造保护：\n\t | 在 Django 中，所有针对内部 URL 的 POST 表单，\n\t | 都应该使用  {% csrf_token %} 模板标签。\n\t-->\n\t{% csrf_token %}\n\t{% for choice in question.choice_set.all %}\n\t\t<input type=\"radio\" name=\"choice\" id=\"choice{{ forloop.counter }}\" value=\"{{ choice.id }}\">\n\t\t<!-- 指示 for 标签已经循环多少次 -->\n\t\t<label for=\"choice{{ forloop.counter }}\">{{ choice.choice_text }}</label><br>\n\t{% endfor %}\n\t<input type=\"submit\" value=\"Vote\">\n\t</form>\n\t```\n\n\t> [跨站点请求伪造保护](https://docs.djangoproject.com/zh-hans/2.1/ref/csrf/)：当恶意网站包含链接，表单按钮或某些旨在在您的网站上执行某些操作的JavaScript时，会发生此类攻击，使用登录用户访问其浏览器中的恶意网站的凭据。一种相关类型的攻击，“登录CSRF”，攻击网站欺骗用户的浏览器以其他人的凭据登录网站也受到保护。\n\t\n- 我们为投票应用创建了一个 URLconf ，即新增一行 `path()`：\n\n\t```python\n\t# polls/urls.py\n\tpath('<int:question_id>/vote/', views.vote, name='vote')\n\t```\n\t\n- 创建一个 `vote()` 函数，来处理相关的数据请求：\n\n\t```python\n\t# polls/views.py\n\tfrom django.http import HttpResponse, HttpResponseRedirect\n\tfrom django.shortcuts import get_object_or_404, render\n\tfrom django.urls import reverse\n\tfrom .models import Choice, Question\n\t\n\tdef vote(request, question_id):\n\t\tquestion = get_object_or_404(Question, pk=question_id)\n\t\ttry:\n\t\t\tselected_choice = question.choice_set.get(pk=request.POST['choice'])\n\t\texcept (KeyError, Choice.DoesNotExist):\n\t\t\t# Redisplay the question voting form.\n\t\t\treturn render(request, 'polls/detail.html', {\n\t\t\t\t'question': question,\n\t\t\t\t'error_message': \"You didn't select a choice.\",\n\t\t\t})\n\t\telse:\n\t\t\tselected_choice.votes += 1\n\t\t\tselected_choice.save()\n\t\t\t# Always return an HttpResponseRedirect after successfully dealing\n\t\t\t# with POST data. This prevents data from being posted twice if a\n\t\t\t# user hits the Back button.\n\t\t\treturn HttpResponseRedirect(reverse('polls:results', args=(question.id,)))\n\t```\n\n\t- 代码返回一个 HttpResponseRedirect 而不是常用的 HttpResponse；\n\t- HttpResponseRedirect 只接收一个参数：用户将要被重定向的 URL；\n\t- 在 HttpResponseRedirect 的构造函数中使用 reverse() 函数。这个函数避免了我们在视图函数中硬编码 URL。\n\n\t\t> reverse() 调用将返回一个这样的字符串 `/polls/3/results/`。\n\t\t> 其中 3 是 question.id 的值。重定向的 URL 将调用 'results' 视图来显示最终的页面。\n\t\n- 当对 Question 进行投票后，vote() 视图将请求重定向到 Question 的结果界面。让我们来编写这个视图 ( 这和上一章节中的 detail() 视图几乎一模一样，唯一的不同是模板的名字。 我们将在稍后解决这个冗余问题 )：\n\n\t```python\n\t# polls/views.py\n\tfrom django.shortcuts import get_object_or_404, render\n\t\n\tdef results(request, question_id):\n\t\tquestion = get_object_or_404(Question, pk=question_id)\n\t\treturn render(request, 'polls/results.html', {'question': question})\n\t```\n\t\n- 再创建一个 `polls/results.html` 模板：\n\n\t```html\n\t<!-- polls/templates/polls/results.html -->\n\t<h1>{{ question.question_text }}</h1>\n\t\n\t<ul>\n\t{% for choice in question.choice_set.all %}<li>\n\t\t{{ choice.choice_text }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}\n\t</li>{% endfor %}\n\t</ul>\n\t\n\t<a href=\"{% url 'polls:detail' question.id %}\">Vote again?</a>\n\t```\n\n#### 通用视图\n\n> 猜想：通用视图是否是通用模板的思想，即使用统一的界面展示数据？\n\n- detail() 和 results() 视图都很简单。并且，像上面提到的那样，存在冗余问题。\n- 这些视图反映基本的 Web 开发中的一个常见情况：根据 URL 中的参数从数据库中获取数据、载入模板文件然后返回渲染后的模板。 由于这种情况特别常见，Django 提供一种快捷方式，叫做“通用视图”系统。\n- 通用视图将常见的模式抽象化，可以使你在编写应用时甚至不需要编写 Python 代码。\n\n\t> 一般来说，当编写一个 Django 应用时，你应该先评估一下通用视图是否可以解决你的问题，你应该在一开始使用它，而不是进行到一半时重构代码。\n\n- 让我们将我们的投票应用转换成使用通用视图系统，这样我们可以删除许多我们的代码。我们仅仅需要做以下几步来完成转换，我们将：\n\t- 转换 URLconf。\n\t- 删除一些旧的、不再需要的视图。\n\t- 基于 Django 的通用视图引入新的视图。\n\n##### 改良 URLconf\n- 首先，打开 polls/urls.py 这个 URLconf 并将它修改成：\n\n\t```python\n\tfrom django.urls import path\n\tfrom . import views\n\t\n\tapp_name = 'polls'\n\turlpatterns = [\n\t\tpath('', views.IndexView.as_view(), name='index'),\n\t\t# 路径字符串中匹配模式的名称已经由 <question_id> 改为 <pk>\n\t\tpath('<int:pk>/', views.DetailView.as_view(), name='detail'),\n\t\tpath('<int:pk>/results/', views.ResultsView.as_view(), name='results'),\n\t\tpath('<int:question_id>/vote/', views.vote, name='vote'),\n\t]\n\t```\n\n##### 改良视图\n- 下一步，我们将删除旧的 index, detail, 和 results 视图，并用 Django 的通用视图代替。打开 polls/views.py 文件，并将它修改成：\n\n\t```python\n\tfrom django.http import HttpResponseRedirect\n\tfrom django.shortcuts import get_object_or_404, render\n\tfrom django.urls import reverse\n\tfrom django.views import generic\n\tfrom .models import Choice, Question\n\n\tclass IndexView(generic.ListView):\n\t\ttemplate_name = 'polls/index.html'\n\t\tcontext_object_name = 'latest_question_list'\n\n\t\tdef get_queryset(self):\n        \t\t# Return the last five published questions.\n        \t\treturn Question.objects.order_by('-pub_date')[:5]\n\n\tclass DetailView(generic.DetailView):\n\t\tmodel = Question\n\t\ttemplate_name = 'polls/detail.html'\n\n\tclass ResultsView(generic.DetailView):\n\t\tmodel = Question\n\t\ttemplate_name = 'polls/results.html'\n\n\t\tdef vote(request, question_id):\n\t\t\t# Same as above, no changes needed.\n\t```\n\n- 上述代码详细解释：\t\t\n\t- 默认情况下，通用视图 DetailView 使用一个叫做 `<app name>/<model name>_detail.html` 的模板。在我们的例子中，它将使用 `polls/question_detail.html` 模板。\n\t- `template_name` 属性是用来告诉 Django 使用一个指定的模板名字，而不是自动生成的默认名字。 \n\t- 我们也为 results 列表视图和 detail 视图指定了 template_name。即使它们在后台都是同一个 DetailView，results 视图和 detail 视图在渲染时具有不同的访问名称。\n\t- 类似地，ListView 使用一个叫做 `<app name>/<model name>_list.html` 的默认模板；我们使用 template_name 来告诉 ListView 使用我们创建的已经存在的 `polls/index.html` 模板。\n\t- 在之前的教程中，提供模板文件时都带有一个包含 question 和 latest_question_list 变量的 context。\n\t\t- 对于 DetailView ， question 变量会自动提供—— 因为我们使用 Django 的模型 (Question)， Django 能够为 context 变量决定一个合适的名字。\n\t\t- 对于 ListView， 自动生成的 context 变量是 question_list。为了覆盖这个行为，我们提供 `context_object_name` 属性，表示我们想使用 `latest_question_list`。\n\n### 自动化测试\n#### 为什么你需要写测试\n- `测试将节约你的时间`：在复杂的应用程序中，组件之间可能会有数十个复杂的交互。改变其中某一组件的行为，也有可能会造成意想不到的结果。判断「代码是否正常工作」意味着你需要用大量的数据来完整的测试全部代码的功能，以确保你的小修改没有对应用整体造成破坏，可想而知其中的工作量。\n- `测试不仅能发现错误且能预防错误`：测试是开发的对立面，这种思想是不对的，开发其实更像是一个不断试错的过程。\n\n#### 开始写一个测试程序\n- 约定俗称，Django 应用的测试应该写在应用的 `tests.py` 文件里，测试系统会自动的在所有以 tests 开头的文件里寻找并执行测试代码。\n- 制造一个 BUG：继续上述提及的应用 Polls，要求 Question 是在一天之内发布， 则 Question.was_published_recently() 方法将会返回 True 。然而现在这个方法在 Question 的 pub_date 字段比当前时间还晚 ( 未来的时间 ) 时也会返回 True。\n\n\t```python\n\timport datetime\n\tfrom django.utils import timezone\n\tfrom polls.models import Question\n\t# create a Question instance with pub_date 30 days in the future\n\ttime = timezone.now() + datetime.timedelta(days=30)\n\tfuture_question = Question(pub_date=time)\n\t# was it published recently? ==> True\n\tfuture_question.was_published_recently()\n\t```\n\n- 创造一个测试用例：创建一个 `django.test.TestCase` 的子类。\n\n\t```python\n\timport datetime\n\tfrom django.utils import timezone\n\tfrom .models import Question\n\tfrom django.test import TestCase\n\t\n\tclass QuestionModelTests(TestCase):\n\t    def test_was_published_recently_with_future_question(self):\n\t        \"\"\"\n\t        was_published_recently() returns False \n\t        for questions whose pub_date is in the future.\n\t        \"\"\"\n\t        time = timezone.now() + datetime.timedelta(days=30)\n\t        future_question = Question(pub_date=time)\n\t        self.assertIs(future_question.was_published_recently(), False)\n\t```\n- 最后，我们可通过 PyCharm 单独运行测试用例，也可以通过终端命令运行自动化测试。\n\n\t```bash\n\tpython manage.py test polls\n\t```\n\n- 发生了什么呢？以下是自动化测试的运行过程：\n\t- `python manage.py test polls` 将会寻找 Polls 应用里的测试代码，它找到了 django.test.TestCase 的一个子类，并创建一个特殊的数据库供测试使用；\n\t- 在类中寻找测试方法 ( 以 test 开头的 )，在 `test_was_published_recently_with_future_question` 方法中，它创建了一个 pub_date 值为 30 天后的 Question 实例。\n\t- 接着使用 `assertls()` 方法，发现 `was_published_recently()` 返回了 True，而我们期望它返回 False。\n\n## 参考资料\n- [1] [廖雪峰. Python 教程之 virtualenv. 2017. liaoxuefeng.com](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432712108300322c61f256c74803b43bfd65c6f8d0d0000)\n- [2] [地球的外星人君. Python Web 框架大乱斗：哪个框架适合你. 2017. zhihu.com](https://zhuanlan.zhihu.com/p/31447222)\n- [3] [知乎问答. Python 有哪些好的 Web 框架. zhihu.com](https://www.zhihu.com/question/20706333)","tags":["python","web","django"],"categories":["Project"]},{"title":"FastDFS：文件系统从入门到应用","url":"/2019/02/FastDFS.html","content":"\n余庆老师在他的 Github 上介绍关于 [FastDFS](https://github.com/happyfish100/fastdfs) 开源项目的描述：FastDFS 是一个开源的高性能分布式文件系统 ( DFS )。 它的主要功能包括文件存储，文件同步和文件访问，以及高容量和负载平衡。\n\n<!-- More -->\n\n## FastDFS 简单介绍\n### FastDFS 核心组件\n- `Tracker Server`：跟踪服务器，负责维持集群的信息；负责管理所有的 Storage Server 和 Group，每个 Storage 在启动后会连接 Tracker，告知自己所属 group 等信息，并保持周期性心跳。\n- `Storage server`：存储服务器，以 Group 为单位进行组织，任何一个 Storage Server 都应该属于某个 Group；一个 Group 可含多个 Storage server；在同一个 Group 内部，各 Storage Server 的数据自行同步、备份。\n- `Client`：客户端，上传、下载数据的服务器，也就是我们自己的项目所部署在的服务器。\n\n\t>核心组件的介绍参考了 [1]、[2] 的概念叙述。\n\n### FastDFS 组织架构\n- 结合组件的功能描述可知，FastDFS 的组织架构 $^{[2]}$ 如图 1-1 所示。\n\n\t![fastdfs_1-1](/images/illustration/Project/2019/02/fastdfs_1-1.jpg)\n\t<center>图 1-1 FastDFS 的组织架构</center>\n\n### FastDFS 文件传输\n- 通过时序图，分析 FastDFS 文件上传、文件下载等操作的流程，如图 1-2 所示。\n\n\t![fastdfs_1-2](/images/illustration/Project/2019/02/fastdfs_1-2.jpg)\n\t<center>图 1-2 FastDFS 文件上传、下载的时序图</center>\n\t\n- 文件上传流程：\n\t- 1) Client 询问 Tracker，发送上传文件的请求；\n\t- 2) Tracker 返回可调用的 `Storage ID: Port`；\n\t- 3) Client 直接与目标 Storage 通讯，完成文件上传；\n\t- 4) Storage 返回 `文件ID`，文件ID 为 `Group ID + FileName`。\n- 文件下载流程：\n\t- 1) Client 询问 Tracker  下载文件所在的 Storage ( 参数为 `文件ID` )；\n\t- 2) Tracker 返回可调用的 `Storage ID: Port`；\n\t- 3) Client 直接与目标 Storage 通讯，完成文件下载；\n\t- 4) Storage 返回 `文件内容`。\n\n## FastDFS 客户端\n\n### Java 客户端\n- 调用余庆老师封装的 [FastDFS Client Java SDK](https://github.com/happyfish100/fastdfs-client-java)，即可实现客户端访问 FastDFS。\n\n### Python 客户端\n- `安装环境`：网上教程一般都是指 Python 2.7，在 Python 3.x 版本下跑不了，即使是通过 `pip3 install fdfs-client-py` 安装也跑不通，这里建议通过源码方式安装 $^{[3, 4]}$。\n\n\t> 源码地址：[Hay86. fdfs_client-py. Last Updated on Sept.9, 2018](https://github.com/jefforeilly/fdfs_client-py.git)\n\n\t```bash\n\t# Case.01.通过 pip 安装\n\tpip install fdfs_client-py-master.zip\n\t'''\n\tCase.02.通过 python 安装\n\t解压 fdfs_client-py-master.zip，进入目录 /fdfs_client-py-master\n\tpython steup.py install\n\t'''\n\t# 安装完成后，若导入时提示缺少 mutagen、requests，请继续安装依赖包\n\tpip install mutagen\n\tpip install requests\n\t```\n\n- `安装指南`：当然，安装指南和 [API Reference](https://github.com/hay86/fdfs_client-py#api-reference) 请参考源码的官方文档。\n\n- `生成配置`：在测试代码前夕，我们还需要创建一配置文件 `client.conf`。注意配置文件名称就是 **client.conf**，更改为其他名称好像行不通。\n\n\t```python\n\t# connect timeout in seconds\n\t# default value is 30s\n\tconnect_timeout=30\n\t\n\t# network timeout in seconds\n\t# default value is 30s\n\tnetwork_timeout=30\n\t\n\t# the base path to store log files\n\tbase_path=log\n\t\n\t# tracker_server can ocur more than once, and tracker_server format is\n\t# \"host:port\", host can be hostname or ip address\n\ttracker_server=192.168.200.221:22122\n\t\n\t# standard log level as syslog, case insensitive, value list:\n\t### emerge for emergency\n\t### alert\n\t### crit for critical\n\t### error\n\t### warn for warning\n\t### notice\n\t### info\n\t### debug\n\tlog_level=info\n\t\n\t# if use connection pool\n\t# default value is false\n\t# since V4.05\n\tuse_connection_pool = false\n\t\n\t# connections whose the idle time exceeds this time will be closed\n\t# unit: second\n\t# default value is 3600\n\t# since V4.05\n\tconnection_pool_max_idle_time = 3600\n\t\n\t# if load FastDFS parameters from tracker server\n\t# since V4.05\n\t# default value is false\n\tload_fdfs_parameters_from_tracker=false\n\t\n\t# if use storage ID instead of IP address\n\t# same as tracker.conf\n\t# valid only when load_fdfs_parameters_from_tracker is false\n\t# default value is false\n\t# since V4.05\n\tuse_storage_id = false\n\t\n\t# specify storage ids filename, can use relative or absolute path\n\t# same as tracker.conf\n\t# valid only when load_fdfs_parameters_from_tracker is false\n\t# since V4.05\n\tstorage_ids_filename = storage_ids.conf\n\n\n\t# HTTP settings\n\thttp.tracker_server_port=80\n\t\n\t# use \"#include\" directive to include HTTP other settings\n\t## include http.conf\n\t```\n\n- `测试代码`：这里假设你已成功安装了 `fdfs-client-py`，那么以一段测试代码正式开始使用。\n\n\t```python\n\t# Step.01. import fdfs_client.client module\n\t# Step.02. instantiate class Fdfs_client\n\t# Step.03. call memeber functions\n\n\tfrom fdfs_client.client import *\n\t# client.conf 配置文件放在 .py 文件同目录下\n\tclient = Fdfs_client('client.conf')\n\n\t# 上传文件\n\tret = client.upload_by_filename('upload.txt')\n\tprint(ret)\n\t## 等待 3 秒，否则下载时会报错文件不存在\n\ttime.sleep(3)  \n\t## 新版本文件存放 Remote file_id 格式变化\n\tfile_id = ret['Remote file_id'].replace('\\\\', '/')\n\t\n\t# 下载文件\n\tret_download = client.download_to_file('download.txt', file_id)\n\tprint(ret_download)\n\t```\n\n- `说明文档`：关于 `Fdfs_client` 类的成员函数详细说明请参考 [API Reference](https://github.com/hay86/fdfs_client-py#api-reference)：\n\t- upload_by_filename(self, filename, meta_dict = None)\n\t- upload_by_buffer(self, filebuffer, file_ext_name = None, meta_dict = None)\n\t- upload_slave_by_filename(self, filename, remote_file_id, prefix_name, meta_dict = None)\n\t- upload_slave_by_buffer(self, filebuffer, remote_file_id, meta_dict = None, file_ext_name = None)\n\t- upload_appender_by_filename(self, local_filename, meta_dict = None)\n\t- upload_appender_by_buffer(self, filebuffer, file_ext_name = None, meta_dict = None)\n\t- delete_file(self, remote_file_id)\n\t- download_to_file(self, local_filename, remote_file_id, offset = 0, down_bytes = 0)\n\t- download_to_buffer(self, remote_file_id, offset = 0, down_bytes = 0)\n\t- list_one_group(self, group_name)\n\t- list_all_groups(self)\n\t- list_servers(self, group_name, storage_ip = None)\n\t- get_meta_data(self, remote_file_id)\n\t- append_by_filename(self, local_filename, remote_fileid)\n\t- append_by_buffer(self, file_buffer, remote_fileid)\n\t- truncate_file(self, truncated_filesize, appender_fileid)\n\t- modify_by_filename(self, filename, appender_fileid, offset = 0)\n\t- modify_by_buffer(self, filebuffer, appender_fileid, offset = 0)\n\n\n## 参考资料\n- [1] [Mafly. 分布式文件系统 FastDFS 简单了解. 2016. cnblogs.com](https://www.cnblogs.com/mafly/p/fastdfs.html)\n- [2] [shenxm. FastDFS 的介绍. 2018. cnblogs.com](https://www.cnblogs.com/shenxm/p/8459292.html)\n- [3] [小草. FastDFS 的 Python 客户端. 2017. zifuchuan.com](http://zifuchuan.com/me/index.php/python/725-1.html)\n- [4] [ZbyFt. Django-FDFS 配置. 2018. csdn.net](https://blog.csdn.net/weixin_42149982/article/details/82391218)\n","tags":["分布式","文件系统","DFS"],"categories":["Project"]},{"title":"树莓派能做什么？","url":"/2019/01/Raspbian-Guideline.html","content":"\n树莓派能做什么？关于此命题，最直观感受就是看看树莓派实验室整理的一些[案例](http://shumeipai.nxez.com/what-raspi-used-for)，相信你心目中会有答案的。例如，打造一个家庭媒体中心 ( KODI )、配置无线路由器、搭建 BT 下载服务器、搭建代码托管服务器 ( SVN、GIt )、搭建网站服务器、搭建 Shadowsocks、用 HomeKit + Siri 声控家里电器等，即可把树莓派想象成嵌入式、微小型的服务器，这一过程就好比操作系统 ( Linux ) 赋予硬件生命，编程 ( Python、Java )、程序灌入灵魂，借助树莓派低能耗、移动便携性、GPIO 等特性，很多想法不是不可能，相信树莓派会给你创造更多的惊喜！\n\n<!-- more -->\n\n需要说明的是，本文将围绕两大方面去探索树莓派，即基础应用和解决方案两大部分，也可理解为基础到进阶的过程。\n\n- [基础应用](#基础应用)：介绍使用树莓派必须的应用或组件，这些应用和组件主要作用是：一方面是增强系统功能，另一方面则是为解决方案建立软件基础。\n- [解决方案](#解决方案)：诸如引言中谈及的，搭建服务器、智能家居控制中心等，即针对某部分需求集成为服务，学术说法称其为某某即服务 ( XaaS )。\n\n## 版本信息\n- 树莓派型号：树莓派 3B+\n- 树莓派系统：[Raspbian v.3.0.0](https://www.raspberrypi.org/downloads/noobs/)\n\n## 更新进度\n\n- 2019.01.21：完成初稿，形成笔记的整体框架；\n- 2019.02.25：更新「Jupyter 服务器」 章节内容；\n- 2019.02.26：更新「Conda 服务器」 章节内容；\n\n## 教学资源\n\n- 🚩 | 社区 | [树莓派实验室](http://shumeipai.nxez.com/) | 教程、创意、作品、资讯、硬件五位一体的爱好者交流社区。\n- 🚩 | 社区 | [趣无尽](https://www.quwj.com/) | 树莓派高端、创意的玩法探索博客站。\n- 📄 | 资料 | [亚博智能官方资料. 树莓派3代B型开发板](https://www.yahboom.com/study/raspberry) | [资料打包下载 ( bwnr )](https://pan.baidu.com/s/1OUa0KszF7sxim5FcUdqccQ)\n\n## 基础应用\n\n### TeamViewer 远程控制\n\n#### 引言\n\n访问树莓派有多种方式，如直连显示器交互使用、通过 SSH 远程登录访问、通过软件实现控制使用等。其中，TeamViewer 是通过软件方式实现对树莓派的远程控制，其拥有有以下几种特性：\n\n- 可穿透局域网，支持外网连接；\n- 实时 GUI 界面显示；\n- 支持文件双向传输。\n\n#### 配置\n\n在本节，则单独介绍 TeamViewer 的配置与使用，当然教程是参考文章 [[5]](http://www.52pi.net/archives/549)、[[6]](https://blog.csdn.net/realDonaldTrump/article/details/79694196) 整理而得。\n\n##### 删除 TeamViewer\n\n删除 TeamViewer，用于安装出错时，清理残留软件包，方便从头再来。😂\n\n> 此步骤是非必要执行的步骤。\n\n```bash\nsudo apt-get remove teamviewer-host\n# 清除所有已删除包的残余配置文件\n# 若报错误 dpkg: –purge needs at least one package name argument\n# 证明你的系统中没有残留配置文件了\ndpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P\n```\n\n##### 安装 TeamViewer\n\nStep.01：进入 [官方下载](https://www.teamviewer.com/en-us/download/linux/)，在「TeamViewer Host for Raspberry Pi」模块，复制安装包地址，接着正式开始安装：\n\n```bash\n# 通过 wget 在线下载安装包\nwget https://download.teamviewer.com/download/linux/teamviewer-host_armhf.deb\n# 安装本地软件包，但不解决依赖关系\nsudo dpkg -i teamviewer-host_armhf.deb\n# 修复损坏的软件包，尝试卸载出错的包，重新安装正确版本的\nsudo apt-get -f install\n\t\t\n# 若提示未找到依赖包，可安装 Gdebi，通过 Gdebi 安装解决依赖问题\n# 使用 Gdebi 可代替软件中心接管 deb 软件包的安装\n# 它会根据软件仓库这一实用的特性来解算依赖关系\nsudo apt-get install gdebi\nsudo gdebi teamviewer-host_armhf.deb\n```\n\n##### 配置 TeamViewer\n\nStep.02：因为我们烧写的系统有图形界面，默认 TeamViewer 要在图形界面进行配置，如远程控制的账号、密码设置等。若有条件支持，可移步图形化界面操作，即可忽略此步骤。\n\n- 没有图形界面，则我们需要在命令行下配置。使用 `raspi-config` 配置 Raspbian 仅命令行模式运行。\n\t\t\n\t```bash\n\tsudo raspi-config\n\t\t\n\t# 命令模式的操作界面\n\t# 依次选择操作 ( 同理，还原桌面模式也是类似操作 )\n\t# Boot Options -> Desktop / CLI -> Console AutoLogin ->\n\t# Finished\n\t```\n\t\n- 配置保存后，树莓派会自动重启，那么重新远程登录继续操作。\n\n\t```bash\n\tsudo teamviewer setup\n\t# 1. Accept License Agreement? (y/n) y\n\t# 2. 输入用户名和密码的步骤无法跳过，没有账号请移步「官网完成注册」\n\t# \t 注册地址：https://login.teamviewer.com/LogOn\n\t# \t Please enter your e-mail / username: kofe\n\t# \t Please enter your password: ******\n\t# 3. 然后 TeamViewer 会发一份设备授权邮件，请移步「邮箱处理」\n\t# 4. 重新输入用户名和密码登录，提示分组信息，点击 y：\n\t# \t Adding this machine as 'raspberrypi' to ... \n\t#\t Do you want to continue? (y/n) [n]  y\n\t# 5. 提示 \"Successfully....\" 即表示已经完成配置工作了\n\t```\n\t\n- 完成初始化配置后，只需设置远程控制密码即可使用了。\n\n\t```bash\n\t# 查看本机 ID\n\tteamviewer info\n\t# 设置本机密码\n\tteamviewer passwd [你的密码]\n\t```\n\t\n- 当然，我们还需要把 Raspbian 还原为图形化操作界面。\n\n\t```bash\n\tsudo raspi-config\n\t# Boot Options -> Desktop / CLI -> Desktop AutoLogin ->\n\t# Finished\n\t```\n\t\n#### 使用\n\n- 一般情况下，我们主要是通过命令模式访问树莓派、配置 TeamViewer。当然也可以通过图形界面完成配置操作，按照文字提示操作即可，这里就不详细阐述了。附上 TeamViewer 常用的命令：\n\n\t```bash\n\t# 查看帮助信息\n\tteamviewer help\n\t# 查看本机 ID\n\tteamviewer info\n\t# 设置本机密码\n\tsudo teamviewer passwd [你的密码]\n\t# 启动 TeamViewer 服务\n\tsudo teamviewer --daemon start\n\t# 开启 TeamViewer 服务随机启动\n\tsudo teamviewer --daemon enable\n\t```\n\n- 最后，关于图形化界面显示方面，可能还有分辨率调整与存在黑边的问题，详细可参考以下文章解决问题：\n\t- [树莓派. 官方使用文档之 CONFIG-TXT. raspberrypi.org](https://www.raspberrypi.org/documentation/configuration/config-txt/README.md)\n\t- [FishChina. 树莓派有黑边不能全屏解决方法. 2017. csdn.net](https://blog.csdn.net/fishchina/article/details/54564395)\n\t\t\n### MySQL 数据库\n\n#### 引言\n\n数据库的用途毋庸置疑，若在树莓派上跑脚本、程序、网站系统等，少不了数据的交互，为此我们需要一款数据库作为数据储存的媒介。MySQL，是一款开源免费的数据库，也是关系型数据库管理系统，支持多种存储引擎 $^{[1, 2]}$，对于个人开发和日常使用足矣。\n\n以下将介绍，在树莓派 Raspbian 上安装 Mysql  服务，并开启远程访问。\n\n#### 安装 MySQL\n\n- 删除 MySQL：安装前，确保系统没有旧版的 MySQL。\n\n\t```bash\n\tsudo apt-get autoremove --purge mysql-server\n\tsudo apt-get remove mysql-common\n\t\n\t# 清除所有已删除包的残馀配置文件\n\t# 若报错误 dpkg: –purge needs at least one package name argument\n\t# 证明你的系统中没有残留配置文件了\n\tdpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P\n\t```\n\t\n- 安装 MySQL：\n\n\t```bash\n\tsudo apt-get install mysql-server\n\tsudo apt-get install mysql-client\n\tsudo apt-get install python-mysqldb # 安装 Python 接口的 MySQL\n\t```\n\t\n#### 配置 MySQL\n\n- 命令行安装，默认是不用配置用户和密码信息，故我们首先配置登录信息 $^{[3]}$：\n\t\t\n\t```sql\n\tsudo mysql -u root # 无密码登录 MySQL\n\tuse mysql;\n\t\t\n\t# 加密方式选择，系统默认是 'unix_socket'，这里暂为空\n\tUPDATE user SET plugin='' WHERE user='root';\n\t\t\n\tUPDATE user SET password=PASSWORD('你自己的密码') WHERE user='root';\n\t\n\tflush privileges; # 清空缓存\n\texit;\n\t```\n- 操作数据库 ( 配置完信息，重启 MySQL 以让设置生效 )\n\n\t```bash\n\t# sudo /etc/init.d/mysql status/start/stop/restart\n\tsudo /etc/init.d/mysql restart\n\t\t\n\t# 当然可通过 systemctl 命令管理系统服务\n\t# sudo systemctl restart mysql # 重启系统服务\n\t# sudo systemctl status mysql # 查看系统状态\n\t```\n\n#### 开启远程访问\n\n以上配置工作完成后，即可本地使用 MySQL 数据库了。若需要开启远程访问服务，我们还需要实现以下工作：防火墙与访问规则配置和远程登录的账号配置。\n\n##### 外网访问\n若在树莓派下测试，让数据库允许外网访问，注意得关闭防火墙或添加规则允许某端口的访问权限 $^{[4]}$。\n\n- Case.01：本机和服务器端 ( 树莓派 ) 互相 Ping 对方 IP，以检验网络是否畅通、是否拒绝访问。\n- Case.02：若网络畅通、没有拒绝访问，还要留意对应端口是否有权限访问，通过 nc -vz IP 端口检验，返回 Succeeded 即成功。\n\n\t```bash\n\t# MacOS：nc -vz IP地址 端口号\n\tnc -vz 192.168.x.x 3306\n\t# Windows：telnet IP地址 端口号\n\ttelnet 192.168.x.x 22 # SSH 远程访问\n\ttelnet 192.168.x.x 3306 # MySQL 数据库\n\t```\n\n##### 防火墙与访问规则\n\n针对上述两种情况，则可通过关闭防火墙或者添加端口的访问规则，以授权 IP 和相关端口接受访问。\n\n- 配置防火墙：\n\n\t```bash\n\t# 安装 ufw ( 已安装忽略 )\n\tsudo apt-get install ufw\n\t# 设置默认规则为 allow，除指明打开的端口，所有端口默认关闭\n\tufw default deny\n\t# 启用 /关闭 ufw\n\tufw enable/disable\n\t# 查看防火墙状态\n\tufw status\n\t```\n\t\n- 配置访问规则：\n\n\t```bash\n\t# 例如：打开 SSH 远程登录\n\tsudo ufw allow 22\n\t# 删除添加过的规则\n\tsudo ufw delete allow 22\n\t```\n\n##### 远程登录的账号\n\n最后，我们还需要设置可远程登录的账号。\n\n- 修改 MySQL 配置：\n\n\t```bash\n\tsudo vim /etc/mysql/mariadb.conf.d/50-server.cnf\n\t# 找到 bind-address 这行注释掉，然后重启\n\tsudo systemctl restart mysql\n\t```\n\t\n- 修改 MySQL 账号信息：在配置 `登录信息` 时已授权，此项可日后用作远程登录账号的配置。\n\t\n\t```sql\n\tmysql -u root -p\n\tuse mysql;\n\tGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root账号密码' WITH GRANT OPTION;\n\tflush privileges;\n\t```\n\n### Jupyter 服务器\n#### 引言\nJupyter Notebooks 是什么？相信做数据科学项目的同学都清楚，Jupyter 其提供了一个集成环境，无需更多附加操作就可在其中编写你的代码、运行代码、查看输出、可视化数据并查看结果。\n\n作为一款可执行端到端的数据科学工作流程的便捷工具，它不仅支持数据清理、统计建模、构建和训练机器学习模型、可视化数据等数据科学工作，而且其强大的交互性，使得它可以更具教学性的方式展示代码。\n\n> 当然 Jupyter 也能运行其他 Python 程序，这里只是为了代入特定场景介绍它。\n\n\n#### 安装 Jupyter Notebook\n\n- 在此之前，需要确保你安装了 `Python` 以及 `pip` 模块。\n\n\t```bash\n\t# 树莓派 Raspbian 原生内置了 Python 2.7\n\t# 我们需要基于 Python 3.x 基础上运作 Jupyter，则需要先安装 Python 3.x\n\tsudo apt-get install python3.5 python3-pip\n\t```\n\n- 安装 Jupyter Notebook：\n\n\t> 若你已经有使用 virtualenv 的经验，强烈建议在虚拟环境中安装所需版本的 jupyter notebook。\n\n\t```bash\n\t# 基于 Python 2.7\n\tpip install --upgrade jupyter\n\t# 基于 Python 3.x\n\tpip3 install --upgrade jupyter\n\t\n\t# 检查是否安装成功，成功返回版本号\n\tjupyter --version\n\t```\n\n#### 配置 Jupyter Notebook\n\n配置 Jupyter Notebook，参考了文档 [[7]](https://www.jianshu.com/p/639c8d939643)：\n\n- 生成配置文件：注意不同用户组，生成的配置文件是存放在不同位置的。\n\n\t```bash\n\t# 配置文件存放于 /root/.jupyter/jupyter_notebook_config.py \n\tsudo jupyter notebook --generate-config\n\t# 配置文件存放于 /home/pi/.jupyter/jupyter_notebook_config.py ( 推荐 )\n\t# /home/pi/ 为当前登录用户的工作目录\n\tjupyter notebook --generate-config\n\t```\n\n- 设置密码：终端进入 iPython / Python 环境，借助 Python 生成 SHA 密钥：\n\n\t> 若不开启远程服务，则可跳过此步骤。\n\n\t```python\n\t>>> from notebook.auth import passwd # 导入授权模块设置密码\n\t>>> passwd() # 提示键入密码\n\tEnter password: your password\n\tVerify password: your password again\n\t# 密码的哈希值，用于配置文件中设置密码\n\t'sha1:67c9e601de......7d111089e11aed' \n\t```\n\n- 进入配置文件：\n\n\t```bash\n\tsudo vim /home/pi/.jupyter/jupyter_notebook_config.py \n\t```\n\t\n- 修改配置内容：配置选项非常丰富，关于其他配置的选项用途详细可参考 `jupyter_notebook_config.py` 内的注释。\n\n\t```bash\n\t# 注意开启配置选项，记得去掉 #，才能使配置生效！\n\t# 允许所有 IP 访问\n\tc.NotebookApp.ip='*'\n\t# 远程访问密钥\n\tc.NotebookApp.password = u'sha:67c9e......11aed'\n\t# 不在本机自动打开浏览器\n\tc.NotebookApp.open_browser = False\n\t# 指定监听端口\n\tc.NotebookApp.port =8888\n\t# Jupyter 的默认工作目录\n\tc.NotebookApp.notebook_dir = '/home/pi/ipynb/'\n\t# 允许使用 root 用户启动 jupyter\n\t# c.NotebookApp.allow_root = True\n\t```\n\t\n- 启动 Jupyter Notebook：`jupyter notebook`\n\n#### 拓展 Jupyter Notebook\n##### 开启远程访问\nJupyter Notebook 开启远程访问 ( 远程访问这里指同一局域网，其他终端访问树莓派，若是要外网访问请参阅内网穿透相关内容 )，但端口被拒绝访问。\n\n- 在配置文件中，我们只设置了 `0.0.0.0` 或 `*` 的 IP 地址，在局域网环境运行能正常访问。但对于远程访问，归根结底，我们还需要知道树莓派的 IP 才能访问到服务端的 Jupyter，故我们是这样解决访问问题的 $^{[7]}$。\n\n\t```bash\n\t# nohup: 一直执行命令，即使关闭了 SSH。\n\t# --ip: 指定在 192.168.10.200 ( 树莓派的IP ) 上监听活动。\n\t# &: 在后台运行这条命令。\n\tnohup jupyter notebook --ip 192.168.10.200 &\n\t```\n\n- 最后，我们需要确保该端口是否在安全策略下已经开启，详细可参考 MySQL 数据库的 [防火墙与访问规则](#防火墙与访问规则) 章节内容。\n\n##### 开启自启服务\n搭建 Jupyter 服务器，Jupyter 挂靠后台服务，且开通断电自动重启功能，参考了文档 [[8]](https://blog.csdn.net/q361949240/article/details/83179560)。\n\n- 在 `/etc/systemd/system` 下创建 `jupyter.service` 输入如下内容：\n\n\t```bash\n\tsudo vim /etc/sytemd/system/jupyter.service\n\t```\n\n- `jupyter.service` 内容填写如下：\n\n\t```bash\n\t[Unit]\n\tDescription=Jupyter Notebook\n\tAfter=network.target\n\n\t[Service]\n\tType=simple\n\t# 这里在 /run 目录下没有 jupyter.pid\n\t# 这个是进程产生之后出现的，虽然在启动前没有，但是可以使用\n\tPIDFile=/run/jupyter.pid\n\t# ExecStart 是执行文件 jupyter-notebook\n\t# config 是配置文件 jupyter_notebook_config.py\n\t# ip 是树莓派的地址\n\tExecStart=/usr/local/bin/jupyter-notebook --config=/home/pi/.jupyter/jupyter_notebook_config.py --ip=192.168.10.200\n\tUser=pi\n\t# 查看用户组 groups pi，发现属于 pi 组\n\tGroup=pi\n\t# 自己设置的工作目录\n\t# 需同时在 jupyter_notebook_config.py 中设置\n\t# c.NotebookApp.notebook_dir = '/home/pi/ipynb/'\n\tWorkingDirectory=/home/pi/ipynb/\n\tRestart=always\n\tRestartSec=10\n\n\t[Install]\n\tWantedBy=multi-user.target\n\t```\n\n- 使服务自启动：`systemctl enable jupyter`\n- 启动服务：`service jupyter start`\n\n##### 加载虚拟环境\n- 首先，我们为 Jupyter Notebook 创建隔绝的虚拟环境，从而便捷、更针对地管理软件包。\n\n\t> 比如，某个 Python 程序需要 Python 2.7 特定环境运行，而我们编译的环境是 Python 3.x ，即为了运行该程序需要把原来的 Python 3.x 给替换成 Python 2.7。同理，对于程序的依赖包，即使是同一个软件包也存在不同版本的要求。那么问题就出现在这，在同一台电脑上，为让更多程序兼容运行，这正是虚拟环境的作用之一。  \n\t\n- 再者，引入 [Conda 管理器](#Conda-管理器) 的概念，简单来说 Conda 是一款包管理系统。conda 与 pip 类似，它会根据你的键入需求，且自行交代清楚相互依赖的包，并实现自动化地下载、安装它们。\n\n- 基于以上两点的理解，我们正式进入正题，开始配置一个虚拟环境，并让 Jupyter Notebook 使用起来：\n\n\t```bash\n\t# 1. 参考 Conda 管理器的 BerryConda 小节，完成 BerryConda 的安装\n\t# 2. 建立一个虚拟环境运作 Conda 以方便管理各种包\n\tconda create -n your_venv_name python=3.6\n\t# 3. 激活环境\n\tsource activate your_venv_name\n\t# 4. 安装 Jupyter 包：上述内容中，Jupyter 是安装在原生环境下的\n\t# 考虑到兼容性的情况 (例如第5点的情况)，在该虚拟环境中重新安装一个 Jupyter\n\tconda install jupyter\n\t# 给该环境下载其他软件包也是类似操作\n\t# conda install scipy numpy scikit-learn...\n\t# 5. 指定版本安装 tornado，不然 Jupyter 会报错\n\tconda install tornado=4.5\n\t# 6. 安装 nb_conda 包，让 Jupyter 支持使用虚拟环境\n\tconda install nb_conda\n\t```\n\n- 若使用虚拟环境中的 Jupyter ( 自启服务的 ExecStart 设置同理 )，此时启动 Jupyter 的程序应该改为：\n\n\t```bash\n\t# /home/pi/ 为当前登录用户的工作目录\n\t/home/pi/berryconda3/envs/your_venv_name/bin/jupyter-notebook\n\t```\n\n##### 打造科学环境\n###### Tensorflow \n值得庆贺的是，[Tensorflow 1.9](https://medium.com/tensorflow/tensorflow-1-9-officially-supports-the-raspberry-pi-b91669b0aa0) 官方版本开始支持树莓派 RaspBerry Pi 了，没有繁琐的步骤即可体验 Tensorflow！具体的安装方法大概参考 [Tensorflow 官方说明文档](https://tensorflow.google.cn/install/pip)。\n\n- 但在实操过程中还是碰到了不可预计的情况：\n\n\t```bash\n\t# 1. 安装 libatlas-base-dev (Required for Numpy)\n\tsudo apt install libatlas-base-dev\n\t# 2. 同样，在虚拟环境内安装 tensorflow，虚拟环境的 Python 版本为 3.6\n\tsource activate your_venv_name\n\t# 3. 安装 h5py、hdf5，不然 tf 安装过程中会报错 ( 缺少 hdf5.h 文件 )：\n\t# /tmp/pip-install-ve4RnJ/h5py/h5py/api_compat.h:27:18: \n\t# fatal error: hdf5.h: No such file or directory\n\t# 4. 通过 conda 安装 h5py ( 好像 pip (Python3.x) 安装 h5py 会遇到缺少文件的问题？)\n\tconda install h5py \n\t# 5. 正式安装 tensorflow\n\t# pip --version 查看是否是虚拟环境的 pip，不然未能安装在当前环境\n\tpip install --upgrade --user tensorflow\n\t```\n\t\n- 若中途不出错、不提示错误，等待安装成功即可。然后输入代码测试验证：\n\n\t```bash\n\tpython # 命令进入 ipython / python 模式\n\t>>> import tensorflow as tf\n\t>>> tf.enable_eager_execution()\n\t>>> print( tf.reduce_sum(tf.random_normal([1000, 1000])) )\n\t```\n\n- 当然，还可能遇到 tensorflow 部分模块的 Python 版本跟编译环境的 Python 版本对不上，则可通过针对 ( 编译环境的 ) Python 版本的 pip 升级 tensorflow 解决此问题：\n\n\t```bash\n\t# 异常的情况大概如下：\n\t# /usr/lib/python3.6/importlib/_bootstrap.py:219: \n\t# RuntimeWarning: compiletime version 3.5 of module 'tensorflow.python.framework.fast_tensor_util' \n\t# does not match runtime version 3.6\n\tpython3.6 -m pip install --upgrade --user tensorflow\n\t```\n\n###### Keras\n- 安装过程演示：\n\n\t```bash\n\t# 1. 同样，在虚拟环境内安装 keras，虚拟环境的 Python 版本为 3.6\n\tsource activate your_venv_name\n\t# 2. 正式安装 keras\n\t# pip --version 查看是否是虚拟环境的 pip，不然未能安装在当前环境\n\tpip install --upgrade --user keras\n\t```\n\t\n- 当然，还可能遇到版本对不上的异常，参考 上述解决方案：\n\n\t```bash\n\tpython3.6 -m pip install --upgrade --user keras\n\t```\n\n##### 常见问题整理\n- 当新建或修改 ipynb 文档时，出现 `Permission denied: Untitled.ipynb` 权限异常，检查工作目录是否具有操作权限、当前用户是否有操作权限。\n\n\t```bash\n\t# 确保 Jupyter 工作目录属于当前登录用户 pi\n\tsudo chown -R pi:pi /home/pi/ipynb\n\t# 确保 Jupyter 工作目录有可读、可写和可执行的权限\n\t# 更新后的权限情况：drwxrwxr--\n\tchmod ug=rwx /home/pi/ipynb\n\t```\n\n### Conda 管理器\n#### 引言\n无论是使用 Jupyter Notebook，亦或是原生 Python 环境做 `数据科学` 相关工作，难免需要 `安装各种科学计算包`，而且还涉及众多依赖包的安装。那么如何管理包变成了一门 \"手艺活\" 了，此时推荐你使用 Conda 包管理系统，繁琐的包安装工作交由 Conda 处理，你只管专心地开展数据科学工作。\n\n参考 [树莓派 Raspbian 系统可安装 Anaconda 吗？](https://www.zhihu.com/question/65430209)，得知树莓派安装 Conda 共有两种选择：\n\n- [MiniConda](https://conda.io/en/latest/miniconda.html)：年久未更，目前 Python 只停留在 Python 3.4 版本。\n- [BerryConda](https://github.com/jjhelmus/berryconda)：是一款为树莓派定制基于 Conda Python 发行版的开源软件。Berryconda 提供了 Python 2.7 的 Berryconda 2 和 Python 3.6 的 Berryconda 3，同时还支持树莓派 0、1、2、3 各个系列，我们可根据树莓派的版本选择适合的软件版本安装即可。\n\n#### Miniconda\nMiniconda 与 Anaconda 同为发行版本的 Conda 包管理系统，Miniconda 则是最小的 Conda 安装环境。以下直接安装操作演示，安装过程参考了 [[9]](https://blog.csdn.net/tju_cc/article/details/80024721)、[[10]](https://www.jianshu.com/p/edaa744ea47d)。\n\n\n##### 安装 MiniConda\n- 首先，确保安装了 `wget` 和 `bzip2`：\n\t\t\n\t```bash\n\t# 查看是否有反馈，有则表示已安装\n\twget --help\n\tbzip2 --help\n\tsudo apt-get install -y wget bzip2\n\t```\n\t\n- 下载安装脚本：\n\n\t```bash\n\t# wget 不添加参数，默认是保存到当前路径\n\t# wget -O /path/name 指定路径及文件名\n\twget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-armv7l.sh   \n\t```\n\t\n- 运行安装脚本：\n\n\t> 安装过程中不需要使用 sudo，程序默认会安装到 /home/pi/miniconda3 中。当然，也是为了确保 miniconda3 工作目录属于当前登录用户 pi。\n\n\t```bash\n\tbash Miniconda3-latest-Linux-armv7l.sh\n\t# 安装过程中，需要阅读一份声明，后面需要输入两次 Yes 确认\n\t# 第一个 Yes 是是否同意声明，若回车跳过则是默认输入了 No\n\t# 第二个 Yes 是添加到环境变量，否则需要自己手动添加到环境变量\n\t# --------- 若选择了 No 则需进行以下步骤的操作 --------- #\n\t# 1. 编辑 /bashrc 文件\n\tvim /home/pi/.bashrc\n\t# 2. 添加以下内容 (根据自己的安装路径修改)：\n\t# export PATH=\"/home/pi/miniconda3/bin:$PATH\"\n\t# 3. 添加完成后记得让其生效 ( 启动时才执行原则 )\n\t# export 生成的环境变量是临时的，关闭终端即结束 ( 可改永久性环境变量 )\n\tsource /home/pi/.bashrc\n\t```\n\n##### 使用 MiniConda\n- 检查 conda 是否安装成功，返回版本信息：\n\n\t```bash\n\t# 检查 conda 是否安装成功，返回版本信息\n\tconda --version\n\t# 显示当前已经安装好的包\n\tconda list \n\t```\n\n- `创建虚拟环境`，以避免 \"污染\" 环境，便于管理各种 Python 包：\n\n\t```bash\n\t# 建立一个虚拟环境运作 Conda 以方便管理各种包\n\tconda create -n your_venv_name python=3.4\n\t# 删除一个虚拟环境：\n\t# conda env remove -n your_venv_name\n\t# 激活环境 <---> 关闭环境：source deactivate\n\tsource activate your_venv_name \n\t```\n\t\n- 更改国内源，优化安装包下载速度：\n\n\t```bash\n\t# 添加国内下载源 ( 例如: 清华源 )\n\tconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n\tconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\n\tconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/\n\t# 替换源后记得更新 Conda 以促使配置生效\n\tconda update conda\n\t```\n\t\n- 使用 Conda 安装包:\n\n\t```bash\n\t# 事先查找指定软件是否存在\n\tconda search numpy\n\t# 安装指定软件\n\tconda install numpy\n\t# 安装特定版本的软件，Conda 会先卸载已安装版本，然后重新安装指定版本\n\tconda install 软件名=版本号\n\t# 更新指定软件\n\tconda update numpy\n\t# 卸载指定软件\n\tconda remove numpy\n\t```\n\n##### 卸载 MiniConda\n- 卸载 MiniConda 的方法：\n\n\t```bash\n\t# 1. 在 /home/pi/.bashrc 移除环境变量 ( 注释掉 )\n\t# export PATH=\"/home/pi/miniconda3/bin:$PATH\"\n\t# 2. 删除 miniconda 整个文件\n\trm -rf miniconda3/\n\t# 3. 重新激活 .bashrc\n\tsource /home/pi/.bashrc\n\t```\n\n#### BerryConda\nBerryConda 是一款为树莓派定制基于 conda python 发行版的开源软件。安装过程参考了 [[11]](https://www.jianshu.com/p/ccad38dbb897)。\n\n##### 安装 BerryConda\n- 参考 [BerryConda](https://github.com/jjhelmus/berryconda) 文档，根据自己的机器版本 ( 树莓派 3B+ / Armv7l 架构 )，并确定 Python 版本号 ( Python 3.x )，为此选择了 Berryconda 3 版本安装，安装方法与 Miniconda 类似。\n\n- 下载安装脚本：\n\n\t> 安装过程中不需要使用 sudo，程序默认会安装到 /home/pi/berryconda3 中。当然，也是为了确保 berryconda3 工作目录属于当前登录用户 pi。\n\n\t```bash\n\twget https://github.com/jjhelmus/berryconda/releases/download/v2.0.0/Berryconda3-2.0.0-Linux-armv7l.sh\n\t```\n\t\n- 执行安装脚本：\n\t\n\t```bash\n\tbash Berryconda3-2.0.0-Linux-armv7l.sh\n\t# 安装过程中，需要阅读一份声明，后面需要输入两次 Yes 确认\n\t# 第一个 Yes 是是否同意声明，若回车跳过则是默认输入了 No\n\t# 第二个 Yes 是添加到环境变量，否则需要自己手动添加到环境变量\n\t# --------- 若选择了 No 则需进行以下步骤的操作 --------- #\n\t# 1. 编辑 /bashrc 文件\n\tvim /home/pi/.bashrc\n\t# 2. 添加以下内容 (根据自己的安装路径修改)：\n\t# export PATH=\"/home/pi/miniconda3/bin:$PATH\"\n\t# 3. 添加完成后记得让其生效\n\t# export 生成的环境变量是临时的，关闭终端即结束 ( 可改永久性环境变量 )\n\tsource /home/pi/.bashrc\n\t```\n\n##### 使用 BerryConda\n- 至此，BerryConda 已经安装完成，查看版本信息检验是否安装成功，剩余的 Conda 操作参考 [使用 MiniConda](#使用-MiniConda) 章节即可。\n\n\t```bash\n\t# 检查 conda 是否安装成功，返回版本信息\n\tconda --version\n\t# 显示当前已经安装好的包\n\tconda list \n\t```\n\n## 解决方案\n\n## 参考资料\n\n- [1] [百度百科. 存储引擎. baike.baidu.com](https://baike.baidu.com/item/存储引擎)\n- [2] [jaywcjlove. mysql-tutorial. 2017. github.com](https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md)\n- [3] [编程浪子. 树莓派3之安装Mysql服务. 2018. cnblogs.com](https://www.cnblogs.com/apanly/p/9061803.html)\n- [4] [farYang. 树莓派安装mysql并开启远程访问. 2016. csdn.net](https://blog.csdn.net/faryang/article/details/50788795)\n- [5] [Li, TaterLi. 十步配置TeamViewer远程控制Pi. 2017. 52pi.net](http://www.52pi.net/archives/549)\n- [6] [萝是carrot夢是Dream. 树莓派安装配置TeamViewer实现外网远程控制. 2018. csdn.net](https://blog.csdn.net/realDonaldTrump/article/details/79694196)\n- [7] [终可见. 树莓派 3B 搭建 Jupyter notebook. 2018. jianshu.com](https://www.jianshu.com/p/639c8d939643)\n- [8] [齐志刚. 树莓派 3B Jupyter notebook 设置为后台服务. 2018. csdn.net](https://blog.csdn.net/q361949240/article/details/83179560)\n- [9] [Holy_C. 树莓派 miniconda3+opencv3.3+tensorflow1.7 踩坑总结. 2018. csdn.net](https://blog.csdn.net/tju_cc/article/details/80024721)\n- [10] [卖萌哥. Conda 的安装与使用. 2018. jiansu.com](https://www.jianshu.com/p/edaa744ea47d)\n- [11] [Speculatecat. 解决 Raspbian Miniconda 无法安装最新 Python3.6. 2018. jianshu.com](https://www.jianshu.com/p/ccad38dbb897)","tags":["树莓派","Raspbian","博客搭建","服务器","数据科学"],"categories":["Technique"]},{"title":"讲座 | 利用 t-SNE 降维并可视化高维数据","url":"/2018/11/The-Best-Way-to-Visualize-a-Dataset-Easily.html","content":"\n{% note default %}  \n作者：Siraj Raval  \n课堂：The Best Way to Visualize a Dataset Easily | [Bilibili](https://www.bilibili.com/video/av35768109) | [Youtube](https://www.youtube.com/watch?v=yQsOFWqpjkE)  \n源码：llSourcell.Visualize_dataset_demo | [Github](https://github.com/llSourcell/visualize_dataset_demo)  \n{% endnote %}\n\n- `目标`：在本次课堂中，将对人类活动识别 ( Human Activity Recognition，HAR ) 数据集进行数据可视化呈现，并进行探索性分析以发现知识。而本课堂具体目标则是人类活动状态识别，活动状态包括：Sitting-down，Standing-up，Standing，Walking，Sitting。\n\n\t具体地，通过降维方法 `t-SNE` 实现不同活动状态的数据自动 \"分类\"，从而在低维度 ( 二维 ) 下复现数据 ( 的特征 )，以便我们理解数据、统计分析数据。\n\t\n- `问题`：若我们要将要描述如此复杂的数据，即它们拥有的特征 ( 维度 ) 过多了，相对于人类大脑只能理解二维或三维的层面，如此复杂数据我们是难以从中发现知识的。\n\n- `解决`：通过可视化数据来描述它们的特征，具体措施是使用机器学习中的降维方法 `T-SNE` ( Distributed Stochastic Neighbor Embedding )，把高维空间中的数据以二维或三维的形式表示。\n\n<!-- More -->\n\n- HAR 数据集的数据来源：参与者绑上健身追踪设备，当它们运动起来时，追踪设备会记录这些身体指标数据。\n\n\t> 关于HAR 数据集更详细的描述请参考：[HAR Set 介绍](http://groupware.les.inf.puc-rio.br/har#ixzz4Mt0Teae2) | [HAR Set 下载](https://d396qusza40orc.cloudfront.net/predmachlearn/pml-training.csv)\n\n## 观察数据\n- 每一行数据代表不同的人。\n- 每一列代表某人的身体指标测量数据，如手臂或者前臂的空间位置 ( x，y，z 坐标 )。\n- 在人类活动识别数据集中，每一行 ( 实体 ) 都有类标签标记。且共有 5 种标签：Sitting-down，Standing-up，Standing，Walking，Sitting。\n\n## 预处理数据\n\n> 关于 `预处理数据` 的详细解释，可参考另外一篇文章：[Kofe. 如何轻松有效地预处理数据](https://www.kofes.cn/2018/11/the-best-way-to-prepare-a-dataset-easily.html)\n\n- `数据清洗`：缺失值处理、光滑噪声数据、识别和删除离群点。\n\n\t> 关于数据清洗，也推荐阅读具有实操意义的一篇博文：[TowardsDataScience. How to Handle Missing Data](https://towardsdatascience.com/how-to-handle-missing-data-8646b18db0d4)\n\n- `数据集成`：多个数据源的数据合并，存放于同一个数据仓库中。\n\t- `实体识别问题`：来自多个信息源，各数据源中的实体之间如何匹配，这涉及实体识别问题。如不同数据来源于不同数据库中，现实意义上它们是同一实体，但它们属性的元数据表达却不同 ( 如主键 )。\n\t- `冗余和相关分析`：集成多个数据源，数据中可能有多组属性重复存在。而冗余可被相关分析检测到，如分类 ( 标称 ) 属性的卡方检验、数值属性的相关系数、数值属性的方差和协方差。\n\t- `元组重复`：元组级检测重复。\n- `数据归约`：在海量数据上进行复杂的数据分析和挖掘，需要时间很长且不显示。在尽可能保持数据原貌前提下，最大限度精简数据量。策略包括：\n\t- `维归约`：也称为特征归约，减少所考虑的属性的个数。方法包括：小波变换、主成分分析、属性子集选择等。当然利用冗余和相关分析也是可行的。\n\t- `数量归约`：用替代的、较小的数据集表示形式替换原数据。方法包括：参数的方法，回归和对数线性模型；非参数的方法，聚类、降维、直方图、抽样和数据立方体聚集。\n\n\t\t> 在本课堂中则使用了降维方法进行维度的归约，其中降维方法有：PCA、t-SNE $^{[4]}$、LargeVis $^{[5, 6]}$ 等。\n\t\n- `数据变换`：主要思想是将数据变换或统一成适合数据挖掘的形式。方法可以是数据归一化、数据离散化、概念分层等。\n\t- `特征构造`：由给定的属性构造新的属性并添加至属性集中。\n\t- `聚集分解`：对数据进行 `汇总` 或者 `聚集`。如聚集季度销售数据。与之相对的是 `分解`，如常见的 “日期” 属性，不同的需求，我们要解构的粒度是不同的。如预测当日的气温变化，则我们可把年和月份剔除。\n\t- `归一化`：针对每一个特征 ( 维度 )，去均值和方差归一化。即把属性数据按比例缩放，让所有特征在统一数量级上运作，如此一来数据指标之间就有了可比性。\n\t- `离散化`：数值属性的原始值用区间标签或者概念标签替换，即这些标签可递归地组织成更高层概念，导致数值属性的 `概念分层`。\n\t\t\n\t\t> 例如，我们\t对年龄进行分层：1 to 17 为 Adolescent；18 to 45 为 Adult；46 以上为 Senior。\n\n## 数据可视化\n### 降维方法\n#### 降维目的\n- 通过降维算法来寻找 `数据内部的本质结构特征`，如特征选择或特征提取。\n\t- `特征选择`：假定数据中包含大量冗余或无关变量 ( 或称特征、属性、指标等 )，旨在从原有变量中找出主要变量。其代表方法为 [LASSO](https://zh.wikipedia.org/wiki/Lasso%E7%AE%97%E6%B3%95)。\n\t- `特征提取`：是将高维数据转化为低维数据的过程。在此过程中可能舍弃原有数据、创造新的变量。其代表方法为 [PCA](https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90)。\n- 在原始的高维空间中，包含有冗余信息、噪音信息。通过降维方法，`减少冗余信息` 所造成的误差，以提高模型的精度。\n\n#### 降维本质\n- 机器学习领域中，降维指采用某种映射方法将原高维空间中的数据点映射到低维度的空间中。\n- 降维的本质是学习一个映射函数 $ f : x \\to y$，其中 $x$ 是原始数据点的表达，$y$ 是数据点映射后的低维向量表达 ( 通常 $y$ 的维度小于 $x$ 的维度 )。$f$ 可能是显式的或隐式的、线性的或非线性的映射函数 ( 例如本例提及的 PCA 或者 t-SNE )。\n- 当我们意识到需要降维时，一般是发现了特征间的高度线性相关。若我们发现了线性相关，则适合使用 PCA 处理 $^{[1]}$，而 t-SNE 主打的是非线性降维。\n\n#### 降维算法\n##### PCA\n- `PCA`：主成分分析算法 ( Principal Component Analysis，PCA )，是最常用的 `线性降维方法`。它通过某种线性投影，将高维的数据映射到低维的空间中表示。具体工作原理是，从原始的空间中顺序地找一组相互正交的坐标轴，而且新的坐标轴选择与数据本身是密切相关的。其中，第一个新坐标轴选择是原始数据中方差最大的方向，第二个新坐标轴选取是与第一个坐标轴正交的平面中使得方差最大的方向，若继续添加第三个坐标轴，第三个轴与第一、二个轴正交的平面中方差最大的。依次类推，可以得到 $n$ 个这样的坐标轴。\n\n\t而实际情况，大部分方差都包含在前面 $k$ 个坐标轴中，后面的坐标轴所含的方差几乎为 0。事实上实现对数据特征的降维处理，相当于只保留包含绝大部分方差的维度，而忽略包含方差几乎为 0 的维度。\n\n##### SNE\n- `t-SNE` 可理解为 `SNE` 的特殊形式，我们先了解 SNE 的基本原理，再延伸学习 t-SNE ( 本小节可参考多篇博文比对学习，如参考资料中的 [2] - [3] )。\n\n- SNE 是通过 [仿射变换](https://www.zhihu.com/question/20666664) 将数据点映射到概率分布上，主要包括两个步骤：\n\n\t- SNE 构建一个高维对象之间的概率分布，使得相似的对象有更高的概率被选择，而不相似的对象有较低的概率被选择。\n\n\t- SNE在低维空间里在构建这些点的概率分布，使之与高维度的概率分布之间尽可能相似。\n\n- SNE 的实现原理：\n\t- 原始 SNE 先将 `欧几里得距离` 转换为 `条件概率` 来表达点与点之间的相似度。具体地，给定一个 $N$ 个高维的数据 $x_1, x_2, ..., x_N$，$x_i$ 和 $x_j$ 之间的相似度可表示为 ( $x_i$ 为中心点 )： \n\n\t\t$$\n\t\tp_{j|i} = \\frac{\n\t\t\texp({-||x^{(i)} - x^{(j)}||}^2 / {\n\t\t\t2\\sigma_i^2})\n\t\t}{ \n\t\t\t\\sum_{k \\neq i} exp({-||x^{(i)} - x^{(k)}||}^2 / {\n\t\t\t2\\sigma_i^2})\n\t\t}\n\t\t\\tag{1}\n\t\t$$\n\t\n\t\t这里的有一个参数是 $\\sigma_i$，其表示以 $x_i$ 为中心点的高斯分布的方差。且对于不同的点 $x_i$ 取值不一样 $^{[2]}$ ( 具体参详 SNE 的困惑度 ( Perplexity ) )。再者，由于我们只关心不同点两两之间的相似度，所以设定 $p_{i|i} = 0$。\n\n\t- 在把数据映射到低维空间后，高维数据点之间的相似性也应该在低维空间的数据点上体现出来。这里同样用条件概率的形式描述，对于低维度下的 $y_i$，我们可以指定高斯分布为方差为 $\\frac{1}{\\sqrt2}$。因此它们之间的相似度为:\n\n\t$$\n\tq_{j|i} = \\frac{\n\t\texp( {-||y^{(i)} - y^{(j)}||}^2 )\n\t}{ \n\t\t\\sum_{k \\neq i} exp( {-||y^{(i)} - y^{(k)}||}^2 )\n\t}\n\t\\tag{2}\n\t$$\n\n\t- 同理，设定 $q_{i|i} = 0$。这样一来，若 $y_i$ 和 $y_j$ 真实反映了高维数据点 $x_i$ 和 $x_j$ 之间的关系，那么条件概率 $p_{j|i}$ 与 $q_{j|i}$ 应该完全相等。\n\n\t\t这里我们只考虑 $x_i$ 与 $x_j$ 之间的条件概率，则它们可构成一个条件概率分布函数 $P$。同理，只考虑 $y_i$ 与 $y_j$ 之间的条件概率，在低维空间存在一个条件概率分布 $Q$，且应该与 $P$ 是一致的。\n\t\t\n\t\t如何衡量两个分布之间的相似性？则我们可通过优化两分布的距离，即 `K-L 散度` ( Kullback-Leibler Divergence )。SNE 最终目标就是对所有数据点最小化这个 K-L 散度，具体地，我们可使用 `梯度下降算法` 最小化以下代价函数：\n\t\t\n\t\t$$\n\t\tC = D_{KL}(P || Q) = \\sum_{i} \\sum_{j} p_{j|i} log \\frac{p_{j|i}}{q_{j|i}}\n\t\t\\tag{3}\n\t\t$$\n\t\t\n\t\tSNE 代价函数对 $y_i$ 求梯度后的形式如下：\n\n\t\t$$\n\t\t\\frac{\\delta C}{\\delta y_i} = \n\t\t2 \\sum_j ( p_{j|i} - q_{j|i} + p_{i|j} - q_{i|j} )( y_i - y_j )\n\t\t\\tag{4}\n\t\t$$\n\t\n\t- 似乎到这里问题就解决了，得到代价函数，利用梯度下降算法进行训练了。但事情远没有那么简单，因为 K-L 散度是一个非对称的度量，最小化代价函数的目的是让 $pj|i$ 和 $qj|i$ 的值尽可能的接近，即低维空间中点的相似性应当与高维空间中点的相似性一致。\n\t\t- 但从代价函数的形式就可以看出，考虑到离群点的情况，当 $p_{j|i}$ 较大，$q_{j|i}$ 较小时，即高维空间中两个数据点距离较近，而映射到低维空间后距离较远，那么将得到一个很高的惩罚，这没什么问题；\n\t\t- 而$p_{j|i}$ 较小，$q_{j|i}$ 较大时，即高维空间中两个数据点距离较远，而映射到低维空间距离较近，将得到一个很低的惩罚值。然而这就是问题所在，理应得到一个较高的惩罚才对。换句话说，SNE 的代价函数更关注局部结构，而忽视了全局结构。\n\n##### t-SNE\n\n{% note success %}\n论文中对 t-SNE 原理描述是基于数学形式化的，更多细节或难以理解的，比如距离度量如何转化为概率度量、如何确定 $\\sigma$、如何求梯度下降值等，建议阅读 t-SNE 的代码实现。\n\n推荐 [karpathy.tsnejs](https://github.com/karpathy/tsnejs) 和 [bindog.t-sne.js](https://gist.github.com/bindog/0ac283fc4dbdeb4c954990ea5c3dcd87) (请科学上网)，需要说明的是，bindog 的版本是基于 karpathy 的，具体工作是添加了注释和 [算法流程图](https://upload-images.jianshu.io/upload_images/415974-ab098a421189c1d0.png) $^{[8]}$。\n{% endnote %}\n\n- 在原始 SNE 中，$p_{i|j}$ 与 $p_{j|i}$ 是不相等的，低维空间中 $q_{i|j}$ 与 $q_{j|i}$ 也是不相等的。若我们分别在高维和低维空间构造更加通用的联合概率分布 $P$ 和 $Q$，使得对任意 i, j，均有 $p_{i|j} = p_{j|i}, \\, q_{i|j} = q_{j|i}$。而这种 SNE 称之为对称 SNE ( Symmetric SNE )，因此它们的概率分布可改写为 ( 同理，我们只关注不同点两两之间的相似性，故设定 $p_{i||i} = 0, q_{i||i} = 0$ ):\n\n\t$$\n\tp_{i, j} = \\frac{\n\t\t\texp({-||x^{(i)} - x^{(j)}||}^2 / {\n\t\t\t2\\sigma_i^2})\n\t\t}{ \n\t\t\t\\sum_{k \\neq l} exp({-||x^{(k)} - x^{(l)}||}^2 / {\n\t\t\t2\\sigma_i^2})\n\t\t} \\\\\n\tq_{i, j} = \\frac{\n\t\texp( {-||y^{(i)} - y^{(j)}||}^2 )\n\t}{ \n\t\t\\sum_{k \\neq l} exp( {-||y^{(k)} - y^{(l)}||}^2 )\n\t}\n\t\\tag{5}\n\t$$\n\n- 这样表达方式使得整体简洁了很多。但是会引入异常值的问题。比如，$x_i$ 是异常值，那么 $||x^{(i)} - x^{(j)}||^2$ 会很大，对应的所有的 $j$, $p_{i, j}$ 都会很小，导致低维映射下的 $y_i$ 无论处在什么位置，对代价函数影响很小。\n\n\t为了解决这个问题，我们将联合概率分布改写为：\n\n\t$$\n\tp_{i,j} = \\frac{\n\t\tp_{j|i} + p_{i|j} \n\t}{2N} \\\\\n\t( p_{j|i} = \\frac{p_{i,j}}{p_i}, \\,\n\tp_{i|j} = \\frac{p_{i,j}}{p_j}, \\,\n\tp_i = p_j = \\frac1N )\n\t\\tag{6}\n\t$$\n\t\n- 其中 N 为数据点的总数，这样定义即满足了对称性，又保证了 $x_i$ 的惩罚值不会过小。此时可以利用 KL 距离写出如下代价函数：\n\t\n\t$$\n\tC = D_{KL}(P || Q) = \\sum_{i} \\sum_{j} p_{i, j} log \\frac{p_{i, j}}{q_{i, j}}\n\t\\tag{7}\n\t$$\n\t\n- 对称 SNE 的最大优点，即梯度计算变得简单了：\n\n\t$$\n\t\\frac{\\delta C}{\\delta y_i} = \n\t4 \\sum_j ( p_{i, j} - q_{i, j})( y_i - y_j )\n\t\\tag{8}\n\t$$\n\t\n\t但是Maaten 还指出 $^{[4]}$，对称 SNE 的效果只是略微优于原始 SNE 的效果，依然没有从根本上解决问题。我们还需要解决 `拥挤问题`。\n\t\n- `拥挤问题`：就是说各个簇聚集在一起，无法区分。这是由于高维空间距离分布和低维空间距离分布的差异造成的。比如，有一高维度数据在降维到 10 维下可以有很好的表达，但是降维到两维后无法得到 \"可信\" 映射。\n\n\t进一步说明，假设一个以数据点 $x_i$ 为中心，半径为 $r$ 的 $m$ 维球 ( 三维空间就是球 )，其体积是按 $r^m$ 增长的，假设数据点是在 m 维球中均匀分布的，我们来看看其他数据点与 $x_i$ 的距离随维度增大而产生的变化。具体，我们可参考代码 $^{[3]}$：\n\t\n\t```python\n\timport numpy as np\n\tfrom numpy.linalg import norm\n\timport matplotlib.pyplot as plt\n\n\tnpoints = 1000\t# 抽取 1000 个 m 维球内均匀分布的点\n\tplt.figure( figsize=(20, 4) )\n\tfor i, m in enumerate((2, 3, 5, 8)):\n\t    # 这里模拟 m 维球中的均匀分布用到了拒绝采样\n\t    # 即先生成 m 维立方中的均匀分布，再剔除 m 维球外部的点\n\t    accepts = []\n\t    while len(accepts) < 1000:\n\t        points = np.random.rand(500, m)\n\t        accepts.extend(\n\t            [d for d in norm(points, axis=1) if d <= 1.0]\n\t        ) # 拒绝采样\n\t    accepts = accepts[:npoints]\n\t    ax = plt.subplot(1, 4, i+1)\n\t    ax.set_xlabel('distance') # x 轴表示点到圆心的距离\n\t    if i == 0:\n\t        ax.set_ylabel('count') # y 轴表示点的数量\n\t    ax.hist(accepts, bins=np.linspace(0., 1., 50), color='green')\n\t    ax.set_title('m={0}'.format(str(m)), loc='left')\n\tplt.show()\n\t```\n\n- 运行结果如图 2-1 所示。据图示反映，随着维度的增大，大部分数据点都聚集在 m 维球的表面附近，与点 $x_i$ 的距离分布极不均衡。若直接将这种距离关系保留到低维，肯定会出现拥挤问题。如何解决呢？这个时候就需要请出 $\\tau$ 分布了。\n\t\n\t![图2-1半径为 r 的 m 维球上的数据分布](/images/illustration/Project/2018/11/The-Best-Way-to-Visualize-a-Dataset-Easily_2-1.jpg)\n\t<center>图 2-1 半径为 r 的 m 维球上的数据分布</center>\n\n- 减轻 `拥挤问题` 的方法：在高维空间下我们使用 `高斯分布` 将距离转换为概率分布；在低维空间下，我们使用更加 `偏重长尾分布` 的方式来将距离转换为概率分布，使得高维度下中低等的距离在映射后能够有一个较大的距离。使用了自由度为 1 的 $\\tau$ 分布之后的 $q$ 变化，如下:\n\n\t$$\n\tq_{i,j} = \\frac{\n\t\t(1 + ||y^{(i)} - y^{(j)}||^2)^{-1}\n\t}{ \n\t\t\\sum_{k \\neq l} (1 + ||y^{(k)} - y^{(l)}||^2)^{-1}\n\t}\n\t\\tag{9}\n\t$$\n\t\n\t依然用 K-L 距离衡量两个分布之间的相似性，此时梯度变为：\n\t\n\t$$\n\t\\frac{\\delta C}{\\delta y_i} = \n\t4 \\sum_j ( p_{i, j} - q_{i, j})( y_i - y_j )(1 + ||y^{(i)} - y^{(j)}||^2)^{-1}\n\t\\tag{10}\n\t$$\n\t\n- `总结`：综上所述，从不对称的 SNE 算法到 t-SNE 算法，所做的改进工作：\n\t- 把 SNE 变为对称 SNE；\n\t- 在低维空间中采用了 $\\tau$ 分布代替原来的高斯分布，高维空间不变。\n\t- 具体算法步骤可参考了文章 [7] 的 [t-SNE](https://zhuanlan.zhihu.com/p/33722444) 图文解释，如图 2-2 所示。\n\n\t![图2-2t-SNE的算法步骤](/images/illustration/Project/2018/11/The-Best-Way-to-Visualize-a-Dataset-Easily_2-2.jpg)\n\t<center>图 2-2 t-SNE 的算法步骤</center>\n\t\n### 数据展示\n\n## 参考资料\n- [1] [微调. t-SNE 数据可视化算法的作用是为了降维还是认识数据. zhihu.com](https://www.zhihu.com/question/52022955/answer/387753267)\n- [2] [Chrispher. t-SNE 完整笔记 [OL]. datakit.cn. 2017](http://www.datakit.cn/blog/2017/02/05/t_sne_full.html#12-sne原理推导)\n- [3] [Bindog. 从 SNE 到 t-SNE 再到 LargeVis. bindog.github.io. 2016](http://bindog.github.io/blog/2016/06/04/from-sne-to-tsne-to-largevis/)\n- [4] Maaten L, Hinton G. Visualizing data using t-SNE [J]. Journal of machine learning r/esearch, 2008, 9(Nov): 2579-2605.\n- [5] Tang J, Liu J, Zhang M, et al. Visualizing large-scale and high-dimensional data[C]. International World Wide Web Conferences Steering Committee, 2016: 287-297.\n- [6] Tang J, Qu M, Wang M, et al. Line: Large-scale information network embedding[C]. International World Wide Web Conferences Steering Committee, 2015: 1067-1077.\n- [7] [徐小贱民. 降维技术解析：PCA, t-SNE and Auto Encoders. zhihu.com](https://zhuanlan.zhihu.com/p/33722444)\n- [8] [Bindog. t-SNE使用过程中的一些坑. jianshu.com. 2018](https://www.jianshu.com/p/631d6529e0df)","tags":["数据挖掘","数据可视化","Kaggle","t-SNE"],"categories":["Project"]},{"title":"讲座 | 如何轻松有效地预处理数据","url":"/2018/11/the-best-way-to-prepare-a-dataset-easily.html","content":"\n{% note default %}  \n作者：Siraj Raval  \n课堂：The Best Way to Prepare a Dataset Easily | [Bilibili](https://www.bilibili.com/video/av35419601) | [Youtube](https://www.youtube.com/watch?v=0xVqLJe9_CY)  \n源码：llSourcell.Prepare dataset challenge | [Github](https://github.com/llSourcell/prepare_dataset_challenge)  \n{% endnote %}\n\n本课堂的核心是讲述数据分析前夕的数据预处理过程，包括准备数据阶段和处理数据阶段。再具体以实例：通过大脑扫描公共数据集来建模、分析，预测某人是否在冥想。\n\n<!-- More -->\n\n## 更新进度\n- 2018.11.20：重新整理「数据预处理」章节，细化了预处理的细节，且重新整理了预处理的结构；\n\n## 准备数据\n- `准备数据阶段`：决定使用何种数据，这跟你试图解决的问题相关。\n- `关于数据来源`：能使用公共数据集解决的问题，尽量使用公共数据集。若公共数据集无法满足你的需求，引用毛主席的老话：没有条件便自己创造条件。即我们通过网络爬虫形式，把原始网页中的数据扒取下来，自己来 \"创造\" 数据集。\n\t- `公共数据集`：[Google 高级搜索](https://www.google.com/advanced_search?hl=zh-CN&fg=1)、[Kaggle](https://www.kaggle.com/)。\n\t- `网络爬虫`：网站提供 API 接口、Python 扒取网页数据。\n\n### 公共数据集\n#### 谷歌高级搜索\n- `官方网址`：[Google 高级搜索](https://www.google.com/advanced_search?hl=zh-CN&fg=1)\n- `使用方式`：顾名思义，即通过高级搜索的限制条件去获得更精确的搜索结果。具体地，我们侧重关注以下检索项，可获得意想不到的效果。\n\t- `关键字部分`：填写问题相关的关键词；\n\t- `网站或域名`：填写 `.edu`、`.gov`、`.org` 等，即为确保数据的权威可靠性，尽可能从教育、政府、组织机构中获取公共数据集；\n\t- `文件类型`：可指定为 csv ( 逗号分隔值 )、xls ( Microsoft Excel ) 等文件类型，Python 对 csv、xls 提供了较好的库支持，为了更便捷进行数据处理，则优先选择此类格式的文件。\n\n#### Kaggle\n- `官方网址`：[Kaggle](https://www.kaggle.com/)\n- `推荐理由`：Kaggle 由 Anthony Goldbloom 创立，主要为开发商和数据科学家提供举办机器学习竞赛、托管数据库、编写和分享代码的平台 ( [与谷歌达成合作关系](http://blog.kaggle.com/2017/03/08/kaggle-joins-google-cloud/) )。由此可见：\n\t- Kaggle 的每个竞赛都是独立的，无需设置项目范围然后收集数据，这让你有时间专注其它技能。\n\t- Kaggle 的每个数据集都有要解决的现实问题，要面向参与竞赛的人群，让参赛者更容易掌握业务知识和数据集的结构特征，因此数据集的描述是不可缺少的。\n\n\t\t> 不妨体验下 Kaggle 社区提供的入门案例 `泰坦尼克：灾难中的机器学习`，其相关的数据集描述：[Titanic: Machine Learning from Disaster](https://www.kaggle.com/c/titanic/data)\n\n- `入门指南`：参考文章 [机器之心. Kaggle 如何入门. zhihu.com](https://www.zhihu.com/question/23987009) 整理而得。\n\n\t- `选择一种编程语言`：你是一个毫无经验的新手，推荐 `Python`，因这是一种通用编程语言，你可以在整个流程中都使用它。\n\n\t- `学习探索数据的基础`：加载、浏览和绘制你的数据（`即探索性分析`）的能力，因为它可以为你将在模型训练过程中做的各种决策提供信息。  \n\n\t\t若你选择了 Python 路线，推荐使用专门为这个目的设计的 `Seaborn` 库。其中有高层面的绘图函数，可以绘制许多最常见和有用的图表。可参考资料：\n\n\t\t- [Seaborn 官网](https://seaborn.pydata.org/)\n\n\t\t- [Seaborn 教程. EliteDataScience.com](https://elitedatascience.com/python-seaborn-tutorial)\n\n\t\t- [机器之心. 数据科学相关的 Python 库介绍](https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650726730&idx=2&sn=89d176a782875afaafc69dd40cbee006&chksm=871b2534b06cac22a9235168a8d8867b97f795d2fba4435a2c7ec18b1039703903e4a79560bd&scene=21#wechat_redirect)\n\n\t- `训练你的第一个机器学习模型`：将数据集分成独立的训练集和测试集，交叉验证避免过拟合以及使用合适的表现评价指标。对于 Python，最好的通用机器学习库是 Scikit-Learn。可参考资料：\n\n\t\t- [Scikit-Learn 官网](https://link.zhihu.com/?target=http%3A//scikit-learn.org/stable/) | [Scikit-Learn 官方文档中文版](http://sklearn.apachecn.org)\n\n\t\t- [Scikit-Learn 教程. EliteDataScience.com](https://elitedatascience.com/python-machine-learning-tutorial-scikit-learn)\n\n\t\t- [机器之心. 从零开始掌握 Python 机器学习](https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650724242&idx=1&sn=703d242700e29813d6c482daf6b211c5&chksm=871b13ecb06c9afa28f8aad729496620078985e4eae8a1296fc407dbd70c1d70fabb3b2817fa&scene=21#wechat_redirect)\n\n\t\t- [Ben Hamner (Kaggle CTO). 机器学习的八个步骤](https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650725654&idx=4&sn=505ababb07a6bee5d42a6254a7493a7e&chksm=871b1968b06c907e9f84888ecb2ced8d3f52f0129720872e97f923b94deb34383eacefb4a5cf&scene=21#wechat_redirect)\n\n\t- `解决入门级竞赛`：[Getting Started](https://www.kaggle.com/competitions?sortBy=grouped&group=general&page=1&pageSize=20&category=gettingStarted) 竞赛非常适合初学者，因为它们给你提供了低风险的学习环境，并且还有很多社区创造的教程。\n\n\t\t> Kaggle 的竞赛分成四个类别：  \n\t\t> `Featured`：通常是由公司、组织甚至政府赞助的，奖金池最大。     \n\t\t> `Research`：研究方向的竞赛，只有很少或没有奖金。它们也有非传统的提交流程。  \n\t\t> `Recruitment`：这些是由想要招聘数据科学家的公司赞助的。目前仍然相对少见。  \n\t\t> `Getting Started`：这些竞赛的结构和 Featured 竞赛类似，但没有奖金。它们有更简单的数据集、大量教程和滚动的提交窗口让你可以随时输入。\n\n### 网络爬虫\n#### 网站 API\n- 当公共数据集无法满足我们的需求时，则需要自定义采集数据。而采集数据则通过网络爬虫实现。值得注意的是，并不是所有的网页，都需要我们花费大功夫去扒取获得，而是它们本身就提供了调用数据的 API。\n- 当然，也有 Github 大神搜集并整理了较实用的 API：[TonnyL. Awesome APIs](https://github.com/TonnyL/Awesome_APIs/blob/master/README-zh.md)\n\n#### 网页爬虫\n- [Beautiful Soup](https://www.crummy.com/software/BeautifulSoup/)：Beautiful Soup 是一个可以从 HTML 或 XML 文件中提取数据的 `Python` 库。\n- [Web Magic](http://webmagic.io/)：Web Magic 是一个简单灵活的 `Java` 爬虫框架。基于 WebMagic，你可以快速开发出一个高效、易维护的爬虫。\n\n## 处理数据\n- 为什么要对数据预处理：确保数据质量，以保证预测的结果更精确。而数据质量涉及许多因素，例如准确性、完整性、一致性、可信性和可解释性，针对不同的特性，都有对应的 `处理策略`。\n\n\t> 注意，数据预处理的主要任务之间存在许多重叠工作，若前面章节有阐述的，后面涉及的则略过。\n\n- 数据预处理的主要任务：\n\t- `数据清洗`：缺失值处理、光滑噪声数据、识别和删除离群点。\n\n\t\t> 关于数据清洗，也推荐阅读具有实操意义的一篇博文：[TowardsDataScience. How to Handle Missing Data](https://towardsdatascience.com/how-to-handle-missing-data-8646b18db0d4)\n\t\n\t- `数据集成`：多个数据源的数据合并，存放于同一个数据仓库中。\n\t\t- `实体识别问题`：来自多个信息源，各数据源中的实体之间如何匹配，这涉及实体识别问题。如不同数据来源于不同数据库中，现实意义上它们是同一实体，但它们属性的元数据表达却不同 ( 如主键 )。\n\t\t- `冗余和相关分析`：集成多个数据源，数据中可能有多组属性重复存在。而冗余可被相关分析检测到，如针对分类 ( 标称 ) 属性的卡方检验、数值属性的相关系数、数值属性的方差和协方差。\n\t\t- `元组重复`：元组级检测重复。\n\t- `数据归约`：在尽可能保持数据原貌前提下，最大限度精简数据量。策略包括：\n\t\t- `维归约`：也称为特征归约，减少所考虑的属性的个数。方法包括：小波变换、主成分分析、属性子集选择等。当然利用冗余和相关分析也是可行的。\n\t\t- `数量归约`：用替代的、较小的数据集表示形式替换原数据。方法包括：参数的方法，回归和对数线性模型；非参数的方法，聚类、降维、直方图、抽样和数据立方体聚集。\n\t- `数据变换`：主要思想是将数据变换或统一成适合数据挖掘的形式。方法可以是数据归一化、数据离散化、概念分层等。\n\t\t- `特征构造`：由给定的属性构造新的属性并添加至属性集中。\n\t\t- `聚集分解`：对数据进行 `汇总` 或者 `聚集`。如聚集日销售数据。与之相对的是 `分解`，如常见的 “日期” 属性，不同的需求，我们要解构的粒度是不同的。如预测当日的气温变化，则我们可把年和月份剔除。\n\t\t- `归一化`：针对每一个特征 ( 维度 )，去均值和方差归一化。即把属性数据按比例缩放，让所有特征在统一数量级上运作，如此一来数据指标之间就有了可比性。\n\t\t- `离散化`：把属性值的原始值用区间标签或者概念标签替换，即这些标签可递归地组织成更高层概念，导致数值属性的 `概念分层`。\n\t\t\n\t\t\t> 例如，我们\t对年龄进行分层：1 to 17 为 Adolescent；18 to 45 为 Adult；46 以上为 Senior。\n\t\n### 数据清洗\n- `缺失值处理`：某些实例数据中属性值为空，我们通过遍历数据集将其剔除。若数据集中存在大量实例含有缺失值的情况，则我们采用 `填补缺失值` 的方法。值得注意的是，根据不同情况，填补缺失值有多种方式：\n\t- 人工填写缺失值。\n\t- 使用全局常量填充缺失值：`N/A` 或者 $\\infty $。\n\t- 使用属性的中心度量：若是对称的数据分布，则使用均值；若是倾斜的数据分布，则使用中位数。\n\t- 使用最可能的值填充缺失值：回归、贝叶斯形式化的推理工具或决策树。\n\n\t\t> 某些情况下，缺失值并不意味数据有错误。例如在申请信用卡时，要求填写申请人的驾驶执照号，没有的人可填写 \"无\" 或者不填。\n\t\n- `光滑噪声`：噪声指数据中存在着错误或异常 ( 偏离期望值 ) 的数据，这些数据对数据的分析造成了干扰。我们可通过 `分箱`、`回归`、`离群点分析` 等噪声光滑技术来消除噪声。\n\t- `分箱`：考察数据的近邻 ( 周围的值 ) 来光滑有序数据值。\n\t- `回归`：用一个函数拟合数据来光滑数据。\n\t- `离群点分析`：五数概括 ( 中位数、四分位数、最大最小观测值 )、箱线图与离群点；或通过聚类来检测离群点。\n\n### 数据集成\n- `实体识别问题`：\n\t- 问题描述：来自多个信息源，各数据源中的实体之间如何匹配，这涉及实体识别问题。如不同数据来源于不同数据库中，现实意义上它们是同一实体，但它们属性的元数据表达却不同 ( 如主键 )。\n\t- 解决方法：每个属性的元数据包含名字、含义、数据类型和属性的允许值范围，以及处理空值的空值规则。这样的元数据可帮助我们避免模式集成的错误。\n- `冗余和相关分析`：这里讨论的冗余是对应于数据的属性 ( 特征 ) 层面讨论的。\n\t- 分类 ( 标称 ) 属性的 `卡方检验` ( $\\chi^2$ )，发现属性 A、B 之间的相关联系。\n\t- 数值数据的 `相关系数`：计算属性 A、B 之间的相关系数 ( 又称 Pearson 积矩系数 )，估计这两个属性的相关度。\n\t- 数值数据的 `协方差`：协方差和方差是两个类似的度量 ( 方差可理解为协方差的特殊形式 )，其作用是评述两个属性如何一起变化。\n\n### 数据归约\n- `维归约`：也称为特征归约，减少所考虑的属性的个数。\n\t- 通俗理解：即从原有的特征中删除不重要或不相关的特征。比如，某些实例数据中属性值与所研究的问题无关，我们可以选择性地剔除。\n\n\t\t> 本课堂实例中，是预测志愿者是否在冥想。而相关数据集呈现三种特征：精神专注度、冷静度以及志愿者的年龄。而志愿者是否发生冥想活动，很明显与性别无关，则可选择性地剔除该属性。\n\n\t- 方法包括：小波变换、主成分分析、属性子集选择等。当然利用冗余和相关分析也是可行的。\n\n- `数量规约`：用替代的、较小的数据表示形式替换原数据。\n\t- 通俗理解：即通过对特征进行重组来减少特征的个数。比如，某些实例数据中属性 ( 维度 ) 太多，我们人类大脑是难以理解它的，则我们可通过降维方法以及可视化工具，以二维或者三维的的形式复现数据 ( 的特征 )。\n\t- 方法包括：参数的方法，回归和对数线性模型；非参数的方法，聚类、降维、直方图、抽样和数据立方体聚集。\n\n### 数据变换\n- `归一化`：针对每一个特征 ( 维度 )，去均值和方差归一化。即把属性数据按比例缩放，让所有特征在统一数量级上运作，如此一来数据指标之间就有了可比性。\n- `离散化`：把值用区间标签或者概念标签替换，即这些标签可递归地组织成更高层概念，导致数值属性的 `概念分层`。\n\t- `数值属性`：在实际操作中，即把连续型特征的值离散化，使之成为少量的区间，每个区间映射到一个离散符号。这种技术的好处在于简化了数据描述，并易于理解数据和最终的挖掘结果。\n\t- `标称 (分类) 属性`：标称属性具有有穷多个不同值，且值之间无序。例如地位位置、年龄层次等。对于标称属性，我们需要人工定义概念分层。\n- `向量化`：当我们已基本完成数据处理阶段的工作，得到可供使用的数据集。那么紧接着的步骤，即把实例数据转换成 `特征向量` ( 向量是特征的数值表示形式 )，所有实例的特征向量组成 `特征矩阵`。然后，在 `Python` 中通过 `Numpy` 和 `Pandas` 包装，即实际上让 `narray` 数组成为特征矩阵的存储和运算的媒介。\n\n\t当完成以上流程后，数据预处理阶段即可告一段落，紧接着便可开始开始训练模型了。\n\n\t> 由于篇幅的缘故，数据预处理的讨论暂到此为止。当然，数据预处理的内容不仅如此，更详细的理论细节可参详 Jiewei Han 的《数据挖掘：概念与技术》$^{[1]}$。 而数据预处理在 Python 中如何实现，则参考 Keras 之父弗朗索瓦·肖莱的 《Python深度学习》$^{[2]}$。\n\n## 参考资料\n- [1] [Jiewei Han, Micheline Kamber and Jian Pei. 数据挖掘 (第三版) [M]. 机械工业出版社, 2018, 56-79.](https://book.douban.com/subject/2038599/)\n- [2] [弗朗索瓦·肖莱，张亮 (译). Python 深度学习 [M]. 人民邮电出版社, 2018, 80-82.](https://book.douban.com/subject/30293801/)","tags":["数据挖掘","Kaggle","数据预处理"],"categories":["Project"]},{"title":"多套软件解决方案助你提高生产力","url":"/2018/11/software-solution.html","content":"\n在输出本博文之初，意图是很纯粹的，即把平日里体验佳、少折腾、踩过坑的种种软件整理成册，以便于日后装机或朋友间安利、分享。\n\n再者，在平日的工作、娱乐环境中，单一的软件远远不够满足我们的需求。软件虽然一定程度上解放了我们的生产力，而随着个人的需求日益增长、消费水平升级，享受的服务逐渐被分散细化，我们的工作效率提升了，但人与软件更密切的交互让我们紧密地捆绑在一起，似乎我们并没有被真正意义地 \"解放\" 出来？其次，每款软件终究是一个体，一些连贯性的交互需求，它们是很难或无法独自完成的，故我们需要更高阶的完整软件解决方案。例如，智能路由系统 ( 网络中心 + 控制中心 )、个人博客 ( 笔记 + 储存 + 分享 )、个人私有云 ( 储存 + 远程 + 共享 )、智能家居控制中心 ( 跨平台 + 控制中心 )、家庭影院中心等。即我们通过专职的服务器，运作相应的操作系统和应用程序，以提供完整的软件解决方案。\n\n最后，谈起专职的服务器便是组装一台 `家用服务器`。在服务器中，我们可通过 `虚拟机` 实现私有云、智能路由系统、Web 服务器、代码托管服务器等，把以上系统方案整合到 N in 1 的服务器中，既充分重利用了硬件资源，同时也节约了房间的物理空间。\t\n<!-- More -->\n\n## 更新进度\n- 2018.10.22：完成初稿；\n- 2018.10.25：完成系统解决方案的「 个人博客解决方案 」章节内容；\n- 2018.11.02：更新「 常备软件清单 」章节内容；\n- 2018.11.03：更新「浏览器插件」章节内容；\n- 2018.11.05：完成系统解决方案的「代码托管方案：Svn」章节内容；\n- 2019.01.28：新增「信仰装机 」章节内容；\n- 2019.02.20：更新「信仰装机 」章节内容；\n- 2019.08.07：更新「办公利器 」和「浏览器插件」章节内容；\n\n## 办公利器：常备软件清单\n### 开篇引言\n- `选应用的意图`：常备软件清单，覆盖了办公、开发、设计、写作、影音、系统等几大类别的应用，且选应用的意图都是很明确的，即办公类应用，应尽可能地提升效率以提高生产力；娱乐类应用，应更便捷地交互体验以提升幸福感；系统类应用，应融洽地接入系统以焕发 Mac 本该拥有的强大本质。\n- `选应用的方法`：再者，为什么推荐这些应用，主要考虑因素是：\n\t- `方案一`：一方面是针对平台优化的独占平台应用，另一方面则是个人的主战装备是 Macbook Pro，故推荐应用以 `MacOS` 先入为主，再考虑替代方案；\n\t- `方案二`：则是 `全平台通用` 的方案。\n\t- `方案三`：总有功能性应用是独占平台的，遇到此情况则提供 `退阶方案`，即寻找同类功能的优秀应用作为替代方案。\n- `选应用的准则`：其次，我们秉承 `免费开源` 的理念来寻找高质量应用，但并不会一味追求免费而错过或放弃收费的应用。由于方案初制定，后期会不断补充内容，造成不便请谅解。\n\n### 影音媒体\n#### IINA\n- 应用类型：📺 | 媒体播放器\n- 是否收费：🆓 | 开源免费\n- 支持平台：`MacOS`\n- 官方地址：[IINA 中文](https://lhc70000.github.io/iina/zh-cn/) | [IINA 英文](https://lhc70000.github.io/iina/) | [Github 开源](https://github.com/lhc70000/iina)\n- 推荐理由：\n\t- 开源且完全免费  ( GPLv3 )；\n\t- 在线字幕搜索和智能本地字幕匹配；\n\t- 满足你关于视频、音频、字幕等相关的基本功能；\n\t- 基于 MPV ( 神级开源解码工具 ) 的媒体播放器，支持几乎所有常用媒体播放，且稳定解码并输出高质量的影像。\n\n#### MPV\n- 应用类型：📺 | 媒体播放器\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS` | `Windows` | `Linux` | `Android`\n- 官方地址：[MPV 介绍](https://mpv.io/) | [MPV 下载](https://mpv.io/installation/) | [MPV 手册](https://mpv.io/manual/master/) | [Github 开源](https://github.com/mpv-player/mpv)\n- 推荐理由：\n\t- 开源且完全免费 ( GPLv2 或更高版本 )；\n\t- IINA 的退阶产品，MPV 的特性与前者相仿，但支持多平台使用。\n\n### 媒体编辑\n#### Permute\n- 应用类型：📽 | 格式转换\n- 是否付费：💵 | 付费应用\n- 支持平台：`MacOS`\n- 官方地址：[Permute 官方](https://software.charliemonroe.net/permute/)\n- 推荐理由：\n\t- 主要与 [Downie](#Downie) 配合使用，用于网络流媒体的分段视频拼接、格式转换；\n\t- 作为媒体编辑应用，足够应付基本的视频、音频、图片格式转换；\n\t- 拖拽方式操作即可实现视频拼接、音轨视频一键合成。\n\n#### FFmpeg\n- 应用类型：📽 | 格式转换\n- 是否付费：🆓 | 免费开源\n- 支持平台：`MacOS` | `Windows` | `Linux`\n- 官方地址：[FFmpeg 官方](http://www.ffmpeg.org/) | [FFmpeg 下载](http://www.ffmpeg.org/download.html) | [FFmpeg 文档](http://www.ffmpeg.org/documentation.html)\n- 推荐理由：\n\t- 开源且完全免费  ( GPLv2 或更高版本、LGPLv2.1 或更高版本 )；\n\t- Permute 的退阶产品，而退阶并不是它功能比前者弱，而是它作为 `音视频的完整解决方案`，入门成本较高；\n\t- 跨平台剪辑、转码、合成音频和视频；\n\n#### X Lossless Decoder\n- 应用类型：📽 | 格式转换\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS`\n- 官方地址：[XLD 官方](https://tmkk.undo.jp/xld/index_e.html)\n- 推荐理由：\n\t- 音频发烧友少不了的利器：可解码、转换、播放各种“无损”音频文件 ( flac、oga、ape、wv、tta、m4a、tak、shn、aiff、wav 等 )；\n\t- 解码时可借助 `cue` 光盘映像辅助文件把音频文件分割成若干音轨 ( 单曲 )；\n\t- 支持 CD 音轨的抓取，并转换为目标格式 ( wav+cue, flac+cue 等 )；\n\n#### ArcTime\n- 应用类型：🎞 | 媒体编辑\n- 是否付费：💵 | 增值服务内购\n- 支持平台：`MacOS` | `Windows` | `Linux`\n- 官方地址：[ArcTime 官方](http://www.arctime.cn/zh/index.html) | [ArcTime 下载](http://www.arctime.cn/zh/download.html)\n- 推荐理由：\n\t- 跨平台的字幕制作软件；\n\t- 语音识别文字，机器翻译 ( 点击了解 [增值服务](http://arctime.cn/zh/service.html) )；\n\t- 导出多种字幕格式，且支持导出面向非编软件的软字幕；\n\t- 无缝支持所有主流非编软件的工程文件互导入、导出。\n\n### 高效办公\n#### MacDown\n- 应用类型：📝 | 文档编辑\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS`\n- 官方地址： [MacDown 官方](http://macdown.uranusjr.com/blog/macdown-help/) | [Github 开源](https://github.com/MacDownApp/macdown)\n- 推荐理由：\n\t- 开源且完全免费；\n\t- 稳定且渲染速度快；\n\t- 纯粹的 Markdown 文本编辑器，支持本地化管理 `MD` 文档 ( 即功能类似 Windows 的 TXT 文本编辑器 )。\n\n#### Typora\n- 应用类型：📝 | 文档编辑\n- 是否付费：🆓 | 免费应用\n- 支持平台：`MacOS` | `Windows` | `Linux`\n- 官方地址：[Typora 官网](https://www.typora.io/)\n- 推荐理由：\n\t- 纯粹的界面交互设计，没有多余元素的干扰，帮助你沉浸于写作本身。\n\t- 支持丰富的 `Github Flavored Markdown (GFM)` 语法，另外还支持表格、图表、TOC、LaTeX、代码块、任务列表等；\n\t- 丰富的 Markdown 导出配置，具体支持有：`html`、`epub`、`pdf`、`docx` 等。\n\n#### MWeb\n- 应用类型：📝 | 文档编辑\n- 是否付费：💵 | 付费应用\n- 支持平台：`MacOS` | `iOS`\n- 官方地址：[MWeb 官方](https://zh.mweb.im/) | [少数派评测](https://sspai.com/post/33855)\n- 推荐理由：\n\t- 苹果全家桶可支持多终端云同步、云办公；\n\t- 支持丰富的 `Github Flavored Markdown (GFM)` 语法，另外还支持表格、TOC、LaTeX、代码块、任务列表、脚注等；\n\t- 内建文档分类、文档贴标签功能，即支持快速检索文章内容，也支持一体化的文档管理；\n\t- 丰富的 Markdown 导出配置，具体支持有：`jpg`、`html`、`epub`、`pdf`、`rtf`、`docx`；\n\t- 支持一键发布功能，直接发布至 `Wordpress`、`印象笔记`、`Blogger` 等。\n\n#### Yu Writer\n- 应用类型：📝 | 文档编辑\n- 是否付费：🆓 | 免费应用 / 💵 | Pro 版本付费\n- 支持平台：`MacOS` | `Windows` | `Linux` ( 待上线 )\n- 官方地址：[Yu Writer 官网](https://ivarptr.github.io/yu-writer.site/)\n- 推荐理由：\n\t- 开源免费 ( 可付费升级至 Pro 版本 )；\n\t- MWeb 的退阶产品，功能几乎与 MWeb 一样，特色是多平台支持。\n\n### 设计工具\n#### Adobe Series\n- 应用类型：📐 | 设计套件\n- 是否付费：💵 | 付费应用\n- 支持平台：`MacOS` | `Windows`\n- 推荐理由：Adobe 全家桶，设计师必备套件。\n\n### 开发工具\n#### Parallels Desktop\n- 应用类型：🖥 | 虚拟机软件\n- 是否付费：💵 | 付费应用\n- 支持平台：`MacOS`\n- 官方地址：[PD 官网](https://www.parallels.com/cn/)\n- 推荐理由：Mac 上性能首屈一指的虚拟机工具。\n\n\t> 在自己的机器上，分别用 VMware 和 PD 测试运行 Windows 10，日常使用强度 ( 编码、浏览网页、看视频等 )。相比于 VMware，PD 运行流畅且发热程度更低。当然，一两台机器的测试结果并不具有参考性，故 PD 在 MacOS 上的优势可自行体验后再决定购入使用 ( 都有试用版本体验 )。\n\n#### VMware\n- 应用类型：🖥 | 虚拟机软件\n- 是否付费：💵 | 付费应用\n- 支持平台：\n\t- `MacOS`：支持产品 VMware  Fusion\n\t- `Window、Linux`：支持产品 Workstation Pro\n\t- `Window、Linux`：支持产品 Workstation Player\n- 官方地址：[VMware Fusion](https://www.vmware.com/cn/products/fusion.html) | [Workstation Pro](https://www.vmware.com/cn/products/workstation-pro.html) | [Workstation Player](https://www.vmware.com/cn/products/workstation-player.html)\n- 推荐理由： 跨平台虚拟化软件，即它可安装在 Windows、Linux、MacOS 的操作系统上使用。\n\n#### VirtualBox\n- 应用类型：🖥 | 虚拟机软件\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS` | `Windows` | `Linux`\n- 官方地址：[VirtualBox 官网](https://www.virtualbox.org/) | [VirtualBox 下载](https://www.virtualbox.org/wiki/Downloads) | [用户手册](https://www.virtualbox.org/wiki/End-user_documentation) | [开源手册](https://www.virtualbox.org/wiki/Technical_documentation)\n- 推荐理由：\n\t- 开源且完全免费；\n\t- 跨平台虚拟化软件，即它可安装在 Windows、Linux、MacOS 的操作系统上使用；\n\t- 可虚拟的操作系统包括 Windows、Mac OS X、Linux、OpenBSD、Solaris、IBM OS2、Android 等。\n\n#### DBeaver\n- 应用类型：🗄 | 数据库管理\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS` | `Windows` | `Linux`\n- 官方地址：[DBeaver 官网](https://dbeaver.io/) | [DBeaver 下载](https://dbeaver.io/download/) | [Github 开源](https://github.com/dbeaver/dbeaver/)\n- 推荐理由：\n\t- 开源且完全免费 ( 可付费升级 [企业版](https://dbeaver.com/) )；\n\t- `通用数据库管理工具` 和 `SQL 客户端`，支持 MySQL, PostgreSQL, Oracle, DB2, MSSQL, Sybase, Mimer, HSQLDB, Derby 及兼容 JDBC 的数据库。\n\t- 它可以处理任何的 `外部数据源` ( 数据源包含数据库服务器的名称和位置、数据库驱动程序以及在登录数据库时所需的信息 )。\n\n#### Sequel Pro\n- 应用类型：🗄 | 数据库管理\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS`\n- 官方地址：[Sequel Pro 官网](http://www.sequelpro.com/) | [Github 开源](https://github.com/sequelpro/sequelpro)\n- 推荐理由：\n\t- 开源且完全免费；\n\t- MacOS 平台独占应用，专门管理 `MySQL` 和 `MariaDB` 数据库的工具，操作界面非常友好，若仅是处理 MySQL 数据库，Sequel Pro 是你开发的最佳伴侣。\n\n#### FileZilla\n- 应用类型：📤 | 文件传输\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS` | `Windows` | `Linux`\n- 官网网址：[FileZilla 官方](https://filezilla-project.org/) | [FileZilla 客户端](https://filezilla-project.org/download.php?type=client) | [FileZilla 服务端](https://filezilla-project.org/download.php?type=server) | [源代码](https://filezilla-project.org/sourcecode.php)\n- 推荐理由：\n\t- 开源且完全免费 ( 可付费升级 [企业版](https://filezillapro.com/) )；\n\t- 跨平台的 `FTP` 解决方案，支持 FTP、FTPS、SFTP 等文件传输协议；\n\n#### CornerStone\n- 应用类型：⌨️ | 代码管理\n- 是否付费：💵 | 付费应用\n- 支持平台：`MacOS`\n- 官方地址：[CornerStone 官网](https://cornerstone.assembla.com/)\n- 推荐理由：面向 Svn ( 开放源代码的版本控制系统 )，即 CornerStone 是一款拥有界面交互的 Svn 客户端。\n\n#### TortoiseSVN\n- 应用类型：⌨️ | 代码管理\n- 是否付费：🆓 | 开源免费\n- 支持平台：`Windows`\n- 官方地址：[TortoiseSVN 官网](https://tortoisesvn.net/) | [TortoiseSVN  下载](https://tortoisesvn.net/downloads.html)\n- 推荐理由：面向 Svn ( 开放源代码的版本控制系统 )，即 TortoiseSVN 是一款拥有界面交互的 Svn 客户端。\n\t\n#### Git GUI Clients\n- 应用类型：⌨️ | 代码管理\n- 是否付费：🆓 | 免费使用\n- 支持平台：`MacOS` | `Windows` | `Linux` | `Android` | `iOS`\n- 官方地址：[Git 官网](https://git-scm.com/) | [Git 下载](https://git-scm.com/downloads/guis)\n- 推荐理由：面向 Git ( 开源的分布式版本控制系统 )，即 Git GUI 是一款拥有界面交互的 Git 客户端。\n\n#### Dash\n- 应用类型：⌨️ | API 文档\n- 是否付费：🆓 | 付费应用\n- 支持平台：`MacOS`\n- 官方地址：[Dash 官网](https://kapeli.com/dash)\n- 推荐理由： API 文档浏览器以及代码片段管理器，涵盖 200+ 种语言的 APIs（几乎涵盖常见的开发语言），离线查询、阅读，实属开发工具序列的一大 \"利器\"。\n\n### 网络工具\n#### Downie\n- 应用类型：📥 |  网络下载\n- 是否付费：💵 | 付费应用\n- 支持平台：`MacOS`\n- 官方下载：[Downie 官方](https://software.charliemonroe.net/downie.php) | [少数派评测](https://sspai.com/post/40999)\n- 推荐理由：\n\t- 超过 1000+ 流媒体网站的视频下载 ( YouTube、Vimeo、Bilibili、优酷、爱奇艺等 )；\n\t- 直接拖拽链接即可下载，但注意部分视频源以分片段形式下载，与 [Permute](#Permute) 搭配使用即可；\n\t- 内置资源搜索功能。\n\n#### Motrix\n- 应用类型：📥 |  网络下载\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS` | `Windows` | `Linux`\n- 官方下载：[Motrix 英文](https://github.com/agalwood/Motrix) | [Motrix 中文](https://github.com/agalwood/Motrix/blob/master/README-CN.md)\n- 推荐理由：\n\tMotrix 是一款全能的下载工具，支持下载 HTTP、FTP、BT、磁力链、百度网盘等资源。\n\n#### Free Download Manager\n- 应用类型：📥 |  网络下载\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS` | `Windows`\n- 官方下载：[FDM 官方下载](https://www.freedownloadmanager.org/zh/download.htm) | [异次元评测](https://www.iplaysoft.com/fdm.html)\n- 推荐理由：\n\t- 老牌的资源下载软件，开源无广告，交互逻辑简单；\n\t- 支持 BT、FTP HTTP 的资源下载；\n\t- 支持批量下载、断点续传、捕获 HTTP 链接、FTP 目录浏览等功能。\n\n\t\t> `断点续传`：FDM 下载时会自动将文件切割成 N 个区块同时进行多线程下载来显著提高下载速度。即便下载途中遇到断线等问题，通过内建的断点续传机制恢复并接续原来的下载。\n\n### 系统补全\n#### Xcode\n- 应用类型：⚙️ | 系统内置 ( 包含大部分应用所需要的运行环境 )\n- 是否付费：🆓 | 免费使用\n- 支持平台：`MacOS`\n- 推荐理由：\n\t-  用于 MacOS 和 iOS 应用程序开发的集成开发工具 ( IDE )；\n\t- 既使不以开发者角度考虑，它包含了大部分应用运行所需要的依赖库 ( 运行环境 )，推荐安装。\n\n#### Automator\n- 应用类型：⚙️ | 系统内置\n- 是否付费：🆓 | 免费使用\n- 支持平台：`MacOS`\n- 官方地址：[Automator 官方](https://support.apple.com/zh-cn/guide/automator/welcome/mac) | [少数派评测](https://sspai.com/post/36667)\n- 推荐理由：iOS 上大名鼎鼎的 `Workflow`、`捷径`，相信大伙不会陌生，而作为提升工作效率的神器，在 Mac 端也同样有替代的方案，它就是 `Automator` ，俗称 \"扛炮\"。\n\n#### iStatistic\n- 应用类型：🌡 | 系统监控\n- 是否付费：💵 | 付费应用\n- 支持平台：`MacOS` | `iOS`\n- 推荐理由：\n\t- 系统监测软件，包括性能、能耗及温度情况监测；\n\t- 动态化、图表化显示数据 ( 支持 Web DashBoard )，喜欢装机的朋友不妨在机箱内挂小屏幕做展示，科技感十足。\n\n#### 加速大师\n- 应用类型：🌡 | 系统优化\n- 是否付费：🆓 | 免费使用\n- 支持平台：`MacOS`\n- 官方地址：暂无 ( 只能从 [Mac App Store](https://itunes.apple.com/cn/app/%E5%8A%A0%E9%80%9F%E5%A4%A7%E5%B8%88/id1144825078?mt=12) 中下载，请认准小火箭的图标。但后面发现作者以另一款软件 [iCare 3](https://itunes.apple.com/cn/app/icare-3/id1142437192) 更新项目 )\n- 推荐理由：\n\t- 轻量级系统垃圾清理工具，卸载管理工具，开机自启项管理工具；\n\t- 支持性能监测 ( 内存、CPU、网络 I/O ) 和内存释放的功能；\n\n#### Keka\n- 应用类型：📦 | 解压缩工具\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS`\n- 官方地址：[Keka 官网](https://www.keka.io/zh-cn/) | [Github 开源](https://github.com/aonez/Keka)\n- 推荐理由：\n\t- 开源且完全免费 ( GPL )；\n\t- MacOS 平台独占应用，支持 `解、压缩` 文件；\n\t- 且支持 `7z` 文件和 `Zip 2.0` 文件使用 `AES-256` 加密 ；\n\t- 可支持创建 7Z, ZIP, TAR, GZIP, BZIP2, XZ, LZIP, DMG, ISO 格式文件；\n\t- 可支持解压 7Z, RAR, TAR, GZIP, BZIP2, XZ, LZIP, DMG, ISO, LZMA, EXE, CAB, WIM, PAX, JAR, APK, APPX, CPGZ, CPIO 格式文件。\n\n#### 7-Zip\n- 应用类型：📦 | 解压缩工具\n- 是否付费：🆓 | 开源免费\n- 支持平台：`Windows` | `Linux`\n- 官方地址：[7-Zip 官网](https://www.7-zip.org/) | [7-Zip 下载](https://www.7-zip.org/download.html)\n- 推荐理由：\n\t- 开源且完全免费 ( LGPL )；\n\t- 国内的解压缩工具不敢恭维，不谈性能，内嵌广告行为就是耍流氓；\n\t- 可支持解、压缩格式：7z, XZ, BZIP2, GZIP, TAR, ZIP, WIM\n\t- 仅可解压格式：ARJ, CAB, CHM, CPIO, CramFS, DEB, DMG, FAT, HFS, ISO, LZH, LZMA, MBR, MSI, NSIS, NTFS, RAR, RPM, SquashFS, UDF, VHD, WIM, XAR。\n\n### 论文写作\n#### Mathpix snipping tool\n- 应用类型：🔢 | 数学公式\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS` | `Windows` | `Linux` | `iOS` | `Android`\n- 官方地址：[Mathpix 官网](https://mathpix.com/)\n- 推荐理由：\n\t- `截图` 或者 `拍照` 即可实现数学公式的识别功能，并转化为 `LaTeX`；\n\t- 众多大牛的力荐 ( 比较风趣的软件介绍，不要较真哈 )：\n\n\t\t![](/images/illustration/Project/2018/11/Software-Solution_mathpix_intro.png)\n\t\t\n\t\t<center>Mathpix 官方介绍</center>\n\n\n## 需求升级：系统解决方案\n### 开篇引言\n- 完整软件解决方案：运作相应的 `操作系统` 和 `应用程序`，以提供完整的软件解决方案。\n- 下述所有 `解决方案`，原则上可在一台服务器实现的。实现原理即服务器上多开 `虚拟机`，让每台虚拟机各司其职，运作相应的 `操作系统` 和 `应用程序`，提供相应的功能或服务。\n- 这也是近些年想达成的小目标：感谢 liuspy 的文章 $^{[1]}$ 启发，才有想法去组一台 `家用服务器`，实现 `个人私有云 (黑群晖)`、`软路由 (OpenWrt/iKuai)`、`Web 服务器`、`代码托管服务器` 等。当然，在条件允许情况下，尽量把攒机过程中所做过的调研资料整理并输出文章，以便同样有折腾需求的朋友复用。\n  \n### 路由系统解决方案\n- 需求定位：突破普通路由器诸多的瓶颈和限制，除了享受高性能的网络体验，且获得更高阶的 `服务体验` 和 `玩法`。\n\t\n\t> 关于服务体验和玩法，具体可参考市面上的智能路由产品，它们表现的花样已经足够多了，如 `科学上网`、`去广告`、`文件服务器 (FTP/SMB)`、`运行 Python 程序` 等，有兴致的朋友可以自行了解详情。\n\n\t- 路由系统可分为软路由和硬路由，在介绍前夕，先弄明白两者的 `概念` $^{[2, 3]}$：\n\t\t- `软路由`：指利用台式机或服务器配合软件 ( 虚拟机 ) 而形成的路由解决方案。简单理解，即 `PC + 操作系统 ( Linux / Windows )  + 专用路由程序` 组成的路由解决方案；\n\t\t- `硬路由`：采用特定的硬件设备，基于嵌入式系统架构，以自行开发或是现成的嵌入式操作系统配合自行开发的路由软件，提供专门的路由器功能。当然，也可理解为 `厂家推出的整体路由解决方案`，例如网件、华硕、华为、小米、TP-LINK 等生产的路由产品。\n\n\t- 事实上，路由其实没有软、硬之分，任何路由器都由处理器、内存、路由程序存储器、网络接口模块、电源模块、输入输出部分与系统构成的。\n\n\t\t而区分两者的概念，主要是为了更精确定位，尽量在满足自己性能需求的前提下，最大化地 `节约硬件成本` 和 `运作成本` ( 主要是耗电成本 )。\n\n- `涉及系统`：根据路由的形式，硬件架构、系统架构是不同的，故各有自适用的路由系统，选择正确的路由系统以发挥其最大效能。\n\t- 针对软路由：[OpenWrt (LEDE)](https://openwrt.org/start?id=zh/start)、[iKuai]()、[海蜘蛛](http://www.hi-spider.com/zh)、[梅林 (koolshare)](http://firmware.koolshare.cn/LEDE_X64_fw867/)\n\t-  针对硬路由：[OpenWrt (LEDE)](https://openwrt.org/start?id=zh/start)、[Padavan (荒野无灯)](http://p4davan.80x86.io/)、[梅林 (支持硬件有限)](http://firmware.koolshare.cn/)\n\n- `涉及硬件`：硬路由器的硬件架构则是专为路由器而设计的，而软路由器的硬件架构是通用的，故我们只能针对软路由器的方案制定 `硬件需求方案`，考虑本章节的主题是路由器，则硬件需求方案将留至 `装机篇章` 讲述。\n\n- 搭建流程：\n\n### 个人博客解决方案\n- 需求定位：\n\t- 纯粹的图文静态博客，仅以内容即可驱动的博客载体，且不需要额外的运营成本 ( 团队运营、服务器等 )。\n\t- Hexo 博客框架的免费开源性质，官方提供强大的 API，还有丰富的社区资源 ( 教程、插件、主题等 )，基本能满足你的个性化服务和需求。\n\t- Hexo 支持 Markdown，上百页面秒级的渲染速度，一键即可部署至 Github。\n\n- 涉及框架：`Hexo`\n\n- 涉及技术：分布式版本控制系统 `Git`。而这里，使用到的主要功能是代码托管，而托管平台我们选择 `Github` ( 当然限于国内的访问速度，你可同时部署多个平台，例如：[Coding](https://coding.net/)、[Gitee](https://gitee.com/)\n\n- 搭建流程：\n\t- 📖 | [Hexo. 官方使用文档. hexo.io](https://hexo.io/zh-cn/docs/) \n\t- 📝 | [Kofe. 基于 Hexo 框架在 Github 上搭建博客. kofes.cn](https://www.kofes.cn/2018/01/Hexo-Installation-Guide.html)\n\t- 📝 | [Panbaixin. Hexo + Github 搭建个人博客. baixin.io](http://baixin.io/2015/08/HEXO搭建个人博客/)\n\t- 📝 | [C.J.Scarlett. How to Create a Blog with Hexo On Ubuntu. digitalocean.com]()\n\n### 个人私有云解决方案\n暂未定更新日期。\n\n### 跨平台智能家居方案\n暂未定更新日期。\n\n### 科学上网解决方案\n暂未定更新日期。\n\n### 虚拟专用网络方案\n暂未定更新日期。\n\n### 代码托管方案：Svn\n- 需求定位：作为 `集中式` 源代码版本控制系统，其适合于企业内部由项目经理统一协调的多个并行项目的开发。有趣的是，更甚有企业把 Svn 当作云端文件夹，毕竟其入门门槛比较低。而在 Git 盛行的环境下，我们学习 Svn 的理由更多的是适应公司的开发模式。至于 Svn 与 Git 的优劣，还是视具体使用环境而言，有兴趣可以参阅参考文章 [4]，其中描述了 Git 与 Svn 的详细对比，它们各自的优劣心中自有标准。  \n- 涉及技术：集中式的源代码版本控制系统 `Svn`。\n- 涉及软件：\n\t- 服务端：[Widnows Server](https://www.visualsvn.com/server/download/)\n\t- 客户端：[TortoiseSVN for Windows](https://tortoisesvn.net/downloads.html) | [Cornerstone for MacOS](https://cornerstone.assembla.com/)\n- 搭建流程：\n\t- 📝 | [Kofe. SVN 环境搭建与使用. kofes.cn](https://www.kofes.cn/2018/08/building-a-svn-server.html)\n\n### 代码托管方案：Git\n暂未定更新日期。\n\n\n## 好马配好鞍：浏览器插件\n### Violentmonkey\n- 插件性质：辅助\n- 支持平台：`Chrome` | `Firefox` | `Opera` | `Maxthon`\n- 官方地址：[Violentmonkey 官网](https://violentmonkey.github.io/) | [Violentmonkey 下载](https://violentmonkey.github.io/get-it/) | [Github 开源](https://github.com/violentmonkey/violentmonkey)\n- 推荐理由：开源的用户脚本管理器。\n\n\t> 用户脚本是什么：是一段代码，它们能够优化您的网页浏览体验。安装之后，有些脚本能为网站添加新的功能，有些能使网站的界面更加易用，有些则能隐藏网站上烦人的部分内容。\n\n- 脚本库：[GreasyFork](https://greasyfork.org/zh-CN) | [OpenUserJs](https://openuserjs.org/)\n\n- 优秀脚本推荐：\n\t- [本地 Youtube 下载器](https://greasyfork.org/zh-CN/scripts/369400-local-youtube-downloader)：不需要透过第三方的服务就能下载 YouTube 影片。当然，Youtube 的高码率 ( 1080P、1440P、2160P ) 的媒体是音频、视频分体的，具体可使用 [FFmpeg](#FFmpeg) 或 Premiere、Final Cut、iMovie 等视频编辑工具合成。\n\t- [网盘自动提取提取码](https://greasyfork.org/zh-CN/scripts/18733-网盘提取工具)：网盘自动提取、输入提取码，省心、省力、不折腾。\n\n### Tampermonkey\n- 插件性质：辅助\n- 支持平台：`Chrome` | `Firefox` | `Opera` | `Edge` | `Safari` | `Dolphin`\n- 官方地址：[Tampermonkey 官网](https://tampermonkey.net/) | [谷歌应用商店](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?utm_source=chrome-ntp-icon)\n- 推荐理由：用户脚本管理器。\n\n### 广告终结者\n- 插件性质：辅助\n- 支持平台：`Chrome` | `360 浏览器` | `搜狗浏览器` | `UC 浏览器` | `猎豹浏览器` | `百度浏览器`\n- 官方地址：[官方网站](http://www.adtchrome.com/) | [谷歌应用商店](https://chrome.google.com/webstore/detail/广告终结者/fpdnjdlbdmifoocedhkighhlbchbiikl?utm_source=chrome-ntp-icon)\n- 推荐理由：\n\t- 可过滤网页中几乎所有的横幅、弹窗、视频广告；\n\t- 手动屏蔽网页广告：最喜欢的功能之一，\"以氓治氓\" 形容也不为过哈。\n\n### 谷歌学术搜索按钮\n- 插件性质：辅助\n- 支持平台：`Chrome`\n- 官方地址：[谷歌应用商店](https://chrome.google.com/webstore/detail/google-scholar-button/ldipcbpaocekfooobnbcddclnhejkcpn?utm_source=chrome-ntp-icon)\n- 推荐理由：快速检索学术论文、文献，一键下载，一键导出多种标准的引用格式；\n\n### Youtube 本地下载器\n- 插件性质：辅助\n- 支持平台：`Chrome` | `FireBox`\n\t\n\t> 需要预装用户脚本插件方可使用，比如 `Violentmonkey`、`Tampermonkey` 等。\n\n- 官方地址：[Greasy Fork](https://greasyfork.org/zh-CN/scripts/369400-local-youtube-downloader)\n- 推荐理由：\n\t- 让你不通过第三方服务来下载 YouTube 影片的简单脚本。\n\t- 支持下载 1080p、1440p 以及 2160p 画质的影片。\n\n\t\t> 注意： 1080p 以上影片的需要从 `Adaptive `栏目下载，但自适应 adaptive 的影片和声音是分开的，若要拿到完整的 1080p 影片，你需要自己把它合并。自己平时使用的合成软件是 `Premiere`，或者使用 `FFmpeg` 命令行合成影片和音频。\t\n\t\n## 信仰装机：学娱并进 PC\n### 需求定义\n- `价格`：不谈价格选配置，浪费时间不止且无意义。为此，我们控制在 8.0k 到 11.4k 的价格区间内，不追求一步到位，可迭代式升级硬件以达成装机目标。具体地，装机计划以阶段目标执行：\n\t\n\t- `第一阶段` (5.3k-8.1k)：机箱 (0.4k-1.0k)，主板 (1.0k-1.5k)，CPU (1.8k-2.3k)，电源 (0.6k-0.8k)，M.2 512GB 固态硬盘 (0.4k-0.8k)，8GB 内存 (0.5k-0.9k)，散热 (0.6k-0.8k)\n\t- `第二阶段` (2.7k-4.0k)：显卡 (2.5k-3.5k)，风扇 (0.2k-0.5k)\n- `第三阶段` (1.5k-2.2k)：屏幕 (1.5k-2.2k)\n\t\n\t\t> 提示：各硬件的售卖价格主要参考各硬件的京东旗舰店定价，且有效统计截止于 2019 年 3 月。\n\t\n- `外观`：基于工作环境的因素考量，首先偏向于 ITX 规格或者适中 M-ATX 规格的机箱；再者是材质方面，钢化玻璃侧透机箱或铝制机箱，且前者可考虑加入 RGB 灯光系统。\n\n\t> 机箱规格分别有：ITX，M-ATX，ATX $^{[5]}$。\n\n- `硬件`：\n\t- `机箱`：中等紧凑型，再考虑标准型 ( 兼容 ATX 的小机箱 )；优先考虑钢化玻璃侧透机箱，再到一体成型铝材机箱。\n\t- `主板`：华硕 ROG 系列，没有超频需求；接口支持丰富；包含 WI-FI 以及蓝牙模组；mATX、ITX 规模的主板 ( 从左到右的优先顺序 )。\n\t- `处理`：盒装 CPU ( 主要考虑 CPU 体质问题，买散装还是有一定风险的 )。\n\t- `电源`：充足的功率支持，便于日后升级之需。注意机箱对电源尺寸的硬性要求。\n\t- `硬盘`：M.2 SSD 512GB；2T 希捷机械盘 7200 转。\n\t- `内存`：不限条件，自由选择。功率在 2666-3200 足矣。\n\t- `散热`：尽可能静音；支持华硕 AURA 灯光同步系统。\n\t- `显卡`：限定为 NVDIA ，且 CUDA 程序良好支持、Tensorflow 良好支持的显卡。\n\t- `屏幕`：2k 分辨率，23.8 / 27 尺寸，当然资金充足可考虑 HDR 10。\n\n### 装机预习\n- [知乎问题. DIY 装机有哪些误区. zhihu.com](https://www.zhihu.com/question/35911743)\n- [3DMGAME. 电脑检测跑分工具大全. 3dmgame.com](https://dl.3dmgame.com/patch/paofenruanjian.html)\n- [卖一手. 台式机电源选购经验篇一：品牌、代工及选购点. 2015. smzdm.com](https://post.smzdm.com/p/106088/)\n- [子希兄弟. 超详细电脑组装、电脑安装教程教学. 2018. bilibili.com](https://www.bilibili.com/video/av25211498)\n\n### 硬件挑选\n- `机箱`：\n\t-  Sunmilo BG2 黑红色版 ( MOD 机箱 )\n\t\n\t\t> [Sunmilo. 官方样张. taobao.com](https://item.taobao.com/item.htm?spm=a1z10.1-c.w4004-9691348913.8.65186580AZGN5m&id=538855908500) | [Griffyn. 桌面 show. chiphell.com](https://www.chiphell.com/thread-1933774-1-1.html)\n\t- 乔思伯 RM3 标准版，其中此型号还有炫彩灯光的版本，支持订制铭牌。\n\n\t\t> 关于 RM3 的样机演示可参考官网搜集的评测集：[RM3 评测集](http://www.jonsbo.com/products/qiaosiboRM3ban.html)\n\t\n- `主板`：华硕 ROG B360/Z370/H370 系列 + I/G/F Gaming\n\t- `选择什么系列` $^{[6]}$：主板是衔接所有硬件的媒介，结合需求选择适用的主板。\n\t\t- Z370、Z390 是针对是否有超频需求的产品，需求不强则选择 B360。\n\t\t- H370 主打的是扩展性。其定位很尴尬，若你选择 iTX / mATX 规格的主板，考量性能差距、价格差距则没有必要上 H370。\n\t- `具体型号说明`：F 为 ATX 规格主板，含 RGB 灯效模块；I 为 ITX 规格主板，含 RGB 灯效模块；G、H，分别是 mATX 和 ATX 规格主板，但不含 RGB 模块，价格相对最便宜。当然，是否需要 PCIe 拓展槽也是需考量的因素。\n\t- `明确最终需求`：对以上主板型号有了宏观认识后即可挑选具体的主板。\n\t\t- 首先，明确需要组装机的规格为 ITX / mATX，同样限制了主板尺寸大小；\n\t\t- 其次，我们要打造一套灯光系统，故华硕的 `AURA` 神光同步是不可缺少的；\n\t\t- 最后，选择 `华硕 ROG B360-I Gaming` / `华硕 TUF Z390M Pro`。\n- `电源`：因为小机箱缘故，且要求走背线，故金牌全模组电源是必须的。\n\t- EVGA G3 金牌全模组 650W\n\t- 海韵 550W 金牌全模组 FOCUS+ 550FX\n\t- 海盗船 SF600  金牌全模组 600W\n- `CPU`：Intel i7 8700 \n- `内存`：支持 AURA 灯效的内存，频率保持 2666-3200 Hz 水平左右。\n\t- 十铨 DDR4 3200 RGB 灯条 8GB \\* 2\n\t- 芝奇 DDR4 3200 幻光戟 8GB  \\* 2\n- `硬盘`：\n\t- `固态`：浦科特  M9PeG 512GB M.2 NVMe\n\t- `机械`：希捷 ST2000DM008 2TB 7200 SATA\n- `散热`：\n\t- 利民 银箭 130 Plus + NF-A12  2000 PWM 散热风扇 * 1\n\t- 猫头鹰 D15S 石墨烯版本 + NF-A14 1500 PWM 散热风扇 * 1\n- `风扇`：MOD 定制的机箱，用于机箱的风扇需要 5 个。\n\t- 机箱底进风：猫头鹰 NF-A12x15 散热风扇 * 2\n\t- 机箱后排风：猫头鹰 NF-A8 2200 PWM 散热风扇 * 2\n- `显卡`：Nvida GeForce RTX 2070\n\n\t> Nvida RTX 2070 是综合考虑机箱兼容性和颜值的选择，显卡环节可根据自己的需求和经济能力选择合适的。\n\t\n- `屏幕`：联想 T24h\n\n### 购买渠道\n- 基于价格、供货渠道、维修售后保障，选择购买硬件的电商平台：\n\t- 淘宝：机箱、线材\n\t- 京东：主板、电源、内存、硬盘、散热、风扇、显示器、CPU、显卡\n\t- 闲鱼：显示器\n\n### 案例搜集\n- 关于装机的案例，主要围绕以下需求进行搜集：\n\t- 基于工作环境的因素考量，首先偏向于 ITX / mATX 规格的案例。\n\t- 机箱是钢化玻璃材质侧透机箱，拥有透视内部结构效果，考虑 RGB 灯光系统，且注重 RGB 系统的可控性。\n\t- 注重走线工整性，最理想的则是包含安装过程与教程的案例。\n\n#### ITX 规格\n- 案例：[80it电脑网. 灵魂走线系列19. 2018. bilibili.com](https://www.bilibili.com/video/av35835083)\n\t- 机箱：迎广 in win A1 ( ITX )\n\t- 主板：华硕 Strix ROG Z390-I Gaming ( mini-ITX )\n\t- 电源：海盗船 SF600 全模组\n\t- CPU：Intel i7 9700k\n\t- 内存：芝奇 Trident Z RGB * 3\n\t- 硬盘：三星 M.2 SSD 970 EVO 500GB\n\t- 显卡：华硕 Strix ROG 2080 8G 猛禽\n\t- 散热：华硕 ROG 龙王 120 ( CPU 散热 )\n\t- 风扇：海盗船 LL120 RGB * 3 ( 机箱散热 )\n- 案例：[ITX实验室. ITX 业界标杆 MK3S & StarWars 主题装机. 2019. bilibili.com](https://www.bilibili.com/video/av41426930)\n\t- 机箱：MK3S 定制机箱 ( 工期很长，必须有很强信仰才敢买啊 )\n\t- 主板：华擎 Z390 ITX 幻影电竞\n\t- 电源：海盗船 SF600 全模组\n\t- CPU：Intel i7 9900k\n\t- 内存：十铨 王者之剑 夜鹰 RGB\n\t- 硬盘：惠普 M.2 SSD EX920 1TB\n\t- 显卡：TITAN XP Starwars 限定\n\t- 散热：利民 银箭130 + 猫头鹰 NF-F12 industrialPPC-3000 PWM ( CPU 散热 )\n\t- 风扇：Tt Luna 8cm RED RGB * 2 ( 机箱散热 )\n- 案例：[FUSION II. 极限性能TX迷你小钢炮装机摄影. 2017. bilibili.com](https://www.bilibili.com/video/av16513351) \n\t- 机箱：NCASE M1 ( ITX )\n\t- 主板：微星 Z370I Pro CarBon AC ( mini-ITX )\n\t- 电源：海盗船 SF600 全模组\n\t- CPU：Intel i5 8600k\n\t- 内存：海盗船 白金统治者 16G 2666MHz * 2\n\t- 硬盘：三星 M.2 SSD 960 EVO 250GB\n\t- 显卡：EVGA GTX1080TI SC2\n\t- 散热：猫头鹰 D9L ( CPU 散热 ) \n\t- 风扇：EK Vardar EVO 12cm 2200RPM ( 机箱散热 )\n\n#### mATX 规格\n- 案例：[FUSION II. 价值$3300美刀极限性能装机. 2018.bilibili.com](https://www.bilibili.com/video/av21497419)\n\t- 机箱：Meshify C Mini\n\t- 主板：华擎 X399M 太极 ( mATX )\n\t- 电源：海盗船 SF600 全模组\n\t- CPU：Intel i5 8600k\n\t- 内存：海盗船 复仇者 8GB DDR4 3000 MHz * 2\n\t- 硬盘：三星 M.2 SSD 960 EVO 250GB\n\t- 显卡：EVGA GTX1080TI SC2\n\t- 散热：安耐美 LiqTech TR4 240 一体水冷散热器 ( CPU 散热 )\n\t- 风扇：酷冷至尊 MasterFan Pro 120 RGB 风扇套装 ( 机箱散热 )\n\n\t\t> 本套方案包含安装过程的详细解说以及走线演示，推荐观看。\n\t\n- 案例：[Okeydokey科技. 超干净的无RGB恩杰装机. 2018.bilibili.com](https://www.bilibili.com/video/av32759959)\n\t- 机箱：恩杰 H400i\n\t- 主板：华硕 ROG Strix Z370-G ( mATX )\n\t- 电源：海盗船 RM650X 全模组电源\n\t- CPU：Intel i7 8700k\n\t- 内存：十铨 DARK PRO 32GB DDR4\n\t- 硬盘：三星 M.2 SSD 960 EVO 250GB\n\t- 显卡：EVGA GTX 1080 Ti SC2\n\t- 散热：EK Coolstream 280mm ( CPU 水冷散热 )\n\t- 散热：猫头鹰 NH-U9S + NF-B9 \\* 2 ( CPU 风冷散热 )\n\t- 风扇：EK Vardar EVO 120mm \\* 2 + 140mm \\* 2 ( 机箱散热 )  \n\n\t\t> 本套方案尝试了两套散热系统，分别是猫头鹰的风冷套装和 EK 的水冷套装。\n\n## 参考资料\n- [1] [Liuspy. 千元 DIY 搞定 7*24 小时 N in 1 服务器. smzdm.com](https://post.smzdm.com/p/674680/)\n- [2] [周晓锋. 软路由 Vs. 硬路由. 2011. 51cto.com](http://blog.51cto.com/likespc/714064)\n- [3] [云上小悟. 软路由 Vs 硬路由. 2013. maixj.net](http://www.maixj.net/ict/ruanluyou-yingluyou-5723)\n- [4] [跪着行走的boY. Git 和 Svn 的详细对比. cnblogs.com. 2017](http://www.cnblogs.com/dazhidacheng/p/7478438.html)\n- [5] [古方日月已使用. 电脑主板板型怎么选 ATX、ITX还傻傻分不清. 2017. zol.com.cn](http://bbs.zol.com.cn/diybbs/d402_9829.html)\n- [6] [太平洋电脑网. Z370/H370/B360/H310主板怎么选. 2018. baijiahao.baidu.com](http://baijiahao.baidu.com/s?id=1601905877566591798&wfr=spider&for=pc)","tags":["博客搭建","软路由","私有云","智能家居","科学上网","代码托管","浏览器插件","mk3s","sunmilo"],"categories":["Technique"]},{"title":"数据分析学习框架","url":"/2018/09/data-analysis-learning-framework.html","content":"\n本笔记以秦路老师的文章「如何七周成为数据分析师」为内容框架，整合相关的论文、书籍、视频资料，输出学习笔记。主要目的是检验自己的学习效果和日常复习之需。\n\n初入数据分析的大门，笔记大部门的知识模块以阅读原资料总结整理而得，难免有理解偏差、错误的地方，若有不正当的解释还望朋友们不吝指教！\n\n<!-- More -->\n\n## 更新进度\n- 2018.09.29：完成初稿，形成笔记的整体框架；\n- 2018.09.30：更新「数据分析入门」章节；\n\n## 学习框架\n- `整体框架`：本笔记以秦路老师的文章「如何七周成为数据分析师」$^{[1]}$ 为内容框架，整合相关的论文、书籍、视频资料，输出学习笔记。\n- `数学部分`：数据分析，离不开数学。关于学习资料的选择，推荐盛骤老师的《概率论与数理统计·第4版》和张宇老师的《带你学概率论与数理统计·浙大4版》。\n\n\t> 数学并不是自己擅长的科目，出于这样的考虑，故选择了 `大学教材` 和 `考研辅导书`，希望借以习题辅导书复习教材内容，以短时间获得最大成效比。\n\n\t- 📖 | 书籍 | [盛骤. 概率论与数理统计·第4版. 高等教育出版社](https://book.douban.com/subject/3165271/)\n\n\t- 📖 | 书籍 | [张宇. 带你学概率论与数理统计·浙大4版. 北京理工大学出版社](https://book.douban.com/subject/26630236/)\n\n\t- 📺 | 视频 | [张宇. 2018 考研概率论强化课程. bilibili.com](https://www.bilibili.com/video/av14690558?from=search&seid=2673720085936060940)\n\n\t- 📝 | 文章 | [Kofe | 笔记 | 概率论与数理统计](https://www.kofes.cn/2018/09/probability-and-statistics.html)\n\n- `统计部分`：很遗憾对此部分知识不了解，在此不具体展开探讨。但《概率论与数理统计》的数理统计部分可以预先复习。\n\n- `数据库部分`：在秦路老师的文章中，数据库部分侧重 SQL ( 结构化查询语言 ) 的讲解，当然这也是操作性和实用性很强的一模块。且据以往语言学习的经历，`多写、多练` 是必不可少的阶段，SQL 也不例外，附带的练习题目中有不少经典的实例，作为入门训练材料刚好合适。\n\n\t当然，数据库的知识不仅如此，有需求的朋友可继续参阅书籍《数据库系统概念》$^{[2]}$，即以数据库工程师的角度出发，从需求到维护的流程化学习过程，整体架构上学习数据库这门学科。\n\t\n\t- 📝 | 文章 | [W3CSchool SQL 教程 & 练习题](http://www.w3school.com.cn/sql/index.asp)\n\n\t- 📝 | 文章 | [LeetCode SQL 练习题](https://leetcode-cn.com/problemset/database/)\n\n\t- 📖 | 书籍 | [Abraham Silberschatz. 数据库系统概念. 机械工业出版社](https://book.douban.com/subject/10548379/)\n\n\t- 📖 | 书籍 | [福达(Ben Forta). SQL 必知必会. 人民邮电出版社](https://book.douban.com/subject/24250054/)\n\t\n- `编程部分`：主导 Python 语言编程。由于篇幅的缘故，该部分内容请参阅另一篇博文：\n\n\t- 📝 | 文章 | [Kofe | 笔记 | Python 3 入门系列教程](https://www.kofes.cn/2018/09/life-is-short-we-need-python.html)\n\n\t- 📝 | 文章 | [廖雪峰. Python 教程. 2018. liaoxuefeng.com](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)\n\n\t\t> 当然，Python 的学习还可以参考廖雪峰老师的教程。\n\n\t- 📖 | 书籍 | [Iamseancheney (译). Python 数据分析 (第二版). 2017. github.com](https://github.com/iamseancheney/python_for_data_analysis_2nd_chinese_version)\n\n\t\t> 本书是 2017 年 10 月 20 号正式出版的，和第一版的不同之处有：  \n\t\t> 1) 包括 Python 教程内的所有代码升级为 `Python 3.6`；  \n\t\t> 2) 更新了 Anaconda 和其它包的 Python 安装方法；   \n\t\t> 3) 更新了 Pandas 为 2017 最新版；  \n\t\t> 4) 新增 `高级的 Pandas 工具` 章节；   \n\t\t> 5) 简要介绍和使用 `StatsModels` 和 `scikit-learn`.  \n\n- `研究部分`：自己课题的需求，数据科学方向的研究是必不可少的环节。篇幅原因，则细节在下文中展开探讨。按照惯例，为了便于知识的引用和问题的探讨，以下罗列自己所使用到的学习资料。\n\t- 🍉 | 书籍 | [周志华. 机器学习 (西瓜书). 清华大学出版社](https://book.douban.com/subject/26708119/)\n\n\t- 🌼 | 书籍 | [[美] 伊恩·古德费洛. 深度学习 (花书). 人民邮电出版社](https://book.douban.com/subject/27087503/)\n\n\t- 📺 | 视频 | [深度学习. 读书会分享视频集. bilibili.com](https://www.bilibili.com/video/av15558220)\n\n\t\t> 视频转载自：[Alena Kruchkova. Deep Learning Book Live Streams. youtube.com](https://www.youtube.com/playlist?list=PLsXu9MHQGs8eO64mazCnCU3bc9l25Z1ZZ)  \n\t\t> 若有条件科学上网的朋友，可至 Youtube 搭配在线字幕观看。\n\t\n\t- 📖 | 书籍 | [李航. 统计学习方法. 清华大学出版社](https://book.douban.com/subject/10590856/)\n\n\t- 📖 | 书籍 | [[美] Jiawei Han. 数据挖掘：概念与技术 (原书第3版). 机械工业出版社](https://book.douban.com/subject/11542972/)\n\n## 数据分析入门\n\n### Excel：不考虑性能和数据量\n- 掌握各类功能强大的函数 -- [常见 Excel 函数](https://ask.hellobi.com/blog/qinlu/5976)\n\t- 清洗处理类：trim、concatenate、replace、substitute、left/right/mid、len/lenb、find、search、text\n\t- 关联匹配类：lookup、vlookup、index、match、row、column、offset\n\t- 逻辑运算类：if、and、or、is系列\n\t- 计算统计类：sum/sumif/sumifs、sumproduct、count/countif/countifs、max、min、rank、rand/randbetween、averagea、quartile、stdev、`substotal`、int/round\n\t- 时间序列类：year、month、weekday、weeknum、day、date、now、today、`datedif`\n- Excel 常用工具 -- [数据分析：Excel 技巧大揭秘](https://ask.hellobi.com/blog/qinlu/5977)\n\t- `格式转换`：自定义格式规范时间。\n\t\t\n\t\t> 2016/11/11 写成 yyyy/MM/dd  \n\t\t> 2016-11-11 23:59:59 写成 yyyy-MM-dd HH:mm:ss\n\t\t\n\t- `分列`：分列功能可以将某一列按照特定规则拆分，常常用来进行数据清洗。\n\t- `数据透视表`：数据透视表的核心思想是聚合运算，将字段名相同的数据聚合起来，所谓数以类分。\n\n\t\t> 列和行的设置，则是按不同轴向展现数据。简单说，你想要什么结构的报表，就用什么样的拖拽方式。\n\t\t\n\t- `删除重复项`：一种数据清洗和检验的快速方式。想要验证某一列有多少个唯一值，或者数据清洗，都可以使用。\n\t- `自定义下拉菜单` (数据有效性)：数据有效性是一种约束，针对单元格限制其输入，也就是让其只能固定几个值。下拉菜单是一种高阶应用，通过允许下拉箭头即可。\n\t- `查找公式错误`：公式报错也不知道错在哪里时候可以使用该功能，尤其是各类IF嵌套或者多表关联，逻辑复杂时。查找公式错误是逐步运算的，以方便定位。\n\t- `分组和分级显示`：常用在报表中，在报表行数多到一定程度时，通过分组达到快速切换和隐藏的目的。\n\t- **`分析工具库`**：分析工具库是高阶分析的利器，包含很多统计计算，检验功能等工具。Excel是默认不安装的，要安装需要加载项，在工具菜单下（不同版本安装方式会有一点小差异）。\n\t\n\t   > 分析工具库是统计包，如随机数发生器、排位与百分比排位、回归、抽样、t-检验等。\n\t\n- Excel 实战教程 -- [数据分析：手把手教你Excel实战](https://ask.hellobi.com/blog/qinlu/5978)\n\t- 明确目的\n\t\t- 数据用来解决什么问题？\n\t\t- 汇总统计制作报表？\n\t\t- 数据可视化，作为一张信息图？\n\t\t- 验证某一类业务假设？\n\t\t- 提高某一个指标的KPI？\n\t- 观察数据\n\t\t- 数据有无缺失值\n\t\t  - 某一字段缺失数据较多，要考虑是否删除该字段（超过 50% 即没有业务意义了）\n\t\t- 数据是否一致化\n\t\t- 数据是否有脏数据：乱码，错位，重复值，未匹配数据，加密数据\n\t\t- 数据标准结构\n\t- 数据清洗：结合 `观察数据` 阶段完成的工作，对数据进行 `预处理操作`。\n\t- 分析过程\n\t   - 数据透视表\n- 单元格格式：数据分析师会和各种数据类型打交道，包括各类 timestamp，date，string，int，bigint，char，factor，float 等。\n- 了解中文编码：UTF-8、GBK、ASCII 码。\n\n### Excel：数据可视化\n- Excel：多种经典图表\n\t- [数据可视化：你想知道的经典图表全在这](https://ask.hellobi.com/blog/qinlu/5986)\n\t   - 散点图：表示两个变量之间的关系。后续的学习中，多次借用到散点，统计中的 `回归分析`，比如数据挖掘中的 `聚类`。\n\t   - 折线图：了解某一维度在时间上的规律或者趋势。\n\t   - 柱形图：堆积柱形图，瀑布图，横向条形图，横轴正负图。\n\t   - 地理图：一切和空间属性有关的分析都可以用到地理图。\n\t   - 饼图\n\t   - 雷达图：也叫蛛网图，适合用在固定的框架内表达某种已知的结果。\n\t   - 箱线图：它能准确地反映数据维度的离散（最大数、最小数、中位数、四分数）情况。凡是离散的数据都适用箱线图。\n\t   - 热力图：以高亮形式展现数据。\n\t   - 关系图\n\t   - 矩形树图：柱形图不适合表达过多类目（比如上百）的数据，那应该怎么办？矩形树图出现了，它直观地以面积表示数值，以颜色表示类目。\n\t   - 桑基图：常表示信息的变化和流动状态。\n\t   - 漏斗图\n\t- [数据可视化：教你打造升职加薪的报表](https://ask.hellobi.com/blog/qinlu/5987)\n- PowerBI：Dashboard 仪表盘，由多个图表集合成的图表仪盘 -- [数据可视化：手把手打造BI](https://ask.hellobi.com/blog/qinlu/5989)\n\t- 商业智能（Business Intelligence，BI），在传统企业中，它是一套完整的解决方案。将企业的数据有效整合，快速制作出报表以作出决策。涉及 `数据仓库`，`ETL`，`OLAP`，`权限控制` 等模块。\n\n## 数据分析思维\n- 麦肯锡的分析思维：结构化思考，MECE原则，假设先行，关键驱动等方法论。 -- [快速掌握麦肯锡的分析思维](https://ask.hellobi.com/blog/qinlu/6002)\n- 分析思维框架：SMART、5W2H、SWOT、4P4C、六顶思考帽等 -- [如何建立数据分析的思维框架](https://ask.hellobi.com/blog/qinlu/6003)\n\n## 业务知识\n\n## 课题研究\n\n## 参考资料\n- \\[1\\] [秦路. 如何七周成为数据分析师. hellobi.com. 2017](https://ask.hellobi.com/blog/qinlu/8930)\n- \\[2\\] [Abraham Silberschatz. 数据库系统概念 (原书第6版) [M]. 机械工业出版社, 2012](https://book.douban.com/subject/10548379/)","tags":["数据分析","Excel","Python","数据库"],"categories":["Reading"]},{"title":"概率论与数理统计","url":"/2018/09/probability-and-statistics.html","content":"\n本笔记是备战考研时，跟着张宇老师的概率论课程学习整理所得。且输出本笔记的主要目的是快速构建概率的基础知识体系，以便于日后复习查阅和问题探究。或是更具体的应用场景，如 `机器学习`、`数据挖掘`、`经济统计` 等领域，概率论作为这些领域的 `先修课程`，理论基础尤为重要。由此，无论是初入门还是温故知新，学习基础学科为必经阶段，不妨选择张宇老师的概率论课程，这不失一种高效的复习方案。\n\n当然，笔记仅是对知识点的整理和归纳，并不能代表原本知识点的严谨定义。若有更进阶的需求，还请查阅概率论相关教材，或重温课程。\n\n<!-- More -->\n\n## 更新进度\n- 2018.10.04：完成初稿，并更新「如何处理复杂事件」章节 ( 共 4 节 )；\n\n## 学习资料\n- 推荐盛骤老师的《概率论与数理统计·第4版》和张宇老师的《带你学概率论与数理统计·浙大4版》。\n\n\t> 数学并不是自己擅长的科目，出于这样的考虑，故选择了 `大学教材` 和 `考研辅导书`，希望借以习题辅导书复习教材内容，以短时间获得最大成效比。\n\t\n\t- 📖 | 书籍 | [盛骤. 概率论与数理统计·第4版. 高等教育出版社](https://book.douban.com/subject/3165271/)\n\t- 📖 | 书籍 | [张宇. 带你学概率论与数理统计·浙大4版. 北京理工大学出版社](https://book.douban.com/subject/26630236/)\n\t- 📺 | 视频 | [张宇. 2018 考研概率论强化课程. bilibili.com](https://www.bilibili.com/video/av14690558?from=search&seid=2673720085936060940)\n\n## 学习目标\n- 以`张宇老师` 的概率论课程为框架的，围绕 `五大问题` 展开学习与探讨：在导课部分就明确了 `课程体系` 和 `学习目标`，即学习什么、学了怎么用都在浓缩于五大问题当中。\n\t- 如何处理复杂事件 $P(A)$；\n\t- 如何求分布 $F(x)$、$F(x, y)$；\n\t- 如何求数字特征 $EX$、$DX$、$Cov(x, y)$、$\\rho_{x,y}$；\n\t- 如何使用极限定理 ( 大样本， $n \\to \\infty$ );\n\t- 如何做估计与评价.\n\n- 前 `四大问题` 主要讨论的是 `概率论` 部分的内容，`最后一问题` 则是 `数理统计` 的内容探讨。\n- 事不宜迟，定下小目标，让自己赶紧行动起来！\n\t\n## 壹 如何处理复杂事件\n\n### 随机试验与样本空间\n#### 随机试验\n- 随机试验，记作 $E$：\n\t- 同条件下可重复。\n\t- 试验结果明确可知，且不止一个。\n\t- 试验前不知哪个结果会发生。\n\n#### 基本概念\n- `试验结果` 中每一个最简单、最基本 (不可再分的结果) 叫 `样本点` (基本事件)，记作 $\\omega$。\n- $\\omega$ 的全体叫 `样本空间`，记作 $\\Omega$。\n- `样本空间的子集` 叫 `随机事件`，记作 $A, B, C, ...$，即英文大写字母表示。\n- 子集中：\n\t- $\\Omega$ 本身为必然事件。\n\t- $\\emptyset$ 为不可能事件。\n\n### 古典概型\n#### 概念梳理\n- 若随机事件 $E$ 的样本空间 $\\Omega$ 中满足下述两种条件，称其为古典概型：\n\t- 存在 `有限个` 样本点；\n\t- 样本点的发生具有 `等可能性`.\n- 则其概率表达式为：\n\n$$\nP(A) = \\frac{A中含样本点个数}{\\Omega 中含样本点总数}\n\\tag{1}\n$$\n\n- 对于概率表达式 (1)，我们侧重关注其 `计数方法`：\n\t- `穷举法`：个数不多时，直接计数即可。\n\t- `集合对应法`：\n\t\t- `加法原理`：完成一件事有 $n$ 类方法，第一类方法有 $m_1$ 种方法，第二类有 $m_2$ 种方法，完成此事共 $\\sum_{i = 1}^n m_i$ 种方法。\n\t\t- `乘法原理`：完成一件事有 $n$ 个步骤，第一步有 $m_1$ 种方法，第二步有 $m_2$ 种方法，第 $n$ 步有 $m_n$ 种方法，故完成此事共 $\\prod_{i=1}^n m_i$ 种方法。\n\t\t- `排列`：从 $n$ 个不同的元素中取出 $m(\\leq n)$ 个元素，并按照一定顺序排成一列，叫做排序。所有排列的个数叫排列数，记作：\n\n\t\t$$\n\t\tA_n^m = n(n-1)···(n - m + 1) = \\frac{n!}{(n - m)!}\n\t\t\\tag{2}\n\t\t$$\n\t\t\n\t\t`全排列`：当 $m = n$ 时，$A_n^m = \\frac{n!}{0!} = n!$ 称为全排列。\n\t\t\n\t\t- `组合`：从 $n$ 个不同元素中取出 $m(\\leq n)$ 个元素，并成一组，叫组合。所有组合个数叫组合数，记作：\n\n\t\t$$\n\t\tC_n^m = \\frac{A_n^m}{m!}\n\t\t\\tag{3}\n\t\t$$\n\t\t\n\t\t> 注意：按照欧美规范，对于 $A_n^m$ 或是 $C_n^m$，m 和 n 的上下位置与我们平常见的是相反的，国内的教材以相反为主。\n\t\t\n\t- `对立事件思想`：若研究对象是复杂的，则转而研究对立事件 $\\overline{A}$，故有：\n\t\n\t$$\n\tn - n_{\\overline{A}} = n_A\n\t\\tag{4}\n\t$$\n\t\n#### 练习巩固\n##### 例题一\n- [题目] 从 0 到 9 个数字中任取 3 个不同数字，求：  \n\t- $A_1$ = {三个数中不含 0 和 5}\n\t- $A_2$ = {三个数中不含 0 或 5}\n\t- $A_3$ = {三个数中含 0，但不含 5}\n- [分析]  令含数字 0 的事件为 $B_1$，含数字 5 的事件为 $B_2$：\n\t- $P(A_1) = \\frac{ C_8^3 }{ C_{10}^3 } = \\frac{7}{15}$\n\t\n\t- $P(A_2) = \\frac{ C_{10}^3 - C_1^1·C_1^1·C_8^1 }{ C_{10}^3 } = \\frac{14}{15}$\n\n\t\t> $A_2$ 事件可通 `对立事件思想` 解题，即所有数字取值可能减去三个数中含 0 且含 5 的情况，即 $A_2 = \\overline{ B_1 \\bigcup B_2 } = \\overline{B_1} \\bigcap \\overline{B_2}$。\n\t\n\t- $P(A_3) = \\frac{ C_1^1·C_8^2 }{ C_{10}^3 } = \\frac{7}{30}$\n\n##### 例题二\n- [题目] 袋中有 5 球，3 白 2 黑：\n\t- 先后有放回取 2 球，求 $B_1$ = {至少一白球}\n\t- 先后无放回取 2 球，求 $B_2$ = {至少一白球} \n\t- 任取 2 球，求 $B_3$ = {至少一白球}\n- [分析] 注意 `有放回` 和 `无放回` 的情况，是有区别的：\n\t- $P(B_1) = \\frac{ C_5^1·C_5^1 - C_2^1·C_2^1 }{ C_5^1·C_5^1 } = \\frac{21}{25}$\n\n\t- $P(B_2) = \\frac{ C_5^1·C_4^1 - C_2^1·C_1^1 }{ C_5^1·C_4^1 } = \\frac{9}{10}$\n\n\t- 通过 `对立事件思想` 解题，先求 $\\overline{B_3}$ = {任取两球全黑} 的概率：\n\n\t$$\n\tP(\\overline{B_3}) = \\frac{ C_2^2 }{ C_5^2 } = \\frac{1}{10} \\\\\n\tP(B_3) = 1 - P(\\overline{B_3}) = \\frac{9}{10}\n\t$$\n\t\n- 我们注意到，$P${先后无放回取，至少一白球} 等于 $P${任取两球，至少一白球} 的概率，即 $P(B_2) = P(B_3)$。\n\t- `得出结论`：`P{先后无放回} = P{任取}`\n\t- `证明方式`：分别用 `先后无放回取两球` 的方式和 `任取两球` 的方式，求 `P{两球全黑}`，再通过 `1 - P{两球全黑}` 求 `P{至少一白球}`： \n\n\t\t$$\n\t\tp(\\text{先后无放回取得两球全黑}) = \n\t\t    \\frac{ C_2^1·C_1^1 }{ C_5^1·C_4^1 } = \\frac{1}{10} \\\\\n\t\tp(\\text{任取两球全黑}) =\n\t\t    \\frac{ C_2^2 }{ C_5^2 } = \\frac{1}{10}\n\t\t$$\n\t\n\t\t当然，任取涉及先后顺序问题，应该对任取结果作排列，但由于上下同乘一种顺序故可略去。\n\t\n\t\t$$\n\t\t\\require{cancel}\n\t\tp(\\text{任取两球全黑}) =\n\t\t    \\frac{ C_2^2·\\bcancel{A_2^2} }{ C_5^2 ·\\bcancel{A_2^2} } = \\frac{1}{10}\n\t\t$$\n\t\t\n\t- 通过此结论，计算 `先后无放回` 抽取问题会有很大帮助。例如，从 100 个球中，先后无放回取 40 个球，则可理解为 `一把抓 40 个球`。\n\n##### 例题三\n- [题目] 袋有 100 个球，40 白 60 黑：\n\t- 先后 `无放回` 取 20 个球，求 $C_1$ = {15 白 5 黑}\n\t- 先后 `无放回` 取 20 个球，求 $C_2$ = {第 20 次取到白球}\n\t- 先后 `有放回` 取 20 个球，求 $C_3$ = {15 白 5 黑}\n\t- 先后 `有放回` 取 20 个球，求 $C_4$ = {第 20 次取到白球}\n- [分析] 根据例题二的结论，无放回抽取可等同于任意抽取。\n\t- $P(C_1) = \\frac{ C_{40}^{15}·C_{60}^5 }{ C_{100}^{20} }$\n\n\t- $P(C_2) = \\frac{C_{40}^1·99!}{100!} = \\frac{40}{100}$ \n\n\t\t- 1) 利用 `抓阄模型` 进行解题。即在本题中可理解为：袋中装有 100 个“灰球”，按概率摸球，则有 40% 可能摸到白球，60% 可能摸到黑球。\n\t\t- 2) 在本题中，我们可把 100 个球想象成 100 个位置，从左往右排列，位置与次数匹配。例如，我们求第 20 次取到白球的概率，即往 20 的位置只考虑放入白球的情况，剩余位置自由排列即可，故有 $C_{40}^1·99!$。\n\n\t\t![图1-1抓阄模型演示](/images/illustration/Reading/2018/10/probability-and-statistics_1-1.png)\n\t\t<center>图1-1 抓阄模型演示</center>\n\n\t- $P(C_3) = C_{20}^{15}·(\\frac{40}{100})^{15}·(\\frac{60}{100})^5$\n\n\t\t- 符合二项分布，记取到白球的次数为 X (实验无非取到黑/白两种球)，则可根据公式求解：\n\t\t$$P\\{X = k\\} = C_n^k·p^k·(1-p)^{n-k}, k = 0, 1, 2, ..., n$$\n\n\t- $P(C_4) = \\frac{40}{100}$\n\n### 几何概型\n\n#### 概念梳理\n- 定义 $\\Omega$ 是一个可度量的几何区域，每个样本点的发生具有等可能性。即样本点落入 $\\Omega$ 中的某一可度量子区域 $A$ 的可能性大小与 $A$ 的 `几何度量` 成正比，而与 $A$ 的位置及形状无关。则称其为 `几何概型`，记作：\n\n\t$$\n\tP(A) = \\frac{ A 的测度 }{ \\Omega 的测度 }\n\t\\tag{5}\n\t$$\n\n#### 练习巩固\n##### 例题一\n- [题目] 假设我上午 8:00-9:00 时间段内进入教室：\n\t- 求 $A_1$ = {我在 8:30-9:00 时间段进教室} 的概率\n\t- 求 $A_2$ = {我恰好在 8:30 进入教室} 的概率\n- [分析] 如图 1-2 所示，设 8:00-9:00 的时间段为单位 1：\n\t- $P(A_1) = \\frac{ \\frac12 }{1} = \\frac12$\n\n\t- $P(A_2) = \\frac01 = 0$\n\n\t\t> 在 8:30 这一刻所占长度为 \"0\"，只是数据研究工具的缺陷，致使测不出来。所以 $P(A) = 0$ 并不能推导 $A_2$ 为不可能事件。\n\n\t![图1-2单位1长时间段](/images/illustration/Reading/2018/10/probability-and-statistics_1-2.png)\n\t<center>图1-2 单位 1 长时间段</center>\n\n##### 例题二\n- [题目] 君子有约，9:00-10:00 甲、乙在校门口见面，等 20 分钟即离开：\n\t- 求 $B$ = {甲、乙能见面} 的概率\n- [分析] 设甲出现的时间为 $x$，乙出现的时间为 $y$：\n\t- 则两方的时间差为 $|x - y| \\leq 20, 0 \\leq x \\leq 60, 0 \\leq y \\leq 60$\n\n\t![图1-3函数图像](/images/illustration/Reading/2018/10/probability-and-statistics_1-3.png)\n\t<center>图1-3  $|x - y| \\leq 20$ 的函数图像</center>\n\n\t- 根据上述函数的图像可得 $P(B) = \\frac{ \\int_A }{ \\int_\\Omega } = \\frac{ 1 - (\\frac{40}{60})^2 }{1} = \\frac59$\n\n##### 例题三\n- [题目] 在 (0, 1) 内随机取两个数，$P\\{两数之和小于 \\leq \\frac65\\}$\n- [解析] 由题意可得，则有：\n\n\t![图1-4函数图像](/images/illustration/Reading/2018/10/probability-and-statistics_1-4.png)\n\t<center>图1-4  $x + y \\leq \\frac65$ 的函数图像</center>\n\n\t$$P\\{ x + y < \\frac65\\} = \\frac{1 - \\frac45*\\frac45*\\frac12}{1} = \\frac{17}{25}$$\n\n### 重要公式求概率\n\n#### 概念梳理\n##### 对立事件\n$$\nP(A) = 1- P(\\overline{A})\n\\tag{6}\n$$\n\n##### 减法公式\n$$\nP(A - B) = P(A) - P(AB)\n\\tag{7}\n$$\n\n##### 加法公式\n\n- 一般情况 ( 通用公式 )：\n\n\t$$\n\tP(A + B) = P(A) + P(B) - P(AB)\n\t\\tag{9}\n\t$$\n\t\n\t$$\n\tP(A + B + C) = P(A) + P(B) + P(C) - P(AB) - P(AC) - P(BC) + P(ABC)\n\t$$\n\n- 若 $A_1, A_2, ..., A_n (n > 3)$ `两两互斥 (互不相容)`，则可得：\n\n\t$$\n\tP(A_1 + A_2 + ... + A_n) = \\sum_{i = 1}^n P(A_i)\n\t\\tag{6}\n\t$$\n\t\n- 若 $A_1, A_2, ..., A_n (n > 3)$  `相互独立`，则可得：\n\t\n\t$$\n\tP(A_1 + A_2 + ... + A_n) = 1 - P ( \\overline{A_1 + A_2 + ... + A_n} ) \\\\\n\t = 1 - P( \\overline{A_1}·\\overline{A_2}·...·\\overline{A_n} ) = 1 - \\prod_{i=1}^n P(\\overline{A_i})\n\t\\tag{10}\n\t$$\n\t\n\t- `相互独立`：设 $A_1, A_2, ..., A_n $，若对其中任意有限个 $A_{i_1}, A_{i_2}, ..., A_{i_k}$ 都有 $P(A_{i_1})·P(A_{i_2})·...·P(A_{i_k})$，则称 $A_1, A_2, ..., A_n $ 相互独立。  \n\t- `妇唱夫随`：$n$ 个事件相互独立 $\\Longleftrightarrow$ 它们中任意一部分事件换成其各自的对立事件，所得的 $n$ 个新事件也是相互独立的。\n\n![图1-5上述公式图解](/images/illustration/Reading/2018/10/probability-and-statistics_1-5.png)\n<center>图 1-5 上述公式图解</center>\n\n##### 条件概率公式\n> 标志性词汇：已知...，当...发生了。\n\n$$\nP(A | B) = \\frac{ P(AB) } { P(B) }, P(B) > 0\n\\tag{11}\n$$\n\n##### 乘法公式\n$$\nP(AB) = P(A | B)·P(B) \\\\\nP(AB) = P(B | A)·P(A)\n\\tag{12}\n$$\n\n一般地，推广至 $P(A_1A_2...A_n)$：\n\n$$\nP(A_1A_2...A_n) = \\\\\nP(A_n | A_1A_2...A_{n-1})·P(A_{n-1} | A_1A_2...A_{n-2})·...P(A_2 | A_1)·P(A_1)\n\\tag{13}\n$$\n\n##### 全集分解公式\n> 也称 `全概率公式`，已知第一阶段，求第二阶段。\n\n- 引例：设一个村子和三个小偷，小偷分别为 $A_1、A_2、A_3$，B = {村子失窃}\n\t- 阶段 (I). 什么人去偷：$A_1, A_2, A_3$\n\t\n\t- 阶段 (II). 村子失窃，各小偷去偷的概率：$P(B | A_1) = 0, P(B | A_2) = \\frac12, P(B | A_3) = 1$\n\n\t- 则村子失窃的概率：\n\t\n\t\t$$P(B) = P(A_1)·P(B | A_1) + P(A_2)·P(B | A_2) + P(A_3)·P(B | A_3) \\\\\n\t\t= \\frac13 * 0 + \\frac13 * \\frac12 + \\frac13 * 1 = \\frac12\n\t\t$$\n\t\n- 定义与公式，设一随机事件 $E$ 可分两个阶段：\n\t- 阶段 (I) $\\bigcup_{i = 1}^n A_i = \\Omega, A_iA_j = \\emptyset (两两互斥), i \\neq j$，则称 $A_1, A_1,..., A_n$ 为 $\\Omega$ 的一个划分，也叫 `完备事件组`。\n\t- 阶段 (II) 事件 $B$ 发生的概率：\n\t\t- $P(B\\Omega) = P(B·(\\bigcup_{i = 1}^n A_i) )$ 为全集分解过程。\n\t\t- $B$ 为第 (II) 阶段，$A_i$ 为第 (I) 阶段。\n\n\t\t$$\n\t\tP(B) = P(B\\Omega) = P(B·(\\bigcup_{i = 1}^n A_i) ) = P( B\\bigcap(A_1 + A_2 + ... + A_n) ) \\\\\n\t\t= P(BA_1 + BA_2 + ... + BA_n) = \\sum_{i = 1}^n P(BA_i) \\\\\n\t\t= \\sum_{i = 1}^n P(B | A_i)·P(A_i)\n\t\t\\tag{13}\n\t\t$$\n\n##### 贝叶斯\n> 也称 `逆概率公式`，已知第二阶段反推第一阶段 ( 执果索因 )。\n\n- 设一随机事件 $E$ 分成两个阶段：\n\t- 阶段 (I) $\\bigcup_{j = 1}^n A_j = \\Omega, A_iA_j = \\emptyset (两两互斥), j \\neq i$，则称 $A_1, A_1,..., A_n$ 为 $\\Omega$ 的一个划分，也叫 `完备事件组`。\n\t- 阶段 (II) 已知 $B$ 发生了，求 $P(A_j | B)$：\n\t\t- $P(B | A_j)$ 是已知的。\n\t\t- 一个事件分两个阶段，考虑全概率公式。\n\n\t\t$$\n\t\tP(A_j | B) = \\frac{ P(A_jB) }{ P(B) }\n\t\t= \\frac{\n\t\t    P(B | A_j)·P(A_j)\n\t\t}{\n\t\t    \\sum_{i = 1}^n P(B | A_i)·P(A_i)\n\t\t}\n\t\t\\tag{14}\n\t\t$$\n\n#### 练习巩固\n##### 例题一\n- [题目] 有甲、乙两名射击手，轮流独立射击打靶，甲命中的概率为 $\\alpha$，乙命中的概率为 $\\beta$。甲先射击，谁先命中谁获胜，求 $P$ = {甲获胜} 的概率。\n- [分析] 记 $A_i = \\{第 i 次命中\\}, i = 1, 2, ...$，则有：\n\n\t- 根据独立互斥条件，结合题意可得：\n\n\t$$\n\tP\\{甲获胜\\} = P\\{ A_1 + \\overline A_1 \\overline A_2 A_3 + \\overline A_1 \\overline A_2 \\overline A_3 \\overline A_4 A_5 + ... \\}\n\t= P(A_1) + P(\\overline A_1 \\overline A_2 A_3) + P(\\overline A_1 \\overline A_2 \\overline A_3 \\overline A_4 A_5) + ... \\\\\n\t= P(A_1) + P(\\overline A_1)P(\\overline A_2)P(A_3) + P(\\overline A_1)P(\\overline A_2)P(\\overline A_3)P(\\overline A_4)P(A_5) + ... \\\\\n\t= \\alpha + (1 - \\alpha)(1 - \\beta)\\alpha + (1 - \\alpha)^2(1 - \\beta)^2\\alpha + ... \\\\\n\t$$\n\t\n\t- 观察上述式子，我们可设公比 $q = (1 - \\alpha)(1 - \\beta)$，则公式继续往下推演：\n\n\t$$\n\t\\int_n^{\\infty} \\alpha + \\alpha q + \\alpha q^2 + ... + \\alpha q^{n-1}\n\t= \\int_n^{\\infty} \\frac{\\alpha (1 - q^n)}{1 - q}\n\t= \\frac{a}{1 - q} = \\frac{a}{1 - (1 - \\alpha)(1 - \\beta)}\n\t$$\n\t\n- [注意] $P$ = {甲获胜} 的概率：\n\n\t$$\n\tP\\{乙获胜\\} = 1 - P\\{甲获胜\\} = \\frac{\\beta (1 - \\alpha)}{1 - (1 - \\alpha)(1 - \\beta)}\n\t$$\n\t\n\t若 $\\alpha = \\beta = p$，则有：\n\t\n\t$$\n\tP\\{甲获胜\\}  = \\frac{p}{1 - (1 - p)^2}, 令 \\, p + q = 1, \\, \n\t= \\frac{p}{1-q^2} = \\frac{p}{(1 + q)(1 - q)} = \\frac{1}{1 + q} \\\\\n\tP\\{乙获胜\\} = 1 - P\\{甲获胜\\} = \\frac{q}{1 + q}\n\t$$\n\t\n\t由此可见，**先下手为强**。即谁先射击，谁的胜率高。\n\n##### 题目二\n- [题目] 某彩票每周开奖一次，中奖概率为十万分之一，且每周开奖相互独立。某人每周买一次，坚持十年 ( 每年 52 周 )，则求 $P$ = {此人从未中奖} 的概率。\n- [分析] 记 $A_i = \\{第 i 次中奖\\}, \\, i. = 1, 2, ... 52, 且 \\, p = 10^{-5}$，则有：\n\n\t$$\n\tP\\{此人从未中奖\\} = \n\tP\\{ \\overline A_1 \\overline A_2 ... \\overline A_{52} \\} = \n\t(1 - 10^{-5})^{52} = 0.9948\n\t$$\n\t\n\t由此可见，**天上是不会平白无故掉馅饼**。\n\n##### 题目三\n- 10 份报名表， 3 女 7 男，先后无放回抽取，则:\n\t- (1) $A_1$ = {第三次取到女的报名表} 的概率\n\t- (2) $A_2$ = {第三次才取到女的报名表} 的概率\n\t- (3) $A_3$ = {已知前两次均取到男，第三次才取到女} 的概率\n\n- [分析] \n\t- (1) 由题意可知，利用 `抓阄模型` 进行解题，即使用 `绝对概率` 求解：\n\n\t\t$$\n\t\tP(A_1) = \\frac{C_3^1 9!}{10!} = \\frac{3}{10}\n\t\t$$\n\t\t\n\t- (2) 由题意可知，使用 `积事件概率` 求解：\n\n\t\t$$\n\t\t记 A_i = \\{第 i 次取到女的报名表\\}, \\,  i = 1,2, ... \\\\\n\t\t则 P(A_2) = P(\\overline A_1 \\overline A_2 A_3) = \n\t\tP(A_3 | \\overline A_1 \\overline A_2 )P(A_2 | \\overline A_1 )P(A_1)\n\t\t\\\\ = \\frac{3}{8} * \\frac{6}{9} * \\frac{7}{10}= \\frac{7}{40}\n\t\t$$\n\t\t\n\t- (3) 由题意可知，使用 `条件概率` 求解：\n\n\t\t$$\n\t\tP(A_3) = P(A_3 | \\overline A_1 \\overline A_2) = \\frac38\n\t\t$$\n\n##### 题目四\n- [题目] 设两批数量相同的零件，有一批全部合格，另一批 25% 不合格，75% 合格。从两批产品中任取一件，经检验为合格品，放回原处，并从该处再取一件，求这一件为不合格的概率。\n\n- [分析] 从两批零件中取得不合格的事件，可分为两个阶段：\n\t- (Ⅰ) 选批次：第一批记作 $H_1$，第二批记作 $H_2$。\n\t- (Ⅱ) 取零件：合格记作 $A$，不合格记作 $\\overline A$。\n\n\t\t由题意可知， $P(H_1) = P(H_2) = \\frac12, P(A | H_1) = 1, P(A | H_2) = \\frac34$\n\t\t\n\t\t首先，从两批产品中任取一件零件为合格品的概率，由全概率公式求得：\n\t\t\n\t\t$$\n\t\tP(A) = P(A \\Omega) = P(A | H_1)P(H_1) + P(A | H_2)P(H_2) = \\frac78\n\t\t$$\n\t\t\n\t\t再者，执因索果，已知第一次所取零件为合格品，则选自第一批、第二批的概率由贝叶斯公式可得：\n\t\t\n\t\t$$\n\t\tP(H_1 | A) =\n\t\t\\frac{P(AH_1)}{P(A)} = \\frac{P(A | H_1)P(H_1)}{\\frac78} = \\frac47 \\\\\n\t\tP(H_2 | A) = \n\t\t\\frac{P(AH_2)}{P(A)} = \\frac{P(A | H_2)P(H_2)}{\\frac78} = \\frac37\n\t\t$$\n\t\t\n\t\t于是，设 $C_i = \\{第二次是从第 i 批中取得零件的\\}, i = 1, 2$，则有：\n\t\t\n\t\t$$\n\t\tP(C_1) = P(H_1 | A) = \\frac47, \\, P(C_2) = P(H_2 | A) = \\frac37 \\\\\n\t\t$$\n\t\t\n\t\t则第二次从该处取得不合格零件的概率为：\n\t\t\n\t\t$$\n\t\tP(\\overline A) =\n\t\tP(\\overline A | C_1)P(C_1) + P(\\overline A | C_2)P(C_2) = \n\t\t0 * \\frac47 + \\frac14 * \\frac 37 = \\frac{3}{28}\n\t\t$$\n\n##### 题目五\n- [题目] 设有两箱同种零件，第一箱 50 件，10 件一等品；第二箱 30 件，18 件一等品。先从中随机挑出一箱，再从该箱中先后无放回取出两个零件，求：\n\t- (1) $P$ = {第一次取到一等品} 的概率\n\t- (2) $Q$ = {在第一次取出的是一等品的条件下，第二次仍取到一等品} 的概率\n- [分析] 从两箱中取得一等品零件的事件，可分为两个阶段：\n\t- (Ⅰ) 选箱子：第一箱记作 $H_1$，第二箱记作 $H_2$。\n\t- (Ⅱ) 取零件：第一次取到一等品记作 $B_1$，第二次取到一等品记作  $B_2$。\n\n\t\t由题意可知， $P(H_1) = P(H_2) = \\frac12, P(B_1 | H_1) = \\frac{10}{50}, P(B_1 | H_2) = \\frac{18}{30}$\n\t\t\n\t\t(1) 由此可得，$P$ = {第一次取到一等品} 的概率为：\n\n\t\t$$\n\t\tP = P(B_1\\Omega) = P(B_1 | H_1)P(H_1) + P(B_1 | H_2)P(H_2) = \n\t\t\\frac{10}{50} * \\frac12 + \\frac{18}{30} * \\frac12 = \\frac{4}{10}\n\t\t$$\n\t\t\n\t\t(2) 依题意，可使用条件概率公式求 $P$ = {在第一次取出是一等品的条件下，第二次仍取到一等品}：\n\t\t\n\t\t$$\n\t\tP(B_2 | B_1) = \\frac{P(B_1B_2)}{P(B_1)} = \n\t\t\\frac{ P(B_1B_2 | H_1)P(H_1) + P(B_1B_2 | H_2)P(H_2) }{\\frac{4}{10}} \\\\\n\t\t= \\frac{10}{4} * (\n\t\t\t\\frac{10}{50} * \\frac{9}{49} * \\frac12 + \n\t\t\t\\frac{18}{30} * \\frac{17}{29} * \\frac12\n\t\t) = 0.486\n\t\t$$\n\t\t\n\t\t当然，也可以参照例题四的思路解题 ( 贝叶斯 )：\n\t\t\n\t\t$$\n\t\tP(H_1 | B_1) = \\frac{ P(B_1 | H_1)P(H_1)}{P(B_1)} = \n\t\t\\frac{ \\frac{10}{50} * \\frac12 }{ \\frac{4}{10} } = \\frac{1}{4}\\\\\n\t\tP(H_1 | B_1) = \\frac{ P(B_1 | H_2)P(H_2)}{P(B_1)} = \n\t\t\\frac{ \\frac{18}{30} * \\frac12 }{ \\frac{4}{10} } = \\frac34 \\\\\n\t\tP(B_2 | B_1) = P(H_1 | B_1) * \\frac{9}{49} + P(H_2 | B_1) * \\frac{17}{29} = 0.486\n\t\t$$\n\n## 贰 如何求分布\n\n### 基本概念\n#### 随机变量\n#### 分布函数\n##### 离散型随机变量\n##### 连续型随机变量\n\n### 常见一维分布\n#### 两点分布\n#### 二项分布\n#### 几何分布\n#### 超几何分布\n#### 泊松分布\n#### 均匀分布\n#### 指数分布\n#### 正态分布\n\n### 一维随机变量及其分布函数\n\n### 二维随机变量及其分布函数\n\n## 叁 如何求数字特征\n\n### 数学期望\n### 方差\n### 协方差\n### 相关系数\n\n## 肆 如何使用极限定理\n\n### 依概率收敛\n\n### 极限定理\n#### 大数定律\n#### 中心极限定理\n\n## 伍 如何作估计\n\n### 总体与样本\n### 估计方法\n#### 矩估计\n#### 最大似然估计","tags":["贝叶斯","全概率","分布函数","数字特征"],"categories":["Reading"]},{"title":"Python 3 快速上手教程","url":"/2018/09/life-is-short-we-need-python.html","content":"\n- 本文章主要以黑马程序员的「[传智播客 Python 就业班 (ij6g)](https://pan.baidu.com/s/1oBnk19WfBWQ1Pwd7rNGixw)」、「 [Python 从入门到精通教程](https://www.bilibili.com/video/av14184325) 」和「 [廖雪峰的 Python 教程](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000) 」为主线，输出学习笔记，目的是检验自己的学习效果和日常复习之需。作为入门 Python 的参考资料，除了视频的基础内容外，文章还会补充视频中讲解不详细或遗漏的必要知识点。\n\n- 文章的内容和知识框架，与「廖雪峰的 Python 教程」和「传智播客的视频」大体保持一致：  \n\n\t> 文章以模块分块阐述： Linux 基础、Python 基础、Python 面向对象，每个模块按知识点区分：  \n\n\t- 1) Linux 基础部分参考 `传智播客 Python 从入门到精通教程`；  \n\t- 2) Python 基础部分参考 `廖雪峰 Python 教程`；  \n\t- 3) 项目实践，即数据分析部分参考书籍 `利用 Python 进行数据分析` $^{[5]}$；  \n\n- 最后，正如 Bruce Eckel 所述 Life is short,  you need python，Python 的高效只有切身体验才会深有体会，期待您早日加入 Python 队伍中来。\n\n<!-- More -->\n\n## 更新进度\n- 2018.09.03：完成初稿，且完成 Linux 基础部分的内容；\n- 2018.09.18：更新 Python 基础部分内容「语言基础、函数、高级特性」；\n- 2018.09.21：更新 Python 基础部分内容「函数式编程」；\n- 2018.10.10：更新 Python 基础部分内容「模块、面向对象编程」；\n- 2018.10.12：更新 Python 基础部分内容「面向对象高级编程」；\n- 2018.10.13：更新 Python 基础部分内容「错误/调试/测试」；\n- 2018.10.14：更新 Python 基础部分内容「面向 I/O 编程」；\n- 2018.11.05：更新 Python 基础部分内容「装饰器」；\n\n## 参考书目\n- `Python 基础`\n\t- 📖 | 埃里克·马瑟斯.《 Python 编程：从入门到实践 》：[豆瓣评分](https://book.douban.com/subject/26829016/)\n\t- 📖 | Albert Sweigart.《 Python 编程快速上手 》：[豆瓣评分](https://book.douban.com/subject/26836700/) \n- `Python 进阶`\n\t- 📖 | David M. Beazley / Brian K. Jones.《 Python Cookbook 》：[中文版](https://book.douban.com/subject/26381341/) | [英文版](https://book.douban.com/subject/20491078/)\n\t- 📖 | Luciano Ramalho. 《 Fluent Python 》：[中文版](https://book.douban.com/subject/27028517/) | [英文版](https://book.douban.com/subject/26278021/)\n- `Python 实践`\n\t- 📖 | Wes Mckinney.《 利用 Python 进行数据分析 》：[豆瓣评分](https://book.douban.com/subject/25779298/)\n\t- 📖 | Clinton W. Brownley.《 Python数据分析基础 》：[豆瓣评分](https://book.douban.com/subject/27100480/)\n\n## 教学资源\n- 📖 | 文章 | [廖雪峰. Python 3 教程. liaoxuefeng.com](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)\n- 📺 | 视频 | [黑马程序员. Python 从入门到精通教程. 2017. bilibili.com](https://www.bilibili.com/video/av14184325)\n- 📺 | 视频 | [传智播客. Python 就业班. 2017. BaiduCloud](https://pan.baidu.com/s/1oBnk19WfBWQ1Pwd7rNGixw) | Pwd: ij6g\n\n\t> 本文章的学习笔记是基于此系列教学视频所得的。\n\n## Linux 基础\n\n### Linux 常用终端命令\n> 仅列举一些项目中常用的命令。\n\n- LS 命令与通配符\n\t- `*`：代表任意个数个字符。\n\t- `?`：代表任意一个字符。\n\t- `[]`：表示可匹配字符组中任意一个。\n\t- `[abc]`：匹配 a、b、c 中的任意一个字符。\n\t- `[a-f]`：匹配从 a 到 f 范围内的任意一个字符。\n\n\t> 常使用 `ls -al` 显示当前文件目录所有文件的详细信息。\n\n- CD 命令与切换目录\n\t- 相对路径：最前面不是 `/` 或 `~`，表示相对 `当前目录` 所在的目录位置。\n\t- 绝对路径：最前面是 `/` 或 `~`，表示从 `根目录 / Home 目录` 开始的具体目录位置。\n\n\t\t```bash\n\t\t# 相对路径：返回上两级目录\n\t\tcd ../../ \n\t\t\n\t\t# 绝对路径：相当于 cd /Users/your username/\n\t\tcd ~\n\t\t```\n\t\n- Tree 命令：以树状结构显示文件目录结构，若 `tree -d` 则显示目录，不显示文件。\n\n- 查看文件内容\n\t- `cat 文件名`：查看文件内容、创建文件、文件合并、追加文件内容等功能。\n\t- `more 文件名`：分屏显示文件内容。\n\t- `grep 搜索文本的文件名`：搜索文件文件内容。\n\t\t- 例如搜索包含单词 “hello” 的文本，即 `grep \"hello\" sample.txt`。\n\t\t- 选项参数：`-n` 显示匹配行号；`-v` 显示不包含匹配文本的所有行；`-i` 忽略大小写。\n\n- Echo 命令与重定向\n\t- `echo` 命令：在终端中显示参数指定的文字。\n\t- 重定向 `>` 和 `>>`：\n\t\t- `>` 表示输出，会覆盖文件原有内容。\n\t\t- `>>` 表示追加，会将内容追加到已有文件的末尾。\n\t- `echo` 命令常结合 `重定向` 使用：\n\n\t\t```bash\n\t\t# 将字符串 \"Hello World\" 追加到\n\t\techo \"Hello World\" >> sample.txt\n\t\t```\n\t\n- 管道符 `|`\n\t- Linux 允许将一个命令的输出通过管道作为另一个命令的输入。\n\t- ls 命令与 grep 命令的结合使用，如从 Home 目录下搜索包含 \"python\" 关键字的文件或者文件夹：\n\n\t\t```bash\n\t\t# 从 Home 目录下搜索包含 \"python\" 关键字的文件或者文件夹\n\t\tls -al ~ | grep python\n\t\t```\n\t\n- Ifconfig 命令与 Ping 命令\n\t- `ifconfig` 命令可查看/配置计算机当前的网卡配置。\n\t- `ping` 命令一般用于检测当前计算机到目标计算机之间的网络是否畅通。\n\n\t\t```bash\n\t\t# 快速查看网卡对应的 IP 地址\n\t\tifconfig | grep inet\n\t\t```\n\n### 远程登录和复制文件\n\n#### 远程登录\n- 远程登录即通过 `SSH 客户端` 连接运行了 `SSH 服务器` 的远程机器上。\n- SSH 是目前较可靠，专为 `远程登录会话` 和 `其他网络服务` 提供安全性协议。\n\t- 有效防止远程管理过程中的信息泄露。\n\t- 对所有传输的数据进行加密，也能防止 DNS 欺骗和 IP 欺骗。\n- SSH 客户端是一种使用 `Secure Shell` 协议连接到远程计算机的软件程序。\n- SSH 客户端简单使用访问服务器：`ssh [-p port] user@remote`\n\t- `user` 是远程机器上的用户名。\n\t- `remote` 是远程机器地址，可为 IP、域名或别名。\n\t- `port` 是 SSH 服务器监听的端口，若不指定端口默认为 22。\n\n#### 复制文件\n- SCP 即 `Secure Copy`，是一个在 Linux 下用来进行 `远程拷贝文件` 的命令。\n\n\t```bash\n\t# 从本地复制文件到远程机器桌面上\n\tscp -P sample.py user@remote:Desktop/sample.py\n\t\n\t# 从远程机器桌面上复制文件夹到本地上\n\tscp -P port -r user@remote:Desktop/sample ~/Desktop/sample\n\t```\n\n#### SSH 高级用法\n\n##### 免密码登录\n免密码登录：即客户端访问服务端时，需要密码验证身份登录。\n\n- Step.01. 配置公钥：执行 `ssh-keygen` 即生成 SSH 密钥。\n- Step.02. 上传公钥到服务器：执行 `ssh-copy-id -p port user@remote`，让远程服务器记住我们的 `公钥`。\n\t\n\t> 1) 有关 SSH 配置信息都保存在 `/Home/your username/.ssh` 目录下。  \n\t> 2) 免密登录使用的是非对称加密算法 ( RSA )，即使用公钥加密的数据，需要使用私钥解密；使用私钥加密的数据，需要使用公钥解密。若有兴趣了解 `RSA 算法` 的原理及计算，可参考引用文章 [1]、[2]。\n\t\n\t![图5-2-1免密码登录实现原理图](/images/illustration/Programme/2018/09/life-is-short-we-need-python_5-2-1.png)\n\t<center>图 5-2-1 免密码登录实现原理图</center>\n\t\n##### 配置别名\n配置别名：每次输入 `ssh -p port user@remote` 是非常繁琐重复的工作，配置别名的方式以替代上述这么一串命令代码。\n\n- 在 `/.ssh/config` 文件下追加以下内容 ( 需建立 Config 文件 )：\n\n\t```vim\n\tHost mac\n\tHostName 192.168.10.1\n\tUser user\n\tPort 22\n\t```\n\t\n- 命令输入 `ssh mac` 即可实现远程登录操作 ( SCP 同样原理 )。\n\n\t```bash\n\t# 若配置别名后，待验证命令的格式:\n\t# 是否为: scp -r ~/Desktop/Sample mac:Desktop/Sample\n\t# 还是: scp -P 22 -r ~/Desktop/Sample mac:Desktop/Sample\n\t```\n\n### 用户和权限\n\n#### 基本概念\n- 在 Linux 中，可指定每一用户针对不同的文件或者目录的不同权限。\n- 对文件 / 目录包含的权限有：\n\n<center>表 5-3-1 文件/目录权限属性说明</center>\n\n| 权限 | 英文 | 缩写 | 数字代号 |\n| :---: | :---: | :---: | :---: |\n| 读 | read | r | 4 |\n| 写 | write | w | 2 |\n| 执行 | excute | x | 1 |\n\n#### 组\n- 为方便用户管理，提出组的概念。在实际开发中，可预先针对组设置好权限，然后将不同的用户添加到对应组中，从而不用依次为每个用户设置权限。\n\n| 权限名称 | 权限参数 | 说明 |\n| :---: | :---: | :---: |\n| user | u | 文件的拥有者，一般指当前用户 |\n| group | g | 文件所属的群组 |\n| other | o | 其他用户 |\n\n#### LL 命令\n- LL 命令即 LS 命令的扩展用法 `ls -al`。\n- LL 命令可查看文件夹下文件的详细信息，从左往右依次是：\n\t- 权限：第一个字符是 `d`，表示目录；`-` 表示文件；\n\t- 硬链接数：通俗理解即有多少种方式可访问到当前目录 / 文件；\n\t- 拥有者：当前用户；\n\t- 组：当前用户所属的组；\n\t- 文件大小，修改时间，文件 / 目录名称.\n\n<center>表 5-3-2 \"ls -al\" 查看文件的权限信息说明</center>\n\n| 目录 | 拥有者权限 | 组权限 | 其他用户权限 | 备注 |\n| :---: | :---: | :---: | :---: | :---: |\n| - | r w - |  r w -  |  r - -  | 文件权限示例 |\n| d |  r w x | r w x | r - x | 目录权限示例 |\n\n#### Chmod 命令\n- Chmod 命令：可修改 `用户/组` 对 `文件/目录` 的权限。\n\n\t```bash\n\t# 一次性修改拥有者/组的权限\n\tchmod +/-rwx 文件名/目录名\n\t# 一次性定制给某拥有者/组赋予某文件或者目录权限\n\t# 给予当前用户及所属群组对于该文件可读、可写、可执行权限\n\tchmod ug=rwx 文件名\n\t# 给予当前用户及所属群组对于该目录下所有文件可读、可写、可执行权限\n\tchmod ug=rwx -R 目录名\n\t```\n\n#### Sudo 命令\n- Sudo 命令：使用预设 ( root, 系统管理员 ) 的身份来执行命令。\n\n\t> Linux 系统中，通常使用标准用户登录及使用系统，通常 `sudo` 命令临时获得权限用于系统的维护与和管理。在执行一些模块的安装过程或者配置过程中，你会经常用到它的。\n\t\n### 系统信息相关命令\n- 查询时间和日期\n\t- `date`：查看系统时间。\n\t- `cal`：查看当月日历，`cal -y` 查看当年的日历。\n- 磁盘和目录空间\n\t- df：`df -h`，Disk Free 显示磁盘剩余空间。\n\t- du：`du -h`，Disk Usage 显示目录下的文件大小。\n- 进程信息\n\t- ps：`ps aux`，即 Process Status，查看进程的详细状况。\n\t- top：动态显示运行中的进程并排序。\n\t- kill：`kill [-9] 进程代号`，`-9` 表示强行终止，终止指定代号的进程。\n\n\t\t> 使用 `kill` 命令时，最好终止当前用户开启的进程，而不是终止 `root` 身份开启的进程。\n\t\t\n### 其他终端命令\n\n#### 查找文件\n查找文件：`find` 命令功能非常强大，通常在特定目录下搜索符合条件的文件。\n\n- 若省略路径，表示在当前文件夹下查找。\n- `find` 命令可结合 `通配符` 一起使用。\n\n\t```bash\n\tfind [路径] -name \"*.py\"\n\t```\n\t\n#### 软链接\n软链接：建立文件的软链接，通俗理解即 PC/MacOS 上的 `快捷方式`。\n\n- 源文件要使用绝对路径，即便于移动链接文件 (快捷方式) 仍能正常使用。\n- 没有 `-s` 选项是建立一个硬链接文件。\n\n\t```bash\n\tln -s 被链接的源文件 快捷方式的名称\n\t```\n\t\n- 在 Linux 中，文件名和文件的数据是分开储存的。\n\n\t![图5-5-1软、硬链接访问文件数据](/images/illustration/Programme/2018/09/life-is-short-we-need-python_5-5-1.png)\n\t<center>图 5-5-1 软、硬链接访问文件数据</center>\n\n#### 打包压缩\n- `tar` 是 Linux 中最常用的备份工具 ( **打包并不压缩** )，其命令格式如下：\n\n\t```bash\n\t# 选项 c：生成档案文件 (.tar)\n\t# 选项 x：解开档案文件\n\t# 选项 v：列出归档/解档的详细过程，显示进程\n\t# 选项 f：指定档案文件名称，选项 f 后应该紧跟 .tar 文件\n\t\n\t# 打包文件：打包放于同一目录下\n\ttar -cvf 打包文件.tar. 被打包文件路径\n\t\n\t# 解包文件\n\ttar - xvf 打包文件 [-C 目标路径]\n\t```\n\t\n- `tar` 与 `gzip` 命令结合可实现文件 `打包和压缩`，即 `tar` 只负责打包文件， `gzip` 负责压缩文件。\n\n\t```bash\n\t# 压缩文件：压缩文件放于同一目录下\n\ttar - zcvf 打包文件.tar.gz 被压缩文件路径\n\t\n\t# 解压缩文件\n\ttar -zxvf 打包文件.tar.gz\n\t\n\t# 解压缩文件到指定路径\n\ttar -zxvf 打包文件.tar.gz [-C 目标路径]\n\t```\n\n\t​\t\n## Python 基础\n\n### 引入\n\n#### Python 优缺点\n- Python 是面向对象 / 过程的语言 ( 对象和过程语言各有自己的优缺点 )：\n\t- 面向对象：由 `数据` 和 `功能组合而成的对象` 构建而成的程序。\n\t- 面向过程：由 `过程` 或仅仅是 `可重用代码` 构建起来的程序。\n\n#### Python 应用场景\n- Web 端程序：\n\t- mod_wsgi 模块：Apache 可运行用 Python 编写 Web 程序。\n\t- 常见 Web 框架：Django、TurboGears、Web2py、Zope 等。\n- 操作系统管理：服务器运维的自动化脚本。\n- 科学计算：NumPy、SciPy、Matplotlib 等。\n- 桌面端程序：PyQt、PySide、wxPython、PyGTK 等。\n- 服务端程序：Twisted ( 支持异步网络编程和多数标准的网络协议，包括客户端和服务端 )。\n\n#### Python 解释器\n- 当我们编写 Python 代码时，我们得到的是一个包含 Python 代码的以 `.py` 为扩展名的文本文件。要运行代码，就需要 Python 解释器去执行 `xxx.py` 文件。\n\n- CPython  \n\t- 当我们从 Python [官方网站下载](https://www.python.org/downloads/) 并安装好 Python 3.x 后，我们就直接获得了一个官方版本的解释器：`CPython` ( C 语言开发的 )。\n\t- 在命令行下运行  `python` 就是启动 CPython 解释器。\n\n- iPython   \n\t- iPython 是基于 CPython 之上的一个交互式解释器，即 iPython 只是在交互方式上有所增强，但是执行 Python 代码的功能和 CPython 是完全一样的。\n\t- 在命令行下运行  `ipython` 即可启动 iPython 交互式解释器。\n\t- CPython 用 `>>>` 作为提示符，而 IPython 用 `In [序号]:` 作为提示符。\n\n\t![图6-1-1Python与iPython提示符表现形式](/images/illustration/Programme/2018/09/life-is-short-we-need-python_6-1-1.jpg)\n\t<center>图 6-1-1 Python 与 iPython 提示符表现形式</center>\n\t\n- PyCharm\n\n\t工欲善其事，必先利其器。为帮助开发者更便捷、更高效来开发 Python 程序，一款集成开发编辑器 ( IDE ) 显得格外重要。IDE 除了快捷键、插件外，重要的是它还支持 `调试程序`。\n\n\t> 当然，支持 Python 程序开发的 IDE 还有很多优秀的产品：如：[Eclipse with PyDev](http://marketplace.eclipse.org/content/pydev-python-ide-eclipse)\n\t\n#### 第一个程序\n\n- 新建并运行 python 程序：`vi python_sample.py` 开始编写程序；通过 `python python_sample.py` 执行程序。以下为简单的 Python 示例：\n\n\t```bash\n\t# 声明部分\n\t# 取机器 Path 中指定的第一个 python 来执行脚本\n\t#!/usr/bin/env python\n\t# python.py 文件中包含中文字符，Python2 在文件头加入以下语句 ( Python3 是默认支持的 )：\n\t# -*- coding=utf-8 -*-\t\n\t\n\t# 代码部分\n\tprint(\"Life is short, you need python.\")\n\t\n\ta = 100\n\tA = 200\n\t\n\tif a >= 100: # 冒号 \":\" 结尾，缩进的语句即为代码块\n\t    print(a)\n\telse:\n\t    print(-A) # Python 是大小写敏感的\t\n\t```\n\n### 语言基础\n\n#### 注释\n- 行注释、块注释：行注释的风格与 Linux 中 Shell 脚本的注释相同，即以 `#` 开头的注释；块注释使用三个单引号 `'` 或三个双引号 `\"` 包裹实现。\n\n\t```python\n\t# 行注释\n\t# line 1...\n\t# line 2...\n\t\n\t'''\n\t' 单引号块注释\n\t' line 1\n\t' line 2\n\t'''\n\t\n\t\"\"\"\n\t\" 双引号块注释\n\t\" line 1\n\t\" line 2\n\t\"\"\"\n\t```\n\n#### 数据类型\n- `整型`：可处理 `任意大小` 的整数，当然包括 `负整数`。例如 0，1，100，-8080 等。\n- `浮点型`：即含有小数点的数，如 1.23，1.23e9 ( 1.23x10$^9$ )，1.23e-5 ( 1.23x10$^{-5}$ )\n\n\t> 1) 整数和浮点数在计算机内部存储的方式是不同的；  \n\t> 2) 整数运算永远是精确的，而浮点数运算则可能会有四舍五入的误差。\n\t\n- `字符型`：以单引号 `' ` 或双引号 `\"` ( 表示方式不同而已 ) 括起来的任意文本。例如 `'(1+2)\\%3 == 0'`，或者 `\"The 'a' is a lowercase letter of 'A'\"`。\n- `布尔型`：True / Flase 两种值。\n\t- 布尔运算：and、or、not，例如 `(3 > 2) and (1 > 2)`，输出 Flase。\n- `空值`：None，注意 None 不能理解为 0，因为 0 是有意义的，而 None 是一个特殊的空值。\n\n> Python 中的数据类型是没有大小限制的，若想定义无限大，可定义为无限大，即 `inf`。\n\n#### 常量变量\n\n##### 常量\n- 常量：例如定义 `PI = 3.14159`，其实际也是变量，只是约定俗成罢了。\n\n##### 变量\n- 形如 `param = value` 的形式赋予变量值，但不用赋变量数据类型。\n- 变量的输入与输出：\n\n\t```python\n\thigh = int( input(Please enter your high:) )\n\t# input() 默认输出 String 类型\n\tprint(\"Your high is: %d\" % high);\n\t```\n\n#### 字符编码\n- 一个字节，表示的最大的整数就是 255，即十进制为 255，二进制为 `11111111`。若想表示更大的整数则需要更多的字节。\n- `ASCII`：127 个字符编码，即大小写字母、数字和一些特殊字符。例如大些字母 A，对应的 ASCII 为 65。\n\n\t> 但处理中文显然一个字节是不够的 ( 至少两个字节 )，且还不能与 ASCII 编码冲突，所以中国制定了`GB2312` 编码。  \n\t>\n\t> 然而，世界有上百种语言，日本把日文编到 `Shift_JIS` 里，韩国把韩文编到 `Euc-kr` 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。   \n\t>\n\t> 因此，Unicode 应运而生 $^{[3]}$。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。\n\t\n- `Unicode`：2 字节及以上。\n\n\t> 为节约空间，把 Unicode 编码转化为“可变长编码”的 UTF-8 编码。\n\t\n- `UTF-8`：根据数字大小编写 1 ~ 6 字节，英文字母 1 字节，汉字 3 字节 ( 生僻字符用到 4 ~ 6 字节 )。\n\n- ACSII、Unicode 与 UTF-8 的关系\n\n<center>表 6-2-1 ACSII、Unicode 与 UTF-8 的关系</center>\n\n| 字符 | ASCII | Unicode | UTF-8 |\n| :---: | :---: | :---: | :---: |\n| A | 0100 0001 | 00000000 01000001 | 01000001 |\n| 中 | -- | 01001110 00101101 | 11100100 10111000 1010 1101 |\n\n- 启示：计算机系统通用的字符编码工作方式，如图 6-2-1 所示。\n\t- 用记事本编辑时，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，当保存的时再把 Unicode 转换为 UTF-8 保存到文件；\n\t- 浏览网页时，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器。\n\n\t![图6-2-1计算机系统通用的字符编码工作方式](/images/illustration/Programme/2018/09/life-is-short-we-need-python_6-2-1.png)\n\t<center>图 6-2-1 计算机系统通用的字符编码工作方式</center>\n\t\n#### 字符串/列表/元组/字典\n\n##### 字符串 Str\n- Python 3 中，字符串是以 Unicode 编码的。\n\t- Python 的字符串类型为 String，内存中以 Unicode 表示。若在网络中传输，则可以把 string 类型的数据变成以字节为单位的 `bytes`。\n\t- `encode()` 与 `decode()`：\n\t\t- 英文字符可用 ASCII 编码 Bytes，即 `\"ABC\".encode(\"ascii\")`。\n\t\t- 中文字符可用 UTF-8 编码，即 `\"中国\".encode(\"utf-8\")`。\n\n\t\t> 含有中文的 str 无法用 ASCII 编码，因中文编码的范围超过了 ASCII 编码的范围。强制编码会抛出异常：  \n\t\t> `'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)\n\t\t`。\n\t\n- 常用数据类型转换，见表 6-2-2 所示：\n\n<center>表 6-2-2 常用数据类型转换说明表</center>\n\n| 函数格式 | 使用示例 | 描述 |\n| --- | --- | --- |\n| int(x [,base]) | int(\"8\") 或 int('A', base = 16) | 可转换的包括 String 类型和其他数字类型，但高精度转换会丢失精度 |\n| float(x) | float(1) 或 float(\"1\") | 可转换 String 和其他数字类型，不足的位数用 0 补齐，例如 1 会变成 1.0 |\n| comple(real,imag) | complex(\"1\") 或 complex(1,2) | 第一个参数可以是 String 或者数字，第二个参数只能为数字类型，第二个参数没有时默认为 0 |\n| str(x) | str(1) | 将数字转化为 String |\n| repr(x) | repr(Object) | 返回一个对象的 String 格式 |\n| eval(str) | eval(\"12+23\") | 执行一个字符串表达式，返回计算的结果，如例子中返回 35 |\n| tuple(seq) | tuple((1,2,3,4)) | 参数可以是元组、列表或字典。若为字典时，返回字典的 key 组成的集合 |\n| list(s) | list((1,2,3,4)) | 将序列转变成一个列表，参数可为元组、字典、列表。若为字典时，返回字典的 key 组成的集合 |\n| set(s) | set(['b', 'r', 'u', 'o', 'n'])或者set(\"asdfg\") | 将一个可迭代对象转变为可变集合且去重复，返回结果可以用来计算差集 `x - y`、并集 `x l y`、交集 `x & y` |\n| frozenset(s) | frozenset([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) | 将一个可迭代对象转变成不可变集合，参数为元组、字典、列表等 |\n| chr(x) | chr(0x30) | chr() 用一个范围在 range (0～255) 内的整数作参数，返回一个对应的字符。返回值是当前整数对应的 ASCII 字符。 |\n| ord(x) | ord('a') | 返回对应的 ASCII 数值，或者 Unicode 数值 |\n| hex(x) | hex(12) | 把整数 x 转换为 16 进制字符串 |\n| oct(x) | oct(12) | 把整数 x 转换为 8 进制字符串 |\n\n- 字符串输入和输出：\n\n\t```python\n\tname = input(\"Enter your name:\")\n\tage = int( input(\"Enter your age:\") )\n\tprint(\"name: %s, age: %d\" % (name, age))\n\t```\n\t\n- 组成字符串的方式：\n\n\t```python\n\tstr1 = \"Hello\"\n\tstr2 = \"World\"\n\t\n\t# str3 组装成 \"HelloWorld\"\n\tstr3 = str1 + str2\n\t\n\t# 组装成 \"===HelloWorld===\"，此方式常用拼凑字符串\n\t\"===%s===\" % (str1 + str2)\n\t```\n\t\n- 字符串下标与取值：\n\n\t```python\n\tarray = \"ABCDE\"\n\t\n\tprint( array[0] ) # 输出 A\n\tprint( array[4] ) # 输出 E\n\tprint( array[-1] ) # 输出 E\n\t\n\t# 切片\n\tprint( array[0:3] ) # 输出 ABC\n\tprint( array[0:-1] ) # 输出 ABCD\n\tprint( array[0:] ) # 输出 ABCDE\n\t\n\t# 即以 2 为步进距离，从下标 0 开始取值至末尾，输出 ACE\n\tprint( array[0::2] )\n\t\n\t# 即以 -1 为步进距离，从末尾开始取值至开端，逆序输出\n\tprint( array[-1::-1] )\n\t```\n\t\n- 字符串常见操作\n\t- `find(s)` 与 `index(s)`：从目标字符串中寻找子串，找到会返回子串的起始下标；若找不到则返回 `-1`。index() 找到目标的情况和 find() 相同，找不到目标则会抛出异常。\n\n\t\t> 当然还有 rfind(s) 和 rindex()，即从右端开始寻找子字符串。\n\t\n\t- `count(str, start, end)`：即在目标字符串 `myStr`，求得 `str` 在位置 start 和 end 之间出现的次数。\n\n\t\t> 例如：`myStr.count(str, start = 0, end = len(myStr))`，\n\t\n\t- `replace(原始字符串, 目标字符串)` 或 `replace(原始字符串, 目标字符串，替代次数)`：\n\n\t\t> 例如：`myStr.replace(\"world\", \"python\")`\n\t\t\n\t- `split(str)`：根据 `str` 把原字符串切开。\n\t- `splitlines(str)`：将字符串中的每一行切割开来。\n\n\t\t> re.split(正则表达式, 目标字符串)，根据正则表达式切割字符。\n\n\t- `capitalize()` 与 `title()`：前者是把字符串中的第一个字符转为大写字母，后者是把字符串中每个单词的首字母转为大写。\n\t- `startsWith(str)` 与 `endsWith(str)`：前者是判断目标字符是否以字符串 str 开头，后者则是判断目标字符是否以字符串 str 结尾。\n\t- `lower()` 与 `upper()`：前者是将目标字符串全转为小写字母，后者是将字符串全转为大写字母。\n\t- `rstrip()`、`lstrip()` 与 `strip()`：去除字符串左边、右边或者两端的空白字符。\n\t- `partition(str)`：以 str 为中心，将目标字符串划分成左、中 ( str 本身 )、右三部分的字符串。\n\t- `isalpha()`、`isdigit()` 与 `isalnum()`：分别用于判断是否为字符，是否为数字和是否全为数字。\n\t- `join()`：例如 `str.join(array)`，即使用 str 将列表 array 的内容拼接起来。\n\n\t\t```python\n\t\tarray = ['A', 'B', 'C']\n\t\tstr1 = '&'\n\t\t# str2 被组装成 A&B&C，即将 str1 组装到字符数组中\n\t\tstr2 = str1.join(array) \n\t\t```\n\n##### 列表 List\n- 定义一个列表：`list = ['A', 'B', 'C', 'D']` 或者 `student = ['lucy', 25, 'female']`。\n- 列表的增删改查 ：\n\t- 增加：  \n\t1) 在列表尾部追加元素：`list.append('D')`   \n\t2) 自定义插入位置：`list.insert(位置，添加的内容)`   \n\t3) 往一列表中添加另一个列表：`student + list` 或者 `student.extend(list)`  \n\t- 删除：  \n\t1) 出栈：`list.pop()` / 入栈：`list.append()`  \n\t2) 根据下标来删除：`del list[0]`，清空列表 `del list[0::1]`  \n\t- 查询：  \n\t1) `('B' in list)` 结果为 Ture  \n\t2) `('D' not in list)` 结果为 Ture\n\n##### 元组 Tuple\n- 有序列表元组 ( Tuple )，与 List 不同，`Tuple 一旦初始化就不能修改`。\n\n\t> 定义一些常量参数时可用 Tuple。\n\n- 定义：`tuples = ('A', 'B', 'C')`。\n- 歧义：`tuple = (1)` 相当于 `tuple = 1`；`tuple(-1, )` 才是元组列表。\n- 事实： Tuple 中存储的是 `引用`。\n\n\t```python\n\ttuple = ('a', 'b', ['A', 'B'])\n\ttuple[2][0] = 'X'\n\ttuple[2][1] = 'Y'\n\t\n\t# 事实上，'A' 和 'B' 被改变为 'X' 和 'Y'\n\t# 即 Tuple 定义是不变的，只是 Tuple 上存储的 List 为引用\n\n \t```\n\n - 再议不可变对象：replace() 并没有改变字符串的内容，我们理解 `str` 是变量，`abc` 是字符串对象。replace() 相当于创建了新的字符串对象 `Abc`。\n\n\t```python\n\tstr = 'abc'\n\tprint( str.replace('a', 'A') ) # 输出 Abc\n\tprint(str) # 输出 abc\n\t```\n\n##### 字典 Dict\n- 字典 ( Dict )，其他语言中又称 Map，使用键值 ( key-value ) 存储。\n- 定义：`dict = {'name': 'Lucy', 'age'：25, 'gender': 'female}`。\n- 字典的增删改查：\n\t- 增加：`dict['high'] = 175`，若对应键值存在即修改的效果。\n\t- 删除：`dict.pop('high')` / `del dict['high']`\n\t- 查询：`dict.get('name')`，若找不到对应键值则抛出异常。\n\n##### 集合 Set\n- Set 与 Dict 类似，是一组 key 的集合，但不存储 value。\n- Set 可看成数学意义上的 `无序` 和 `无重复` 元素的集合。\n\n\t```python\n\tprint( set([1, 1, 2, 3, 4, 4, 5]) ) # 输出 [1, 2, 3, 4, 5]\n\t```\n\n#### 条件判断\n- 标准条件判断语句：\n\n\t```python\n\tif <condition 1>:\n\t    <action 1>\n\telif <condition 2>:\n\t    <action 2>\n\telse:\n\t    if <condition 3>: # if 嵌套\n\t        <action 3>\n\t```\n\n- 三元表达式：在 Python 中，可将 `if-else` 语句放到一行里，语法如下：\n\n\t```python\n\t# true-expr 或 false-expr 可以是任何 Python 代码\n\tvalue = true-expr if condition else false-expr\n\t\n\t# 上述三元表达式等同于标准条件判断语句的写法\n\tif condition:\n\t    value = true-expr\n\telse:\n\t    value = false-expr\n\t```\n\n#### 循环结构\n\n- `For` 循环与 `While` 循环\n\n\t```python\n\t# For 循环\n\tnames = ['LiMing', 'ZhangWei']\n\tfor name in names\n\t    print(name)\n    \n\t# While 循环\n\tsum = 0\n\ti = 0\n\twhile( i<100 ):\n\t    sum += 1\n\t    i += 1\n\t```\n\n- `Break` 与 `Continue`\n\t- Break：终止 ( 跳出 ) 循环。\n\t- Continue：中断本次循环。\n\n### 函数\n\n#### 定义函数\n- 定义函数使用 `def` 语句，依次写 `函数名`、`括号`、( 还可以包括 `参数` )、`冒号`。然后是 `函数体` ( 需缩进编写 )。\n\n\t```python\n\tdef FuncName(param):\n\t    <action>\n\t    return [返回参数]\n\t```\n\t\n- 空函数：模块化设计，即先架构后编码。\n\n\t```python\n\tdef FuncName(param):   \n\t    pass # 占位符：暂不书写代码逻辑\n\t```\n\t\n- 返回多个值：\n\n\t```python\n\tdef move(x, y):\n\t    x = x + 1\n\t    y = y + 1\n\t    return x, y\n\t    \n\tx, y = move(100, 100) # 其实返回的是一个 Tuple，即 (x, y)\n\t```\n\n#### 函数参数\n- 默认参数 ( 缺省参数 )：最大好处是降低调用函数难度，类似注册时，多数用户只关心核心的信息，即其余信息设置为默认值。\n\n\t> 注意：定义默认参数时，必须指向不变对象。如 n = 2，不能 n = m ( m 为变量 )\n\t\n\t```python\n\tdef power(x, n = 2):\n\t\ts = 1\n\t\twhile(n > 0):\n\t\t    n = n - 1\n\t\t    s = s * x\n\t\treturn s\n\t\t\n\tprint( power(5) ) # 输出 25\n\tprint( power(5, 3) ) # 计算 5 的 3 次方，输出 125\n\t```\n\t\n- 可变参数：顾名思义，可变参数就是传入的参数个数是可变的。\n\n\t```python\n\t# def calculator(numbers)，即理解 numbers 为一个 tuple\n\tdef calculator(*numbers): \n\t    sum = 0\n\t    for n in numbers:\n\t        sum = sum + n ** 2\n\t    return sum\n\t\n\t# 等价于 calculator( (1, 3, 5, 7) )\n\tprint( calculator(1, 3, 5, 7) ) # 输出 84\n\t```\n\t\n- 关键字参数：  \n\t`可变参数` 允许你传入 0 个或任意个参数，这些参数在函数调用时自动组装为一个 `元组` ( Tuple )。  \n\t`关键字参数` 允许你传入 0 个或任意个参数，这些关键字参数在函数内部自动组装成为一个 `词典` ( Dict )。  \n\n\t```python\n\tdef person(name, age, **kw): \n\t    print(' name:', name, ' age:', age, ' others:', kw)\n\t\n\tperson('Lucy', 35, city = 'Guangzhou', gender = 'M')\n\t# 输出  name: Lucy  age: 35  others: {'city': 'Guangzhou', 'gender': 'M'}\n\t\n\t# 当然，我们可先组装词典 dict，然后把该 dict 转换为关键字参数传进去\n\textra = {'city': 'Guangzhou', 'gender': 'M'}\t\n\t\n\t# 将字典中的元素，拆分成独立的 Key-Value 键值，引用时前缀也要加 \"**\"\n\tperson('Jack Ma', 50, **extra)\n\t# 输出 name: Jack Ma  age: 50  others: {'city': 'Guangzhou', 'gender': 'M'}\n\t```\n\t\n- 参数组合：Python 中定义函数，可多种参数组合使用，但必须满足一下参数定义顺序：`必选参数`、`默认参数`、`可变参数`、`命名关键字` 和 `关键字参数`。\n\n\t```python\n\tdef func(a, b, c = 0, *args, **kw):\n\t    print(' a=', a, ' b=', b, ' c=', c, ' args=', args, ' kw=', kw)\n\t\n\t# 输出 a=1 b=2 c=3 args=('a', 'b') kw={'x'=99}\n\tfunc(1, 2, 3, 'a', 'b', 'x'=99)\n\t```\n\n- 结合 `tuple` 和 `dict`：即通过类似 `func(*args, **kw)` 形式调用函数。参数虽可自由组合使用，但不要组合太复杂，以造成可理解性较差的结果。\n\n\t```python\n\targs = (1, 2, 3)\n\tkw = {'x' = 5, 'y' = 6}\n\tfunc(*args, **kw)\n\t```\n\n#### 递归函数\n- 函数内部可以调用其他函数。若一个函数内部调用了其自身，即该函数为 `递归函数`。\n\n\t```python\n\tdef fact(n):\n\t    if n == 1:\n\t        return 1\n\t    return n * fact(n - 1)\n\t```\n\t\n- 递归的过深调用会导致栈溢出。可通过 `尾递归` 优化。\n- 尾递归优化：解决递归调用栈溢出的方法，即函数返回时调用本身，并且 return 语句不能包含表达式。\n\n\t- 区别上述的 fact(n) 函数，由于 `return n * fact(n - 1)` 引入了乘法表达式，即非尾递归。\n\t- 而 `return fact_iter(num - 1, num * product)` 仅仅返回函数本身。\n\t- 这样，编译器 / 解释器就可对尾递归做优化，即使递归本身调用 n 次，都只占用一个栈帧，不会出现栈溢出的情况。\n\n\t```python\n\tdef fact():\n\t    return fact_iter(n, 1)\n\t    \n\tdef fact_iter(num, product):\n\t    if num == 1:\n\t        return product\n\t    return fact_iter(num -1, num * product)\n\t```\n\n### 高级特性\n\n#### 切片\n- 切片操作符：在 List 中指定 `索引范围` 的操作。  \n\t索引范围具体为： `起始位置:结束位置:步进` ，注意步进数 ( 默认为 1，不能为 0 )。\n\n\t```python\n\tlist = [11, 22, 33, 44, 55]\n\t\n\t# 输出 [11, 22, 33]，即从小标为 0 开始，步进为 1，取前 3 个元素\n\tprint( list[0:3:1] )\n\t```\n\n- 倒数切片：\n\n\t```python\n\tlist = ['A', 'B', 'C', 'D', 'E']\n\t\n\t# 输出 ['A', 'B', 'C', 'D']，即从下标为 0 开始，切片至倒数第一个元素 (不含其本身)\n\tprint( list[0:-1] )\n\t```\n\t\n- 字符串切片：\n\n\t```python\n\tstr = 'ABCDE'\n\t\n\t# 输出 ACE，即对字符串中所有字符作用，每隔两位取值\n\tprint( str[::2] )\n\t```\n\t\n- 注意：`Tuple` 也是一种 `List`，唯一不同的是 Tuple 不可变，因此 Tuple 不可用切片操作。\n\n#### 迭代\n- 迭代：给定一个 List 或 Tuple，通过 For 循环遍历这个 List 或 Tuple。\n\n\t```python\n\tlist = ['A', 'B', 'C', 'D', 'E']\n\t\n\tfor str in list:\n\t    print(str) # 输出 ABCDE\n\t```\n\t\n- `enumerate` 函数可以把一个 list 变成 `索引-元素树`，这样就可以在 For 循环中同时迭代 `索引` 和 `元素本身`。\n\n\t```python\n\tlist = ['A', 'B', 'C', 'D', 'E']\n\t\n\tfor i, value in enumerate(list):\n\t    print(i, value)\n\t```\n\n#### 列表生成式\n- 列表生成式：List Comprehensions，用于创建 List 的生成式。\n\n\t```python\n\tlist1 = []\n\t\n\tlist1 = [x**2 for num in range(1, 10)]\n\t# 输出 1x1，2x2，3x3, ..., 9x9\n\tprint(list1)\n\t\n\t'''\n\t等价于：\n\tfor num in range(1, 10):\n\t    list1.append(num ** 2)\n\t'''\n\t    \n\t# for 循环与 if 判断配合，例如取得 10 以内的偶数，求其平方数\n\tlist2 = [ num**2 for num in range(1, 10) if num%2 == 0 ]\n\t# 输出 2x2, 4x4, 6x6, 8x8\n\tprint(list2)\n\t\n\t# 两层 for 循环\n\tlist3 = [ m+str(n) for m in 'ABC' for n in range(1,4) ]\n\t# 输出 ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']\n\tprint(list3)\n\t\n\tlist4 = [ m*n for m in 'ABC' for n in range(1,4) ]\n\t# 输出 ['A', 'AA', 'AAA', 'B', 'BB', 'BBB', 'C', 'CC', 'CCC']\n\tprint(list4)\n\t\n\t# 列出当前目录下所有文件和目录名\n\timport os # 导入 os 模块\n\tlist = [d for d in os.listdir('.')] \n\t```\n\n#### 生成器\n- 引入：`列表生成式`，可直接创建一个列表。但受到内存限制，列表容量肯定是有限的。例如：我们需要一个包含 100 万个元素的列表 ( 列表中的元素按照某种算法推算出来 )，直接创建是不太现实的，那么我们是否可通过某种过程，实现 `动态推算` 并 `输出元素` ？ \n- Generator：`生成器`，即不用一步到位创建 list 对象，而是通过循环过程中不断推算出后续的元素。在 Python中，把这种一边循环一边计算的机制称作 `Generator`。\n- 创建 Generator：把列表生成式的 `[]` 改成 `()` 即可。\n\n\t```python\n\t# 受到内存限制，运行过程中可能会崩掉\n\tlist = [ x for x in range(1, int(10e10)) ]\n\t\n\t# 简单生成器\n\tgenerator = ( x for x in range(1, int(10e10)) )\n\tfor n in generator:\n\t    print(n)\n   \n\t# 简单示例：带 yield 的 Generator 函数\n\t# 1) 在每次循环时都执行，遇到 yield 语句返回\n\t# 2) 再次执行时，从上次返回的 yield 语句处继续执行\n\tdef odd():\n\t    print('First Return: ')\n\t    yield [1, 2, 3]\n\t    print('Second Return:')\n\t    yield (1, 2, 3)\n\t    print('Third Return:')\n\t    yield {'key': 'value'}\n\t    \n\tfor n in odd():\n\t    print(n)\n\t    \n\t# Fibonacci 数列\n\tdef fibonacci(times):\n\t    n, a, b = 0, 0, 1\n\t    while n < times:\n\t        yield b\n\t        (a, b) = (b, a+b)\n\t        n = n + 1\n\t    return 'done'\n\t    \n\tfor n in fibonacci(10):\n\t    print(n)\n\t```\n\n#### 迭代器\n- 可用于 for 循环的数据类型：\n\t- 集合数据类型：list、tuple、dict (字典)、set、str (字符串)\n\t- Generator 生成器和带 `yield` 的 Generator 函数\n- 可用于 for 循环的对象统称为可迭代对象 `Iterable`。\n\n\t```python\n\t# 使用 isinstance() 判断一个对象是否为 Iterable 对象\n\tform collections import Iterable\n\t\n\tisinstance([], Iterable) # True\n\tisinstance((x for x in range(1, 10)), Iterable) # True\n\tisinstance(100, Iterable) # False\n\t```\n\n- 生成器是 `Iterator` 对象；List、Dict、Str 虽然是 Iterable 对象，但却不是 `Iterator`。\n\t我们可以通过 `iter()` 函数，把 List、Dict、Str 等 Iterable 转换达成 `Iterator`。\n\t\n\t> Python 的迭代器 ( Iterator ) 对象表示的是一个数据流，即 Iterator 对象可被 `next()` 函数调用并不断返回下一个数据，直至没有数据时抛出 `StopIteration` 异常。\n\t\n\t```python\n\tisinstance(iter([]), Iterator) # True\n\tisinstance(iter('abc'), Iterator) # True\n\t```\n\t\n### 函数式编程\n\n- 函数：\n\t- `模块化编程`，即把大段功能代码拆分、封装成模块，通过层层调用，把复杂任务解构成简单任务。\n\t- 这种分解称之为 `面向过程` 的程序设计。\n\t- 函数是面向过程程序设计的 `基本单元`。\n- 函数式编程：\n\t- 就是一种抽象程序很高的 `编程范式`；\n\t- 纯粹的函数式编程语言编写的函数没有变量；\n\t- 函数式编程的特点：允许函数作为 `参数`，作为另一函数的 `输入`。\n\n#### 高阶函数\n- 变量可指向函数：\n\n\t```python\n\t# 直接调用函数\n\tx = abs(-10)\n\t\n\t# 变量可指向函数\n\tf = abs\n\tx = f(-10)\n\t\n\t# x 的结果都为 10\n\t```\n\t\n- 函数名也是变量：函数名其实就是指向函数的变量。\n\n\t> 注意：  \n\t> 1) 而在实际编码当中，绝对不能这样写，只是为了说明函数名也是变量。  \n\t> 2) 若需恢复 abs 函数，请重启 Python 交互环境。  \n\n\t```python\n\tabs = 10\n\tabs(-1)\n\t\n\t# 抛出异常\n\t# 即 abs 已指向一个整数 10，而不是指向求绝对值的函数。  \n\tTraceback (most recent call last):\n\t    File \"<stdin>\", line 1, in <module>\n\tTypeError: 'int' object is not callble\n\t```\n\t\n- 传入函数：一个函数接收另一个函数作为参数，称为 `高阶函数`。\n\n\t```python\n\tdef add(x, y, f):\n\t    return f(x) + f(y)\n\t    \n\t# 调用 add(-5, 6 abs) 时，计算的过程为：\n\t# x = -5\n\t# y = -6\n\t# f = abs\n\t# f(x) + f(y)\n\t```\n\n##### MapReduce\n- Python 内建了 map() 和 reduce() 函数。\n- Map / Reduce 的概念 ：\n\t- MapReduce 是一种编程模型，是 `处理` 和 `生成` 大型数据集的相关实现。\n\t- 用户指定一映射函数 `map()` 处理键/值对，以生成一组`中间键/值对`；同时也指定 `reduce()` 函数用以 `合并` 含相同中间键所关联的所有中间值。\n\n\t> 为了更加透彻理解 MapReduce，可研读  Google 关于 MapReduce 的论文：  \n\t> `MapReduce: Simplified Data Processing on Large Clusters` $^{[4]}$。\n\t\n###### Map 函数\n- map() 函数：其接收 `两个参数`，第一个是 `函数`，第二个是 `Iterable`。即 map 将传入的 `函数` 依次 `作用` 到序列的 `每个元素`，并把结果作为新的 `Iterator` 返回。\n\n\t```python\n\t# 例 1：有一个函数 f(x) = x*x，将其作用于一个 list = [1, 2, 3, 4, 5]\n\tdef f(x):\n\t    return x ** 2\n\t\n\t# 1) map() 函数\n\tr = map(f, [1, 2, 3, 4, 5])\n\tprint(list(r)) # 输出 [1, 4, 9, 16, 25]\n\t\n\t# 2) 不需要 map() 函数的等价写法\n\tlist = []\n\tfor n in [1, 2, 3, 4, 5]\n\t    list.append( f(n) )\n\tprint(list) # 输出 [1, 4, 9, 16, 25]\n\t\n\t# 例 2：map 作为高阶函数，事实上它把运算规则抽象了，如把 list 中数字转字符串\n\tlist( map(str, [1, 2, 3, 4, 5]) ) # 输出 ['1', '2', '3', '4', '5']\n\t```\n\t\n###### Reduce 函数\n- reduce() 函数：其接收 `两个参数`，第一个是 `函数`，第二个是 `Iterable`。即 reduce 把结果继续和序列的 `下一个元素` 做 `累积计算`。\n\n\t> reduce(f, [x1, x2, x3, x4]) 等价于 f( f( f(x1, x2), x3 ), x4 )\n\t\n\t```python\n\tfrom functools import reduce\n\tdef add(x, y):\n\t    return x + y\n\t\n\tprint( reduce(add, [1, 2, 3, 4, 5]) )\n\t```\n- 当然，上述的实例只是为了描述原理而设定，下面将结合 map() 与 reduce() 举例：\n\n\t```python\n\tfrom functools import reduce\n\t\n\t# 定义一计算公式\n\tdef fn(x, y):\n\t    return x * 10 + y\n\t\n\t# 定义一字符转数字的函数\n\tdef char2num(s):\n\t    digits = {'0': 10, '1': 20, '2': 30, '3': 40}\n\t    return digits[s]\n\t    \n\t# map/reduce 实现处理与计算的功能\n\tprint( reduce(fn, map(char2num, '0123')) )\n\t```\n\n##### Filter\n- Python 内建了 `filter()` 函数，用于过滤序列。\n- filter() 函数：接收 `两个参数`，一个是 `函数`，另一个是 `序列`。即 filter 把传入的函数作用于每个元素，然后根据返回值是 `True/False` 决定是否 `保留/丢弃` 该元素。\n\n\t> filter() 函数返回的是一个 Iterator，即一个惰性序列，故需要强迫 filter() 完成计算结果，如 list() 函数获得所有结果。\n\t\n\t```python\n\t# 在一个 list 中，删掉偶数，只保留奇数\n\tdef isOdd(n):\n\t    return n % 2 == 1\n\t    \n\t# 输出 [1, 3, 5]\n\tlist( filter(isOdd, [1, 2, 3, 4, 5]) )\n\t\n\t# 把一个序列中的空字符剔除\n\tdef rejectBlankStr(s):\n\t    return s and s.strip()\n\t    \n\t# 输出 ABC\n\tlist( filter(rejectBlankStr, ['A', 'B', '', None, 'C']) )\n\t```\n\n##### Sorted\n- 排序算法：排序的核心是 `比较两元素的大小`。若是数字则直接比较；但比较的若是字符串或两个字典，则比较过程需通过函数抽象实现。\n\n\t```python\n\t# 输出 [-6, 2, 12, 24, 36]\n\tprint( sorted( [36, 24, -6, 12, 2] ) )\n\t```\n\t\n- `sorted()` 也是一高阶函数，可接收一个 key 函数来自定义排序:\n\n\t```python\n\t# 输出 [2, -6, 12, 24, 36]\n\tprint( sorted([36, 24, -6, 12, 2], key = abs) )\n\t\n\t# 忽略大小写，实现字符串排序\n\t# 实现字符串的比较是根据 ASCII 实现比较的\n\tprint( sorted(['Bob', 'Lucy', 'Zoo', 'Danny'], key = str.lower) ) \n\t\n\t# 进行反向排序，可传入第三个参数实现\n\tprint( sorted(['Bob', 'Lucy', 'Zoo', 'Danny'], key = str.lower, reverse = True) )\n\t```\n\n#### 返回函数\n\n##### 函数作为返回值\n- 函数作为返回值：高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。\n\n\t```python\n\t# 通常情况实现一个可变参数的求和\n\tdef calcSum(*args):\n\t    ax = 0\n\t    for n in args:\n\t        ax = ax + n\n\t    return ax\n\t    \n\t# 若不想立刻求和，可不返回求和结果，而是求和函数\n\tdef lazySum(*args):\n\t    def sum():\n\t        ax = 0\n\t        for n in args:\n\t            ax = ax + n\n\t        return ax\n\t    return sum\n\t\n\t# 调用 lazySum() 时，返回函数而不是结果\n\tf = lazySum(1, 3, 5, 7, 9)\n\t\n\t# 调用 f，才真正计算求和的结果\n\tf()\n\t\n\t# 当每次调用 lazySum() 时，都会返回一个新的函数，既使传入参数相同\n\tf1 = lazySum(1, 3, 5, 7, 9)\n\tf2 = lazySum(1, 3, 5, 7, 9)\n\tprint( f1 == f2 ) # 输出 False\n\t```\n\n##### 闭包\n- 注意到上述例子返回的函数在其定义内部引用了局部变量 `args`，故当一个函数返回一个函数后，其内部的局部变量还被新函数引用。\n- 注意返回的函数并没有立刻执行，而是调用了 `f()` 才执行。\n\n\t```python\n\tdef count():\n\t    fs = []\n\t    for i in range(1, 4):\n\t        def f():\n\t            return i ** 2\n\t        fs.append(f)\n\t    return fs\n\t    \n\tf1, f2, f3 = count()\n\t# 输出 9::9::9\n\tprint( str(f1()) + '::' + str(f2()) + '::' + str(f3()) ) \n\t\n\t\"\"\"\n\t\" 实际结果为：f1() --> 9，f2() --> 9, f3() --> 9\n\t\" 全部结果都为 9，原因在于返回的函数引用了变量 i，但它并非立刻执行\n\t\" 需等到 3 个函数都返回时，它们所引用的变量 i 已经变成了 3，故最终结果是 9\n\t\"\"\"\n\t\n\t# 若需引用循环的变量\n\tdef count():\n\t    def f(j):\n\t        def g():\n\t            return j * j\n\t        return g\n\t    \n\t    fs = []\n\t    for i in range(1, 4):\n\t        fs.append( f(i) ) # f(i) 立刻执行，i 的当前值被传入 f()\n\t    return fs\n\t    \n\tf1, f2, f3 = count()\n\t# 输出 1::4::9\n\tprint( str(f1()) + '::' + str(f2()) + '::' + str(f3()) )\n\t```\n\n\t{% note danger %}\n\t返回闭包时牢记一点：返回函数不要引用任何循环变量，或后续会发生变化的变量。\n\t{% endnote %}\n\n#### 匿名函数\n- 当函数作为 `传入参数` 时，我们不需要显式地定义函数，直接传入匿名函数更便捷。\n- 关键字 `lambda` 表示匿名函数，冒号前面表示传入参数，后面为返回值 ( 一般为表达式运算后的结果 )，如 `lambda x, y : x+y`\n\n\t```python\n\t# 以 map() 函数为例\n\t# 输出 [1, 4, 9, 16, 25]\n\tprint( list(map(lambda x : x ** 2, [1, 2, 3, 4, 5])) )\n\t\n\t# 匿名函数实际为：\n\tdef f(x):\n\t    return x ** 2\n\t```\n\n- 匿名函数有一好处，即不必担心 `函数名冲突`。此外，匿名函数也是一个函数对象，可把匿名函数赋值给一个变量，再利用变量来调用。\n\n\t```python\n\tf = lambda x : x ** 2\n\tprint( f(5) ) # 输出 25\n\t```\n\t\n- 匿名函数作为返回值返回：\n\n\t```python\n\tdef build(x, y):\n\t    return lambda: x * x + y * y\n\t```\n\t\n#### 装饰器\n- 提示：对于装饰器，除了廖雪峰老师的教程外 ( 侧重原理讲解 )，还可参考程序员大咖的推文 [Python 装饰器的诞生过程](https://mp.weixin.qq.com/s/0nZTAjeftR3Xa9T9TbQc-g) ( 侧重具体实现讲解 )。\n\n- 引例：假设我们有 time() 函数，我们要增强 time() 函数的功能，比如在函数调用前后自动打印日志，但又不希望修改 time() 函数的定义。\n\n\t这种在代码运行期间动态增加功能的方式，称之为 `装饰器 (Decorator)`。\n\n\t```python    \n\tdef log(func):\n\t    def wrapper(*args, **kw):\n\t        print('call %s():' % func.__name__)\n\t        return func(*args, **kw)\n\t    return wrapper\n\t    \n\t@log\n\tdef time():\n\t    print('2018-11-11 23:11')\n\t```\n\n\n- 那么装饰器是如何实现的？在实现装饰器之前，我们有必要回顾函数的特性：\n\t- `函数作为变量传递`：函数作为变量来传递，代表的是一个函数对象。若函数不加括号，是不会执行的；\n\t- `函数作为参数传递`：一个函数可以接受另一个函数对象作为自己的参数，并对函数对象进行处理；\n\t- `函数作为返回值`：一个函数的返回值可以是另一个函数对象。\n\t- `函数嵌套及跨域访问`：一个函数 (主函数) 内部是可以嵌套另一个函数 (子函数) 的；\n\n\t```python\n\t# 函数作为变量传递\n\tdef add(x):\n\t    return x + 1\n\ta = add # 作为变量\n\t\n\t# 函数作为参数传递\n\tdef add(x):\n\t    return x + 1\n\tdef excute(f):\n\t    return f(3)\n\texcute(add) # 作为参数\n\t\n\t# 函数作为返回值\n\tdef add(x):\n\t    return x + 1\n\tdef get_add():\n\t    return add # 作为返回值\n\t\n\t# 函数嵌套及跨域访问\n\tdef outer():\n\t    x = 1\n\t    def inner():\n\t        print(x) # 被嵌套函数 inner 内部的 x 变量可以到封装域去获取\n\t    inner()\n\t    \n\touter()\n\t```\n\n- Python 中的装饰器是通过闭包实现的，即闭包就是引用了外部变量的内部函数，而闭包的实现正是利用了以上函数特性。具体实现：\n\t- `问题`：观察打印结果，从 func() 到 closure()，func 变成了closure，具体是怎么装饰的呢？\n\t- `解释`：closure 实际上是 outer(func)，func 作为参数传进 outer，outer 的子函数 inner 对 func 返回的结果进行了一番装饰，返回了一个装饰后的结果，最后 outer 返回 inner，可以说 inner 就是装饰后的 func，这就是一个函数被装饰的过程，重点在于执行 outer(func) 这个步骤，即执行 closure()。\n\n\t```python\n\tdef func():\n\t    return '函数 func'\n\t\n\tdef outer(x):\n\t    def inner(): # 函数嵌套\n\t        return '戴了 inner 帽子的' + x() # 跨域访问，引用了外部变量 x\n\t    return inner # 函数作为返回值\n\t\n\t# 函数 func 作为 outer 的参数，函数作为变量赋给 closure\n\tclosure = outer(func) \n\t\n\tprint( func() ) # 执行原始函数\n\tprint( closure() ) # 执行闭包\n\t\n\t# 执行结果：\n\t# 函数 func\n\t# 戴了 inner 帽子的函数 func\n\t```\n\n- 装饰器语法糖 `@`：Python 给我们提供了语法糖 `@`，我们想执行 outer(func)，只需要把 outer 函数 @ 到 func 函数的上即可。具体实现：\n\n\t```python\n\tdef outer(x):\n\t    def inner():\n\t        return '戴了 inner 帽子的' + x()\n\t    return inner\n\t\n\t@outer\n\tdef func():\n\t    return '函数 func'\n\t\n\tprint( func() ) # 输出：戴了 inner 帽子的函数 func\n\t```\n\n#### 偏函数\n- 例：int() 函数可把字符串转为整数，当且仅当传入字符串时，int() 函数默认按照 `10 进制转换`。\n\n\t```python\n\tprint( int('12345') ) # 输出 12345\n\t\n\t# int() 函数提供额外 base 参数，默认值为 10\n\t# 若传入 base 参数即可做 N 进制转换 ( N 进制转到 10 进制 )\n\tprint( int('10', base = 8) ) # 输出 8\n\tprint( int('A', base = 16) ) # 输出 10\n\t\n\t# 若我们要转换大量二进制字符串，则可通过定义函数\n\tdef int2(x, base = 2):\n\t    return int(x, base)\n\t    \n\t# 这样转换二进制就非常便捷了\n\tprint( int2('10000000') ) # 输出 128\n\tprint( int2('10101010') ) # 输出 170\n\t```\n\n- 其实 `functools.partial` 就是帮助我们创建一个偏函数，即其作用就是把一个函数的某些参数固定住 ( 设置默认值 )，返回一个新函数。\n\n\t```python\n\timport functools\n\tint2 = functools.partial(int, base = 2)\n\t```\n\t\n- 创建偏函数时，实际可接收 `函数对象`、`*args` 和 `**kw` 这三个参数。\n\n\t```python\n\tint2 = functools.partial(int, base = 2)\n\t\n\t# 相当于：\n\targs = '10001000'\n\tkw = {'base': 2}\t\n\tint(*args, **kw)\n\t```\n\t\n### 模块\n\n#### 基本概念\n- 一个 `.py` 文件称之为一个模块 (Module)，模块可避免函数名和变量名冲突。\n\n\t> ⚠️ 尽量不与 Python 内置函数名称相冲突，详细可参考 Python 标准函数库 $^{[6]}$。\n\t\n- 按目录来组织模块的方法，称为包 (Package)，可避免模块名称的冲突。\n\n\t> ⚠️ 创建模块的名称不能和 Python 自带的模块名称相冲突。例如系统自带 `sys` 模块。\n\n\t- `__init__.py` 该文件必须存在，否则 Python 就把当前 目录当作普通目录，而不是一个包了。\n\t- `__init__.py` 可以是空文件，也可含有代码。\n\t- `samplye.py` 的模块名称为 `mypython.sample`。\n\t- `__init__.py` 的模块名称为 `mypython`。\n\n\t```bash\n\tmypython\n\t  ├─ __init__.py\n\t  ├─ sample.py\n\t  └─ example.py\n\t```\n\t\n#### 使用模块\n- 以内建的 `sys` 模块为例，编写 `sample` 模块:\n\n\t```python\n\timport sys\n\t\n\tdef test():\n\t    args = sys.argv\n\t    if len(args) > 2:\n\t        for str in args:\n\t            print('%s' % str)\n\t    else:\n\t        print('Empty paramter')\n\t```\n\t\n- 作用域：在一模块中，我们可能会定义很多函数和变量。或许我们有这样的需求：有的函数和变量仅希望是在模块内部使用。Python 中通过 `_` 前缀实现的。\n\t- 正常的函数和变量名是公开的 (public)，可被直接引用。例如，`abc`、`x1`、`PI` 等。\n\t\t\n\t- 非公开的函数和变量 (private)，不应该被直接引用。例如 `_xxx`、`__xxx`。\n\n\t\t> `不应该` 被直接引用，而不是不能被直接引用，因为 Python 并没有一种方法可以完全限制访问 private 函数或者变量。\n\t\t\n\t- 使用 `private` 函数，实现代码封装和抽象的方法：\n\n\t\t```python\n\t\tdef __sayHello(name):\n\t\t    print('Hello' + name)\n\t\t\n\t\tdef greeting(name):\n\t\t    __sayHello(name)\n\t\t\n\t\t# 调用函数\n\t\tgreeting('Bob')\n\t\t```\n\t\t\n#### 第三方模块\n- Python 中，安装第三方模块是通过包管理工具 `pip` 完成的。 \n\t- 若是 `Mac/Linux` 用户，可跳过安装 `pip` 的步骤。\n\t- 若是 `Windows` 用户，则需要安装 `pip` 工具。( 安装方法自行搜索或参考 [7] )\n- 安装完包管理工具 `pip`，可通过 `pip install Pillow` (Python 2.x) 或 `pip3 install Pillow` (Python 3.x) 命令安装 Python Imaging Library (处理图像的工具库)。\n- 当然，Python 使用过程中需要安装和使用大量的第三方库，若通过上述方式安装未免太过繁琐，故我们可考虑直接安装 [Anaconda](https://www.baidu.com/link?url=wU4ubxmhQWv3nZxRpf8-49yE1jNiaKCbtn0a1tfl9V4OOvw4KG0FH0mbdC4REMDf&wd=&eqid=f287538e0000a002000000065bbc170c)。\n\n\tAnaconda，其是一个基于 Python 的数据处理和科学计算的平台，他已经内置了许多非常有用的第三方库。在完整完 Anaconda 后，重新在命令行中键入 `python`，出现以下信息即安装成功，可正常导库使用：\n\t\n\t```python\n\tpython\n\tpython 3.x.x | Anconda, Inc. | ... on darwin\n\t>>> import numpy # 直接倒入第三方模块即可\n\t```\n\t\n#### 模块搜索路径\n- 当我们试图搜索某一模块，若找不到会报错。\n\n\t```python\n\t>>> import mymodule\n\tTraceback (most recent call last)\n\t    File \"<stdin>\", line 1, in <module>\n\tModuleNotFoundError: No module named 'mymodule'\n\t```\n\t\n- 默认情况，Python 解释器会搜索当前目录，所有已安装内置模块和第三方模块，`搜索路径` 存放在 `sys 模块` 的 `path 变量` 中：\n\n\t```python\n\t# 若需要添加搜索目录\n\timport sys\n\tsys.path.append('/User/kofe/mypython')\n\tprint(sys.path) # 查看是否已添加\n\t```\n\n### 面向对象编程\n- `面向对象编程`，Object Oriented Programming，简称 OOP。是一种程序设计思想。其把对象作为 `程序基本单元`，且对象中包含了 `数据` 和 `操作的函数`。\n\n\t> 面向对象的程序设计把计算机程序视为一组对象集合，而每个对象都可接收其他对象发送的消息并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。\n\n- 面向对象的程序可理解为：`程序 = 对象 + 对象`；`对象 = 成员变量 + 成员函数`。\n- 对比 `面向过程编程`，即把计算机程序视为一系列的命令集合，或可理解为一组函数的顺序执行。\n- 面向过程的程序可理解：`程序 = 函数 + 算法`。 \n\n- 在 Python 中，所有数据都可视为对象。当然，可以通过类来自定义对象的数据类型。例如，我们定义一个 `Student` 类型来代表学生的范畴：\n\n\t```python\n\tclass Student(object):\n\t    # __xxx__ 为特殊变量或方法，有特殊用途，会在后面章节详细讲解\n\t    def __init__(self, name, score):\n\t        self.name = name\n\t        self.score = score\n\t    \n\t    def printScore(self):\n\t        print('name: %s, score: %s' % (self.name, self.score))\n\t        \n\tstu1 = Student('Lucy', 80)\n\tstu2 = Student('Danny', 90)\n\t\n\t# 给对象发送消息实际就是调用对应的关联函数\n\tstu1.printScore()\n\tstu2.printScore()\n\t```\n\t\n#### 类和实例\n- 面向对象的核心概念是 `类 (Class)` 和 `实例 (Instance)`，牢记类是抽象的模板。例如，上述的 `Student 类`，实例即根据类创建出一个个具体的对象 `stu1`、`stu2`。\n- 通过 `class` 关键字定义类：\n\t\n\t```python\n\t# 若没有合适的继承类，则默认使用 object 类，这是所有类最终都会继承的类\n\tclass Student(object):\n\t    pass\n\t```\n\t\n- 创建类的实例，如 `stu = Student()`\n\n- 由于类起到模板的作用，因此可在创建实例时，通过特殊方法 `__init__()`，把属性绑定进去。\n\n\t```python\n\tclass Student(object):\n\t    def __init__(self, name, score):\n\t        self.name = name\n\t        self.score = score\n\t\n\t#创建实例时，不需要传入 self，即实例本身\n\tstu = Student('Lucy', 95)\n\t```\n\n- `数据封装`：访问实例本身的数据，不通过外部函数访问，而是通过类的内部定义访问数据的函数，这样实现数据封装。\n\n\t```python\n\tclass Student(object):\n\t    def printInfo(self):\n\t        print('name: %s, score: %s' % (self.name, self.score))\n\t```\n\n#### 访问限制\n- `私有变量`：让内部属性不被外部访问，在 Python 中，通过双下划线 `__` 开头，变量变成私有变量。\n\n\t```python\n\tclass Student(object):\n\t    def __init__(self, name, score):\n\t        self.__name = name\n\t        self.__score = score\n\t     \n\t    # Getter 方法\n\t    def getName(self):\n\t        return self.__name  \n\n\t    def getScore(self):\n\t        return self.__score\n\t        \n\t    # Setter 方法\n\t    def setName(self, name):\n\t        self.__name = name\n\n\t    def setScore(self, score):\n\t        # Setter 方法修改属性值的好处，可定义规则约束有效值\n\t        if  0  <= score <= 100:\n\t            self.__score = score\n\t        else:\n\t            raise ValueError('Bad Score')\n\t\n\tstu = Student('Bob', 90)\n\t\n\t# 直接访问会报错误:\n\t# AttributeError: 'Student' object has no attribute '__name'\n\tprint( stu.__name ) \n\t\n\t# 实现数据封装后\n\t# 使用 Getter 函数访问属性\n\tprint( stu.getName() )\n\t# 使用 Setter 函数修改属性\n\tstu.setName('Lucy')\n\t```\n\n- 在 Python 中，类似 `__xxx__` 的变量名，是 `特殊变量`，可直接访问。\n- 在 Python 中，私有变量 `_xxx` 和 `__xxx`，也是可以外部访问的。其实 Python 编译器是会把变量名修改为 `_类名__变量名`，致使直接访问报错。例如：`_Student__name`，通过 `stu. _Student__name ` 可实现外部访问 “私有变量”。\n\n\t> ⚠️ 当然，我们不建议这样做。因为不同版本的 Python 解释器可能会把 `__xxx` 改成不同变量名称。我们还是按照 `约定俗成` 的规定，视 `__xxx` 为私有变量。\n\n#### 继承和多态\n- `继承`：在面向对象程序设计中，可从某个现有类继承，新的类称为 `子类`，被继承的类称为 `基类、父类或超类`，例如：\n\n\t```python\n\tclass Animal(object):\n\t    def run():\n\t        print('Animal is running...')\n\t \n\t# Animal 实现了 run() 方法，Dog 继承 Animal 类\n\t# Dog 作为子类自然也拥有了 run() 方法\n\tclass Dog(Animal):\n\t    def run():\n\t        print('Dog is running...')\n\n\t# 当然，子类还可以重写方法和增加方法\n\tclass Cat(Animal):\n\t    def run():\n\t        print('Cat is running...')\n\t    def call():\n\t        print('Miao, Miao, Miao...')\n\t    \n\t```\n\n- `多态`：把不同子类对象都当作父类来看，可屏蔽不同子类对象之间的差异，写出通用代码。具体地，我们可从实例中理解多态：\n\n\t```python\n\tdef runTwice(animal):\n\t    animal.run()\n\t    animal.run()\n\t    \n\trunTwice( Animal() ) # 输出：Animal is running...\n\trunTwice( Dog() ) # 输出：Dog is running...\n\trunTwice( Cat() ) # 输出：Cat is running...\n\t```\n\n#### 获取对象信息\n- `type()` 函数：可判断对象类型\n\t\n\t```python\n\t# 基本类型\n\ttype(12345) # <class 'int'>\n\ttype('hello') # <class 'str'>\n\ttype(None) # <type(None) 'NoneType'>\n\t\n\t# 变量指向函数或者类\n\ttype(abs) # <class 'builtin_function_or_method'>\n\t\n\t# type() 函数返回类型\n\ttype(12345) == int # True\n\ttype('HelloWorld') == str # True\n\t\n\t# 判断其他类型\n\timport types\n\ttype(abs) == types.BuiltinFunctionType # True\n\ttype(lambda x:x) == types.lambdaType # True\n\ttype( (x for x in range(10)) ) == types.GeneratorType # True\n\t```\n\t\n- `isinstance()` 函数\n\t- 判断基本类型：`isinstance('abc', str)`，`isinstance(b'a', bytes)`  \n\t- 判断 class 类型：如有继承关系，如 `object -> Animal -> Dog`，则有：  \n\ta = Animal() => isinstance(a, Animal) =>True  \n\td = Dog() => isinstance(d, Animal) =>True  \n\td = Dog() => isinstance(d, Dog) =>True  \n\n- `dir()` 函数：若要获得一个对象的 `所有属性和方法`，可使用该函数。它返回一个包含字符串的 `list`。例如，获得一个 str 对象的所有属性和方法。\n\t\n\t```python\n\t# 输出：['__add__', '__class__', ... 'zfill']\n\tdir('abc') \n\t```\n\t\n- 类似 `__xxx___` 的属性和方法在 Python 中都有特殊用途。如 `__len__()` 方法返回长度。调用 `len()` 函数，在函数内部实际是它自动地去调用该对象的 `__len__（)` 方法，故下面代码是等价的。\n\t\n\t```python\n\tlen('abc') == 'abc'.__len__() # 输出 True\n\t```\n\t\n- 仅仅把属性和方法列出来是不够的，配合 `getattr()`、`setattr()` 及 `hasattr()`，我们可直接操作一个 `对象的状态`。\n\n\t```python\n\tclass Retangle(object):\n\t    def __init__(self):\n\t        self.x = x\n\t        self.y = y\n\t    def area(self):\n\t        return self.x * self.y\n\t\n\trectangle = Rectangle(5, 10)\n\t\n\thasattr(rectangle, 'z') # 是否含有属性 z\n\tsetattr(rectangle, 'z', 1) # 设置一个属性 z，令其等于 1\n\tgetattr(rectangle, 'z') # 获取属性 z\n\t\n\t# 也可以获得对象方法\n\tif hasattr(rectangle, 'area'):\n\t    fn = getattr(rectangle, 'area')\n\t```\n\n#### 实例属性和类属性\n- 给实例绑定属性的方法是通过 `实例变量` 赋值，或通过 `self 变量` 赋值。\n\n\t```python\n\tclass Student(object):\n\t    # self 变量赋值\n\t    def __init__(self, name, score):\n\t        self.name = name\n\t        self.score = score\n\t\n\tstu = Student('Bob', 80)\n\t# 实例变量赋值\n\tstu.gender = 'male'\n\t```\n\t\n- 给类绑定属性，直接在 `class` 中定义属性即可。\n\n\t> Tips：编写程序时，不要对 `实例属性` 和 `类属性` 使用相同名称，若含有相同名称的实例属性，将屏蔽掉同名称的类属性。\n\t\n\t```python\n\tclass Student(object):\n\t    grade = 'postgraduate'\n\t    \n\tstu = Student('Lucy', 95)\n\tprint( stu.grade ) # 与 print(Student.grade()) 效果相同\n\t```\n\n### 面向对象高级编程\n\n#### 使用 @property\n- `引入`：在「[访问限制](https://www.kofes.cn/2018/09/life-is-short-we-need-python.html#访问限制)」章节中，我们通过 setScore() 和 getScore() 方法实现修改数据和获取数据，以实现数据封装。\n\n\t那么本节提及 `@property`  属性，到底是何意图？先看看原始的 Setter 和 Getter 使用方法：\n\t\n\t```python\n\tclass Student(object):\n\t    # Getter 方法\n\t    def getScore(self):\n\t        return self.__score\n        \n\t    # Setter 方法\n\t    # setXXX() 方法还可书写规则以约束输入数据或检查数据\n\t    def setScore(self, score):\t        \n\t        if  0  <= score <= 100:\n\t            self.__score = score\n\t        else:\n\t            raise ValueError('Bad Score')\n\t\n\tstu = Student()\n\tstu.set_score(90)\n\tprint( stu.get_score() )\n\t```\n\t\n- `改进`：在操作逻辑层面，Python 还提供了更多特性，既直接 `调用变量的方式操作属性`，又不破坏数据的封装特性，`@property 装饰器` 的作用就在于此。\n\n\t```python\n\tclass Student(object):\n\t\n\t@property\n\tdef score(self):\n\t    return self.__score\n\t\n\t@score.setter\n\tdef score(self, value):\n\t    if not isinstance(value, int):\n\t        raise ValueError('Score must be an integer!')\n\t    if value < 0 or value > 100:\n\t        raise ValueError('score must between 0 ~ 100!')\n\t    self.__score = value\n\t    \n\tstu = Student()\n\tstu.score = 90 # 实际转化为 s.set_score(90)\n\tprint( stu.score ) # 输出 90\n\t```\n\n#### 多重继承\n- 继承是面向对象编程的一个重要的特性。通过继承，子类可以扩展父类的功能。\n- 在 Python 中，多实现多重继承，子类就可同时获得多个父类的所有功能。这种设计模式也叫 `MixIn`。\n\n\t> ⚠️ 同样是面向对象编程的语言，Java 只允许单继承，即一个类最多只能显示地继承于一个父类。当然，Java 要获得更多 “属性能力”，也可通过实现接口的方式实现。\n\t\n\t```python\n\t# 需求：我们赋予不同动物不同的能力\n\t\n\tclass Walking(object):\n\t    def walk(self):\n\t        print('Walking...')\n\t\n\tclass Swimming(object):\n\t    def swim(self):\n\t        print('Swimming...')\n\t\n\tclass Flying(object):\n\t    def fly(self):\n\t        print('Flying...')\n\t\n\t# 定义一双栖动物：通过继承父类，从而获得对应能力\n\tclass Amphibian(Walking, Swimming):\n\t    pass\n\t    \n\t# 定义一只天鹅：能走能飞能游泳\n\tclass Swan(Walking, Flying, Swimming):\n\t    pass\n\t```\n\n#### 定制类\n- 形如 `__xxx__` 的变量或者函数名在 Python 中是有特殊用途的。例如：`__slots__` 用于限制能绑定的属性，`__len__()` 方法返回对象本身的长度。\n\n\t除此之外，Python 的 class 中还有许多这样有特殊用途的 `属性` 和 `函数`，可帮助我们定制属性和定制类。\n\n#####  \\_\\_slots\\_\\_\n- 当我们创建一 class 实例后，可给该实例绑定 `任何` 属性和方法，这正体现了动态语言的灵活性。\n\n\t```python\n\tclass Student(object):\n\t    pass\n\t\n\t# 创建实例\n\tstu = Student()\n\t\n\t# 绑定属性\n\tstu.name = 'Bob'\n\tstu.score = 80\n\t\n\t# 绑定方法\n\tfrom types import MethodType\n\t\n\tdef setAge(self, age):\n\t    self.age = age\t\n\tstu.setAge = MethodType(setAge, stu) # 给实例绑定方法\n\tstu.setAge(25)\n\t\n\t# 上述方式只对本实例对象有效，若要所有实例对象起效，则需给 class 绑定方法\n\tdef setGrage(self, grade):\n\t    self.grade = grade\n\tStudent.setGrage = setGrage\n\t```\n\n- `动态绑定`：允许我们在程序运行的过程中动态给 class 添加功能 (方法)。\n- `限定实例的属性`：定义特殊变量 `__slots__`，可限制 class 实例能添加的属性。\n\t- 当子类定义了 slots 时，子类会继承父类的 slots，那么子类实例能添加的属性是子类与父类 slots 的 `并集`。\n\t- 当子类定义中没有 slots 时，父类的 slots 对子类不起作用。\n\n\t```python\n\tclass Student(object):\n\t    __slots__ = ('name', 'score', 'gender', 'age')\n\t    \n\tstu = Student()\n\tstu.email = 'admin@kofes.cn' # email 不在限定内，会报 AttributeError 错误\n\t```\n\n##### \\_\\_getattr\\_\\_\n- 正常情况下，当我们调用类的方法或属性，若不存在则会报错。例如定义 Student 类：\n\n\t```python\n\tclass Student(object):\n\t    def __init__(self):\n\t        self.name = 'Bob'\n        \n\tstu = Student()\n\tprint(stu.name) # 输出 Bob\n\tprint(stu.score) # 没有对应属性故会报 AttributeError 错误\n\t```\n\t\n- 要避免这个错误，除了补上 score 属性外，Python 还有另一个机制，即通过 `__getattr__()` 方法，动态返回一个属性。\n\n\t```python\n\tclass Student(object):\n\t    def __init__(self):\n\t        self.name = 'Bob'\n\t    def __getattr__(self, attr):\n\t        if 'score' == attr:\n\t            return 90\n\t            \n\t# 注意：只有在没有找到属性的情况下，才调用 __getattr__\n\t# 已有的属性，不会在 __getattr__ 中查找\n\tprint(stu.score) # 输出 90\n\t\n\t# 注意：若在 __getattr__ 也没有匹配属性，则返回 None\n\t# __getattr__ 默认返回 None\n\tprint(stu.age) # 输出 None\n\t```\n\t\n- 要让 class 只响应特定的几个属性，我们就要按照约定，抛出 `AttributeError` 错误即可：\n\n\t```python\n\tclass Student(object):\n\t    def __init__(self):\n\t        self.name = 'Bob'\n\t    def __getattr__(self, attr):\n\t        if 'score' == attr:\n\t            return 90\n\t        raise AttributeError(\n\t            '\\'Student\\' object has no attribute \\'%s\\'' % attr)\n\t```\n\t\n##### \\_\\_iter\\_\\_\n- 若想让一个类用于 `for ... in` 循环，类似 list 或 tuple 那样，就必须实现一个 `__iter__()` 方法，该方法返回一个 `迭代对象`，然后 Python 的 For 循环就会不断调用该迭代对象的 `__next__()` 方法拿到循环的下一个值，直到遇到 `StopIteration` 错误时退出循环。\n\n\t我们以斐波那契数列为例，写一个 Fib 类作用于 For 循环 ：\n\n\t```python\n\tclass Fib(object):\n\t    def __init__(self):\n\t        self.a, self.b = 0, 1 # 初始化两个计数器 a，b\n\t\n\t    # 方法重写\n\t    def __iter__(self):\n\t        return self # 实例本身就是迭代对象，故返回自己\n\t\t\n\t    # 方法重写\n\t    def __next__(self):\n\t        self.a, self.b = self.b, self.a + self.b # 计算下一个值\n\t        if self.a > 100000: # 退出循环的条件\n\t            raise StopIteration()\n\t        return self.a # 返回下一个值\n\t\n\t# Fib 实例作用于 For 循环：  \n\tfor n in Fib():\n\t    print(n)\n\t```\n\n- 对于定制类，我们让其实现了 `__iter__()` 和 `__next__()` 方法，那么它就是一个 `Iterator` 类型的，这正是动态语言的特性。  \n\n\t{% note success %}\n\t这种特性称为 `动态语言` 的 `鸭子类型`，动态语言并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。\n\t{% endnote %}\n\n##### \\_\\_call\\_\\_\n- 一个对象实例可以有自己的属性和方法，当我们调用实例方法时，使用 `instance.method()` 来调用。能不能直接在实例本身上调用呢？\n\n\t答案是可以的。任何类，只需要定义一个 `__call__()` 方法，就可以直接对实例进行调用。\n\t\n\t```python\n\tclass Student(object):\n\t    def __init__(self, name):\n\t        self.name = name\n\t    def __call__(self):\n\t        print('My name is %s.' % self.name)\n\t\n\t# 调用方式\n\tstu = Student('Bob')\n\tstu() # 输出 My name is Bob.\n\t```\n\n#####  更多定制\n- Python的 class 允许定义许多定制方法，让我们非常方便地生成特定的类。更多的定制方法请参考 Python 的官方文档：[Special Method Names](https://docs.python.org/3/reference/datamodel.html#special-method-names)。\n\n#### 使用枚举类\n- 在 Python 中，我们定义常量是采用 `约定俗成` 的方法来定义的，例如：`PI = 3.14159`。但其本质仍然是 `变量`。\n- 而本节介绍的枚举类，通过 `Enum` 定义一个 `class` 类型，然后，每个常量都是 class 的一个 `唯一实例`。例如：定义 `Month` 类型的枚举类。\n\n\t```python\n\tfrom enum import Enum\n\tMonth = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n\t    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))\n\t\n\tfor name, member in Month.__members__.items():\n\t    # value 属性：则是自动赋给成员的 int 常量，默认从 1 开始计数\n\t    print(name, '=>', member, ',', member.value)\n\t\n\t'''\n\t' 输出结果：\n\t' Jan => Month.Jan , 1\n\t' Feb => Month.Feb , 2\n\t' Mar => Month.Mar , 3\n\t' Apr => Month.Apr , 4\n\t' May => Month.May , 5\n\t' Jun => Month.Jun , 6\n\t' Jul => Month.Jul , 7\n\t' Aug => Month.Aug , 8\n\t' Sep => Month.Sep , 9\n\t' Oct => Month.Oct , 10\n\t' Nov => Month.Nov , 11\n\t' Dec => Month.Dec , 12\n\t'''\n\t\n\t# 当然，我们还可以这样访问枚举类\n\tprint( Month.Jan ) # 输出 Month.Jan\n\tprint( Month(1) ) # 输出 Month.Jan\n\tprint( Month['Jan'] ) # 输出 Month.Jan\n\tprint( Month.Jan.value ) # 输出 1\n\t```\n\t\n- 若有需求，我们可精确地控制枚举类型，即从 `Enum` 派生出自定义类：\n\n\t```python\n\tfrom enum import Enum, unique\n\t\n\t@unique\n\t# @unique 装饰器可以帮助我们检查保证没有重复值\n\tclass Weekday(Enum):\n\t    Sun = 0\n\t    Mon = 1\n\t    Tue = 2\n\t    Wed = 3\n\t    Thu = 4\n\t    Fri = 5\n\t    Sat = 6\n\t```\n\n### 错误/调试/测试\n\n#### 错误处理\n##### 返回错误码\n- 在操作系统提供的调用中，返回错误码非常常见。比如打开文件的函数 open()，成功时返回文件描述符 (就是一个整数)，出错时返回 `-1`。同理，我们设计函数时，也可相仿地设置返回代码。\n\n\t```python\n\tRESULT_OK = 0\n\tRESULT_FALSE = -1\n\t\n\tdef test():\n\t    if false:\n\t        return RESULT_FALSE\n\t    return RESULT_OK\n\t```\n\t\n##### 异常错误\n- 高级语言通常都内置了一套 `try...except...finally...` 的错误处理机制，Python 也不例外，使用方法见实例：\n\n\t```python\n\ttry:\n\t    result = 10 / int('2')\n\t    # result = 10 / 0\n\t    print('result:', result)\n\texcept ValueError as e:\n\t    # 抛出非数值异常错误\n\t    print('ValueError:', e)\n\texcept ZeroDivisionError as e:\n\t    # 抛出被除数为零的异常错误\n\t    print('ZeroDivisionError:', e)\n\telse:\n\t    # 若没有错误发生可在 except 语句块后加一个 else\n\t    # 当没有错误发生时，会自动执行else语句\n\t    print('no error!')\n\tfinally:\n\t    # 若设置了 finally 则一定会被执行，但可不设置 finally 语句\n\t    print('finally...')\n\t```\n\t\n- Python 的异常类型其实也是 class，所有的异常类型都继承自 BaseException，常见的错误类型和继承关系见：[Python. Exception hierarchy](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)\n\n\t故在使用 except 时需要注意的是：它不但捕获该类型的错误，还把其子类也 “一网打尽”，例如：\n\t\n\t```python\n\ttry:\n\t    foo()\n\texcept ValueError as e:\n\t    print('ValueError')\n\texcept UnicodeError as e:\n\t    print('UnicodeError')\n\t    \n\t# 假设 foo() 函数运行错误，则输出 \"ValueError\"\n\t# 第二个 except 永远也捕获不到 UnicodeError\n\t# 因为 UnicodeError 是 ValueError 的子类，即异常被第一个 except 给捕获了\n\t```\n\n##### 调用栈\n- 在函数嵌套调用中，若错误没有被捕获，它就会一直往上抛，直至被 Python 解释器捕获，并打印一个错误信息然后程序退出。因此当发生错误时，一定要分析错误的 `调用栈` 信息，定位错误的位置，找出 `错误根源`。\n\n\t```python\n\t# err.py\n\t# 定义函数\n\tdef foo(src):\n\t    return 10 / int(src)\n\tdef bar(src):\n\t    return foo(src) * 2\n\tdef main():\n\t    bar('0')\n\t\n\tmain() # 调用函数\n\t\n\t# 抛出异常错误，错误的跟踪信息如下：\n\tTraceback (most recent call last):\n\tFile \"err.py\", line 11, in <module>\n\t    main()\n\tFile \"err.py\", line 9, in main\n\t    bar('0')\n\tFile \"err.py\", line 6, in bar\n\t    return foo(s) * 2\n\tFile \"err.py\", line 3, in foo\n\t    return 10 / int(s)\n\tZeroDivisionError: division by zero\n\t```\n\n##### 抛出异常\n- 异常类型属于 class，捕获一个异常就是捕获到该 class 的一个实例。因此，异常并不是凭空产生而是 `有意` 创建并抛出的。Python 的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出异常。\n\n\t如果要抛出错误，首先根据需要定义一个异常的 class，并选择好继承关系，然后用 `raise` 语句抛出一个异常实例：\n\t\n\t```python\n\t# 只有在必要的时候才定义我们自己的错误类型\n\t# 尽量使用 Python 内置的错误类型，例如 ValueError，TypeError\n\tclass FooError(ValueError):\n\t    pass\n\t\n\tdef foo(s):\n\t    n = int(s)\n\t    if 0 == n:\n\t        raise FooError('invalid value: %s' % s)\n\t    return 10 / n\n\t\n\tfoo('0')\n\t```\n\n#### 调试\n- 推荐 IDE 调试，即设置断点、单步执行，就需要一个支持调试功能的 IDE。目前比较好的 Python IDE 有： `PyCharm` 和 `Eclipse vs pyDev`。\n\n#### 单元测试\n- 单元测试是用来对一个 `模块`、`函数` 或 `类` 来进行正确性检验的 `测试` 工作。\n- 这种以 `测试驱动` 的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的 `测试用例`。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。\n- 为了编写单元测试，我们需要引入 Python 自带的 `unittest` 模块。以下为一个 `单元测试` 的示例：\n\n\t```python\n\timport unittest\n\t\n\t# 继承unittest.TestCase\n\tclass MyTest(unittest.TestCase):  \n\t\n\t    # 每个测试用例执行之后做操作\n\t    def tearDown(self):\n\t        print('After each testcase...')\n\t        \n\t    # 每个测试用例执行之前做操作\n\t    def setUp(self):\n\t        print('Before each testcase...')\n\n\t    @classmethod\n\t    # 必须使用 @classmethod 装饰器，所有 test 运行完后运行一次\n\t    def tearDownClass(self):\n\t        print('After all testing...')\n\t        \n\t    @classmethod\n\t    # 必须使用 @classmethod 装饰器，所有 test 运行前运行一次\n\t    def setUpClass(self):\n\t        print('Before all testing...')\n\n\t    def testTestcaseA(self):\n\t        self.assertEqual(1, 1)  # 测试用例\n        \n\t    def testTestcaseB(self, elem1 = 'a', elem2 = 'A'):\n\t        self.assertEqual(elem1, elem2)  # 测试用例\n      \n\t# 一旦编写好单元测试就可运行单元测试，最简单的运行方式是在最后加上两行代码：\n\tif __name__ == '__main__':\n\t    unittest.main()\n\t```\n\n- 下面是一些常用的断言，也就是校验结果：\n\n\t```python\n\tassertEqual(a, b)\t\t# a == b\n\tassertNotEqual(a, b)\t\t# a != b\n\tassertTrue(x)\t\t\t# bool(x) is True\n\tassertFalse(x)\t\t\t# bool(x) is False\n\tassertIsNone(x)\t\t\t# x is None\n\tassertIsNotNone(x)\t\t# x is not None\n\tassertIn(a, b)\t\t\t# a in b\n\tassertNotIn(a, b)\t\t# a not in b\n\t```\n\n### 面向 I/O 编程\n- `I/O`：即输入/输出 ( Input/Output )。\n\n- `I/O 接口`：是 `主机` 与 `被控对象` 进行 `信息交换` 的纽带。例如，程序运行时数据是在内存中驻留的，由 CPU 来执行计算、控制，其中涉及到的数据交换则由磁盘、网络等实现。具体地，I/O 接口的功能就是负责选址、传送命令、传送数据等。\n\n- `I/O 编程`：`操作 I/O` 是由 `操作系统` 完成的，且操作系统会提供低级 `C 接口`，即对 I/O 操作进行 `封装`，高级语言通过调用 (函数) 的方式实现操作 I/O 的目的。Python 也不例外，即面向 I/O 接口编程。\n\n- 程序完成 I/O 操作会有 Input 和 Output 两个 `数据流`：\n\t- `Stream (流)` 是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。\n\t- `Input Stream` 就是数据从外面 (磁盘、网络) 流进内存，`Output Stream` 就是数据从内存流到外面去。\n\n- 需要知道的是，CPU 的速度远远快于磁盘、网络等 I/O。因此，代码操作 I/O 接口时速度是会产生不匹配的问题，而同步和异步的区别就在于是否等待 I/O 执行的结果，故 I/O 编程有分 `同步模型` 和 `异步模型`。\n\t- `同步 I/O`：在一个线程中，CPU 执行代码的速度极快，然而，一旦遇到 I/O 操作，如读写文件、发送网络数据时，就需要等待 I/O 操作完成才能继续进行下一步操作。\n\n\t\t> 引用廖老师的例子，同步 I/O 指：去麦当劳点餐，你说 “来个汉堡”，服务员告诉你，对不起，汉堡要现做需等 5 分钟，于是你站在收银台前面等了 5 分钟，当拿到汉堡再去逛商场。\n\t\n\t-  `异步 I/O`：当代码需要执行一个耗时的 I/O 操作时，它只发出 I/O 指令并不等待 I/O 结果，然后去执行其他代码。一段时间后，当 I/O 返回结果时，再通知 CPU 进行处理。\n\t\n\t\t> 异步 I/O 指：你说“来个汉堡”，服务员告诉你，汉堡需要等 5 分钟，你可以先去逛商场，等做好了我们再通知你，这样你可以立刻去干别的事情 (逛商场)，这是异步 I/O。\n\n\t- 同步 I/O 与 异步 I/O 模型的实现原理如图 6-10-1 所示：\n\n\t![图 6-10-1 同步 I/O 与 异步 I/O 模型的实现原理](/images/illustration/Programme/2018/09/life-is-short-we-need-python_6-10-1.png)\n\t<center>图 6-10-1 同步 I/O 与 异步 I/O 模型的实现原理</center>\n\n#### 存/取本地数据\n- 读写文件是最常见的 I/O 操作，Python 内置了读写文件的函数，用法和 C 是兼容的。\n- 在磁盘上读写文件的功能都是由操作系统提供的，即读写文件就是请求操作系统打开一个 `文件对象` (通常称为文件描述符)，通过操作系统提供的接口从这个文件对象中读取数据 (读文件)，或把数据写入这个文件对象  (写文件)。\n\n##### 读文件\n- `open()` 函数，传入文件名和标示符：\n\n\t```python\n\ttry:\n\t    # 以只读方式读入 test.txt 文件\n\t    file = open('/Users/kofe/test.txt', 'r', encoding='utf-8') \n\t    \n\t    # 若文件不存在，则抛出 IOError 的错误\n\t    # Traceback (most recent call last):\n\t    # File \"<stdin>\", line 1, in <module>\n\t    # FileNotFoundError: [Errno 2] No such file or directory: '...'\n\t    \n\t    # 若文件打开成功，调用 read() 方法可一次读取文件的全部内容\n\t    # Python 把内容读到内存，用一个 str 对象表示**\n\t    str = f.read()\n\tfinally:\n\t    if file:\n\t        f.close() # 文件使用完毕后必须关闭\n\t           \n\t# 当然，try...finally...  的写法实在太繁琐，故 Python 引入了 with 语句写法：\n\twith open('/Users/kofe/test.txt', 'r') as file:\n\t\tprint( file.read() )\n\t\n\t# 读取文件的方式：\n\t# read()：适合文件较小，可一次性读取文件\n\t# read(size)：若不能确定文件大小，通过反复调用读取文件\n\t# readlines()：若是读取配置文件，行读取最为方便\n\tfor line in f.readlines():\n\t    print(line.strip()) # 把末尾的 '\\n' 删掉\n\t```\n\n##### File-like Object\n- 要想操纵一个文件你需要使用 `open()` 函数打开文件，`open()` 函数返回一个 `类文件对象 (File-like Object)`，这就是这个文件在 python 中的抽象表示。除了 File 外，还可以是内存的字节流，网络流，自定义流等。\n- File-like Object 不要求从特定类继承，就如 [定制类.iter](http://localhost:4000/2018/09/life-is-short-we-need-python.html#iter) 章节所提及的 `鸭子类型`，只要我们让 `class` 实现 `read()` 方法，它就是 File-like Object。\n\n##### 二进制文件\n- 前面的操作是读取文本文件，且是 `UTF-8` 编码的文本文件。要读取二进制文件，例如图片、视频等，用 `rb` 模式打开文件即可：\n\n\t```python\n\tfile = open('/Users/kofe/test.jpg', 'rb')\n\tprint( file.read() )\n\t\n\t# 输出十六进制表示的字节：\n\tb'\\xff\\xd8\\xff\\x18Exif\\x00...'\t\n\t```\n\n##### 写文件\n- 写文件和读文件是一样的，唯一区别是调用 open() 函数时，传入标识符 `w` 或者 `wb` 表示写 `文本文件` 或 `写二进制文件`：\n\n\t```python\n\t# 写入文件后，务必要调用 f.close() 来关闭文件\n\t# 使用 Try...finally... ，或 With 语句的写法：\n\twith open('/Users/kofe/test.txt', 'w') as file:\n\tfile.write('Hello, world!')\n\t```\n\n- 所有模式的定义及含义可参考 Python 官方文档：[Built-in Functions.open()](https://docs.python.org/3/library/functions.html#open)\n\n<center>表 6-10-1 open() 函数操作文件的模式</center>\n\n| 标识符 | 描述 |\n| :---: | :--- |\n| r | 只读模式 (默认) |\n| w | 写入模式 (覆盖原文件) |\n| a |  追加模式 (文件存在则在文件尾部追加，反之则建立) |\n| b | 二进制格式 |\n| + | \t刷新打开的磁盘文件 (读与写) |\n\n#### StringIO/BytesIO\n> `StringIO` 和 `BytesIO` 是在内存中操作 str 和 bytes 的方法。\n\n##### StringIO\n- 数据读写不一定是文件，也可以在内存中读写。\n- StringIO 顾名思义就是在内存中读写 str。要把 str 写入 StringIO，我们需要先创建一个 StringIO，然后像文件一样写入：\n\n\t```python\n\tfrom io import StringIO\n\tfile = StringIO()\n\tfile.write('Welcome to\\n Python World!')\n\t\n\twhile True:\n\t    s = file.readline()\n\t    if '' == s:\n\t        break\n\t    print( s.strip() )\n\t \n\t# 输出结果：\n\tWelcome to\n\tPython World!\n\t```\n\n##### BytesIO\n- StringIO 操作的只能是 str，如果要操作二进制数据，就需要使用 BytesIO。\n- BytesIO 实现了在内存中读写 bytes。\n\n\t```python\n\tfrom io import BytesIO\n\tfile = BytesIO()\n\tfile.write( '中文'.encode('utf-8') )\n\tprint( file.getvalue() )\n\t\n\t# 写入的不是 str，而是经过 UTF-8 编码的 bytes：\n\tb'\\xe4\\xb8\\xad\\xe6\\x96\\x87'\n\t```\n\n#### 操作文件和目录\n- 若我们要操作文件、目录，可在命令行下面输入操作系统提供的各种命令来完成。例如 dir、cp 等命令。\n\n- 若要在 Python 程序中执行这些目录和文件的操作怎么办？其实 Python 内置的 `os` 模块，可以直接调用操作系统提供的 `接口函数`。\n\n\t```python\n\timport os\n\t\n\t# 现实操作系统类型\n\t# posix：Linux、Unix 或 Mac OS X\n\t# nt：Windows\n\tprint( os.name )\n\t```\n\n##### 环境变量\n- 在操作系统中定义的环境变量，全部保存在 `os.environ` 这个变量中，可直接查看：\n\n\t```python\n\timport os\n\t\n\t# 操作系统中定义的环境变量，全部保存在os.environ 变量中\n\tos.environ\n\t\n\t# 获取某个环境变量的值：os.environ.get('key')\n\tos.environ.get('PATH')\n\t```\n\n##### 操作文件和目录\n- 操作文件和目录的函数一部分放在 `os` 模块中，一部分放在 `os.path` 模块中。\n- 查看、创建和删除目录可以这么调用：\n\n\t```python\n\t# 查看当前目录的绝对路径\n\tos.path.abspath('.')\n\t\n\t# 在某个目录下创建一个新目录 (首先把新目录的完整路径表示出来)\n\tos.path.join('/Users/kofe', 'testdir')\n\t# 然后创建一个目录\n\tos.mkdir('/Users/michael/testdir')\n\t\n\t# 删掉一个目录\n\tos.rmdir('/Users/kofe/testdir')\n\t\n\t# 把两个路径合成一个时，不要直接拼字符串，而要通过 os.path.join() 函数\n\t# 同理，要拆分路径时，也不要直接去拆字符串，而要通过 os.path.split() 函数\n\tos.path.split('/Users/kofe/testdir/file.txt')\n\t('/Users/kofe/testdir', 'file.txt') # 返回一个元组 Tuple \n\t\n\t# 例如：os.path.splitext() 可直接让你得到文件扩展名\n\tos.path.splitext('/path/to/file.txt')\n\t('/path/to/file', '.txt') # 返回一个元组 Tuple \n\t```\n\t\n- 文件操作：\n\n\t```python\n\t# 对文件重命名\n\tos.rename('test.txt', 'test.py')\n\t\n\t# 删掉文件\n\tos.remove('test.py')\n\t\n\t# 然而在 os 模块中没有关于复制的函数\n\t# 借助 shutil 模块提供了copyfile() 的函数实现复制 (os 模块的补充)\n\t```\n\t\n- 利用 Python 的特性操作文件或目录：\n\n\t```python\n\t# 列出当前目录下的所有目录\n\t[x for x in os.listdir('.') if os.path.isdir(x)]\n\t```\n\n#### 序列化\n- 在程序运行期间，变量都是在内存中存放的。当 `程序结束`，变量所占用的内存将被操作系统 `全部回收`。若在程序运行期间，有需求保存 `变量` 或者 `对象` 的 `数据` 和 `状态信息`，以待下次启动程序时可直接加载该变量或对象。\n- `序列化`：将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。\n- `反序列化`：可通过从存储区中读取或反序列化对象的状态，重新创建该对象。\n- 在 Python 中，序列化称为 `pickling`，在其他语言中也被称为 `serialization`、`marshalling`、`flattening` 等。Python 提供了 `pickle` 模块来实现序列化。\n\n\t```python\n\timport pickle\n\t\t\n\tdict = {'name': 'Bob', 'age': 25, 'score': 90}\n\t\n\t### Case.01. 对象/变量 => Bytes => File 文件\n\t\n\t# dump() 将序列化后的对象 obj 以二进制形式写入文件 file 中\n\twith open('./dump.txt', 'wb') as file:\n\t    pickle.dump(dict, file)\n\t# load() 将序列化的对象从文件 file 中读取出来\n\twith open('./dump.txt', 'rb') as file:\n\t    dict = pickle.load(file)\n\t\n\t### Case.02. 对象/变量 => Bytes\n\t\n\t# dumps() 方法不需要写入文件中，可直接返回一个序列化的 bytes 对象\n\tdump = pickle.dumps(dict)\n\t# loads() 则可直接读取一个序列化的 bytes 对象\n\tdict_sub = pickle.loads(dump) \n\t```\n\n#### JSON 基础\n- `引入`：Pickle 的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于 Python，且可能不同版本的 Python 彼此都不兼容。\n\n\t若我们要在不同的编程语言之间传递对象，就必须把 `对象序列化为标准格式`，例如 XML，但 XML 需要解析读取。但更好的方法是序列化为 JSON，因为 JSON 表示出来就是一个 `字符串`，可以被所有语言读取，且方便地存储到磁盘或者通过网络传输。\n\t\n- `JSON` 表示的对象就是标准的 `JavaScript` 语言的对象，JSON 和 Python 内置的数据类型对应如下：\n\n<center>表 6-10-2 JSON 类型与 Python 类型的数据类型对应表</center>\n\n| JSON 类型 | Python 类型 |\n| :---: | :---: |\n| {} | dict |\n| [] | list |\n| \"String\" | str |\n| 10 / 3.14159 | int / float |\n| true / false | True / False |\n| null | None |\n\n-  Python 内置的 `json` 模块提供了非常完善的 Python 对象到 JSON 格式的转换：\n\n\t```python\n\timport json\n\tdict = {'name': 'Bob', 'age': 25, 'score': 90}\n\t\n\t# dump() 方法可以直接把 JSON 写入一个 File-like Object\n\t# dumps() 方法返回一个字符串，内容就是标准的 JSON\n\tjson_str = json.dumps(dict)\n\t\n\t# load() 方法从一个 File-like Object 中直接反序列化出对象\n\t# loads() 把 JSON 的字符串反序列化为 Python 对象\n\tjson_str = '{\"name\": \"Bob\", \"age\": 25, \"score\": 90}'\n\tjson.loads(json_str)\n\t```\n\t\n- 由于 JSON 标准规定 JSON 编码是 `UTF-8`，所以我们总是能正确地在 Python 的 str 与 JSON 的字符串间转换。\n\n#### JSON 进阶\n- Python 的 `dict = {'key': value}` 对象可直接序列化为 JSON 的 `{\"key\": value}`。但一般情况，我们常用 class 表示对象 ( 例如 `Student` 类 )，再序列化该对象：\n\n\t```python\n\timport json\n\n\tclass Student(object):\n\t    def __init__(self, name, age, score):\n\t        self.name = name\n\t        self.age = age\n\t        self.score = score\n\t\n\t# 运行代码，将会报 TypeError 错误\n\tstu = Student('Bob', 25, 90)\n\tprint(json.dumps(stu))\n\t```\n\n- 造成上述错误的原因是：Student 对象不是一个可序列化为 JSON 的对象。\n\t\n\t其实，仔细观察 `dumps()` 的参数列表，可以发现除了第一个必须的 `obj` 参数外，`dumps()` 方法还提供了一大堆的 [可选参数](https://docs.python.org/3/library/json.html#json.dumps)，这些可选参数可让我们来定制 JSON 序列化：\n\n\t```python\n\t# 默认情况下 dumps() 不知道如何将 Student 实例变为 JSON 的 {\"key\": value}\n\t# 我们只需为 Student 实例专门写一个转换 (组装) 函数\n\tdef student2dict(std):\n\t    return {\n\t        'name': std.name,\n\t        'age': std.age,\n\t        'score': std.score\n\t    }\n\t\n\t# 这样，Student 实例首先被 student2dict() 函数转换成 dict，再被序列化为 JSON\n\tprint( json.dumps(stu, default = student2dict) )\n\t```\n\t\n- 当然，若我们遇到一个 Teacher 类的实例，照样无法序列化为 JSON。其实可以通过一种 `通用方法` 将任意 class 的实例变为 dict。\n\n\t通常 class 的实例都有一个 `__dict__` 属性，它本身一个 `dict`，用来存储实例变量。也有少数例外，比如定义了 `__slots__` 的 class。\n\n\t```python\n\tprint( json.dumps(s, default = lambda obj: obj.__dict__) )\n\t```\n\n- 同理，我们需要把 JSON 反序列化为一个 Student 实例对象，`loads()` 方法首先转换出一个 `dict` 对象，然后我们传入的 [object_hook](https://docs.python.org/3/library/json.html#json.load) 函数，其负责把 dict 转换为 Student 实例对象。\n\n\t```python\n\tdef dict2student(d):\n\t    return Student( d['name'], d['age'], d['score' ])\n\t    \n\tjson_str = '{\"age\": 25, \"score\": 90, \"name\": \"Bob\"}'\n\tprint( json.loads(json_str, object_hook = dict2student) )\n\t```\n\n#### 同步 I/O\n- 在本章引言部分已讲述 同步 I/O 与 异步 I/O 模型的区别，同步模型即按普通顺序写执行代码：\n\n\t```python\n\tdo_some_code()\n\tfile = open('/path/file.txt', 'r')\n\t\n\t# 线程停在此处等待 I/O 操作结果\n\tr = file.read() \n\t\n\t# I/O 操作完成后线程才能继续执行\n\tdo_some_code(r)\n\t```\n\n#### 异步 I/O\n- 在 I/O 操作过程中，由于一个 I/O 操作阻塞了当前线程，导致其他代码无法执行，故我们可使用多线程或者多进程来 `并发` 执行代码。然而，我们通过 `多线程和多进程` 的模型解决了 `并发` 问题，但现实情况是系统不能无上限地增加线程，因为系统切换线程的开销很大，一旦线程数量过多，CPU 花在线程切换上的时间就增多，则导致性能严重下降的结果。\n\t\n\tCPU 高速执行能力和 I/O 设备的读写速度严重不匹配导致线程阻塞。多线程和多进程只是解决这一问题的一种方法，而另一种解决 I/O 问题的方法就是异步 I/O。\n\n- `异步 I/O 模型` 需要一个 `消息循环`。在消息循环中，主线程不断地重复 `读取消息 / 处理消息` 这一过程：\n\n\t```python\n\tloop = get_event_loop()\n\twhile True:\n\t    event = loop.get_event()\n\t    process_event(event)\n\t```\n\n##### 协程\n> 在开始异步 I/O 模型学习前，我们先来了解 `协程` 的概念。\n\n- 协程 ( Coroutine )，又称微线程、纤程。协程不是进程或线程，其执行过程更 `类似于` 子程序，或者说 `不带返回值的函数调用`。  \n\n\t例如：A 调用 B，B 中又调用了 C。C 执行完毕返回，B 执行完毕返回，最后是 A 执行完毕。\n\n\t- 子程序调用是通过栈实现的，`一个线程` 就是执行 `一个子程序`。子程序调用总是 `一个入口`，`一次返回`，且 `调用顺序是明确的`。\n\n\t- 而协程的调用和子程序是不同的。协程看上去也是子程序，但在执行过程中，`调用顺序不固定`，在子程序内部可中断转而执行别的子程序，在适当的时再返回来接着执行原子程序。\n\t\n\t```python\n\tdef A():\n\t    print('1')\n\t    print('2')\n\t\n\tdef B():\n\t    print('x')\n\t    print('y')\n\t    \n\t# 若由协程执行，在执行 A 的过程中可随时中断去执行 B\n\t# B 也可能在执行过程中中断再去执行 A，则执行结果有：\n\t1\n\tx\n\ty\n\t2\n\t```\n\t\n- 从上述例子结果可看出，A、B 的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？\n\n\t- `协程极高的执行效率`：因为子程序切换不是线程切换，而是由程序自身控制。因此，没有线程切换的开销，和多线程相比，线程数量越多协程的性能优势就越明显。\n\n\t- `不需要多线程的锁机制`：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，故执行效率相对多线程要高。\n\n- 因为协程是一个线程执行，是否可利用多核 CPU 获得更高的性能，若方案可行的话如何操作？最简单的方法是 `多进程` + `协程`，既充分利用多核，又充分发挥协程的高效率。\n\n- Python 对协程的支持是通过 `generator` 实现的，例如：\n\t- 传统 `生产者 - 消费者` 模型是：一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但有很大机率出现 `死锁`。\n\t- 若改用协程，生产者生产消息后，直接通过 `yield` 跳转到消费者开始执行，待消费者执行完毕后切换回生产者继续生产。\n\n\t```python\n\tdef consumer():\n\t    result = ''\n\t    while True:\n\t        # Step.03. consumer 通过 yield 取消息并处理，再通过 yield 把结果回传\n\t        n = yield result\n\t        print('[CONSUMER] Consuming %s...' % n)\n\t        result = 'OK:' + str(n) # result 可能是 I/O 操作或耗时任务\n\t\n\tdef produce(c):\n\t    # Step.01. 首先调用 c.send(None) 启动生成器\n\t    c.send(None)\n\t    n = 0\n\t    while n < 5:\n\t        n = n + 1\n\t        print('[PRODUCER] Producing %s...' % n)\n\t        # Step.02. 当产生了东西后，通过 c.send(n) 切换到 consumer 执行\n\t        result = c.send(n)\n\t        # Step.04. produce 拿到 consumer 的处理结果，(或) 继续生产下条消息\n\t        print('[PRODUCER] Consumer return: %s' % result)       \n\t    # Step.05. produce 决定不生产了，通过 c.close() 关闭 consumer，整个过程结束\n\t    c.close()\n\t\n\t# 函数调用\n\tcons = consumer()\n\tproduce(cons)\n\t\n\t# 输出结果\n\t[PRODUCER] Producing 1...\n\t[CONSUMER] Consuming 1...\n\t[PRODUCER] Consumer return: OK:1\n\t[PRODUCER] Producing 2...\n\t[CONSUMER] Consuming 2...\n\t[PRODUCER] Consumer return: OK:2\n\t[PRODUCER] Producing 3...\n\t[CONSUMER] Consuming 3...\n\t[PRODUCER] Consumer return: OK:3\n\t```\n\n##### Asyncio\n- `asyncio` 是 `Python 3.4` 版本引入的标准库，直接内置了对异步 I/O 的支持。\n- `asyncio` 的编程模型是一个 `消息循环`。我们从 asyncio 模块中直接获取一个 `EventLoop` 的引用，然后把需要执行的协程扔到 EventLoop 中执行，就实现了异步 I/O，具体操作实例：\n\t- `@asyncio.coroutine` 把一个 `generator` 标记为 `coroutine` 类型，然后，我们就把这个 coroutine 扔到 EventLoop 中执行。\n\t- `hello()` 会首先打印出 `Hello world!`。然后，`yield from` 语法可以让我们方便地调用另一个 generator。由于 `asyncio.sleep()` 也是一个 `coroutine`，所以线程不会等待 `asyncio.sleep()`，而是直接中断并执行下一个消息循环。当 `asyncio.sleep()` 返回时，线程就可以从 `yield from` 拿到返回值 ( 此处是 None )，然后接着执行下一行语句。\n\n\t\t> 若我们把 asyncio.sleep(1) 看成是一个耗时一秒的 I/O 操作。在此期间，主线程并未等待，而是去执行 EventLoop 中其他可以执行的 coroutine，因此实现了 `并发执行`。\n\n\t```python\n\timport asyncio\n\t\n\t@asyncio.coroutine\n\tdef hello():\n\t    print(\"Hello world!\")\n\t    # 异步调用 asyncio.sleep(1):\n\t    r = yield from asyncio.sleep(1)\n\t    print(\"Hello again!\")\n\t\n\t# 获取 EventLoop\n\tloop = asyncio.get_event_loop()\n\t# 执行 coroutine\n\tloop.run_until_complete(hello())\n\tloop.close()\n\t```\n\t\n- `举一反三`：我们尝试用 Task 封装两个 coroutine：\n\n\t```python\n\timport threading\n\timport asyncio\n\t\n\t@asyncio.coroutine\n\tdef hello():\n\t    print('Hello world! (%s)' % threading.currentThread())\n\t    yield from asyncio.sleep(1)\n\t    print('Hello again! (%s)' % threading.currentThread())\n\t\n\tloop = asyncio.get_event_loop()\n\ttasks = [hello(), hello()]\n\tloop.run_until_complete(asyncio.wait(tasks))\n\tloop.close()\n\t\n\t# 输出结果\n\t# 由打印当前线程名称可看出，两个 coroutine 由同一个线程并发执行的\n\tHello world! (<_MainThread(MainThread, started 140735195337472)>)\n\tHello world! (<_MainThread(MainThread, started 140735195337472)>)\n\t(暂停约 1 秒)\n\tHello again! (<_MainThread(MainThread, started 140735195337472)>)\n\tHello again! (<_MainThread(MainThread, started 140735195337472)>)\n\t```\n\t\n- `具体应用场景`：我们 asyncio 的异步网络连接来获取 sina、sohu 的首页。\n\n\t```python\n\timport asyncio\n\t\n\t@asyncio.coroutine\n\tdef wget(host):\n\t    print('wget %s...' % host)\n\t    connect = asyncio.open_connection(host, 80)\n\t    reader, writer = yield from connect\n\t    header = 'GET / HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n' % host\n\t    writer.write(header.encode('utf-8'))\n\t    yield from writer.drain()\n\t    while True:\n\t        line = yield from reader.readline()\n\t        if line == b'\\r\\n':\n\t            break\n\t        print('%s header > %s' % (host, line.decode('utf-8').rstrip()))\n\t    # Ignore the body, close the socket\n\t    writer.close()\n\t\n\tloop = asyncio.get_event_loop()\n\ttasks = [wget(host) for host in ['www.sina.com.cn', 'www.sohu.com']\n\tloop.run_until_complete(asyncio.wait(tasks))\n\tloop.close()\n\t\n\t# 输出结果\n\twget www.sohu.com...\n\twget www.sina.com.cn...\n\t(打印出sohu的header)\n\twww.sohu.com header > HTTP/1.1 200 OK\n\twww.sohu.com header > Content-Type: text/html\n\t...\n\t(打印出 sina 的 header)\n\twww.sina.com.cn header > HTTP/1.1 200 OK\n\twww.sina.com.cn header > Date: Wed, 20 May 2015 04:56:33 GMT\n\t...\n\t```\n\n##### Async / Await\n- 用 asyncio 提供的 @asyncio.coroutine 可把一个 generator 标记为 coroutine 类型，然后在 coroutine 内部用 yield from 调用另一个 coroutine 实现异步操作。\n- 为简化并更好地标识异步 I/O，从 `Python 3.5` 开始引入了新语法 `async` 和 `await`，可以让 `coroutine` 的代码更简洁易读。请注意，async 和 await 是针对 coroutine 的新语法，即只需要做两步简单的替换：\n\t- 把 `@asyncio.coroutine` 替换为 `async`；\n\t- 把 `yield from` 替换为 `await`.\n\n\t```python\n\t# asyncio 原语法书写\n\t@asyncio.coroutine\n\tdef hello():\n\t    print(\"Hello world!\")\n\t    result = yield from asyncio.sleep(1)\n\t    print(\"Hello again!\")\n\t    \n\t# 用新语法重新编写\n\tasync def hello():\n\t    print(\"Hello world!\")\n\t    result = await asyncio.sleep(1)\n\t    print(\"Hello again!\")\n\t    \n\t# 剩下的代码保持不变\n\t```\n\n##### Aiohttp\n- asyncio 可实现单线程并发 I/O 操作。若仅用在客户端，发挥的威力不大。若在服务器端，例如Web服务器，由于HTTP连接就是 I/O 操作，因此可以用 `单线程 + coroutine` 实现多用户的高并发支持。\n\n\tasyncio 实现了 TCP、UDP、SSL 等协议，`aiohttp` 则是基于 asyncio 实现的 HTTP 框架。\n\n## 参考资料\n- \\[1\\] [Eddie Woo. The RSA Encryption Algorithm. 2017. bilibili.com](https://www.bilibili.com/video/av10742893?from=search&seid=163310817147442185)  \n- \\[2\\] [John cui. 轻松学习RSA加密算法原理. 2018. jianshu.com](https://www.jianshu.com/p/3221e07d3310)  \n- \\[3\\] [廖雪峰. Python 教程. 2018. liaoxuefeng.com](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000)  \n- \\[4\\] [Dean J, Ghemawat S. MapReduce: simplified data processing on large clusters [J].  \nCommunications of the ACM, 2008, 51(1): 107-113.](https://dl.acm.org/citation.cfm?id=1327492)  \n- \\[5\\] [Wes McKinney. 利用 Python 进行数据分析 [M]. 机械工业出版社, 2013](https://book.douban.com/subject/25779298/)  \n- \\[6\\] [Python. The Python Standard Library. python.org](http://docs.python.org/3/library/functions.html) \n- \\[7\\] [渐行渐远silence. Windows 下多版本 Python 安装与 pip 安装和 pip 使用. 2017. csdn.net](https://blog.csdn.net/silence2015/article/details/56483892)","tags":["python","数据分析","linux","爬虫"],"categories":["Programme"]},{"title":"SVN 环境搭建与使用","url":"/2018/08/building-a-svn-server.html","content":"\n最近有机会接触到公司的新项目，对于多人参与的项目，此刻才感受到 `源代码版本控制` 的重要性。遗憾之余，为了加深理解和复用起见，本文将从 `搭建`、`配置` 和 `使用` 多方面总结 SVN ( Subversion，开放源代码的版本控制系统 )。\n\n当然，版本控制的工具有很多，比如 CVS、GIT、SVN。CVS 几乎淘汰；GIT 适合开源软件项目；SVN 适合企业内部由项目经理统一协调的多个并行项目的开发。考虑到种种因素，我们不能单方面评论每种版本控制工具的优劣，故选择哪款版本控制工具视具体情况而定。\n\n<!-- More -->\n\n## 源代码管理\n\n> 介绍参考了资料 [1]。 \n\n### 管理的意义\n- 目的：为了解决在软件开发过程中，由源代码引发的各种繁琐的问题。\n- 作用：\n\t- 能追踪一个项目从诞生一直到定案的过程；\n\t- 记录一个项目的所有内容变化，方便地查阅特定版本的修订情况.\n- 常见问题：\n\t- **代码冲突**：多人操作同一个文件 ( 团队开发中的常见问题 )；\n\t- 版本备份：费空间 ( 大数据时代，储存成本反而最 \"廉价\" )；\n\t- 权限控制：无法对源代码进行精确的权限控制；\n\n### 管理的工具\n- CVS：历史悠久，现在几乎没人使用。\n- SVN：\n\t- 集中式版本控制的代表；\n\t- CVS 的接班人，速度和功能比 CVS 有很大幅度提升.\n- GIT：\n\t- 分布式源代码管理工具；\n\t- 目前被大多数开源项目使用。\n\n## SVN 概念概述\n- `Subversion` 的简称为 SVN，是一个开放源代码的版本控制系统；\n- SVN 用于多个人共同开发同一个项目，目的是为了资源共享共用；\n- SVN 服务器有 2 种 `运行方式`：独立服务器和借助 Apache。两种方式各有利弊，可自行选择。\n- SVN `存储版本数据` 也有 2 种方式：`Berkeley DB` ( 事务安全型表类型 ) 和 `FSFS` ( 不需要数据库的存储系统 )。因为 Berkeley DB 方式在服务器中断时，有可能锁住数据，故选择 FSFS 的存储方式会更安全一点。\n\n## SVN 环境搭建\n\n### SVN 服务器\n- 安装 SVN Server For `Windows`：[VisualSVN Server](https://www.visualsvn.com/server/download/) \n\n\t配置是通过界面操作完成的，具体安装流程就不阐述了，可参考引用文章完成配置 $^{[1,2]}$。\n\n\t> Tips.01. 安装过程中，其中 SVN 服务器端口配置推荐使用HTTPS 的 `8443` 端口，因为 HTTPS 安全性比較高，尽管 `443` 是标准 HTTPSport。  \n\t> Tips.02. 还有就是用于验证的身份配置：Windows 验证和 Subversion 身份验证，默认是 Subversion 身份验证。\n\n- 安装 SVN Server For `MacOS`：MacOS 自带了 SVN 的服务器端和客户端功能。参考引用文章完成配置即可使用 $^{[3,4]}$。\n\n### SVN 客户端\n- Windows Client：[TortoiseSVN](https://tortoisesvn.net/downloads.html)\n- MacOS Client：[Cornerstone](https://cornerstone.assembla.com/)\n\n\t> 在 MacOS 上可利用 SVN 图形界面工具来管理源代码，可以大大减小使用命令行的痛苦 $^{[5]}$。\n\n### SVN 配置与使用\nWindows 端配置和使用 SVN，可通过图形界面工具即可完成操作，详细的步骤在引用文章 [1]、[2] 中也有提及。故在本章节主要讲述 `Mac` 环境下搭建和配置 SVN。\n\n#### SVN 服务端配置\n\n##### 创建代码仓库\n- Step.01. 新建一个 `svn` 目录，例如 `/Users/kofe/svn`，以后可在 `svn` 目录下创建多个仓库目录。\n- Step.02. 打开终端，创建一个名为 `idea` 仓库，输入指令：\n\n\t```bash\n\t# 指令执行成功后，会发现硬盘上多了个 /Users/kofe/svn/idea 目录\n\tsvnadmin create /Users/kofe/svn/idea\n\t```\n\n##### 配置用户权限\n主要是修改 `/svn/idea/conf` 目录下的三个文件：`svnserve.conf`、`Passwd` 文件和 `Authz` 文件。\n\n- svnserve.conf\n\n\t```bash\n\t# anon-access = read 代表匿名访问的时候是只读的\n\t# anon-access = none 代表禁止匿名访问，需要帐号密码才能访问\n\tanon-access = read\n\tauth-access = write\n\tpassword-db = passwd\n\tauthz-bd = authz\n\t```\n\n- Passwd 文件：在 `[users]` 下面添加账号和密码。\n\n\t```bash\n\t[users]\n\t# 格式：账号 = 密码\n\tkofe = 123456\n\tlucy = 123456\n\t```\n\n- Authz 文件：配置用户组和权限我们可以将在 Passwd 里添加的用户分配到不同的用户组里。以后就可对不同用户组设置不同的权限，没有必要对每个用户进行单独设置权限。即在 `[groups]` 下面添加组名和用户名，多个用户之间用逗号 **,** 隔开。\n\n\t```bash\n\t[groups] \n\tusergroup = kofe, lucy # 格式：组名 = 用户1, 用户2, ...\n\t\n\t# 使用 [/] 代表 SVN 服务器中的所有资源库\n\t# 某个组有读写权限\n\t[/]\n\t@usergroup = rw\n\t\n\t# 使用 [/] 代表 SVN 服务器中的所有资源库\n\t# 某个用户有读写权限\n\t# lucy = rw\n\t```\n\n##### 启动关闭服务\n- 在终端输入下列指令：若没有任何提示，恭喜你启动成功。\n\n\t```bash\n\tsvnserve -d -r /Users/kofe/svn\n\t# 或输入: svnserve -d -r /User/kofe/svn/idea\n\t```\n\n- 当然，会启用也要会关闭 SVN 服务器，特别是首次配置完 SVN 服务器需要重启。  \n\tCase.01. 在 `活动监视器` 中搜索 `svn`, 在列表中找到进程 `svnserve`, 点击左上角的`强制退出进程`。  \n\tCase.02. 或者可通过 shell 脚本实现一键关闭。  \n\t\n\t```bash\n\t#!/bin/sh\n\techo \"Current Process List:\"\n\techo \"= = = = = = = = = = =\"\n\tps -A | grep svn\n\techo \"= = = = = = = = = = =\"\n\tkill `pgrep \"svn\"`\n\t\n\techo \"Kill successfully!\" Current Process Status:\n\techo \"= = = = = = = = = = = = = = = = = = = = = =\"\n\tps -A | grep svn\n\techo \"= = = = = = = = = = = = = = = = = = = = = =\"\n\t```\n\n#### SVN 客户端操作\n\n##### 代码版本控制\n> 当然，充分利用 SVN 图形界面工具 ( [Cornerstone](https://cornerstone.assembla.com/) ) 来管理源代码，可大大减小使用命令行的痛苦，提升使用效率。\n\n- 首次导入工程文件到 SVN 服务器：\n\n\t```bash\n\t# /Users/kofe/procedure/idea/SSM_DEMO，指的是需要导入的工程文件\n\t# svn://localhost/idea 指把工程文件上传到 idea 目录下\n\t# --username=admin --password=123456 指的是校验用户名和密码\n\t# -m \"初始化导入\" 指的是提交的信息注释\n\tsvn import /Users/kofe/procedure/idea/SSM_DEMO svn://localhost/idea --username=kofe --password=123456 -m \"初始化导入\"\n\t```\n\n- 从 SVN 服务器下载工程文件到本地 ( Checkout )：\n\n\t```bash\n\tsvn checkout svn://localhost/idea --username=kofe --password=123456 /Users/kofe/procedure/idea\n\t```\n\t\n- 二次提交代码到服务器：二次提交是有一个前提的, 那就是你首先需要在 SVN服务器上下载代码到本地，然后再去修改这一份代码, 才能够二次提交。\n\n\t```bash\n\tcd /Users/kofe/procedure/idea\n\tsvn commit -m \"修改部分代码 (注释修改的内容)\"\n\t```\n\t\n- SVN 基本操作原理：\n\t- `svn checkout`：将服务器代码完整下载到本地。\n\t- `svn update`：将服务器最新的代码下载到本地。\n\t- `svn commit`：将本地修改的内容提交到服务器。\n\n\t![图3-1SVN 基本操作原理](/images/illustration/Project/2018/08/building-a-svn-server_3-1.png)\n<center>图 3-1 SVN 基本操作原理</center>\n\n##### 代码版本冲突\n- 版本冲突原因：\n\n\t假设 A、B 两用户都在版本号为 100 时更新了 `sample.txt` 文件，A 用户在修改完成之后提交 sample.txt 到服务器，这个时候提交成功，这个时候 sample.txt 文件的版本号已经变成 101 了。同时 B 用户在版本号为 100 的 sample.txt 文件上作修改，修改完成之后提交到服务器时，由于不是在当前最新的 101 版本上作的修改，所以导致提交失败。\n\n- 版本冲突现象：\n\n\t冲突发生时，SVN 会在当前工作目录中保存所有的目标文件版本 [ 上次更新版本、当前获取的版本 ( 即别人提交的版本 )、自己更新的版本、目标文件 ]。  假设文件名是 `sample.txt` ，对应的文件名分别是 ( 同时在目标文件中标记来自不同用户的更改 )：\n\n\t```bash\n\tsample.txt.r101\n\tsample.txt.r102\n\tsample.txt.mine\n\tsample.txt\n\t```\n\t\n- `手工合并` SVN 冲突 $^{[6]}$，开始的时候让人觉得害怕，但有规律可循。例如有以下文本：\n\n\t```java\n\tMayonnaise\n\tLettuce\n\tTomato\n\tProvolone\n\t<<<<<<<.mine\n\tSalami\n\tMortadella\n\tProsciutto\n\t=======\n\tSauerkraut\n\tGrilledChicken\n\t>>>>>>>.r2\n\t```\n\n\t一连串的大于、小于、等于号是 SVN 冲突标记，这些数据得全部删除才可以提交。在 SVN 冲突区中，或许你需要和你的同事沟通来安排冲突区的文本内容，待所有冲突区得到合理的解决之后方可再提交文件。\n\n\t```java\n\t// 是你在冲突区里面做的修改\n\t<<<<<<<.mine\n\tSalami\n\tMortadella\n\tProsciutto\n\t=======\n\t\n\t// 是别人在冲突区做的修改\n\tSauerkraut\n\tGrilledChicken\n\t>>>>>>>.r2\n\t```\n\t\n- 如何降低冲突解决的复杂度：\n\t- 在提交时写上明确的 Message ( 注释 )，方便以后查找用户更新的原因。\n\t- 养成良好的使用习惯，使用 SVN 时每次都是先提交，后更新。每天 `早上` 打开后，首先要从版本库 `获取最新版本`，每天 `下班前` 必须将已经编辑过的文档都 `提交` 到版本库。\n\n## 参考资料 \n\\[1\\] [PhelanGeek. SVN 服务器搭建教程. jianshu.com. 2016](https://www.jianshu.com/p/96f2db36044b)  \n\\[2\\] [RealLiuNing. Windows 10 搭建独立 SVN 服务器. jianshu.com. 2018](https://juejin.im/post/5b0e50f5f265da08ec33b74e)  \n\\[3\\] [CainLuo. 搭建 MacOS 本地 SVN 服务器. juejin.im. 2016](https://juejin.im/post/58209be1a0bb9f0058c08452)  \n\\[4\\] [Sunny Fight. iOS 版本控制 SVN (Mac 环境下 SVN 的使用). jianshu.com. 2016](https://www.jianshu.com/p/66f085556fb2)  \n\\[5\\] [天蓝. SVN 在 Mac 上使用 Xcode+Cornerstone. jianshu.com. 2017](https://www.jianshu.com/p/650342b0a0ce)  \n\\[6\\] [aaronGao. svn conflict 冲突解决. cnbologs.com. 2016](https://www.cnblogs.com/aaronLinux/p/5521844.html)","tags":["svn","mac","git","版本控制"],"categories":["Project"]},{"title":"Java EE：SSM 框架快速上手教程","url":"/2018/08/J2EE-SSM-1.html","content":"\n本文章主要围绕 J2EE 中 SSM ( Spring、Spring MVC、MyBatis ) 框架的配置以及使用问题展开学习的，最终目的是输出可复用的版本，以供后续的项目复用。当然，学习和配置的过程难免有不恰当或错误之处，还望朋友指出、斧正。\n\n<!-- More -->\n\n## 更新进度\n- 2018.08.13：完成初稿，梳理 SSM 框架初识章节；\n- 2018.08.20：框架内容，梳理 SSM 框架基本内容；\n- 2018.08.24：框架内容，修正 SSM 框架部分内容；\n- 2018.08.26：框架内容，整合 Spring 和 MyBatis；\n\n## 教学资源\n- 视频 | [黑马程序员. J2EE 进阶. MyBatis 框架由浅入深. 2017. bilibili.com](https://www.bilibili.com/video/av20394903)\n\n\t> 本框架的学习笔记是基于此系列教学视频所得的。\n\t\n- 文章 | [吴操. 搭建一个基于 SSM 框架的人力资源管理系统. 2018. csdn.net](https://blog.csdn.net/noaman_wgs/article/details/79503559)\n\n\t> 发现这位博主搭建的例子 ( [nomico271. SSM_HRMS. Github](https://github.com/nomico271/SSM_HRMS) ) 紧凑、简练，适合初入门时来模仿构建自己的项目。\n\n## IDE 搭建\nIDE 搭建以 [Java EE 之 SSH 框架配置与使用](https://www.kofes.cn/2018/07/J2EE-SSH-SSI-1.html#IDE-搭建) 为参考。\n\n\n## 版本信息\t\n-  框架版本：\n\t- Spring MVC：4.3.x\n\t- Spring：4.3.x\n\t- MyBatis：3.4.x\n- 其他组件：\n\t- MySQL：5.7.x / SQL Server：2008 R2\n\t- Tomcat：9.0.x\n\t- Maven：3.3.9\n\t- JDK：1.8\n- 构建框架，还需要相关依赖库 ( Jar 包 )，为便于你下载 Jar 包或校对依赖是否齐全，具体地，以下列举了 SSM 框架所需要的依赖库。\n\n| Spring | MyBatis |\n| :---- | :---- | \n| spring-core | mybatis | \n| spring-beans | mybatis-spring ( Spring 整合 Mybatis ) |\n| spring-context | pagehelper ( 分页助手 ) |\n| spring-webmvc | &nbsp; |\n| spring-web | &nbsp; |\n| spring-aop ( 整合 Aop ) | &nbsp; |\n| aopalliance ( 整合 Aop ) | &nbsp; |\n| spring-aspect ( 整合 Aop ) | &nbsp; |\n| aspectjweaver ( 整合 Aop ) | &nbsp; |\n| spring-tx ( 整合事务 ) | &nbsp; |\n| spring-jdbc | &nbsp; |\n\n|  其他依赖库 ( Jar 包 ) | 备注 |\n| :---- | :---- |\n| log4j | 日志支持 |\n| log4j-core、log4j-api | 日志支持 |\n| slf4j-api、slf4j-log4j12 | 日志支持 |\n| junit | Junit 单元测试 |\n| c3p0 | c3p0 数据库连接池 |\n| mysql-connector-java | 添加 MySQL 数据库支持 |\n| jackson-databind | Json 数据转化为类对象 |\n| jsp-api | JSP |\n| javax.servlet-api | Servlet |\n| jstl | JSTL 标签库 |\n| taglibs-standard-impl | JSP 标准标签库 |\n\n\n## 框架初识\n- SSM 框架集由 Spring、SpringMVC、MyBatis 三个开源框架整合而成，是继 SSH (Spring、Struts2、Hibernate ) 之后，目前比较主流的 Java EE 企业级框架，适用于搭建各种大型的企业级应用系统。 \n\n\t> SSM 与 SSH 都有各自的优缺点，而根据你的项目特点而选择合适的框架即可。关于 SSH 框架的配置与使用，感兴趣的可参考本博客的文章：[Java EE 之 SSH 框架配置与使用](https://www.kofes.cn/2018/07/J2EE-SSH-SSI-1.html)\n\n### ORM 框架\n- 对象关系映射（Object Relational Mapping，O/R Mapping，ORM）是通过使用描述对象和数据库之间映射的 `元数据`，将面向对象语言程序中的 `对象` 自动 `持久化` 到 `关系数据库` 中。本质上就是将数据从一种形式转换到另外一种形式。 \n- 让 `实体类` 和 `数据库表` 进行一一对应关系 (映射关系)，`实体类属性` 和 `表里面的字段` 对应。操作表对应实体类对象，而不需操作数据库表。\n\n### SSM 框架\n\n#### MyBatis\n\n##### 原生 Jdbc 操作数据库\n在引入 MyBatis ( 或 Hibernate ) 前，一般通过原生 Jdbc 来操作数据库，而这种方式存在很多问题 $^{[2]}$：\n\n- 程序创建数据库连接，即需求时创建，用完后关闭。若频繁的创建、关闭数据库连接，显然存在问题。 ( 可以通过数据库连接池来处理这个问题 )\n\n- 硬编码的地方太多了。例如，数据库连接相关信息，SQL相关信息等。( 可通过使用 XML 配置文件，来避免这个问题 )\n\n- 实质上，我们编写JDBC是有步骤可循的，即先得到数据库连接对象，传入SQL、输入参数、设置参数，再去执行SQL，然后遍历结果集将数据库 SQL 执行的结果对象转化为 JAVA 对象，然后再去业务处理，最后释放资源。\n\n\t那么这个过程，实际上是个 `模板方法`，能不能抽离出来，更好的去完成这个过程呢？\n\n\n##### 框架比较\n-  Hibernate\n\t- 优点：  \n\t1) Hibernate 这个纯粹的 ORM 框架，以面向对象的方式来完成数据库的操作。  \n\t2) Hibernate 不需要编写 SQL 即可完全映射，且可通过 HQL (Hibernate Query Language) 语言对 POJO 操作。  \n\t3) Hibernate 提供了日志、缓存、级联等特性。  \n\t- 缺点：\n\t1) Hibernate 可自由编写 SQL，但非常繁琐，则优化 SQL 实现高性能数据库操作有限制，在互联网项目快速迭代开发中显得过于笨重。\n\t2) Hibernate 的 `级联会造成太多性能的丢失`。\n\t3) Hibernate 不支持存储过程。\n- MyBatis\n\t- 优点：自由书写 SQL、支持动态 SQL、处理列表、动态生成表名、支持存储过程。\n\t- 缺点：需要编写 SQL 和映射规则，工作量相对较大。\n\n##### 基本介绍\n- MyBatis 前身是 Apache 的开源项目 `iBatis`，`iBatis` 一词源于 internet 和 abatis 的组合，是一个基于 Java 的持久层框架。\n\n- MyBatis 是一款持久层框架，它支持定制化 SQL (不屏蔽 SQL)、存储过程以及高级映射。\n- MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。\n- MyBatis 可使用 XML配置文件形式或注解形式来配置和映射原生信息，将接口和 POJOs ( Plain Ordinary Java Object，普通 Java 对象 / 实体类 ) 映射成数据库中的记录。\n\n\t> 我们把 POJO 对象和数据库表相互映射的框架称为对象关系映射框架 ( Object Relational )。\n\n##### 架构原理\n\n![图6-1SSM架构原理图](/images/illustration/Project/2018/08/J2EE-SSM-1_6-1.png)\n<center>图 6-1 SSM架构原理图</center>\n\n- `SqlMapConfig.xml`：MyBatis 全局配置文件，配置数据源、事务等运行环境相关信息；SQL文件即是 `Mapper.xml`。\n\n- `SqlSessionFactory`：会话工厂，用于创建 SqlSession。\n\n- `SqlSession`：即操作数据库的接口，其内部借助 `Executor` 执行器完成对数据库的操作。\n\n- `MappedStatement`：底层封装对象，对操作数据库储存封装，其中包括 SQL 语句 ( Mapper.xml )、输入对象和输出结果类型。\n\n##### 配置文件\n\n- 全局配置文件：在 Src 根目录下建立并配置 `SqlMapConfig.xml`  \n\n\t与 Spring 整合 Hibernate 一样，后期 Spring 整合 MyBatis 后此配置文件可省略。当然，学习阶段代码还是得提供。\n\t\n\t```xml\n\t<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\t<!DOCTYPE configuration\n\t    PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n\t    \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\t<configuration>\n\t\n\t    <!-- 加载 Java 的配置文件或者声明属性信息 ( 详细见本项目源码 ) -->\n\t    <properties resource=\"c3p0.properties\"></properties>\n\t\n\t    <!-- 全局参数配置 -->\n\t    <!-- <settings></settings> -->\n\t\n\t    <!-- 自定义别名 -->\n\t    <typeAliases>\n\t        <!-- 单个别名定义\n\t        <typeAlias type=\"cn.kofes.ssm.pojo.Sample\" alias=\"Sample\"/>\n\t        -->\n\t\n\t        <!-- 批量别名定义 ( 推荐 )\n\t         | package：指定包名称来为该包下的 pojo 类声明别名，默认的别名就是类名 ( 首字母大小写都可 )\n\t        -->\n\t        <package name=\"cn.kofes.pojo\"/>\n\t    </typeAliases>\n\t\n\t    <!-- 配置 MyBatis 的环境信息，与 Spring 整合，该信息由spring来管理 -->\n\t    <environments default=\"development\">\n\t        <environment id=\"development\">\n\t            <!-- 配置 Jdbc 事务控制，由 MyBatis 进行管理 -->\n\t            <transactionManager type=\"JDBC\"></transactionManager>\n\t            <!-- 配置数据源，采用 MyBatis 连接池 -->\n\t            <dataSource type=\"POOLED\">\n\t                <property name=\"driver\" value=\"${datasource.driverClass}\"/>\n\t                <property name=\"url\" value=\"${datasource.jdbcUrl}\"/>\n\t                <property name=\"username\" value=\"${datasource.user}\"/>\n\t                <property name=\"password\" value=\"${datasource.password}\"/>\n\t            </dataSource>\n\t        </environment>\n\t    </environments>\n\t\n\t    <!-- 加载映射文件 -->\n\t    <mappers>\n\t        <!-- 单个映射文件添加 -->\n\t        <mapper resource=\"mapper/SampleMapper.xml\"/>\n\t\n\t        <!-- 批量加载映射文件：mapper.java 与 mapper.xml 同名，且在同一目录下\n\t        <package name=\"cn.kofes.ssm.mapper\" />\n\t        -->\n\t    </mappers>\n\t</configuration>\n\t```\n\t\n- Mapper 映射文件：例如 `SampleMapper.xml`\n\n\t- 创建实体类对象 ( POJOs )：\n\n\t```java\n\t// cn.kofes.pojo.Sample.java\n\tpublic class Sample {\n\t    private Integer id;\n\t    private String name;\n\t\n\t    public Integer getId() { return id; }\n\t    public void setId(Integer id) { this.id = id; }\n\t    public String getName() { return name; }\n\t    public void setName(String name) { this.name = name; }\n\t}\t\n\t```\n\n\t- 在映射文件中配置 SQL 语句，如建立 `SampleMapper.xml` ( 便于管理，把映射文件统一放置 mapper 文件夹下 )：\n\n\t```xml\n\t<!-- mapper/SampleMapper.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\t<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n\t    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n\t\n\t<!-- namespace 用于绑定 Mapper 代理开发 -->\n\t<mapper namespace=\"cn.kofes.mapper.SampleMapper\">\n\t    <!--\n\t     | 配置 SQL 语句：例如查找某一元组\n\t     | - id 属性：唯一标识映射文件中的 SQL\n\t     | - parameterType 属性：指定输入参数的类型\n\t     | - resultType 属性：指定输出参数的类型\n\t     |   SQL 语句会封装到 MappedStatement 对象中，故 ID 又称为 Statement 的 ID\n\t     | - #{}：表示一个占位符号\n\t     | - #{id}：id 表示接收输入的参数，参数名称就是 id\n\t    -->\n\t    <select id=\"findCertianTupleById\" parameterType=\"int\" resultType=\"cn.kofes.bean.Sample\">\n\t        SELECT * FROM t_sample WHERE id = #{id}\n\t    </select>\n\t    \n\t    <!-- 插入元组 -->\n\t    <insert id=\"insertOneTuple\" parameterType=\"cn.kofes.pojo.Sample\">\n\t        <!-- 用于自增 ID 的情况，在完成插入后将 ID 返回 user 对象中\n\t        <selectKey keyProperty=\"id\" order=\"AFTER\" resultType=\"java.lang.Integer\">\n\t            SELECT LAST_INSERT_ID()\n\t        </selectKey>\n\t        -->\n\t\n\t        <!-- 用于非自增 ID 的情况，先产生 ID 放入 user 对象中，再执行保存\n\t        <selectKey keyProperty=\"id\" order=\"BEFORE\" resultType=\"java.lang.String\">\n\t            SELECT UUID()\n\t        </selectKey>\n\t        INSERT INTO t_sample (id, name) VALUES (#{id}, #{name})\n\t        -->\n\t        INSERT TO t_sample(id, name) value(#{id}, #{name})\n\t    </insert>\n\t    \n\t    <!-- 删除一条元组 -->\n\t    <delete id=\"deleteOneTupleById\" parameterType=\"java.lang.Integer\">\n\t        DELETE FROM t_sample WHERE id = #{id}\n\t    </delete>\n\t\n\t    <!-- 更新一条元组 -->\n\t    <update id=\"updateOneTupleById\" parameterType=\"cn.kofes.pojo.Sample\">\n\t        UPDATE t_sample SET id = #{id}, name = #{name}\n\t        WHERE id = #{id}\n\t    </update>\n\t</mapper>\n\t```\n\t\n##### 案例演示 \n- 单独使用 MyBatis 框架，根据 id 查询指定用户：\n\n\t```java\n\t// 便于检验效果，这里以单元测试类实现\n\tpublic class DBOperatorTest {\n\t    @Test\n\t    public void testDoSomethingInDB() {\n\t        // 加载 MyBatis 配置文件\n\t        String resource  = \"SqlMapConfig.xml\";\n\t        // 得到配置文件流\n\t        InputStream inputStream = Resource.getResourceAsStream(resource);\n\t        // 创建会话工厂\n\t        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder()\n\t            .build(inputStream);\n\t            \n\t        // 通过会话工厂，得到 SqlSession 对象\n\t        SqlSession sqlSession = sqlSessionFactory.openSession();\n\t        \n\t        // 通过 SqlSession 操作数据库\n\t        // 第一个参数：namespace + statement id\n\t        // 第二个参数：指定和映射文件中所匹配的 parameterType 相同属性类型的参数\n\t        \n\t        /* 根据 ID 查询元组\n\t        Sample sample = sqlSession.selectOne(\n\t            \"cn.kofes.mapper.SampleMapper.findCertainTupleById\", 1);\n\t        */\n\t\n\t        /* 插入一条元组\n\t        Sample sample = new Sample();\n\t        sample.setName(\"邯郸\");\n\t        sqlSession.insert(\n\t            \"cn.kofes.mapper.SampleMapper.insertOneTuple\", sample);\n\t        */\n\t        \n\t\n\t        /* 根据 ID 修改元组\n\t        Sample sample = new Sample();\n\t        sample.setId(14);\n\t        sample.setName(\"阿斗\");\n\t        sqlSession.update(\n\t            \"cn.kofes.mapper.SampleMapper.updateOneTupleById\", sample);\n\t        */\n\t        \n\t        sqlSession.commit();\n\t        sqlSession.close();\n\t    }\n\t}\n\t```\n\t\n- 案例总结：\n\t- `namespace`：命名空间，作用是隔离 SQL。在 MyBatis 和 Spring 结合使用时具有特殊的意义，这里暂且使用全限定类名。\n\t- `<select>` 等 SQL Command 标签需要一个 ID，还需要输入参数 parameterType，输出参数映射 resultType 等。在 MyBatis 底层封装成了一个 MappedStatement 对象，使用时以 `namespace.id` 的方式引用即可。\n\t- `#{}` 和 `${}`：\n\t\t- `#{}`：表示一个占位符号，用于接收输入参数，类型可以是简单类型，也可是 POJO、HashMap 等。( 通过 `OGNL 表达式` 读取对象的属性值 )\n\t\t- `${}`：表示一个拼接符号，会引入 `SQL注入`，故不建议使用。\n\n- 思考问题：\n\t- 我们重点关注的是 SqlSession，它其实是一个 interface，定义了很多操作数据库的接口，其中实现了 Closeable 接口，很明确是使用完毕后需要 `close()` 的。  \n\t- 它的实现类 DefaultSqlSession 中有一些数据域，比如说 autoCommit，在默认情况下是不开启自动提交的；且方法也并不是 Synchronized 的，这说明 SqlSession 并不是线程安全的，因此我们应该是局部使用 SqlSession，且在使用完毕后 `close()` 关闭 sqlSession。\n\n##### ~~MyBatis 原始方法~~\n\n> 这种方式，重复的代码太多，现阶段基本弃用，目前使用最多的就是 Mapper 代理开发。\n\n- 在开始 Mapper 代理开发前，可了解一种 MyBatis 的原始 Dao 开发方法：\n\t- Step.01.提供 Dao 接口，有增、删、改、查的方法。\n\t- Step.02.提供 Dao 的实现类，在实现类中利用 Spring 注入 SqlSessionFactory，然后在各个方法中得到 SqlSession，进行操作后，关闭 SqlSession 即可。\n- 便于理解，放上实现代码：\n\n\t```java\n\t// DAO 层接口\n\tpublic interface BaseDao {\n\t    public void insertOneTuple(User user) throw Exception;\n\t    public void deleteOneTupleById(int id)  throw Exception;\n\t    public void updateOneTupleById(User user)  throw Exception;\n\t    public User findCertainById(int id) throw Exception;    \n\t}\n\t\n\t// DAO 层实现类\n\tpublic class SampleDaoImpl implements BaseDao {\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    \n\t    public SampleDaoImpl(SqlSessionFactory sqlSessionFactory) \n\t        throw Exception {\n\t        this.sqlSessionFactory = sqlSessionFactory;\n\t    }\n\t    \n\t    @Override\n\t    public User findCertainById(int id) throw Exception { \n\t        // 省略实现逻辑...\n\t    }\n\t    @Override\n\t    public void deleteOneTupleById(int id)  throw Exception { \n\t        // 省略实现逻辑...\n\t    }\n\t    @Override\n\t    public void updateOneTupleById(User user)  throw Exception {\n\t        // 省略实现逻辑...\n\t    }\n\t    @Override\n\t    public User findCertainById(int id) throw Exception {\n\t        // 省略实现逻辑...\n\t    }\n\t}\n\t\n\t// 单元测试类\n\tpublic class SampleDaoTest {\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    \n\t    @Before\n\t    public void setUp() {\n\t        InputStream inputStream = \n\t            Resource.getResourceAsStream(\"SqlMapConfig.xml\");\n\t        SqlSessionFactory sqlSessionFactory = \n\t            new SqlSessionFactoryBuilder().build(inputStream);\n\t    }\n\t\n\t    @Test\n\t    public void testFindCertainById() {\n\t        BaseDao sampleDao = new SampleDaoImpl(sqlSessionFactory);\n\t        User user = sampleDao.findCertainById(5);\n\t        System.out.println( user.toString() );\n\t    }\n\t}\n\t```\n\n##### Mapper 代理开发\n\n- Mapper 映射文件：上一节配置的映射文件 `SampleMapper.xml`\n\n- Mapper 接口：\n\t-  在 SampleMapper.xml 中 namespace 等于 Mapper 的接口地址 ( `全路径地址` )；\n\t-  在 Mapper 接口中的 `方法名` 和 SampleMapper.xml 中 Statement 的 `ID` 名称一致；\n\t-  在 Mapper 接口中的方法 `输入参数类型` 和 SampleMapper.xml 中 Statement 的 `parameterType` 指定的类型一致。\n\t-  在 Mapper 接口中的 `方法返回值类型` 和 SampleMapper.xml 中 Statement 的 `resultType` 指定的类型一致。\n\n- 关于规范的启示：故我们进行 Mapper 的开发应该遵循一些规范，这样 MyBatis 方可自动生成 `XXXMapper` 类的代理实现类。\n\t- 保证 XXXMapper.xml 中的 `namespace` 同 XXXMapper.java 的 `全限定名称` 一致；\n\t- 保证 XXXMapper.xml 中的 `Statement ID` 同 XXXMapper.java 的 `方法名称` 一致；\n\t- 保证 XXXMapper.xml 中的 Statement 的输入参数的类型 ( `parameterType` )、输出参数的类型 ( `resultType` ) 同 `XXXMapper.java` 的保持一致.\n\n\t![图6-2Mapper代理开发规范](/images/illustration/Project/2018/08/J2EE-SSM-1_6-2.png)\n<center>图6-2 Mapper 代理开发规范</center>\n\n\t```java\n\t// Mapper 接口：cn.kofes.ssm.mapper.SampleMapper.java\n\tpublic interface SampleMapper {\n\t    public void insertOneTuple(Sample sample);\n\t    public void deleteOneTupleById(Integer id);\n\t    public void updateOneTupleById(Sample sample);\n\t    public Sample findCertainTupleById(Integer id);\n\t}\n\t\n\t// 单元测试类\n\tpublic class SampleMapperTest {\n\t\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    private  SqlSession sqlSession;\n\t\n\t    @Before\n\t    public void setUp() throws IOException {\n\t        // 加载 MyBatis 配置文件，得到配置文件流\n\t        InputStream inputStream =\n\t            Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n\t        // 创建会话工厂\n\t        SqlSessionFactory sqlSessionFactory =\n\t            new SqlSessionFactoryBuilder().build(inputStream);\n\t        // 通过会话工厂，得到 SqlSession 对象\n\t        sqlSession = sqlSessionFactory.openSession();\n\t    }\n\t\n\t    @Test\n\t    public void testFindCertainTupleById() {\n\t        SampleMapper sampleMapper = sqlSession.getMapper(SampleMapper.class);\n\t        System.out.println( sampleMapper.findCertainTupleById(15).toString() );\n\t        sqlSession.close();\n\t    }\n\t}\n\t```\n- 当然不要忘记在全局配置文件 `SqlMapConfig.xml` 中加载映射文件 ( 参考上述配置文件 )。\n\n##### POJO 包装类型查询\n\n###### 输入映射\n-  输入映射：通过 parameterType 指定输入参数的类型，类型可以是 `简单类型`，也可以是  `POJO`、`HashMap` 类型。\n\n\t```java\n\t// 定义包装类型 POJO：自定义所需要的查询条件，实现多表查询\n\tpublic class POJOCollection {\n\t    /**\n\t     * 为更加形象、理解，这里引入用户和部门的实体类\n\t     * 一个用户对应一个部门，一个部门包含多个用户\n\t     */\n\t    private User user; // User 实体类\n\t    private Department department; // Department 实体类\n\t    \n\t    // 构造函数初始化\n\t    public POJOCollection() {\n\t        user = new User();\n\t        department = new Department();\n\t    }\n\t\t\n\t    // 生成 Setter 和 Getter 方法\n\t    public void setUser(User user) { this.user = user; }\n\t    public User getUser() { return user; }\n\t    public void setDepartment(Department department) { this.department = department; }\n\t    public Department getDepartment() { return department; }\n\t}\n\t```\n\n- 在映射文件 `SampleMapper.xml` 中配置 SQL 语句：\n\n\t```xml\n\t<!--  自定义所需要的查询条件，实现多表查询 -->\n\t<select id=\"findPOJOList\"\n\t    parameterType=\"cn.kofes.ssm.pojo.POJOCollection\"\n\t    resultType=\"cn.kofes.ssm.pojo.User\">\n\t    SELECT * FROM t_user as u, t_department as d\n\t    WHERE u.uid = #{user.uid} and d.depart_id = #{department.depart_id}\n\t</select>\n\t```\n\n- Mapper 接口：\n\n\t```java\n\t// Mapper 接口：cn.kofes.ssm.mapper.SampleMapper.java\n\tpublic interface SampleMapper {\n\t    public List<Sample> findPOJOList(POJOCollection pojoCollection);\n\t}\n\t\n\t// 单元测试类\n\tpublic class SampleMapperTest {\n\t\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    private  SqlSession sqlSession;\n\t\n\t    @Before\n\t    public void setUp() throws IOException {\n\t        // 同上\n\t    }\n\t\n\t    @Test\n\t    public void testFindPOJOList() {\n\t        // Mapper 接口代理\n\t        SampleMapper sampleMapper =\n\t            sqlSession.getMapper(SampleMapper.class);\n\t\n\t        POJOCollection pojoCollection = new POJOCollection();\n\t        pojoCollection.getUser().setUid(50);\n\t        pojoCollection.getDepartment().setDepart_id(1);\n\t\n\t        List<User> list =\n\t            sampleMapper.findPOJOList(pojoCollection);\n\t        System.out.println( list.get(0).toString() );\n\t\n\t        sqlSession.close();\n\t    }\n\t}\n\t```\n\n###### 输出映射\n\n- 输出映射：使用 resultType 进行输出映射，查询列名和 POJO 中的属性名一致，该列才会成功映射。\n\n\t> 若查询出来的列名 ( 通过 AS 自定义的列名 ) 和 POJO 的属性名不一致，通过定义一个 resultMap 对列名和属性名之间作一个映射关系。\n\t\n- 定义 resultMap：在映射文件 `SampleMapper.xml` 中定义；\n\n\t```xml\n\t<!--\n\t | id：resultMap 唯一标识\n\t | type：\n\t-->\n\t<resultMap id=\"sampleResultMap\" type=\"cn.kofes.ssm.pojo.Sample\">\n\t    <!--\n\t     | id 表示查询结果集中的唯一标识\n\t     | colum：查询出来的列名 ( AS 自定义列名 )\n\t     | property：type 指定的 POJO 类型中的属性名\n\t    -->\n\t    <id column=\"id_\" property=\"id\" />\n\t    <!--\n\t     | result 对非 ID 的属性进行映射定义\n\t    -->\n\t    <result column=\"name_\" property=\"name\" />\n\t</resultMap>\n\t\n\t<!-- 使用 resultMap 作为 Statement 的输出映射类型 -->\n\t<select id=\"listCustomView\"\n\t    parameterType=\"int\" resultMap=\"sampleResultMap\">\n\t    SELECT id as id_, name as name_\n\t    FROM t_sample\n\t    WHERE id = #{id}\n\t</select>\n\t```\n\n- Mapper 接口：\n\n\t```java\n\t// Mapper 接口：cn.kofes.ssm.mapper.SampleMapper.java\n\tpublic interface SampleMapper {\n\t    public Sample listCustomView(Integer id);\n\t}\n\t\n\t// 单元测试类\n\tpublic class SampleMapperTest {\n\t\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    private  SqlSession sqlSession;\n\t\n\t    @Before\n\t    public void setUp() throws IOException {\n\t        // 同上\n\t    }\n\t\n\t    @Test\n\t    public void testListCustomView() {\n\t        // Mapper 接口代理\n\t        SampleMapper sampleMapper = \n\t            sqlSession.getMapper(SampleMapper.class);\n            \n\t        System.out.println( sampleMapper.listCustomView(15) );\n\t    }\n\t}\n\t```\n\n###### 映射对比\n- `resultType` 查询出来的列名 ( 通过 AS 自定义的列名 ) 和 POJO 的属性名需一致，该列才会成功映射。  \n\t`resultMap` 可根据查询出来的列名指定 POJO 类型中的应的属性名。\n- `resultType` 返回的是 User 对象，适应较简单的输出结果映射，MyBatis 其实还提供了`resultMap` 作为复杂输出结果映射。在 [高级映射](#高级映射) 章节将对比阐述。\n\t\n##### 动态 SQL\nMyBatis 核心是对 SQL 语句进行灵活操作，通过表达式进行判断，对 SQL 进行灵活拼接、组装。\n\n- SQL 语句 `拼接`，例如 `<where>` 和 `<if>` 标签的组合使用；\n- SLQ 语句 `抽离`，例如 `<sql>` 和 `<include>` 标签的组合使用； \n- Foreach：向 SQL 传递数组或 List 集合，MyBatis 使用 `<foreach>` 标签解析。例如，我们需要查询多个 ID 值；\n\n\t```xml\n\t<!-- 将通用的 SQL 语句抽离，例如：属性名、表名等 -->\n\t<sql id=\"t_sample\">t_sample</sql>\n\t\n\t<select id=\"findPOJOList\" \n\t    parameterType=\"cn.kofes.ssm.pojo.POJOCollection\"\n\t    resultType=\"cn.kofes.ssm.pojo.Sample\">\n\t    SELECT * FROM <include refid=\"t_sample\" />\n    \n\t    <!-- 自动去掉条件中第一个 AND 或者 OR  -->\n\t    <where>\n\t        <!-- Case.01.注意下面这种写法只适用于 id 类型为 String  -->\n\t        <if test=\" sample.id != null and sample.id != '' \">\n\t            AND sample.id = #{sample.id}\n\t        </if>\n\t        <if test=\" other.id != null and other.id  != '' \">\n\t            AND other.id = #{other.id}\n\t        </if>\n        \n\t        <!-- Case.02.若 id 类型为 Integer 需要以下写法 \n\t        <if test=\"_parameter!=null and _parameter > 0\">\n\t            AND id = #{id}\n\t        </if>\n\t        -->\n\t        \n\t        <!-- Case.03.查询多个 ID 值 -->\n\t        \n\t        <!--  拼接效果：AND(id = ? OR id = ? OR id = ?) \n\t        <if test=\"ids != null\">\n\t            <foreach collection=\"ids\" item=\"id\" \n\t                open=\"AND (\" close=\")\" separator=\"OR\">\n\t                id = #{id}\n\t            </foreach>\n\t        </if>\n\t        -->\n\t        \n\t        <!--  拼接效果：IN(1, 3, 5)\n\t        <if test=\"ids != null\">\n\t            <foreach collection=\"ids\" item=\"id\" \n\t                open=\"IN (\" close=\")\" separator=\",\">\n\t                id = #{id}\n\t            </foreach>\n\t        </if>\n\t        -->\n\t    </where>\n\t</select>\n\t```\n\t\n##### 高级映射\n为便于后续章节的学习，这里以用户表、商品表、订单表和订单明细表的实例来阐述问题：\n\n![图6-3用户购物清单ER图](/images/illustration/Project/2018/08/J2EE-SSM-1_6-3.png)\n<center>图 6-3 用户购物清单 ER 图</center>\n\n- 用户表 ( User )：购买商品的用户信息；\n- 商品表 ( Item )：商品的明细信息；\n- 订单表 ( Order )：用户所创建的订单；\n- 订单明细表 ( OrderDetail )：每一张订单记录购买的商品信息；\n\n\t> 为便于理解，数据表与 POJO ( 实体类 ) 的名称统一命名为相同名称。\n\n###### 一对一映射\n便于理解，我们可以确立一需求：查询订单表，关联查询 `创建订单的用户信息`。\n\nUser 和 Order 的关联查询，关键是查询出来的结果如何映射？是用 resultType，还是用 resultMap？\n\n1) `resultType`  \n\n显然我们的实体类 ( User 仅仅包含用户信息，Order 仅仅包含订单信息，Order 中没有 User 的引用 ) 并不能接受关联查询的结果集，那么我们可以考虑使用 OrderVoUser 映射类，即让它 `extends Orders`，然后在加上一些 User 的属性作为输出结果类型。\n\t\n> OrdersVoUser 映射类的创建原理与上述的 POJOCollection 映射类一样。\n\n2) `resultMap`  \n\t\n\n可满足复杂输出结果映射，例如数据库字段名称与查询的字段名称 ( 或通过 AS 声明了别名 ) 不一致的映射；延迟加载；一对一，一对多，多对多等高级映射特性。\n\t\n> 这里引用实例说明，即使用 resultMap 将查询结果中的订单信息映射到 Other 对象中，在 Order 类中添加 User 属性，将关联查询出来的用户信息映射到 Other 对象中的 User 属性中。 \n\n- 配置映射文件 Mapper.xml \n\n\t```xml\n\t<!-- 映射文件 Mapper.xml -->\n\t\n\t<!-- 订单查询映关联查询用户信息的 resultMap  -->\n\t<resultMap id=\"OrderUserResultMap\" type=\"cn.kofes.ssm.pojo.Order\">\n\t    <!-- \n\t     | 配置映射的订单信息\n\t     | colum：订单信息的列名\n\t     | property：订单信息的列名所映射到 POJO 中的属性名\n\t    -->\n\t    <id column=\"order_id\" property=\"order_id\" />\n\t    <result column=\"createtime\" property=\"createtime\" />\n\t    \n\t    <!-- \n\t     | 配置映射的关联用户信息\n\t     | association 标签中 javaType 必须要明确指明类型\n\t     -->\n\t     <association property=\"user\" javaType=\"cn.kofes.ssh.pojo.User\">\n\t         <id column=\"uid\" property=\"uid\" />\n\t         <result column=\"username\" property=\"username\" />\n\t         <result column=\"age\" property=\"age\" />\n\t         <result column=\"phone\" property=\"phone\" />\n\t     </association>\n\t</resultMap>\n\t\n\t<!-- SQL 语句：查询订单表，关联查询创建订单的用户信息  -->\n\t<select id=\"findOrderUserResultMap\" resultMap=\"OrderUserResultMap\">\n\t    SELECT\n\t        u.uid, u,username, u.age, u.phone, \n\t        o.order_id\n\t    FROM\n\t        Order AS o, User AS u\n\t    WHERE\n\t        o.id = u.uid\n\t</select>\n\t```\n\t\n- Mapper 接口：\n\n\t```java\n\t// SampleMapper 接口\n\tpublic interface SampleMapper {\n\t    public List<Order> findOrderUserResultMap();\n\t}\n\t\n\t// 单元测试类\n\tpublic class SampleMapperTest {\n\t\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    private  SqlSession sqlSession;\n\t\n\t    @Before\n\t    public void setUp() throws IOException {\n\t        // 同上\n\t    }\n\t\n\t    @Test\n\t    public void testFindOrderUserResultMap() {\n\t        // Mapper 接口代理\n\t        SampleMapper sampleMapper = \n\t            sqlSession.getMapper(SampleMapper.class);\n            \n\t        List<Order> list = sampleMapper.findOrderUserResultMap();\n\t    }\n\t}\n\t```\n\n###### 一对多映射\n确立一需求：查询订单及订单明细的信息。\n\n- 实体类配置\n\n\t> 为了满足二级缓存需求，所有实体类实现 `Serializablle` 接口，实现序列化。\n\n\t```java\n\tpublic class User implements Serializable {\n\t\n\t    private Integer uid;\n\t    private String username;\n\t    private Integer age;\n\t    private String phone;\n\t    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t\n\tpublic class Order implements Serializable {\n\t    private Integer order_id;\n\t    private Date createtime;\n\t    \n\t    // 把订单所对应的订单明细映射到 orderDetail 属性中\n\t    private List<OrderDetail> orderDetail;\n\t    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t\n\tpublic class OrderDetail implements Serializable {\n\t    private Integer orderdetail_id;\n\t    private Integer item_id;\n\t    private Integer order_id;\n\t    private Integer amount;\n\t    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\n\tpublic class Item implements Serializable {\n\t    private Integer item_id;\n\t    private String itemname;\n\t    private String itemprice;\n    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t```\n\n- 配置映射文件 Mapper.xml \n\n\t```xml\n\t<!-- 映射文件 Mapper.xml -->\n\t\n\t<!-- 查询订单及关联查询订单明细的 resultMap  -->\n\t<resultMap \n\t    id=\"OrderAndOrderDetailResultMap\"\n\t    type=\"cn.kofes.ssm.pojo.Order\"\n\t    extend=\"OrderUserResultMap\">\n\t\n\t    <!-- 配置映射的订单信息 -->  \n\t    <!-- 配置映射的用户信息 -->\n\t    <!-- 通过继承免去重复配置：extend=\"Objective ResultMap ID\" -->\n\t    \n\t    <!-- \n\t     | 配置映射的订单明细信息：使用 Collection 对关联查询的多条记录\n\t     | 映射到一个 List 集合属性中\n\t     | ofType：指定映射到集合属性中 POJO 的类型\n\t    -->\n\t    <collection property=\"orderDetail\" ofType=\"cn.kofe.ssm.pojo.OrderDetail\">\n\t        <id column=\"orderdetail_id\" property=\"id\">\n\t        <result column=\"item_id\" property=\"username\" />\n\t        <result column=\"order_id\" property=\"username\" />\n\t        <result column=\"amount\" property=\"amount\" />\n\t    </collection>\n\t</resultMap>\n\t\n\t<!-- SQL：查询订单及订单明细的信息 -->\n\t<select \n\t    id=\"findOrderAndOrderDetailResultMap\"\n\t    resultMap=\"OrderAndOrderDetailResultMap\">\n\t    SELECT\n\t        o.order_id, o.createtime, \n\t        od.item_id, od.amount,\n\t        i.itemname\n\t    FROM\n\t        Order AS o, Item AS i, OrderDetail As od\n\t    WHERE \n\t        od.order_id = o.order_id AND \n\t        od.item_id = i.item_id\n\t</select>\n\t```\n\t\n- Mapper 接口：\n\n\t```java\n\t// SampleMapper 接口\n\tpublic interface SampleMapper {\n\t    public List<Order> findOrderAndOrderDetailResultMap();\n\t}\n\t\n\t// 单元测试类\n\tpublic class SampleMapperTest {\n\t\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    private  SqlSession sqlSession;\n\t\n\t    @Before\n\t    public void setUp() throws IOException {\n\t        // 同上\n\t    }\n\t\n\t    @Test\n\t    public void testFindOrderAndOrderDetailResultMap() {\n\t        // Mapper 接口代理\n\t        SampleMapper sampleMapper = \n\t            sqlSession.getMapper(SampleMapper.class);\n            \n\t        List<Order> list = sampleMapper.findOrderAndOrderDetailResultMap();\n\t    }\n\t}\n\t```\n\n###### 多对多映射\n确立一需求：查询用户及用户购买的商品信息。\n\n在多对多映射中，具体的映射思路是：  \n1) 在 User 实体类中添加订单列表属性 `List<Order> orderList`，将用户创建的订单映射到 orderList。  \n2) 在 Order 实体类中添加订单明细列表属性 `List<OrderDetail> orderDetail`，将订单的明细映射到 orderDetail。  \n3) 在 OrderDetail 实体类中添加 `Item` 属性，将订单明细所对应的商品映射到 item。  \n\n- 实体类配置\n\n\t```java\n\tpublic class User implements Serializable {\n\t    private Integer uid;\n\t    private String username;\n\t    private Integer age;\n\t    private String phone;\n\t    \n\t    // 将用户创建的订单映射到 orderList\n\t    private List<Order> orderList;\n\t    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t\n\tpublic class Order implements Serializable {\n\t    private Integer order_id;\n\t    private Date createtime;\n\t    \n\t    // 将订单所对应的订单明细映射到 orderDetail 属性中\n\t    private List<OrderDetail> orderDetail;\n\t    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t\n\tpublic class OrderDetail implements Serializable {\n\t    private Integer orderdetail_id;\n\t    private Integer item_id;\n\t    private Integer order_id;\n\t    private Integer amount;\n\t    \n\t    private Item item;\n\t    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t\n\tpublic class Item implements Serializable {\n\t    private Integer item_id;\n\t    private String itemname;\n\t    private String itemprice;\n    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t```\n\n- 配置映射文件 Mapper.xml \n\n\t```xml\n\t<!-- 映射文件 Mapper.xml -->\n\t\n\t<!-- 查询用户及关联查询用户购买的商品信息的 resultMap  -->\n\t<resultMap \n\t    id=\"UserAndItemResultMap\" type=\"cn.kofes.ssm.pojo.User\">\n\t    \n\t    <!-- 配置用户信息 -->\n\t    <id column=\"uid\" property=\"uid\">\n\t    <result column=\"username\" property=\"username\" />\n\t    <result column=\"age\" property=\"age\" />\n\t    <result column=\"phone\" property=\"phone\" />\n\t\n\t    <!-- \n\t     | 配置映射的订单信息：使用 Collection 对关联查询的多条记录\n\t     | 映射到一个 List 集合属性中\n\t     | ofType：指定映射到集合属性中 POJO 的类型\n\t    -->\n\t    <collection property=\"orderList\" ofType=\"cn.kofe.ssm.pojo.Order\">\n\t    \n\t        <id column=\"order_id\" property=\"order_id\">\n\t        <result column=\"createtime\" property=\"createtime\" />\n\t        \n\t        <!-- 配置映射的订单明细信息：一个订单包含多个订单明细 -->\n\t        <collection property=\"orderDetail\" ofType=\"cn.kofe.ssm.pojo.OrderDetail\">\n\t        \n\t            <id column=\"orderdetail_id\" property=\"id\">\n\t            <result column=\"item_id\" property=\"username\" />\n\t            <result column=\"order_id\" property=\"username\" />\n\t            <result column=\"amount\" property=\"amount\" />\n\t            \n\t            <!-- 配置映射的商品信息：一个订单明细对应一个商品 -->\n\t            <association property=\"item\" javaType=\"cn.kofes.ssm.pojo.Item\">\n\t                <id column=\"item_id\" property=\"item_id\">\n\t                <result column=\"itemname\" property=\"itemname\" />\n\t                <result column=\"itemprice\" property=\"itemprice\" />\n\t            </association>\n\t            \n\t        </collection>\n\t        \n\t    </collection>\n\t    \n\t</resultMap>\n\t\n\t<!-- SQL：查询用户信息和用户购买过的商品信息 -->\n\t<select id=\"findUserAndItemResultMap\" resultMap=\"UserAndItemResultMap\">\n\t    SELECT \n\t        u.uid, u.username, \n\t        o.order_id,\n\t        od.item_id, od.amount\n\t        i.itemname, i.itemprice\n\t    FROM\n\t        Order AS o, User AS u, Item AS i, OrderDetail As od\n\t    WHERE\n\t        o.user_id = u.uid AND\n\t        od.order_id = o.order_id AND\n\t        od.item_id = i.item_id\n\t</select>\n\t```\n\t\n- Mapper 接口：\n\n\t```java\n\t// SampleMapper 接口\n\tpublic interface SampleMapper {\n\t    public List<User> findUserAndItemResultMap();\n\t}\n\t\n\t// 单元测试类\n\tpublic class SampleMapperTest {\n\t\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    private  SqlSession sqlSession;\n\t\n\t    @Before\n\t    public void setUp() throws IOException {\n\t        // 同上\n\t    }\n\t\n\t    @Test\n\t    public void testFindUserAndItemResultMap() {\n\t        // Mapper 接口代理\n\t        SampleMapper sampleMapper = \n\t            sqlSession.getMapper(SampleMapper.class);\n            \n\t        List<User> list = sampleMapper.findUserAndItemResultMap();\n\t    }\n\t}\n\t```\n\n###### 高级映射总结\n- 一对一映射：在 `Order` 实体对象中引入 `User` 属性，且在配置文件 Mapper.xml 中，通过 `<association>` 标签关联用户信息。\n- 一对多映射：在 `Order` 实体对象中添加订单明细列表属性 `List<OrderDetail> orderDetails`，且在配置文件 Mapper.xml 中，通过 `<collection>` 标签关联订单明细信息。\n- 多对多映射：\n\t- 在 User 实体对象中添加订单列表属性 `List<Order> orderList`，将用户创建的订单映射到 orderList。  \n\t- 在 Order 实体对象中添加订单明细列表属性 `List<OrderDetail> orderDetail`，将订单的明细映射到 orderDetail。  \n\t- 在 OrderDetail 实体对象中添加 `Item` 属性，将订单明细所对应的商品映射到 item。\n\n##### 延迟加载\n- 延迟加载，即需要时才发出 SQL 查询请求。Hibernate 中有延迟加载，MyBatis 同样提供了这个功能，具体以 `<resultMap>` 标签的属性完成配置。当然，我们可具体分析 MyBatis 的延迟加载。\n\n- MyBatis是默认开启延迟加载的么？如果不是，那么显然应该进行延迟加载配置。\n\n\t在 MyBatis 的全局核心配置文件 SqlMapConfig.xml 的 `<settings>` 标签中可设置 lazyLoadingEnabled 以及 aggressiveLazyLoading 属性值。\n\t\n\t- `lazyLoadingEnabled`：全局性设置懒加载，默认值为 flase，即所有相关联的都会被初始化加载。\n\n\t- `aggressiveLazyLoading`：默认值为 ture，懒加载的对象可能被任何懒属性全部加载。否者，每个属性按需加载。\n\n- 要实现延迟加载，就得进行 SQL 拆分 ( 若我们的SQL都写在一起，DB要么执行，要么不执行，根本做不到按需查询，所以要延迟加载就得拆分 SQL ) 那么怎么进行拆分呢？\n\n\t在 resultMap 中的 `<collection>` 以及 `<association>` 标签中有 `select` 属性，也就是说当使用到了 `<collection>` 或者 `<association>` 时才发出 `select` 属性对应的 SQL。\n\t\n\t```xml\n\t<!-- 映射文件 Mapper.xml -->\n\t\n\t<!-- 延迟加载的 resultMap -->\n\t<resultMap\n\t    id=\"OrderUserLazyLoadingResultMap\" type=\"cn.kofes.ssm.pojo.Order\">\n\t    <id column=\"order_id\" property=\"order_id\" />\n\t    <result column=\"createtime\" property=\"createtime\" />\n\t\n\t    <!-- 实现对用户信息进行延迟加载\n\t     | select 属性：指定延迟加载需要执行的 Statement 的 ID，\n\t     | 即根据 user_id 查询用户信息的 Statement\n\t     | column 属性：订单信息中关联查询用户信息得到的列，\n\t    -->\n\t    <association \n\t        property=\"user\" javaType=\"cn.kofes.ssh.pojo.User\"\n\t        select=\"findUserById\" column=\"user_id\" />\n\t    \n\t</resultMap>\n\t\n\t<!-- Step.01.查询订单管理查询用户信息，用户信息需要延迟加载 -->\n\t<select\n\t    id=\"finOrderUserLazyLoading\" resultMap=\"OrderUserLazyLoadingResultMap\">\n\t    SELECT * FROM Order\n\t</select>\n\t\n\t<!-- Step.02.关联查询用户信息：根据订单信息中的 user_id 去关联查询用户信息 -->\n\t<select\n\t    id=\"findUserById\" parameterType=\"int\" resultType=\"cn.kofes.ssm.pojo.User\">\n\t    SELECT * FROM User WHERE user_id = #{user_id}\n\t</select>\n\t\n\t<!-- \n\t | 执行顺序：即先执行 finOrderUserLazyLoading，\n\t | 当需要查询用户时在再执行 findUserById\n\t-->\n\t```\n\t\n- 我们其实可以借助 MyBatis 去完成延迟加载，也可以自己实现延迟加载。怎么做呢？即有需求时，我们自己调用相应的 Statement 完成即可。\n\n##### 查询缓存\n\n![图6-4MyBatis的一级缓存和二级缓存](/images/illustration/Project/2018/08/J2EE-SSM-1_6-4.png)\n<center>图 6-4 MyBatis 的一级缓存和二级缓存 $^{[3]}$</center>\n\n- MyBatis 提供一级缓存和二级缓存：\n\t- 一级缓存是 sqlSession 级别的缓存。在操作数据库时需要构造 sqlSession 对象，在对象中有一个数据结构 ( HashMap，KEY 主要就是 SqlSession + StatementId 构成 ) 用于存储缓存数据。不同的 sqlSession 之间的缓存数据区域是互不影响的；\n\t- 二级缓存是 Mapper 级别的缓存 ( `按 Namespace 划分` )。多个 sqlSession 去操作同一个 Mapper 的 SQL 语句，多个 sqlSession 去操作数据库得到数据的数据会存到二级缓存中。二级缓存区域是共享的。\n\n###### 一级缓存\n- 一级缓存的工作原理：\n\t- 如图 6-3 所示，当 sqlSession 发起 `查询` 操作，查询结果会 `写入` 到一级缓存中，待二次 `读取` 直接从一次缓存中读取即可；若 sqlSession 发起 `插入、更新、删除` 操作，则会 `清空` 一级缓存区域中的信息，以避免脏读。\n\t- 当 sqlSession 关闭时，sqlSession 缓存也随之失效。\n- MyBatis 是默认支持一级缓存的，无需配置开启。\n\n###### 二级缓存\n- 二级缓存是需要配置开启的：\n\t- 在全局配置文件 `SqlMapConfig.xml` 中指明，即在 `<setting>` 标签中的 `cacheEnabled` 属性，开启全局性缓存开关；\n\t- 其次在需要开启二级缓存的 `XXXMapper.xml` 中指明 `<cache>` 标签。\n\n\t```xml\n\t<mapper namespace=\"cn.kofes.mapper.SampleMapper\">\n\t    <!-- \n\t     | 开启本 Mapper namespace 下的二级缓存\n\t     | type 属性：指定 cache 接口的实现类的类型，默认使用 PerpetualCache\n\t     | \n\t    -->\n\t    <cache type=\"...\"/>\n\t    \n\t    <!-- 当然也可使用分布式缓存：Ehcache\n\t    <cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/>\n\t    -->\n\t</mapper>\n\t```\n\t\n- 所有 POJO 实现序列化接口：若开启二级缓存，其存储介质可在内存、磁盘等，即为了将缓存数据取出执行反序列化操作。\n\n\t```java\n\tpublic class User implements Serializable { /* 省略细节 */ }\n\tpublic class Order implements Serializable { /* 省略细节 */ }\n\t```\n\t\n- 二级缓存的局限性：\n\n\t例如，我们仅仅更新了其中一个信息，那么意味着二级缓存的清空。而我们真正想要的是刷新该商品的缓存信息而不要影响其他商品的缓存信息。\n\t\n##### 整合 ehcache\n- `ehcache` 是一个分布式缓存框架，当然还有 `redis`、`memached` 等。\n- 分布式缓存，系统为了提高系统并发、性能，一般对系统进行分布式部署 ( 集群部署方式 )。\n- 整合方法：MyBatis 提供的 Cache 接口，实现缓存逻辑即实现 Cache 接口即可。\n\t- 提供 ehcache 以及 ehcache 与 MyBatis 整合的依赖 ( 或者 Jar 包 )；\n\t- 在 `<cache>` 标签中，type 属性指明 ehcache 实现 Cache 接口的实现类，既有：  \n\t`<cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/>`；\n\t- 提供相关的 ehcache 配置文件.\n\n\t```java\n\t// MyBatis 提供的 Cache 接口\n\tpublic interface Cache {\n\t    String getId();\n\t    void putObject(Object var1, Object var2);\n\t    Object getObject(Object var1);\n\t    Object removeObject(Object var1);\n\t    void clear();\n\t    int getSize();\n\t    ReadWriteLock getReadWriteLock();\n\t}\n\t```\n\n##### 逆向工程\n- MyBatis 官方提供逆向工程，可针对单表自动生成 MyBatis 执行所需要的代码 ( mapper.java，mapper.xml，pojo 等 )。\n- 企业实际开发中，常用的逆向工程方式：由数据库表生成 Java 代码。\n- 添加依赖或添加 Jar 包：[MyBatis-Generator](http://mvnrepository.com/artifact/org.mybatis.generator/mybatßis-generator-core) ( Maven 中央仓库 )\n\n###### 运行逆向工程\n- 参考官方指南 [MyBatis Generator](http://www.mybatis.org/generator/running/running.html)，运行逆向工程有如下方式：\n\t- 使用命令提示符读取 XML 配置文件；\n\t- 使用 Maven 插件；\n\t- 使用 Java 程序读取 XML 配置文件 ( 推荐，即不依赖 IDE )；\n\t- 使用 IDE 插件 ( Eclipse )；\n\n###### 代码配置文件\n- MyBatis 官方提供了配置文档的范例：[MyBatis GeneratorXML Configuration File Reference](http://www.mybatis.org/generator/configreference/xmlconfig.html)\n\n\t当然，你可以参考下文 $^{[5]}$，搭配注释，互相补充：\n\t\n\t```xml\n\t<!-- generatorConfig.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<!DOCTYPE generatorConfiguration\n\t    PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n\t    \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n\t    \n\t<generatorConfiguration>\n\t    <context id=\"testTables\" targetRuntime=\"MyBatis3\">\n\t    \n\t        <commentGenerator>\n\t            <!-- 是否去除自动生成的注释：true / false -->\n\t            <property name=\"suppressAllComments\" value=\"true\" />\n\t        </commentGenerator>\n\t        \n\t        <!-- ( 必填 ) 数据库连接的信息：驱动类、连接地址、用户名、密码 -->\n\t        \n\t        <!-- 连接 MySQL 数据库 -->\n\t        <jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" \n\t            connectionURL=\"jdbc:mysql://127.0.0.1:3306/db_testdb?characterEncoding=utf-8\" \n\t            userId=\"root\" password=\"123456\">\n\t        </jdbcConnection>\n\t        \n\t        <!-- 连接 Oracle 数据库\n\t        <jdbcConnection driverClass=\"oracle.jdbc.OracleDriver\"\n\t            connectionURL=\"jdbc:oracle:thin:@127.0.0.1:1521:db_testdb\" \n\t            userId=\"kofe\" password=\"123456\">\n\t        </jdbcConnection>\n\t        -->\n\t\n\t        <!--\n\t         | false ( 默认 )，把 Jdbc Decimal 和 Numeric 类型解析为 Integer\n\t         | true，把 Jdbc Decimal 和 Numeric 类型解析为 java.math.BigDecimal\n\t        -->\n\t        <javaTypeResolver>\n\t            <property name=\"forceBigDecimals\" value=\"false\" />\n\t        </javaTypeResolver>\n\t\n\t        <!-- targetProject：生成 PO 类的位置 -->\n\t        <javaModelGenerator targetPackage=\"cn.kofes.ssm.pojo\"\n\t            targetProject=\".\\src\">\n\t            <!-- enableSubPackages 是否让 schema 作为包的后缀 -->\n\t            <property name=\"enableSubPackages\" value=\"false\" />\n\t            <!-- 从数据库返回的值被清理前后的空格 -->\n\t            <property name=\"trimStrings\" value=\"true\" />\n\t        </javaModelGenerator>\n\t            \n\t        <!-- targetProject:mapper 映射文件生成的位置 -->\n\t        <sqlMapGenerator targetPackage=\"cn.kofes.ssm.mapper\" \n\t            targetProject=\".\\src\">\n\t            <!-- enableSubPackages 是否让 schema 作为包的后缀 -->\n\t            <property name=\"enableSubPackages\" value=\"false\" />\n\t        </sqlMapGenerator>\n\t            \n\t        <!-- targetPackage:mapper 接口生成的位置 -->\n\t        <javaClientGenerator type=\"XMLMAPPER\"\n\t            targetPackage=\"cn.kofes.ssm.mapper\" \n\t            targetProject=\".\\src\">\n\t            <!-- enableSubPackages 是否让 schema 作为包的后缀 -->\n\t            <property name=\"enableSubPackages\" value=\"false\" />\n\t        </javaClientGenerator>\n\t            \n\t        <!-- 指定数据库表 -->\n\t        <table tableName=\"Item\"></table>\n\t        <table tableName=\"Order\"></table>\n\t        <table tableName=\"Orderdetail\"></table>\n\t        <table tableName=\"User\"></table>\n\t        \n\t        <!--\n\t        <table schema=\"\" tableName=\"sys_user\"></table>\n\t        <table schema=\"\" tableName=\"sys_role\"></table>\n\t        <table schema=\"\" tableName=\"sys_permission\"></table>\n\t        <table schema=\"\" tableName=\"sys_user_role\"></table>\n\t        <table schema=\"\" tableName=\"sys_role_permission\"></table>\n\t        -->\n\t\n\t        <!-- 有些表的字段需要指定 Java 类型\n\t        <table schema=\"\" tableName=\"\">\n\t            <columnOverride column=\"\" javaType=\"\" />\n\t        </table>\n\t        -->\n\t        \n\t    </context>\n\t</generatorConfiguration>\n\t```\n\n###### 执行逆向工程生成代码\n\n- 配置文件配置完成后，执行以下程序即可生成代码，细节如下：\n\n\t```java\n\tpublic class GeneratorSqlmap {\n\n\t    public void generator() throws Exception{\n\n\t        List<String> warnings = new ArrayList<String>();\n\t        boolean overwrite = true;\n\t        \n\t        //指定逆向工程配置文件\n\t        File configFile = new File(\"generatorConfig.xml\"); \n\t        \n\t        ConfigurationParser cp = new ConfigurationParser(warnings);\n\t        Configuration config = cp.parseConfiguration(configFile);\n\t        DefaultShellCallback callback = new DefaultShellCallback(overwrite);\n\t        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,\n\t            callback, warnings);\n\t        myBatisGenerator.generate(null);\n\t    } \n\t    \n\t    // 调用 generator() 执行逆向工程生成代码\n\t    public static void main(String[] args) throws Exception {\n\t        try {\n\t            GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap();\n\t            generatorSqlmap.generator();\n\t        } catch (Exception e) {\n\t            e.printStackTrace();\n\t        }\n\t    }\n\t    \n\t}\n\t```\n\n- 值得注意的是，除了生成基本的 POJO 类还多了一个类，就是 `xxxExample.java`。这个类是给用户自定义 SQL 使用的。到这里就生成好了，下面我们就把生成的代码 `拷贝` 到自己的工程即可。\n\n\n---\n\n#### Spring\n\n- Spring 框架是 Java 应用最广的框架，其成功源于它的理念，即 `控制反转` ( Inversion of Control，IoC ) 和 `面向切面编程` ( Aspect Oriented Programming，AOP )。\n- Spring 框架也可理解为一个轻量级的 IoC 和 AOP 的容器框架。\n- Spring 框架在 [SSH 部分](https://www.kofes.cn/2018/07/J2EE-SSH-SSI-1.html#Spring) 有阐述，在本章节就不具体展开探讨，笔记以补充和整合部分内容为主。\n\n\t> 在 SSH Spring 章节中，要求导入相关 Jar 包，而本文的 SSM 框架要求导入的 Jar 包 ( 或者 Maven 依赖 ) 以 `版本信息` 的为标准。\n\n##### Spring 整合 MyBatis \nSpring 整合 MyBatis 是通过 `MyBatis-Spring` 的类库实现的，具体配置和使用信息可参考 [MyBatis-Spring 官方使用文档](http://www.mybatis.org/spring/zh/index.html) $^{[4]}$。\n\n###### 原始 DAO 开发\n首先要向 DAO 的实现类中注入 SqlSessionFactory ( 交由 Spring 管理，即 Spring 声明式注入 SqlSessionFactory )，然后在各个方法中得到 SqlSession 进行数据库操作。\n\n> `诉求`：在 Spring 运作中，首先加载 Spring 核心配置文件，再创建对象 ( SqlSessionFactory )。而创建对象可通过 New 的方式创建 ( [原始方法](#MyBatis-原始方法) )，但效率太低，则我们可以把加载配置文件和创建对象过程，在服务器启动时完成。故引入 Spring 声明式注入 SqlSessionFactory。\n\n- 使用封装的方法，即让 Dao 的实现类继承 `SqlSessionDaoSupport`，而 SqlSessionDaoSupport 类中已经存在 `setSqlSessionFactory()` 方法，因此我们可以直接向 Dao 的实现类注入 SqlSessionFactory。\n- 另外 SqlSessionDaoSupport 中有 SqlSession，因此使得操作更加简单；而且都交给 Spring 管理，我们自然不必担心忘记关闭 SqlSession。\n\t\n\t```java\n\t// 下述实现是通过 XML 配置方式加载配置和 Bean ( 注解方式也是可行的，但写法有区别 )\n\t\n\t// Dao 接口\n\tpublic interface BaseDao {\n\t    public List<Sample> findSampleById(int id);\n\t}\n\t\n\t// Dao 层实现类\n\tpublic class SampleDaoImpl extends SqlSessionDaoSupport implements BaseDao {\n\t\n\t    private SqlSession sqlSession;\n\t    \n\t    public SampleDaoImpl() throws Expection {\n\t        sqlSession = this.getSqlSession();\n\t    }\n\t\n\t    public Sample findSampleById(int id) throws Exception {\n\t        return sqlSession.selectOne(\n\t            \"cn.kofes.ssm.mapper.SampleMapper.findSampleById\", id);\n\t    }\n\t}\n\t\n\t// 单元测试类\n\tpublic class SampleDaoTest {\n\t\n\t    private BaseDao baseDao;\n\t    \n\t    @Before\n\t    public void setUp() {\n\t        applicationContext = \n\t            new ClassPathXmlApplicationContext(\"classpath:spring.xml\");\n\t        baseDao = (BaseDao) applicationContext.getBean(\"baseDao\");\n\t    }\n\t\n\t    @Test\n\t    public void testFindCertainById() {\n\t        System.out.println( baseDao.findSampleById(15).toString() );\n\t    }\n\t}\n\t```\n\n###### Mapper 代理开发\n\n- Mapper 代理开发的具体思路：\n\t- SqlSessionFactory 交给 Spring 管理 ( 单例模式 )。\n\n\t注意到 SqlSessionFactory 的创建显然需要数据库连接相关的信息，因此需要 `数据库连接池 (c3p0)`；除此之外还需要 MyBatis 的主配置文件 `SqlMapConfig.xml`。\n\t\n\t- Spring 和 MyBatis 整合生成代理对象，使用 SqlSessionFactory 创建 SqlSession ( Spring 和 MyBatis 整合后自动完成此过程 )。\n\n\t- 若采用 Mapper 代理的方式开发，我们需要 Spring 管理 Mapper 动态代理实现。\n\n- 在 Spring 配置文件下配置数据库信息，并整合 MyBatis。后者将 SessionFacotry 交由 Spring 管理：\n\n\t> c3p0.properties 配置文件位于 Src 根目录下，键值分离以便修改配置。\n\n\t```xml\n\t<!-- spring.xml -->\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xsi:schemaLocation=\"\n\t    http://www.springframework.org/schema/beans \n\t    http://www.springframework.org/schema/beans/spring-beans.xsd \n\t    http://www.springframework.org/schema/context \n\t    http://www.springframework.org/schema/context/spring-context.xsd\">\n\n\t    <!-- 扫描包下注解，并注册为 Bean -->\n\t    <context:component-scan base-package=\"cn.kofes.ssm\">\n\t        <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\">\n\t        </context:exclude-filter>\n\t    </context:component-scan>\n           \n\t    <!-- 在根目录下新建文件 c3p0.properties，存储数据连接信息 -->\n\t    <context:property-placeholder location=\"classpath:c3p0.properties\" />\n\n\t    <!-- Dao 层的配置，即 Mybatis 的配置 ( 分模块开发思想 ) -->\n\t    <import resource=\"spring/mybatis-spring.xml\"/>\n\t</beans>\n\t\n\t<!-- mybatis-spring.xml -->\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xsi:schemaLocation=\"\n\t    http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\t    \n\t    <!-- 1. 数据源 : DriverManagerDataSource -->\n\t    <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" destroy-method=\"close\">\n\t        <!-- 引用 c3p0.properties 的键值对即可，格式如 ${key.value} -->\n\t        <property name=\"driverClass\" value=\"${datasource.driverClass}\"/>\n\t        <property name=\"jdbcUrl\" value=\"${datasource.jdbcUrl}\"/>\n\t        <property name=\"user\" value=\"${datasource.user}\"/>\n\t        <property name=\"password\" value=\"${datasource.password}\"/>\n\t        <!-- 设置数据库连接池的最大连接数 -->\n\t        <property name=\"maxPoolSize\" value=\"${datasource.maxPoolSize}\"/>\n\t        <!-- 设置数据库连接池的最小连接数 -->\n\t        <property name=\"minPoolSize\" value=\"${datasource.minPoolSize}\"/>\n\t        <!-- 设置数据库连接池的初始化连接数 -->\n\t        <property name=\"initialPoolSize\" value=\"${datasource.initialPoolSize}\"/>\n\t        <!-- 设置数据库连接池的连接最大空闲时间 -->\n\t        <property name=\"maxIdleTime\" value=\"${datasource.maxIdleTime}\"/>\n\t        <!-- c3p0缓存Statement的数量数 -->\n\t        <property name=\"maxStatements\" value=\"${datasource.maxStatements}\"/>\n\t        <!-- 当连接池的连接用完的，从 C3p0 下获取新的连接数 -->\n\t        <property name=\"acquireIncrement\" value=\"${datasource.acquireIncrement}\"/>\n\t        <property name=\"checkoutTimeout\" value=\"${datasource.checkoutTimeout}\"/>\n\t        <property name=\"idleConnectionTestPeriod\" value=\"${datasource.idleConnectionTestPeriod}\"/>\n\t    </bean>\n\n\t    <!-- 2. 配置和 MyBatis 的整合 -->\n\t    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n\t        <property name=\"dataSource\" ref=\"dataSource\"/>\n\t    </bean>\n\n\t    <!-- 3. 配置一个可以执行批量的 SqlSession -->\n\t    <bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n\t        <constructor-arg name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/>\n\t        <constructor-arg name=\"executorType\" value=\"BATCH\"/>\n\t    </bean>\n\n\t    <!--\n\t     | 4. MyBatis 自动扫描加载 Sql 映射文件: MapperScannerConfigurer\n\t     | 自动扫描出的 Mapper Bean 的 ID 名称为首字母小写的类名\n\t     | 且效果与 SqlMapConfig.xml 中配置批量加载映射文件相同，即 <package name=\"cn.kofes.ssm.mapper\"/>\n\t     | 1) 批量加载映射文件：mapper.java 与 mapper.xml 同名，且在同一目录下\n\t     | 2) 当然，你可以建立同样的文件夹目录 (cn/kofes/ssm/mapper)，把 mapper.xml 单独放置资源目录下\n     -->\n\t    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n\t        <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\" />\n\t        <property name=\"basePackage\" value=\"cn.kofes.ssm.mapper\" />\n\t    </bean>\n\n\t</beans>\n\t```\n\n- 代码实现：注解方式实现 Mapper 类的调用：\n\n\t```java\n\t// 下述实现是通过注解方式加载配置和 Bean ( XML 方式也是可行的，但写法有区别 )\n\t\n\t// Mapper 接口\n\tpublic interface SampleMapper {\n\t    public Sample findCertainTupleById(Integer id);\n\t}\n\t\n\t// 单元测试类\n\t@RunWith(SpringJUnit4ClassRunner.class)\n\t@ContextConfiguration(locations = {\"classpath:spring.xml\"})\n\tpublic class SampleMapperTest {\n\t\n\t    @Autowired\n\t    private SampleMapper sampleMapper;\n\t\n\t    @Test\n\t    public void testFindCertainTupleById() {\n\t        System.out.println( \n\t            sampleMapper.findCertainTupleById(15).toString() );\n\t    }\n\t}\n\t```\n\n---\n\n#### Spring MVC\n\n- MVC ( Model-View-Controller ) 模式把应用程序 ( 输入逻辑、业务逻辑和 UI 逻辑 ）分成不同的方面，同时提供这些元素间的松耦合。\n\t- Model：模型，封装了应用程序的 `数据` 和由它们组成的 `POJO`。\n\t- View：视图，负责把模型数据 `渲染到视图` 上，将数据以一定形式展现给用户。\n\t- Controller：负责 `处理用户请求`，并建立适当的模型把它传递给视图渲染。\n- Spring MVC 把 `模型`、`视图` 和 `控制器` 分层，组合成一个有机灵活的系统。\n- Spring MVC 中可定义逻辑视图，通过其提供的解析器找到对应的视图渲染；或在 Controller 的方法内加入注解 ( `@ResponseBody` )，通过消息转换系统将数据转换为 JSON，提供给前端 Ajax 请求使用。\n\n\n## 参考资料\n\n- \\[1\\] [ 杨开振. Java EE 互联网轻量级框架整合开发 [M]. 电子工业出版社. 2017](https://book.douban.com/subject/27090950/)\n- \\[2\\] [张丰哲. MyBatis + Spring MVC 开发指南 (一). 简书. 2017](https://www.jianshu.com/p/91a32e3d4b26)\n- \\[3\\] [张丰哲. MyBatis + Spring MVC 开发指南 (二). 简书. 2017](https://www.jianshu.com/p/48b78ee24fa3)\n- \\[4\\] [MyBatis. MyBatis-Spring 官方使用文档. mybatis.org](http://www.mybatis.org/spring/zh/index.html)\n- \\[5\\] [李阿昀. MyBatis 逆向工程自动生成代码. csdn.net. 2017](https://blog.csdn.net/yerenyuan_pku/article/details/71909325)\n\n","tags":["J2EE","JSP","SSM","MyBatis","Spring","Spring MVC"],"categories":["Project"]},{"title":"Java EE：SSH 框架快速上手教程","url":"/2018/07/J2EE-SSH-SSI-1.html","content":"\n本文章主要围绕 J2EE 中 SSH ( Spring、Struts、Hibernate ) 框架的配置以及使用问题展开学习的，最终目的是输出可复用的版本，以供后续的项目复用。当然，学习和配置的过程难免有不恰当或错误之处，还望朋友指出、斧正。\n\n<!-- More -->\n\n## 教学资源\n- 视频 | [黑马程序员. J2EE 进阶. 4 天精通 Hibernate 框架. 2017. bilibili.com](https://www.bilibili.com/video/av14626440)\n- 视频 | [黑马程序员. J2EE 进阶. 60 集精通 Spring 框架. 2017. bilibili.com](https://www.bilibili.com/video/av14839030)\n- 视频 | [黑马程序员. J2EE 进阶. Struts2 框架精品教程. 2017. bilibili.com](https://www.bilibili.com/video/av13748042)\n\n\t> 本框架的学习笔记是基于此系列教学视频所得的。\n\n## 更新进度\n- 2018.07.17：完成初稿，IDE 搭建、框架初识章节；\n- 2018.07.20：更新 SSH 框架 Hibernate 的内容；\n- 2018.07.31：更新 SSH 框架 Spring 的内容；\n- 2018.08.03：整合 SSH 框架 ( 输出基本框架 )；\n- 2018.08.08：补充 SSH 框架 Struts 部分的内容；\n- 2018.08.15：重新整理 SSH 框架项目，见版本信息；\n\n\n## IDE 搭建\n- Step.01：安装 JDK；\n- Step.02：安装 IDE ( `IntelliJ Idea` / Eclipse / MyEclipse )；\n- Step.03：配置 Tomcat 环境；\n\t- 让 Tomcat 可同时运行多个 Module，即在菜单栏 `Run > Run Configurations > Deployment > Application context` 下配置目录访问路径即可 ( 一般规范填写项目名 )。\n\n\t![Tomcat 9.0.x Deployment](/images/illustration/Project/2018/08/J2EE-SSH-SSI-1_4-1.jpg)\n<center>图 4-1 Tomcat 9.0.x Deployment</center>\n\n\t- 紧接着，在菜单栏 `File > Project Structure > Artifacts` 下配置，把对应的 module 的 Available Elements `Put into Output Root` 到 `xxx:war_exploded` 下。\n\t\n\t![Project Structure Artifacts](/images/illustration/Project/2018/08/J2EE-SSH-SSI-1_4-2.jpg)\n<center>图 4-2 Project Structure Artifacts</center>\n\n- Step.04：配置 MySQL / SQL Server 数据库；\n\t- 命名规范：数据库 `db_dbname`；数据表 `t_tablename`；属性 `attribute`\n\t- 访问外网：若在虚拟机或者本机测试，让数据库允许外网访问，注意得关闭防火墙或添加规则允许某端口的访问权限。\n\n\t\t> Case.01：本机和服务器端互相 `Ping` 对方 IP，以检验网络是否畅通、是否拒绝访问。  \n\t\t> Case.02：若网络畅通、没有拒绝访问，还要留意对应端口是否有权限访问，通过 `nc -vz IP 端口`  检验，返回 `Succeeded` 即成功。  \n    \n\t- 数据库权限：若 MySQL 通过命令安装，需特别注意的权限问题，即账号和密码是默认配置的，用户可自行修改，具体修改细节见参考 [6] - [8] 中的方法 ( 可能实操过程中还会遇到其他问题，推荐翻阅下参考文章，也许对你有帮助 )。\n\n\t\t> 若有需求远程连接数据库，我们需要创建一个新用户，并赋予访问权限 (当然，你可让你的 root 账户也赋予远程连接数据库的权限)。具体地：  \n\t\t> `grant all privileges on *.* to  kofe@\"%\" identified by \"123321\" with grant option;`. \n\t\t> 授权完成后，刷新下账户权限即可：`flush privileges;`。  \n  \n- Step.05：以 IntelliJ Idea IDE 为参考搭建框架，参考 [1] - [3] 中的方法；\n\t- [1] 中 `全注解方式的 SSH 基础框架` 的框架整合的思想不错，推荐在你搭建框架时参详。\n\t- [2] - [3] 的搭建方法都是 `导 Jar 包形式`，但千万要注意相对应的 Jar 包是否已经下载到本地。\n\t- 当然，推荐 `Maven` 管理项目，即它是添加依赖库的方式配置环境的，下述的内容也是基于 Maven 构建框架。\n\n## 版本信息\n- **基于以下版本，打包的 SSH 框架 ( Maven )**：[SSHFrameComposition.2018.08.15](https://pan.baidu.com/s/11czZlhOzSLNX7gB16t1AtQ)\n\n\t> 这是基于 Maven 构建的 SSH 框架项目，若有错误的地方还望指正。\n\n-  框架版本：\n\t- Struts：2.5.16\n\t- Spring：4.3.x\n\t- Hibernate：5.2.x\n- 其他组件：\n\t- MySQL：5.7.x / SQL Server：2008 R2\n\t- Tomcat：9.0.x\n\t- Maven：3.3.9\n\t- JDK：1.8\n- 构建框架，还需要相关依赖库 ( Jar 包 )，详细请参阅 [IoC 入门案例](#IoC-入门案例)。\n\n\t> 为便于你下载 Jar 包或校对依赖是否齐全，具体地，以下列举了 SSH 框架所需要的依赖库。\n\n| Spring | Struts2 | Hibernate |\n| :---- | :---- | :---- | \n| spring-core | asm | antlr | \n| spring-beans | asm-commons | stax2-api |\n| spring-context | asm-tree | geronimo-jta\\_1.1\\_spec |\n| spring-expression | commons-fileupload | hibernate-commons-annotation |\n| spring-web ( 整合 Web ) | commons-io | hibernate-core |\n| spring-aop ( 整合 Aop ) | commons-lang3 | hibernate-jpa |\n| aopalliance ( 整合 Aop ) | freemarker | jandex |\n| spring-aspect ( 整合 Aop ) | javassist | javassist |\n| aspectjweaver ( 整合 Aop ) | log4j-api | jboss-logging |\n| spring-orm | log4j-core | &nbsp; |\n| spring-tx ( 整合事务 ) | ognl | &nbsp; |\n| spring-jdbc ( 整合 Hibernate ) | struts-core | &nbsp; |\n| c3p0 ( 数据库连接池 ) | &nbsp; | &nbsp; |\n\n|  其他依赖库 ( Jar 包 ) | 备注 |\n| :---- | :---- |\n| junit | Junit 单元测试 |\n| mysql-connector-java | 添加 MySQL 数据库支持 |\n| struts2-spring-plugin | Struts 整合 Spring 插件 |\n| struts2-junit-plugin | 便于浏览项目中所有 action 及其与 Jsp View 的映射 |\n| jstl | JSTL 标签库 |\n| taglibs-standard-impl | 标签库 |\n\n\n\n## 框架初识\n\n### ORM 框架\n- 对象关系映射（Object Relational Mapping，O/R Mapping，ORM）是通过使用描述对象和数据库之间映射的 `元数据`，将面向对象语言程序中的 `对象` 自动 `持久化` 到 `关系数据库` 中。本质上就是将数据从一种形式转换到另外一种形式。 \n- 让 `实体类` 和 `数据库表` 进行一一对应关系 (映射关系)，`实体类属性` 和 `表里面的字段` 对应。操作表对应实体类对象，而不需操作数据库表。\n\n### SSH 框架\nSSH 框架：[Spring](http://spring.io/)、[Struts2](http://struts.apache.org/)、[Hibernate](http://hibernate.org/) \n\n集成 SSH 框架的系统从职责上分为四层：`表示层`、`业务逻辑层`、`数据持久层` 和 `域模块层`，以帮助开发人员在短期内搭建结构清晰、可复用性好、维护方便的 Web 应用程序。其中使用 `Struts` 作为 `系统的整体基础架构`，负责 MVC 的分离，在 Struts 框架的模型部分，控制业务跳转，利用 `Hibernate` 框架对 `持久层` 提供支持，`Spring` 做管理，`管理 Struts 和 Hibernate`。\n    \n具体做法是：用面向对象的分析方法根据需求提出一些模型，将这些模型实现为基本的 Java 对象，然后编写基本的 DAO (Data Access Objects) 接口，并给出 Hibernate 的 DAO 实现，采用 Hibernate 架构实现的 DAO 类来实现 Java 类与数据库之间的转换和访问，最后由 Spring 做管理，管理 Struts 和 Hibernate。\n\n---\n\n#### Struts\n主要是用来做 `表示层`，也就所谓的 `界面`，和用户直接打交道，用来处理用户的请求和请求后返回给用户的模型数据。 Struts 对 Model，View 和 Controller 都提供了对应的组件。\n\n##### Struts2 入门\n\n###### Struts2 概述\n- Struts2 框架应用在 Java EE 三层结果中的 Web 层框架；\n- Struts2 解决的问题：\n\n\t![Struts2解决的问题](/images/illustration/Project/2018/08/J2EE-SSH-SSI-1_6-1.png)\n<center>图 6-1 Struts2 解决的问题</center>\n\n###### Struts2 案例\n\n- 创建 Action：\n\n\t```java\n\t// BaseAction.java\n\t\n\tpublic class BaseAction extends ActionSupport {\n\t    @Override\n\t    // 每次访问 action ，默认执行名称 execute() 方法\n\t    public String execute() throws Exception {\n\t        return NONE;\n\t    }\n\t}\n\t```\n\t\n- 配置 Action 类访问路径：需在 Src 根目录下创建核心配置文件 struts.xml，其名称和位置是固定的。\n\n\t```xml\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<!DOCTYPE struts PUBLIC\n\t    \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\"\n\t    \"http://struts.apache.org/dtds/struts-2.3.dtd\">\n\t\n\t<struts>\n\t    <package name=\"sample\" extends=\"struts-default\" namespace=\"/\">\n\t        <!--\n\t         | Name 属性值填写 action 访问的名称，例如 BaseAciton.action\n\t         | Class 属性值填写目标 Action 的全路径\n\t        -->\n\t        <action name=\"BaseAction\" class=\"cn.kofes.action.BaseAction\">/\n\t            <result name=\"success\">/jsp/success.jsp</result>\n\t        </action>\n\t    </package>\n\t</struts>\n\t```\n\t\n- 配置过滤器：在 web.xml 中添加过滤器\n\t\n\t```xml\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n\t    version=\"4.0\">\n\t\n\t    <!-- 过滤器模块 -->\n\t    <filter>\n\t        <filter-name>struts2</filter-name>\n\t        <filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>\n\t    </filter>\n\t    <filter-mapping>\n\t        <filter-name>struts2</filter-name>\n\t        <url-pattern>/*</url-pattern>\n\t    </filter-mapping>\n\t\n\t    <welcome-file-list>\n\t        <welcome-file>index.jsp</welcome-file>\n\t    </welcome-file-list>\n\t</web-app>\n\t```\n\n###### Struts2  底层执行过程\n\n如图 6-2 所示，为 Struts 底层执行过程图示。\n\n![Struts底层执行过程](/images/illustration/Project/2018/08/J2EE-SSH-SSI-1_6-2.png)\n<center>图 6-2 Struts 底层执行过程</center>\n\n###### Struts2 配置\n\n- Struts 核心配置文件 ( Struts2.5.x 版本 )\n\n\t```xml\n\t<!-- Struts 2.5.x 版本的约束 -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<!DOCTYPE struts PUBLIC\n\t    \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\"\n\t    \"http://struts.apache.org/dtds/struts-2.5.dtd\">\n\t<struts>\n\t    <!-- 表单的编码/乱码问题 -->\n\t    <constant name=\"struts.i18n.encoding\" value=\"UTF-8\" />\n\t    <!-- 指定Struts2处于开发阶段，可以进行调试 -->\n\t    <constant name=\"struts.devMode\" value=\"true\" />\n\t    <constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\" />\n\t\n\t    <!--\n\t     | Name 属性：唯一标识 Package\n\t     | Extends 属性：属性固定的的，即 Package 中配置的类具有 action 功能\n\t     | Namespace 属性：与 action 标签名构成访问路径\n\t    -->\n\t    <package name=\"sample\" namespace=\"/\" extends=\"struts-default\" strict-method-invocation=\"false\">\n\t        <!-- Struts2.5.x 版本特征，提升安全性 -->\n\t        <global-allowed-methods>regex:.*</global-allowed-methods>\n\t\n\t        <!--\n\t         | Name 属性：唯一标识，与 namespace 构成访问访问路径\n\t         | Class 属性：Action 类的全路径\n\t         | Method 属性：除了 execute() 方法，若绑定 Action 类其他方法则用此属性\n\t        -->\n\t        <action name=\"baseAction\" class=\"cn.kofe.action.baseAction\" method=\"login\">\n\t            <!--\n\t             | 根据 Action 类中方法的返回值，配置到不同的路径里面\n\t             | Name 属性：与 Action 类对应的方法的返回值一样\n\t             | Type 属性：配置如何到路径中 ( 转发或者重定向 )，默认值为转发\n\t            -->\n\t            <result name=\"success\">/success.jsp</result>\n\t        </action>\n\t\n\t        <!-- Add actions here -->\n\t\n\t    </package>\n\t</struts>\n\t```\n\n###### Struts2 Action 创建\n\n- 创建普通类，不继承任何类，不实现任何接口；\n\n- ~~创建类，实现 Action 接口~~；\n\n\t```java\n\tpublic class BaseAction implements Action {\n\t    @Override\n\t    public String execute throws Exception {\n\t        return NONE; // SUCCESS、ERROR ( 也可自定义字符串 ) ... \n\t    }\n\t}\n\t```\n- 创建类，继承 ActionSupport；\n\n\t```java\n\tpublic class BaseAction extends ActionSupport {\n\t    @Override\n\t    public String execute throws Exception {\n\t        return NONE; // SUCCESS、ERROR ( 也可自定义字符串 ) ... \n\t    }\n\t    \n\t    // 自定义方法\n\t    public String login() { return SUCCESS; }\n\t}\n\t```\n\n###### Struts2 Action 方法访问\n\n- 使用 action 标签中的 method 属性，在属性里写执行的 action 的方法名称；\n\n\t```xml\n\t<package name=\"sample\" namespace=\"/\" extends=\"struts-default\" strict-method-invocation=\"false\">\n\t    <action name=\"login\" class=\"cn.kofes.action.BaseAction\" method=\"login\" />\n\t</package>\n\t```\n\n- 使用通配符方式实现；\n\n\t```xml\n\t<package name=\"sample\" namespace=\"/\" extends=\"struts-default\" strict-method-invocation=\"false\">\n\t    <!-- 例如，访问路径为 http://192.168.x.x/action_login.action -->\n\t    <action name=\"action_*\" class=\"cn.kofes.action.BaseAction\" method=\"{1}\" />\n\t</package>\n\t```\n\n- 动态访问实现；\n\n\t```xml\n\t <!-- 动态方法访问 -->\n\t<constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\" />\n\t\n\t<!-- strict-method-invocation：是否允许使用通配符 ( 默认开启，不需要关闭 ) -->\n\t<package name=\"sample\" namespace=\"/\" extends=\"struts-default\" strict-method-invocation=\"true\">\n\t    <!-- 还可以限制具体哪些方法可以动态访问 -->\n\t    <global-allowed-methods>regex:.*</global-allowed-methods>\n\t    <action name=\"login\" class=\"cn.kofes.action.BaseAction\" method=\"login\" />\n\t</package>\n\t```\n\n- 常见错误：\n\t- 若 action 方法有返回值，在配置文件中没有配置，会出现无法找到页面的错误 (404)。\n\t- action 的名称，action 方法的返回值常量，规范使用 `驼峰式命名` 定义。\n\n##### Struts2 数据操作\n\n###### 结果页面配置\n- 全局结果页面：若多个 Action，方法的返回值相同，到达页面也是相同，则可使用全局结果页面配置。\n\n\t```xml\n\t<package name=\"sample\" namespace=\"/\" extends=\"struts-default\">\n\t    <global-results>\n\t        <result name=\"success\">/success.jsp</result>\n\t    </global-results>\n\t</package>\n\t```\n\n- 局部结果页面：若配置了全局和局部结果页面，以局部为准。\n\n\t```xml\n\t<package name=\"sample\" namespace=\"/\" extends=\"struts-default\">\n\t    <action name=\"login\" class=\"cn.kofes.action.BaseAction\" method=\"login\" />\n\t</package>\n\t```\n\n- Result 标签 的 Type 属性 (值)：\n\t- `dispatcher`：默认值，转发操作。\n\t- `redirect`：重定向操作。\n\t- `redirectAction`：重定向到 action。\n\t- ~~`chain`：转发到 action ( 缓存问题 )~~。\n\n###### 表单数据操作\n- 先构造一个表单：\n\n\t```html\n\t<!-- login.jsp -->\n\t<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n\t<html>\n\t    <head>\n\t        <title>SSH_FRAME_COMP</title>\n\t    </head>\n    \t    \n\t    <body>\n\t        <form action=\"${pageContext.request.contextPath}/form.action\" method=\"post\">\n\t            Username：<input type=\"text\" name=\"username\" /><br/>\n\t            Age：<input type=\"text\" name=\"age\" /><br/>\n\t            Email：<input type=\"text\" name=\"email\" /><br/>\n\t            Phone：<input type=\"text\" name=\"phone\" /><br/>\n\t        <input type=\"submit\" value=\"Submit\" />\n\t        </form>\n\t    </body>\n\t</html>\n\t\n\t<!-- struts.xml -->\n\t<action name=\"FormOperator\" class=\"cn.kofes.action.FormOperator\" method=\"execute\">\n\t    <!-- 若返回 \"success\"，则重定向到另一个 action，即执行登录 -->\n\t    <result name=\"success\" type=\"redirectAction\">login</result>\n\t</action>\n\t```\n\n- action 获取表单提交数据\n\n\t```java\n\tpublic class FormOperator extends ActionSupport {\n\t\n\t    public String execute() throw Exception { \n\t    \n\t        // Case.01.使用 ActionContext 类获取\n\t        ActionContext context = ActionContext.getContext();\n\t        // key 时表单输入项 Name 的属性值，Value 时输入的值 \n\t        Map<String, Object> map = context.getParameters();\n\t        Set<String> keys = map.keySet();\n\t        for(String key : keys) {\n\t            // 数组形式，考虑有复选框的情况\n\t            Object[] obj = (Object[]) map.get(key);\n\t        }\n\t \t\n\t        // Case.02.使用 ServletActionContext 类获取\n\t        HttpServletRequest request = ServletActionContext.getRequest();\n\t        String username = request.getParamter(\"username\");\n\t        \n\t        rerun NONE;\n\t    }\n\t}\n\t\n\t// Case.03.使用接口注入方式获取\n\tpublic class FormOperator extends ActionSupport implements ServletRequestAware {\n\t\n\t    private HttpServletRequest request;\n\t    \n\t    @Overrride\n\t    public  void setServletRequest(HttpServletRequest request) {\n\t        this.request = request;\n\t    }\n\t    \n\t    public String execute() throw Exception {\n\t        String username = request.getParamter(\"username\");\n\t        return NONE;\n\t    }\n\t}\n\t```\n\t\n- action 操作域对象\n\n\t```java\n\tpublic class FormOperator extends ActionSupport {\n\t\n\t    public String execute() throw Exception { \n\t    \n\t        // 操作域对象\n\t        // Request 域\n\t        HttpServletRequest request = ServletActionContext.getRequest();\n\t        request.setAttribute(\"requestKey\", \"requestValue\");\n\t        \n\t        // Session 域\n\t        HttpSession session = request.getSession();\n\t        session.setAttribute(\"sessionKey\", \"sessionValue\");\n\t        \n\t        // ServletContext 域\n\t        ServletContext context = ServletActionContext.getServletContext();\n\t        context.setAttribute(\"contextKey\", \"contextValue\");\n\t        \n\t        rerun NONE;\n\t    }\n\t}\n\t```\n\n- struts2 提供获取表单数据方式\n\n\t```java\n\t// 原始方式获取表单数据，再封装数据到实体类对象中\n\tUser user = new User();\n\tHttpServletRequest request = ServletActionContext.getRequest();\n\tuser.setUsername( request.getParamter(\"username\") );\n\t\n\t// 属性封装：获取表单数据到属性中  ( Setter 和 Getter 方法补全即可 )\n\t// 在 action 的成员变量位置定义变量 ( 变量名称和表单输入项的 Name 属性值一样 )\n\tprivate String username;\n\tpublic void setUsername(String username) { this.username = username }\n\tpublic String getUsername() { return username; }\n\t// 以此类推...\n\t\n\t// 模型驱动封装\n\t// Step.01. 实现接口 ModelDriven\n\t// Step.02. 实现接口的方法 getModel()，再把创建对象返回\n\t// Step.03. 在 action 里『创建』实体类对象\n\tpublic class FormOperator extends ActionSupport implements ModelDriven<User> {\n\t    private User user = new User();\n\t    @Override\n\t    public User getModel() {\n\t        return user;\n\t    }\n\t    @Override\n\t    public Sring execute() throw EXception {\n\t        return NONE;\n\t    }\n\t}\n\t\n\t// 表达式封装\n\t// Step.01.在 action 中『声明』实体类；\n\t// Step.02.生成实体类变量的 Setter 和 Getter 方法\n\t// Step.03.再表单输入项的 Name 属性值中填写表达式\n\t\n\t// 表达式：<input type=\"text\" name=\"user.username\" />\n\t\n\tpublic class FormOperator extends ActionSupport {\n\t    private User user;\n\t    public void setUser(User user) { this.user = user; }\n\t    public User getUser() { return user; }\n\t    \n\t    @Override\n\t    public Sring execute() throw EXception {\n\t        return NONE;\n\t    }\n\t}\n\t```\n\t\n> 使用模型驱动和属性封装是注意事项：在同一个 action 中，获取表单数据可以是模型驱动合作和属性封装，但不能同时使用二者。`同时使用只会执行模型驱动`。  \n\n- `表达式封装` 和 `模型驱动` 比较：  \n\t- 相同点：使用表达式封装和模型驱动封装都可把数据封装到实体类对象里。\n\t- 不同点：使用模型驱动只能把数据封装到一个实体类对象里。而表达式封装没有限制，即通过表达式封装可把数据封装到多个、不同的实体类对象里面。\n\n- struts2 获取数据封装到集合：\n\t\n\t```xml\n\t<!-- 封装数据到 List 集合 -->\n\t<input type=\"text\" name=\"list[0].username\" />\n\t<input type=\"text\" name=\"list[0].age\" />\n\t<input type=\"text\" name=\"list[1].username\" />\n\t<input type=\"text\" name=\"list[1].age\" />\n\t\n\t<!-- 封装数据到 Map 集合 -->\n\t<input type=\"text\" name=\"map['Lucy'].username\" />\n\t<input type=\"text\" name=\"map['Lucy'].age\" />\n\t<input type=\"text\" name=\"map['Mark'].username\" />\n\t<input type=\"text\" name=\"map['Mark'].age\" />\n\t\n\t\n\t<!-- 在实现类中声明 -->\n\tpublic class FormOperator extends ActionSupport {\n\t    private List<User> list;\n\t    public void setList(List<User> list) { this.list = list; }\n\t    public List<User> list getUser() { return list; }\n\t     \n\t    // private Map<String, User> map;\n\t    // public void setMap(Map<String, User> map) { this.map = map }\n\t    // public Map<String, User> getMap() { return map; }\n\t    \n\t    @Override\n\t    public Sring execute() throw EXception {\n\t        return NONE;\n\t    }\n\t}\n\t```\n\t\n###### 案例实操展示\n- 新建表单操作页面 `form.jsp` 和数据展示页面 `info.jsp`：\n\n\t```html\n\t<!-- form.jsp -->\n\t<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n\t<html>\n\t    <head>\n\t        <title>SSH_FRAME_COMP</title>\n\t    </head>\n\t    <body>\n\t        <form name=\"loginForm\" action=\"${pageContext.request.contextPath}/form.action\" method=\"post\">\n\t            Username：<input type=\"text\" name=\"user.username\"/><br/>\n\t            Age：<input type=\"text\" name=\"user.age\"/><br/>\n\t            Email：<input type=\"text\" name=\"user.email\"/><br/>\n\t            Phone：<input type=\"text\" name=\"user.phone\"/><br/>\n\t            <input type=\"submit\" value=\"Submit\"/>\n\t        </form>\n\t    </body>\n\t</html>\n\t\n\t<!-- info.jsp -->\n\t```\n\t\n- 在 struts.xml 配置文件中添加 action：\n\n\t```xml\n\t<!-- struts.xml -->\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<!DOCTYPE struts PUBLIC\n\t    \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\"\n\t    \"http://struts.apache.org/dtds/struts-2.5.dtd\">\n\t\n\t<struts>\n\t    <!-- 表单的编码/乱码问题 -->\n\t    <constant name=\"struts.i18n.encoding\" value=\"UTF-8\" />\n\t    <!-- 动态方法访问 -->\n\t    <constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\" />\n\t\n\t    <package name=\"sample\" namespace=\"/\" extends=\"struts-default\" strict-method-invocation=\"true\">\n\t        <global-allowed-methods>regex:.*</global-allowed-methods>\n\t        \n\t        <!-- 使用注解创建 FormOperator 对象，直接引用标签值 -->\n\t        <action name=\"form\" class=\"formOperator\" method=\"saveInfo\">\n\t            <result name=\"getinfo\" type=\"redirectAction\">info</result>\n\t        </action>\n\t        \n\t        <!-- 插入数据后加载数据库 -->\n\t        <action name=\"info\" class=\"formOperator\" method=\"getInfo\">\n\t            <result name=\"listinfo\">/jsp/info.jsp</result>\n\t        </action>\n\t        \n\t    </package>\n\t</struts>\n\t```\n\t\n- 在 Action 中实现逻辑处理类：\n\n\t```java\n\t// FormOperator.java\n\t// Action 层：界面交互层\n\t@Controller(value=\"formOperator\")\n\t@Scope(value = \"prototype\")\n\tpublic class FormOperator extends ActionSupport {\n\t    private User user;\n\t    \n\t    // Service 处理业务逻辑\n\t    @Resource(name = \"sampleService\")\n\t    private BaseService service;\n\t    \n\t    @Override\n\t    public Sring execute() throw EXception {\n\t        return NONE;\n\t    }\n\t    \n\t    public String saveInfo() {\n\t        service.saveUserInfo(user);\n\t        return \"info\";\n\t    }\n\t    \n\t    public String getInfo() {\n\t        // 从数据库中加载数据\n\t        return NONE;\n\t    }\n\t}\n\t\n\t// SampleServiceImpl.java\n\t// Servie 层：业务逻辑层\n\t@Service(value = \"sampleService\")\n\t@Transactional\n\tpublic class SampleServiceImpl implements BaseService {\n\t\n\t    @Resource(name = \"sampleDao\")\n\t    private BaseDao dao;\n\t\n\t    @Override\n\t    public void saveUserInfo(User user) {\n\t        if( null != dao.queryOneTuple(user.getClass(), user.getUid()) ) {\n\t            dao.updateOneTuple(user);\n\t        } else {\n\t            dao.insertOneTuple(user);\n\t        }\n\t    }\n\t}\n\t\n\t// SampleDaoImpl.java\n\t// Dao 层：数据持久层\n\t@Repository(value = \"sampleDao\")\n\tpublic class SampleDaoImpl implements BaseDao {\n\t\n\t    @Resource(name = \"hibernateTemplate\")\n\t    private HibernateTemplate hibernateTemplate;\n\t\n\t    @Override\n\t    public void insertOneTuple(Object entity) {\n\t        hibernateTemplate.save(entity);\n\t    }\n\t    \n\t    @Override\n\t    public void updateOneTuple(Object entity) {\n\t        hibernateTemplate.update(entity);\n\t    }\n\t    \n\t    @Override\n\t    public <T> T queryOneTuple(Class<T> entityClass, Serializable id) {\n\t        T temporary = null;\n\t        if (null != entityClass) {\n\t            temporary = hibernateTemplate.get(entityClass, id);\n\t        }\n\t        return temporary;\n\t    }\n\t}\n\t```\n\n##### Struts2 值栈\n\n###### 值栈概念\n- 什么是值栈：\n\t- Struts 里本身提供一种存储机制，类似于 `域对象`。即值栈，可存储数据也可读取数据。\n\t- Striuts 把数据放到值栈里，在 Jsp 页面中获取到值栈数据。\n\n- Ognl：Web 阶段，EL 表达在 Jsp 中获取域对象中的值。而 Ognl 也是一种表达式。\n\t- Struts 中操作值栈数据，和 `Struts 标签` 一起使用、操作值栈。\n\t- Ognl 不是 Struts 的一部分，可以单独使用。\n- Struts 标签：虽然标签封装了样式，方便操作，但故样式上会有限制。\n\n\t```html\n\t<!-- 在对应的 jsp 页面中引入标签库  -->\n\t<%@ taglib uri=\"/struts-tags\" prefix=\"s\" %>\n\t\n\t<!-- 查看值栈结构和数据 -->\n\t<s:debug />\n\t\n\t<!-- 使用 Ognl + Struts 标签，实现计算字符串长度 -->\n\t<s:property value=\"'str'.length()\" />\n\t\n\t<!-- html 表单标签\n\t | 1) form：action、method、enctype\n\t | 2) 输入项：大部分在 input 中封装 type 值实现各种输入项，例如：\n\t |    text，普通文本输入项\n\t |    password，密码输入项\n\t |    radio，单选输入项\n\t |    checkbox，复选输入项\n\t |    file，文件上传项\n\t |    hidden，隐藏项\n\t |    button，普通按钮\n\t |    submit，提交按钮\n\t |    image，图片提交\n\t |    reset，重置\n\t | 3) select：下拉输入项\n\t | 4) textarea：文本域\n\t-->\n\t<s:form name=\"signupForm\" action=\"form.action' method=\"POST\">\n\t    <!-- 普通输入项 -->\n\t    <s:textfield name=\"username\" label=\"username\" />\n\t    <!-- 密码输入项 -->\n\t    <s:password name=\"password\" label=\"password\" />\n\t    <!-- 单选项 -->\n\t    <s:radio list=\"#{'male':'男', 'female':'女'}\" name=\"gender\" label=\"gender\" />\n\t    <!-- 多选项 -->\n\t    <s:checkboxlist list=\"{'sleep', 'eat'}\" name=\"interest\" label=\"interest\" />\n\t    <!-- 下拉输入框 -->\n\t    <s:select list=\"{'str1', 'str2', 'str3'}\" name=\"sample\" label=\"sample\" />\n\t    <!-- 文件上传项 -->\n\t    <s:file name=\"file\" label=\"file\" />\n\t    <!-- 文本域 -->\n\t    <s:textarea row=\"10\" cols=\"10\" name=\"description\" value=\"description\" />\n\t    <!--  隐藏项 -->\n\t    <s:hidden name=\"hiddenContent\" value=\"hidden content is here\" />\n\t    <!-- 提交按钮 -->\n\t    <s:submit value=\"Submit\" />\n\t</s:form>\n\t\n\t\n\t```\n- Servlet 和 Action 区别：\n\t- Servlet：默认在第一次访问时创建，仅创建一次。( 单实例 )\n\t- Action：访问时候创建，且每次访问时都会创建 action 对象。( 多实例 )\n\n\n###### 获取值栈对象\n- 使用 ActionContext 类的方法获取值栈对象\n\n\t```java\n\t\n\tpublic class FormOperator extends ActionSupport {\n\t    private User user;\n\t    \n\t    @Override\n\t    public Sring execute() throw EXception {\n\t        ActionContext context = ActionContext().getContext();\n\t        ValueStack stack = context.getValueStack();\n\t        return NONE;\n\t    }\n\t}\t\n\t```\n\n###### 值栈内部结构\n值栈主要分为两部分：\n\n- Root：List 集合 `Class Compoundroot extends ArrayList { ... }`\n\t\n- Context：Map 集合 `Class Compoundroot extends Object implements Map { ... }`\n\n\t![Context 存储的对象引用](/images/illustration/Project/2018/08/J2EE-SSH-SSI-1_6-3.png)\n\t<center>图 6-3 Context 存储的对象引用</center>\n\n###### 向值栈存数据\n\n> 结合 `<s:debug />` 标签，可浏览值栈的传值情况。\n\n向值栈存数据的多种方式：\n\n- 获取值栈对象，调用值栈对象的 set 方法。\n- 获取值栈对象，调用值栈对象的 push 方法。\n- 在 action 定义变量，生产变量的 get 方法。\n\t\n\t```java\n\t// 获取值栈对象\n\tActionContext context = ActionContext.getContext();\n\tValueStack stack = context.getValueStack();\n\t\n\t// 向值栈放字符串\n\t// Case.01\n\tstack.set(\"username\", \"AttrSet\");\n\t// Case.02\n\tstack.push(\"PushMethod\");\n\t// Case.03.声明变量，生成 Getter 方法\n\tprivate String str;\n\tpublic String getStr() { return str; }\n\tstr = \"SetStrAttr\";\n\t\n\t// 向值栈放对象\n\tprivate User user;\n\tpublic User getUser() { return user; }\n\t// user.setXXX();\n\t\n\t// 向值栈放 List 集合\n\tprivate List<User> list;\n\tpublic List<User> getList() { return list; }\n\tlist = getAllUserInfo(User.class);\n\t```\n\n###### 从值栈取数据\n\n- 从值栈获取数据\n\n\t```html\n\t<!-- 在对应的 jsp 页面中引入 struts 标签库  -->\n\t<%@ taglib uri=\"/struts-tags\" prefix=\"s\" %>\n\t\n\t<!-- 在 Jsp 页面中获取属性值 -->\n\t<s:property value=\"str\" />\n\t\n\t<!-- Jsp 页面中获取对象的值 -->\n\t<s:property value=\"user.username\" />\n\t<s:property value=\"user.email\" />\n\t\n\t<!-- Jsp 页面中获取 List 集合：方式 1 -->\n\t<s:iterator value=\"list\">\n\t    <s:property value=\"username\" />\n\t    <s:property value=\"age\" />\n\t    <s:property value=\"email\" />\n\t    <s:property value=\"phone\" />\n\t</s:iterator>\n\t\n\t<!-- Jsp 页面中获取 List 集合：方式 2 -->\n\t<s:iterator value=\"list\" var=\"user\">\n\t    <s:property value=\"#user.username\" />\n\t    <s:property value=\"#user.age\" />\n\t    <s:property value=\"#user.email\" />\n\t    <s:property value=\"#user.phone\" />\n\t</s:iterator>\n\t```\n\n---\n\n#### Spring\n`业务逻辑层`，是一个轻量级的控制反转 (IoC) 和面向切面 (AOP) 的容器框架。\n\n#####  Spring 概念\n- 一站式轻量级开源框架，在 Java EE 三层结构中，每一层提供不同的解决技术。\n\t- `Web 层`：Spring MVC\n\t- `Service 层`：IoC\n\t- `DAO 层`：Spring 的 JdbcTemplate\n- AOP：`面向切面编程`，扩展功能不是通过修改源码实现的，即通过 `动态代理技术`，把各类通知 / 增强织入到它所约定的流程当中。事实上，是通过引入其他类的方法来实现的。\n- IoC：`控制反转`，例如：对象的创建不通过 new 方式实现，而是通过 Spring 配置创建类对象。\n\n##### Spring IoC\n控制反转 (IoC)，是一种通过描述 (在 Java 中可以是 XML 或者注解) 并通过第三方去产生或获取特定对象的方式。\n\n###### IoC 底层原理\n- 使用技术：\n\t- XML 配置文件；\n\t- Dom4j 解析 XML；\n\t- 工厂设计模式；\n\t- 类的反射.\n- 代码实现：\n\t- 创建 XML 配置文件，配置要创建对象类。\n\t- 创建工厂类，使用 Dom4j 解析配置文件，通过反射创建类对象。\n\t\n###### IoC 入门案例\n- Maven 中添加依赖库 ( 对应导入 Jar 包 )：\n\n\t> 下载 Jar 包：到 [Maven Pository](http://mvnrepository.com/) 中搜索目标 Jar 包，在具体页面中的 Files 一栏可下载。例如：[log4j-core.2.11.0](http://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core/2.11.0)\n\n\t```xml\n\t<!-- porm.xml -->\n\t\n\t<!-- Version Control of Jar Dependency  -->\n\t\n\t<properties>\n\t    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n\t    <spring.version>4.3.18.RELEASE</spring.version>\n\t    <hibernate.version>5.2.17.Final</hibernate.version>\n\t    <struts2.version>2.5.16</struts2.version>\n\t</properties>\n\t\n\t<!-- Foundation of SSH ( Spring、Struts 2、Hibernate ) -->\n\t\n\t<dependencies>\n\t\n\t    <!-- spring -->\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-beans</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-core</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-context</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-expression</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n        \n\t    <!-- 以下依赖包为下文所需要的，为方便起见这里统一配置 -->\n\t\n\t    <!-- struts2 -->\n\t    <dependency>\n\t        <groupId>org.apache.struts</groupId>\n\t        <artifactId>struts2-core</artifactId>\n\t        <version>${struts2.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.ow2.asm</groupId>\n\t        <artifactId>asm</artifactId>\n\t        <version>5.2</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.ow2.asm</groupId>\n\t        <artifactId>asm-commons</artifactId>\n\t        <version>5.2</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.ow2.asm</groupId>\n\t        <artifactId>asm-tree</artifactId>\n\t        <version>5.2</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>commons-fileupload</groupId>\n\t        <artifactId>commons-fileupload</artifactId>\n\t        <version>1.3.3</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>commons-io</groupId>\n\t        <artifactId>commons-io</artifactId>\n\t        <version>2.5</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.apache.commons</groupId>\n\t        <artifactId>commons-lang3</artifactId>\n\t        <version>3.6</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.freemarker</groupId>\n\t        <artifactId>freemarker</artifactId>\n\t        <version>2.3.23</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.javassist</groupId>\n\t        <artifactId>javassist</artifactId>\n\t        <version>3.22.0-GA</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>ognl</groupId>\n\t        <artifactId>ognl</artifactId>\n\t        <version>3.1.15</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>javax</groupId>\n\t        <artifactId>javaee-api</artifactId>\n\t        <version>8.0</version>\n\t        <scope>provided</scope>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>javax.servlet</groupId>\n\t        <artifactId>jstl</artifactId>\n\t        <version>1.2</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.apache.taglibs</groupId>\n\t        <artifactId>taglibs-standard-impl</artifactId>\n\t        <version>1.2.5</version>\n\t    </dependency>\n\t\n\t    <!-- config-browser-plugin 插件方便浏览项目中的所有 Action 及其与 Jsp View 的映射 -->\n\t    <dependency>\n\t        <groupId>org.apache.struts</groupId>\n\t        <artifactId>struts2-junit-plugin</artifactId>\n\t        <version>${struts2.version}</version>\n\t        <scope>test</scope>\n\t    </dependency>\n\t\n\t    <!-- Hibernate -->\n\t    <dependency>\n\t        <groupId>org.hibernate</groupId>\n\t        <artifactId>hibernate-core</artifactId>\n\t        <version>${hibernate.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.hibernate.common</groupId>\n\t        <artifactId>hibernate-commons-annotations</artifactId>\n\t        <version>5.0.4.Final</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.hibernate.javax.persistence</groupId>\n\t        <artifactId>hibernate-jpa-2.1-api</artifactId>\n\t        <version>1.0.2.Final</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.jboss</groupId>\n\t        <artifactId>jandex</artifactId>\n\t        <version>2.0.5.Final</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.jboss.logging</groupId>\n\t        <artifactId>jboss-logging</artifactId>\n\t        <version>3.3.2.Final</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>antlr</groupId>\n\t        <artifactId>antlr</artifactId>\n\t        <version>2.7.7</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.codehaus.woodstox</groupId>\n\t        <artifactId>stax2-api</artifactId>\n\t        <version>3.1.4</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.apache.geronimo.specs</groupId>\n\t        <artifactId>geronimo-jta_1.1_spec</artifactId>\n\t        <version>1.1.1</version>\n\t    </dependency>\n\t\n\t    <!-- Combining with SSH ( Spring、Struts 2、Hibernate ) framework -->\n\t\n\t    <!-- Spring 整合 Hibernate 和事务 -->\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-jdbc</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-orm</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-tx</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t\n\t    <!-- Spring 整合 AOP -->\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-aop</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-aspects</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>aopalliance</groupId>\n\t        <artifactId>aopalliance</artifactId>\n\t        <version>1.0</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.aspectj</groupId>\n\t        <artifactId>aspectjweaver</artifactId>\n\t        <version>1.9.1</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>cglib</groupId>\n\t        <artifactId>cglib-nodep</artifactId>\n\t        <version>3.2.7</version>\n\t    </dependency>\n\t\n\t    <!-- Spring 整合 Web -->\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-web</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t\n\t    <!-- Sturts 2 整合 Spring 框架 -->\n\t    <dependency>\n\t        <groupId>org.apache.struts</groupId>\n\t        <artifactId>struts2-spring-plugin</artifactId>\n\t        <version>${struts2.version}</version>\n\t    </dependency>\n\t\n\t    <!-- Others -->\n\t\n\t    <!-- 添加对 MySQL 数据库的支持 -->\n\t    <dependency>\n\t        <groupId>mysql</groupId>\n\t        <artifactId>mysql-connector-java</artifactId>\n\t        <version>6.0.6</version>\n\t    </dependency>\n\t\n\t    <!-- 添加对数据源的支持 -->\n\t    <!-- https://mvnrepository.com/artifact/com.mchange/c3p0 -->\n\t    <dependency>\n\t        <groupId>com.mchange</groupId>\n\t        <artifactId>c3p0</artifactId>\n\t        <version>0.9.5.2</version>\n\t    </dependency>\n\t\n\t    <!-- c3p0数据库连接池的辅助包 -->\n\t    <dependency>\n\t        <groupId>com.mchange</groupId>\n\t        <artifactId>mchange-commons-java</artifactId>\n\t        <version>0.2.15</version>\n\t    </dependency>\n\t\n\t    <!-- 日志系统 -->\n\t    <dependency>\n\t        <groupId>org.apache.logging.log4j</groupId>\n\t        <artifactId>log4j-core</artifactId>\n\t        <version>2.10.0</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.apache.logging.log4j</groupId>\n\t        <artifactId>log4j-api</artifactId>\n\t        <version>2.10.0</version>\n\t    </dependency>\n\t\n\t    <!-- Junit -->\n\t    <dependency>\n\t        <groupId>junit</groupId>\n\t        <artifactId>junit</artifactId>\n\t        <version>4.12</version>\n\t        <scope>compile</scope>\n\t    </dependency>\n\t\n    </dependencies>\n\t```\n\t\n- 创建 Spring 配置文件：在 Src 目录下 (建议)，创建 Spring 核心配置文件 applicationContext.xml。\n\t\n\t```xml\n\t<!-- applicationContext.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xsi:schemaLocation=\"\n\t    http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd>\n\t    <bean id=\"operator\" class=\"cn.entity.UserOperator\"></bean>\n\t</beans>\n\t```\n\n- 再配置创建类，对象创建 (方便演示，以单元测试形式呈现)：\n\n\t```java\n\t// 单元测试类\n\tpublic class IoCTest() {\n\t    @Test\n\t    public void testUser() {\n\t        // Step.01.加载 Spring 配置文件\n\t        ApplicationContext context  = \n\t            new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t            \n\t        // Step.02. 得到配置创建的对象\n\t        UserOperator operator = \n\t            (UserOperator) context.getBean(\"operator\");\n\t    }\n\t}\n\t```\n\n##### Spring Bean 管理 (XML)\n\n###### Bean 标签常用属性\n- ID 属性：Bean 标签的名称，要求只含数字和大小写英文字母。\n- Class 属性：常见对象所在类的全路径。\n- Name 属性：功能和 ID 属性一样，Name 属性可包含特殊字符值。\n- Scope 属性：\n\t- `singleton`：单例的 ( 默认值 )。\n\t- `prototype`：多例的。\n\n###### Bean 实例化的方式\n- 使用类的无参数构造创建对象\n\n\t```java\t\n\tpublic class UserOperator {\n\t   public UserOperator() { }\n\t}\n\t```\n\n- 使用静态工厂创建对象\n\n\t```java\n\tpublic class UserOperatorFactory {\n\t    public static UserOperator getOperator() {\n\t        String className = \"classValue\"; // cn.entity.UserOperator\n\t        Class clz = Class.forName(className);\n\t        return clz.newInstance();\n\t    }\n\t}\n\t```\n\t\n- 上述实例化方法在 applicationContext.xml 中的配置：\n\n\t```xml\n\t<!-- 无参数构造创建对象 -->\n\t<bean id=\"operator\" class=\"cn.kofes.entity.UserOperator\" scope=\"singleton\"></bean>\n   \n\t<!-- 静态工厂创建对象 -->\n\t<bean id=\"operator\" class=\"cn.kofes.entity.UserOperatorFactory\" factory-method=\"getOperator\"></bean>\n    \n\t```\n\n###### 属性注入方式\n- Set() 方法注入\n\n\t```java\n\tpublic class UserOperator {\n\t    private String operationType;\n\t    public void setUsername(String operationType) {\n\t        this.operationType = operationType;\n\t    }\n\t}\n\t```\n\n- 有参数构造注入\n\n\t```java\n\tpublic class UserOperator {\n\t    private String operationType;\n\t    public UserOperator(String operationType) {\n\t        this.operationType = operationType;\n\t    }\n\t}\n\t```\n\t\n- 注入 `对象属性` 类型：\n\n\t```java\n\tpublic class UserOperator {\n\t\n    private User user;\n    \n    public void setUser(User user) {\n        this.user = user;\n    }\n    \n\t    @Test\n\t    public void operatorTest() {\n\t        ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t        UserOperator operator = (UserOperator) context.getBean(\"operator\");\n\t        // TODO\n\t    }\n\t}\n\t```\n\t\n- 注入 `复杂类型` 属性：\n\t- 数组\n\t- List 集合\n\t- Map 集合\n\t- Properties 类型\n\n\t```java\n\tpublic class UserOperatorXML {\n\t    private String arrs;\t\t// 数组\n\t    private List<String> list;\t\t// List 集合\n\t    private Map<String, String> map;\t// Map 集合\n\t    private Properties properties;\t// Properties 类型\n\t    \n\t    // Setter() 方法此处省略...\n\t    \n\t    @Test\n\t    public void operatorTest() {\n\t        ApplicationContext context = \n\t        \tnew ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t        UserOperatorXML operator =\n\t        \t (UserOperatorXML) context.getBean(\"operator\");\n\t        // TODO\n\t    }\n\t}\n\t```\n\t\n- 上述 `注入方法` 在 applicationContext.xml 中的配置：\n\n\t```xml\n\t<!-- -- 有参数构造注入属性 -- -->\n\t<bean id=\"operator\" class=\"cn.kofes.entity.UserOperatorXML\">\n\t    <constructor-arg name=\"operationType\" value=\"modify\" />\n\t</bean>\n    \n\t<!-- -- Set 方法注入属性 -- -->\n\t<bean id=\"operator\" class=\"cn.kofes.entity.UserOperatorXML\">\n\t    <property name=\"operationType\" value=\"modify\" />\n\t</bean>\n\t\n\t<!-- -- 注入 对象属性 类型 -- -->\n\t<bean id=\"user\" class=\"cn.kofes.entity.User\"></bean>\n\t\n\t<bean id=\"operator\" class=\"cn.kofes.entity.UserOperatorXML\">\n\t    <!--\n\t     | Name 属性值：类里面的定义属性的名称\n\t     | Ref 属性：定义属性在 Bean 标签中的 ID 值\n\t    -->\n\t    <property name=\"user\" ref=\"user\" />\n\t</bean>\n\t\n\t\n\t<!-- -- 注入 复杂类型 属性 -- -->\n\t<bean id=\"complex\" class=\"cn.kofes.entity.UserOperatorXML\">\n\t    <!-- 数组、List 集合适用 -->\n\t    <property name=\"arrs\">\n\t        <list>\n\t            <value>Arrs0</value>\n\t            <value>Arrs1</value>\n\t            <value>Arrs2</value>\n\t        </list>\n\t    </property>\n\t\n\t    <!-- Map 集合 -->\n\t    <property name=\"map\">\n\t        <map>\n\t            <entry key=\"seq1\" value=\"str1\" />\n\t            <entry key=\"seq2\" value=\"str2\" />\n\t            <entry key=\"seq3\" value=\"str3\" />\n\t        </map>\n\t    </property>\n\t\n\t    <!-- Properties：例如我们要配置数据库 -->\n\t    <property name=\"properties\">\n\t        <props>\n\t            <prop key=\"driverclass\">com.mysql.jdbc.Driver</prop>\n\t            <prop key=\"username\">root</prop>\n\t            <prop key=\"password\">123456</prop>\n\t        </props>\n\t    </property>\n\t</bean>\n\t```\n\t\n###### Spring DI\nIoC 与 DI 的区别\n\n- `IoC`：`控制反转`，把对象创建交给 Spring 进行配置。\n- `DI`：`依赖注入`，向类中的属性设置属性值。\n\t\n\t> 关系：依赖注入不能单独存在，需在 IoC 基础之上完成操作。\n\t\n##### Spring Bean 管理 (注解)\n- 注解格式：`@注解名称(value=\"属性值\")` 或者 `@注解名称(\"属性值\")` \n- `@Component(\"user\")` 相当于 `<bean id=\"user\" class=\"\" />`，其三个衍生注解为：\n\t- @Controller：Web 层，相当于 Struts 中的 Action 层。\n\t- @Service：业务层 ，业务逻辑处理。\n\t- @Repository：持久层，标注数据访问组件，即 DAO 组件。\n\n\t> 功能目前来说是一致的，即创建对象。\n\t\n- `@Scope(\"prototype\")` 或 `@Scope(\"singleton\")`：即配置的对象是单实例还是多实例。\n\n\t```java\n\t@Component(\"BaseAction\")\n\t@Scope(\"prototype\")\n\tpublic class BaseAction { ... }\n\t```\n\n###### 基本内容\n- 使用注解创建对象\n- 使用注解注入对象\n- xml 和注解方式混合使用\n\n###### 小试牛刀\n- 创建类和方法\n\n\t```java\n\tpublic class User { /* 省略实体类的属性 */ }\n\tpublic class Customer { /* 省略实体类的属性 */ }\n\tpublic class Firm { /* 省略实体类的属性 */ }\n\t```\n\n- 创建 Spring 配置文件，并引入约束 (在上述 applicationContext.xml 中追加)\n\t\n\t```xml\n\t<!-- applicationContext.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xsi:schemaLocation=\"\n\t    http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n\t    http://www.springframework.org/schema/context\n\t    http://www.springframework.org/schema/context/spring-context-2.5.xsd\">\n\t    \n\t    <!-- 注解扫描：扫描属性上面的注解 -->\n\t    <context:annotation-config/>\n\t    \n\t    <!-- \n\t     | 注解扫描：到包里扫描类、方法、属性上面的注解，\n\t     | 即使用 Annotation 自动注册 Bean\n\t    -->\n\t    <context:component-scan base-package=\"cn.kofes\"/>\n\t    <context:component-scan base-package=\"cn.kofes.entity\"/>\n\t</beans>\n\t```\n\t\n- 注解中创建对象\n\n\t```java\n\t// 此方式相当于 <bean id=\"user\" class=\"cn.kofes.entity.User\" />\n\t\n\t@Component(value=\"user\")  \n\tpublic class User { \n\t    // 省略实体类的属性...\n\t}\n\n\tpublic class UserOperatorAnn {\n\t    private User user;\n\n\t    @Test\n\t    public void operatorTest() {\n\t        ApplicationContext context = \n\t        \tnew ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t        System.out.println(user);\t // 直接调用 user 对象\n\t    }\n\t}\n\t```\n\n- 注解注入属性\n\n\t```java\n\t// 实体操作类\n\tpublic class UserOperatorAnn {\n\t\n\t    // 相当于 Set 方法注入属性：\n\t    // @Autowired 或者 @Resource(name = \"user\") \n\t    \n\t    @Autowired\t\n\t    private User user;\n\t\n\t    @Test\n\t    public void operatorTest() {\n\t        ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t        System.out.println(user);\t\n\t        System.out.println(customer);\t\n\t        System.out.println(firm);\t\n\t    }\n\t}\n\t```\n\t\n- XML 配置文件和注解混合使用\n\t- 创建对象操作使用 XML 配置文件方式实现；\n\t- 注入属性的操作使用注解方式实现.\n\n\t```java\n\t/* Start：applicationContext.xml */\n\t\n\t<bean id=\"user\" class=\"cn.kofes.entity.User\" />\n\t<bean id=\"customer\" class=\"cn.kofes.entity.Customer\" />\n\t<bean id=\"firm\" class=\"cn.kofes.entity.Firm\" />\n\t\n\t/* End：applicationContext.xml */\n\t\n\tpublic class UserOperatorAnn {\t\n\t    // 注解方式注入属性\n\t    @Resource(name = \"user\") \n\t    private User user;\n\t    @Resource(name = \"customer\") \n\t    private Customer customer;\n\t    @Resource(name = \"firm\") \n\t    private Firm firm;\n\t\n\t    @Test\n\t    public void operatorTest() {\n\t        ApplicationContext context = \n\t        \tnew ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t        System.out.println(user);\t\n\t        System.out.println(customer);\t\n\t        System.out.println(firm);\t\n\t    }\n\t}\n\t```\n\n##### Spring AOP\n\n###### AOP 概述\n面向切面编程 (Aspect Oriented Programing，AOP)，扩展功能不通过修改代码实现。AOP 采取 `横向抽取机制` 取代传统 `纵向继承体系` 重复性代码。\n\n- 纵向继承体系：通过继承获得父类的功能 (方法)。\n- 横向抽取机制：动态代理方式。\n\t- 针对有接口的情况，使用 JDK 动态代理。\n\t- 针对没有接口情况，使用 Cglib 动态代理。\n\n\t```java\n\tpublic interface Dao {\n\t    public void add();\n\t}\n\t\n\tpublic class DaoImpl implements Dao {\n\t    public void add() {\n\t        // 具体逻辑\n\t    }\n\t}\n\t```\n\n######  AOP 相关术语\n\n便于理解，引入实体类进行说明：\n\n```java\npublic class User {\n    public void add() {}\n    public void update() {}\n    public void delete() {}\n    public void findAll() {}\n}\n```\n\n- 连接点 (Join Point)：指那些被拦截到的点，在 Spring 这些点指的是方法，因 Spring 只支持方法类型的连接点。\n\n\t> 类中有哪些方法可被增强，这些方法称为连接点。\n\n- `切入点 (Pointcut)`：指我们要对哪些 `Join Point` 进行拦截的定义。\n\n\t> 类中有很多方法被增强，例如实际操作中，只是增强了类中的 add() 和 update() 方法，即称为切入点。\n\t\n- 引介 (Introduction)：一种特殊的通知在不修改类代码的前提下， Introduction 可为类动态地添加一些方法或 Field。\n\n- `通知/增强 (Advice)`：指拦截到 `Join Point` 之后要做的事情就是通知。通知分为前置通知、后置通知、异常通知、最终通知、环绕通知 (切面要完成的功能)。\n\n\t> 增强的逻辑称为增强，例如扩展日志功能，这个日志功能称为增强。  \n\t> 前置通知，在方法之前执行；后置通知，在方法之后执行；  \n\t> 异常通知，方法出现异常；最终通知，在后置之后执行；  \n\t> 环绕通知，在方法之前和之后执行.  \n\n- 目标对象 (Target)：代理的目标对象 (要增强的类)。\n\n- 织入 (Weaving)：把增强应用到目标的过程，即把 Advice 应用到 Target 的过程。\n\n- `切面 (Aspect)`：切入点和通知 (引介) 的结合。\n\n\t> 把增强应用到具体方法上，此过程称为切面。例如把日志功能写进 add() 方法中。\n\t\n- 代理 (Proxy)：一个类被 AOP 织入增强后，产生一个结果代理类。\n\n###### Spring AOP 操作\n\n> (1) 基于 AspectJ 的 Spring AOP 操作。\n\nASpectJ：面向切面的框架，其扩展了 Java 语言。AspectJ 定义了 AOP 语法，故它有一个专门的编译器来生成遵守 Java 字节编码规范的 Class 文件。 \n\nAspectJ 并不是 Spring 一部分，和 Spring 一起使用进行 AOP 操作。\n\n使用 AspectJ 实现 AOP 有两种方式：1) 基于 AspectJ 的 XML 配置；2) 基于 AspectJ 的注解方式。\n\n> (2) 操作基本流程 ( XML 方式 )：\n\n- 使用表达式配置切入点\n\t- execution( <访问修饰符>?<返回类型><方法名>(<参数>)(异常) )\n\n\t> execution( \\* cn.kofes.UserOpertor.add(..) )  -- UserOperator 类中 add() 方法增强\n\t> execution( \\* cn.kofes.UserOperator.\\*(..) )  -- UserOperator 类中所有方法增强\n\t> execution( \\* \\*.\\*(..) )  -- 所有类中所有方法增强  \n\t> execution( \\* save\\*(..) ) -- 所有 save 开头的方法增强\n\t\n- 代码实现\n\n\t```java\n\t// strengthenUserOperator.java\n\tpublic class strengthenUserOperator {\n\n\t    public strengthenUserOperator() { }\n\n\t    /**\n\t     * This's an aspect inserting to the method() the front.\n\t     */\n\t    public void listBeforeOperatorType() {\n\t        System.out.println(\"Inserting to the method() the front.\");\n\t    }\n\n\t    /**\n\t     * This's an aspect inserting to the method() the front and latter.\n\t     * @param proceedingJoinPoint 执行被增强的方法\n\t     * @throws Throwable\n\t     */\n\t    public void listArroundOperatorType(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n\t        System.out.println(\"Inserting to the method() the front.\");\n\t        proceedingJoinPoint.proceed();\n\t        System.out.println(\"Inserting to the method() the latter.\");\n\t    }\n\t}\n\t\n\t// UserOperatorXML.java\n\tpublic class UserOperatorXML {\n\n\t    private User user;\n\n\t    public void setUser(User user) { this.user = user; }\n\n\t    public User getUser() { return user; }\n\n\t    @Test\n\t    public void operatorTest() {\n\t        ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t        UserOperatorXML operator = (UserOperatorXML) context.getBean(\"operator\");\n\t        // 会在用户信息之前输出 “前置增强” 的信息。\n\t        System.out.println( operator.getUser() );\n\t    }\n\t}\n\t```\n\n- 创建 Spring 配置文件，并引入约束 (在上述 applicationContext.xml 中追加)\n\t\n\t```xml\n\t<!-- applicationContext.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n\t    xsi:schemaLocation=\"\n\t    http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n\t    http://www.springframework.org/schema/context\n\t    http://www.springframework.org/schema/context/spring-context-2.5.xsd\n\t    http://www.springframework.org/schema/aop\n\t    http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\">\n\t    \n\t    <!-- 无参数构造创建对象 -->\n\t    <bean id=\"operator\" class=\"cn.kofes.entity.UserOperatorXML\" />\n\t    <bean id=\"strengthenoperator\" class=\"cn.kofes.entity.strengthenUserOperator\" />\n\t    \n\t    <!-- 配置 AOP 操作 -->\n\t    <aop:config>\n\t        <!-- 配置切入点：匹配 UserOperator 类中所有方法 -->\n\t        <aop:pointcut id=\"pointcutA\" expression=\"execution( * cn.kofes.UserOperatorXML.*(..))\" />\n\t        <!-- 配置切面：把增强用到方法上面 -->\n\t        <aop:aspect ref=\"strengthenoperator\">\n\t            <!-- 配置增强类型\n\t             | Aop：增强类型有 before、after、arroud 等\n\t             | Method：增强类里面使用哪个方法作为前置\n\t            -->\n\t            <aop:before method=\"listAllOperatorType\" pointcut-ref=\"pointcutA\" />\n\t        </aop:aspect>\n\t    </aop:config>\n\t    \n\t</beans>\n\t```\n\t\n> (3) 操作基本流程 ( 注解方式 )：\n\n- 创建 Spring 配置文件 (在上述 applicationContext.xml 中追加)，XML 配置创建对象，并开启 AOP 操作：\n\n\t```xml\n\t<!-- 无参数构造创建对象 -->\n\t<bean id=\"strengthenoperator\" class=\"cn.kofes.entity.strengthenUserOperator\" />\n\t\n\t<!-- 开启 AOP 操作 -->\n\t<aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n\t```\n\t\n- 在增强类上面使用注解完成 AOP 操作：\n\n\t```java\n\t// strengthenUserOperator.java\n\t@Aspect\n\tpublic class strengthenUserOperator {\n\t\n\t    public strengthenUserOperator() { }\n\t\n\t    /**\n\t     * This's an aspect inserting to the method() the front.\n\t     */\n\t    public void listBeforeOperatorType() {\n\t        System.out.println(\"Inserting to the method() the front.\");\n\t    }\n\t\n\t    /**\n\t     * This's an aspect inserting to the method() the front and latter.\n\t     * @param proceedingJoinPoint 执行被增强的方法\n\t     * @throws Throwable\n\t     */\n\t    @Around(value=\"execution( * cn.kofes.entity.UserOperatorXML.*(..) )\")\n\t    public void listArroundOperatorType(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n\t        System.out.println(\"Inserting to the method() the front.\");\n\t        proceedingJoinPoint.proceed();\n\t        System.out.println(\"Inserting to the method() the latter.\");\n\t    }\n\t}\n\t```\n\n##### Spring 整合 Web 项目\n`诉求`：在 Spring 运作中，首先加载 Spring 核心配置文件，再创建对象。而创建对象可通过 New 的方式创建，但效率太低，则我们可以把加载配置文件和创建对象过程，在服务器启动时完成。\n\n###### 问题引入\n- Action 调用 Service，Service 调用 Dao。而每次 Action 时都会加载 Spring 配置文件，影响性能。\n\n###### 实现原理\n- ServletContext 对象\n- 监听器 (观察者模式)\n\n###### 操作简叙\n- 在服务器启动时，为每个项目创建一 ServletContext 对象；\n- 在 ServletContext 对象创建时，使用监听器监听 ServletContext 对象在什么时创建；\n- 监听到 ServletContext 对象创建时，加载 Spring 配置文件，把配置文件配对象创建；\n- 把创建的对象放置 ServletContext 域对象里；\n- 到 ServletContext 域中，通过 getAttribute() 方法获取对象。\n\n###### 具体实现\n- 在 `web.xml` 配置文件中添加监听器，并指定 Spring 配置文件 的位置。\n\n\t```xml\n\t<!-- 指定 Spring 配置文件 -->\n\t<context-param>\n\t    <param-name>contextConfigLocation</param-name>\n\t    <param-value>classpath:applicationContext.xml</param-value>\n\t</context-param>\n    \n\t<!-- 监听器模块 -->\n\t<listener>\n\t    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n\t</listener>\n\t```\n\n##### Spring JdbcTemplate 操作\n- Spring 对不同的持久化层技术都进行了封装：\n\t- `Jdbc`\n\t- `Hibernate 5.x`\n\t- `iBatis / MyBatis`\n\t- `JPA`\n- JdbcTemplate 对 Jdbc 进行了封装，以下为实际操作介绍。\n\n###### JdbcTemplate 增删改查\n\n- Step.01.创建对象，设置数据库信息\n- Step.02.创建 jdbcTemplate 对象，设置数据源\n- Step.03.调用 jdbcTemplate 对象，实现其中的方法实现增、删、改、查操作。\n\n\t```java\n\t// Jdbc 模板依赖连接池获得数据库连接，所以必须先构造连接池\n\tDriverManagerDataSource dataSource = new DriverManagerDataSource();\n\tdataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n\tdataSource.setUrl(\"jdbc:mysql://192.168.x.x/db_testdb\");\n\tdataSource.setUsername(\"root\");\n\tdataSource.setPassword(\"123456\");\n\t \n\t// 创建 Jdbc 模板\n\tJdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n\t \n\t// 建表 SQL 语句\n\tString sql_create = \"CREATE TABLE \" + \n\t\t\"t_user(id int primary key auto_increment, username varchar(20), password varchar(20))\";\n\tString sql_insert = \"INSERT INTO t_user VALUES(?, ?, ?)\";\n\tString sql_update = \"UPDATE t_user password = ? WHERE username = ?\";\n\tString sql_delete = \"DELETE FROM t_user WHERE username = ?\";\n\t\n\t// JdbcTemplate 实现增、删、改操作\n\tjdbcTemplate.execute(sql_create); \n\tjdbcTemplate.update(sql_insert, \"Lucy\", \"123456\"); \n\tjdbcTemplate.update(sql_update, \"Lucy\", \"abc123\");\n\tjdbcTemplate.update(sql_delete, \"Lucy\");\n\t\n\t/**\n\t * JdbcTemplate 实现查询操作，使用 RowMapper 接口，\n\t * 但 JdbcTemplate 没有针对这个接口提供实现类，得到不同的类型数据需要进行数据封装\n\t */\n\t\n\t// 查询返回某一个值 \n\tsql_select_certain = \"SELECT count(*) FROM t_user\";\n\t// args0：SQL 语句，args1：返回类型 Class\n\tjdbcTemplate.queryForObject(sql_select_certain, Integer.class);\n\t \n\t// 查询返回 list 集合\n\tsql_select_all = \"SELECT * FROM t_user\";\n\tList<User> list = jdbcTemplate.query( sql_select_all, new MyRowMapper() );\n\t\n\t// 查询返回 list 集合，需要创建类实现 RowMapper 接口\n\tpublic class MyRowMapper implements RowMapper<User> {\n\t    @Override\n\t    public User mapRow(ResultSet rs, int num) throws SQLExpection {\n\t        User user = new User();\n\t        user.setUsername( rs.getString(\"username\") );\n\t        user.setPassword( rs.getString(\"password\") );\n\t        return user;\n\t    }\n\t}\n\n \t```\n\n##### Spring 配置连接池\n- 创建 Spring 配置文件，配置连接池：\n\n\t```xml\n\t<!-- 为便于修改配置，可在根目录下新建文件 c3p0.properties，填写格式如下：\n\t | datasource.driverClass=com.mysql.jdbc.Driver\n\t | datasource.jdbcUrl=jdbc:mysql://192.168.x.x:3306/db_testdb?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC\n\t | datasource.user=root\n\t | ...\n\t-->\n\t<context:property-placeholder location=\"classpath:c3p0.properties\"/>\n\t\n\t<!-- Data Connection Setting -->\n\t<bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n\t    <!-- 引用 c3p0.properties 的键值对即可 -->\n\t    <property name=\"driverClass\" value=\"${datasource.driverClass}\"/>\n\t    <property name=\"jdbcUrl\" value=\"${datasource.jdbcUrl}\"/>\n\t    <property name=\"user\" value=\"${datasource.user}\"/>\n\t    <property name=\"password\" value=\"${datasource.password}\"/>\n\t    <!-- 设置数据库连接池的最大连接数 -->\n\t    <property name=\"maxPoolSize\" value=\"${datasource.maxPoolSize}\"/>\n\t    <!-- 设置数据库连接池的最小连接数 -->\n\t    <property name=\"minPoolSize\" value=\"${datasource.minPoolSize}\"/>\n\t    <!-- 设置数据库连接池的初始化连接数 -->\n\t    <property name=\"initialPoolSize\" value=\"${datasource.initialPoolSize}\"/>\n\t    <!-- 设置数据库连接池的连接最大空闲时间 -->\n\t    <property name=\"maxIdleTime\" value=\"${datasource.maxIdleTime}\"/>\n\t    <!-- c3p0缓存Statement的数量数 -->\n\t    <property name=\"maxStatements\" value=\"${datasource.maxStatements}\"/>\n\t    <!-- 当连接池的连接用完的，从 C3p0 下获取新的连接数 -->\n\t    <property name=\"acquireIncrement\" value=\"${datasource.acquireIncrement}\"/>\n\t    <property name=\"checkoutTimeout\" value=\"${datasource.checkoutTimeout}\"/>\n\t    <property name=\"idleConnectionTestPeriod\" value=\"${datasource.idleConnectionTestPeriod}\"/>\n\t</bean>\n\t\n\t<!-- JdbcTemplate 类中封装了 DataSource 类，以 XML 配置形式注解关系即可 -->\n\t<bean name=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n\t    <property name=\"dataSource\" ref=\"dataSource\" />\n\t</bean>\n\t```\n\t\n- 代码引用：\n\n\t```java\n\t@Resource(name = \"jdbcTemplate\")\n\tprivate JdbcTemplate jdbcTemplate;\n\t\n\tString sql = \"SELECT * FROM t_user\";\n\t    List<User> list = jdbcTemplate.query(sql, new MyRowMapper());\n\t}\n\t```\n\n##### Spring 事务管理\n\n###### 编程式事务管理\n此部分省略。\n\n######  声明式事务管理\n- 创建 Service 类和 Dao 类，再添加注入关系：  \n\t1) Service 层，又称业务逻辑层；  \n\t2) Dao 层，数据持久层，单纯对数据库进行操作.  \n\t\n- 引入问题：ServiceTest 类中制造的异常，即造成了转账的不一致问题，细节如下：\n\n\t```java\n\t// ServiceTest.java\n\tpublic class ServiceTest {\n\t\n\t    private DaoTest daotest;\n\t    \n\t    public void setDaotest(DaoTest daotest) {\n\t        this.daotest = daotest;\n\t    }\n\t    \n\t    /* @Transactional 注解方式时填写 */\n\t    public void executeUpdateInDB() {\n\t        GrowUp();\n\t        int exception = 10 / 0;\t// 人为制造异常\n\t        Dealth();\n\t    }\n\t    public void GrowUp() {\n\t        daotest.updateOneTuple(\"UPDATE t_user SET age=age+1 where username = ?\",\n\t        \tnew Object[]{\"诸葛亮\"}, new int[]{Types.VARCHAR});\n\t    }\n\t    public void Dealth(){\n\t        daotest.updateOneTuple(\"UPDATE t_user SET age=0 where username = ?\",\n\t        \tnew Object[]{\"诸葛亮\"}, new int[]{Types.VARCHAR});\n\t    }\n\t\n\t    }\n\t\n\t// DaoTest.java\n\tpublic class DaoTest {\n\t\n\t    private JdbcTemplate jdbcTemplate;\n\t    \n\t    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {\n\t        this.jdbcTemplate = jdbcTemplate;\n\t    }\n\t    \n\t    /**\n\t     * @param sql 插入元组的 SQL 语句\n\t     * @param obj 插入的属性值，与 SQL 中填写属性名的顺序相同\n\t     * @param types 对应属性值的数据类型\n\t     */\n\t    public void updateOneTuple(String sql, Object[] obj, int[] types) {\n\t        jdbcTemplate.update(sql, obj, types);\n\t    }\n\t}\n\t```\n\n- 基于 XML 配置文件形式实现 ( AOP 的思想 )\n\n\t> 目前为止，Spring 配置文件中约束添加完毕，以后配置复制此段即可。\n\n\t```xml\n\t<!-- 目前为止，Spring 配置文件中约束添加完毕，以后的程序复制此段即可 -->\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n\t    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n\t    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n\t    http://www.springframework.org/schema/context\n\t    http://www.springframework.org/schema/context/spring-context-2.5.xsd\n\t    http://www.springframework.org/schema/aop\n\t    http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\n\t    http://www.springframework.org/schema/tx\n\t    http://www.springframework.org/schema/tx/spring-tx-2.5.xsd\">\n\t    \n\t    <!-- set 方法注入属性 -->\n\t    <bean id=\"service\" class=\"cn.kofes.service.ServiceTest\">\n\t        <property name=\"daotest\" ref=\"dao\" />\n\t    </bean>\n\t    <bean id=\"dao\" class=\"cn.kofes.dao.DaoTest\">\n\t        <!-- 引用上例的 jdbcTemplate bean 即可 -->\n\t        <property name=\"jdbcTemplate\" ref=\"jdbcTemplate\" />\n\t    </bean>\n   \n\t    <!-- 配置事务管理器 -->\n\t    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t        <!-- 注入 dataSource  -->\n\t        <property name=\"dataSource\" ref=\"dataSource\" />\n\t    </bean>\n\n\t    <!-- 配置事务增强 -->\n\t    <tx:advice id=\"txadvice\" transaction-manager=\"transactionManager\">\n\t        <!-- 做事务操作 -->\n\t        <tx:attributes>\n\t            <!--\n\t             | 事务操作方法的匹配规则，若事务操作的方法有规范命名，可以简写为：\n\t             | <tx:method name=\"execute*\" />\n\t            -->\n\t            <tx:method name=\"executeTrading()\" />\n\t        </tx:attributes>\n\t    </tx:advice>\n\t    \n\t    <!-- 配置 AOP 操作 -->\n\t    <aop:config>\n\t        <!-- 切点 -->\n\t        <aop:pointcut id=\"poitncutB\" expression=\"execution( * cn.kofes.service.ServiceTest.executeTrading(..) )\" />\n\t        <!-- 切面 -->\n\t        <aop:advisor advice-ref=\"txadvice\" pointcut-ref=\"pointcutB\" />\n\t    </aop:config>\n\t    \n\t</beans>\n\t```\n\n- 基于注解形式实现\n\n\t在需要事务操作的类上配置注解 `@Transactional`，再配置 applicationContext.xml：\n\t\n\t```xml\n\t<!-- 在 applicationContext.xml 中配置事务管理器 -->\n\t<!-- 配置事务管理器 -->\n\t<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t    <!-- 注入 dataSource  -->\n\t    <property name=\"dataSource\" ref=\"dataSource\" />\n\t</bean>\n\t\n\t<!-- 开启注解事务 -->\n\t<tx:annotation-driven transaction-manager=\"transactionManager\" />\n\t```\n\n---\n\n#### Hibernate\n`数据持久层`，Hibernate 是一个开放源码的 `ORM` 持久层框架。简单的说，Hibernate 只是一个将持久化类与数据库表相映射的工具，`每个持久化类实例均对应于数据库表中的一个数据行而已`。用户只需直接使用面向对象的方法操作此持久化类实例，即可完成对数据库表数据的插入、删除、修改、读取等操作。\n\n##### Hibernate 配置\n- 使用配置文件将映射关系对应起来；\n\n\t```xml\n\t<!-- 配置文件命名规范：*.hbm.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\t<!DOCTYPE hibernate-mapping PUBLIC \n\t    \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\t    \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n\t<hibernate-mapping>\n\t    <!--\n\t     | 配置类和表相对应：Class 标签\n\t     | name 属性：实体类全路径\n\t     | table 属性：数据库表名称\n\t    -->\n\t    <class name=\"cn.entity.User\" table=\"t_user\">          \n\t        <!--\n\t         | 配置实体类 ID 与表 ID 对应：ID 标签\n\t         | Hibernate 要求实体类有一个属性唯一值，且要求表有字段作为唯一值\n\t         | name 属性：实体类的 id 属性名称\n\t         | column 属性：生产的表字段名称\n\t        -->\n\t        <id name=\"uid\" column=\"uid\">\n\t            <!-- 设置数据库表 id 增长策略：Class 标签\n\t             | 属性有：increment、hilo、squence、identity、native、uuid、guid 等。\n\t            -->\n\t            <generator class=\"native\" />\n\t        </id>\n                    \n\t        <!-- 配置其他属性和表字段对应：Property 标签 -->\n\t        <!-- 若使用的是 SQL Server 数据库系统，Property 映射对的顺序要和数据库中列 (属性) 的顺序相对应 -->\n\t        <property name=\"username\" column=\"username\" type=\"string\" />\n\t        <property name=\"age\" column=\"age\" type=\"int\" />       \n\t    </class>\n\t</hibernate-mapping> \n\t```\n\t\n> 关于映射配置的一些批注：\n\n- Note.01：就映射配置来说，这里千万要记住，若访问的是 SQL Server 数据库系统，则 **<property> 映射对的顺序要和数据库中列 (属性) 的顺序相对应**。( 其他数据库系统没有出现此类问题，鉴于阅读与编程的规范，则不管使用哪种数据库系统驱动，都以此种方式编辑 Property 映射对 )\n- Note.02：关于配置中实体类的主键生成策略有多种形式，详细见参考 [4]。\n- Note.03：User 实体类对象的状态：\n\t- `瞬时态`：对象没有 ID 值，且其与 Session 没有关联。\n\t- `持久态`：对象有 ID 值，且其与 Session 有关联。\n\t- `托管态`：对象有 ID 值，但其与 Session 没有关联。\n\n\t```Java\n\t/**\n\t * 下述代码只列举了细节不同的部分，其他细节见源代码\n\t */\n\tUser user = new User();\n            \n\t// 瞬时态：即插入元组\n\tuser.setUserName(\"Sample\");\n\tuser.setAge(25);\n\tsession.saveOrUpdate(user);\n\t\n\t// 托管态：对数据表中具体 ID 的元组进行数据修改，即更新元祖\n\tuser.setUid(attr_id);\n\tuser.setUserName(\"Sample\");\n\tuser.setAge(25);\n\tsession.saveOrUpdate(user);\n\t// session.save(user); // 注意：此操作为新增元组，但不是全部属性都修改，会引入空值\n            \n\t// 持久态：对数据表中具体 ID 的元组进行数据修改，即更新元祖\n\tuser = session.get(User.class, attr_id);\n\tuser.setUserName(\"Sample\");\n\tuser.setAge(25);\n\tsession.saveOrUpdate(user);\n            \n\t// 启示：从持久态和托管态态的实验结果可知，修改元组，先查再改，防止空值。\n\t```\n\n- 创建 Hibernate 的核心配置文件；\n        \n\t核心配置文件格式是 XML，且核心配置文件名称和位置是 `固定的` ( Src 根目录下，且名称为 `hibernate.cfg.xml` )。Hibernate 操作过程中，仅加载核心配置文件。\n\n\t```xml\n\t<!-- 配置文件命名规范：hibernate.cfg.xml -->\n                \n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<!DOCTYPE hibernate-configuration PUBLIC\n\t    \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n\t    \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\">\n    \n\t<hibernate-configuration>\n\t    <session-factory>\n\t        <!-- (必填) 配置数据库信息：从 hibernate.property 中获取 -->\n\t        <property name=\"hibernate.connection.driver_class\" value=\"com.mysql.jdbc.Driver\" />\n            \n\t        <!-- SQL Server 数据库管理系统的 Driver \n\t        <property name=\"hibernate.connection.driver_class\">com.microsoft.sqlserver.jdbc.SQLServerDriver</property>\n\t        <property name=\"hibernate.connection.url\">\n\t            jdbc:sqlserver://192.168.0.133:1433;DatabaseName=testDB\n\t        </property>\n\t        -->\n            \n\t        <!-- MySQL 数据库管理系统的 Driver -->\n\t        <property name=\"hibernate.connection.driver_class\">com.mysql.jdbc.Driver</property>\n\t        <property name=\"hibernate.connection.url\">\n\t            jdbc:mysql://192.168.0.163:3306/testDB?serverTimezone=UTC\n\t        </property>\n            \n\t        <property name=\"hibernate.connection.username\">sa</property>\n\t        <property name=\"hibernate.connection.password\">pztech753</property>\n                    \n\t        <!-- (可选) 配置 Hibernate 信息：从 hibernate.property 中获取 -->\n\t        <!-- 操作数据库时，向控制台输出 SQL 语句 -->\n\t        <property name=\"hibernate.show_sql\">true</property> \n\t        <!-- 操作数据库时，向控制台输出格式化的 SQL 语句 -->\n\t        <property name=\"hibernate.format_sql\">true</property>\n\t        <!-- Hibernate 配置自动建表：Update，有表更新没表建立 -->\n\t        <property name =\"hibernate.hbm2ddl.auto\">update</property>\n\t        <!-- \n\t         | 例如，实现分页功能：\n\t         | MySQL 里面使用 LIMIT 关键字，Oracle 中使用 ROWNUM 关键字\n\t         | 让 Hibernate 识别不同数据库中特有的语句\n\t        -->\n\t        <property name=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</property>\n                    \n\t        <!-- (必填) 把映射文件放到核心配置文件中 ( 填 Src 之后的路径 ) -->\n\t        <mapping resource=\"cn/entity/User.hbm.xml\" />\n\t    </session-factory>\n\t</hibernate-configuration>\n\t```\n\n> 关于核心配置的一些批注：\n\n> 面对不同的数据库管理系统，对应的配置属性也存在差异，详细见参考 [5]。\n\n- 通过 Session 保存实体类数据到数据库表中；\n\n    简单演示，详细见下一章节：[Hibernate 使用](#Hibernate-使用)\n        \n    ```java\n    User user = new User();\n    user.setUsername(\"Lucy\");\n    user.setAge(25);\n    Session.save(user);\n    ```\n    \n##### Hibernate 使用\n- 以下代码为 Hibernate 最基本的使用方法，后续将通过优化 Configuration，以及规范事务来优化 Hibernate。\n\n\t```java\n\t// Step.01：加载 Hibernate 核心配置文件 hibernate.cfg.xml\n\tConfiguration cfg = new Configuration();\n\tcfg.configure();\n    \n\t// Step.02：创建 SessionFactory 对象；\n\t// 在此过程中，根据映射关系在数据库中把表创建起来\n\tSessionFactory sessionFactory = cfg.buildSessionFactory();\n\n\t// Step.03：使用 SessionFactory 创建 Session 对象；\n\tSession session = sessionFactory.openSession();\n\n\t// Step.04：手动开始事务；\n\tTransaction trans = session.beginTransaction();\n\n\t// Step.05：写具体逻辑，例如：增删改查；\n\t// 例如添加操作 ( 不操作数据表，而操作实体类 )\n\tUser user = new User();\n\tuser.setUsername(\"Lucy\");\n\tuser.setAge(25);\n\tsession.save(user);\n\n\t// Step.06：提交事务；\n\ttrans.commit();\n\n\t// Step.07：关闭资源；\n\tsession.close();\n\tsessionFactory.close();\n\t```\n\n- Configuration\n    - 到 Src 目录下加载核心配置文件 `hibernate.cfg.xml`；\n- SessionFactory\n    - 根据核心配置文件中数据库配置、映射配置，且根据映射关系，到数据库中把表创建起来。\n    - 创建 SessionFactory 过程中，特别消耗资源，故应该采取优化措施：\n    \n    在 Hibernate 操作中，建议一个项目创建一个 SessionFacotry 对象，以静态的工具类形式封装使用。  \n        \n\t```java\n\tpublic class HibernateUtils {\n\t\tprivate static Configuration cfg = null;\n\t\tprivate static SessionFactory sessionFactory = null;            \n\t\tstatic {\n\t\t    cfg = new Configuration();\n\t\t    cfg.configure();\n\t\t    sessionFactory = cfg.buildSessionFactory();\n\t\t}\n         \n\t\tpublic static SessionFactory getSessionFactory() {\n\t\t    return sessionFactory;\n\t\t}\n\t}\n\t```\n\n- Session\n    - 类似 Jdbc 中的 Connection，可调用 Session 中的不同方法实现 `增、删、改、查` 操作。 \n        - 增加：save()；\n        - 修改：update()；\n        - 删除：delete()；\n        - 查询：get()；\n    - Session 为单线程对象，即不能共用，仅自己使用。\n\t\t- Hibernate 已实现本地线程与 Session 的绑定：在 Hibernate 的核心配置文件中，再调用 sessionFactory 的方法得到。\n        \n\t\t```XML\n\t\t<property name=\"hibernate.current_session_context_class\">thread</property>\n\t\t```\n\n\t\t- 在 HibernateUtils 静态工具类中追加静态方法：\n\n\t\t```java\n\t\tpublic class HibernateUtils {\n\t\t    // 返回与本地线程绑定的 Session\n\t\t    public static Session getSessionObject() {\n\t\t    return sessionFactory.getCurrentSession();\n\t\t    }\n\t\t}\n        \n\t\t/* 在其他类中调用该方法 */\n\t\tSession session = HibernateUtils.getSessionObject();\n\t\t```\n\n- Transaction\n    - 事务概念；\n    - 事务特性：原子性、一致性、隔离性、持久性；\n\n        > 隔离性：不考虑隔离性会产生的问题，如脏读、不可重复读和虚读。当然，可以设置隔离的级别来解决问题。\n        \n    - Hibernate 使用 Transaction 创建事务对象；\n    - 事务的 commit() 与 rollback() 方法 ( `规范用法` )；\n\n\t```java\n\tSessionFactory sessionFactory = null;\n\tSession session = null;\n\tTransaction trans = nu\n\ttry {\n\t    sessionFactory = HibernateUtils.getSessionFactory()\n\t    session = sessionFactory.openSession();\n\t    // 开启事务\n\t    trans = session.beginTransaction();\n            \n\t    // 人为制造异常，被除数不能为零\n\t    User user = ne0w User();\n\t    user.setAge(50/0);\n\t    session.save(user);\n            \n\t    // 提交事务\n\t    trans.commit();\n\t} catch(Exception ex) {\n\t    // 发生异常\n\t    trans.rollback();\n\t} finally {\n\t    session.close();\n\t    sessionFactory.close();\n\t}\n\t```\n    \n##### Hibernate 优化\n\n###### Hibernate 缓存机制\n- 一级缓存：默认是打开的，其使用的范围为 Session 创建到关闭的范围，且存储数据必须为持久态数据。\n- 一级缓存的特性：持久态的数据会自动更新数据库 ( 不用 session.update(user)、session.save(user) )，过程细节如下：\n\n\t```java\n\t// Get() 操作后，将返回持久态对象 user 存于一级缓存中，\n\t// 及存一份到缓存中的快照区 (副本)。\n\tuser = session.get(User.class, attr_id);\n\t// setXXX() 操作，同时修改持久态对象的值和一级缓存中的内容。\n\tuser.setUserName(\"Sample\");\n\t// 当提交事务时，会比较一级缓存和快照区，\n\t// 若不相同，会触发更新数据库操作。\n\ttrans.commit();\n\t```\n  \n- 二级缓存 (替代技术：`redis` )：默认关闭，SessionFactroy 的使用范围。\n\n##### Hibernate 查询\n\n> 在 `Hibernate 查询方式` 小节将详细阐述。\n\n###### Query 对象\n\n> 推荐使用\n\n- 使用 Query 对象，不需要写 SQL 语句，以 HQL 替代。\n  \n    > HQL：Hibernate Query Language，有别于 SQL 语句，即：SQL 操作表和表字段，而 HQL 操作实体类和属性。\n    \n-  Query 对象的使用：\n   \n    ```java\n    // 创建 Query 对象\n    Query query = session.createQuery(\"from User\");\n    // 调用 query 对象的方法得到结果\n    List<User> list = query.list();\n    ```\n    \n###### Criteria 对象\n- Ceiteria 对象的使用： \n\n    ```java\n    // 创建 Criteria 对象　\n    Criteria criteria = session.createCriteria(User.class);\n    // 调用 criteria 对象的方法得到结果\n    List<User> list = criteria.list();\n    ```\n\n###### ~~SQLQuery 对象~~\n- SQLQuery 对象的使用：\n\n\t```java\n\t// 创建 SQLQuery 对象\n\tString sql = \"SELECT * FROM t_user t WHERE t.username= ? AND t.age = ?\";\n\tSQLQuery sqlQuery = session.createSQLQuery(sql)\n\t    .setParameter(0, \"ABC\").setParameter(1, 15);\n    \n\t// Case.01. 以数组形式接收结果\n\t// List<Object []> list = sqlQuery.list();\n    \n\t// Case.02. 返回目标的 User 对象 \n\tsqlQuery.addEntity(User.class);\n\tList<User> list = sqlQuery.list();\n\t```\n\t\n##### Hibernate 多表操作\n- 数据库的多表查询\n\t- 外键\n\t\t- 指定外键关键字： Foreign Key(列名)\n\t\t- 引用外键关键字： References <主表名>(主表主键)\n\t- 关系\n\t\t- 一对一\n\t\t- 一对多\n\t\t- 多对多\n\n###### 一对多操作\n- 一对多映射配置：`实体类配置`\n\t- 创建两个实体类，例如：公司和客户 ( 公司是一，客户是多 )；\n\t- 让两个实体类间互相表示；  \n    \n\t```java\n\t// 客户实体类\n\tpublic class Customer { \n\t    // 省略其他属性\n\t    // ...\n\t    \n\t    // 在客户实体类中表示所属公司，一个客户只属于一个公司\n\t    private Firm firm;\n\t   \n\t    public void setFirm(Firm firm) { this.frim = firm; }\n\t    public Firm getFirm() { return firm; }\n\t}\n    \n\t// 公司实体类\n\tpublic class Firm {\n\t    // 省略其他属性\n\t    // ...\n\t    \n\t    // Set 集合：无序，元素不可重复\n\t    private Set<Customer> customerSet = new HashSet<Customer>();    \n\t    public Set<Customer> getCustomerSet() { return customerSet; }\n\t    public void setCustomerSet(Set<Customer> customerSet) { this.customerSet = customerSet; }\n\t}\n\t```\n\t\n- 一对多映射配置：`XML 配置文件`，一个实体类对应一个映射文件，除了映射文件的基本配置之外，且要在映射文件中配置一对多的关系。\n\n\t```xml\n\t<!-- firm.bhm.xml -->\n\t<class name=\"cn.kofes.entity.Firm\" table=\"t_firm\">\n\t    <!-- \n\t     | 表示公司的所有客户\n\t     | Name 属性：属性值写公司实体类里表示客户 Set 集合的对象名称\n\t    -->\n\t    <set name=\"customerSet\">\n\t        <!--\n\t         | 一对多关系建表，有外键\n\t         | Hibernate 机制，双向维护外键，即在一和多方都配置外键\n\t         | Column 属性：属性值为外键的名称，名称可自定义\n\t        -->\n\t        <key column=\"f_fid\" />\n\t        <!-- 公司的所有客户，即 Class 里写客户实体类全路径 -->\n\t        <one-to-many class=\"cn.entity.Customer\" />\n\t    </set>\n\t</class>\n\t\n\t<!-- customer.bhm.xml -->\n\t<class name=\"cn.kofes.entity.Customer\" table=\"t_customer\">\n\t    <!--\n\t     | 表示客户所属公司\n\t     | Name 属性：客户实体类中使用 firm 对象表示\n\t     | Class 属性：Firm 实体类的全路径\n\t     | Column 属性：外键名称，名称可自定义\n\t    -->\n\t    <many-to-one name=\"firm\" class=\"cn.entity.Firm\" column=\"c_fid\" />\n\t</class>\n\t```\n\t\n- 核心配置文件中，加入 customer.bhm.xml 和 firm.bhm.xml。\n\n\t```xml\n\t<!-- (必填) 把映射文件放到核心配置文件中 ( 填 Src 之后的路径 ) -->\n\t<mapping resource=\"cn/entity/firm.hbm.xml\" />\n\t<mapping resource=\"cn/entity/customer.hbm.xml\" />\n\t```\n\t\n- 一对多级联的操作实现\n\n\t> 在原生数据库中，对包含外键的元组直接删除，是无法成功执行的。正确操作方式为：先删除外键约束，再删除对应元组。但在 Hibernate 中，不用考虑此类问题，因为内置封装了相关功能组件。\n  \n\t- 一对多级联的保存\n    \n\t```java\n\t// Step.01.建立公司对象和客户对象的关系\n\tFirm firm = new Firm();\n\tCustomer customer = new Customer();\n\t// Step.02.把客户对象放到公司对象的 Set 集合里\n\tfirm.getCustomerSet().add(customer);\n\t// Step.03.把公司对象放到客户对象里\n\tcustomer.setFirm(firm);\n\t\t\n\t/**\n\t * 级联保存：即一方和多方都需配置数据\n\t */\n    \n\tsession.save(customer);\n\tsession.save(firm);\n\t```\n\n\t- 一对多级联的删除：在一方 ( 与多方对立 ) 即公司对象，修改其配置文件。\n\n\t最后，直接在代码中进行删除操作即可。\n\n\t```xml\n\t<!-- firm.bhm.xml -->\n\t<class name=\"cn.kofes.entity.Firm\" table=\"t_firm\">\n\t    <!-- 对 Set 标签的 casade 值为 delete -->\n\t    <set name=\"customerSet\" cascade=\"delete\">\n\t        ...\n\t   </set>\n\t</class>\n\t```\n\t\n- 优化步骤之 `Inverse 属性`\n\n\t> 因为 Hibernate 是双向维护外键，在公司和客户里面都需维护外键 ( 从级联删除的执行过程中可体验出来 )。故我们可以设置其中的一方 `放弃` 维护外键，以优化性能。\n\n\t```xml\n\t<!-- firm.bhm.xml -->\n\t<class name=\"cn.kofes.entity.Firm\" table=\"t_firm\">\n\t\t<!--\n\t\t | Inverse 属性\n\t\t | Flase，表示不放弃关系维护\n\t\t | True，表示放弃关系维护\n\t\t-->\n\t\t<set name=\"customerSet\" cascade=\"save-update, delete\" inverse=\"true\">\n\t\t\t...\n\t\t</set>\n\t</class>\n\t```\n\t\n###### 多对多操作\n- 多对多映射配置：实体类配置\n\t- 创建两个实体类，例如：用户和角色 ( 一个用户可扮演多个角色，一个角色可由多个用户扮演 )；\n\t- 让两个实体类间互相表示；  \n\n\t```java\n\t// 用户实体类\n\tpublic void User {\n\t\t// 省略其他属性\n\t\t// ...\n\t\tprivate Set<Role> roleSet = new HashSet<Role>();\n\t\tpublic Set<Role> getRoleSet() { return roleSet; }\n\t\tpublic void setRoleSet(Set{Role} roleSet) { this.roleSet = roleSet; }\n\t}\n\t\n\t// 角色实体类\n\tpublic void Role {\n\t\t// 省略其他属性\n\t\t// ...\n\t\tprivate Set<User> userSet = new HashSet<User>();\n\t\tpublic Set<User> getUserSet() { return userSet; }\n\t\tpublic void setUserSet(Set<User> userSet { this.userSet = userSet; }\n\t}\n\t```\n\t\n- 多对多映射配置：`XML 配置文件`，一个实体类对应一个映射文件，除了映射文件的基本配置之外，且要在映射文件中配置多对多的关系。\n\n\t```xml\n\t<!-- user.bhm.xml -->\n\t<class name=\"cn.kofes.entity.User\" table=\"t_user\">\n\t    <!--\n\t     | 在用户中，表示所有的角色\n\t     | Name 属性：属性值写用户实体类里表角色 Set 集合的对象名称\n\t     | Table 属性：填写多对多时，两实体的联系转化成表 ( 第三张表 )\n\t    -->\n\t    <set name=\"roleSet\" table=\"t_user_role\">\n\t        <!--\n\t         | 多对多关系建表，有外键\n\t         | Column 属性：当前用户实体，在第三张表中的外键名称 \n\t        -->\n\t        <key column=\"u_fid\" />\n\t        <!-- \n\t         | Class 属性：填写角色实体类全路径\n\t         | Column 属性：角色实体，在第三张表中的外键名称\n\t        -->\n\t        <many-to-many class=\"cn.entity.Role\" column=\"r_fid\" />\n\t    </set>\n\t</class>\n\t\n\t<!-- role.bhm.xml -->\n\t<class name=\"cn.kofes.entity.Role\" table=\"t_role\">\n\t    <!--\n\t     | 在角色中，表示所有的用户\n\t     | Name 属性：属性值写角色实体类里表示用户 Set 集合的对象名称\n\t     | Table 属性：填写多对多时，两实体的联系转化成表 ( 第三张表 )\n\t    -->\n\t    <set name=\"userSet\" table=\"t_user_role\">\n\t        <!--\n\t         | 多对多关系建表，有外键\n\t         | Column 属性：当前角色实体，在第三张表中外键的名称\n\t        -->\n\t        <key column=\"r_fid\" />\n\t        <!-- \n\t         | Class 属性：填写用户实体类全路径\n\t         | Column 属性：用户实体，在第三张表中外键的名称\n\t        -->\n\t        <many-to-many class=\"cn.entity.User\" column=\"u_fid\" />\n\t    </set>\n\t</class>\n\t```\n\t\n- 核心配置文件中，加入 customer.bhm.xml 和 firm.bhm.xml。\n\n\t```xml\n\t<!-- (必填) 把映射文件放到核心配置文件中 ( 填 Src 之后的路径 ) -->\n\t<mapping resource=\"cn/entity/user.hbm.xml\" />\n\t<mapping resource=\"cn/entity/role.hbm.xml\" />\n\t```\n\n- 多对多级联的操作实现\n\t- 多对多级联保存\n\n\t\t```java\n\t\t// 和一对多级联操作一样，在用户配置文件 user.hbm.xml 中，\n\t\t// 对 Set 标签的 casade 值为 save-update\n\t\t\n\t\t// 多对多级联保存\n\t\tUser user_1 = new User();\n\t\tUser user_2= new User();\n\t\tRole role_1 = new Role();\n\t\tRole role_2 = new Role();\n\t\tRole role_3 = new Role();\n\t\t\n\t\t// user_1 拥有角色 1、2，user_2 拥有角色 2、3\n\t\tuser_1.getRoleSet().add(role_1);\n\t\tuser_1.getRoleSet().add(role_2);\n\t\tuser_2.getRoleSet().add(role_2);\n\t\tuser_2.getRoleSet().add(role_3);\n\t\t\n\t\t// 保存用户即可 ( 对应于配置文件中设置了 casade 值的实体 )\n\t\tsession.save(user_1);\n\t\tsession.save(user_2);\n\t\t```\n\t- 多对多级联删除 ( 不推荐 )：配置文件；最后，直接在代码中进行删除操作即可。\n\n\t\t```xml\n\t\t// 和一对多级联操作一样，在用户配置文件 user.hbm.xml 中，\n\t\t// 对 Set 标签的 casade 值为 delete ( 可以与保存的属性共存 )\n\t\t<!-- user.bhm.xml -->\n\t\t<class name=\"cn.kofes.entity.User\" table=\"t_user\">\n\t\t    <set name=\"roleSet\" table=\"t_user_role\" casade=\"save-update, delete\">\n\t\t        ...\n\t\t    </set>\n\t\t</class>\n\t\t```\n\t- 维护多对多的关系，通过维护 `第三张表` ( 两实体的联系转化成的表 ) 实现。\n\n##### Hibernate HQL 查询详解\n\n-  `OID` 查询和 `对象导航` 查询 \n\n```java\n// 单元测试类\npublic class HibernateTest {\n    @Test\n    public void testSelect1() {\n        SessionFactory sessionFactory = null;\n        Session session = null;\n        Transaction trans = null;\n\t\t\n        try {\n            sessionFactory = HibernateUtils.getSessionFactory();\n            session = sessionFactory.openSession();\n            trans = session.beginTransaction();\n\t\t\t\n            // 需求：根据 ID 查询某个公司，再查询这个公司的所有客户\n\t\n            // OID 查询：查询 ID 为 1 的公司\n            Firm firm = session.get(Firm.class, 1); // \n            // 对象导航查询：根据某条记录的 ID，返回对象 (公司的客户)\n            Set<Customer> customer = firm.getCustomerSet();\n            System.out.print( customer.toString() );\n\n            trans.commit();\n        } catch(Exception ex) {\n            e.printStackTrace();\n            transaction.rollback();\n        } finally {\n            session.close();\n            sessionFactory.close();\n        }\t\n    }\t\n}\n```\n\n###### HQL 查询\n\n```java\n// Step.01.创建 Query 对象，写 HQL 语句实现查询\n// Step.02.调用 query 对象的方法得到结果\n\n// 查询所有\nQuery query = session.createQuery(\"FROM t_user\");\nList<User> list = query.list();\n\n// 条件查询\nString sql_obscure = \"FROM t_user WHERE username LIKE ?\"; // 模糊查询\nString sql_accurate = \"FROM t_user WHERE age = ? AND username = ?\"; // 精确查询\nQuery query = session.createQuery(sql_accurate);\n// arg0 为占位符位置，arg1 为参数\nquery.setParameter(0, 25).setParameter(1, \"Lucy\");\nList<User> list = query.list();\n\n// 排序查询：ASC，升序 / DESC，降序\nString sql = \"FROM t_user ORDER BY uid ASC\"; \nQuery query = session.createQuery(sql);\nList<User> list = query.list();\n\n// 分页查询：LIMIT 关键字\nString sql = \"FROM t_user\";\nQuery query = session.createQuery(sql);\nquery.setFirstResult(0);\nquery,.setMaxResults(10);\nList<User> list = query.list();\n\n// 投影查询\nString sql = \"SELECT username, age FROM t_user\";\nQuery query = session.createQuery(sql);\nList<Object> list = query.list();\n\n// 聚集函数\n// COUNT()、SUM()、MAX()、MIN()...\nString sql = \"SELECT COUNT(*) FROM t_user\";\nQuery query = session.createQuery(sql);\n// 将结果以对象形式返回\nObject obj = query.uniqueResult();\n```\n\n###### HQL 多表查询\n- 内连接：连接两个表有关联的数据，忽略两个表中对应不起来的数据。\n\t- SQL：SELECT * FROM t_user AS u, t_role AS r ON  u.uid = r.uid;\n \t- 或者：SELECT * FROM t_user u INNER JOIN t_role r ON  u.uid = r.uid;\n\n- 左外链接：左边表所有元组，右边表关联数据。\n\t- 若左表与右表没有关联数据，则右边表数据补 NULL 值，多了则删除\n\t- SQL：SELECT * FROM t_user u LEFT OUTER JOIN t_role r ON  u.uid = r.uid;\n- 右外链接：与左外链接同理。\n\n```java\n// HQL 内连接 ( 左、右外链接同理 )\nString sql_inner_join = \"FROM t_user u INNER JOIN u.roleSet\";\nQuery query = session.createQuery(sql_inner_join);\nList list = query.list(); // list 返回的每部分都是数组\n\n// HQL 迫切内连接\nString sql_inner_join_fetch = \"FROM t_user u INNER JOIN FETCH u.roleSet\";\nQuery query = session.createQuery(sql_inner_join_fetch);\nList list = query.list();  // list 返回的每部分都是对象\n\n// HQL 迫切左外连接  ( 没有迫切右外连接 )\nString sql_inner_join_fetch = \"FROM t_user u LEFT OUTER JOIN FETCH u.roleSet\";\n```\n\n##### Hibernate 检索策略\n\n###### 立即查询\n根据 ID 查询，调用 get() 方法，则马上发送语句查询数据库。\n\n```java\n// Debug 方式可检验，即执行代码马上发送 SQL 语句\nUser user = session.get(User.class, 1);\n```\n\n###### 延迟查询\n根据 ID 查询，调用 load() 方法，不会马上发送语句查询数据库，只有得到对象的值时，才发送语句查询数据库。\n\n```java\n// 调用 load() 方法之后，并不会马上发送 SQL 语句\nUser user = session.load(User.class, 1);\nSystem.out.println( user.getUid() );\n// 当得到对象里其他值时，即非 ID 值，才发送 SQL 语句进行查询\nSystem.out.println( user.getUsername() );\n```\n\n- 类级别延迟：例如，根据 ID 查询返回实体类对象，调用 load() 方法不会马上发送 SQL 语句。 \n-  关联级别查询：例如上述 `对象导航查询`，查询某个公司后，再查询这间公司的所有客户，查询公司所有客户的过程是否需要延迟，则称其为关联级别延迟。\n\n\t```xml\n\t<!-- \n\t | 在配置文件中实现关联级别延迟\n\t | fetch 属性：select\n\t | lazy 属性：true / false / extra\n\t | \t- True，当得到对象里其他值时，即非 ID 值，才发送 SQL 语句进行查询。\n\t | \t- False，反之，会多执行一次查询 ( getUid() )。\n\t | \t- Extra，需要什么属性，查询什么属性 ( 仅需少量属性时推荐使用 )\n\t-->\n\t<class name=\"cn.kofes.entity.User\" table=\"t_user\">\n\t    <set name=\"roleSet\" table=\"t_user_role\" fetch=\"select\" lazy=\"true\" >\n\t        ...\n\t    </set>\n\t</class>\n\t```\n\t\n###### 批量抓取\n- 例如，我们需要查询所有公司的所有客户，代码实现如下：\n\t\n\t```java\n\tCriteria criteria = session.createCriteria(User.class);\n\tList<Firm> list = criteria.list();\n\tfor(Firm firm : list) {\n\t    System.out.println( firm.getId() + \":\" + firm.getName() );\n\t    Set<Customer> customerSet = firm.getCustomerSet();\n\t    for(Customer customer : customerSet) {\n\t        System.out.println( customer.getUid() + \":\" + customer.getUsername() );\n\t    }\n\t}\n\t\n\t// 但在执行过程中，暴露的问题时：每次循环都执行一次查询，拖沓性能\n\t```\n\t\n- 故我们只需要在实体映射配置文件中，对 Set 标签进行设置属性即可：\n\n\t```xml\n\t<!-- firm.bhm.xml -->\n\t<class name=\"cn.kofes.entity.Firm\" table=\"t_firm\">\n\t    <!-- batch-size 的值为整数即可 -->\n\t    <set name=\"customerSet\" batch-size=\"10\">\n\t        ...\n\t    </set>\n\t</class>\n\t```\n\t\n---\n\n#### SSH 框架总结\n\n##### Struts\n- Action 操作\n\t- Action 创建 (三种方式)：继承 `ActionSupport` 类。\n\t- Action 访问路径：创建 `struts.xml` 配置文件，文件名称和位置 ( Src 目录 ) 固定。\n\t- 访问 Action 的多个方法：使用 `通配符方式` 配置。\n\t- Action 获取表单提交数据：\n\t\t- 获取 Request 对象 ( 使用 `ServletAction` 类 )；\n\t\t- 属性封装；\n\t\t- 模型驱动；\n\t- Action 操作域对象：使用 `ServletAction` 类。\n\t- 配置 Struts2 过滤器。\n- 值栈\n\t- 向值栈放数据：\n\t\t- Set 方法；\n\t\t- Push 方法；\n\t\t- 定义变量，生成 Get 方法.\n\t- 从值栈获取数据：在 JSP 中使用 Struts2 标签 + Ognl 获取\n\t\t- `<s:property />`\n\t\t- `<s:iterator />`\n- 拦截器\n\t- AOP 和责任链模式；\n\t- 自定义拦截器：\n\t\t- 继承 `MethodFilterInterceptor` 类，并重写类方法；\n\t\t- 配置拦截器和 Action 关联.\n\n##### Spring\n- Spring 核心配置文件：\n\t- 名称和位置没有固定要求；\n\t- 在 Spring 核心配置文件中引入 Schema 约束.\n- 创建对象：\n\t- XML 配置方式：`<bean id=\"\" class=\"\" />`；\n\t- 注解方式：`@Component` 或 `@Controller` (Web层)、`@Service` (业务层)、`@Repository` (持久层).\n- 注入属性:\n\t- XML 配置方式：`<bean id=\"\" class=\"\"><property name=\"\" ref=\"\" /></bean>`；\n\t- 注解方式：`@autowired`、`@Resource(name=\"value\")`.\n- 使用 ServletContext 对象和监听器实现\n\t- 在服务器启动时，加载 Spring 配置文件，创建对象；\n\t- 配置 Spring 的监听器；\n\t- 指定 Spring 配置文件位置.\n- Spring JdbcTemplate \n- Spring 事务配置：\n\t- XML 配置方式；\n\t- 注解方式：`@Transational`\n\n##### Hibernate\n- ORM 思想：`对象关系映射`，参考 [ORM 框架](#ORM-框架)；\n- 数据库信息配置：MySQL / SQL Server 2008 R2；\n- Hibernate 信息配置：即配置 Hibernate 核心配置文件 ( `hibernate.cfg.xml` )。\n\n\t> Hibernate 和 Spring 整合时，配置文件的名称和位置是没有固定要求的。\n\t\n- 映射关系配置：即配置 Hibernate 映射配置文件 ( `xxx.hbm.xml` )，实体类和数据表映射关系 ( 使用 ORM 思想 )。\n- Hibernate 操作步骤：Spring 框架对 Hibernate 框架也有封装，即 `HibernateTemplate` 类。\n\n#### SSH 框架整合\n\n![SSH框架整合思想](/images/illustration/Project/2018/08/J2EE-SSH-SSI-1_6-4.png)\n<center>图 6-4 SSH 框架整合思想</center>\n\n- Spring 与 Struts 2 框架的整合\n\t\n\t把 Struts 2 的 Action 对象创建交给 Spring 进行管理。\n\n\t```xml\n\t<bean id=\"\" class=\"\" scope=\"prototype\" />\n\t```\n\n- Spring 与 Hibernate 框架的整合\n\n\t把 Hibernate 的核心配置文件里的数据库配置，直接写在 Spring 配置文件中。且把 SessionFactory 对象创建交给 Spring 管理。\n\t\n#### SSH 整合演示\n\n##### Spring 与 Struts 2 整合\n\n- Action 代码实现：\n\n\t```java\n\t// cn.kofes.dao.BaseAction.java\n\t\n\tpublic class BaseAction extends ActionSupport {\n\t    @Override\n\t    public String execute() throws Exception {\n\t        System.out.println(\"The portion of action has deployed successfully.\");\n\t        return NONE;\n\t    }\n\t}\n\t```\n\t\n- 在 Spring  配置文件下整合 Struts：\n\n\t```xml\n\t<!-- spring.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n\t    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n\t    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n\t    http://www.springframework.org/schema/context\n\t    http://www.springframework.org/schema/context/spring-context-2.5.xsd\n\t    http://www.springframework.org/schema/aop\n\t    http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\n\t    http://www.springframework.org/schema/tx\n\t    http://www.springframework.org/schema/tx/spring-tx-2.5.xsd\">\n\n\t    <!-- 整合 Struts：Action 对象的配置 -->\n\t    <bean id=\"BaseAction\" class=\"cn.kofes.action.BaseAction\" scope=\"prototype\"/>\n\t    \n\t</beans>\n\t```\n\n- 整合 Web，当服务器启动时加载 Spring 配置即初始化，我们需要在 web.xml 下配置监听器：\n\n\t```xml\n\t<!-- web.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n\t    version=\"4.0\">\n\t    \n\t    <!-- 加载 Spring 的配置文件 -->\n\t    <context-param>\n\t        <param-name>contextConfigLocation</param-name>\n\t        <param-value>classpath:spring.xml</param-value>\n\t    </context-param>\n\t\n\t    <!-- 监听器模块：作用就是启动 Web 容器时,自动装配 spring.xml 文件的配置信息 -->\n\t    <listener>\n\t        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n\t    </listener>\n\t\n\t    <!-- 过滤器模块 -->\n\t    <filter>\n\t        <filter-name>struts2</filter-name>\n\t        <filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>\n\t    </filter>\n\t    <filter-mapping>\n\t        <filter-name>struts2</filter-name>\n\t        <url-pattern>/*</url-pattern>\n\t    </filter-mapping>\n\t\n\t    <welcome-file-list>\n\t        <welcome-file>index.jsp</welcome-file>\n\t    </welcome-file-list>\n\t\n\t</web-app>\n\t```\n\t\n- 最后，struts.xml 填入以下配置即可：\n\n\t```xml\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<!DOCTYPE struts PUBLIC\n\t    \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\"\n\t    \"http://struts.apache.org/dtds/struts-2.3.dtd\">\n\t\n\t<struts>\n\t    <package name=\"sample\" extends=\"struts-default\" namespace=\"/\">\n\t        <!--\n\t         | Class 属性值不写目标 Action 的全路径，原因是防止二次创建对象\n\t         | 引入 Spring 相对应  Action 的 Bean 标签 ID\n\t        -->\n\t        <action name=\"BaseAction\" class=\"BaseAction\" />\n\t    </package>\n\t</struts>\n\t```\n\n##### Spring 与 Hibernate 整合\n\n- 在 Spring  配置文件下配置数据库信息，及整合 Hibernate。后者即将 SessionFacotry 交由 Spring 管理：\n\n\t> `c3p0.properties` 和 `hibernate.properties` 配置文件位于 Src 根目录下，键值分离以便以后修改配置。\n\n\t```xml\n\t<!-- spring.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n\t    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n\t    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n\t    http://www.springframework.org/schema/context\n\t    http://www.springframework.org/schema/context/spring-context-2.5.xsd\n\t    http://www.springframework.org/schema/aop\n\t    http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\n\t    http://www.springframework.org/schema/tx\n\t    http://www.springframework.org/schema/tx/spring-tx-2.5.xsd\">\n\n\t    <!-- 在根目录下新建文件 c3p0.properties，存储数据库连接信息 -->\n\t    <context:property-placeholder location=\"classpath:c3p0.properties\"/>\n\n\t    <!-- Data Connection Settings -->\n\t    <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n\t        <!-- 引用 c3p0.properties 的键值对即可，格式如 ${key.value} -->\n\t        <property name=\"driverClass\" value=\"${datasource.driverClass}\"/>\n\t        <property name=\"jdbcUrl\" value=\"${datasource.jdbcUrl}\"/>\n\t        <property name=\"user\" value=\"${datasource.user}\"/>\n\t        <property name=\"password\" value=\"${datasource.password}\"/>\n\t        <!-- 设置数据库连接池的最大连接数 -->\n\t        <property name=\"maxPoolSize\" value=\"${datasource.maxPoolSize}\"/>\n\t        <!-- 设置数据库连接池的最小连接数 -->\n\t        <property name=\"minPoolSize\" value=\"${datasource.minPoolSize}\"/>\n\t        <!-- 设置数据库连接池的初始化连接数 -->\n\t        <property name=\"initialPoolSize\" value=\"${datasource.initialPoolSize}\"/>\n\t        <!-- 设置数据库连接池的连接最大空闲时间 -->\n\t        <property name=\"maxIdleTime\" value=\"${datasource.maxIdleTime}\"/>\n\t        <!-- c3p0缓存Statement的数量数 -->\n\t        <property name=\"maxStatements\" value=\"${datasource.maxStatements}\"/>\n\t        <!-- 当连接池的连接用完的，从 C3p0 下获取新的连接数 -->\n\t        <property name=\"acquireIncrement\" value=\"${datasource.acquireIncrement}\"/>\n\t        <property name=\"checkoutTimeout\" value=\"${datasource.checkoutTimeout}\"/>\n\t        <property name=\"idleConnectionTestPeriod\" value=\"${datasource.idleConnectionTestPeriod}\"/>\n\t    </bean>\n\t    \n\t    <!-- 整合 Hibernate：SessionFactory 对象的配置 -->\n\t    <bean id=\"sessionFactory\"\n\t        class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\">\n\t        <!-- (必填信息) 指定数据库 -->\n\t        <property name=\"dataSource\" ref=\"dataSource\" />\n\t        <!-- (可选信息) 配置 Hibernate 信息 -->\n\t        <property name=\"hibernateProperties\" value=\"classpath:hibernate.properties\" />\n\t        <!-- (必填信息) 把映射文件放到核心配置文件中 ( 现直接加载到 LocalSessionFactoryBean 类中即可 )  -->\n\t        <property name=\"mappingResources\">\n\t            <list>\n\t                <value>mapper/sample.hbm.xml</value>\n\t            </list>\n\t        </property>\n\t    </bean>\n\n\t</beans>\n\t```\n\n- 创建实体类：\n\n\t```java\n\t// Employee.java\n\tpublic class Sample { ... }\t\n\t\n\t```\n\t\n- 创建实体类映射文件 ( 文件位置没有固定要求，建议统一文件夹存储 )：\n\n\t```xml\n\t<!-- src/resource/HbmCollection/sample.hbm.xml -->\n\t\n\t<?xml version='1.0' encoding='UTF-8'?>\n\t<!DOCTYPE hibernate-mapping PUBLIC\n\t    \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\t    \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n\t    \n\t<hibernate-mapping>\n\t    <!--\n\t     | name 属性：实体类全路径\n\t     | table 属性：数据库表名称\n\t    -->\n\t    <class name=\"cn.kofes.bean.Sample\" table=\"t_sample\">\n\t        <!--\n\t         | Hibernate 要求实体类有一个属性唯一值，且要求表有字段作为唯一值\n\t         | name 属性：实体类的 id 属性名称\n\t         | column 属性：数据表字段名称\n\t        -->\n\t        <id name=\"id\" column=\"id\">\n\t            <!-- 设置数据库表 id 增长策略：Class 标签\n\t             | 属性值：increment、hilo、squence、identity、native、uuid、guid 等。\n\t            -->\n\t            <generator class=\"native\"/>\n\t        </id>\n\n\t        <!-- 配置其他属性和表字段对应：Property 标签 -->\n\t        <property name=\"name\" column=\"name\" type=\"string\"/>\n\t    </class> \n\t</hibernate-mapping>\n\t```\n\n- 在 `核心配置文件` 中引入 `映射配置文件`：\n\n\t> 在 Spring 配置文件中已引入映射配置文件，故不需要再单独配置 `hibernate.cfg.xml`。\n\t\n- 事务配置：在 spring.xml 配置文件中配置并开始事务注解，再到 Service 层添加注解 `@Transactional`： \n\n\t```xml\n\t<!-- 配置事务管理器 -->\n\t<bean id=\"transactionManager\"\n\t    class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\">\n\t    <property name=\"sessionFactory\" ref=\"sessionFactory\"/>\n\t</bean>\n\t\n\t<!--  开始事务注解 -->\n\t<tx:annotation-driven transaction-manager=\"transactionManager\" />\n\t```\n\n##### Spring 分模块开发\n\n- 在 Spring 里配置多个内容，容易造成配置混乱，不利于维护。\n- 把 Spring 核心配置文件中，将一部分配置放到单独的配置文件中，再在 Spring 核心配置文件中引入单独配置文件。\n\n\t```xml\n\t<!-- \n\t | 将原 Spring 中的部分配置放置到独立 xml 中，\n\t | 例如我把 Dao 层的配置独立出来，再到 spring.xml 中引入配置文件 dao.xml 即可。\n\t-->\n\t<import resource=\"classpath:dao.xml\" />\n\t```\n\t\n##### SSH 框架使用演示\n\nSSH 整合工作告一段落，当然你可通过 Maven 打包工程，以便以后复用。\n\n\n### SSM 框架\n\n> 当然，随着框架技术的迭代更新，更加科学、合理的新框架也逐渐在项目中使用起来，如 SSM 框架。具体细节可参考：[Java EE 之 SSM 框架配置与使用](https://www.kofes.cn/2018/08/J2EE-SSM-1.html)\n\n- `SSM 框架`：Spring MVC、Spring、MyBatis\n\n\tSSM ( Spring + SpringMVC + MyBatis ) 框架集由 Spring、SpringMVC、MyBatis 三个开源框架整合而成，常作为数据源较简单的 Web 项目的框架。\n\n- `Spring`：是一个轻量级的控制反转 (IoC) 和面向切面 (AOP) 的容器框架。\n\n\t> 与本文的 Spring 章节内容相同。\n\n- `SpringMVC`：分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。\n- `Mybatis`：[Mybatis](http://blog.mybatis.org/) 是一个支持普通SQL查询，存储过程和高级映射的优秀持久层框架。它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs (Plain Old Java Objects，普通的 Java对象 ) 映射成数据库中的记录。\n\n##参考资料 \n\n- \\[1\\] [ 一枪尽骚 · 魂. 基于全注解方式的SSH基础框架. csdn.net](https://blog.csdn.net/u012377333/article/details/50037825)\n- \\[2\\] [刻下岁月. IntelliJ IDEA 2016.1.2 + Spring + Struts2 + Hibernate ( SSH ). lunhui.ren](http://blog.lunhui.ren/archives/225) \n- \\[3\\] [kent. JavaEE SSH 三大框架整合 ( Spring + Struts2 + Hibernate ). cnblogs.com](https://www.cnblogs.com/xieyupeng/p/7108141.html)\n- \\[4\\] [Starskyhu. Hibernate 各种主键生成策略与配置详解. cnblogs.cn](https://www.cnblogs.com/hoobey/p/5508992.html)\n- \\[5\\] [陈铁锋. Hibernate 连接三种数据库的配置 ( SQL Server、Oracle、MySQL ). csdn.net](https://blog.csdn.net/chentiefeng521/article/details/58775415)\n- \\[6\\] [RoadOfStudy. MySQL 5.7版本的root用户重置密码问题. cnbolgs.com](https://www.cnblogs.com/roadofstudy/p/7446690.html)\n- \\[7\\] [Time Tries All. MySQL 重置密码出现的一系列问题. csdn.net](https://blog.csdn.net/time_tries_all/article/details/78571984)\n- \\[8\\] [Souvc. 连接虚拟机 (Ubuntu16.04) 的 MySQL 服务器. souvc.com](http://www.souvc.com/?p=915)","tags":["J2EE","JSP","Spring","SSH","Hibernate","Struts"],"categories":["Project"]},{"title":"论文 | 归类分析 GPS 以预测车辆停留意图信息","url":"/2018/06/Stop-purpose-classification-from-GPS-data-of-commercial-vehicle-fleets.html","content":"\n{% note default %}\n原文：Stop purpose classification from GPS data of commercial vehicle fleets\n作者：Sarti L, Bravi L, Sambo F.    \n来源：Data Mining Workshops, 2017 IEEE International Conference on. IEEE, 2017: 280-287.  \n{% endnote %}\n\n## 摘要\n\n从原始 GPS（全球定位系统）数据中提取 `汽车停靠意图数据` 是大多数位置感知应用程序中的关键任务，且随着从移动设备收集 GPS 数据的不断增长，这项任务变得越来越有趣。近期很多研究都集中在行人手机数据上（可理解为红海市场），而商用车领域几乎没有探索（蓝海市场）。\n\n在本论文中，针对车辆 GPS 数据的汽车停靠意图的 `识别` 和 `分类` 问题 (利用来自不同行业的商业车队的大型异构数据集)，按照意图分类，旨在把汽车停靠点分类为：`工作相关` 和 `非工作相关`，以挖掘相关商业价值。\n\n还对每个汽车停靠点计算一组含 100 个不同特征的集合，特征可分为四个主要类别：`汽车停靠点特征`，`兴趣点特征`，`汽车停靠点集群特征` 和 `序列特征`。并组合四组特征，加入训练，通过随机森林分类模型，我们得以评估四组特征中每个特征的相对重要性。\n\n> 强特征可有效地提升分类模型的精度。\n\n实验结果表明，本论文的方法显着地超越了现有商业车辆背景下用于汽车停靠意图的分类模型。\n\n<!-- More -->\n\n## 正文\n\n### 引入\n在过去的十年中，GPS 设备的巨大推广，使得人们越发关注 `数据挖掘算法` 在 `时空数据` (GPS 产生的数据) 中的应用。而许多实际应用需要使用关于 `用户行为` 和 `地理位置的语义信息`。例如，下述的两个实例：\n\n- 基于用户的历史位置以衡量用户之间的相似度 $^{[1]}$；\n- 基于位置的兴趣地点推荐系统 $^{[2]}$。\n\n语义标记 GPS 数据，目标旨在 `识别` 和 `归类` GPS 沿途轨迹上的位置信息，即具体工作有 `语义位置的侦察` 和 `汽车停靠或出游的意图归类`。尽管上述问题不是同一类型的问题，但却是强相关的。例如，对多个用户而言具有相同意图的共同定位点，可能是语义上相关联的地方，因为知道某个地方的语义对分类每个汽车停靠点意图有很大的帮助。\n\n通常，对于上述 `识别` 和 `归类` 问题的解决方法分两个阶段执行：\n\n- `侦查兴趣地点`：通常以非监督的方式实现位置侦查 $^{[3,4]}$，而作者提出了基于 `DBSCAN` $^{[5\\,or\\,6]}$ 的修改版本的聚类算法，或者利用层次聚类从汽车停靠位置中提取访问点。\n\n\t> 当要处理非常大的数据集时需要考虑计算性能的问题，可参考其他论文中的扩展方法，例如对地点坐标进行哈希散列法 $^{[7,8]}$。\n\n- `对侦查到的地点分类`：对有关地点或汽车停靠点进行分类，可以在文献中找到两种主要方法：\n\t- 基于规则的系统 $^{[9,10]}$，其主要依赖于活动的位置、土地利用的数据以及机器学习方法，即活动本身提取特征；\n\t- 利用 SVM 分类器来区分标识位置内的活动停靠点和非活动停靠点。分类器 (SVM，随机森林或逻辑回归) 利用时间和空间特征 $^{[6]}$，以及隐马尔可夫模型 (HMM) 利用时序特征把这些汽车停靠点分类为预定义类型。\n\n\t\t> 1) SVM 提取三个主要特征：停车驻留时间，每个汽车停靠地段周围的点到质心的平均距离。    \n\t\t> 2) 地点的语义分类是基于 GPS 数据和卫星图像的组合而定的 $^{[8]}$。  \n\t\n\n最后，本论文解决了与参考文献 [7] 的同样问题，即利用四个不同的特征集，使用一个随机森林分类器，对商业车队的汽车停靠意图数据进行分类建模。且本文的主要贡献如下：\n\n- 描述了一种方法，即从 GPS Pings (GPS 定位仪) 中提取汽车停靠点信息，并从运作状态的停车时间表 ( 已知的地点信息 ) 中給它们分配地面实况标签，实际是 `标注标签的过程`;\n- 基于以上带标签的数据集，`建立模型`，`自动分类` 汽车停靠点，即区分工作相关和非工作相关的停靠点;\n- 提供了严格评估的多类型 `特征集`，便于我们处理问题 (提高分类精确度)，其中包括：\n\t- 汽车停靠点特征 (Stop-wise features，SWF)；\n\t- 兴趣点特征 (Points of interest features，POIF)；\n\t- 停靠点集群特征 (Stop Cluster，CF)；\n\t- 序列特征 (Sequential features，SeqF).\n\n### 方法\n#### GPS 和工单数据的定义\n- 本论文采用的数据集由 Fleetmatics 公司 (车队情报公司) 提供。\n- 采集的数据有两种类型，分别是 `原始 GPS Pings 数据` 和 `工单数据`。\n\t- 原始 GPS Pings 数据\n\t\t- 提供有关车辆位置的信息、工单状态的信息、有关司机执行工作的进度信息；\n\t\t- 设定有一系列的 GPS Pings $\\{P_i\\}_{i=1}^n = \\{P_1, ..., P_n\\}$ 分别描述每辆车行驶的路线。\n\t\t- 每一个 GPS Ping $P_i$ 包含每辆车的状态信息，即有车辆 ID $v_i$，经度和纬度 (位置信息 $p_i$)，里程表 $d_i$，时间戳 $t_i$ 和 事件代码 $e_i$。\n\t- 工单数据\n\t\t- 设定有一系列的工单 $\\{W_i\\}_{i=1}^n = \\{W_1, ..., W_n\\}$。\n\t\t- 每一个工单包含的信息有：车辆 ID $v_i$，经度和纬度 (位置 $p_i$)，时间戳 $t_i$ 和 状态代码 $c_i$ (例如：挂起，启动，完成)。\n\n#### 侦查车辆停靠状态的方法\n正如上述所描述的，关于瞬时车辆位置的原始数据是由 GPS Ping 组成的，将它们汇集起来以描述车辆的活动。为此本论文开发了一个 `时空聚类程序`。\n\n- 首先得为每个 GPS 信息分配一种状态类型 (Engine off，iDling，Journey)，然后把它们聚集成 GPS Ping 群组，并把这个 GPS Ping 群组称为 `汽车停靠点集`。\n- GPS Ping 的状态可分为三种类型：\n\t- `Engine Off (发动机关闭状态)`：发动机关闭事件。即这些 Ping 在发动机关闭的瞬间产生的 (当发动机处于关闭状态时不发送 Ping);\n\t- `iDling (空转/怠速状态)`：发动机处于开启状态，但车辆静止或车辆在小区域内仍然缓慢行驶。对于后者，我们还需要作一些约束，设定 $H(p_i,p_{i-1})$ 表示两点间的半正定距离。然后，对于给定车辆给予一对连续的 Ping $P_i\\,and\\,P_{i-1}$，且满足以下约束，则可定义为怠速：\n\t\t- $s_i = H(p_i,p_{i-1})\\,/\\,(t_i - t_{i-1}) \\leq 1.4\\,m/s\\,(5km/h)$，确定速度接近零；\n\t\t- $H(p_i,p_{i-1}) \\leq 150\\,m$，确保 $P_{i-1}\\,and\\,P_i$ 足够接近，且避免了由于丢失数据而产生的 `伪影`。\n\t- `Journey (行驶状态)`：即不是发动机关闭状态，也不是怠速状态。\n- 当 Ping 被分类后，以每辆车为单位，按时间顺序排序；并把所有连续的怠速状态和发动机关闭状态的 Ping 聚集成集群 (并不会被其中 Journey 状态的 Ping 給分割开来)。\n- 由于丢失数据，导致一组连续的怠速状态 Ping 彼此相对较远地分布开来。故我们得重新执行 `时间-空间` 的约束条件 ($s_i \\leq 1.4\\,m/s$ and $H(p_i,p_{i-1}) \\leq 150\\,m$)。\n\n\t> 无法满足约束条件：即一组连续的怠速状态 Ping 将被分隔得很远，其中的 Journey 状态的 Ping 都给丢失了。 \n\t\n- 以这种方式创建的 `Pings 集群` 代表我们想要分类的 `已标识汽车停靠点`。综上所述，汽车停靠点被定义为按时间顺序排序的 Pings  集群 (包含怠速状态或发动机关闭状态的 Pings，并且满足进一步的 `时间-空间` 约束条件。\n- 每个 `汽车停靠点` 都有几个特性 ( 通过计算其中的 Ping )：Ping 的数量，停靠点的起点和终点 ( 属于该停靠点的 Ping 的第一个和最后一个时间戳 )，驻留时间 ( 属于该停靠点的起始时间和结束时间 ) 和形状 ( 由GPS消息的最大 (最小) 纬度/经度坐标定义 )。\n- 所有这些信息对于在第二阶段提取特征工作至关重要，即汽车停靠点意图的分类。\n\n#### 标注标签\n- 首先，对上述程序中获得的汽车停靠点分配 `地面实况标签`。\n- 再者，将它们与 `工单数据` 进行匹配。一般来说，若车辆停留点在时间上和空间上与工单数据 $W_i$ 相匹配，则可认为该汽车停靠点就是该工单数据。\n\t- `空间匹配`：对于只包含 idling 和 engine off 状态的停靠点，我们认为它满足空间上的匹配。\n\t- `时间匹配`：对于任何工单，空间上匹配了停留点；如果停留点的驻留时间与工单的时间项 (指示作业已启动的时间和指示服务已结束的时间) 间隔相交，时间的匹配也随着满足。\n\n#### 分类特征\n在 `车辆停靠侦查技术` 章节中描述的，从一系列的 GPS Pings 提取汽车停靠点，并从中提取 100 个不同的特征用于训练随机森林模型，随之将这些特征划分为 4 个不同的组：\n\n- 汽车停靠点特征 ( Stop-wise features，SWF )：\n\t- 驻留时间：(汽车) 停靠点第一个和最后一个 Ping 的时间差。\n\t- 开始时间特征：一天中的小时，一周中的某天，某月某日，某年某日等。\n\n\t\t> 是否统一时间表示方式 (时间戳)： yyyy-MM-dd HH:mm\n\t\n\t- 关闭引擎所花费的时间：对于每一个引擎关闭事件，我们计算当前 Ping 与前一个非引擎关闭状态的 Ping 之间的时间差，以表示引擎启动的时间。由于每个停靠点包含多个引擎关闭状态的 Ping，我们需要使用几个聚合函数聚合取得结果。\n\t- 形状：停靠点的宽度、高度、面积、比例。\n\t- 停靠点类型：发动机关闭状态。\n\t- 停靠点中发动机关闭状态 Ping 的数量。\n\t- 里程表距离：从第一次 Ping 到最后一次 Ping 的里程表距离。\n\t- 停靠点内 Ping 的总数。\n\t- 平均速度 (根据停留点中第一次和最后一次 Ping 之间的里程差除以驻留时间计算所得)。\n- 兴趣点特征 ( Points of interest features，POIF)：利用 `PTV xLocate Server` 中提取以下 POI 类型：\n\t- 银行;\n\t- 大学;\n\t- 酒店;\n\t- 餐厅;\n\t- 休息区;\n\t- 杂货店;\n\t- 学校;\n\t- 购物中心;\n\t- 汽油;\n\t- 开放式停车场;\n- 汽车停靠点集群特征 ( Stop cluster features，CF )：描述当前停靠点集周围停靠点的特征所组成的特征集。其原理是，存在一些工作状态的工单和非工作状态的工单数据，趋向于聚类成簇。类似于 [7] 中提出的熵度量方法：对于每个停靠点，查看并收集 250 米半径内的周边环绕的停靠点数据。\n\t- 车辆熵，计算公式为：\n\n\t$$E_v = - \\sum_{\\nu \\in V} \n\t\t\\frac{n_{\\nu}}{N} ln(\\frac{n_{\\nu}}{N})\n\t\t\\tag{1}\n\t$$\n\t\n\t> $V$ 是车队中的车辆集合， $N$ 是 250 米半径范围内车队所有车辆的总停留点数，$n_{\\nu}$ 是车辆 $\\nu$ 在同一区域停靠的总次数。这个熵度量给出了一个区域内同一车队车辆的多样性。\n\t\n\t- 簇中汽车停靠点的平均，总和，最大和最小驻留时间。\n\t- 邻近汽车停靠点的数量 (在其质心250米半径以内)。\n\t\n- 序列特征 (Sequential features，SeqF)：\n\t- `工作日内停车的次序位置`：同一辆车在白天按照停车先后顺序的 (归一化的) 相对位置。\n\t- `停车所涵盖的时间百分比`：停车行为在工作日中的时间占比 ( 注意该值与工作日的开始相关，且工作日的开始由一天中第一个 Ping 定义 )。这也是司机夜间休息时间的近似假设。\n\n## 实验\n> 实验过程请参考原文献，篇幅问题就不照搬文章内容了。\n\n## 总结\n- 本文基于商用车队的 GPS 数据研究了停车目的识别和分类问题。\n- 为了建立地面真实数据集，通过查看考虑到每辆车的工作单进度数据，开发了一个时空聚类算法，实现了一个自动标注标签过程；\n- 为了提高分类精确度，从 GPS Ping 数据中提取了 4 组不同的特征 ( SWF、POIF、CF 和 SeqF )；\n- 利用提取的特征训练随机森林模型，并与两种基线模型进行性能比较。实验结果表明，本文提取总结的 4 组特征显著提高了随机森林的分类能力。\n\n## 不足\n- 在车辆停靠点侦查技术章节中，使用的是非监督方式的算法，即基于密度的 DBSCAN 聚类算法。其中涉及密度阈值的设定多少问题，就需要对具体样本量进行考究才能决定。\n- 数据集是否可用于处理多分类问题。例如，通过扩大标签集以包含更具体的停车类型，而不仅仅限制于二元标签 ( 工作状态与非工作状态 )。\n\n## 参考\n[1] Horozov T, Narasimhan N, Vasudevan V. Using location for personalized POI recommendations in mobile environments [C]//Applications and the internet, 2006. SAINT 2006. International symposium on. IEEE, 2006: 6 pp.-129.  \n[2] Jiang K, Yin H, Wang P, et al. Learning from contextual information of geo-tagged web photos to rank personalized tourism attractions [J]. Neurocomputing, 2013, 119: 17-25.\n[3] Palma A T, Bogorny V, Kuijpers B, et al. A clustering-based approach for discovering interesting places in trajectories [C]//Proceedings of the 2008 ACM symposium on Applied computing. ACM, 2008: 863-868.  \n[4] Gong L, Sato H, Yamamoto T, et al. Identification of activity stop locations in GPS trajectories by density-based clustering method combined with support vector machines [J]. Journal of Modern Transportation, 2015, 23(3): 202-213.  \n[5] Ester M, Kriegel H P, Sander J, et al. A density-based algorithm for discovering clusters in large spatial databases with noise [C]//Kdd. 1996, 96(34): 226-231.  \n[6] Lv M, Chen L, Xu Z, et al. The discovery of personally semantic places based on trajectory data mining [J]. Neurocomputing, 2016, 173: 1142-1153.  \n[7] Gingerich K, Maoh H, Anderson W. Classifying the purpose of stopped truck events: An application of entropy to GPS data [J]. Transportation Research Part C: Emerging Technologies, 2016, 64: 17-27.  \n[8] Sambo F, Salti S, Bravi L, et al. Integration of GPS and satellite images for detection and classification of fleet hotspots [C]//Intelligent Transportation Systems (ITSC), 2017 IEEE 20th International Conference on. IEEE, 2017: 1-6.  \n[9] Wolf J, Guensler R, Bachman W. Elimination of the travel diary: Experiment to derive trip purpose from global positioning system travel data [J]. Transportation Research Record: Journal of the Transportation Research Board, 2001 (1768): 125-134.  \n[10] Bohte W, Maat K. Deriving and validating trip purposes and travel modes for multi-day GPS-based travel surveys: A large-scale application in the Netherlands [J]. Transportation Research Part C: Emerging Technologies, 2009, 17(3): 285-297.  ","tags":["数据挖掘","聚类","机器学习","分类","特征提取"],"categories":["Paper"]},{"title":"论文 | 降维分类方法：以改进质谱流式细胞识别技术","url":"/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding.html","content":"\n{% note default %}\n原文：Automatic classification of cellular expression by nonlinear stochastic embedding (ACCENSE)  \n作者：Karthik Shekhar, Petter Brodin, Mark M.Davis and Arup K.Chakraborty.  \n来源：Proceedings of the National Academy of Sciences (PNAS), 2014, 111(1): 202-207.  \n{% endnote %}\n\n## 摘要\n\n质谱流式细胞技术（Mass cytometry）能够在单细胞水平上识别到近 40 种不同的蛋白质，即提供前所未有的多维信息。由于各式各样的细胞种群数据集的复杂性，要收集有用的生物学知识对计算工具也有新的要求。回顾之前的聚类方法，聚类需要特征（维度），而每一种蛋白质（细胞表征由不同蛋白质表示）可当作一种特征，聚类算法就会自动识别不同类型的簇群，即对于不同功能的细胞识别是基于细胞表征相似性来实现区分的。当然，经典方法存在一定局限性，例如单细胞分辨率的损失（特征或维度的减少）；经典方法需要预知簇中的对象数量（本文中指细胞亚群的规模数量）。\n\n<!-- More -->\n\n而该论文引入 `ACCENSE` ( Automatic classification of cellular expression by nonlinear stochastic embedding ) 高维单细胞数据分析工具：\n\n- 基于密度划分的非线性降维方法，降维方法采用 `t-Distributed Stochastic Neighbor Embedding (t-SNE)` 算法 $^{[1]}$。\n- 该算法非常适合于探索性数据分析，同时避免任何手动 `阀门（阈值）` 的需要，即有别于基于距离的方法（离群点判定）、基于密度的方法） 密度阈值设定）。\n- 化繁为简，在二维或三维图上展示不同功能的多元细胞群。\n\n再有，本论文将 ACCENSE 应用于 35 参数的质谱流式细胞技术，检测 CD8+ T 细胞的数量（数据来自于特定的无病原和无菌小鼠），并将细胞分层到表型亚群中。\n\n> 注意：对于具体的聚类算法、降维算法中，**特定的符号名称会以具体的对象名称替代**。\n\n## 正文\n\n### 背景介绍\n- 免疫系统包含了许多类型的细胞，它们在免疫应答过程中表现出多样化的功能和复杂方式的相互作用，即通过不同蛋白质的表征所定义，故个体细胞的功能与其细胞表型密切相关。这里启示我们，对于不同功能的细胞可通过细胞表型相似性进行聚类区分。\n\n- 传统流式细胞技术和质谱流式细胞技术的区别：\n\t- 传统流式细胞技术 ( Flow Cytometry ) $^{[2]}$ 中，用 `荧光基因` 标记的抗体染色，其通过单细胞分辨率的光发射信号对靶标蛋白进行量化。且由于有限的光谱和重叠的发射信号，每个细胞限制为 12-16 个参数进行量化。\n\n\t- 质谱流式细胞技术 ( Mass Cytometry ) $^{[3]}$ ，使用 `金属螯合探针` 可对单个细胞多达 42 个参数的进行量化。\n\n\t- 传统流式细胞技术和质谱流式细胞技术相比，主要有两点不同：  \n\t\t- 标签系统的不同，前者主要使用各种荧光基团作为抗体的标签，后者则使用各种金属元素作为标签；  \n\t\t- 检测系统的不同，前者使用激光器和光电倍增管，而后者使用 ICP 质谱技术。 \n\n### 聚类算法\n- 由 `质谱流式细胞技术产生的高维数据`，以生物学的方式解释是具有挑战性的。然而，很多聚类工具是基于细胞的蛋白表达相似性进行细胞分类的，\n- 例如，`SPADE 算法` $^{[4,5]}$ 使用多元信息定义细胞簇，并在树状结构中显示潜在的表型层次结构。但尚有不足之处：\n\t- 一是单细胞分辨率的损失；\n\t- 二是对目标集群数量的需要预知。\n\n### 降维算法\n\n> 关于 `降维算法` 在另外一篇博文也有提及，不妨参考学习：[利用 t-SNE 降维并可视化数据](https://www.kofes.cn/2018/11/The-Best-Way-to-Visualize-a-Dataset-Easily.html)。\n\n- 同样，降维算法以细胞表征 ( 由不同蛋白质表示 ) 的相似性为依据，把空间组织的细胞群在低维空间上聚类成不同的细胞亚群。以下罗列一些常见的降维算法。\n- `PCA 算法`：PCA 降维的大致思想就是，挑选特征明显的、显得比较重要的信息保留下来。在本论文中，Newell 等人将主成分分析 ( Principal component analysis，PCA ) 应用于 25 参数的质谱流式细胞技术，检测人的 CD8+ T 细胞的数量，且使用前三种主成分 ( 3D-PCA ) 分离细胞亚群。3D-PCA 以三个汇总变量表示数据，每个汇总变量都是原始维度的 `线性组合`，并去捕获投影后数据的方差，直至其取值为最大值。然而，PCA 能在数据中所有的可能线性组合中找到最优表达，但也存在限制条件：线性投影可能太严格而不能产生精确的表示 $^{[6]}$，故作者引入 t-SNE 算法继续展开研究。\n- `t-SNE 算法` $^{[7]}$：t-Distributed Stochastic Neighbor Embedding，数据降维与可视化的方法，具体的算法细节如下：\n\t- 让 $\\{x^{(i)}\\}$ 表示归一化的 N 维蛋白质表达向量编码的细胞表型 i ( i=1, 2, ..., M )。\n\t- 若在 2D 平面图下，$\\{y^{(i)}\\}$ 向量是高维向量 $\\{x^{(i)}\\}$ 对应于低维的映射，它使得具有相似表型的 T 细胞彼此靠近嵌入，表型不相似的则嵌入相对较远的距离。\n\t- 采用细胞 i 和 j 之间的成对概率 $\\{p_{i,j}\\}$ 表示 $\\{x^{(i)}\\}$ 与 $\\{x^{(j)}\\}$ 之间的相似性。\n\t- 若在 2D 平面图下，成对概率 $\\{q_{i,j}\\}$ 表示 $\\{y^{(i)}\\}$ 与 $\\{y^{(j)}\\}$ 之间的相似性。\n\t- 通过最小化 $\\{p_{i,j}\\}$ 与 $\\{q_{i,j}\\}$ 的 KL 散度 ( 可理解为代价函数 )，然后找出 \"最佳\" 嵌入向量 $\\{y^{(i)}\\}$，即它表示的意义是，高维转低维的表示信息能最大程度被保存下来。\n\t\n\t\t> K-L 散度 ( [详细见附录 1](#1-t-SNE-中的概率) )，Kullback-Leibler Divergence，又称相对熵，即描述两概率分布 P 和 Q 的差异。KL 散度公式 (1) 如下：\n\t\n\t$$D_{KL}(\\{p_{i,j}\\}|\\{q_{i,j}\\}) = \\sum_{i,j} p_{i,j} log \\frac{p_{i,j}}{q_{i,j}} \\tag{1}$$\n\t\n\t- $\\{y^{(i)}\\}$ 可以编码非线性关系，不像 PCA 中被约束为 $\\{x^{(i)}\\}$ 的线性组合。\n\t- `最佳嵌入` 是通过数值梯度下降法来确定的，即所有数据点的 KL 散度总和减小到最小 ( [详细见附录 2](#2-数值梯度下降法) )。\n\n### 识别细胞亚群\n- 使用一个高斯核函数，把 t-SNE 的二维细胞散点图加工成 `复合图像`，如图 1-1 (D) 所示。其中，$K_\\gamma(y)$ 通过计算低维空间中所有细胞的位置总和，以表示 t-SNE 二维映射图中细胞的局部密度：\n\n\t$$K_\\gamma(y) = (2 \\pi \\gamma^2)^{-1}\n\t\\sum_{y' \\in Y}exp( -\\frac{||y - y'||^{2}}{2\\gamma^2})\n\t\\tag{2}\n\t$$\n\n- 在本论文中，$K_\\gamma(y)$ 的 `局部最大值` 表示具有共同表型的 CD8+ T 细胞亚群，且使用了 Matlab 的峰值检测算法识别这些局部最大值。\n\n\t> 当然，也可以在嵌入点上使用 K-Means 聚类算法来识别 T 细胞子集，但其要求事先指定簇的数量。\n\t\n- 如何求得 `局部最大值`，关键是对于公式 (2) 中 $\\gamma$ 的参数设定多少有关。即通过比较不同的核-带宽 $\\gamma$ ( 核函数的方差，也可理解为窗口、邻域 ) 产生的结果，则存在一个 $\\gamma$ 值为表型空间中的局部和全局特征提供了准确的粗粒度表示。从图 1-2 中可得，即启示我们可以以数据驱动的方式，求得较合适的 $\\gamma$ 值，以近似地识别 CD8+ T 细胞的细胞亚群。\n\n### 相关图表\n- 如图 1-1 所示，ACCENSE 应用于质谱高维数据。\n\n![图1-1ACCENSE ACCENSE 应用于质谱高维数据](/images/illustration/Paper/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding_1-1.jpg)\n<center>图 1-1 ACCENSE 应用于质谱高维数据</center>\n\n(A) 质谱细胞计数数据集样本的图示。行对应于不同的细胞，而列对应于测量其表达 (细胞表面抗原和细胞内蛋白) 的不同标记的金属螯合抗体。每一元组对应于指示每个标记的表达水平的质荷比变换值 (反双曲函数)。(C) 来自SPF B6 小鼠的 CD8+ T 细胞的 2D t-SNE 图谱。每个点代表来自训练集的一个细胞 (M = 18304)，且数据点是通过对原始数据集进行下采样得到。(D) 通过使用基于 [高斯核密度变换](https://sklearn.apachecn.org/docs/0.21.3/27.html) ($K_{\\gamma}(y)\\,{,}\\,\\gamma = 7$)，将细胞的局部概率密度嵌入 (C) 的复合图像。并使用标准的峰值检测算法进行识别局部最大值，在二维密度图表示表型亚群的中心。\n\n- 如图 1-2 所示，展示了峰值随着 $\\gamma$ 的增加而变化。\n\n![图1-2展示了峰值随着γ的增加而变化](/images/illustration/Paper/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding_1-2.png)\n<center>图 1-2 展示了峰值随着 $\\gamma$ 的增加而变化</center>\n\n\n## 附录\n\n### 1 t-SNE 中的概率\n#### $p_{i,j}$ 概率\n- 基于蛋白质相似性，设 $p_{j|i}$ (i,j = 1, 2, ..., M) 表示细胞 i 将选择细胞 j 作为其最近邻的概率 ( $p_{j|i}$ 越大，$x^{(i)} 和 x^{(j)}$ 越近 )：\n\n$$\np_{j|i} = \\frac{\n\texp({-||x^{(i)} - x^{(j)}||^2} / {\n\t2\\sigma_i^2})\n}{ \n\t\\sum_{k \\neq i} exp({-||x^{(i)} - x^{(k)}||^2} / {\n\t2\\sigma_i^2})\n}, d_{i,j} = ||x^{(i)} - x^{(j)}||_2\n\\tag{3}\n$$\n\n- 对于概率 $p_{j|i}$ 的几点说明：\n\n\t- $d_{i,j}$ 可以使用其他距离范式替代欧式距离范式；\n\t- 原始的 SNE 算法是不对称的，为简化梯度公式，t-SNE 中让公式 (3) 的条件概率是对称的。即初始化 $p_{i|i} = 0$ ( 只考虑不同点两两之间的相似度 )，对于任意的 $p_{i|j} = p_{j|i}$，可得：\n\n\t$$\n\tp_{i,j} = \\frac{\n\t\tp_{j|i} + p_{i|j} \n\t}{2M} = \\frac{\n\t\texp({-d_{i,j}^2} / {\n\t\t2\\sigma_i^2})\n\t}{ \n\t\t\\sum_{k \\neq i} exp({-d_{i,k}^2} / {\n\t\t2\\sigma_i^2})\n\t}\n\tp_{i,j} = \\frac{\n\t\tp_{j|i} + p_{i|j} \n\t}{2N} \\\\\n\t( p_{j|i} = \\frac{p_{i,j}}{p_i}, \\,\n\tp_{i|j} = \\frac{p_{i,j}}{p_j}, \\,\n\tp_i = p_j = \\frac1M )\n\t\\tag{4}\n\t$$\n\t\n- 不同的点 $x_i$，方差 $\\sigma_i$ 的取值也是不同的。\n\t- 公式 (3) 中的方差 $\\sigma_i$ 是确保对于每一个细胞都有相同的困惑度 ( Complexity )。复杂度可理解为一个点附近的 `有效近邻点个数`。\n\t- 定义复杂度为 $P_i = 2^{H_{j|i}}$，其近似地解释为细胞 i 的最近邻点的数量。\n\t- 定义 $p_{j|i}$ 的香农熵 (信息熵) 为 $H_{j|i} = - \\sum_j p_{j|i} \\log_2 p_{j|i}$，且 $H_{j|i}$ 随着 $\\sigma_i$ 的增加而增加。\n\n\t\t> 在本论文中，t-SNE 图谱的复杂度被设定为 30，即 10-50 范围内的复杂度对最终结果的影响不大 (较好的鲁棒性)。\n\n#### $q_{i,j}$ 概率\n- 对于低维度下的 $\\{y_i\\}$，在原始的 SNE 算法 $^{[7]}$ 中 Hinton 和 Rowers 引用高斯分布函数定义 $q_{i,j}$，但在低维表达中发现了 `拥挤问题`。\n\n\t> `拥挤问题`：就是说各个簇聚集在一起，无法区分。譬如，有一高维度数据在降维到 10 维下可以有很好的表达，但是降维到两维后无法得到可信映射。具体情况是，10 维中有数个点之间两两等距离的，在二维下就无法得到可信的映射结果。  \n\t>\n\t> 进一步说明，假设一个以数据点 $x^i$ 为中心，半径为 r 的 m 维球(三维空间就是球)，其体积是按 $r^m$ 增长的，假设数据点是在 m 维球中均匀分布的，我们来看看其他数据点与 $x^i$ 的距离随维度增大而产生的变化。\n\n- t-SNE 减轻了拥挤问题，即使用更加偏重长尾分布的方式来将距离转换为概率分布 $^{[8]}$，故有 $q_{i,j}$：\n\n\t$$\n\tq_{i,j} = \\frac{\n\t\t(1 + ||y^{(i)} - y^{(j)}||^2)^{-1}\n\t}{ \n\t\t\\sum_{k \\neq i} (1 + ||y^{(i)} - y^{(k)}||^2)^{-1}\n\t}, \\Delta_{i,j} = ||y^{(i)} - y^{(j)}||^2\n\t\\tag{5}\n\t$$\n\n- 同样地，对于概率 $q_{i,j}$ 的几点说明：\n\t- $\\Delta_{i,j}$ 可以使用其他距离范式替代欧式距离范式；\n\t- 原始的 SNE 算法是不对称的，为简化梯度公式，t-SNE 中让公式 (5) 的条件概率是对称的。即初始化 $q_{i|i}=0$，对于任意的 $q_{i|j} = q_{j|i}$。\n\n### 2 数值梯度下降法\n- 在 [7] 中的概述过程，获得优化的梯度公式，如下所示:\n\n\t$$\n\t\\frac{\n\t\t\\partial D_{KL}(\\{p_{i,j}\\} | \\{q_{i,j}\\})\n\t}{\n\t\t\\partial_{y_t}^{(i)}\n\t} = 4 \\sum_j \\frac{\n\t\t(p_{i,j} - q_{i,j})\n\t}{\n\t\t(1 + ||y_t^{(i)} - y_t^{(j)}||^2)\n\t}\n\t(y_t^{(i)} - y_t^{(j)})\n\t\\tag{6}\n\t$$\n\n- 通过梯度下降法迭代计算局部最大值：\n\n\t$$\n\ty_{t+1}^{(i)} = y_{t}^{(i)} + \\eta(t) \\frac{\n\t\t\\partial D_{KL}(\\{p_{i,j}\\} | \\{q_{i,j}\\})\n\t}{\n\t\t\\partial_{y_t}^{(i)}\n\t} + \\alpha(t)(y_{t}^{(i)} - y_{t-1}^{(i)})\n\t\\tag{7}\n\t$$\n\n\t- $y_t^{(i)}$ 表示迭代 t 次的解，$\\eta(t)$ 表示学习速率，$\\alpha(t)$ 表示迭代 t 次的动量。\n\t- 学习速率初始值为 $\\eta(t) = 100\\,^{[9]}$，且动能量 $\\alpha(t)$ 设定为：\n\t\n\t$$\n\t\\alpha(t) = \\begin{cases} 0.8, & t < 300 \\\\\n\t0.5, & t \\geq 300 \\end{cases}\n\t$$\n\n## 不足\n- t-SNE 主要用于可视化，很难用于其他目的。譬如测试集合降维，因为他没有显式的预估部分，不能在测试集合直接降维。\n- 关于核-带宽 $\\gamma$ 参数设定问题：文中展示了 $\\gamma$ 参数的大小与识别细胞亚群能力的数量关系。然而，数据驱动方式虽能实现自动聚类，但缺乏对于 $\\gamma$ 参数设定范围该如何控制的说明。\n\n## 参考\n- [1] Maaten L, Hinton G. Visualizing data using t-SNE [J]. Journal of machine learning research, 2008, 9(Nov): 2579-2605.  \n- [2] Cantor H, Simpson E, Sato V L, et al. And functional studies of peripheral t-cells binding different amounts of fluorescent anti-thy 1.2 (theta) Antibody using a fluorescence--activated cell sorter (FACS) [J]. 1975. \n- [3] Bendall S C, Nolan G P, Roederer M, et al. A deep profiler's guide to cytometry [J]. Trends in immunology, 2012, 33(7): 323-332. \n- [4] Qiu P, Simonds E F, Bendall S C, et al. Extracting a cellular hierarchy from high-dimensional cytometry data with SPADE [J]. Nature biotechnology, 2011, 29(10): 886.  \n- [5] Bendall S C, Simonds E F, Qiu P, et al. Single-cell mass cytometry of differential immune and drug responses across a human hematopoietic continuum [J]. Science, 2011, 332(6030): 687-696.  \n- [6] Van Der Maaten L, Postma E, Van den Herik J. Dimensionality reduction: a comparative [J]. J Mach Learn Res, 2009, 10: 66-71.  \n- [7] Maaten L, Hinton G. Visualizing data using t-SNE [J]. Journal of machine learning research, 2008, 9(Nov): 2579-2605.\n- [[8] Chrispher. t-SNE 完整笔记 [OL]. www.datakit.cn. 2017.](http://www.datakit.cn/blog/2017/02/05/t_sne_full.html)  \n- [9] Jacobs R A. Increased rates of convergence through learning rate adaptation[J]. Neural networks, 1988, 1(4): 295-307.","tags":["数据挖掘","聚类","机器学习","降维","免疫表型"],"categories":["Paper"]},{"title":"论文 | 扩展 K-means 算法：混合数据类型的聚类方法","url":"/2018/06/Extensions-to-the-k-Means-algorithm-for-custering-large-datasets-with-categorical-values.html","content":"\n{% note default %}\n原文：Extensions to the k-means algorithm for clustering large datasets with categorical values  \n作者：ZHEXUE HUANG.  \n来源：Data mining and knowledge discovery, 1998, 2(3): 283-304.  \n{% endnote %}\n\n## 摘要\n\n在早期，大多数聚类工作主要集中在数值数据上，且它们主要是利用数值数据的固有几何特性，即数据点之间的 `距离函数` ([见附录1](#1-距离函数))。但是，数据挖掘应用程序通常涉及许多数据集，这些数据集是由混合数值属性和标称属性组成的，仅拥有数值数据的测量方法已无法满足混合数据类型的聚类工作。\n\n本论文基于经典的 K-Means 算法上，提出了两种聚类算法，分别应对 `标称域` 和 `混合数值与标称域` 属性值的聚类操作。首先介绍的是`K-Modes (K-众数)` 聚类算法，他运作的方式与 K-Means 相仿，只是它利用的是相异性度量处理标称对象，聚类中心以众数替代均值，且众数以基于频率的方法去迭代更新，直至 `聚类代价函数` 的结果最小化停止迭代。其次，是 `K-Prototype` 聚类算法，它定义了一组合的相异性度量值，进一步整合 `K-Means` 和 `K-Modes` 算法，以实现对混合数值与标称属性的对象进行聚类操作。\n\n<!-- More -->\n\n## 正文\n\n### 引入\n将数据库中的一组对象划分为同构组或集群是数据挖掘中最基本的操作。而讨论划分操作，自然离不开聚类。聚类是把每一组对象划分为一个簇，且同一簇中对象之间相似，而不同簇之间的对象相异。\n\n数据挖掘最显著的特征是处理复杂的大型数据集。特别地，数据集包含数以百万计由不同类型属性或变量描述的对象，由此数据挖掘操作和算法应充分考虑可扩展性，以应付处理不同类型的属性。\n\n在本论文中，提出的两个新聚类算法，即利用 `K-Means 范式` 对拥有标称属性的数据进行聚类。`K-Modes (K-众数)` 聚类算法，他运作的方式与 K-Means 相仿，只是它利用的是相异性度量处理标称对象，聚类中心以众数替代均值，且众数以基于频率的方法去迭代更新，直至 `聚类代价函数` 的结果最小化停止迭代。其次，是 `K-Prototype` 聚类算法，它定义了一组合的相异性度量值 $s^r + \\gamma s^c$，以实现对混合数值与标称属性的对象进行聚类操作。其中，$s^r$ 是由 `平方欧式距离` 定义的 `数值属性` 的相异性度量值，$s^c$ 是由 `两个对象间类别不匹配的数量` 定义的 `标称属性` 的相异性度量值，$\\gamma$ 是平衡数值属性和标称属性两部分的的权值，以避免偏向于某一属性。若聚类的效果更青睐于数值属性，则可以设定一个较小的 $\\gamma$ 值；反之，设定一较大的 $\\gamma$ 值。\n\n### 符号\n- 假设需要聚类的对象数据集储存在数据集 D 中。\n\t- 集合的属性 $A_1, A_2, ... , A_m$ 分别是值域 $D_1, D_2, ... , D_m$ 的描述。\n\t- 在 D 中的每个对象由元组 t 表示，$t \\in D_1 \\times D_2 \\times ... \\times D_m$。\n- 针对本文讨论的聚类问题，仅考虑两种常见数据类型：数值类型和标称类型。\n\t- 数值域的取值范围是实数域。\n\t- 在多维的密度空间中，每一个数值型的数据点都采用诸如欧式或马氏的距离度量方法。\n\t- 若值域 $D_i$ 被定义为有限、无序的标称域，则对象的比较操作只允许在 $D_i$ 中执行，即有 $a, b \\in D_i$，either a = b or $a \\neq b$。\n- 对于数据集中的每一数据对象 $X$，也可由 `属性-属性值` 的键值对表示，\n\n\t$$[A_1=x_1] \\bigwedge [A_2=x_2] \\bigwedge ... \\bigwedge [A_m=x_m]$$\n\n- 即当 $x_i \\in D_i$，for i = 1, 2, ..., m。为简单起见，这里以 $X$ 表示元组：\n\n\t$$[x_1^r, x_2^r, ...,x_p^r, x_{p+1}^c, ..., x_m^c] \\in D_1 \\times D_2 \\times ... \\times D_m$$\n\n\t> 最后一个数值对象为元素 $p$ ，其余的都是标称对象。当然，若元组中仅有一种数据类型，可表示为 $[x_1, x_2, ..., x_m]$。\n\n### K-Means (均值) 算法\n- K-Means，是一种划分或非分层的聚类算法，为进一步阐述细节，需给出如下设定：\n    - 一组含 $n$ 个数值数据的对象集 $D = \\{X_1, X_2, ..., X_n\\}$；\n    - 距离度量 $d$；\n    - 自然数 $k (\\leq n)$，并把 $D$ 划分 $k$ 个非空且相分离的簇群：\n    $$\n    C_1, C_2, ..., C_k, \\, with \\, C_i \\bigcap C_j = \\emptyset \\, and \\, \\bigcup_{i=1}^k C_i = D\n    $$\n    - $D$ 中随机选取 $k$ 个对象，每个对象代表一个簇的初始均值或中心。\n- 如此一来，使得数据对象与其簇的中心之间的平方误差总和被最小化。然后，根据非线性优化问题，将该问题描述为:\n\n    $$\n    Minimise \\, P(W,Q) = \\sum_{l=1}^k \\sum_{i=1}^n w_{i,l} d(X_i, Q_l)\n    \\tag{1}\n    $$\n\n    且服从：\n\n    $$\n    \\begin{cases}\n    \\sum_{l=1}^k w_{i,l} = 1, \\, i = 1, 2, ..., n \n    \\\\ w_{i,l} \\in \\{0,1\\}, \\, i = 1, 2, ..., n; l = 1, 2, ..., k\n    \\end{cases}\n    \\tag{2}\n    $$\n    \n   - $w_{i,l}$ 指标变量表示对象 $X_i$ 仅属于哪一个簇。即取值为 1 时，表示对象 $X_i $ 在 簇 $C_l$ 中；反之，取值为 0。\n   - $W = \\left[ w_{i,l} \\right]_{n \\times k}$ 是分块矩阵 (见公式 3)，$Q = \\{Q_1, Q_2, ..., Q_K\\}$ 是簇的中心集合，$d(·,·)$ 是两对象间的平方欧式距离 ([见附录1](#1-距离函数))。\n\n   $$W = \\left[ w_{i,l} \\right]_{n \\times k} = \n   \\begin{bmatrix} \n   w_{11} & \\cdots & w_{1l} & \\cdots & w_{1k} \\\\ \n   \\vdots & & \\vdots & & \\vdots \\\\\n   w_{i1} & \\cdots & w_{il} & \\cdots & w_{ik} \\\\\n   \\vdots & & \\vdots & & \\vdots \\\\\n   w_{n1} & \\cdots & w_{nl} & \\cdots & w_{nk} \\\\ \n   \\end{bmatrix}\n   \\tag{3}\n   $$\n\n- 紧接着，在约束条件 (2) 下对 (1) 中的 P 进行优化，即对 Q 和 W 进行局部优化。首先，我们先固定 Q 并找出必要条件 W 使 P 最小化。然后，根据 Q 去修正 W 并最小化 P。基于上述几点，若为了达到 P 最小化，K-Means 算法通过 `三步迭代`，直到 P(W, Q) `收敛` 到某个 `局部最小值`。\n    - `Step.01`： 初始化 $Q^{(0)} = \\{Q_1^{(0)}, Q_2^{(0)}, ..., Q_k^{(0)}\\}$，且设立 $t = 0$。\n    - `Step.02`：固定 $Q^{(t)}$ 不变，求解 $P(W, Q^{(t)})$ 再去获得 W，即以 Q 作为簇群的中心，将每个对象分配到距离其最近的簇中心的簇群当中。\n    - `Step.03`：固定 $W^{(t)}$  不变，生成 $Q^{(t+1)}$，求解 $P(W^{(t)}, Q^{(t+1)})$。比较 $P(W, Q^{(t)}) \\, and \\, P(W^{(t)}, Q^{(t+1)})$，若后者为最小化，则根据当前的对象部分构造新的簇群中心。\n        - $Q_t^{t+1} = \\{q_{l,1}^{(t+1)}, ..., q_{l,m}^{(t+1)}\\}, \\, for \\, l = 1, 2, ..., k$，且：\n    \n        $$\n        q_{l,j}^{(t+1)} = \\frac {\n            \\sum_{i=1}^n w_{i,l}^{(t)} x_{i,j}\n        }{\n            \\sum_{i=1}^n w_{i,l}^{(t)}\n        }, \\, j = 1, 2, ..., m\n        \\tag{4}\n        $$\n        \n    - `Step.04`：当满足收敛或给定的停止条件时 ( `局部最优化` )，输出结果并停止；反之，令 $t = t + 1$，并继续从 `Step.02` 开始执行。\n- 为了解决 `簇间边界不明确` 的问题，模糊分区的概念成功地应用到聚类问题中，即模糊聚类 $^{[2,3]}$。但是，我们在本论文中不考虑这个问题。\n- 综上所述，K-Means 算法具有以下特征：\n    - 局部最优化为算法结束的终止条件；\n    - 仅适用于数值属性数据的聚类；\n    - 簇群的特征为球形簇.\n\n### K-Modes (众数) 算法\n原则上，K-Means 算法中问题 P 的公式对于分类和混合类型的对象也是有效的，之所以 K-Means 算法不能对标称属性对象进行聚类的原因是它的相异性度量方法和用于构造新的簇群中心的方法不适用，故通过对 K-Means 算法进行以下修改，可消除不适用问题：\n\n- 用于标称属性对象的相异性度量的方法；\n- 簇群的中心以 `众数` 替代 `均值`；\n- 使用基于频率的方法求的众数，以构造新的簇群中心。\n\n#### 相异性度量\n相异性度量：设 $X,Y$ 是由 m 个标称属性描述的两个标称属性对象， $X,Y$ 的相异性度量可通过两个对象间相对应属性的不匹配总和来定义，即不匹配的次数越少，两个对象越相似。定义如下：\n\n$$\nd_1(X,Y) = \\sum_{j=1}^m \\delta (x_j,y_j)\n\\tag{5}\n$$\n\n 且满足条件：\n\n$$\n\\delta (x_j,y_j) = \\begin{cases}\n0 , \\, (x_j = y_j) \\\\\n1 , \\, (x_j \\neq y_j)\n\\end{cases}\n \\tag{6}\n$$\n\n#### 众数集\n设 $X$ 是由标称属性 $A_1, A_2, ..., A_m$ 描述的标称属性对象集。$X= \\{X_1, X_2, ..., X_n\\}$ 的众数由向量 $Q =\\{q_1, q_2, ..., q_m\\}$ 表示，并最小化函数：\n\n$$\nMinimise \\, D(X,Q) = \\sum_{i=1}^n d_1(Xi,Q)\n\\tag{7}\n$$\n\n>  注意，这里 $Q$ 并不一定是 $X$ 中包含元素 (有别于 K-Medoids 算法 $^{[4]}$，质心从它的样本点中选择 )。    \n\n#### 挑选众数\n设 $n_{c_{k,j}}$ 为属性 $A_j$ 中包含第 k 个标称属性 $c_{k,j}$ 的对象数量，且定义 $f(A_j = c_{k,j} | X) = \\frac{ n_{c_{k,j}} }{n}$ 为标称属性 $c_{k,j}$ 在 $X$ 中的出现频率。\n\n- `定理 1`：若满足下述条件 (8)，即 $D(X,Q)$ 已最小化 ( 证明见[附录2](#2-定理证明) )。即定理定义了一种从给定的 $X$ 中找到 $Q$ 的方法，即它允许使用 K-Means 范式来聚类标称数据，且定理 1 暗示了数据集 $X$ 的众数不是唯一的。 \n\n    $$\n    f(A_j = q_j | X) \\geq f(A_j = c_{k,j} | X) \\, for \\, q_j \\neq c_{k,j},j=1, 2, ..., m\n    \\tag{8}\n    $$\n\n#### 算法核心\n- 当公式 (5) 用作标称属性对象的相异性度量时，公式 (1) 的代价函数将推导为：\n\n$$\nP(W,Q) = \\sum_{l=1}^k \\sum_{i=1}^n \\sum_{j=1}^m w_{i,l} \\delta(x_{i,j},q_{l,j})\\\\\\ where \\, w_{i,l}  \\in W \\, and \\, Q_l = [q_{l,1}, q_{l,1}, ..., q_{l,m}] \\in Q\n\\tag{9}\n$$\n\n- 为了最小化代价函数，则修改经典 K-Means 算法：\n    - 以相异性度量方法求解 $W$，即上述 `Step.02` 所描述的，以当前 $Q$ 为簇群中心，将每个对象分配到距离其最近的簇中心的簇当中去；\n    - 用簇的众数代替均值，根据 `定理 1` 选择众数来求解  $Q$，即上述 `Step.03` 所描述的，求得新的簇群中心。\n- 在经典算法中，我们需要在每次获得一个新的 $Q$ 或 $W$ 时，根据整个数据集计算总代价 P。为了提高计算效率，我们在实践中采用了下面的算法。\n    - `Step.01`：初始化 k 个众数，且每个众数对应一个簇；\n    - `Step.02`：根据公式 (5)，将距离众数最近的对象分配该簇当中。再根据 `定理 1`，在每次分配后更新簇群的众数。\n    - `Step.03`：当所有对象分配到具体的簇群之后，重新测试对象与当前众数的相异性。如果找到一个对象，距离其最近的众数属于另一个簇群而不是当前的簇群，则将该对象重新分配给该簇群，并更新两个簇群的众数。\n    - `Step.04`：重复执行 `Step.03`，直到对整个数据集进行完整的循环测试之后，没有对象更改簇群。\n\n        > 目前，虽没有证明该算法的收敛性，但在实际使用过程中，它的表现总是收敛的。\n\n- 与 K-Means 算法一样，K-Modes 算法也是产生 `局部最优解`，且依赖于数据集中的 `初始的众数` 和 `对象的顺序`。考虑 `初始的众数` 和 `对象的顺序` 的因素影响，我们通过两种方法改进算法。\n    - 第一个方法是第一次从数据集中选择 $k$ 个不同的记录作为初始 $k$ 个众数值。\n    - 第二个方法通过以下步骤实现：\n        - `Step.01`：计算所有属性的所有标称值的频率，并按照频率的降序将它们存储在一个标称类型的数组中，如图 2-1 所示，展示了标称类型数组中，分别包含 4、2、5、3 个标称值的 4 个属性。这里 $c_{i,j}$ 表示属性 $i$ 的标称值 $j$，$f(c_{i,j})$ 为标称值的频率，且 $f(c_{i,j}) \\geq f(c_{i+1,j})$。\n        - `Step.02`：将频率最高的标称值作为 $k$ 个众数的初始值。\n        - `Step.03`：从 $Q_1$ 开始，选择相似性最接近其的记录并替换它的初始众数。以此类推，直至 $Q_k$  的初始众数被替换完成。其中，$Q_l \\neq Q_t \\, for \\, l \\neq t$。\n        \n            > `Step.03` 的目的在于避免空簇群的情况，致使初始众数具有多样性，以获得更好的聚类结果。\n\t\n\t$$\n\t\\begin{Bmatrix} \n\tc_{1,1} & c_{1,2} & c_{1,3} & c_{1,4} \\\\ \n\tc_{2,1} & c_{2,2} & c_{2,3} & c_{2,4} \\\\ \n\tc_{3,1} & \\, & c_{3,3} & c_{3,4} \\\\ \n\tc_{4,1} & \\,  & c_{4,3} & \\, \\\\ \n\t\\,  & \\,  & c_{5,3} & \\, \\\\ \n\t\\end{Bmatrix}\n\t$$\n\n\t<center>图 2-1 标称类型数组 ( 横向表示集合的属性 A，纵向表示簇中心点 Q )</center>\n\t\n### K-Prototypes 算法\n- 将 K-Means 和 K-Modes 算法集成到 K-Prototypes 算法中是很容易的，这种算法用于混合类型对象的簇群聚类。\n\t\n- 在混合对象 $X$ 和 $Y$ 间的相异性可由属性 $A_1^r, A_2^r, ..., A_p^r, A_{p+1}^c, ..., A_m^c$ 描述，并定义其相异性度量为：\n\t\n    $$\n    d_2(X,Y) = \\sum_{j=1}^p (x_j - y_j)^2 + \\gamma \\sum_{j=p+1}^m \\delta(x_j,y_j)\n    \\tag{10}\n    $$\n\n     > 其中，第一项是数值属性的平方欧氏距离度量，第二项是标称属性的相异性度量。权重 $\\gamma$ 是用来避免偏袒任何类型的属性，即聚类结果更趋向于数值属性还是标称属性。\n\n- 当公式 (10) 用作混合类型属性对象的相异性度量时，公式 (1) 的代价函数将推导为：\n\n    $$\n    P(W,Q) = \\sum_{l=1}^k (\n        \\sum_{i=1}^n w_{i,l} \\sum_{j=1}^p(x_{i,j}-q_{l,j})^2\n        + \\gamma \\sum_{i=1}^n w_{i,l} \\sum_{j=p+1}^m \\delta(x_{i,j}-q_{l,j})\n    )\n    \\tag{11}\n    $$\n    \n    > $ \\sum_{i=1}^n w_{i,l}$ 即公式 (2) 所描述的，每个簇对象只对应一个簇中心。\n    \n    - 为简化公式 (11)，让：\n\n    $$\n    P_l^r = \\sum_{i=1}^n w_{i,l} \\sum_{j=1}^p(x_{i,j}-q_{l,j})^2\n    \\tag{12}\n    $$\n    \n    $$\n    P_l^c =  \\gamma \\sum_{i=1}^n w_{i,l} \\sum_{j=p+1}^m \\delta(x_{i,j}-q_{l,j})\n    \\tag{13}\n    $$\n    \n    - 重写公式 (11)：\n\n    $$\n    P(W,Q) = \\sum_{l=1}^k (P_l^r + P_l^c)\n    \\tag{14}\n    $$\n\n - $P_l^r$ 和 $P_l^c$ 都是非负的，最小化 $P(W,Q)$ 等同于最小化 $P_l^r$ 和 $P_l^c$，$1 \\leq l \\leq k$。\n\n## 附录\n\n### 1 距离函数\n`距离函数`：关于数据点之间的距离函数，即数值属性刻画的对象相异性的距离度量。度量方法 $^{[1]}$ 包括闵可夫斯基距离 (闵氏距离)、欧几里得距离 (欧式距离) 和曼哈顿距离。\n\n令 $i=(x_{i1},x_{i2},...,x_{ih})$ 和 $j=(x_{j1},x_{j2},...,x_{jh})$ 是两个被 p 个数值属性描述的对象。 \n\n闵氏距离是欧式距离和曼哈顿距离的推广，定义如下：\n\n$$\nd(i, j) = \\sqrt[h](\n\t\\sum_{f=1}^p |x_{if}-x_{jf}|^{h}\n),h \\geq 1\n\\tag{1}\n$$\n\n- 当 h = 1 时，它表示 `曼哈顿距离`，也称 `城市块` 距离 (城市两点之间的街区距离，如向南 2 个街区，横过 3 个街区，共计五个街区)，其定义如下：\n\n$$\nd(i, j) = \\sum_{f=1}^p |x_{if}-x_{jf}|,h \\geq 1\n\\tag{2}\n$$\n\n- 当 h = 2 时，它表示 `欧式距离`，也称 `直线或乌鸦飞行` 距离，其定义如下：\n\n$$\nd(i, j) = \\sqrt(\\sum_{f=1}^p (x_{if}-x_{jf})^2)\n,h \\geq 1\n\\tag{3}\n$$\n\n- 当 h = $\\infty$ 时，它表示 `上确界距离`，又称 `切比雪夫距离`，其定义如下L：\n\n$$\nd(i, j) = \\lim_{h \\to \\infty} (\n\t\\sum_{f=1}^p |x_{if}-x_{jf}|^h\n)^\\frac{1}{h} = \\max^{p}_{f} |x_{if}-x_{jf}|\n\\tag{4}\n$$\n\n### 2 定理证明\n`定理 1` 的证明如下：\n\n- 让 $f_r (A_j = c_{k,j} | X) = \\frac { n_{c_{k,j}} }{n}$ 为属性 $A_j$ 的第 $k$ 个标称属性 $c_{k,j}$ 的相对频率，$n$ 是 $X$ 中对象的总数，$n_{C_{k,j}}$ 是拥有标称属性 $c_{k,j}$ 的对象的计数。\n- 则有，相异性度量公式可推导为：\n\n$$\n\\sum_{i=1}^n d(X_i,Q) = \\sum_{i=1}^n \\sum_{j=1}^m \\delta(x_{i,j},q_j)\n\\\\ = \\sum_{i=1}^n ( \\sum_{j=1}^m \\delta(x_{i,j},q_j) )\n= \\sum_{i=1}^m n(1-\\frac{n_{q_j}}{n})\n= \\sum n( 1-f_r(A_j = q_j | X) )\n$$\n\n- 因为 $n( 1-f_r(A_j = q_j | X) ) \\geq 0 \\, , \\, 1 \\leq j \\leq m$，若让 $\\sum_{i=1}^n  d(X_i,Q)$ 最小化，则需让每一个 $n( 1-f_r(A_j = q_j | X) )$ 取最小值，即 $f_r(A_j = q_j | X)$ 必须取最大值。\n\n## 思考\n\n## 参考\n[1] Jiewei Han, Micheline Kamber and Jian Pei. 数据挖掘 (第三版) [M]. 机械工业出版社, 2018, 48-49.  \n[2] Bezdek J C. A convergence theorem for the fuzzy ISODATA clustering algorithms [J]. IEEE transactions on pattern analysis and machine intelligence, 1980 (1): 1-8.  \n[3] Ismail M A, Selim S Z. Fuzzy c-means: optimality of solutions and effective termination of the algorithm[J]. Pattern recognition, 1986, 19(6): 481-485.  \n[4] Park H S, Jun C H. A simple and fast algorithm for K-medoids clustering[J]. Expert systems with applications, 2009, 36(2): 3336-3341.  ","tags":["数据挖掘","聚类","机器学习","混合类型","K-Means"],"categories":["Paper"]},{"title":"论文 | 通过密度峰值进行聚类分析的方法","url":"/2018/05/Clustering-by-fast-search-and-find-of-density-peaks.html","content":"\n\n{% note default %}\n原文：Clustering by fast search and find of density peaks  \n作者：Alex Rodriguez and Alessandro Laio  \n来源：Science 344.6191(2014), 1492-1496.\n{% endnote %}\n\n\n## 摘要\n\n聚类分析的目的在于根据元素的相似性将元素分类。而该论文基于这样一种观点的提出新的方法，即聚类中心的密度高于其邻居，而密度高的点相对较远。这个想法构成了聚类过程的基础，其中簇的数量直观地产生，异常值被自动地发现并从分析中排除，并且聚类被识别，而不管它们的形状和嵌入它们的空间的维度如何。\n\n<!-- More -->\n\n## 正文\n\n### 不同的聚类策略\n\n#### 基于距离的方法\n在 `K-means` 和 `K-medoids`，聚类是以距离聚类中心很小的距离为特征的数据集合。\n\n然而，因为数据点总是被分配到最近的中心，所以该类算法只能发现球形的簇，而在发现任意形状的簇时会遇到困难。\n\n> 提示：`K-均值 (K-Means)` 的方法仅当簇中均值有定义时才有意义，而当涉及具有标称属性的数据时，K-均值的方法失效。而这里可采用 `K-众数 (K-Modes)` 的变体，即采用 `基于频率` 的方法来更新簇的众数，对具有标称属性的数据进行聚类。当然，还有 `K-Prototype` $^{[1,2]}$、`K-Means++` $^{[3]}$ 等优化版本的算法。\n\n#### 基于密度的方法\n通过基于数据点局部密度的方法很容易检测具有任意形状的簇。其主要思想是：在某领域 (对象或数据点的数目) 内，给定密度阈值，将密度低于该阈值的数据点视为噪声丢弃，并将其分配给不连续的高密度领域的其他簇。这样的方法可用来过滤噪声或离群点，发现任意形状的簇。\n\n`DBSCAN` (Density-Based Spatial Clustering of Applications with Noise) 是一个基于密度的聚类算法，它将簇定义为密度相连的点的最大集合，能够把具有足够高密度的领域划分为簇。在噪声的空间数据库中可发现任意形状的聚类。\n\n然而，从上述当中可知，除了要选择合适的阈值，且它缺少均值漂移的聚类方法。虽然这种方法允许发现非球形簇，但仅适用于由一组坐标定义的数据。\n\n#### 本文改进的方法\n首先，该算法提出假设：类簇中心被具有较低局部密度的 `邻居点` 包围，且与具有较高密度的 `任何点` 有相对较大的距离。对于每一个数据点 i，要计算 `两个量`：点的局部密度 $\\rho_i$ 和该点到具有更高局部密度的点的距离 $\\delta_i$。而这两个值都取决于数据点间的距离 ${d}_{ij}$ (欧几里得距离，也称 `欧式距离`)。数据点的局部密度定义为：\n\n$$ \\rho_i = \\sum_j \\chi(d_{ij} - d_c) $$\n\n\n其中 $\\chi(x)$ 为 0-1 函数，如果 x < 0，那么 $\\chi(x) = 1$；否则 $\\chi(x) = 0$，$d_{c}$ 是一个 `截断距离`。基本上，$\\rho_i$ 等于与点 i 的距离小于 $d_{c}$ 的点的个数。算法只对不同点 $\\rho_i$ 的相对大小敏感，这意味着对于大数据集，分析结果在 $d_{c}$ 的选择方面具有很好 `鲁棒性`。\n\n- $\\delta_i$ 是通过计算点之间的 `最小距离` 来测量的，即数据点 i 与距离它最近的、密度更高的点 j 的距离最小值式：\n\n\t> 提示：在图 1-1.(A) 中可知，数据点是按照密度降序排列。\n\n$$ \\delta_i = min_{j:\\rho_j>\\rho_i}(d_{ij}) $$\n\n- 若数据点 i 是密度最大的点，$\\delta_i$ 为所有节点中到数据点 i 的最大距离：\n\n$$ \\delta_i = max_j(d_{ij}) $$\n\n如图 1-1 所示，其展示了算法的核心思想。图 1-1.(A) 展示了二维空间中的 28 个点，`且 A 中数据点是按照密度降序排列`。图 1-1.(B) 中以 $\\rho_i$ 作为横坐标，$\\delta_i$ 作为纵坐标，画二维图，并称其为决策图。可以发现点 1 和点 10 的  $\\rho_i$ 和 $\\delta_i$ 最大，故将其作为类簇中心。\n\n> 点 9 和点 10 的 $\\rho_i$ 相似，但 $\\delta_i$ 值却有很大差别：点 9 属于点 1 的类簇，且有其它几个更高 $\\rho_i$ 的点距其很近，然而点 10 拥有更高密度的最近邻属于其它的类簇。  \n> \n> 所以，正如预期的那样，只有具有高 $\\delta_i$ 和相对较高 $\\rho_i$ 的的点才是 `类簇中心`。因为点 26、27、28 是孤立的，所以有相对较高的 $\\delta_i$ 值和低 $\\rho_i$ 值，它们可以被看作是由单个点做成的类簇，也就是 `异常点`。\n\n![图1-1算法在二维空间的展示](/images/illustration/Paper/2018/05/Clustering-by-fast-search-and-find-of-density-peaks_1-1.jpg)\n<center>图 1-1 算法在二维空间的展示</center>\n\n类簇中心找到后，剩余的每个点被归属到它的有更高密度的最近邻所属类簇。类簇分配只需 `一步即可完成`，不像其它算法要对目标函数进行 `迭代优化`。\n\n在聚类分析中，定量的衡量分配的可信度是很重要的。在该算法中，首先为每个类簇定义一个 `边界区域` (即分配到该类簇的点集合，且与其它类簇的点的距离小于 $d_c$)，然后为每个类簇的找到其边界区域中密度最高的点 $\\rho_b$，并以来表示该点的密度。若类簇中局部密度值比 $\\rho_b$ 大的点被看作是类簇的核心部分 (即分配到该类簇的可靠性较高)，其他点 (类簇中局部密度值比 $\\rho_b$ 小的点) 被看作是类簇的 `光晕部分` (亦可被看作是噪声)。\n\n![图1-2合成点分布的结果](/images/illustration/Paper/2018/05/Clustering-by-fast-search-and-find-of-density-peaks_1-2.jpg)\n<center>图 1-2 合成点分布的结果</center>\n\n(A) 为绘制点分布的概率分布。(B和C) 分分别为 4000 和 1000 样本点的点分布。且每个点以其颜色表示所属类簇，黑色点属于光晕类簇 (噪声点)。(D和E) 为 (B和C) 相应的决策图，其中心由相应簇来着色。(F) 作为样本维度的函数，分配给不正确聚类的点的分数。误差线表示平均值的标准误差。\n\n从图 1-2.(F) 中可以看到，错分点的比例即使在只有 1000 个点的小样本中仍保持在 1% 以下，说明算法有很好的鲁棒性。\n\n从图 1-3 中可以看到，该算法对于各种数据级都能达到很好的聚类效果 (图中为引用文献中的测试用例结果)。\n\n![图1-3引用文献中的测试用例结果](/images/illustration/Paper/2018/05/Clustering-by-fast-search-and-find-of-density-peaks_1-3.jpg)\n<center>图 1-3 引用文献中的测试用例结果</center>\n\n## 思考\n\n1. 摘要部分提到的，异常点能 `自动地` 被分析出来，但从它的 Matlab 源码可知，还是需要人为判断异常点 (与问题三结合思考)？\n2. 文中提到的截断距离 $d_c$，该设定多少才算较合理？\n3. 文中判断簇中心的两个参数量 $\\delta_i$ 和 $\\rho_i$，即同时具有相对较高的距离和局部密度可选为簇中心，那么如何定义相对较高的具体值？\n\n## 参考\n\n[1] Huang Z. Clustering large data sets with mixed numeric and categorical values [C]. 1997: 21-34.  \n[2] Huang Z. Extensions to the k-means algorithm for clustering large data sets with categorical values [J]. Data mining and knowledge discovery, 1998, 2(3): 283-304.  \n[3] San O M, Huynh V N, Nakamori Y. A clustering algorithm for mixed numeric and categorical data [J]. Journal of Systems Science and Complexity, 2003, 16(4): 562-571.  \n\n","tags":["数据挖掘","聚类","机器学习"],"categories":["Paper"]},{"title":"高级软件工程与导论","url":"/2018/05/Sofeware-Engineering.html","content":"\n在软工系列课程上，老师常提及的一条等式  `软件 = 程序 + 软件工程` ( 或 `软件 = 程序 + 文档`)，即一般情况讨论，一款软件产品的诞生之际总是伴随着一系列的软件过程。\n\n那么如何充分理解软件工程 (过程)？从本书作者理念出发，我所理解的即应该时刻对软件产品持有 `生命周期` 的思维模式，将 `需求、建模、设计、实现、测试、维护` 等工程阶段联系起来，以自身代入案例环境中，去模拟开展软件过程的一系列活动，而非割裂。而这样的动态过程中，不仅仅是枯燥地学习理论、方法，则更像是问题所需、问题导向的理论应用过程。\n\n当然，软件工程作为一门工程学科，学习过程的最大收获可以说是对 `项目思维模式` 的掌握。譬如，我们可以抛开软件产品的范畴，谈谈现实生活的实例：假若你需要在一定时限内掌握一门新知识、任务，则我们的做法可以从调研、计划、布局、实施，直至验收，即类似的过程可复用软件工程的方法。\n\n最后，也是想声明的一点：学习软件工程的过程中，无可避免地将反映本人的一些观点、倾向，当然这也反映该学科需要 `多沟通` 的特点，若有不恰当、错误之处，欢迎大伙出建议、斧正。\n\n<!-- More -->\n\n- 参考书目：\n\t- 《 软件工程 》. Ian Sommerville 著：计算机科学丛书，且是著名软件工程学家 Ian Sommerille 系统介绍软件工程理论的经典教材。\n\t- 《 构建之法(第二版) 》: 待整理。贴上本书豆瓣的书评，供朋友评判，做出抉择。[构建之法(第二版)](https://book.douban.com/subject/26577755/) \n\n## 更新进程\n- 2018.05.02：完成初稿；\n- 2018.05.04：更新正文：导论部分  (第 4 / 8 章)；\n\n## 零 内容总览\n- 软件工程导论\n\t- [壹 软件过程](#壹-软件过程)\n\t- [贰 敏捷软件开发](#贰-敏捷软件开发)\n\t- [叁 需求工程](#叁-需求工程)\n\t- [肆 系统建模](#肆-系统建模)\n\t- [伍 体系结构设计](#)\n\t- [陆 设计与实现](#)\n\t- [柒 软件测试](#)\n\t- [捌 软件进化 / 软件维护](#)\n- 高级软件工程\n\t- [玖 软件复用](#)\n\t- [拾 基于组件的软件工程](#)\n- 软件管理\n\t- [拾壹 项目管理](#)\n\t- [拾贰 项目规划](#)\n\n## 壹 软件过程\n\n- 学习目标\n\t- 3个一般的 `软件过程模型`；\n\t- 了解软件需求工程、开发、测试和进化中所涉及的 `基本过程活动`；\n\t- 理解为什么软件过程要有效地组织以应对软件需求和设计上的变更；\n\t- Rational 统一过程 (RUP).\n- 软件过程必须具有的基本活动\n\t- 软件描述\n\t- 软件设计和实现\n\t- 软件有效性验证\n\t- 软件进化\n- 没有“理想”的软件过程 -- 寻找平衡点\n\t- 计划驱动过程：提前计划好所有的过程活动，再按计划去考核过程的执行。\n\t- 敏捷过程：计划是增量式的，且容易根据不断变化的客户需求变更过程。更多详细内容见 `第叁章`。\n\t\n### 软件过程模型\n- 软件过程：产生一个软件系统的一系列活动。\n- 软件过程的简化表示 (抽象表示)。\n- 每个过程模型都是从一个特定的侧面表现软件过程，所以只提供过程的部分信息。\n\n\t> 如过程活动模型表现了这些活动和他们的顺序，但可能表现不出人们在这些活动中的角色。\n\t\n#### 瀑布模型\n![图1-1瀑布模型](/images/illustration/Reading/2018/05/Sofeware-Engineering_1-1.png)\n<center>图 1-1 瀑布模型</center>\n\n- 计划驱动模型；\n- 该模型将基本的过程活动、描述、开发、有效性验证和进化，看成是一些界限分明的独立的过程阶段。\n\t- 需求分析和定义：通过咨询系统用户建立系统的服务、约束和目标，并对其详细定义形成系统描述。\n\t- 系统和软件设计\n\t\t- 系统设计 -- 建立系统的总体体系结构，将需求区分为硬件需求和软件需求。\n\t\t- 软件设计 -- 识别和描述一些基本的软件系统抽象及其之间的关系。\n\t- 实现和单元测试\n\t\t- 软件设计实现 -- 实现为一组程序或程序单元。\n\t\t- 单元测试 -- 验证每个单元是否符合其描述。\n\t- 集成和系统测试\n\t\t- 集成 -- 集成单个的程序单元或一组程序。\n\t\t- 系统测试 -- 评估系统的可靠性；是否满足软件需求。\n\t- 运行和维护\n\n#### 增量式开发\n![图1-2增量式开发](/images/illustration/Reading/2018/05/Sofeware-Engineering_1-2.png)\n<center>图 1-2 增量式开发</center>\n\n- 即可是计划驱动的，也可是敏捷方法的。\n\t- 系统增量是提前定义好的，即为 `计划驱动方法`。\n\t- 最初的增量是定义好的，但往后的增量的开发取决于项目的进展情况及客户的优先选择，即为 `敏捷方法`。\n- 系统的开发是建立一系列的版本 (增量) 每个版本添加部分功能到先前版本中。\n- 增量式开发的特性\n\t- 降低了适应用户需求变更的成本。\n\t- 开发过程中及时得到用户已做的开发工作的反馈意见。\n\t- 更快地交付和部署有用的软件到客户方。\n\n#### 面向复用的软件工程\n基于复用开发的一般过程模型如图 1-3 所示。初始需求描述阶段、有效性验证阶段与其他过程差不多，面向复用过程的中间阶段是不同的。\n\n![图1-3面向复用的软件工程](/images/illustration/Reading/2018/05/Sofeware-Engineering_1-3.png)\n<center>图 1-3 面向复用的软件工程</center>\n\n- 中间阶段：即组件分析、需求修改、使用复用的系统设计、开发和集成阶段。\n\t- 组件分析：需求描述 -> 搜组件 (往往只提供所需的部分功能)。\n\t- 需求修改：根据得到组件信息分析需求，再修改需求以反映可得到的组件。\n\t- 使用复用的系统设计：设计系统的框架或者重复使用一个已存在的框架。\n\t- 开发和集成\n\n### 过程活动\n\n#### 软件描述\n- 软件描述或需求工程是理解和定义系统需要提供什么样的服务，以及找出开发和运行中受到哪些约束。\n- 需求工程过程的主要阶段，如图 1-4 所示。\n\t- 可行性研究\n\t- 需求导出和分析\n\t- 需求描述\n\t- 需求有效性验证\n\n![图1-4需求工程过程](/images/illustration/Reading/2018/05/Sofeware-Engineering_1-4.png)\n<center>图 1-4 需求工程过程</center>\n\n#### 软件设计和实现\n- 软件设计和实现阶段是把系统描述转换成一个可运行的系统的过程。\n- 软件设计是对实现软件的结构、系统的数据、系统组件间的接口以及所用的算法的描述。这是一反复、迭代的过程。\n\n#### 软件有效性验证\n- 程序测试：用模拟测试数据运行系统。\n- 测试过程各阶段\n\t- 组件 (单元) 测试：每个组件单独测试；组件可是简单实体，如函数、对象类或这些实体的集合。\n\t- 系统测试：集成组件形成完整系统，对组件组成的子系统测试。\n\t- 接收测试：客户提供真实数据测试系统。\n\n#### 软件进化/软件维护\n软件工程不再是开发和维护两个独立的过程，而是一个进化过程。即软件在其生命内不断随着需求的变更而变更的进化式过程。\n\n![图1-5系统进化](/images/illustration/Reading/2018/05/Sofeware-Engineering_1-5.png)\n<center>图 1-5 系统进化</center>\n\n### 应对变更\n- 有效降低变更成本\n\t- 变更避免：预测变更，如 `原型系统` 的开发，客户试用原型，在花费高额的软件生产成本之前重新定义需求。\n\t- 变更容忍：`增量开发`，即使单个增量(系统一小部分)的修改来适应变更，以较低成本处理变更。\n- 应对变更系统需求的方法\n\t- 系统原型：快速开发一个系统版本或系统一部分，以检验客户需求和某些设计决定的可行性，即它支持 `变更避免`。\n\t- 增量交付：系统增量地交付给用户，给用户评审和试用。即它支持 `变更避免` 和 `变更容忍`。\n\n#### 原型构造\n- 原型是一个软件系统的最初版本，用于验证概念、试用设计选项、发现更多的问题和可能的解决方法。\n- 原型开发的过程模型如图 1-6 所示。\n\t\n\t![图1-6原型开发的过程](/images/illustration/Reading/2018/05/Sofeware-Engineering_1-6.png)\n\t<center>图 1-6 原型开发的过程</center>\n\t\n\t> 最后一阶段：原型评估，则必须安排用户培训，应根据原型的目标制定一个评估计划。即用户需习惯并适用新系统，一旦他们自然地使用了系统，将可能发现错误和被遗漏的需求。\n\n- 不强求原型是可执行的。\n\n\t> 基于纸质的模型系统的用户界面，用户和这个界面交互，但他们的请求被传递给一个人，该人员解释此请求并输出相应的响应。\n\t\n#### 增量式交付\n- 增量式开发是软件开发的一种方法，如图 1-7 所示。\n\n\t![图1-7增量式交付](/images/illustration/Reading/2018/05/Sofeware-Engineering_1-7.png)\n\t<center>图 1-7 增量式交付</center>\n\n- 增量式开发过程的好处\n\t- 早期的增量作为原型，从中获得对后面系统增量的需求经验。\n\t- 每一增量会满足他们大多数需求，即软件马上就能使用。\n\t- 具有高优先权的服务被首先交付，而后继有增量不断被集成进来，使得最重要的系统服务接受了多次测试。\n- 增量式交付存在的问题\n\t- 软件描述和软件本身一起开发是迭代过程的本质。在增量方法中，直到最后的增量描述完成，才会有完整的系统描述。而许多机构 (如政府) 的采购模型是，系统开发合同中附带完整的系统描述，即相互冲突。\n\t- 旧系统的所有功能与新系统的部分功能，多数用户宁可选前者，即获取反馈较困难。\n\n#### Boehm 的螺旋模型\n- 风险驱动的软件过程框架 (螺旋模型)\n\t- 在螺旋线中每个回路表示软件过程的一个阶段，如最里的回路可能与系统可行性研究有关，下一回路与系统需求定义有关等。\n\t- 螺旋线中每个回路被分成4部分：  \n\t1) 目标设置  \n\t2) 风险评估和规避  \n\t3) 开发和有效性验证  \n\t4) 规划  \n\n### Rational 统一过程\n- RUP 一般从3个视角描述过程\n\t- 动态视角：给出模型中随时间所经历的各个阶段。\n\t- 静态视角：给出所进行的过程活动。\n\t- 实践视角：提出在过程中可采用的良好实践建议。\n- RUP 是一阶段化模型，如图 1-8 所示。\n\t- 开端  \n\t\t- 目标是建立系统的一个业务案例。  \n\t\t- 识别所有与系统交互的外部实体 (人和系统) 并定义这些交互。\n\t\t- 适用这些信息评估系统对业务的贡献，若贡献微小，那么项目在此阶段结束。\n\t- 细化\n\t\t- 目标是增进对问题域的理解，建立系统的体系框架，给出项目计划并识别关键项目风险。\n\t\t- 输出系统的需求模型 (描述的用例、体系结构描述及开发计划)。\n\t- 构造：系统设计、编程和测试。\n\t- 转换：将系统从开发单位转移到用户单位，并使之在真实环境中工作。\n\n\t> 1) RUP 中的阶段是紧密与业务关联，而不是与技术层面关联。  \n\t> 2) RUP 把 `阶段` (开端、细化、构造、转换) 和 `工作流` (需求、分析、设计...) 分离，即各种 RUP 工作流在整个过程的所有阶段都是可能存放的。  \n\n\t![图1-8Rational统一过程的各阶段](/images/illustration/Reading/2018/05/Sofeware-Engineering_1-8.png)\n\t<center>图 1-8 Rational 统一过程的各阶段</center>\n\t\n- 实践视角\n\t- 迭代地开发软件；\n\t- 对需求的管理：记录并跟踪客户的需求；\n\t- 使用基于组件的体系结构，将系统体系结构组织成组件形态；\n\t- 可视化地建模软件：UML 模型表现软件的静态、动态视图；\n\t- 检验软件质量；\n\t- 控制对软件的变更：变更管理系统、配置管理程序和工具来管理软件的变更。\n- 静态视角\n\t- 聚焦在开发过程中所发生的活动上，这些在 RUP 描述中被称为工作流。\n\t- 此过程中包含6个核心过程工作流，3个核心支持工作流，见图 1-9 所示。\n\n\t![图1-9RUP中的静态工作流](/images/illustration/Reading/2018/05/Sofeware-Engineering_1-9.png)\n\t<center>图 1-9 RUP 中的静态工作流</center>\n\t\n## 贰 敏捷软件开发\n\n{% note success %} 开始敏捷开发篇章前，引入一有趣的例子。Jazz Band 模式，跟 “敏捷的开发模式” 类似，同样也可以产生优秀的作品。( 演奏中，Miles Davis 先用小号吹出主题 ( 类比为架构师 )，然之后到一旁抽烟。曲目交由其他人员即兴发挥。最后， Miles Davis 加入演奏，回应主题 )。\n\n感兴趣的可以观看视频：[Miles Davis So What](http://v-wb.youku.com/v_show/id_XMTUzNzUxOTEwNA==.html) {% endnote %}\n\n- 学习目标\n\t- 理解敏捷软件开发方法的基本原理、核心内涵，以及它与计划驱动软件开发方法的差别；\n\t- 极限编程；\n\t- 理解敏捷项目管理的 `Scrum` 方法；\n\t- 应用伸缩的敏捷方法时的事项和问题 -> 大型软件系统开发过程.\n\n### 敏捷方法\n- 敏捷方法是一种专注于快速开发的 `增量式开发`，`频繁地发布软件`、`降低过程开销`、生产高质量代码。他们使用户直接参与到开发过程中。\n- 敏捷方法的基本原理体现在 `敏捷宣言` 中：\n\t- 个体和交互胜过工具和过程；\n\t- 编写软件胜过书写详尽文档；\n\t- 用户合作胜过合同谈判；\n\t- 响应变更更胜过遵循计划.\n\t\n\t> 即我们更重视左边的项的价值，虽左右两边的项都有价值。\n\t\n- 大量的软件工程努力维护和进化现有的软件系统，而由敏捷方法的特性可知，敏捷方法维护的问题有：\n\t- 软件交付后的主要困难可能是继续让用户参与到过程中。\n\t- 保持开发团队的持续性，因没有参考文档可循，若一个敏捷开发团队解散了，则 `依赖于团队成员理解系统` 的 `隐式知识` 旧丢失了。\n- 混成方法：敏捷方法嵌入来自计划计划驱动式开发的某些技术。\n\n### 计划驱动开发和敏捷开发\n计划驱动和敏捷描述如图 2-1 所示。\n\n![图2-1计划驱动和敏捷描述](/images/illustration/Reading/2018/05/Sofeware-Engineering_2-1.png)\n<center>图 2-1 计划驱动和敏捷描述</center>\n\n- 敏捷方法：\n\t- 迭代发生在所有活动间。\n- 计划驱动方法：\n\t- 迭代发生在各个活动中，用 `正式文件` 在软件过程中各阶段间沟通。\n\n\t> `正式文件`：可视化作为各阶段的输出产物。\n- 在计划驱动和敏捷方法之间得到平衡，必须回答以下一些技术的、人员的和机构方面的问题。\n\t- 详尽的描述和设计 -> `计划驱动开发`\n\t- 交互用户并快速取得反馈 -> `敏捷开发`\n\t- 开发系统的规模；\n\t- 开发的系统类型，如有复杂时序需求的实时系统，通常需要相当详细的设计来实现分析 -> `计划驱动开发`\n\t- 预想的系统寿命有多长；\n\t- 什么样的技术支持系统开发 (敏捷方法通常依赖于工具，以跟踪设计进化)；\n\t- 开发团队的组织情况；\n\t- 影响系统开发的文化问题 (传统的工程机构有计划驱动的文化)；\n\t- 开发团队的成员专业水平；\n\t- 系统是否受制于外部法规 (如联邦的航空管理局 FAA 核准一个安全性要求极高的航空操作软件)；\n\n### 极限编程 (XP)\n- 极限编程所属敏捷方法，它集成了一系列好的编程经验。例如，频繁地软件发布、连续软件改善和客户参与到软件开发团队。\n- XP 中，所有的需求都表示为脚本 (称为用户故事情节)，它将直接实现为一系列任务。\n- 一个 XP 过程，产生了正在开发的系统的一个增量，具体如图 2-2 所示。\n\n![图2-2极限编程的版本循环](/images/illustration/Reading/2018/05/Sofeware-Engineering_2-2.png)\n<center>图 2-2 极限编程的版本循环</center>\n\n- 脚本卡是 XP 规划过程的主要输入。\n\t- 开发团队把每个 `脚本` 拆分成 `任务`，并估计实现所需人力资源。\n\t- 与客户交谈，定义需求，对脚本进行优先权排序。\n\n#### 极限编程中的测试\t\n- 很多增量开发方法的测试过程是很不规范的。\n- 为避免一些测试和系统验证方面的问题，XP 方法更加强调测试过程。\n- XP 当中测试的关键特性：\n\t- 测试优先的开发 (先写测试程序再写代码)；\n\t- 来自脚本的增量式测试开发；\n\t- 用户参与测试开发和有效性验证；\n\t- 自动测试系统的使用。将测试写成了可执行的组件，该测试组件是独立的。自动测试框架即是这样的一个系统。譬如 Eclipse 的 JUnit，JUnit 用于单元测试。\n\n#### 结对编程\n结对编程是有一些质量效益，但却不足以抵消它的开销。但信息共享在结对编程是很重要的，因为当有团队成员离开时，它降低了项目风险。\n\n### 敏捷项目管理\n- 项目管理的标准：计划驱动。\n- 适合增量开发 (敏捷方法) 的管理方法 (框架)：`Scrum`。\n\t- Scrum 的管理过程如图 2-3 所示。\n\n\t![图2-3Scrum的管理过程](/images/illustration/Reading/2018/05/Sofeware-Engineering_2-3.png)\n\t<center>图 2-3 Scrum 的管理过程</center>\n\n\t- Scrum 的 3 个阶段\n\t\t- 规划纲要阶段：建立大致的项目目标和设计软件体系结构。\n\t\t- 冲刺循环阶段：\n\t\t\t- 每个循环开发出一个系统增量；\n\t\t\t- 每个循环为一个计划单元，其中的工作有评估、特征选择和开发、软件实现；\n\t\t- 项目结束阶段：完善文档，如系统帮助和用户手册。\n\t\t- 冲刺循环阶段的特征：\n\t\t\t- 冲刺有固定长度，一般是 2-4 周，在 XP 过程中对对应与一个系统版本的开发。\n\t\t\t- 规划的起点，即积压的任务 (Backlog)，也是项目中要完成的工作清单。\n\t\t\t- 评估阶段：Backlog 需经过审查，并对它们进行优先级排序和风险指派。\n\t\t\t- 选择阶段：项目所有成员都要参加，和用户一起选择冲刺循环中要开发的特性和功能。\n\t\t\t- 开发阶段：达成共识将组织进行软件开发，每一天团队开发成员参与段时间会议，回顾开发过程，若有必要重新安排工作。且在此阶段开发团队是隔离于客户和机构的。\n\t\t\t- 冲刺循环阶段结束，对已做工作复查并交付给用户。\n\t\t\t\n\t\t\t> 所有交流都是通过 `Scrum Master` 进行，SM 可理解为调解人。体现了 Scrum 的思想，即整个团队被赋予决定的权利。\n\t\t\n\t- Scrum 适合分布式的开发环境。\n\n### 可扩展的敏捷方法\n- 敏捷方法的开发是为同一房间办公与交流的小团队开发使用，因此常被用于小型系统开发。\n- 可伸缩的敏捷方法也可适用于开发大型系统。\n- 大型、小型系统开发的区别 (可理解为可扩展的敏捷方法应用于大型系统的挑战)。\n\t- 大型系统经常由独立的、交互的子系统组成。不同团队独立开发不同子系统，且团队可能在不同地点或不同时区工作。\n\t- 大型系统包含了一系列的已存在的系统并与它们进行交互，许多系统需求关注这种交互。\n\t- 当一个系统由多个系统集成产生时，开发工作中重要部分是系统配置而不是原始代码开发。这不一定与增量式开发和频繁的系统集成兼容。\n\t- 大型系统通常具有不同的信息持有者，将不同的信息持有者加入开发流程中是必要的。\n- 伸缩的敏捷方法的两个观点\n\t- 照搬放大，即关注如何将这些方法应用到哪些 `小团队` 无法开发的 `大型项目` 中。\n\t- 渗透，即关注如何将敏捷方法介绍 `推广` 到拥有多年开发经验的 `大机构` 中。\n\t\n## 叁 需求工程\n\n- 学习目标\n\t- 了解用户需求、系统需求；\n\t- 了解功能需求、非功能需求；\n\t- 如何在软件需求文档中 `机构需求`；\n\t- 了解需求工程活动的内容及他们之间的关系；\n\t- 了解需求管理.\n\n- 一些概念\n\t- 用户需求：用自然语言加图的形式给出的关于系统 `需要提供` 哪些服务及系统操作受到哪些 `声明的约束`。\n\n\t> 高层 (抽象) 的概要需求。\n\t\n\t- 系统需求：详细给出系统 `将要提供` 的服务及系统所受到的约束。系统的需求文档也称功能描述。\n\n\t> 系统应提供哪些服务的详细描述。\n\n### 功能需求与非功能需求\n- 功能需求\n\t- 描述系统所提供的功能或服务。\n\t- 若是用户需求，就要用可以被系统用户理解的一种抽象方法描述功能需求。\n\t- 更具体的功能性系统需求则需要详细地描述系统功能、异常、输入和输出。\n- 非功能需求\n\t- 指那些不直接关系到系统向用户提供的具体服务的一类需求。简言之，他们对 `系统实现` 定义了 `约束`，如 I/O 设备的能力、与其他系统接口的数据的表示。\n\t- 非功能性系统需求：通常会从总体上规范或约束系统的特性。\n\n\t> 若一个非功能系统需求没有满足则可能使整个系统无法使用。\n\t\n\t- 非功能需求分类：表明非功能需求或是来源于所要求的软件特性 (产品需求)，或是来源于开发软件的机构 (机构需求)，或是来源于外部来源。如图 3-1 所示。\n\n\t![图3-1非功能需求的类型](/images/illustration/Reading/2018/05/Sofeware-Engineering_3-1.png)\n\t<center>图 3-1 非功能需求的类型</center>\n\n### 软件需求文档\n- 如表 3-1 所示，是基于 IEEE 标准的需求文档的结构。\n\t- 需求文档中内容的详细程序，取决于所要开发的系统的类型及所使用的开发过程。\n\n<center>表 3-1 需求文档结构</center>\n\n| 章节 | 描述 |\n| :--- | :--- |\n| 绪言 | 定义文档的读者对象，说明版本的修正历史，包括新版本为什么要创建，每个版本间的变更内容的概要 |\n| 引言 | 描述为什么需要该系统，简要描述系统的功能，解释系统是如何与其他系统协同工作的。描述该系统在机构总体业务目标和战略目标中的位置和作用 |\n| 术语 | 定义文档中的技术术语和词汇。假设文档读者是不具有专业知识和经验的人 |\n| 用户需求定义 | 这一部分要描述系统应该提供的服务以及非功能系统需求，该描述可以使用自然语言、图表或者其他各种客户能理解的标记系统。产品和过程必须遵循的标准也要在此定义 |\n| 系统体系结构 | 这一部分要对待建系统给出体系结构框架，该体系结构要给出功能在各个模块中的分布。能被复用的结构中组件要用醒目方式示意出来 |\n| 系统需求描述 | 这一部分要对功能和非功能需求进行详细描述。如有必要，对非功能需求要再进一步描述，例如定义与其他系统间的接口 |\n| 系统模型 | 这一部分要提出一个或多个系统模型，以表达系统组件、系统以及系统环境之间的关系。这些模型可以是对象模型、数据流模型和语义数据模型 |\n| 系统进化 | 这一部分要描述系统基于的基本设想和定位以及硬件和用户需求改变时所要做的改变。这部分对系统设计人员来说是有用的，因为这有助于他们避免一些设计决策，这些决策可能会限制未来系统的变更 |\n| 附录 | 这一部分要提供与开发的应用有关的详细、专门的信息。该附录的例子是硬件和数据库的描述，硬件需求定义了系统最小和最优配置，数据库需求定义了系统所用的数据的逻辑结构和数据之间的关系 |\n| 索引 | 可以包括文档的几个索引。除了标准的字母顺序索引外，还可以有图标索引、功能索引等 |\n\n### 需求描述\n- 即在需求文档中写下用户需求和系统需求。\n\t- 用户需求：从用户角度来描述系统功能需求和非功能需求，一般用自然语言、图形叙述。\n\t- 系统需求：\n\t\t- 用户需求的扩展；\n\t\t- 软件工程师开始系统设计的起点；\n\t\t- 解释如何能让系统提供用户需求.\n- 原则上系统需求应 `反描述` 系统的 `外部行为` 和对它的 `操作限制`，而不是描述系统如何设计、实现。\n\n\t> 当然，并不是不提及任何设计信息，这也是不可能的，例如系统初始的体系结构设计。\n\n#### 自然语言描述\n- 在使用自然语言书写需求时，为了尽力 `减少误解`，应有一些简单的指导原则：\n\t- 设计一个 `标准格式`，并保证所用的需求定义都遵循此格式书写。\n\t- 使用一致性的语言来区分强制性需求和可选性需求。\n\t\t- 强制性需求：必须支持的，定义时使用 `必须`。\n\t\t- 可选性需求：不是必要的，定义时使用 `应该`。\n\t- 对文本加亮 (粗体、斜体、颜色) 来突出显示关键性需求。\n\t- 避免使用专业术语和缩写语 (无法避免时应该在有标注说明)。\n\t- 任何情况下，都应尝试把需求原理和每一个用户需求联系起来。\n\n#### 结构化描述\n- 使用结构化方法来描述系统需求，则先为需求定义一个或多个的 `标准模板`，并将模板表示成结构化的表格形式。如表 3-2 所示，是胰岛素泵需求的结构化描述。\n\n<center>表 3-2 胰岛素泵需求的结构化描述</center>\n\n| 项目名称 | 胰岛素泵/控制软件/SRS/3.3.2 |\n| :--- | :--- |\n| 功能 | 计算胰岛素剂量；安全的胰岛素水平 |\n| 描述 | 计算所要传输的胰岛素剂量，这是在当前度量的血糖水平处于 3-7 个单位之间这样正常范围之内时的胰岛素计算 |\n| 输入 | 当前血糖读数 (r2)，先前的两个读数 (r0, r1) |\n| 来源 | 来自传感器的当前血糖读数。其他读数来自内存 |\n| 输出 | CompDose：所要传输的胰岛素剂量 |\n| 目的地 | 主控制循环 |\n| 行动 | 如果血糖水平是稳定的或往下掉或是上升但速率下降，则 CompDose 为 0。若血糖的水平是在上升且上升速率也上升，那么 CompDose 的计算方法是求当前血糖水平和先前血糖水平，再除以 4 并取整。若取整的结果为 0，那么 CompDose 就被设置成可以传输的最小剂量 |\n| 需求 | 两个先前的读数，这样血糖变化速率就可以计算出来了 |\n| 前置条件 | 胰岛素池容纳至少是单个传输剂量的最大值 |\n| 后置条件 | r0 被 r1 替换，然后 r1 被 r2 替换 |\n| 副作用 | 无 |\n\n- 标准格式描述功能需求时，应包括下列信息：\n\t- 关于所定义的功能或实体的描述；\n\t- 关于输入及输入来源的描述；\n\t- 关于输出及输出去向的描述；\n\t- 关于计算所需要的信息及系统中所使用的其他实体信息；\n\t- 关于所采取的行动的描述；\n\t- 如果使用一个功能方法，前置条件、后置条件的设定描述；\n\t- 关于操作的副作用，没有则填写无.\n\t\n### 需求工程过程\n- 需求工程过程包括4个高层活动：\n\t- 系统可行性研究：评估系统是否对业务有用。\n\t- 需求导出和分析：需求发现。\n\t- 需求描述：将需求转变为某种标准格式描述。\n\t- 需求有效性验证：检验需求是否正确地定义了客户所希望的系统。\n- 在实际需求工程是一个活动相互交错的迭代过程，如图 3-2 体现了这种交错性。\n\n![图3-2需求工程过程的螺旋模型](/images/illustration/Reading/2018/05/Sofeware-Engineering_3-2.png)\n<center>图 3-2 需求工程过程的螺旋模型</center>\n\n### 需求导出和分析过程\n- 反复的过程，也可看做是一种 `螺旋式活动`。\n- 需求发现 (需求导出)\n\t- 对准备建立的系统和正使用的系统进行信收集，并从中提取用户需求和系统需求的过程。\n\t- 与 `信息持有者` 通过交谈和观察进行交互，即可使用 `用例` 和 `原型` 来帮助对方理解系统。\n- 采访\n\t- 封闭式采访：即信息持有者回答一组 `锁定的问题`。\n\t- 开放式采访：需求工程团队 `即兴访问`，更深层次了解对方需求是什么。\n- 脚本\n\t- 脚本是对 `交互实例片段` 的描述。\n\t- 脚本开始于一个 `交互框架`，在导出过程中细节增加，直至产生一完整的交互描述。\n\t- 脚本的内容\n\t\t- 开始部分有一系统和用户期望的描述；\n\t\t- 标准事件流的描述；\n\t\t- 处理错误的描述；\n\t\t- 完成后系统状态的描述.\t\n- 用例\n\t- 统一建模语言 (UML) 的基本特征。\n\t- 用例的集合代表所有将会在系统需求中出现的交互。过程中的角色可为人、其他系统等。\n\t- UML 对于面向对象模型来说，是一约定俗成的标准，因此基于用例的导出被广泛应用于需求导出中。\n- 深入实际：如图 3-3 所示的需求分析的深入实际方法和原型法。\n\n![图3-3需求分析的深入实际方法和原型法](/images/illustration/Reading/2018/05/Sofeware-Engineering_3-3.png)\n<center>图 3-3 需求分析的深入实际方法和原型法</center>\n\n### 需求有效性验证\n- 有效性检查：任何一组需求都不可避免地要在不同用户之间协商。\n- 一致性检查：需求不应该彼此冲突。\n- 完备性检查：需求文档应包括所有系统用户想要的功能和约束。\n- 真实性检查：检查需求以保证需求能真正实现。\n- 可检验性检查：检查方法 -> 验证需交付的系统 -> 满足定义的需求。\n\t- 需求评审：主要是错误检查和不一致检查。\n\t- 原型建立：提供一可执行的系统模型，客户和最终用户在此基础检查系统。\n\t- 测试用例生成。\n\n### 需求管理\t\n- 大型软件系统的需求总是在变化的，即开发这些系统需满足某些棘手问题，则这些问题不可能被完全定义。如图 3-4 所示为需求进化的过程。\n\n![图3-4需求进化过程](/images/illustration/Reading/2018/05/Sofeware-Engineering_3-4.png)\n<center>图 3-4 需求进化过程</center>\n\n#### 需求管理规划\n- 需求识别：每一需求有 `唯一标识码`。\n- 变更管理过程：变更带来的影响和成本的评估活动。\n- 可追溯策略：`策略` 定义了需求间和需求与系统设计间的 `关系`；关系是要记录的，并附有记录的 `维护方法`。\n- 工具支持\n\t- 需求存储\n\t- 变更管理：如图 3-5 所示，即变更过程由有效工具来支持。\n\t- `可追溯性` 管理：需求间的 `关联` <- 自然语言处理技术 (NLP)\n\n\t![图3-5需求变更管理](/images/illustration/Reading/2018/05/Sofeware-Engineering_3-5.png)\n\t<center>图 3-5 需求变更管理</center>\n\n#### 需求变更管理\n- 问题分析和变更描述：问题或变更 -> 检验有效性 -> 反馈变更请求者 -> 导致两种结果：\n\t- 更加详尽的需求变更、提议；\n\t- 取消本次变更.\n- 变更分析和成本计算：需求文档修改、系统设计和实现的成本估算。\n- 变更实现：与编写程序类似，文档的 `可追溯性` 即 `关联性` 是通过最小化外部引用和尽量使之模块化来实现的。\n\n## 肆 系统建模\n\n- 学习目标\n\t- 如何用图形模型表示软件系统；\n\t- 基本的建模角度 (如上下文、交互、结构、行为等)；\n\t- 统一建模语言 (UML)；\n\t- 模型驱动工程.\n- 系统建模：建立系统抽象模型的过程\n\t- 图形建模；\n\t- 形式化建模 (数学模型). \n- 不同角度表述系统 `与 第陆章 中的「4+1」视图相仿`\n\t- `外部` -- 上下文模型：系统上下文；系统环境；\n\t- `交互` -- 交互模型：系统与环境之间；系统各组成部分之间；\n\t- `结构` -- 结构模型：系统的体系结构；\n\t- `行为` -- 行为模型：系统的动态行为和它对事件响应方式.\n\n### 上下文模型\n- 定义系统边界：定义系统上下文和系统与环境之间的依赖关系。\n- 上下文模型表示某一环境包括几个其他的自动系统 (忽略子系统之间及待描述的系统与它们之间的关联关系的类型)。\n- 结合业务过程模型 \n\t- 活动图：如图 4-1 所示。\n\n\t![图4-1活动图](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-1.png)\n\t<center>图 4-1 活动图</center>\n\t\n### 交互模型\n- 为用户交互建模 -> 识别用户需求。\n- 为系统各部分之间的交互建模 -> 系统结构能否实现系统所需的功能及其可靠性。\n\n#### 用例建模\n- 用例图：如图 4-2 所示。\n\n![图4-2用例图](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-2.png)\n\t<center>图 4-2 用例图</center>\n\n- 时序图：表示在特定用例中的交互发生顺序。如图 4-3 所示。\n\n![图4-3时序图](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-3.png)\n\t<center>图 4-3 时序图</center>\n\n### 结构模型\n\n> 课本第 6、18、19 章讲述软件体系结构的不同方面和软件体系结构建模。\n\n- 静态模型：表示系统设计的结构。\n- 动态模型：表示系统执行时的构成。\n\n#### 类图\n- 类图可表示系统中的类和这些类之间的关联。\n\n\t> 类与类之间的链接，表示类与类之间具有某种关系。\n\t\n\t- 简单类图：如图 4-4 所示。其中一对多关系的类图，类似于语义数据模型，即数据实体、与他们相关的属性。\n\n\t![图4-4简单类图](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-4.png)\n\t<center>图 4-4 简单类图</center>\n\n\t- 扩展类图：如图 4-5 所示。\n\n\t![图4-5扩展类图](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-5.png)\n\t<center>图 4-5 扩展类图</center>\n\n#### 泛化\n- 推断一些类的成员具有的某些共同特征，针对类的所有成员给出一般性的描述。如图 4-6 所示。\n\n![图4-6泛化关系](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-6.png)\n<center>图 4-6 泛化关系</center>\n\n#### 聚合\n- 一个对象 (全体) 可有由其他对象 (部分) 组成。如表示一条病人记录由 Patient 和一个不确定的 Consulation 组成。如图 4-7 所示，表示了一条病人记录由 Patient 和一个不确定的 Consulation 组成。\n\n![图4-7聚合关系](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-7.png)\n<center>图 4-7 聚合关系</center>\n\n#### 依赖\n如图 4-8 所示，展示了依赖关系。\n\n![图4-8依赖关系](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-8.png)\n<center>图 4-8 依赖关系</center>\n\n### 行为模型\n- 描述系统运行时的动态行为的模型，表示系统响应于所处环境的刺激所发生或可能发生的事情。\n- 刺激：`数据`、`事件`\n\t- 数据：一些数据到达必须由系统处理。\n\t- 事件：某些触发系统处理的事件的发生。\n\n#### 数据驱动的建模\n- 数据驱动模型描述一个 `动作序列`，该动作序列涉及输入数据的处理和相关 `输出的产生`。\n\n\t> `输出的产生`：指系统的响应。\n\n- 处理序列的方法：\n\t- `时序图`：强调系统中的对象。\n\t- `数据流图` (DFD)：关注于功能。\n\n#### 事件驱动模型\n- 事件驱动模型表示系统对内、外部事件的响应方式。\n- 基于事件的模型表示方法：状态图，表示系统状态和引起状态和引起状态改变的事件。其中状态图的表示如图 4-9 所示。\n\n![图4-9状态图](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-9.png)\n<center>图 4-9 状态图</center>\n\n### 模型驱动工程\n- 模型驱动工程 (MDE) 起源于模型驱动体系结构 (MDA)，该体系由对象管理组织 (OMG) 提出。\n- 支持者与反对方：\n\t- `支持者`：更高的抽象水平上考虑系统，不用关心实现细节，减少出错可能性，加速设计和实现过程，且可复用。\n\t- `反对方`：并不是模型所支持的抽象都是正确的、可实现的。\n\n#### 模型驱动体系结构\n- 计算独立模型 (CIM) -- `领域建模` -- 不同的 CIM 反映系统的不同方面。\n- 平台独立模型 (PIM) -- 表示静态系统结构和系统对内外事件的响应。\n- 平台特定模型 (PSM) -- PIM -> PSM。如图 4-10 所示，为一个复合平台特定模型实例。\n\n![图4-10复合平台特定模型](/images/illustration/Reading/2018/05/Sofeware-Engineering_4-10.png)\n<center>图 4-10 复合平台特定模型</center>\n\n#### 可执行 UML：xUML\n- 为建立一 UML 可执行子集，模型类型可分为：\n\t- 领域模型：识别出系统的主要关注点，由 UML 的类图定义，包括对象、属性和关联。\n\t- 类模型：定义类及它们的属性和操作。\n\t- 状态模型：每一状态与一个类相关联，并且用来描述类的生命周期。","tags":["软件工程","需求工程","系统建模","UML"],"categories":["Reading"]},{"title":"一个 APP 的诞生：以设计师角度造产品","url":"/2018/03/Producting-An-Application.html","content":"\n[《 一个 APP 的诞生 》](https://book.douban.com/subject/26865230/)被定义是一本教科书、工具书，适合想通过 APP 实现自己的产品梦的受众通读，即通过本书可让你快速了解 APP 产品的整个流程，从零到一，创造 APP 产品。\n\n而通读本书籍后，或许你、我有同样的感受，即大部分内容是以设计师的角度看待问题的。这样，若你就是设计师，或许这将助你更加透彻理解 APP 的产出过程；若你是软件工程师，也可看待成是从另一角度理解软件过程。当然，这些知识只停留在书本层面，而对实际项目而言，有出入是无法避免的，但不失它的参考价值。简言之，这样一本图文并茂、实例贴近现实且含有众多跨界元素 (设计、开发、交互、产品等) 的工具书，特别是产品这一类别的书目 (下述还有同类型的书籍推荐)，不仅让你有机会感同身受业界优秀企业的工作流程，也是自身寻求产品方法论的不二选择。\n\n<!-- More -->\n\n- 推荐书目：\n\t- 《 U一点·料 》：由阿里巴巴集团 1688.UED 团队历经多年实践之后的佳作，内容重实战、讲方法、求专业、论文化，且以 “道─术─器” 的思路为编排脉络，从设计观、思考体系、方法论上层层剖析，将零散的行业技术诀窍串成体系，对 “UED如何发展突破” 提出了自己的真知灼见。  \n\n\t\t贴上本书的 [豆瓣书评](https://book.douban.com/subject/26594029/)，供朋友评判，做出抉择。\n\t\n\t- 《 设计之下 》：由搜狐新闻客户端 UED 团队共同出品的佳作，分别以交互设计、视觉设计、设计师视觉，全面讲解了用户体验设计的流程和方法。  \n\n\t\t贴上本书的 [豆瓣书评](https://book.douban.com/subject/25817190/)，供朋友评判，做出抉择。\n\n## 更新进程\n- 2018.03.25：完成序言；\n- 2018.03.26：更新内容 ( 共 6 章 )；\n- 2018.04.02：更新完毕.\n\n## 零 思维导图 \n\n> 学习思路：根据思维导图的架构，掌握知识；以及参考部分项目经验，文档归纳。\n\n- 前景探索\n\t- 竞品分析\n\t\t- 熟悉竞品分析的流程；\n\t\t- 明确竞品分析的每个部分包含的内容；\n\t\t- 分析报告的输出.\n\t- 用户研究\n\t\t- 了解用户研究的方法及它们的定义；\n\t\t- 用户画像  \n\t\t1) 掌握建立的流程；  \n\t\t2) 用户画像的分类，每种分类的使用方法及优缺点；  \n\t\t3) 用户画像的构成、价值.  \n- 设计规范及流程\n\t- 建立设计规范的特定情况；\n\t- iOS 和 Android 规范的差别；\n\t- 主要元素及作用.\n- 交互设计\n\t- 用户体验\n\t\t- 交互设计师的工作内容、状况分析及处理；\n\t\t- 紧密联系生活.\n\t- 交互设计的基本流程\n\t\t- 交互设计五要素：`人`、`目的`、`环境`、`媒介`、`行为`；\n\t\t- 基本流程.\n- 视觉设计\n\t- Ui 设计\n\t\t- Ui 设计制作流程；\n\t\t- 对未来设计趋势的了解与把握.\n\t- 图标品质的提升\n\t- 界面细节设计\n\t\t- 栅格系统提升界面易读性与可用性；\n\t\t- 切图标注的知识与技能；\n\t\t- 设计资源命名及文件分类整理.\n- 开发实现\n\t- 如何与产品、运营、开发配合工作\n\t\t- 互联网企业中产品开发实现过程；\n\t\t- 主要工作岗位职责和工作性质，以及岗位配合的注意事项.\n\t- 发布制作完成的 APP\n\t\t- 发布方式\n\t\t- 常见市场\n- 线上运营\n\t- 运营的定义\n\t\t- 什么是运营及运营的目标；\n\t\t- 运营手段及运营岗位.\n\t- 线上运营活动：策划线上活动流程\n\t- H5 页面和 Banner 设计\n- 服务设计\n\n\t> 推荐阅读 *This is service design thinking* \\\\(^{[1]}\\\\)\n\t\n\t- 服务设计的概念\n\t- 服务设计的流程\n\t- 工具箱：熟悉常见服务设计工具\n- 跨界设计\n\n## 壹 前景探索\n\n### 竞品分析\n竞品分析，能带来的价值：\n\n- 企业：优势 (Strength，S) 和 劣势 (Weakness，W)\n- 设计：User Interface\n\n#### 为什么要竞品分析\n- 知己知彼\n\t- 市场：红海 (已知的市场空间)；蓝海 (还不存在的产品)\n\t- 动向：目标人群、运营策略、用户体验、用户反馈\n- 设计灯塔：权衡利益与设计成本的关系\n\n#### 如何做竞品分析\n- `确立` 竞争对手\n\t- 市场目标一致；\n\t- 目标用户相同；\n\t- 产品功能相同、相似；\n\t- 用户需求相同.\n\t\t\n> 选择优质和合适的竞品，再进行分析。如表 1-1 所示，定位于即时通信类 APP ，即所要考虑的竟品类型及竞争关系。\n\n<center>表 1-1 即时通信类 APP 的竟品类型及竞争关系</center>\n\n| 考虑因素 | 主要分析对象 | 参考分析对象 |\n| :------ | :--------- | :--------- |\n| 市场目标方向一致、目标用户群体大致相同、功能用户需求相似 | QQ、微信 | 陌陌、JUJU |\n| 市场目标方向不一致、功能需求互补 | YY、斗鱼 | -- |\n\n- `挖掘` 对手信息\n\t- 搜集资料\n\t\t- 数据资料，例如：APP 下载量，市场方面数据等。\n\t\t- 其他信息，例如：APP 新闻动态，研究报告，APP 评价等。\n\t- 搜集渠道\n\t\t- 公司内部资源\n\t\t- 运营部门\n\t\t- 搜索引擎\n\n- `分析` 数据信息\n\t- [分析数据模型](#分析数据信息)\n\t- 整合收集的信息 (企业战略、目标人群、交互设计、视觉设计、运营策略等)\n\n- `输出` 分析报告 -- [可视化输出](#输出分析报告)\n\n#### 分析数据信息\n\n- 分析数据模型\n\t- `SWOT` 模型，即道斯矩阵、态势分析法，经常用于企业战略制定、竞争对手分析。\n\t\n\t详细解释见：[MBAlib.智库百科.SWOT分析模型](http://wiki.mbalib.com/wiki/%E9%81%93%E6%96%AF%E7%9F%A9%E9%98%B5)\n\n\t> `SWOT` 分别代表企业的优势 (Stength)、劣势 (Weakness)、机会 (Opportunity) 和威胁 (Threats)。\n\t\n\t- 波士顿矩阵 \\\\(^{[2,3]}\\\\)，四象限分析法。详细解释见：[MBAlib.智库百科.波士顿矩阵](http://wiki.mbalib.com/wiki/%E6%B3%A2%E5%A3%AB%E9%A1%BF%E7%9F%A9%E9%98%B5)\n\n\t- KANO 模型 \\\\(^{[4]}\\\\)，一种典型的定性分析模型，经常用于绩效指标分类。其定义了顾客需求的三个层次：基本型需求、期望型需求和兴奋型需求。详细解释见：[MBAlib.智库百科.KANO 模型](http://wiki.mbalib.com/wiki/KANO%E6%A8%A1%E5%9E%8B)\n\n- 关于 SWOT 分析模型\n\t- SW：竞争优势指一企业超越其竞争对手的能力，这种能力有助于实现企业的主要目标 -- 盈利。  \n\t- OT：不利发展趋势所形成的挑战。\n\n<center>表 1-2 SWOT 分析模型</center>\n\n| 发展趋势 (负) | 条件 | 发展趋势 (正) |\n| :----: | :----: | :----: |\n| 劣势 (Weakness，W) | 企业自身自身实力与竞争对手比较 | 优势 (Strength，S) |\n| 威胁 (Threats，T) | 外部环境变化对企业可能的影响 | 机遇 (Opportunity，O) |\n\n> 举例：对蚂蜂窝 APP 实行 SWOT 分析法\t\n\n- `S`：旅游攻略是蚂蜂窝进军移动端的拳头产品，手持海量 UGC 数据和攻略引擎技术。\n- `W`：盈利模式单一，知识与传统 OTA 合作的佣金 + 广告模式)。\n- `O`：OTA & O2O。\n- `T`：行业壁垒；变现能力还能支持技术和运营走多远？\n\n- 关于波士顿矩阵：波士顿矩阵区分出4种业务组合，如表 1-3 所示。\n\n<center>表 1-3 波士顿矩阵业务组合</center>\n\n|   | 销售增长率 | 市场占有率 |\n| :--- | :--- | :--- |\n| 明星类产品 | 高 | 高 |\n| 瘦狗类产品 | 低 | 低 |\n| 问题类产品 | 高 | 低 |\n| 现金牛类产品 | 低 | 高 |\n\n#### 输出分析报告\n- 竞品分析包括内容：\n\t- 市场趋势、行业现状； -- `SWOT 分析法`\n\t- 竞品的企业愿景、APP 定位、发展策略；\n\t- 目标用户，用户画像；\n\t- 核心功能；\n\t- 交互设计；\n\t- APP 优缺点；\n\t- 运营及推广策略；\n\t- 总结并建议.\n\n### 用户研究\n用户研究最终的输出产物之一就是用户画像，即用户研究 => 用户画像。\n\n#### 一般方法\n- 场景观察：正常的工作环境或其他产品合适的 `物理场景` 中观察用户并与其交流。\n- 可用性测试：用户在一定场景下使用产品。由可用性工程师对 `用户操作过程、习惯` 等进行 `观察、记录和测量`，以评估产品的可用性问题。\n- 问卷调查：用 `统一、严格设计的问卷` 收集研究对象有关的 `心理特征` 和 `行为数据` 资料。\n- 访谈研究：在访问用户过程中，提示被访者对某一问题的 `潜在冬季、新年、态度和感情`。\n\n\t> 潜在冬季、新年、态度和感情？\n\n- 焦点小组：定性研究方法。一定的组织结构，让用户一起进行 `互动`，用以激发新的思考和想法。\n- 桌面研究：对已收集信息进行调研活动，即对二手资料进行搜集、筛选，并判断问题是否已经 `局部解决` 或 `全部解决`。\n- 专家评估：组织各领域专家运用专业方面知识和经验，通过直观归纳，对产品过去、现在及发展过程进行综合分析、研究，再作判断。\n\n#### 用户画像\n\n- 输出用户画像的流程\n\t- 获取研究用户信息\n\t- 细分用户群\n\t- 建立并丰富用户画像\n\n- 建立用户画像的方法\n\t- `定性` 用户画像\n\t- 经 `定量验证` 的 `定性` 用户画像\n\t- `定量` 用户画像\n\t\n\t> 定性 (性质) 研究：创立理论的过程。即 `具体向抽象转化`，形成理论。通常以 `访谈、观察` 等方法收集第一手描述性资料 (归纳法)。 \n\t> \n\t> 定量 (度量) 研究：`提出理论假设`，使用 `问卷` 等工具收集具有数量关系的资料，对资料进行 `量化`，以 `数据形式` 验证假设。\n\n- 定性用户画像 -- `直接分用户群`\n\t- 步骤  \n\t1) 定性研究访谈；  \n\t2) 细分用户群；  \n\t3) 建立细分群体的用户画像。 \n\t- 定性用户画像优缺点\n\t\t- 优点 - 省时省力、简单、需要专业人员少。\n\t\t- 缺点 - 缺少数据支持和验证。\n\t\n- 经定量验证的定性用户画像 -- `分了用户群再验证`\n\t- 步骤  \n\t1) 定性研究访谈；  \n\t2) 细分用户群；  \n\t3) 定量验证细分群体；  \n\t4) 建立细分群体的用户画像。  \n\t- 经定量验证的定性用户画像优缺点\n\t\t- 优点 - 有一定的定量验证工作，需要少量的专业人员。\n\t\t- 缺点 - 工作量较大，成本较高。\n\t\n- 定量用户画像 -- `验证了再分用户群`\n\t- 步骤  \n\t1) 定性研究；  \n\t2) 多个细分假设；  \n\t3) 通过定量收集细分数据；  \n\t4) 聚类分析细分用户；  \n\t5) 建立细分群体的用户画像。  \n\t- 定量用户画像的优缺点\n\t\t- 优点 - 有充分的佐证、更加科学、需要大量的专业人员。\n\t\t- 缺点 - 工作量较大，成本高。\n\n- 用户画像包含以下元素：\n\t- 基本信息 (姓名、照片、年龄、家庭状况、收入、工作)；\n\t- 典型场景；\n\t- 目标和动机；\n\t- 需求和痛点；\n\t- 对 APP 的态度；\n\n\t如图 1-1 以音乐沉侵爱好者为例，建立用户画像。\n\t\n\n![音乐沉侵爱好者的用户画像](/images/illustration/Reading/2018/03/Producting_An_Application_1-1.png)\n<center>图 1-1 音乐沉侵爱好者的用户画像</center>\n\n#### 调查问卷设计\n设计问卷的目的是为了更好地搜集信息或者定量去验证定性研究的结果。故在问卷设计的过程中，要把握调查的目的和需求，具体可分为以下几个步骤：\n\n- 问卷设计流程\n\t- 确定所需要的信息\n\t\t- 调研目的\n\t\t- 竞品分析文档\n\t\t- 用户画像\n\t- 确定问题顺序：`先易后难`\n\t- 问卷的测试和修改\n\t\t- 投放预测试\n\t\t- 问题修改\n\n- 设计问卷题目\n\t- 用户基本信息 (年龄、爱好、APP 相关生活行为)\n\t- 用户使用 APP 典型场景 (碎片化时间使用，使用频次)\n\t- 用户的痛点与需求\n\t\n\t> 可参考书本 P27-30 的实例，全民 K 歌用户体验调研问卷。\n\t\n## 贰 交互设计\n\n### 用户体验\n- 用户体验，即站在用户角度考虑问题。\n- 交互设计师\n\t- 核心价值：沟通\n\t- 工作流程：\n\t\t- 对重要或者紧急设计任务进行准备、分工、安排；\n\t\t- 写解决方案，画稿；\n\t\t- 评审待确认的设计；\n\t\t- 总结方案，输出结果，同步给部门；\n\t\t- 输出设计稿，与产品、研发及时沟通；\n\t\t- 与项目接口人沟通.\n\t\n### 交互设计基本流程\n\n#### 交互五要素\n- 人 (Amber)：有记录灵感的设计师，有需求的人称之为用户。\n- 媒介 (Tools)：用户使用的设备。\n- 行为 (Behavior)：用户的具体操作。\n- 目的 (Purpose)：要达到某种的效果。\n- 环境 (Enviroment)：用户使用的设备，这里指手机。\n\t\n\n![交互设计五元素](/images/illustration/Reading/2018/03/Producting_An_Application_2-1.png)\n<center>图 2-1 交互设计五元素</center>\n\n#### 如何参与一个项目\n\n交互设计师接到一个项目或者需求后，他们的工作流程基本按照以下流程执行，即需求分析、信息架构设计、流程图设计、原型设计、最终进入产品的可用性测试，当然需求分析阶段完成后，也可以进行可用性测试，以验证方案的可行性。图 2-2 描述了交互设计师如何参与一个项目。\n\n![交互设计师如何参与一个项目](/images/illustration/Reading/2018/03/Producting_An_Application_2-2.png) \n<center>图 2-2 交互设计师如何参与一个项目</center>\n\n> 提示：实例中，我们以便签 APP 为主题展开讨论的。\n\n- 1) 需求分析\n\t- 了解需求\n\t- 用户调研\n\t- 需求定位：竟品分析、头脑风暴、绘制故事板、人物建模 (用户画像)、产品数据\n\t- `实例`：在需求分析阶段，我们从诸多研究方法和数据中简明得出便签 APP 的产品定位：  \n\t\t- 产品定义\n\t\t\t- 使用人群 -- `设计师、学设计的学生`  \n\t\t\t- 主要功能 -- `记录想法、分享想法`  \n\t\t- 用户需求\n\t\t\t- 使用目标 -- `随时随地记录想法、把想法分享给同事和朋友`  \n\t\t\t- 使用场景 -- `商场、会议、课堂、工作、训练、作图`  \n\t\t\t- 用户目标 -- `操作方便快捷、耗流量少、学习成本低`\n\n- 2) 信息架构\n\t- 需求收集\n\t- 需求删减\n\t- 定义优先级\n\t- 用户任务\n\t- `实例`：根据需求分析得到的信息，接下来便梳理架构，开始架构草图设计。如图 2-2 所示。\n\n\t![信息架构图](/images/illustration/Reading/2018/03/Producting_An_Application_2-3.png) \n\t<center>图 2-3 信息架构图</center>\n\t\n- 3) 流程图\n\t- 操作流程\n\t- 页面流\n\t- 布局设计\n\n- 4) 原型设计\n\t- 交互原型\n\t- 交互说明\n\t- 设计规范\n\t- 项目跟进\n\n- 5) 测试\n\t- 可用性测试\n\t- A/B 测试\n\t- 用户反馈\n\t- 产品数据\n\n#### 需求分析的考虑因素\n在产品设计的整个过程中，要充分考虑商业需求和用户体验的平衡。如图 2-4 所示，展示了需求收集需要考虑的因素。\n\n需求的删减是需求分析中很有必要的步骤，他是设计师们综合考虑各种因素，取舍得到的结果。\n\n![信息架构图](/images/illustration/Reading/2018/03/Producting_An_Application_2-4.png)\n<center>图 2-4 需求收集需要考虑的因素</center>\n\n#### 如何组织需求\n- 1) 定义信息优先级\n\t- 产品定位：核心功能，意味着这些功能的优先级最高。\n\t- 真实需求：区分次要需求。它们是围绕核心功能进行拓展的。\n\t- 需求删减：权衡删减需求。\n- 2) 信息架构：深度和广度要均衡。\n\n#### 流程图设计\n- 确定信息架构\n- 确定用户任务\n- 如何完成操作\n\n\t完成任务方法即我们所说的流程，任务流程是根据用户实际操作的心理和行为来确定的。  \n\t\n\t[实例] 人在使用纸质版的便签的流程：  \n\t\n\t- 首先拿出纸和笔；\n\t- 纸上记录想法；\n\t- 粘贴醒目的地方便于查看。\n\t\n\t在现实中使用便签的过程和在手机上使用便签的实际操作步骤基本吻合，如图 2-5 所示，展示了添加便签的流程图。\n\t\n\t> 这里的流程图设计，可以使用 C 语言程序设计中的程序流程图。\n\t\n\n![添加便签的流程图](/images/illustration/Reading/2018/03/Producting_An_Application_2-5.png)\n<center>图 2-5 添加便签的流程图素</center>\n\n#### 原型设计及设计原则\n- 确立功能和逻辑后\n- 设计草图\n- 低保真线框图\n- 高保真原型图\n\t\n\t图 2-6 是本人早期设计的沙漏记事 APP 的低保真线稿，强制插入了一段广告哈。而对应的高保真原型图，可参考对应的专题介绍。[「沙漏记事」APP](http://www.zcool.com.cn/work/ZMTU3NjcxMTI=.html)\n\t\n\t![沙漏记事APP低保真线稿](/images/illustration/Reading/2018/03/Producting_An_Application_2-6.jpg)\n\t<center>图 2-6 沙漏记事 APP 低保真线稿</center>\n\n#### 总结\n- 交互设计基本流程\n\t- 需求收集和分析\n\t- 定义优先级\n\t- 信息架构设计\n\t- 流程设计\n\t- 原型设计\n- 需求分析过程，要综合考虑 `商业`、`项目`、`用户` 三要素。\n\n## 叁 视觉设计\n\n### UI 设计\n\n#### UI 的定义\n用户界面 (User Interface，UI)，系统和用户之间进行交互和信息交换的媒介，它实现信息的内部形式与人类可接受形式之间的转换。\n\n#### UI 设计流程\n\n- 具体把 UI 设计流程分为前期准备和情绪板两个阶段。\n\t- 1) 定义：做好定义 / 用户细分。\n\t- 2) 找寻：找到同类竞品的 APP 安装并进行沉侵式体验。\n\t- 3) 分析：分析竞品并学习。\n\t- 4) 关键字：确定情感关键字。\n\t- 5) 收集：图片素材收集，建立情绪板。\n\t- 6) 分析：对情绪板进行色彩和质感分析。\n\t- 7) 访谈：用户验证确定设计风格。\n\t- 8) 完善：完善整个 APP 视觉设计。\n\n\t> Step 1 \\~ 4 为前期准备阶段，Step 5 \\~ 8 为情绪板阶段。\n- 做用户定义：如何定义用户在这不再重复阐述，详细见 [第一章 前景探索](#壹-前景探索)。\n- 找寻同类竞品 APP 使用并体验：站得高，看得远。即选择的竞品也要有足够的市场表现力。\n- 确定情感关键字：该 APP 的视觉所要表达的情感感受。\n- 情绪板：把每个人对情感的抽象理解成实际可定义的元素。\n\t- 关键字提炼；\n\t- 建立具象图库 (具体的事实物、场景) 和抽象；\n\t- 图库 (色彩质感等元素).\n- 对情绪板进行色彩和质感分析，即把握图片上的颜色、元素的感觉，再抽象成颜色方案。\n\n### 图标品质提升\n\n#### 素描色彩的基础\n- 素描的三大面五大调\n\t- 三大面：亮面，灰面，暗面。\n\t- 五大调：亮面，灰面，明暗交界线，反光部和投影。\n\n\t> 在构图中，我们都是通过假设光源的方法来进行创作。\n\t\n- 构图注意事项\n\t- 构图不能太小 (让人觉得画面不够饱满，显得小气)；\n\t- 构图应注重重心平衡；\n\t- 构图应注意透视的变化及比例关系.\n\n- 色彩的魅力\n\t- 色彩的冷暖：物体通过表面色彩给人温暖或凉爽的观感。\n\t- 色彩的轻重：质感与色感的复合感觉。\n\t- 色彩的前进性与后腿性：一般而言，暖色比冷色更富有前进的特性。\n\n#### 一个像素也是事儿\n- `边缘像素` 的完美方案：图标变虚问题 => 没有边缘对齐，故在矢量绘图当中，需要对齐边缘，对齐像素。\n- `旋转像素` 的完美方案：\n\t- 旋转中心点挪到任意定点，再旋转。\n\t- 若是旋转并缩放，建议先旋转再缩放。\n- Ai 到 Ps 的完美粘贴\n\t- 1) Ai 里选 `对齐像素网格`；\n\t- 2) Ps 里建一个图标大小相同的 `选区`，再粘贴进来，粘贴时最好选择 `形状图层`，这样便于后期编辑。\n\n#### 国际化的图标设计\n- 表现形式上符合全球化潮流的设计趋势。\n\n\t> 这里非常容易理解，例如地铁、高铁、机场的指示标志，还有厕所指示标志等。\n\n- 动感：动效与交互的相交融。\n- 质感：拟物、扁平和微质感，这里视具体情况而决定，如公司文化、应用受众、市场趋势等因素，总得来说，调研、分析工作是少不了环节。\n\n### 界面细节提升\n\n#### 栅格系统\n栅格系统，又称网格系统。主要以规则的网格阵列来指导和规范页面中的版面布局以及信息布局。当然，栅格系统也只是一种布局辅助工具，在实际项目中应灵活地根据需求在整体或布局合理应用，即综合 iOS 或 Android 的规范准则，总体把控每个元素与界面的协调感。\n\n#### 资源规范\n- 切图\n\t- iOS：选择一这种的分辨率，即 @2x，750 x 1334 px，再输出 @3x，@4x。当然，你的设计稿是基于 `矢量工具` 绘制的。\n\t- Android：MDPI (160 DPI)，HDPI (240 DPI)，XHDPI (320 DPI), XXHDPI (480DPI)，或更多。\n\t\n\t> 1) 关于切图适配的问题，除了上述的原始办法外，现有很多插件、工具可帮你完成此项工作了。  \n\t> 2) 一套切图尽可能适配 iOS 与 Android，即找准 @ 与 DPI 的大小关系即可。\n\t\n\t- 在标注文档中，可采用 `物理像素单位` 描述元素的大小、布局的位置和间距留白的大小。  \n\t这样做的好处是，**开发人员直接设置参数，设计人员按照切图的倍率输出切图** (@2x、@3x、@4x)。\n\t\n\t- 特别地，切图是以偶数倍放大的，便于缩放，设计元素的大小注意使用偶数单位即可。  \n\t\n\t例如，标注的基准信息是 `14.0 DP / @1x`，适配对应尺寸的参数即有：\n\t`XHDPI / @2x <=> 28px`，`XXHDPI / @3x <=> 42px`，`@4x <=> 56px`。\n\t\n- .9.PNG\n\t- 最外围的一圈像素，必须限定是 `1px` 大小，必须是纯黑色 `#000000`，任何参杂都不行。\n\t- 文件名后缀必须是 `*.9.PNG`。\n\n\t![.9.PNG使用演示图](/images/illustration/Reading/2018/03/Producting_An_Application_3-1.png)\n\t<center>图 3-1 .9.PNG使用演示图</center>\n\n- 压缩切图：在 Photoshop 中，输出方式为 `存储为 web 所用格式`；在 Sketch 中使用 `导出功能` 导出图片；其他工具可自行查阅资料，这里就不一一列举了。\n- 标注\n\t- 常用的标注软件：`Markman`、PxCook、Assistor PS。\n\t- 若公司、团队有规范的设计、开发手册，则请按照规范标准进行设计。\n\t- 拥有自己的一套标注文档 (迎合大众的，容易理解的)。\n\n\t对于一界面来说，图片、图标、框架、文字等元素，是必不可少的。若是为了更高程度的还原，那么详细的标注描述、文字说明、交互说明是必要的。在一般情况下，很多朋友为了便捷 (偷懒) 会在同一界面一次性把上述工作都堆积在一起完成，而这样带来的问题就是 `糟糕的阅读体验`。\n\t\n\t这里推崇一种做法 `分页描述法`。即：  \n\t1) 第一页，描述界面布局的信息，如间距大小、背景颜色；  \n\t2) 第二页，描述文字属性信息，如文字的字体、字号、颜色、布局；  \n\t3) 第三页，描述组件属性信息，如按钮、小图标等；\n\t4) 第四页，描述界面的交互信息，按照需求，你还可以细分为每个组件的交互信息；\n\t5) 以此类推...\n\t\n- 资源命名\n\t- `组件类型_模块_子功能_状态` 或者 `模块_组件类型_子功能_状态`；\n\n\t> 例如：btn\\_setting\\_logout\\_n.png / setting\\_btn\\_logout\\_n.png\n\t\n\t- 下划线相连命名，如 `ico_appicon_normal.png`\n- PSD 源文件\n\t- 以模块为单位，归类于不同文件夹中；\n\t- PSD 源文件中，有 `分组分层` 的习惯.\n\n## 肆 开发实现\n\n### 如何与产品、运营、开发配合\n\n#### 互联网产品的研发流程\n- 需求来了：产品经理，负责需求的策划和整理，输出产品需求文档 (Product Requirement Document，PRD)。那么产品经理的需求来自哪：\n\t- 版本规划：从无到有策划一款产品，这些功能不是一次性开发的，而是分布在若干版本中。\n\t- 动态演变的产品：根据市场的反馈，调整后续的增量版本。\n\t- 细节的优化：注重用户体验的优化。\n\t- 适应丰富的使用场景。\n- 需求要评审：方案需要和开发、设计、测试、运维人员一起评审。\n- 开始设计\n- 开始开发\n- 测试把关\n\n#### 与各种角色融洽相处\n可借助一些 `协作平台` 来规范研发流程，如需求的追加、任务分派、提交 BUG 等。相关人员通过日志、文档开展工作。\n\n`协作平台`：[Worktile](https://worktile.com/) 、 [Teambition](https://www.teambition.com/) 、[有道云协作](http://co.youdao.com/) 、 [ProcessOn (在线绘图)](https://processon.com/)  \n\n当然，软件过程中，一款合适的团队协作工具能使事情事半功倍。特别是敏捷方法，它是非常依赖工具的。至于哪款工具更适合于你们团队，建议参考知乎的文章再作判断：[Worktile 与 Teambition 的优劣对比？](https://www.zhihu.com/question/24920474)\n\n#### 发布应用程序\n- 灰度发布：在发布新版本时，仅针对少部分用户样本发布。灰度发布是一种常用的产品测试及质量管理工具。对于用户量大的产品，贸然发布一个新版本取代用户当前使用的版本，风险太大。因此互联网公司摸索出了一种工具，即灰度发布。\n\n#### 快速制作原型\n快速原型的工具有很多，推荐几款制作工具：[墨刀](https://modao.cc/) 、 [Axure PR](https://www.axure.com/download) 、 [Proto.io](https://proto.io/)\n\n## 伍 线上运营\n\n### 运营的概述\n\n#### 运营的定义\n在互联网中，针对不同群体推广产品，进行内容建议，并通过数据指标优化运营手段、产品功能与体验等行为。\n\n- 运营三要素：产品、用户和渠道，如图 5-1 所示。\n\n![运营三要素](/images/illustration/Reading/2018/03/Producting_An_Application_5-1.png)\n<center>图 5-1 运营三要素</center>\n\n- 运营的目标：运营是以目标为导向，数据为基础的工作。一切工作都围绕着运营三要素来进行，即产品、用户和渠道。运营的目标如图 5-2 所示。\n\n![运营的目标](/images/illustration/Reading/2018/03/Producting_An_Application_5-2.png)\n<center>图 5-2 运营的目标</center>\n\n- 产品、运营、设计工作的关系：为了达到运营目标，运营经理需要与产品经理、设计师等配合工作，如图 5-3 所示，简单地描述了产品经理、运营经理和设计师的工作关系。\n\n\t![产品、运营、设计工作关系图](/images/illustration/Reading/2018/03/Producting_An_Application_5-3.png)\n\t<center>图 5-3 产品、运营、设计工作关系图</center>\n\n#### 运营工作内容及岗位\n- 典型的产品生命周期：即每个阶段的运营重点都不同。图 5-4 展示了一款产品的生命周期。\n\n\t![产品的生命周期](/images/illustration/Reading/2018/03/Producting_An_Application_5-4.png)\n\t<center>图 5-4 产品的生命周期</center>\n\n- 运营目标：可量化的指标\n\t- 拉新：为 APP 带来下载或注册，或微信公众号拉粉。\n\t常用手段有：`搜索引擎优化`，`广告投放`，`渠道合作`、`社交媒体推广`。\n\t- 留存：想办法留住用户。运营的方式为：`优化产品内容机制`；`策划活动与用户互动`。\n\t- 促活：\n\t\t- 促用户更高频使用产品，增加用户黏性。可用 `等级设定`、`激励体系`、`积分制度` 等增加长期活跃性。\n\t\t- 已流失的用户，通过 `站内信`、`邮件`、`短信` 等手段召回。\n\t- 营收：增加付费用户和提高付费用户的活跃度。\n\n#### 运营工作方法论\n- 如何让运营手段更抓住人心，追根溯源就是研究人性，一款好的产品及运营，一定能迎合人性七宗罪中的其中之一。下述为 `利用人性` 的产品功能举例。\n\t- `色欲`：美女直播、陌陌、基于 LBS (基于位置的服务) 的陌生人社交。\n\t- `虚荣`：游戏装备。\n\t- `贪婪`：双十一折扣、抽奖、送红包。\n\t- `懒惰`：一键下单、二维码。\n\t- `窥探`：无秘、悄悄关注。\n\t- `傲慢`：吵架营销、粉丝大战。\n- 数据化运营：基于数据的运营决策更可靠。\n\t- 产品数据\n\t\t- 用户注册：包括下载量、注册用户激活数、APP 打开数、新增注册数等；\n\t\t- 用户留存：留存率、使用留存、购买留存等；\n\t\t- 用户活跃：活跃用户数、注册活跃转化率、APP 启动数、访问频率、浏览时长等；\n\t\t- 营收数据：付费用户数、付费转化率、付费金额、付费频次等；\n\t\t- 功能数据：每日评论数、交互反馈次数 (收藏、分享、喜欢等功能)。\n\t- 用户数据：用户画像 (性别、职业、学历、年龄、地域、使用设备、操作系统、消费行为)。\n\n### 活动运营\n\n#### 什么是活动运营\n- 传统行业短期的活动促销，带来一定人气增长、销售额增加。\n- 社交网络的病毒式传播，例如春晚微信摇红包、支付宝集五福等。\n\n#### 活动使用场景\n- 常规活动：有针对性提高某一指标，或新功能推广。其活动形式有：签到、邀请好友、新用户福利。\n- 节日：每个节日都有其自带的属性，利用节假日的情感共鸣。如表 5-1 所示。\n\n<center>表 5-1 常见节日举例</center>\n\n| 常见节日 | 举例 |\n| :----- | :--- |\n| 常规节日 | 春节、情人节、圣诞节、母亲节、劳动节 |\n| 人为创造 | 双十一、双十二、520告白日 |\n| 店庆活动 | 天猫店庆、周年庆 |\n| 季节变化 | 换季清仓、节气、春夏秋冬交替 |\n| 体育赛事 | 奥运会、欧冠、世界杯、NBA |\n| 颁奖典礼 | 奥斯卡、电影节 |\n\n每个节日都有其自带属性，例如春节会想到春运，双十一想到打折促销、中秋节想到团圆等。\n\n- 突发热点事件：极具话题性，短期爆发力强，能迅速传播。如表 5-2 列举了一些热点。\n\n<center>表 5-2 热点举例</center>\n\n| 热点 | 举例 |\n| :--- | :--- |\n| 民生类 | 与我有关的话题，生老病死的话题 |\n| 公益类 | 环保、支教、老人、儿童、宠物 |\n| 娱乐类 | 明星八卦、热门参与、笑话段子 |\n| 敏感话题 | 权利、金钱、色情 |\n| 技术趋势 | 人工智能、区块链、科技公司新品发布 |\n\n例如，肌萎缩侧索硬化症引发的冰桶挑战，达到的效果有：微博话题阅读超 7 亿，捐款总额达 137 万元。\n\n#### 如何策划线上活动\n策划线上活动共四阶段，即准备阶段、策划阶段、执行阶段和总结阶段。\n\n- `准备阶段`：活动前的准备\n\t- 活动需求：目的、人群、平台、机会点 (借势发挥，如世界杯)\n\t- 活动目的：量化为数据指标，核心目标为推广品牌、拉新用户、促进消费、提升用户活跃度。\n- `策划阶段`：活动方案策划\n\t- 明确活动的时间、内容、规范、文案、流程；\n\t- 确认奖品及协调推广资源；\n\t\n\t[注意] 策划方案时应：\n\t1) 流程简单，文案清晰；\n\t2) 吸引力，例如奖励等手段；\n\t3) 适时反馈，精神激励。例如动态显示参与人数、突出用户收益、获奖用户轮播。\n- `执行阶段`：活动上线后做好三点\n\t- 客服跟进：解决用户疑难，平息用户情绪。\n\t- 监控数据：随时调整，保证活动质量和预期。\n\t- 分布活动结果和活动善后 (`不要让用户感到被欺骗`)。\n- `总结阶段`\n\t- 用户参与情况和数据，用以判断是否达到目标。\n\t- 总结活动经验，提炼亮点和失误点，为下次活动做准备。\n\n#### 案例分析\n以 “新浪微博愚人节刮奖” 活动为例。\n\n- 活动类型：游戏\n- 活动目标：提升用户活跃度\n- 活动时间：愚人节，七天活动\n- 目标人群及切入需求：针对老用户 -> `逐利心理`\n- 平台：手机\n- 交互方式：模拟真实的刮奖操作\n- 规则判定\n\t- 每天每个用户可参与 5 次 刮刮卡活动，第一次免费。\n\t- 完成某些指定任务可获得更多抽奖活动。\n- 奖品设置\n\t- 根据预算控制奖品数量和中奖概率。\n\t- 头奖要吸引眼球，配合普通奖品，`增加用户获奖信心`。\n- 文案与视觉设计\n\t- 标题醒目，规则明确，页面简洁。\n\t- 结合活动主题渲染气氛。\n- 活动指标：参与人数，传播度 (分享数)，任务完成度，活动期间的活跃用户数。\n\n### H5 与 Banner 的设计\n\n#### H5 表现形式\nH5，即第五代 HTML，也泛指利用 HTML5 语言制作的页面。在开始设计前，先了解 H5 专题页的类型。\n\n- 按功能形式分：如图 5-5 所示。\n\n![按功能形式分的H5](/images/illustration/Reading/2018/03/Producting_An_Application_5-5.png)\n<center>图 5-5 按功能形式分的 H5</center>\n\n- 按目标分：如图 5-6 所示。\n\t\n\n![按目标分的H5](/images/illustration/Reading/2018/03/Producting_An_Application_5-6.png)\n<center>图 5-6 按目标分的 H5</center>\n\n- 在确定了专题页的功能与目标后，接下来的设计阶段尤为关键。即可从用户角度出发，思考用户的分享动机 (共六种情况)。\n\t- 利益相关：`有奖形式` 促进用户分享。\n\t- 有所收获：通过传播内容，学习自己感兴趣的知识，或 `自我提升`。\n\t- 身份认同：内容使某一类型人产生身份认同和归属感。\n\t- 成就吸引：朋友间竞技，满足用户 `炫耀心理需求`。\n\t- 情感共鸣：`情感共鸣`，从而产生集体回忆的分享冲动。\n\t- 借助热点：借助 `当前热点`，吸引用户眼球。\n\t\n- H5 页面表现形式\n\t- 展示型：支付宝十年账单、微信故事。\n\t- 互动型：智能招聘的职场神曲 DIY。\n\t- 产品型：微信公众号里的微商城，如京东。\n\n#### Banner \n投放于线上 (PC端、移动端) 的各种尺寸和形状的广告图。\n\n- 设计流程\n\t- 了解目的，定义信息优先级；\n\t- 确定文案，确定设计方向；\n\t- 视觉设计排版，讨论修改.\n- 搭配方式 => 输出 Banner\n\t- 内容专题：文案 + 主体物或文案 + 背景形式。`P238`\n\t- 电商：文案 + 主体物 + 背景形式。`P239`\n\t- 活动：文案 + 主体物 + 引导 Button + 背景 + 引导 Button 的形式。`P240 ~ 241`\n\n## 陆 服务设计\n\n### 概念\n\n#### 服务设计的定义\n一种新兴领域，主要关注通过 `有形、无形媒介的结合方式` 形成细致考量过的 `体验设计过程`。它已经在实践中为各种传统下行业都带来了更优良的用户体验。\n\n#### 相关术语\n\n> 本章节将围绕一个虚构的餐馆为例，姑且称他为 `美食与爱`。\n\n- 服务提供者：除一般含义的服务人员外，还包括电子显示屏、按钮开关等实体。\n\n\t> 在 `美食与爱` 中，就包括侍应、收银员、厨师、后台系统等。\n\n- 利益相关者：服务提供者所属的商业实体负责人。\n\n\t> 餐馆老板、门店经理、收银系统的服务商。\n\n- 服务设计团队：除设计师外，还包括利益相关者、一些顾客等。\n\n- 顾客：指服务提供者面向的用户、消费者等。\n\n- 触点：顾客与服务提供者之间每个有接触点的点。\n\n\t> 门口排位服务员、侍应、菜单、桌椅。\n\n- 服务周期：前期、中期和后期。\n\n\t以就餐为例：\n\t\n\t- `前期` 顾客感到饥饿时，有人推荐或搜 `美食与爱`，前往餐馆就餐。\n\t- `中期` 到门店后，需排位等待，收号入座，点菜，等就餐，就餐，结账。\n\t- `后期` 离开餐馆，呼叫的士回家 / 公司。 \n\n#### 五个原则\n- 用户至上：应通过客户的视角出发来设计整套服务。\n- 合作创新：设计师 (主持人)，利益相关者，服务提供人员，顾客。每种角色必须从自己视角出发提出想法。\n- 先后顺序：服务是一般以 `时间为序` 的 `动态` 的过程，而每一 `服务片段` 类似电影中的帧一样，把服务结构成一个个 `独立触点` 和 `交互行为`。\n- 有理有据：服务是无形的，需要用人工制品的形式“显示”出来，让其容易被感知。\n\n\t> 例如，酒店的清洁人员在客人不在时打扫卫生。\n\n- 全局视觉：涉及的角色、触点众多，具备全局视觉，以统筹好各个环节。\n\n### 设计流程\n以下介绍服务设计的基本流程，即 `探索` => `创造` => `反思` => `实施`。\n\n- `探索`\n\t- 了解公司对于设计思维的态度，是否接受服务设计这样需要合作创新的设计流程。\n\t- 找服务设计要解决的本质问题 (问题往往是公司自身的，或是从公司角度提出的)。\n\t- 找出问题本质所在。\n\n\t> 从 `潜在顾客` 和 `顾客` 的角度出发，理解他们当时的处境以及做出对应行为背后的真实动机。\n\n\t- 设计师要把研究后的发现和现有服务流程可视化方法展现出来。\n- `创造`：产生解决方案的阶段\n\t- 服务设计的最大特点：鼓励各种试错，而不是避免出错。\n\t- 阶段任务：\n\t\t- 基于探索阶段发现的核心问题；\n\t\t- 基于顾客需求；\n\t\t- 基于服务提供者本身诉求等约束条件；\n\t\t- 基于用户旅程图的一系列的触点.\n\n\t\t> 设计新的方案，并不断加以迭代验证、优化方案。\n- `反思`：创新阶段产生新方案后，这个阶段要进行测试验证。\n\t- 产品原型 (人机交互 Demo / 实体产品小样)，找顾客或者专家进行测试评估，然后不断改进以达到预期目标。\n\t- 服务原型：通过 `角色扮演` 等 `互动沉侵` 的方式，让顾客与服务之间产生 `真实的交互` 以及 `情感上的沟通`。\n- `实施`：工具 -- `服务蓝图`\n\n### 工具箱\n在 *This is service design thinking* \\\\(^{[1]}\\\\) 中，列举了 24 种服务设计的工具，下述选择了其中三款常用工具进行阐述，即 `影子跟随法`、`顾客旅程图`、`服务蓝图`，若对此模块有兴趣可查阅原书学习。\n\n#### 影子跟随法\n- 概念：研究人员或设计师把自己融入到顾客的，前后台人员的日常生活或工作中去，像 `影子` 一样跟着他们去观察他们一举一动。\n\n\t> 该方法可以真正做到从全局或者 `上帝视觉` 审视整个服务运作方式。\n\t\n#### 顾客旅程图\n- 概念：用 `顾客` 与 `服务` 之间产生互动的一个个 `触点` 来构成用户完整旅程的 `地图`。即这个图是从顾客的视角表达出所有与服务之间互动的行为以及由于互动而产生的情感。\n- 如何绘制顾客旅程图\n\t- 1) 需要找到顾客与服务之间所有互动的行为触点。\n\t- 2) 当所有行为触点找出后，按时序的方式进行罗列以形成完整的体验流程。\n\t- 3) 然后通过访谈或利用顾客自己的描述和记录，以顾客口吻表达出他们每个步骤的心理活动，对应某种情绪，打分以形成情绪曲线图。\n\t- 4) 分析旅程图中情绪分值较低部分 (尤其是 `谷底` 时)，找出问题所在，往往当中存在不错创新设计机会点。\n\n\t如图 6-1 所示，为餐馆就餐的典型顾客旅程图。\n\t\n\n![餐馆就餐的典型顾客旅程图](/images/illustration/Reading/2018/03/Producting_An_Application_6-1.png)\n<center>图 6-1 餐馆就餐的典型顾客旅程图</center>\n\n#### 服务蓝图\n> 服务蓝图，类似建筑设计的蓝图。\n\n- 从全局的视觉详细地设计服务体系里包含的所有对象、交互、触点等的图形化语言。\n- 该图包含多种角色：用户、服务提供者，涉及服务流程相关者，触点及后台流程。\n- 服务蓝图绘制方法： \n\t- 首先按时序把 `用户新的行为` (设计后的行为) 从左到右罗列出来。并从服务的前中后阶段 (如就餐前、就餐时、就餐后) 对其进行分类。\n\t- 在行为 `上一行`，列出用户行为所接触的物理触点或环境。\n\t- 在行为 `下一行`，列出用户交互的服务提供者。\n\t- 在行为 `下两行`，是后台服务提供者以及提供的支援流程。\n\n\t如图 6-2 所示，针对餐馆优化后的服务蓝图。\n\n![针对餐馆优化后的服务蓝图](/images/illustration/Reading/2018/03/Producting_An_Application_6-2.png)\n<center>图 6-2 针对餐馆优化后的服务蓝图</center>\n\n## 参考资料\n[[1] Schneider, Jakob. This is service design thinking [M]. Canada: BIS Publishers, 2011](https://book.douban.com/subject/5397784/)  \n[2] 赵晋. 波士顿矩阵分析在实际案例中的运用[J]. 中国高新技术企业,2008,(8).  \n[3] 张镜天. 波士顿矩阵在酒类营销中的运用[J]. 中国酒业. 2006,(1).  \n[4] 上海质量科学研究院. 顾客满意的测量、分析与改进[M]. 中国标准出版社,2009.10.  ","tags":["APP","产品","设计流程","规范"],"categories":["Reading"]},{"title":"场景化学习设计模式：Android 案例与实践","url":"/2018/01/Design-Pattern-Based-on-Android.html","content":"\n在安卓项目中，诸如监听器、适配器、迭代器等并不陌生，然而它们无不体现着设计模式的精髓，设计与模式的结合往往与设计能力与代码质量息息相关。同理逆向思考此类问题，对于一些优秀项目源码的学习障碍往往是对其架构设计的理解（逻辑、性能、解耦等），而不仅仅是源码本身。作为开发者，知其然知其所以然，这也正是我们深入学习设计模式的理由之一。\n\n当然，我们还要正视学习设计模式的心态，掌握了各种设计模式，并不代表个人的设计能力与代码质量就能突飞猛进；同样在项目中，也不是生搬硬套设计模式就能解决问题的。在《 [Head First 设计模式](https://book.douban.com/subject/2243615/) 》一书中指出，即没有最好的模式，只有最适合问题的设计模式，学习过程与运用过程要注重融会贯通。\n\n最后，学习设计模式不要局限于《 [Android 源码设计模式](https://book.douban.com/subject/26644935/) 》本身，您还可以搭配一些经典论文、综述或者书籍学习，以至于怀疑一个问题的正误时，多比对、多思考，以得到正确理解。\n\n<!-- More -->\n\n- 推荐书目：\n\t- 《 设计模式（可复用面向对象软件的基础）》\n- 推荐项目：\n\t- [Design Pattern Quick Reference.Jason Mcdonald](http://www.mcdonaldland.info/2007/11/28/40/)：[PDF Download](/pdf/Design_Pattern_Quick_Reference.pdf)\n\t- [Awesome Design Patterns.DovAmir.Github](https://github.com/DovAmir/awesome-design-patterns#languageframework-design-patterns-mainly-gof)\n\n## 更新进程\n- 2018.01.30：完成序言；\n- 2018.01.31：更新第壹章；\n- 2018.02.05：更新第贰章 ( 共 23 种设计模式 )；\n- 2021.04.19：所有图片资源更新为 svg 格式源；\n- 2021.05.02：重新梳理内容、排版格式；\n\n## 内容总览\n\n- [零 本书架构](#零-本书架构)\n- [壹 面向对象编程六大原则](#壹-面向对象编程六大原则)\n- [贰 二十三种设计模式解析](#贰-二十三种设计模式解析)\n- [叁 MVC 与 MVP 模式](#叁-MVC-与-MVP-模式)\n\n\n## 零 本书架构\n### 面向对象六大原则\n- `单一职责原则`：优化代码第一步。即就一个类而言，应该 `有且仅有` 一个引起它变化的原因。\n- `开闭原则`：让程序更稳定、更灵活，即软件中的对象（类、模块、函数等）对于扩展是开放的，但对于修改是封闭的。\n- `里氏替换原则`：构建扩展性更好的系统。\n- `依赖倒置原则`：让项目拥有变化能力，即依赖抽象，不依赖具体实现。\n- `接口隔离原则`：系统拥有更高灵活性。\n- `迪米特原则`：也称为 `最少知识原则`，即一个对象应对其他对象有最少的了解。\n\n### 二十三种设计模式\n\n| 模式名称 | 目的 | 一句话描述 |\n| :--- | :--- | :--- |\n| 单例模式 | 创建型 | 一个类只有一个实例 |\n| Build 模式 | 创建型 | 自由拓展你的项目 |\n| 原型模式 | 创建型 | 使程序运行更高效 |\n| 工厂方法模式 | 创建型 | 生成复杂对象 |\n| 抽象工厂模式 | 创建型 | - |\n| 策略模式 | 行为型 | 时势造英雄 |\n| 状态模式 | 行为型 | 随遇则安 |\n| 责任链模式 | 行为型 | 使编程更有灵活性 |\n| 解释器模式 | 行为型 | 化繁为简的翻译机 |\n| 命令模式 | 行为型 | 让程序畅通执行 |\n| 观察者模式 | 行为型 | 解决、解耦的钥匙 |\n| 备忘录模式 | 行为型 | 编程中的后悔药 |\n| 迭代器模式 | 行为型 | 解决问题的第三者 |\n| 模块方法模式 | 行为型 | 抓住问题的核心 |\n| 访问者模式 | 行为型 | 数据结构与操作分离 |\n| 中介者模式 | 行为型 | 调解者模式或调停者模式 |\n| 代理模式 | 结构型 | 委托模式 |\n| 组合模式 | 结构型 | 物以类聚 |\n| 适配器模式 | 结构型 | 得心应手粘合剂 |\n| 装饰模式 | 结构型 | 动态给对象添加额外职责 |\n| 享元模式 | 结构型 | 对象共享，避免创建多对象 |\n| 外观模式 | 结构型 | 统一编程接口 |\n| 桥接模式 | 结构型 | 连接两地的交通枢纽 |\n\n- 按照设计模式的目的可分为三类：创建型模式与对象的创建相关；结构型模式处理类或对象的组合；行为型模式对类或对象如何交互以及怎样分配职责进行描述。\n- 容易混淆的设计模式之间相比较：\n\t- 策略模式 v.s. 状态模式\n\t- 代理模式 v.s. 装饰模式\n\t- 原型模式 v.s. 备忘录模式\n\t- 观察者模式 v.s. 发布订阅模式\n\n## 壹 面向对象编程六大原则\n### 单一职责原则\n- Single Responsibility Principle，SRP\n- 即就一个类而言，应该仅有一个引起它变化的原因。\n- 如何划分一个类、一个函数的职责？每个人的经验不同，观点看法也不同，故视具体任务而定。但也有一些基本原则供参考：  \n\t- 两个完全不一样的功能就不应该放到同一个类中。\n\t- 一个类中应该是一组相关性很高的函数、数据的封装。\n\n### 开闭原则\n- Open Close Principle，OCP\n- 即软件中的对象（类、模块、函数等）应该对于 `扩展是开放` 的，但对于 `修改是封闭` 的。\n\n- 勃兰特·梅耶. 《面向对象软件构造》中提倡：\n\t- 新的特性应通过新建不同的类实现，新建的类可通过 `继承` 的方式来重用原类的代码。\n\t- 已存在的实现类对于修改是封闭的，但新的实现类可通过 `覆写父类的接口` 应对变化。\n\n\t> 总结：当软件需变化时，应该尽量通过扩展方式来实现变化，而不是通过修改已有代码来实现。\n\n### 里氏替换原则\n\n> 往往开闭原则与里氏替换原则是生死相依、不离不弃的。\n\n- Liskov Substitution Principle，LSP\n- 所有引用基类的地方必须能透明地使用其子类的对象。\n- 举例：任何继承自 View 类的子类都可以设置给 show 方法，即里氏替换。尽管千变万化的 View 传递给 Window，Window 只管组织 View 并显示在屏幕上。\n\n\t```java\n\tpublic abstract class View {\n\t\tpublic abstract void draw();\n\t\tpublic void measure(int width, int height) {\n\t\t\t// 测量视图的大小\n\t\t}\n\t}\n\tpublic class Button extends View {\n\t\tpublic draw() {\n\t\t\t// 绘制按钮\n\t\t}\t\n\t}\n\tpublic class Windows {\n\t\tpublic show(View child) {\n\t\t\tchild.draw();\n\t\t}\n\t}\n\t```\n\n### 依赖倒置原则\n- Dependence Inversion Principle，DIP\n- 一种特定的 `解耦形式`，使得高层次的模块不依赖于低层次的模块的实现细节。\n- 依赖倒置原则的几个关键点：\t\n\t- 高层模块不应该依赖低层模块，两者都应依赖其抽象（接口或抽象类）；\n\n\t\t> 高层模块指调用端，低层模块指实现类。\n\t\n\t- 抽象不应该依赖细节，细节应依赖抽象。\n\n- 模块间的依赖通过抽象发生，实现类之间不发生直接依赖关系。\n\n\t> 一句话概括：`面向接口编程，面向抽象编程`\n\n- 举例：设计一款实现图片缓冲功能的接口，具体的缓冲实现方式、细节，根据实际情况编写。\n\n\t```Java\n\tpublic interface ImageChache {\t// ImageCache 缓存抽象\n\t\tpublic Bitmap get(String url);\n\t\tpublic void put(String url, Bitmap bmp);\n\t}\n\tpublic class MemoryCache implements ImageCache {\n\t\t// 根据实际需求，再实现具体细节\n\t}\n\tpublic class ImageLoader {\n\t\t// 图片缓存类，依赖抽象，不依赖细节\n\t\tImageCache mCache = new MemoryCache();\n\t\tpublic void displayImage(String url, ImageView imageView) {\n\t\t\tBitmap bmp = mCache.get(url);\n\t\t\tif(null == bmp){\n\t\t\t\tdownloadImageAsync(url, imageView);\n\t\t\t} else {\n\t\t\t\timageView.setImageBitmap(bmp);\n\t\t\t}\n\t\t}\n\t\tpublic void setImageCache(ImageCache cache) {\n\t\t\tthis.mCache = cache;\n\t\t}\n\t}\n\t```\n\n### 接口隔离原则\n- Interface Segregation Principles，ISP\n- 类间的依赖关系应建立在最小接口上。ISP 将非常庞大、臃肿的接口拆分成更小的和更具体的接口。IPS的目的是系统解开耦合。\n\n\t> 如上例 ImageLoader 中的 ImageCache，ImageLoader 只需要知道该缓存对象有存、取缓存图片的接口即可，其他一概不管。\n\n### 迪米特原则\n- 一个对象应对其他对象有最少的了解、即类的内部如何实现与调用者、依赖者没关系，调用者或依赖者之需知道它需要的方法即可，其他一概不管。\n\n- 图 1-1 展示了租客、中介与房间相互之间的需求关系。\n\n\t![租客、中介与房间关系](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_1-1.svg)\n\t<center>图 1-1 租客、中介与房间关系</center>\n\n\t因为租客只需要房子，即把需求转达中介，对房子具体的租金、维修、签约等交由中介处理，租客不需要再了解细节。改进效果见图 1-2。\n\n\t![租客、中介与房间关系](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_1-2.svg)\n\t\n\t<center>图 1-2 改进：租客、中介与房间的关系</center>  \n\n## 贰 二十三种设计模式解析\n### 单例模式\n#### 单例模式的定义\n- 确保某 `一个类只有一个实例` ，而且自行实例化并向整个系统提供这个实例。\n\n\t> `一个类只有一个实例` ：避免产生多个对象消耗过多资源，如访问 I/O 和数据库等资源。\n\n#### 单例模式 UML 类图\n![单例模式示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-1.svg)\n<center>图 2-1 单例模式示意图</center> \n\n- 实现单例模式主要有如下几个关键点：\n\t- `构造函数` 不对外开放，一般设为 `私有` ；\n\t- 通过一个 `静态方法` 或者 `枚举返回` 单例类对象；\n\t- 确保单例类的对象有且只有一个，尤其多线程环境下；\n\t- 确保单例类对象在 `反序列化` 时不会重新构建对象；\n\t\n\t\t> `序列化`：将对象的状态信息转换为可以存储或传输的形式的过程。一般将一个对象存储至一个储存媒介，例如档案或是记亿体缓冲等。在网络传输过程中，可以是字节或是 XML 等格式。  \n\t\t> `反序列化`：而字节的或XML编码格式可以还原完全相等的对象。这个相反的过程又称为反序列化。\n\n#### 单例模式的简单示例\n- 举例：例如一个公司只有一个 CEO，一个应用只有一个 Application 对象等。下面以公司里的 CEO 为例来简单演示，即一个公司只有一个 CEO，可有多个 VP 以及多名员工。\n\n\t```Java\n\t// 员工的基类\n\tpublic class Staff { \n\t\tpublic void work(){\n\t\t\t// 忽略执行细节\n\t\t}\n\t}\n\t \n\t// 副总裁类\n\tpublic class VP extends Staff {\n\t\tpublic void work() {\n\t\t\t// 覆写执行细节\n\t\t}\n\t}\n\t\n\t// 饿汉单例模式：声明静态对象时已初始化\n\tpublic class CEO extends Staff { // 公司保证只有一个 CEO\n\t\tprivate static final CEO mCeo = new CEO();\n\t\tprivate CEO(){}\n\t\tpublic static CEO getCeo() {\n\t\treturn mCeo;\n\t\t}\n\t\tpublic void work() {\n\t\t// 覆写执行细节\n\t\t}\n\t}\n\t\n\t/*\n\t * 实际中使用：\n\t * CEO 类不能通过 new 的形式构造对象，只能通过 CEO.getCeo() 函数获取。\n\t * CEO 对象是静态对象，并在声明时已初始化，保证 CEO 对象的唯一性。\n\t */\n\tStaff ceo1 = CEO.getCeo();\t\n\tStaff ceo2 = CEO.getCeo();\n\t```\n\n#### 单例模式的其他实现方式\n##### 懒汉模式\n- 懒汉单例模式：用时才初始化，即 `惰性处理机制`\n\n\t```Java\n\tpublic class Singleton {\n\t\tprivate static Singleton instantce;\n\t\tprivate Singleton() {}\n\t\n\t\t// 添加 synchronized 关键字，即 getInstance() 是一个同步方法\n\t\tpublic static synchronized Singleton getInstance() {\n\t\t\tif( null == instance ) {\n\t\t\t\tinstance = new Singleton();\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t}\n\t```\n\n\t- 声明一静态对象；\n\t- 调用 getInstance() 方法初始化（用时才初始化，即惰性处理机制）；\n\t- 懒汉单例模式优点：使用时才实例化，一定程度上节约资源；\n\t- 懒汉单例模式缺点：每次调用 getInstance() 都进行同步，造成不必要同步开销。\n\n##### 双重检查锁定\n- 双重检查锁定（Double CheckLock, DCL）\n\n\t```Java\n\tpublic class Singleton {\n\t  // private static Singleton sInstance = null;\n\t  // 保证 sInstance 对象每次都是从主内存存、读取\n\t  private volatile static Singleton sInstance = null; \n\n\t  private Singleton() {}\n\t\n\t  public void doSomething() {\n\t    System.out.println(\"do sth.\");\n\t  }\n\n\t  public static Singleton getInstance() {\n\t    if( null == sInstance ) { // 避免不必要同步\n\t      synchronized(Singleton.class) {\n\t        // 此处判空操作，是因为 Java 编译器允许处理器乱序执行，具体见下述解析\n\t        if( null == sInstance ) { \n\t          sInstance = new Singleton();\n\t        }\n\t      }\n\t    }\n\t    return sInstance;\n\t  }\n\t}\n\t```\n\n- DCL 又称「丑陋的优化」：DCL 虽一定程度解决了资源消耗，多余同步、线程安全等问题，但某种情况下还是会出现失效问题，为此称 DCL 为「丑陋的优化」。\n- 线程 A 执行 `sInstance = new Singleton()`，编译器会编译成多条汇编指令，具体汇编指令的分工：\n\n\t- Step.01 给 Singleton 实例分配内存；  \n\t- Step.02 调用 Singleton() 的构造函数；  \n\t- Step.03 将 sInstance 对象指向分配的内存空间.\n\n- 然而 Java 编译器允许处理器 `乱序执行`，即有「1-2-3」或「1-3-2」的执行顺序。\n\n\t> 重排序，包括 `Java 指令重排序` 以及 `机器指令重排序`。\n\n- 若执行「1-3-2」的顺序，这样会使 DCL 的优化失效，即第三步执行完毕，sInstance 非空，线程 B 取走 sInstance。再使用时就会报错。\n\n##### 静态内部类单例\n- 静态内部类单例模式\n\n\t```java\n\tpublic class Singleton {\n\t\tprivate Singleton() {}\n\t\tpublic static Singleton getInstance() {\n\t\t\treturn SingletonHolder.sInstance;\n\t\t}\n\t\tprivate static class SingletonHolder { // 静态内部类\n\t\t\tprivate static final Singleton sInstance = new Singleton();\n\t\t}\n\t}\n\t```\n\n- 第一次加载 Singleton 的 getInstance() 方法才会使 sInstance 被初始化。因此，第一次调用 getInstance() 方法会导致虚拟机加载 SingletonHolder 类。\n- 内部类是 `延时加载` 的，只会在第一次使用时加载，不使用不加载。这样即保证了线程安全，又保证单例对象唯一性，同时也延迟单例的实例化。\n\n##### 枚举单例\n- 默认枚举实例的创建是线程安全的，并且在任何情况下它都是一个单例。\n\n\t```Java\n\tpublic enum SingletonEnum {\n\t\tINSTANCE;\n\t\tpublic void doSomething() {\n\t\t\tSystem.out.println(\"do sth.\");\n\t\t}\n\t}\n\t```\n\n#### 总结\n- 不管以哪种形式实现单例模式，核心原理都是将 `构造函数私有化`，并通过 `静态方法获取一个唯一实例`。\n\n\t> 获取实例的过程须保证线程安全，防止反序列化导致重新生成实例对象等。\n\n- 选择哪种实现形式取决项目本身，如是否是复杂的并发环境、JDK 版本是否过低、单例对象的资源消耗等。\n- 单例模式优点  \n\t- 只生成一个实例，减少系统的性能开销。  \n\t- 当产生一对象的需要较多资源时，如读取配置、产生其他依赖对象时，可通过应用启动时直接产生一个单例对象，永久驻留内存。\n- 单例模式缺点\n\t- 单例模式一般没有接口，扩展性难。 \n\t- 单例对象若持有 Context，那么很容易引发内存泄漏，此时需注意传递给单例对象的 Context 应该是 `Application.Context`。\n\n### Bulider 模式\n#### Bulider 模式的定义\n- 创建型设计模式。\n- 将一个复杂对象的 `构建` 与它的 `表示` 分离，使得同样的构建过程可以创建不同的表示。\n- Builder 模式是一步步创建一个复杂对象的，它允许用户在不知内部构建细节的情况下，可以更精细地控制对象的构造流程。\n\n#### Builder 模式的使用场景\n- 产品类非常复杂，或产品类中调用顺序不同产生不同的作用，这时需要使用 Builder 模式。\n- 初始化一个对象特别复杂，如参数多，且很多参数都具有默认值。\n\n#### Builder 模式的 UML 类图\n![Builder模式示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-2.svg)\n<center>图 2-2 Builder 模式示意图</center> \n\n#### Builder 模式的简单实现\n- 利用 Builder 模式解释计算机的组装过程。\n\n\t```Java\n\t/* 下述程序以计算机组装过程简化为：构建主机，设置操作系统，设置显示器 */\n\n\t// 计算机抽象类：Product 角色\n\tpublic abstract class Computer {\n\t\tprotected String mBoard;\n\t\tprotected String mDisplay;\n\t\tprotected String mOS;\n\t\tprotected Computer() {}\n\t\tpublic void setBoard(String board) { // 设置 CPU 核心数\n\t\t\tmBoard = board;\n\t\t}\n\t\tpublic void setDisplay(String display) { // 设置内存\n\t\t\tmDisplay = display;\n\t\t}\n\t\tpublic abstract void setOS();\n\t\t@override\n\t\tpublic String toString() {\n\t\t\treturn \"Computer[...]\";\n\t\t}\n\t}\n\t// 具体 Computer 类：MacBook\n\tpublic class Macbook extends Computer {\n\t\tprotected Macbook() {}\n\t\t@override\n\t\tpublic void setOS() {\n\t\t\tmOS = \"MAC OSX 10.10\";\n\t\t}\n\t}\n\t// 抽象 Builder 类\n\tpublic abstract class Builder {\n\t\tpublic abstract class Builder {\n\t\t\tpublic abstract void buildBoard(String board); // 设置主机\n\t\t\tpublic abstract void buildOS(); // 设置操作系统\n\t\t\tpublic abstract void buildDisplay(String display); // 设置显示器\n\t\t\tpublic abstract Computer create(); // 创建 Computer\n\t\t}\n\t}\n\t// 具体 Builder 类：MacbookBuilder\n\tpublic class MacbookBuilder extends Builder {\n\t\tprivate Computer mComputer = new Macbook();\n\t\tpublic void buildBoard(String board){\n\t\t\tmComputer.setBoard(board);\n\t\t}\n\t\tpublic void buildDisplay(String display) {\n\t\t\tmComputer.setDisplay(display);\n\t\t}\n\t\tpublic void buildOS() {\n\t\t\tmComputer.setOS();\n\t\t}\n\t\tpublic Computer create() {\n\t\t\treturn mComputer;\n\t\t}\n\t}\n\t// Director 类：负责构造 Computer\n\tpublic class Director {\n\t\tBuilder mBuilder = null;\n\t\tpublic Director(Builder builder) {\n\t\t\tmBuilder = builder;\n\t\t}\n\t\tpublic void construct(String board, String display) {\n\t\t\tmBuilder.buildBoard(board);\n\t\t\tmBuilder.buildDisplay(display);\n\t\t\tmBuilder.buildOS();\n\t\t}\n\t}\n\n\t// 客户端实现\n\tpublic class Test {\n\t\tpublic static void main(String[] args) {\n\t\t\tBuilder builder = new MacbookBuilder(); // 构造器\n\t\t\tDirector pcDirector = new Director(builder); // Director\n\t\t\t// 封装构建过程\n\t\t\tpcDirector.construct(\"英特尔主板\", \"Retina 显示器\");\n\t\t\tSystem.out.println(\"Computer Info:\"\n\t\t\t\t+ builder.create().toString());\n\t\t}\n\t}\n\t```\n\n- 便于理解，本示例的 UML 类图见图 2-3。\n\n\t![计算机组装过程](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-3.svg)\n\t\n\t<center>图 2-3 计算机组装过程</center> \n\n#### Builder 模式实战\n- 举例：知名图片加载库 Universal-Image-Loader\n\n\t```Java\n\tImageLoaderConfiguration config = new ImageLoaderConfiguration\n\t\t/**\n\t\t * 用户只能通过 Builder 对象构建 ImageLoaderConfiguration 对象\n\t\t * 这就是构建和表示相分离\n\t\t */\n\t\t.Builder(context) \n\t\t.threadPriority(Thread_NORM_PRIORITY_2)\n\t\t.denyCacheImageMultipleSizesInMemory()\n\t\t.discCacheFileNameGenerator( new MD5FileNameGenerator() )\n\t\t.tasksProcessingOrder(QueueProcessingType.LIFO)\n\t\t.bulider();\n\t\n\tImageLoader.getInstance().init(config);\n\t```\n\n#### 总结\n- Builder 模式，通过作为配置类的构建器将配置的构建和表示分离开来，同时也将配置从目标类中隔离出来，避免过多的 Setter 方法暴露在目标类当中。\n- Builder 模式的优点  \n\t- 良好的封装性，不必知道产品内部组成的细节；  \n\t- 建造者独立，易于扩展。\n- Builder 模式的缺点  \n\t- 产生多余 Builder 对象及 Director 对象，消耗内存。\n\n### 原型模式\n#### 原型模式的定义\n- 创建型的模式。\n- 定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。\n\t- 原型拥有 `样板实例`，可克隆内部属性一致的对象。\n\t- 原型模式多用于创建复杂的或构建耗时的实例，即复制一个已经存在的实例可使程序运行更高效。\n\n#### 原型模式的使用场景\n- 类初始化需消耗非常多的资源（数据、硬件资源等）。\n- 通过 new 产生一个对象需要非常繁琐的数据准备或访问权限。\n- 一个对象需提供其他对象访问，且各调用者可能都需修改其值时，可考虑用原型模式或拷贝多个对象以供调用者使用，即 `保护性拷贝` 。\n\n#### 原型模式的 UML 类图\n![Builder模式示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-4.svg)\n<center>图 2-4 原型模式的 UML 类图</center> \n\n#### 原型模式的简单实现\n- 设计一简单文档处理功能类，支持编辑克隆对象以保障源文件的安全性。\n\n\t```Java\n  /**\n\t * WordDocument 具有文字、图片编辑功能的简单文档处理类。\n\t * 为保护源文件，其可在克隆对象上作内容修改。\n\t */\n\tpublic class WordDocument implements Cloneable {\n\t\t// WordDocument 扮演 ConcretePrototype 角色\n\t\t// Cloneable 扮演 Prototype 角色\n\t\tprivate String mText; // 文本\n\t\tprivate ArrayList<String> mImages = new ArrayList<String>(); // 图片名列表\n\t\tpublic WordDocument() {\n\t\t\t// 忽略实现细节\n\t\t}\n\t\t@Override\n\t\tprotected WordDocument clone() {\n\t\t\ttry {\n\t\t\t\t// 对象拷贝一份（浅拷贝）\n\t\t\t\tWordDocument doc = (WordDocument) super.clone();\n\t\t\t\t// 对象里的成员变量也拷贝一份（深拷贝）\n\t\t\t\tdoc.mText = this.mText;\n\t\t\t\tdoc.mImages = this.mImages;\n\t\t\t\treturn doc;\n\t\t\t} catch(Exception e) {\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tpublic String getText() {\n\t\t\treturn mText;\n\t\t}\n\t\tpublic void setText(String mText) {\n\t\t\tthis.mText = mText;\n\t\t}\n\t\tpublic List<String> getImage() {\n\t\t\treturn mImages;\n\t\t}\n\t\tpublic void addImage(String img) {\n\t\t\tthis.mImages.add(img);\n\t\t}\n\t\tpublic void showDocument() {\n\t\t\tSystem.out.println(\"Text:\" + mText);\n\t\t\tSystem.out.println(\"Images List:\");\n\t\t\tfor(String imgName:mImages) {\n\t\t\t\tSystem.out.println(\"image name:\" + imgName);\n\t\t\t}\n\t\t}\n  }\n\n\t// 客户端实现\n\tpublic class Client {\n\t\tpublic static void main(String[] args) {\n\t\t\tWordDocument originDoc = new WordDocument();\n\t\t\t/* Partion A start */\n\t\t\toriginDoc.setText(\"This is a Aircle\");\n\t\t\toriginDoc.addImage(\"Image A\");\n\t\t\t/* Partion A end */\n\t\t\toriginDoc.showDocument();\n\n\t\t\tWordDocument secDoc = originDoc.clone();\n\t\t\tsecDoc.showDocument();\n\t\t\tsecDoc.setText(\"This is a Paper\"); // 只是改变了引用指向\n\t\t\tsecDoc.showDocument();\n\t\t\toriginDoc.showDocument(); // 还是输出 Partion A 的结果\n\t\t}\n\t}\n\t```\n\n\t> 注意：通过 clone() 拷贝对象时并不会执行构造函数。如果在构造函数中需要一些特殊的初始化操作类型，在使用 Cloneable 实现拷贝时需特别去处理。\n\n- 便于理解，本示例的 UML 类图见图 2-5。\n\n\t![WordDocument文档编辑器](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-5.svg)\n\t\n\t<center>图 2-5 WordDocument 文档编辑器</center> \n\n#### 浅拷贝和深拷贝\n- 浅拷贝：上述例子实际上只是一个浅拷贝，也称 `影子拷贝`，即只是副本文档 `引用` 原始文档的字段。\n\n\t![浅拷贝示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-6.svg)\n\t<center>图 2-6 浅拷贝示意图</center> \n\n\t```Java\n\tsecDoc.setText(\"This is a Paper.\");\n\tsecDoc.addImage(\"Image B\");\n\tsecDoc.showDocument(); // Case 1\n\toriginDoc.showDocument(); // Case 2\n  ```\n\n\t> Case 1，2 都增加了图片 “Image B”，原因是 secDoc 只是单纯指向了 this.mImages。\n\n- 深拷贝：为了解决浅拷贝所带来的“问题” ( 视具体问题而定 )，引入深拷贝。\n\n\t```Java\n\t@Override\n\tprotected WordDocument clone() {\n\t\ttry {\n\t\t\tWordDocument doc = (WordDocument) super.clone();\n\t\t\tdoc.mText = this.mText;\n\t\t\t// doc.mImages 指向 mImages 的一份拷贝，而不是 this.mImages 本身\n\t\t\tdoc.mImages = (ArrayList<String>) this.mImages.clone();\t\t\n\t\t\treturn doc;\n\t\t} catch(Exception e) {\n\t\t}\n\t\treturn null;\n\t}\n\t```\n\n#### 原型模式实战\n- 用户信息的更新，限定于与 LoginSession 类在同一包下才能执行，即 Partion A 的操作，使这样的限定失效。\n\n\t```Java\n\t/* 在线用户信息修改（需登录后修改用户信息） */\n\t\n\t// 用户实体类\n\tpublic class User {\n\t\tpublic int age;\n\t\tpublic String name;\n\t\tpublic String phoneNum;\n\t\tpublic Adress adress;\n\t}\n\t\n\t// 登录接口\n\tpublic interface Login (\n\t\tvoid login();\n\t)\n\n\tpublic class LoginImpl implements Login {\n\t\t@Override\n\t\tpublic void login() {\n\t\t\tUser loginedUser = new User(); // 登录服务器，获取用户信息\n\t\t\tloginedUser.age = 12;\n\t\t\tloginedUser.name = \"Mr.Sample\";\n\t\t\tloginedUser.address = new Address(\n\t\t\t\t\"BeiJing\", \"HaiDing\", \"Garden Rd\");\n\n\t\t\t// 登录完成后，将用户信息设置到 Session:\n\t\t\tLoginSession.getLoginSession().setLoginedUser(loginedUser)\n\t\t}\n\t}\n\n\t// 登录 Session\n\tpublic class LoginSession {\n\t\tstatic LoginSession sLoginSession = null;\n\t\tprivate User longinedUser; // 已登录用户\n\t\tprivate LoginSession() {}\n\t\tpublic static LoginSession getLoginSession() {\n\t\t\tif(null == sLoginSession) {\n\t\t\t\tsLoginSession = new LoginSession();\n\t\t\t}\n\t\t\treturn sLoginSession;\n\t\t}\n\n\t\t// 包级私有：即不加任何修饰符，该模式(默认访问模式)下，只允许在同一包中进行访问\n\t\tvoid setLoginedUser(User user) { // 设置已登录用户信息，不对外开放\n\t\t\tloginedUser = user;\n\t\t}\n\n\t\tpublic User getLoginedUser() {\n\t\t\treturn loginedUser;\n\t\t}\n\t}\n\n\t/* Partion A : 以下是实际执行部分，可能在不同包的某个类下执行 */\n\n\t// 获取已登录的 User 对象\n\tUser newUser = LoginSession.getLoginSession().getLoginedUser();\n\t// 更新用户信息\n\tnewUser.address = new Adress(\"BeiJing\", \"ChaoYang\", \"DaWang Rd\");\n\t```\n\n- 我们可作以下改进：\n\t- 在 User 类中实现 Cloneable 接口。\n\t- 在 LoginSession 中将 getLoginedUser() 改为 `return loginedUser.clone()` ，即在任何地方调用，获得的都是用户拷贝的对象，修改只是作用于拷贝的对象。\n\n  ```Java\n\t// 实现 Cloneable 接口\n\tpublic class User implements Cloneable { // 用户实体类\n\t\tpublic int age;\n\t\tpublic String name;\n\t\tpublic String phoneNum;\n\t\tpublic Adress adress;\n\t\n\t\t@Override\n\t\tpublic User clone() {\n\t\t\tUser user = null;\n\t\t\ttry {\n\t\t\t\tuser = (User) super.clone();\n\t\t\t} catch(CLoneNotSupportedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn user;\n\t\t}\n\t}\n\t\n\tpublic class LoginSession { \n\t\t// 即管在任何地方调用，获得的都是用户拷贝的对象\n\t\tpublic User getLoginedUser() {\n\t\t\treturn loginedUser.clone();\n\t\t}\n\t}\n\t```\n\n#### 总结\n- 原型模式的优点：原型模式是在内存中二进制的拷贝，比 new 一个对象性能更优。\n- 原型模式的缺点：内存中拷贝，构造函数是不会执行的。\n\n### 工厂方法模式\n#### 工厂方法模式的定义\n- 创建型设计模式。\n- 定义一个用于创建对象的接口，让子类决定实例化哪个类，使得一个 `类的实例化延迟到其子类`。\n\n#### 工厂方法模式的使用场景\n- 创建复杂对象，相反用 New 即可完成创建的对象则不必使用工厂方法了。\n\n#### 工厂方法模式的 UML 类图\n- 工厂方法模式的 UML 如图 2-7 所示。\n\n  ![浅拷贝示意图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-7.svg)\n\n  <center>图 2-7 工厂方法模式 UML 类图</center> \n\n- 工厂方法的简单代码实现：\n\n\t```Java\n\tpublic abstract class Product {\n\t\tpublic abstract void method();\n\t}\n\t\n\tpublic class ConcreteProductA extends Product { // 具体产品 A\n\t\t@Override\n\t\tpublic void method() {\n\t\t\tSystem.out.println(\"我是具体的产品A.\");\n\t\t}\n\t}\n\t\n\tpublic class ConcreteProductB extends Product { // 具体产品 B\n\t\t@Override\n\t\tpublic void method() {\n\t\t\tSystem.out.println(\"我是具体的产品B.\");\n\t\t}\n\t}\n\t\n\tpublic abstract class Factory { // 抽象工厂类\n\t\t/*\n\t\t * @return 具体的产品对象\n\t\t */\n\t\tpublic abstract Product createProduct();\n\t}\n\t\n\tpublic class ConcreteFactory extends Factory {\n\t\t@Override\n\t\tpublic Product createProduct() {\n\t\t\t// 返回具体产品 A 或者具体产品 B\n\t\t\t// return new ConcreteProductA();\n\t\t\t// return new ConcreteProductB();\n\t\t}\n\t}\n\n\t// 客户端实现\n\tpublic class Client {\n\t\tpublic static void main(String[] args) {\n\t\t\tFactory factory = new ConcreteFactory();\n\t\t\tProduct p = factory.createProduct();\n\t\t\tp.method();\n\t\t}\n\t}\n\t```\n\n- 另外，我们可以利用 `反射` 的方式实现多工厂方法模式，具体见下述代码。\n\n\t```Java\n\tpublic abstract class Factory {\n\t\t/*\n\t\t * 具体生产什么由子类去实现\n\t\t * @param clz 产品对象类类型\n\t\t * @return 具体的产品对象\n\t\t */ \t\n\t\tpublic abstract<T extends Product> T createProduct(class<T> clz);\n\t}\n\tpublic class ConcreteFactory extends Factory {\n\t\t@Override\n\t\tpublic <T extends Product> T createProduct(class<T> clz) {\n\t\t\tProduct p = null;\n\t\t\ttry {\n\t\t\t\tp = (Product) class.forName(clz.getName()).newInstance();\n\t\t\t} catch(Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn (T) p;\n\t\t}\n\t}\n\t\n\t// 客户端中实现\n\tpublic class Client {\n\t\tpublic static void main(String[] args) {\n\t\t\tFactory factory = new ConcreteFactory();\n\t\t\tProduct p = factory.createProduct(ConcreteProductA.class);\n\t\t\tp.method();\n\t\t}\n\t}\n\t```\n\n#### 工厂方法模式的简单实现\n- 某汽车厂主要就是组装某款 SUV 车型，比如 Q3、Q5、Q7，对于这类车型来说，内部结构差异并不是很大，因此一条生产线足以应付 3 种车型，对于该类生产线可提供一抽象类定义。\n\n\t```Java\n\tpublic abstract class AudiFactory {\n\t\t/*\n\t\t * 某工厂生产某种车型的工厂方法\n\t\t * @param clz 具体的 SUV 型号类型\n\t\t * @return 具体型号的 SUV 车对象\n\t\t */\n\t\tpublic abstract<T extends AudiCar> T createAudiCar(class<T> clz);\n\t}\n\n\tpublic class AudiCarFactory extends AudiFactory {\n\t\t@Override\n\t\tpublic <T extends AudiCar> T createProduct(class<T> clz) {\n\t\t\tAudiCar p = null;\n\t\t\ttry {\n\t\t\t\tp = (AudiCar) class.forName(clz.getName()).newInstance(); \n\t\t\t} catch() {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn (T) p;\n\t\t}\n\t}\n\n\t// 汽车的抽象产品类\n\tpublic abstract class AudiCar {\n\t\tpublic abstract void drive();\n\t\tpublic abstract void selfNavigation();\n\t}\n\n\t// 具体车型：Q3\n\tpublic class AudiQ3 exntends AudiCar {\n\t\t@Override\n\t\tpublic void drive() {\n\t\t\tSystem.out.println(\"Q3 Launched!\");\n\t\t}\n\t\t@Override\n\t\tpublic void selfNavigation() {\n\t\t\tSystem.out.println(\"Q3 starts a auto-navigation!\");\n\t\t}\n\t}\n\n\t// 客户端实现\n\tpublic class Client {\n\t\tpublic static void main(String[] args) {\n\t\t\tAudiFactory factory = new AudiFactory();\n\t\t\tAudiQ3 audiQ3 = factory.createProduct(AudiQ3.class);\n\t\t\taudiQ3.dirve();\n\t\t\taudiQ3.selfNavigation();\t\n\t\t}\n\t}\n\t```\n\n- 便于理解，本示例的 UML 类图见图 2-8。\n\n\t![某工厂生产某车型的工厂方法](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-8.svg)\n\t\n\t<center>图 2-8 某工厂生产某车型的工厂方法</center> \n\n#### 工厂方法模式的实战\n- Android 数据持久化有很多方式，如 SharedPreferences (XML)、SQLite (关系数据库)。对数据操作的方法无非就是增、删、改、查，若我们将每种数据储存的方式作为一个产品类，在抽象产品类中定义对数据操作的方法，即我们宏观层面把握操作的逻辑，具体的实现逻辑由储存数据的方式决定。\n\n\t```Java\n\tpublic abstract class IOHandler {\n\t\tpublic abstract void add(String id, String name);\n\t\tpublic abstract void remove(String id);\n\t\tpublic abstract void update(String id, String name);\n\t\tpublic abstract String query(String id);\n\t}\n\t\n\tpublic class FileHandler extends IOHandler { // 普通文件存储\n\t\t@Override\n\t\tpublic void add(String id, String name) {\n\t\t\t/* 业务逻辑 */\n\t\t}\n\t\t@Override\n\t\tpublic void remove(String id) {\n\t\t\t/* 业务逻辑 */ \n\t\t}\n\t\t@Override\n\t\tpublic void update(String id, String name) {\n\t\t\t/* 业务逻辑 */ \n\t\t}\n\t\t@Override\n\t\tpublic String query(String id) {\n\t\t\t/* 业务逻辑 */ \n\t\t\treturn \"AigeStudio\";\n\t\t}\n\t}\n\t\n\tpublic class XMLHandler extends IOHandler { // XML 文存储\n\t\tpublic void add(String id, String name) {\n\t\t\t/* 业务逻辑 */ \n\t\t}\n\t\tpublic void remove(String id) {\n\t\t\t/* 业务逻辑 */\n\t\t}\n\t\tpublic void update(String id, String name) {\n\t\t\t/* 业务逻辑 */ \n\t\t}\n\t\tpublic String query(String id) {\n\t\t\t/* 业务逻辑 */\n\t\t\treturn \"SMBrother\";\n\t\t}\n\t}\n\t\n\tpublic class DBHandler extends IOHandler { // SQLite 数据库存储\n\t\tpublic void add(String id, String name) {\n\t\t\t/* 业务逻辑 */ \n\t\t}\n\t\tpublic void remove(String id) {\n\t\t\t/* 业务逻辑 */ \n\t\t}\n\t\tpublic void update(String id, String name) {\n\t\t\t/* 业务逻辑 */ \n\t\t}\n\t\tpublic String query(String id) {\n\t\t\t/* 业务逻辑 */\n\t\t\treturn \"Android\";\n\t\t}\n\t}\n\t\n\tpublic class IOFactory {\n\t\t/*\n\t\t * 获取 IO 处理者\n\t\t * @param clz IOHandler 类型的类类型\n\t\t * @return IOHandler 对象\n\t\t */\n\t\tpublic static <T extends IOHandler> T getIOHandler(class<T> clz) {\n\t\t\tIOHandler handler = null;\n\t\t\ttry {\n\t\t\t\thandler = (IOHandler) class.forName(clz.getName()).newInstance();\n\t\t\t} catch(Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn (T) handler;\n\t\t}\n\t}\n\t\n\t// 客户端实现\n\tpublic class FactoryActivity extends Activity {\n\t\t@override\n\t\tprotected void onCreate(Bundle saveInstanceState) {\n\t\t\tsuper.onCreate(saveInstanceState);\n\t\t\tsetContentView(R.layout.activity_factory);\n\t\n\t\t\t// 获取显示查询内容的 TextView 对象\n\t\t\tfinal TextView tvContent = \n\t\t\t\t(TextView) this.findViewById(R.id.factory_content_tv);\n\t\t\t// 获取查询普通文件数据的按钮对象，并设置监听\n\t\t\tButton btnFile = (Button) this.findViewById(R.id.factory_file_btn);\n\t\t\tbtnFile.setOnClickListener(new View.OnClickListener() {\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tIOHandler handler = \n\t\t\t\t\t\tIOFactory.getIOHanHandler(FileHandler.class);\n\t\t\t\t\tLog.d(\"AigeStudio\", handler.query(\"4455645646\"));\n\t\t\t\t\ttvContent.setText(handler.query(\"4455645646\"));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\t```\n\n### 抽象工厂模式\n#### 抽象工厂模式的定义\n- 创建型设计模式。\n- 为创建一组相关或者是相互依赖的对象提供一个 `接口` ，而不需要指定它们的具体类。\n\n#### 抽象工厂模式的使用场景\n- 一个对象族有相同约束时可以使用抽象工厂模式。比如 Android、iOS、Window Phone 下都有短信软件和拨号软件，两者属于软件范畴，但由于操作系统平台不一样，其代码实现细节也是有差异的，则我们可考虑使用抽象工厂方法模式去产生不同平台下的同款软件。\n\n#### 抽象工厂模式的 UML 类图\n- 抽象工厂方法模式的 UML 如图 2-9 所示。\n\n  ![抽象工厂方法模式UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-9.svg)\n\n  <center>图 2-9 抽象工厂方法模式 UML 类图</center> \n\n- 抽象工厂的简单代码实现：\n\n\t```Java\n\t// 抽象产品类 A\n\tpublic abstract class AbstractProductA { \n\t\tpublic abstract void method();\n\t}\n\t// 抽象产品类 B\n\tpublic abstract class AbstractProductB { \n\t\tpublic abstract void method();\n\t}\n\t// 具体产品类 A1\n\tpublic class ConcreteProducxtA1 extends AbstractProductA { \n\t\t@Override\n\t\tpublic void method() {\n\t\t\tSystem.out.println(\"具体产品 A1 的方法.\");\n\t\t}\n\t}\n\t// 具体产品类 A2\n\tpublic class ConcreteProducxtA2 extends AbstractProductA { \n\t\t@Override\n\t\tpublic void method() {\n\t\t\tSystem.out.println(\"具体产品 A2 的方法.\");\n\t\t}\n\t}\n\t// 具体产品类 B1\n\tpublic class ConcreteProducxtB1 extends AbstractProductB { \n\t\t@Override\n\t\tpublic void method() {\n\t\t\tSystem.out.println(\"具体产品 B1 的方法.\");\n\t\t}\n\t}\n\t// 具体产品类 B2\n\tpublic class ConcreteProducxtB2 extends AbstractProductB { \n\t\t@Override\n\t\tpublic void method() {\n\t\t\tSystem.out.println(\"具体产品 B2 的方法.\");\n\t\t}\n\t}\n\t// 抽象工厂类\n\tpublic abstract class AbstractFactory { \n\t\t/**\n\t\t * 创建产品 A 的方法\n\t\t * @return 产品 A 的对象\n\t\t */\n\t\tpublic abstract AbstractProductA createProductA();\n\t\t/**\n\t\t * 创建产品 B 的方法\n\t\t * @return 产品 B的对象\n\t\t */\n\t\tpublic abstract AbstractProductB createProductB();\n\t}\n\t// 具体工厂类 1\n\tpublic class ConcreteFactory1 extends AbstractFactory { \n\t\t@Override\n\t\tpublic abstract AbstractProductA createProductA1() {\n\t\t\treturn new ConcreteProductA1();\n\t\t};\n\t\t@Override\n\t\tpublic abstract AbstractProductB createProductB1() {\n\t\t\treturn new ConcreteProductB1();\n\t\t};\n\t}\n\t// 具体工厂类 2\n\tpublic class ConcreteFactory2 extends AbstractFactory { \n\t\t@Override\n\t\tpublic abstract AbstractProductA createProductA2() {\n\t\t\treturn new ConcreteProductA2();\n\t\t};\n\t\t@Override\n\t\tpublic abstract AbstractProductB createProductB2() {\n\t\t\treturn new ConcreteProductB2();\n\t\t};\n\t}\n\t```\n\n#### 抽象工厂模式的简单实现\n- 在简单工厂模式的简单实现中，我门以车厂生产汽车为例。虽 Q3、Q5、Q7 同为一车系，但三者之间的零部件产别却很大，如 Q3、Q7 当中，Q3 装配的是国产发动机，普通轮胎和普通制动系统；Q7 则装配的是进口发动机，全尺寸越野轮胎和制动性能极好的制动系统。\n\n\t> 即同为一系列车，大家共有部件有发动机、轮胎和制动系统等，由于具体的部件品质不同，装配的细节又不同。故我们可将抽象工厂模式应用当中，化繁为简。\n\n\t```Java\n\tpublic abstract class CarFactory {\n\t\t/**\n\t\t * 生产轮胎\n\t\t * @return ITire 轮胎\n\t\t */\n\t\tpublic abstract ITire createTire(); \t\n\t\t/**\n\t\t * 生产发动机\n\t\t * @return IEngine 发动机\n\t\t */\n\t\tpublic abstract IEngine createEngine();\n\t\t/**\n\t\t * 生产制动系统\n\t\t * @return IBrake 制动系统\n\t\t */\n\t\tpublic abstract IBrake createBrake();\n\t}\n\n\tpublic interface ITire { // 轮胎\n\t\tvoid tire();\n\t}\n\n\tpublic class NormalTire implements ITire {\n\t\t@Override\n\t\tpublic void tire() {\n\t\t\tSystem.out.println(\"普通轮胎\");\n\t\t}\n\t}\n\n\tpublic class SUVTire implements ITire {\n\t\t@Override\n\t\tpublic void tire() {\n\t\t\tSystem.out.println(\"越野轮胎\");\n\t\t}\n\t}\n\n\tpublic interface IEngine() { // 发动机\n\t\tvoid engine();\n\t}\n\n\tpublic class DomesticEngine implements IEngine {\n\t\t@Override\n\t\tpublic void engine() {\n\t\t\tSystem.out.println(\"国产发动机\");\n\t\t}\n\t}\n\n\tpublic class ImportEngine implements IEngine {\n\t\t@Override\n\t\tpublic void engine() {\n\t\t\tSystem.out.println(\"进口发动机\");\n\t\t}\n\t}\n\n\tpublic interface IBrake { // 制动系统\n\t\tvoid brake();\n\t}\n\n\tpublic class NormalBrake implements IBrake {\n\t\t@Override\n\t\tpublic void brake() {\n\t\t\tSystem.out.println(\"普通制动\");\n\t\t}\n\t}\n\n\tpublic class SeniorBrake implements IBrake {\n\t\t@Override\n\t\tpublic void brake() {\n\t\t\tSystem.out.println(\"高级制动\");\n\t\t}\n\t}\n\n\tpublic class Q3Factory extends CarFactory { // Q3工厂类\n\t\t@Override\n\t\tpublic ITire createTire() {\n\t\t\treturn new NormalTire();\n\t\t}\n\t\t@Override\n\t\tpublic IEngine createEngine() {\n\t\t\treturn new Domestic Engine();\n\t\t}\n\t\t@Override\n\t\tpublic IBrake createBrake() {\n\t\t\treturn new NormalBrake();\n\t\t}\n\t}\n\n\tpublic class Q3Factory extends CarFactory { // Q3工厂类\n\t\t@Override\n\t\tpublic ITire createTire() {\n\t\t\treturn new NormalTire();\n\t\t}\n\t\t@Override\n\t\tpublic IEngine createEngine() {\n\t\t\treturn new DomesticEngine();\n\t\t}\n\t\t@Override\n\t\tpublic IBrake createBrake() {\n\t\t\treturn new NormalBrake();\n\t\t}\n\t}\n\n\tpublic class Q7Factory extends CarFactory { // Q7 工厂类\n\t\t@Override\n\t\tpublic ITire createTire() {\n\t\t\treturn new SUVTire();\n\t\t}\n\t\t@Override\n\t\tpublic IEngine createEngine() {\n\t\t\treturn new ImportEngine();\n\t\t}\n\t\t@verride\n\t\tpublic IBrake createBrake() {\n\t\t\treturn new SeniorBrake();\n\t\t}\n\t}\n\n\t// 客户端实现\n\tpublic class Client {\n\t\tpublic static void main(String[] args) {\n\t\t\t// 构造一个生产 Q3 的工厂\n\t\t\tCarFactory factoryQ3 = new Q3Factory();\n\t\t\tfactoryQ3.createTire().tire();\n\t\t\tfactoryQ3.createEngine().engine();\n\t\t\tfactoryQ3.createBrake().brake();\n\t\t\t// 构造一个生产 Q7 的工厂\n\t\t\tCarFactory factoryQ7 = new Q7Factory();\n\t\t\tfactoryQ7.createTire().tire();\n\t\t\tfactoryQ7.createEngine().engine();\n\t\t\tfactoryQ7.createBrake().brake();\n\t\t}\n\t}\n\t```\n\n- 具体的架构如图 2-10 的 UML 类图所示。\n\n\t![车厂生产同系列汽车的抽象工厂模式](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-10.svg)\n\t\n\t<center>图 2-10 车厂生产同系列汽车的抽象工厂模式</center>\n\n#### 总结\n- 抽象工厂方法优点：分离接口与实现，即客户端使用抽象工厂的创建对象，客户端不知具体实现是谁，客户端只是面向产品的接口编程而已，使其从具体的产品实现中解耦。\n- 抽象工厂方法缺点：\n\t- 类文件的爆炸性增加。  \n\t- 不太容易扩展新的产品类，因为每当增加一个产品类，就需修改抽象工厂，故所有具体工厂类均会被修改。\n\n### 策略模式\n#### 策略模式的介绍\n- 实现某功能，可以有多种算法或策略选择，例如排序算法，有插入排序、归并排序、冒泡排序等。\n\t- 思考：多种排序算法，可以写在一个类中，一个方法对应一种具体排序。但是缺点也是很明显，即臃肿；维护成本高，且容易引发错误；每增加一种排序需修改封装类的源码。  \n\t- 改进：提供一个 `统一接口`，不同的算法或策略有不同的实现类。\n\n#### 策略模式的使用场景\n- 针对同类问题的多种处理方式，仅仅是 `具体行为` 有差别。\n- 需要安全地封装多种 `同类型` 的操作。\n- 出现同一抽象类，有多个子类，而又需使用 `if-else` 或 `switch-case`  来选择具体子类。\n\n\t> 但缺点也明显，耦合性高；代码臃肿难维护。\n\n#### 策略模式的 UML 类图\n- 策略模式的 UML 如图 2-11 所示。\n\n\t![策略模式UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-11.svg)\n\t\n\t<center>图 2-11 策略模式 UML 类图</center> \n\n#### 策略模式的简单实现\n- 比如公交价格，不设单一票价制，而是分段计费。显然，公交车和地铁的价格计算方式是不一样的。但是，我们的示例中是需要计算乘不同出行工具的成本，故我们采用策略模式进行设计、编码。\n\n\t```Java\n\tpublic interface CalculateStragety {\n\t\t/**\n\t\t * 按距离来计算价格\n\t\t * @param km 公里\n\t\t * @return 返回价格\n\t\t */\n\t\tint calculatePrice();\n\t}\n\tpublic class BusStragety implements CalculateStragety {\n\t\t@Override\n\t\tpublic int calculatePrice(int km) {\n\t\t\t// 公交车价格计算策略\n\t\t}\n\t}\n\tpublic class SubwayStragety implements CalculateStragety {\n\t\t@Override\n\t\tpublic int calculatePrice(int km) {\n\t\t\t// 地铁价格计算策略\n\t\t}\n\t}\n\t\n\t// 客户端实现: 出行价格计算器\n\tpublic class TranficCalculator {\n\t\tCalculateStrategy mStrategy = null;\n\t\tpublic static void main(String[] args) {\n\t\t\tTranficCalculator calculator = new TranficCalculator();\n\t\t\t// 设置计算策略\n\t\t\tcalculator.setStrategy( new BusStrategy() );\n\t\t\t// 计算价格\n\t\t\tSystem.out.println(\"公交车乘16公里的价格: \" \n\t\t\t\t+ calculator.calculatePrice(16));\n\t\t}\n\t\tpublic void setStrategy(CalculateStrategy mStrategy) {\n\t\t\tthis.mStrategy = mStrategy;\n\t\t}\n\t\tpublic int calculatePrice(int km) {\n\t\t\treturn mStrategy.calculatePrice(km);\n\t\t}\n\t}\n\t```\n\n- 便于理解，本示例的 UML 类图如图 2-12 所示。\n\n\t![交通方案UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-12.svg)\n\t\n\t<center>图 2-12 交通方案的 UML 类图</center> \n\n#### 策略模式的实战应用\n- 对于默认情况下，ImageLoader 会按照先后顺序加载图片，但在实际算法当中，相反顺序加载图片也是有可能的，即反序列加载图片。当然加载方式可看作多种策略，共同的目标是实现加载图片。\n\n\t```Java\n\tpublic interface LoadPolicy { // 加载策略接口\n\t\tpublic int compare(BitmapRequest request1, BitmapRequest request2);\n\t}\n\t/**\n\t * 顺序加载策略\n\t */\n\tpublic class SerialPolicy implements LoadPolicy {\n\t\t@Override\n\t\tpublic int compare(BitmapRequest request1, BitmapRequest request2) {\n\t\t\t// 按照添加到队列的序列号顺序来执行\n\t\t\treturn request1.serialNum - request2.serialNum;\n\t\t}\n\t}\n\t/**\n\t * 逆序加载策略，即从最后加入队列的请求进行加载\n\t */\n\tpulbic class ReversePolicy implements LoadPolicy {\n\t\t@Override\n\t\tpublic int compare(BitmapRequest request1, BitmapRequest request2) {\n\t\t\t// 注意: Bitmap 请求要先执行最晚加入队列的请求，ImageLoader 的策略 \n\t\t\treturn request2.serialNum - request1.serialNum;\n\t\t}\n\t}\n\t/** \n\t * 因每个请求都有一序列号，序列号以递增形式增加，越晚加入队列的请求序列号越大。\n\t * 而请求队列是优先级队列，因此需要在图片加载请求类中实现 Comparable 接口，以实现对这些请求的排序处理。\n\t */\n\tpublic class BitmapRequest implements Comparable<BitmapRequest> { \n\t\tLoadPolicy mLoadPolicy = new SerialPolicy();\n\t\t@Override\n\t\tpublic int compareTo(BitmapRequest another) {\n\t\t\t// 委托给 LoadPolicy 进行处理，实现按照策略模式\n\t\t\treturn mLoadPolicy.compare(this, another);\n\t\t}\n\t}\n\t/**\n\t * 用户在配置 ImageLoader 时可以设置加载策略，\n\t * 这个策略会被设置给每个图片加载请求对象，具体如下：\n\t */\n\tpublic void displayImage(\n\t\tfinal ImageView imageView, final String uri, \n\t\tfinal DisplayConfig config, final ImageListener listener) {\n\t\tBitmapRequest request = \n\t\t\tnew BitmapRequest(imageView, uri, config, listener);\n\t\t// 加载的配置对象，如果没有设置则使用 ImageLoader 的配置\n\t\trequest.displayConfig = request.displayConfig != null ?\n\t\trequest.displayConfig : mConfig.displayConfig;\n\t\t// 设置加载策略\n\t\trequest.setLoadPolicy(mConfig.loadPolicy);\n\t\t// 添加到队列中\n\t\tmImageQueue.addRequest(request);\n\t}\n\t```\n\n- 图 2-13 是 ImageLoader 的 UML 类图。\n\n\t![ImageLoader的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-13.svg)\n\t\n\t<center>图 2-13 ImageLoader 的 UML 类图</center>\n\n#### 总结\n- 策略模式的优点  \n\t- 很好地演示了开闭原则，也就定义了抽象。  \n\t- 耦合度相对较低，扩展方法。\n- 策略模式的缺点：随着策略的增加，子类会变得繁多。\n\n### 状态模式\n- 状态模式和策略模式和结构几乎一样，但它们的目的本质完全相异。\n\t- 策略模式：行为彼此独立，可相互替换。\n\t- 状态模式：行为是平行的，不可替换的。\n\n#### 状态模式的定义\n- 当一个对象的 `内在状态改变` 时允许 `改变其行为`，这个对象看起来像是改变了其类。\n\n#### 状态模式的使用场景\n- 代码中包含大量与 `对象状态` 有关的条件语句，比如操作中含有庞大的多分支语句（`if-else` 或 `switch-case`），且这些分支依赖与该对象的状态。\n- 若使用状态模式来优化架构，即每一条件分支放于独立的类。\n\n#### 状态模式的 UML 类图\n- 状态模式的 UML 类图如图 2-14 所示。\n\n\t![状态模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-14.svg)\n\t\n\t<center>图 2-14 状态模式的 UML 类图</center> \n\n#### 状态模式的简单示例\n- 下面以电视遥控器为例演示状态模式的实现。便于理解，本示例的 UML 类图如图 2-15 所示。\n\n\t![电视遥控器UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-15.svg)\n\t\n\t<center>图 2-15 电视遥控器 UML 类图</center> \n\n#### 状态模式实战\n- 在新浪微博中，用户在未登录的情况下点击转发按钮，此时会先让用户登录，然后再执行转发操作；如果已登录的情况下，那么用户输入转发的内容后就可以直接进行操作。\n\n\t![新浪微博用户状态管理UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-16.svg)\n\t\n\t<center>图 2-16 新浪微博用户状态管理 UML 类图</center> \n\n#### 总结\n- 状态模式的优点：将所有与一个特定的状态相关的行为都放入一个状态对象中，它提供了一个更好的方法来组织与特定状态相关的代码，将繁琐的状态判断转为结构清晰的状态类族。\n- 状态模式的缺点：必然增加系统类和对象的个数。\n\n### 责任链模式\n#### 责任链模式的定义\n- 行为型设计模式。\n- 通俗定义：每个节点看作一对象，每一对象拥有不同的处理逻辑，将一请求从链式的首端发出，沿着链的路径一次传递每个节点对象，`层层递归` 直至有对象处理这个请求为止。\n- 标准定义：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成链，并沿着这条链传递该请求，直至有对象处理它为止。\n\n#### 责任链模式的使用场景\n- 多个对象可以处理同一请求，但具体由哪个对象处理则在 `运行时动态决定`。\n- 在请求处理者不明确的情况下向多个对象中的其一提交一个请求。\n- 需要动态指定一组对象处理请求。\n- 比如 Spring 拦截器、过滤器都是采用责任链的设计模式设计的。\n\n#### 责任链模式的 UML 类图\n- 责任链的简单代码实现：\n\n\t```Java\n\t// 抽象处理者\n\tpublic abstract class Handler {\n\t\tprotected Handler successor; // 下一节点的处理者\n\t\t/**\n\t\t * 请求处理\n\t\t * @param condition 请求条件\n\t\t */\n\t\tpublic abstract void handleRequest(String condition);\n\t}\n\t// 具体的处理者1\n\tpublic class ConcreteHandler1 extends Handler {\n\t\t@Override\n\t\tpublic void handleRequest(String condition) {\n\t\t\tif(condition.equals(\"ConcreteHandler1\")) {\n\t\t\t\tSystem.out.println(\"ConcreteHandler1 handled\");\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tsuccessor.handleRequest(condition);\n\t\t\t}\n\t\t}\n\t}\n\t// 具体的处理者2\n\tpublic class ConcreteHandler2 extends Handler {\n\t\t@Override\n\t\tpublic void handleRequest(String condition) {\n\t\t\tif(condition.equals(\"ConcreteHandler2\")) {\n\t\t\t\tSystem.out.println(\"ConcreteHandler2 handled\");\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tsuccessor.handleRequest(condition);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 客户端实现\n\tpublic class Client {\n\t\tpublic static void main(String[] args) {\n\t\t\t// 构造一个 ConcreteHandler1 对象\n\t\t\tConcreteHandler1 handler1 = new ConcreteHandler1();\n\t\t\t// 构造一个 ConcreteHandler2 对象\n\t\t\tConcreteHandler2 handler2 = new ConcreteHandler2();\n\t\t\t// 设置 handler1 的下一个节点\n\t\t\thandler1.successor = handler2;\n\t\t\t// 处理请求\n\t\t\thandler1.handleRequest(\"ConcreteHandler2\");\n\t\t}\n\t}\n\t```\n\n- 责任链模式的 UML 类图如图 2-17 所示。\n\n\t![责任链模式UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-17.svg)\n\t\n\t<center>图 2-17 责任链模式 UML 类图</center>\n\n#### 责任链模式的简单实现\n- 在公司中报销费用中，审批的流程其实就是一个类似责任链的实例。例如，小明是请求的发起者，而处理者有组长、部门主管、经理和老板，对于不同额度的报销费用需要不同级的处理者审批，准确地说，每一类人代表这条链上的一个节点。\n\n\t例如小民是请求的发起者，而老板则是处于链条顶端的类，小民从链的底端开始发出一个申请报账的请求，首先由组长处理该请求，组长比对后发现自己权限不够于是将该请求转发给位于链中下一个节点的主管，主管比对后发现自己权限不足又将该请求转发给经理，经理也基于同样的原因将请求转发给老板，这样层层转达直至请求被处理。即至始至终小民关心的是报账结果，而不用在乎处理者是谁。责任链模式在这里很好地将请求的发起者与处理者解耦。\n\t\n\t```Java\n\t// 抽象领导者\n\tpublic abstract class Leader {\n\t\tprotected Leader nextHandler; // 上一级领导处理者\n\t\t/**\n\t\t * 处理报账请求\n\t\t * @param money 能批复的报账额度\n\t\t */\n\t\tpublic final void handleRequest(int money) {\n\t\t\tif( money < limit() ) {\n\t\t\t\thandle(money);\n\t\t\t} else {\n\t\t\t\tif( null != nextHandlder ) {\n\t\t\t\t\tnextHandler.handleRequest(money);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * 自身能批复的额度权限\n\t\t * @return 额度\n\t\t */\n\t\tpublic abstract int limit();\n\t\t/**\n\t\t * 处理报账行为\n\t\t * @param money 具体金额\n\t\t */\n\t\tpulbic abstract void handle(int money);\n\t}\n\n\tpublic class GroupLeader extends Leader {\n\t\t@Override\n\t\tpublic int limit() {\n\t\t\treturn 1000;\n\t\t}\n\t\t@Override\n\t\tpublic void handle(int money) {\n\t\t\tStsten.out.println(\"组长批复报销\" + money + \"元\");\n\t\t}\n\t}\n\t\n\tpublic class Director extends Leader {\n\t\t@Override\n\t\tpublic int limit() {\n\t\t\treturn 5000;\n\t\t}\n\t\t@Override\n\t\tpublic void handle(int money) {\n\t\t\tStsten.out.println(\"主管批复报销\" + money + \"元\");\n\t\t}\n\t}\n\t\n\tpublic class Manager extends Leader {\n\t\t@Override\n\t\tpublic int limit() {\n\t\t\treturn 10000;\n\t\t}\n\t\t@Override\n\t\tpublic void handle(int money) {\n\t\t\tStsten.out.println(\"经理批复报销\" + money + \"元\");\n\t\t}\n\t}\n\t\n\tpublic class Boss extends Leader {\n\t\t@Override\n\t\tpublic int limit() {\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}\n\t\t@Override\n\t\tpublic void handle(int money) {\n\t\t\tStsten.out.println(\"老板批复报销\" + money + \"元\");\n\t\t}\n\t}\n\n\t// 小民从组长开始发起请求申请报账\n\tpublic class XiaoMin {\n\t\tpublic static void main(String[] args) {\n\t\t\t// 构造各个领导对象\n\t\t\tGroupLeader groupLeader = new GroupLeader();\n\t\t\tDirector director = new Director();\n\t\t\tManager manager = new Manager();\n\t\t\tBoss boss = new Boss();\n\t\t\t// 设置上一级领导处理者对象\n\t\t\tgroupLeader.nextHandler = director;\n\t\t\tdirector.nextHandler = manager;\n\t\t\tmanager.nextHandler = boss;\n\t\t\t// 发起报账申请\n\t\t\tgroupLeader.handleRequest(50000);\n\t\t}\n\t}\n\t```\n\n- 便于理解，本示例的 UML 类图如图 2-18 所示。\n\n\t![报账审核机制UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-18.svg)\n\t\n\t<center>图 2-18 报账审核机制 UML 类图</center>\n\n#### 责任链模式实战\n- Android 中我们可以借鉴责任链模式的思想来优化 BroadcastReceiver 使之成为一个全局的责任链处理者。\n\n- 我们知道 Broadcast 可以被分为两种:\n\n\t- Normal Broadcast：普通广播，`异步广播`，发出时可被 `所有` 的接收者收到。\n\t- Ordered Broadcast：有序广播，`依优先级依次传播`，直到有接收者将其终止或所有接收者都不终止它。\n\n- 有序广播这一特性与我们的责任链模式很相近，通过它可实现一种全局的责任链事件处理。\n\n\t```Java\n\t// 具体的实现思路是，通过 Intent 的限制值来限定最终的广播权归谁所有\n\tpublic class FirstReceiver extends BroadcastReceiver {\n\t\t@Override\n\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\t// 获取 Intent 中附加的限制值\n\t\t\tint limit = intent.getIntExtra(\"limit\", -1001);\n\t\t\t// 如果限定值等于 1000 则处理，否则继续转发给下一个 Receiver\n\t\t\tif( 1000 == limit ) {\n\t\t\t\t// 获取 Intent 中附加的字符串消息并 Toast\n\t\t\t\tString msg = intent.getStringExtra(\"msg\");\n\t\t\t\tToast.makeText(context, msg, Toast.LENGTH_SHORT).show();\t\t\n\t\t\t\t// 终止广播\n\t\t\t\tabortBroadcast();\n\t\t\t} else {\n\t\t\t\t// 添加信息发送给下一个 Receiver\n\t\t\t\tBundle b = new Bundle();\n\t\t\t\tb.putString(\"new\", \"Message from FirstReceiver\");\n\t\t\t\tsetResultExtras(b);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic class SecondReceiver extends BroadcastReceiver {\n\t\t@Override\n\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\t// 获取 Intent 中附加的限制值\n\t\t\tint limit = intent.getIntExtra(\"limit\", -1001);\n\t\t\t// 如果限定值等于 100 则处理，否则继续转发给下一个 Receiver\n\t\t\tif( 100 == limit ) {\n\t\t\t\t// 获取 Intent 中附加的字符串消息\n\t\t\t\tString msg = intent.getStringExtra(\"msg\");\n\t\t\t\t// 获取上一个 Receiver 增加的消息\n\t\t\t\tBundle b = getResultExtras(true);\n\t\t\t\tString str = b.getString(\"new\");\n\t\t\t\tToast.makeText(context, msg + str, Toast.LENGTH_SHORT).show();\t\n\t\t\t\t// 终止广播\n\t\t\t\tabortBroadcast();\n\t\t\t} else {\n\t\t\t\t// 添加信息发送给下一个 Receiver\n\t\t\t\tBundle b = new Bundle();\n\t\t\t\tb.putString(\"new\", \"Message from FirstReceiver\");\n\t\t\t\tsetResultExtras(b);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic class ThirdReceiver extends BroadcastReceiver {\n\t\t@Override\n\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\t// 获取 Intent 中附加的限制值\n\t\t\tint limit = intent.getIntExtra(\"limit\", -1001);\n\t\t\t// 如果限定值等于 10 则处理，否则继续转发给下一个 Receiver\n\t\t\tif( 10 == limit ) {\n\t\t\t\t// 获取 Intent 中附加的字符串消息\n\t\t\t\tString msg = intent.getStringExtra(\"msg\");\n\t\t\t\t// 获取上一个 Receiver 增加的消息\n\t\t\t\tBundle b = getResultExtras(true);\n\t\t\t\tString str = b.getString(\"new\");\n\t\t\t\tToast.makeText(context, msg + str, Toast.LENGTH_SHORT).show();\t\n\t\t\t\t// 终止广播\n\t\t\t\tabortBroadcast();\n\t\t\t} else {\n\t\t\t\t// 添加信息发送给下一个 Receiver\n\t\t\t\tBundle b = new Bundle();\n\t\t\t\tb.putString(\"new\", \"Message from FirstReceiver\");\n\t\t\t\tsetResultExtras(b);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// 客户端实现\n\tpublic class OrderActivity extends Activity {\n\t\t@Override\n\t\tprotected void onCreate(Bundle savedInstanceState) {\n\t\t\tsuper.onCreate(savedInstanceState);\n\t\t\tsetContentView(R.layout.activity_order);\n\t\t\n\t\t\tButton btnSend = (Button) findViewById(R.id.order_send_btn);\n\t\t\tbtnSend.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tIntent i = new Intent();\n\t\t\t\t\ti.setAction(\"com.aigestudio.action.ORDER_BROADCAST\");\n\t\t\t\t\t// 这里我们设置 limit = 100，即只有 SecondReceiver 才会处理它\n\t\t\t\t\ti.putExtra(\"limit\", 100);\n\t\t\t\t\ti.putExtra(\"msg\", \"Message from OrderActivity\");\n\t\t\t\t\tsendOrderedBroadcast(i, null);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\t```\n\n#### 总结\n- 责任链模式的优点：对请求者和处理者关系解耦，提高代码灵活性。\n- 责任链模式的缺点：递归调用。特别是处理者太多，那么遍历定会影响性能。\n\n### 解释器模式\n#### 解释器模式的定义\n- 行为型设计模式。\n- 概念：给定一个语言，定义它的 `文法` 的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。\n- 文法：例如我们熟悉的「主谓宾结构」，通过下述短语举例，我们可把短语抽象看作：I am a/an [noun.]\n\n| 主语 | 谓语 | 宾语 |\n| --- | --- | --- |\n| I | am | a designer |\n| I | am | a teacher |\n\n- 再举例：假设有如以 ab 开头 ef 结尾，中间排列 N(N>=0) 个 cd 的字符串，如 `abcdcd...cdef`。\n\t- 在计算机科学中，我们将上述字符串中的 “a”、“b”、“c”、“d”、“e” 和 “f” 这 6 个字符称为一种形式语言的 `字符表`。\n\t- 而这些字符组成的集合，如 “abcdcd...cdef” 这样由字符表构成的字符串则称为 `形式语言`。注意这里的语言不是文法。\n\n\t- 假设定义一个符号 S，从符号 S 出发推导上述字符串，即可得到如下推导式：\n\n\t\t```Java\n\t\tS ::= abA*ef  \n\t\tA ::= cd\n\t\t```\n\n\t\t- `::=` 称为推导；  \n\t\t- `*` 表示闭包，上述推导式中意思是，符号 A 可以有 0 或 N 个重复；  \n\t\t- 非终结符号：`S` 和 `A` 则称非终结符号，即它们能推导出式子右边的表达式；  \n\t\t- 终结符号：\"pqmn\"，“ab”，“ef”，即无法再推导；\n\n#### 解释器模式的使用场景\n- 某个 `简单语言` 需要解释执行且可将该语言中的语句表示为 `抽象语法树` 时可考虑使用解释器模式。\n\n  > 如：有非终结符号 p+q+m-n，即该数学表示式可表示为一棵抽象语法树。如图 2-19 所示。\n\n  ![p+q+m-n的抽象语法树](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-19.svg)\n\n  <center>图 2-19 p+q+m-n 的抽象语法树</center>\n\n- 某些特定的领域出现 `不断重复` 的问题时，可将该领域的问题转化为一种语法规则下的语句，然后构建解释器来解释该语句。比如英文字母的大小写转换、阿拉伯数字转为中文的数字等。\n\n#### 解释器模式的 UML 类图\n- 解释器模式的 UML 类图如图 2-20 所示。\n\n\t![解释器模式UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-20.svg)\n\t<center>图 2-20 解释器模式 UML 类图</center>\n\n\t```Java\n\tpublic abstract class AbstractExpression {\n\t\t/**\n\t\t * 抽象的解析方法\n\t\t * @param ctx 上下文环境对象\n\t\t */\n\t\tpublic abstract void interpret(Context ctx);\n\t}\n\t\n\t// 终结符表达式\n\tpublic class TerminalExpression extends AbstractExpression {\n\t\t@Override\n\t\tpublic abstract void interpret(Context ctx) {\n\t\t\t// 实现文法中与终结符有关的解释操作\n\t\t}\n\t}\n\t\n\t// 非终结符表达式\n\tpublic class NonterminalExpression extends AbstractExpression {\n\t\t@Override\n\t\tpublic abstract void interpret(Context ctx) {\n\t\t\t// 实现文法中与非终结符有关的解释操作\n\t\t}\n\t}\n\t\n\tpublic class Context {\n\t\t// 包含解释器之外的全局信息\n\t}\n\t\n\tpublic class Client {\n\t\tpublic static void main(String[] args) {\n\t\t\t// 根据文法对特定句子构建抽象语法树后解释\n\t\t}\n\t}\n\t```\n\n#### 总结\n- 解释模式的优点：灵活的扩展性，即我们想对文法规则进行扩展延伸时，只需增加相应的非终结符解释器，并在构建抽象语法树时，使用到新增的解释器对象进行具体的解释即可。\n- 解释模式的缺点：  \n\t- 对于每一条文法对应至少一个解释器，其会生成大量的类，导致后期维护困难； \n\t- 构建其抽象语法树会显得异常繁琐，甚至可能出现需要构建多棵抽象语法树的情况。\n\n### 命令模式\n#### 命令模式的定义\n- 行为型设计模式。\n- 介绍：将一系列的方法调用封装，用户只需调用一个方法执行，那么所有这些被封装的方法就会被挨个执行调用。\n- 定义\n\t- 将一个请求封装成一个对象，从而让用户使用不同的请求把客户端参数化。\n\t- 对请求排队或者记录请求日志，以及支持可撤销的操作。\n\n#### 命令模式的使用场景\n- 需要抽象出待执行的动作，然后以参数的形式提供处理，类似过程设计中的 `回调机制`。\n- 在不同的时刻指定、排列和执行请求。一个命令对象可以有与初始请求无关的生存期。\n- 需要 `支持取消` 操作。\n- 需要 `支持事务` 操作。\n- 支持 `修改日志` 功能，若系统崩溃，这些修改可重做一遍。\n\n#### 命令模式的 UML 类图\n- 命令模式的 UML 类图如图 2-21 所示。\n\n\t![命令模式UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-21.svg)\n\t<center>图 2-21 命令模式 UML 类图</center>\n\n\t- **Receiver 接收者角色**：该类负责具体实施或执行一个请求，通俗地说，执行具体逻辑的角色。\n\t- **Command 命令角色**：定义所有具体命令类的抽象接口。\n\t- **ConcreteCommand 具体命令角色**：该类实现了 Command 接口，在 execute() 方法中调用接收者角色的相关方法，在接收者和命令执行的具体行为之间加以弱耦和。\n\t- **Invoker 请求者角色**：该类的职责就是调用命令对象执行具体的请求，相关的方法我们称为行动方法。\n\n- 这里其实大家可以看到，命令模式的应用其实可用一句话概述，就是将行为调用者与实现者解耦。命令模式简单代码如下：\n\n\t```Java\n\t// 接收者类\n\tpublic class Receiver {\n\t\t// 真正执行具体命令逻辑的方法\n\t\tpublic void action() {\n\t\t\tSystem.out.println(\"执行具体操作\");\n\t\t}\n\t}\n\t// 抽象命令接口\n\tpublic interface Command {\n\t\t// 执行具体操作的命令\n\t\tvoid execute();\n\t}\n\t// 具体命令类\n\tpublic class ConcreteCommand implements Command {\n\t\tprivate Receiver receiver; // 持有一个对接受者对象的引用\n\t\tpublic ConcreteCommand(Receiver receiver) {\n\t\t\tthis.receiver = receiver;\n\t\t}\n\t\t@Override\n\t\tpublic void execute() {\n\t\t\t// 调用接收者的相关方法来执行具体逻辑\n\t\t\treceiver.action();\n\t\t}\n\t}\n\t// 请求者类\n\tpublic class Invoker {\n\t\tprivate Command command; // 持有一个对应命令对象的引用\n\t\tpublic Invoker() {\n\t\t\tthis.command = command;\n\t\t}\n\t\tpublic void action() {\n\t\t\t// 调用具体命令对象的相关方法，执行具体命令\n\t\t\tcommand.execute();\n\t\t}\n\t}\n\t\n\t// 客户端实现\n\tpublic class Client {\n\t\tpublic static void main(String[] args) {\n\t\t\t// 构造一个接受者对象\n\t\t\tReceiver receiver = new Receiver();\n\t\t\t// 根据接收者对象构造一个命令对象\n\t\t\tCommand command = new ConcreteCommand(receiver);\n\t\t\t// 根据具体的对象构造请求者对象\n\t\t\tInvoker invoker = new Invoker(command);\n\t\t\t// 执行请求方法\n\t\t\tinvoker.action();\n\t\t}\n\t}\n\t```\n\n#### 命令模式的简单实现\n- 这里以古老的俄罗斯方块游戏为例，在命令模式下如何操控俄罗斯方块变换。游戏中含有 4 个按钮，即上下左右。设定玩游戏的人相当于我们的客户端，游戏上的 4 个按钮相当于请求者，而执行具体按钮命令的逻辑方法可看作命令角色。\n\n\t```Java\n\t// 接收者角色\n\tpublic class TetrisMachine {\n\t\tpublic void toLeft() { // 真正处理 “向左” 操作的逻辑代码\n\t\t\tSystem.out.println(“向左”);\n\t\t}\n\t\tpublic void toRight() { // 真正处理 “向右” 操作的逻辑代码\n\t\t\tSystem.out.println(“向右”);\n\t\t}\n\t\tpublic void fastToBottom() { // 真正处理 “快速落下” 操作的逻辑代码\n\t\t\tSystem.out.println(“快速落下”);\n\t\t}\n\t\tpublic void transform() { // 真正处理 “改变形状” 操作的逻辑代码\n\t\t\tSystem.out.println(“改变形状”);\n\t\t}\t\n\t}\n\n\t// 命令者抽象\n\tpublic interface Command {\n\t\t// 命令执行方法\n\t\tvoid execute();\n\t}\n\n\t// 具体命令者：向左移的命令类\n\tpublic class LeftCommand implements Command {\n\t\t// 持有一个接收者俄罗斯方块游戏对象的引用\n\t\tprivate TetrisMachine machine;\n\t\tpublic LeftCommand(TetriMachine machine){\n\t\t\tthis.machine = machine;\n\t\t}\n\t\t@Override\n\t\tpublic void execute() {\n\t\t\t// 调用游戏机里的具体方法执行操作\n\t\t\tmachine.toLeft();\n\t\t}\n\t}\n\n  // 具体命令者：向右移的命令类\n\tpublic class RightCommand implements Command {\n\t\t// 持有一个接收者俄罗斯方块游戏对象的引用\n\t\tprivate TetrisMachine machine;\n\t\tpublic RightCommand(TetriMachine machine){\n\t\t\tthis.machine = machine;\n\t\t}\n\t\t@Override\n\t\tpublic void execute() {\n\t\t\t// 调用游戏机里的具体方法执行操作\n\t\t\tmachine.toRight();\n\t\t}\n\t}\n\n\t// 具体命令者：快速落下的命令类\n\tpublic class FallCommand implements Command {\n\t\t// 持有一个接收者俄罗斯方块游戏对象的引用\n\t\tprivate TetrisMachine machine;\n\t\tpublic FallCommand(TetriMachine machine){\n\t\t\tthis.machine = machine;\n\t\t}\n\t\t@Override\n\t\tpublic void execute() {\n\t\t\t// 调用游戏机里的具体方法执行操作\n\t\t\tmachine.fastToBottom();\n\t\t}\n\t}\n\n\t// 具体命令者：改变形状的命令类\n\tpublic class TransformCommand implements Command {\n\t\t// 持有一个接收者俄罗斯方块游戏对象的引用\n\t\tprivate TetrisMachine machine;\n\t\tpublic TransformCommand(TetriMachine machine){\n\t\t\tthis.machine = machine;\n\t\t}\n\t\t@Override\n\t\tpublic void execute() {\n\t\t\t// 调用游戏机里的具体方法执行操作\n\t\t\tmachine.transform();\n\t\t}\n\t}\n\n\t// 请求者类：命令由按钮发起\n\tpublic class Buttons {\n\t\tprivate LeftCommand leftCommand; // 向左移动的命令对象引用\n\t\tprivate RightCommand rightCommand; // 向右移动的命令对象引用\n\t\tprivate FallCommand fallCommand; // 快速落下的命令对象引用\n\t\tprivate TransformCommand transformCommand; // 变换形状的命令对象引用\n\n\t\t/**\n\t\t * 设置向左移动的命令对象\n\t\t * @param leftCommand 向左移动的命令对象\n\t\t */\n\t\tpublic void setLeftCommand(LeftCommand leftCommand) {\n\t\t\tthis.leftCommand = leftCommand;\n\t\t}\n\t\t/**\n\t\t * 设置向右移动的命令对象\n\t\t * @param rightCommand 向右移动的命令对象\n\t\t */\n\t\tpublic void setRightCommand(RightCommand rightCommand) {\n\t\t\tthis.rightCommand = rightCommand;\n\t\t}\n\t\t/**\n\t\t * 设置快速落下的命令对象\n\t\t * @param fallCommand 向左移动的命令对象\n\t\t */\n\t\tpublic void setFallCommand(FallCommand fallCommand) {\n\t\t\tthis.fallCommand = fallCommand;\n\t\t}\n\t\t/**\n\t\t * 设置变换形状的命令对象\n\t\t * @param transformCommand 向左移动的命令对象\n\t\t */\n\t\tpublic void setTransformCommand(TransformCommand transformCommand) {\n\t\t\tthis.leftCommand = leftCommand;\n\t\t}\n\t\tpublic void toLeft() { // 按下按钮向左移动\n\t\t\tleftCommand.execute();\n\t\t}\n\t\tpublic void toRight() { // 按下按钮向右移动\n\t\t\trightCommand.execute();\n\t\t}\n\t\tpublic void fall() { // 按下按钮快速落下\n\t\t\tfallCommand.execute();\n\t\t}\n\t\tpublic void transform() { // 按下按钮改变形状\n\t\t\ttransformCommand.execute();\n\t\t}\n\t}\n\n\t// 客户端实现\n\tpublic class Player {\n\t\tpublic static void main(String[] args) {\n\t\t\t// 首先要有俄罗斯方块游戏\n\t\t\tTetrisMachine machine = new TetrisMachine();\n\t\t\t// 根据游戏我们构造 4 种命令\n\t\t\tLeftCommand leftCommand = new LeftCommand(machine);\n\t\t\tRightCommand rightCommand = new RightCommand(machine);\n\t\t\tFallCommand fallCommand = new FallCommand(machine);\n\t\t\tTransformCommand transformCommand = new TransformCommand(machine);\n\t\t\t// 按钮可以执行不同的命令\n\t\t\tButtons buttons = new Buttons();\n\t\t\tbuttons.setLeftCommand(leftCommand);\n\t\t\tbuttons.setRightCommand(rightCommand);\n\t\t\tbuttons.setFallCommand(fallCommand);\n\t\t\tbuttons.setTransformCommand(transformCommand);\n\t\t\t// 具体按下哪个按钮玩家决定\n\t\t\tbuttons.toLeft();\n\t\t\tbuttons.toRight();\n\t\t\tbuttons.fall();\n\t\t\tbuttons.transform();\n\t\t}\n\t}\n\t```\n\n- 便于理解，本示例的 UML 类图如图 2-22 所示。\n\n\t![命令模式实现俄罗斯方块游戏](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-22.svg)\n\t\n\t<center>图 2-22 命令模式实现俄罗斯方块游戏</center>\n\n- 对于大部分开发者来说，更愿意接受的形式：\n\n\t```Java\n\tTetrisMachine machine = new TetrisMachine();\n\t// 实现怎样的控制方式，直接调用相关函数\n\t// machine.toLeft();\n\t// machine.toRight();\n\t// machine.fastToBottom();\n\t// machine.transform();\n\tmachine.toLeft();\n\t```\n\n\t- 调用逻辑做得如此复杂，其实是为了开发起来方便，即每次我们增加或修改游戏功能只需修改 TetrisMachine 类即可。\n\t- 当然，其实这样做是有原因的，即设计模式种有一条重要的原则：对修改关闭对扩展开放。具体好处是：\n\t\t- 如修改功能、代码的具体逻辑，以上例为例，修改 TetrisMachine 类即可。\n\t\t- 此外，命令模式还可以实现命令记录的功能，如在 Buttons 里使用数据结构存储执行过的命令对象，需要时可恢复。\n\n#### 总结\n- 命令模式的优点：更灵活的控制性以及更好的扩展性；更弱的耦合性。\n- 命令模式的缺点：类的膨胀，大量衍生类的创建。\n\n### 观察者模式\n#### 观察者模式的定义\n- 定义对象间一种 `一对多` 的 `依赖关系`，使得每当一个对象改变状态，则所有依赖与它的对象都会得到通知并被自动更新。\n\n#### 观察者模式的使用场景\n- 关联行为场景，即关联行为是可拆分的，而不是组合关系。\n- 事件多级触发场景。\n- 跨系统的消息交换场景，如消息队列、事件总线的处理机制。\n\n#### 观察者模式的 UML 类图\n- 观察者模式的 UML 类图如图 2-23 所示。\n\n\t![观察者模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-23.svg)\n\t\n\t<center>图 2-23 观察者模式的 UML 类图</center>\n\n#### 观察者模式实战\n\n#### 总结\n- 观察者模式主要的作用就是对象解耦，将观察者与被观察者完全隔离，只依赖于 Observer 和 Obserable 抽象。\n\n\t> 如：ListView 就是运用了 Adapter 和观察者模式，使之它的扩展性、灵活性增强，且耦合度却很低。\n\n- 观察者模式的优点  \n\t- 增强系统灵活性、可扩展性。 \n\t- 将观察者与被观察者之间是抽象耦合，应对业务变换。\n- 观察者模式的缺点：应用观察者模式，需考虑开放效率和运行效率问题（一般考虑采用异步的方式）。\n\n### 备忘录模式\n#### 备忘录模式的介绍\n- 行为型设计模式。\n- 用于保存对象当前状态，并在之后可再次恢复到此状态。\n- 保证被保存的对象状态不能被对象从外部访问，目的是为了保护好被保存对象状态的完整性及内部实现不向外暴露。\n\n#### 备忘录模式的定义\n- 在不破坏封闭的前提下，捕获一个 `对象的内部状态`，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原生保存的状态。\n\n#### 备忘录模式的 UML 类图\n- 备忘录模式的 UML 类图如图 2-24 所示。\n\n\t![备忘录模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-24.svg)\n\t<center>图 2-24 备忘录模式的 UML 类图</center>\n\n\t- **Originator**：负责创建一个备忘录，可以记录、恢复自身的内部状态。同时 Originator 还可以根据需要决定 Memoto 存储自身的哪些内部状态。\n\t- **Memoto**：备忘录角色，用于储存 Originator 的内部状态，并且可以防止 Originator 以外的对象访问 Memoto。\n\n\t\t> 备忘录角色的作用类似于 POJO 实体类，只作参数表示。\n\n\t- **Caretaker**：负责储存备忘录，不能对备忘录的内容进行操作和访问，只能够将备忘录传递给其他对象。\n\n#### 备忘录模式的简单实例\n- 对于备忘录模式来说，比较贴切的场景应该是游戏中的存档功能，该功能就是将游戏进度存储到本地文件系统或者数据库中，下次再次进入时从本地加载进度，使得玩家能够继续上一次的游戏之旅。下面我们以“使命召唤”这款游戏为例简单演示备忘录模式的实现。\n\n\t首先我们建立游戏类 CallOfDuty，备忘录类 Memoto 和负责管理 Memoto 的 CareTaker 类。玩游戏到某个节点对游戏进行存档，然后退出游戏，再重新进入时从存档中读取进度，并且进入存档时的进度。\n\t\n\t```Java\n\t// ”使命召唤“ 游戏 ( 简化的数据模型，仅供简单演示 )\n\tpublic class CallOfDuty {\n\t\tprivate int mCheckPoint = 1;\n\t\tprivate int mLifeValue = 100;\n\t\tprivate String mWeapon = \"沙漠之鹰\";\n\t\tpublic void play() { // 玩游戏\n\t\t\t// 忽略实现细节\n\t\t}\n\t\tpublic void quit() { // 退出游戏\n\t\t\t// 忽略实现细节\n\t\t}\n\n\t\tpublic Memoto createMemoto() { // 创建备忘录\n\t\t\tMemoto memoto = new Memoto();\n\t\t\tmemoto.mCheckPoint = mCheckPoint;\n\t\t\tmemoto.mLifeValue = mLifeValue;\n\t\t\tmemoto.mWeapon = mWeapon;\n\t\t\treturn memoto;\n\t\t}\n\t \n\t\tpublic void restore(Memoto memoto) { // 恢复游戏\n\t\t\tthis.mCheckPoint = memoto.mCheckPoint;\n\t\t\tthis.mLifeValue = memoto.mLifeValue;\n\t\t\tthis.mWeapon = memoto.mWeapon;\n\t\t\tSystem.out.println(\"恢复后的游戏属性: \" + this.toString());\n\t\t}\n\t \n\t\t@Overrride\n\t\tpublic String toString() {\n\t\t\treturn \"CallOfDuty[mCheckPoint=..., mLifeValue=..., mWeapon=...]\"\n\t\t}\n\t}\n\n\t// 备忘录类\n\tpublic class Memoto {\n\t\tpublic int mCheckPoint;\n\t\tpublic int mLifeValue;\n\t\tpublic String mWeapon;\n\t}\n\n\t// Caretaker，负责管理 Memoto\n\tpublic class Caretaker {\n\t\tMemoto memoto = null;\n\t\n\t\tpublic void archive(Memoto memoto) { // 存档\n\t\t\tthis.memoto = memoto;\n\t\t}\n\n\t\tpublic Memoto getMemoto() { // 读取存档\n\t\t\treturn memoto;\n\t\t}\n\t}\n\n\t// 客户端实现\n\tpublic class Client {\n\t\tpublic static void main(String[] args) {\n\t\t\tCallOfDuty game = new CallOfDuty();\n\t\t\t// Step.01 游戏开始\n\t\t\tgame.play();\n\t\t\t// Step.02 游戏存档\n\t\t\tCaretaker caretaker = new Caretaker();\n\t\t\tcaretaker.archive( game.createMemoto() );\n\t\t\t// Step.03 退出游戏\n\t\t\tgame.quit();\n\t\t\t// Step.04 恢复游戏\n\t\t\tCallOfDuty newGame = new CallOfDuty();\n\t\t\tnewGame.restore( caretaker.getMemoto() );\n\t\t}\n\t}\n\t```\n\n- 便于理解，本示例的 UML 类图如图 2-25 所示。\n\n\t![使命召唤的存储功能实现](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-25.svg)\n\t\n\t<center>图 2-25 使命召唤的存储功能实现</center>\n\n#### 总结\n- 备忘录模式是在不破坏封装的条件下，通过备忘录对象 (Memoto) 存储另外一个对象内部状态的快照，在需求的时候把对象还原到存储的状态。\n- 备忘录的优点：恢复状态机制；信息封装\n- 备忘录的缺点：消耗内存 \n\n### 迭代器模式\n\n#### 迭代器模式的介绍\n- 又称游标 (Cursor) 模式，行为型设计模式。\n- 迭代器模式源于对容器的访问，若我们将遍历的方法封装在容器中，则存在问题：\n\t- 不仅维护自身内部数据且要对外提供遍历的接口方法。\n\t- 不能对同一个容器同时进行多个遍历操作。\n\t- 不提供遍历方法，而让使用者自行实现，必暴露内部细节。  \n- 解决方案：在客户访问类与容器直接插入一个第三者 `迭代器`。\n\n#### 迭代器模式的定义\n- 提供一种方法 `顺序访问` 一个容器对象中的各个元素，而不需暴露该对象内部细节。\n\n#### 迭代器模式的 UML 类图\n- 迭代器模式的 UML 类图如图 2-26 所示。\n\n\t![迭代器模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-26.svg)\n\t<center>图 2-26 迭代器模式的 UML 类图</center>\n\n\t- **Iterator**：迭代器接口，负责定义、访问和遍历元素的接口。\n\t- **ConcreteIterator**：具体迭代器类，实现迭代器接口，并记录遍历的当前位置。  \n\t- **Aggregate**：容器接口，负责提供创建具体迭代器角色的接口。\n\t- **ConcreteAggregate**：具体容器类，具体迭代器角色与该容器相关联。\n\n- 迭代器模式的简单代码实现：\n\n\t```Java\n\t// 迭代器接口\n\tpublic interface Iterator<T> {\n\t\t/**\n\t\t * 是否还有下一个元素\n\t\t * @return true 表示有，false 表示没有\n\t\t */\n\t\tboolean hasNext();\n\t\t/**\n\t\t * 返回当前位置的元素并将位置移至下一位\n\t\t * @return T 返回当前位置的元素\n\t\t */\n\t\tT next();\n\t}\n\t// 具体迭代器类\n\tpublic class ConcreteIterator<T> implements Iterator<T> {\n\t\tprivate List<T> list = new ArrayList<T>();\n\t\tprivate int cursor = 0;\t\n\t\tpublic ConcreteIterator(List<T> list) {\n\t\tthis.list = list;\n\t\t}\t\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn cursor != list.size();\n\t\t}\n\t\t@Override\n\t\tpublic T next() {\n\t\t\tT obj = null;\n\t\t\tif( this.hasNext()) {\n\t\t\t\tobj = this.list.get(cursor++);\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\t}\n\t// 容器接口\n\tpulbic interface Aggregate<T> {\n\t\t/**\n\t\t * 添加一个元素\n\t\t * @param obj 元素对象\n\t\t */\n\t\tvoid add(T obj); \t\n\t\t/**\n\t\t * 移除一个元素\n\t\t * @param obj 元素对象\n\t\t */\n\t\tvoid remove(T obj);\t\n\t\t\t/**\n\t\t * 获取容器的迭代器\n\t\t * @return 迭代器对象\n\t\t */\n\t\tIterator<T> Iterator();\n\t}\n\t// 具体容器类\n\tpublic class ConcreteAggregate<T> implements Aggregate<T> {\n\t\tprivate List<T> list = new ArrayList<T>();\n\t\t@Override\n\t\tpublic void add() {\n\t\t\tlist.add(obj);\n\t\t}\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tlist.remove(obj);\n\t\t}\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new ConcreteIterator<T>(list);\n\t\t}\n\t}\n\t\n\t// 客户端实现\n\tpublic class Client {\n\t\tpublic static void main(String[] args) {\n\t\t\tAggregate<String> aggregate = new ConcreteAggregate<>();\n\t\t\n\t\t\taggregate.add(\"Aige \");\n\t\t\taggregate.add(\"Studio\\n\");\n\t\t\taggregate.add(\"SM \");\n\t\t\taggregate.add(\"Brother\\n\");\n\t\t\n\t\t\tIterator<String> iterator = aggregate.iterator();\n\t\t\twhile( iterator.hasNext() ) {\n\t\t\t\tSystem.out.println(iterator.next());\n\t\t\t}\t\n\t\t}\n\t}\n\t```\n\n#### 总结\n- 迭代器模式的优点：支持以不同的方式遍容器对象，也可以有多个遍历，弱化了容器类与遍历算法之间的关系。\n- 迭代器模式的缺点：类文件的增加。  \n- 当然几乎每一种高级语言都有相应的内置迭代器实现，故本章的内容在于了解思想而非应用。\n\n### 模板方法模式\n#### 模板方法模式的介绍\n- 若我们知道一个算法所需的 `关键步骤`，并确定了这些步骤的 `执行顺序`，但某些步骤的具体 `实现未知` 或实现是随 `环境变化` 的。\n\n- 例如，执行程度的流程大致为：  \n\t- Step.01：检查代码正确性  \n\t- Step.02：链接相关类库  \n\t- Step.03：编译  \n\t- Step.04：执行程序  \n\n\t> 即上述步骤的实现细节不一样，但执行流程是固定的。\n\n- 模版方法给我们的启示是，写程序应该 \"先有主体逻辑，再填实现细节\"。\n\n#### 模板方法模式的定义\n- 定义一个操作的 `算法框架`。\n- 将步骤延迟到子类，使子类不改变算法结构即可重定义该算法的某些特定步骤。\n\n#### 模板方法模式的使用场景\n- 多个子类有公有的方法且逻辑基本相同。\n- 重要复杂的算法，可把核心算法设计为模板方法，周边细节功能则由各个子类实现。\n- 重构时使用模板方法，即相同代码抽取到父类中，然后通过 `钩子函数` 约束其行为。\n\n\t> `钩子函数`：普通的抽象类多态，即它在模板方法模式中提供了改变原始逻辑的空间。\n\n#### 模板方法模式的 UML 类图\n- 模板方法模式的 UML 类图如图 2-27 所示。\n\n\t![模板方法模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-27.svg)\n\t\n\t<center>图 2-27 模板方法模式的 UML 类图</center>\n\n#### 总结\n- 模板方法模式：`流程封装`，即把某个固定流程封装到一个 final 函数中，并让子类能够定制这个流程的某些或者所有步骤。\n\n\t> 要求父类提供共同代码，即提高代码复用性、可扩展性。\n\n- 模板方法的优点  \n\t- 封装不变部分，扩展可变部分。\n\t- 提取公共部分代码。\n\n### 访问者模式\n#### 访问者模式的介绍\n- 将 `数据操作` 与 `数据结构` 分离的设计模式。\n- 软件系统拥有由许多对象构成的对象结构，这些对象拥有一个 accept() 方法接受访问者对象访问。\n- 访问者是一接口，拥有一个 visit() 方法对访问到的对象结构中不同类型的元素作出不同的处理。\n\t- 在对象结构的一次访问中，遍历整个对象结构，对每个元素实施 accept() 方法。  \n\t- 每一元素的 accept() 方法会调用访问者的 visit() 方法，即访问者可针对对象结构设计不同的访问类来完成不同操作。\n\n#### 访问者模式的定义\n- 封装用于某种数据结构中各元素操作，且在不改数据结构的前提下定义这些元素的新操作。\n\n#### 访问者模式的使用场景\n- 对同一对象结构中的对象进行不同且不相关的操作。\n- 需避免操作 “污染” 对象的类。\n- 增加新操作是不修改这些类。\n- 对象结构稳定，但经常需在对象结构上定义新操作。\n\n#### 访问者模式的 UML 类图\n- 访问者模式的 UML 类图如图 2-28 所示。\n\n\t![访问者模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-28.svg)\n\t\n\t<center>图 2-28 访问者模式的 UML 类图</center>\n\n#### 访问者模式的简单示例\n- 公司给员工进行业绩考核，评定由公司高层负责。但不同领域的管理人员对与员工的评定标准不一样。即我们把员工分为工程师和经理，评定员工分为 CTO 和 CEO。\n\n\t假定 CTO 关注工程师的代码量，经理的新产品数量；CEO 关注工程师的 KPI，经理的 KPI 及新产品数量。\n\n\t```Java\n\t// 员工基类\n\tpublic abstract class Staff {\n\t\tpublic String name;\n\t\tpublic int kpi; // 员工 KPI\n\t\tpublic Staff(String name) {\n\t\t\tthis.name = name;\n\t\t\tkpi = new Random().nextInt(10); // 随机生成 10 内的值.\n\t\t}\t\n\t\t// 接受 Visitor 的访问\n\t\tpublic abstract void accept(Visitor visitor);\n\t}\n\n\t// 工程师类型\n\tpublic class Engineer extends Staff {\n\t\tprivate int codes; // 代码量\n\t\tpublic Engineer (String name) {\n\t\t\tsuper(name);\n\t\t\tcodes = new Random().nextInt(100000)\n\t\t}\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.visit(this);\n\t\t}\t\t\n\t\tpublic int getCodeLines() { // 工程师一年内写的代码量\n\t\t\treturn codes;\n\t\t}\n\t}\n\n\t// 经理类型\n\tpublic class Manager extends Staff {\n\t\tprivate int products; // 产品数量\n\t\tpublic Manager (String name) {\n\t\t\tsuper(name);\n\t\t\tproducts = new Random().nextInt(10);\n\t\t}\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.visit(this);\n\t\t}\n\t\tpublic int getProducts() { // 经理一年内做的产品数量\n\t\t\treturn products;\n\t\t}\n\t}\n\n\tpublic interface Visitor {\n\t\t// 访问工程师类型\n\t\tpublic void visit(Engineer engineer); \t\n\t\t// 访问经理类型\n\t\tpublic void visit(Manager leader); \n\t}\n\n\t// CEO 访问者\n\tpublic class CEOVisitor implements Visitor {\n\t\t@Override\n\t\tpublic void visit(Engineer engineer) {\n\t\t\tSystem.out.println(\"Name:..., KPI:...\");\n\t\t}\t\n\t\t@Override\n\t\tpublic void visit(Manager mgr) {\n\t\t\tSystem.out.println(\"Name:..., KPI:..., Products:...\");\n\t\t}\n\t}\n\n\t// CTO 访问者\n\tpublic class CTOVisitor implements Visitor {\n\t\t@Override\n\t\tpublic void visit(Engineer engineer) {\n\t\t\tSystem.out.println(\"Name:..., Codes:...\");\n\t\t}\n\t\t@Override\n\t\tpublic void visit(Manager mgr) {\n\t\t\tSystem.out.println(\"Name:..., Products:...\");\n\t\t}\n\t}\n\n\tpublic class BusinessReport {\n\t\tList<Staff> mStaffs = new LinkedList<Staff>();\n\t\tpublic BusinessReport() {\n\t\t\tmStaffs.add(new Manager(\"Manager Wang.\"));\n\t\t\tmStaffs.add(new Manager(\"Manager Lin.\"));\n\t\t\tmStaffs.add(new Manager(\"Engineer Kael.\"));\n\t\t\tmStaffs.add(new Manager(\"Engineer Chaos.\"));\n\t\t}\n\t\t/**\n\t\t * 为访问者展示报表\n\t\t * @param visitor 公司高层，如 CEO、CTO\n\t\t */\n\t\tpublic void showReport(Visitor visitor) {\n\t\t\tfor( Staff staff : mStaffs ) {\n\t\t\t\tstaff.accept(visitor);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 客户端实现\n\tpublic class Client {\n\t\tpublic static void main(String[] args) {\n\t\t\tBusinessReport report = new BusinessReport();\n\t\t\treport.showReport( new CEOVisitor() );\n\t\t\treport.showReport( new CTOVisitor() );\n\t\t}\n\t}\n\t```\n\n- 便于理解，本示例的 UML 类图如图 2-29 所示。\n\n\t![公司员工业绩考核](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-29.svg)\n\t\n\t<center>图 2-29 公司员工业绩考核</center>\n\n#### 总结\n- 对象结构足够稳定，但需要在对象结构上经常定义新操作，需要对对象结构中的对象进行不同不相关的操作，考虑使用访问者模式。\n- 访问者模式的优点  \n\t- 单一职责原则，即各角色职责分离。  \n\t- 数据结构和作用于该结构上的 `操作解耦`。\n- 访问者模式的缺点  \n\t- 具体元素对访问者公布细节。  \n\t- 具体元素变更导致修改成本大。  \n\t- 违反依赖倒置原则，即为了 “区别对待” 而依赖了具体类，没有依赖抽象，如上例中的 Engineer 与 Manager。  \n\t\n### 中介者模式\n#### 中介者模式的介绍\n- 又称为调节者模式或调停者模式，行为型设计模式。\n\n#### 中介者模式的定义\n- 包装一系列对象相互作用的方式，使这些对象不必相互明显作用。\n- 将多对多的相互作用转化为一对多的相互作用。\n- 将对象的行为和协作抽象化。\n\n#### 中介者模式的使用场景\n- 对象间交互操作较多且每个对象的行为操作都依赖彼此时，为防止修改其中一对象的行为同时涉及修改很多其他对象的行为。\n- 该模式将对象间的 `多对多关系` 变成 `一对多关系`。\n- 中介者对象将系统从网状结构变成以调停者为中心的星形结构，以降低系统复杂性，提高可扩展性作用。\n\n#### 中介者模式的 UML 类图\n- 中介者模式的 UML 类图如图 2-30 所示。\n\n\t![中介者模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-30.svg)\n\t\n\t<center>图 2-30 中介者模式的 UML 类图</center>\n\n- 中介者模式的简单代码实现：\n\n\t```Java\n\t// 抽象中介者\n\tpublic abstract class Mediator {\n\t\tprotected ConcreteColleagueA colleagueA; // 具体同事类 A\n\t\tprotected ConcreteColleagueB colleagueB; // 具体同事类 B\n\t\t// 抽象中介方法、子类实现\n\t\tpublic abstract void method();\n\t\tpublic void setColleagueA(ConcreteColleagueA colleagueA) {\n\t\t\tthis.colleagueA = colleagueA;\n\t\t}\n\t\tpublic void setColleagueB(ConcreteColleagueB colleagueB) {\n\t\t\tthis.colleagueB = colleagueB;\n\t\t}\n\t}\n\t\n\t// 具体中介者\n\tpublic class ConcreteMediator extends Mediator {\n\t\t@Override\n\t\tpublic void method() {\n\t\t\tcolleagueA.action();\n\t\t\tcolleagueB.action();\n\t\t}\n\t}\n\t\n\t// 抽象同事\n\tpublic abstract class Colleague {\n\t\tprotected Mediator mediator; // 中介者对象\n\t\tpublic Colleague(Mediator mediator) {\n\t\t\tthis.mediator = mediator;\n\t\t}\n\t\t// 同事角色的具体行为，由子类去实现\n\t\tpublic abstract void action();\n\t}\n\t\n\t// 具体同事 A\n\tpublic class ConcreteColleagueA extends Colleague {\n\t\tpublic ConcreteColleagueA(Mediator mediator) {\n\t\t\tsuper(mediator);\n\t\t}\n\t\t@Override\n\t\tpublic void action() {\n\t\t\tSystem.out.println(\"Colleague A 将信息递交给中介者处理.\");\n\t\t}\n\t}\n\t\n\t// 具体同事 B\n\tpublic class ConcreteColleagueB extends Colleague {\n\t\tpublic ConcreteColleagueB(Mediator mediator) {\n\t\t\tsuper(mediator);\n\t\t}\n\t\t@Override\n\t\tpublic void action() {\n\t\t\tSystem.out.println(\"Colleague B 将信息递交给中介者处理.\");\n\t\t}\n\t}\n\t```\n\n#### 中介者模式的简单实现\n- 便于理解，本示例的 UML 类图如图 2-31 所示。\n\n\t![电脑内部硬件的交互](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-31.svg)\n\t<center>图 2-31 电脑内部硬件的交互</center>\n\n\t- 中介者模式就是用来协调多个对象之间的交互，就像上例中的主板，没有主板这个中介者，那么电脑里的每一个零部件都要与其他零部件建立关联。\n\n\t- 比如 CPU 要与内存交互，与显卡交互以及与 IO 设备交互，那么这样一来就会构成一个错综复杂的网状图，而中介者模式即将网状图变成一个结构清晰的星形图。\n\n#### 中介者模式实战\n- 协调多个交互的对象，Android 中这么多形形色色控件也算是交互对象。\n- 其中社交、网商等应用的用户登录模块，账号框、密码框、登录按钮之间的相互制约、联系，正是中介者模式的表现，具体的实例样式可自行尝试。\n\n#### 总结\n- 中介者模式的优点：将网状般的依赖关系转化为以中介者为中心的星形结构，即使用中介者模式可对这种依赖关系进行解耦使逻辑结构清晰。\n- 中介者模式的缺点：若几个类间的依赖关系并不复杂，使用中介者模式反而会使原本不复杂的逻辑结构变得复杂。\n\n### 代理模式\n#### 代理模式的定义\n- 结构型设计模式。\n- 为其他对象提供一种代理以控制目标对象的访问。\n\n#### 代理模式的使用场景\n- 无法或不想直接访问某个对象或访问某对象存在困难。\n- 为保证客户端使用的透明性，委托对象与代理对象需实现相同的接口。\n\n#### 代理模式的 UML 类图\n- 代理模式的 UML 类图如图 2-32 所示。\n\n\t![代理模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-32.svg)\n\t<center>图 2-32 代理模式的 UML 类图</center>\n\n\t- **Subject 抽象主题类**：该类主要职责是声明真实主题与代理的共同接口方法，其可是抽象类或接口。\n\t- **RealSubject 真实主题类**：该类也被称为被委托类或者被代理类，该类定义了代理所表示的真实对象，由其执行具体的业务逻辑方法，而客户类则通过代理类间接地调用真实主题类中定义的方法。\n\t- **ProxySubject 代理类**：该类也称为委托类或者代理类，该类持有一个对真实主题类的引用，在其所实现的接口方法中调用真实主题类中相应的接口方法执行，以起到代理的作用。\n\n- 代理模式的简单代码实现：\n\n\t```Java\n\t// 抽象主题类\n\tpublic abstract class Subject {\n\t\t// 一个普通的业务方法\n\t\tpublic abstract void visit();\n\t}\n\t// 实现抽象主题的真实主题类\n\tpublic class RealSubject extends Subject {\n\t\tpublic void visit() {\n\t\t\tSystem.out.println(\"Real Subjetc!\");\n\t\t}\n\t}\n\t// 代理类\n\tpublic class ProxySubject extends Subject {\n\t\tprivate RealSubject mSubject; // 持有真实主题的引用\n\t\tpublic ProxySubject(RealSubject mSubject) {\n\t\t\tthis.mSubject = mSubject;\n\t\t}\n\t\t@Override\n\t\tpublic void visit() {\n\t\t\tmSubject.visit();\n\t\t}\n\t}\n\t\n\t// 客户端实现\n\tpublic class Client {\n\t\tpublic static void main(String args) {\n\t\t\t// 构造一个真实主题对象\n\t\t\tRealSubject real = new RealSubject();\n\t\t\t// 通过真实主题对象构造一个代理对象\n\t\t\tProxySubject proxy = new ProxySubject(real);\n\t\t\t// 调用代理的相关方法\n\t\t\tproxy.visit(); \n\t\t}\n\t}\n\t```\n\n#### 代理模式的简单实现\n- 以生活中常有的例子，老板拖欠工资甚至克扣工资的情况，而最恰当的途径就是通过法律诉讼解决问题。一旦选择走法律途径解决该纠纷，那么不可避免地需请一个律师来作为自己的诉讼代理人。\n\n\t```Java\n\t// 诉讼接口类\n\tpublic interface ILawsuit {\n\t\tvoid submit(); // 提交申请\n\t\tvoid burden(); // 进行举证\n\t\tvoid defend(); // 开始辩护\n\t\tvoid finish(); // 诉讼完成\n\t}\n\t// 具体诉讼人\n\tpublic class XiaoMin implements ILawsuit {\n\t\t@Override\n\t\tpublic void submit() {\n\t\t\tSystem.out.println(\"老板拖欠工资，特此申请仲裁!\");\n\t\t}\n\t\t@Override\n\t\tpublic void burden() {\n\t\t\tSystem.out.println(\"这是合同书和过去一年的银行工资流水!\");\n\t\t}\n\t\t@Override\n\t\tpublic void defend() {\n\t\t\tSystem.out.println(\"证据确凿!\");\n\t\t}\n\t\t@Override\n\t\tpublic void finish() {\n\t\t\tSystem.out.println(\"诉讼成功!\");\n\t\t}\n\t}\n\t// 代理律师\n\tpublic class Lawyer implements ILawsuit {\n\t\tprivate ILawsuit mLawsuit; // 持有一个具体被代理者的引用\t\n\t\tpublic Lawyer(ILawsuit lawsuit) {\n\t\t\tmLawsuit = lawsuit;\n\t\t}\n\t\t@Override\n\t\tpublic void submit() {\n\t\t\tmLawsuit.submit();\n\t\t}\n\t\t@Override\n\t\tpublic void burden() {\n\t\t\tmLawsuit.burden();\n\t\t}\n\t\t@Override\n\t\tpublic void defend() {\n\t\t\tmLawsuit.defend();\n\t\t}\n\t\t@Override\n\t\tpublic void finish() {\n\t\t\tmLawsuit.finish();\n\t\t}\n\t}\n\n\t// 客户端实现\n\tpublic class Client {\n\t\tpublic static void main(String[] args) {\n\t\t\tILawsuit xiaomin = new XiaoMin();\n\t\t\tILawsuit lawyer = new Lawyer(xiaomin);\n\t\t\tlawyer.submit();\n\t\t\tlawyer.burden();\n\t\t\tlawyer.defend();\n\t\t\tlawyer.finish();\n\t\t}\n\t}\n\t```\n\n- 便于理解，本示例的 UML 类图如图 2-33 所示。\n\n\t![律师作为诉讼代理人](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-33.svg)\n<center>图 2-33 律师作为诉讼代理人</center>\n\n#### 静态代理与动态代理\n- `静态代理`：代码由程序员自己或者通过一些自动化工具生成固定的代码（硬编码）再对其进行编译，即在代码运行前代理类的 Class 编译文件就已经存在。上述例子即为静态代理的实现模式。\n\n- `动态代理`：通过 `反射机制` 动态地生成代理者的对象，即我们在编译阶段不需要知道代理者是谁，代理谁我们将在执行阶段决定。Java 提供了便捷的动态代理接口 InvocationHandler。  \n\t- 同样，以动态代理方式实现上述例子，本示例的 UML 类图如图 2-34 所示。\n\n\t  ![动态代理的实现案例](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-34.svg)\n\t\n  <center>图 2-34 动态代理的实现案例</center>\n\t\n- 动态代理方式的简单代码实现：\n\n\t```Java\n\tpublic class DynamicProxy implements IncocationHandler {\n\t\tprivate Object obj; // 被代理的类引用\n\t\tpublic DynamicProxy(Object obj) {\n\t\t\tthis.obj = obj;\n\t\t}\n\t\t@Override\n\t\tpublic Object invoke(\n\t\tObject proxy, Method method, Object[] args) throws Throwable {\n\t\t\tObject result = method.invoke(obj, args);\n\t\t\treturn result;\n\t\t}\n\t}\n\t\t\n\t// 客户端实现\n\tpublic class Client {\n\t\tpublic static void main(String[] args) {\n\t\tILawsuit xiaomin = new XiaoMin();\n\t\tDynamicProxy proxy = new DynamicProxy(xiaomin);\n\t\t\n\t\t// 获取被代理类小民的 ClassLoader\n\t\tClassLoader loader = xiaomin.getClass().getClassLoader();\n\t\t// 动态构造一个代理者律师\n\t\tILawsuit lawyer =(ILawsuit) Proxy.newProxyInstance(loader,\n\t\t\tnew Class[] {ILawsuit.class}, proxy);\n\t\t)\n\t\t// 律师提交诉讼申请\n\t\tlawyer.submit();\n\t\t// 律师进行举证\n\t\tlawyer.burden();\n\t\t// 律师代替小民进行辩护\n\t\tlawyer.defend();\n\t\t// 完成诉讼\n\t\tlawyer.finish();\n\t\t}\n\t}\n\t```\n\n### 组合模式\n#### 组合模式的介绍\n- 又称 “部分整体” 模式，结构型设计模式。\n- 它将一组相似的对象看作一个对象处理，并根据一个树状结构来组合对象，然后提供一个统一的方法去访问相应对象。\n\n- 例如公司组织结构的树状图，如图 2-35 所示。\n\n  ![公司组织结构的树状图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-35.svg)\n\n  <center>图 2-35 公司组织结构的树状图</center>\n\n- 在组合模式中，我们将这样的一个拥有分支的节点称之为枝干构件，位于树状结构顶部的枝干结构比较特殊，我们称为根结构件，因其为整个树状图的始端。同样对于像行政部和研发部这样没有分支的结构，我们称之为叶子结构，这样的一个结构就是组合模式的雏形。如图 2-36 所示。\n\t\n\t![组合模式的雏形](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-36.svg)\n\n\t<center>图 2-36 组合模式的雏形</center>\n\n#### 组合模式的定义\n- 将对象组合成 `树状结构` 以表示 \"部分-整体\" 的 `层次结构`，使得用户对单个对象和组合对象的使用具有一致性。\n\n#### 组合模式的使用场景\n- 表示对象的 `部分-整体` 层次结构时。\n- 从一个整体中能够独立出部分模块或功能的场景。\n\n#### 组合模式的 UML 类图\n- 组合模式的 UML 类图如图 2-37 所示。\n\n  ![组合模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-37.svg)\n\n  <center>图 2-37 组合模式的 UML 类图</center>\n\n- 上述所讲与依赖倒置原则相违背，既然是面向接口编程，则我们就该把焦点放在接口设计上，即在 Composite 的一些实现方法定义到 Component 中。\n- 这样，我们会得到一个不一样的组合模式，也称为安全的组合模式，该安全组合模式的 UML 类图见图 2-38 所示。\n\n\t> 透明组合模式不管是叶子还是枝干节点都有相同的结构，那么意味着不能单一的 getChildren() 方法得到子字节的类型 (已是叶子节点)，则必须在方法实现的内部进行判断。\n\n\t![安全的组合模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-38.svg)\n\t\n\t<center>图 2-38 安全的组合模式的 UML 类图</center>\n\n- 安全组合模式的代码实现：\n\n\t```Java\n\t// 透明的组合模式抽象根节点\n\tpublic abstract class Component {\n\t\tprotected String name; // 节点\n\t\tpulbic Component(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\t\t//具体的逻辑方法由子类实现\n\t\tpublic abstract void doSomething();\n\t\t/**\n\t\t * 添加子节点\n\t\t * @child 子节点\n\t\t */\n\t\tpublic abstract void addChild(Component child);\n\t\t/**\n\t\t * 移除子节点\n\t\t * @child 子节点\n\t\t */\n\t\tpublic abstract void removeChild(Component child);\n\t\t/**\n\t\t * 获取子节点\n\t\t * @param index 子节点对应下标\n\t\t * @return 子节点\n\t\t */\n\t\tpublic abstract Component getChildren(int index);\n\t}\n\t\n\t// 透明的组合模式具体枝干节点\n\tpublic class Composite extends Component {\n\t\t// 存储节点的容器\n\t\tprivate List<Component> components = new ArrayList<>();\n\t\tpublic Composite(String name) {\n\t\t\tsuper(name);\n\t\t}\n\t\t@Override\n\t\tpublic void doSomething() {\n\t\t\tSystem.out.println(name);\n\t\t\tif( null != components ) {\n\t\t\t\tfor(Component c : components) {\n\t\t\t\t\tc.doSomething();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic void addChild(Component child) {\n\t\t\tcomponents.add(child);\n\t\t}\n\t\t@Override\n\t\tpublic  void removeChild(Component child) {\n\t\t\tcomponents.remove(child);\n\t\t}\n\t\n\t\t@Override\n\t\tpublic Component getChildren(int index) {\n\t\t\treturn components.get(index);\n\t\t}\n\t}\n\t\n\t// 透明的组合模式叶子节点\n\tpublic class Leaf extends Component {\n\t\tpublic Leaf(String name) {\n\t\t\tsuper(name);\n\t\t}\n\t\t@Override\n\t\tpublic void doSomething() {\n\t\t\tSystem.out.println(name);\n\t\t}\n\t\t@Override\n\t\tpublic void addChild(Component child) {\n\t\t\tthrow new UnsupportedOperationException(\"叶子节点没有子节点\");\n\t\t}\n\t\n\t\t@Override\n\t\tpublic void removeChild(Component child) {\n\t\t\tthrow new UnsupportedOperationException(\"叶子节点没有子节点\");\n\t\t}\n\t\n\t\t@Override\n\t\tpublic Component getChildren(int index) {\n\t\t\tthrow new UnsupportedOperationException(\"叶子节点没有子节点\");\n\t\t}\n\t}\n\t\n\t// 客户端实现\n\tpublic class Client {\n\t\tpublic static void main(String[] args) {\n\t\t\t// 构造一个根节点\n\t\t\tComponent root = new Composite(\"Root\");\n\t\t\t// 构造两个枝干节点\n\t\t\tComponent branch1 = new Composite(\"Branch1\");\n\t\t\tComponent branch2 = new Composite(\"Branch2\");\n\t\t\t// 构造两个叶子节点\n\t\t\tComponent leaf1 = new Leaf(\"Leaf1\");\n\t\t\tComponent leaf2 = new Leaf(\"Leaf2\");\n\t\t\t// 将叶子节点添加至枝干节点中\n\t\t\tbranch1.addChild(leaf1);\n\t\t\tbranch2.addChild(leaf2);\n\t\t\t//将枝干节点添加到根节点中\n\t\t\troot.addChild(branch1);\n\t\t\troot.addChild(branch2);\n\t\t\t// 执行方法\n\t\t\troot.doSomething();\n\t\t}\n\t}\n\t```\n\n#### 组合模式的简单实现\n- 在操作系统中，文件系统其实就是一种典型的组合模式例子。\n- 具体地，文件系统中文件就是可被具体程序执行的对象，文件夹就是可存放文件和文件夹的对象。文件系统的组合模式表示如图 2-39 所示。\n\n  ![文件系统的组合模式表示](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-39.svg)\n\n  <center>图 2-39 文件系统的组合模式表示</center>\n\n- 便于理解，本实例的 UML 类图如图 2-40 所示。\n\n  ![文件系统的组合模式实现](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-40.svg)\n\n  <center>图 2-40 文件系统的组合模式实现</center>\n\n- 文件系统的组合模式的代码实现：\n\n\t```Java\n\t// 表示文件或文件夹的抽象类\n\tpublic abstract class Dir {\n\t\t/**\n\t\t * 声明一个 List 成员变量存储文件夹下的所有元素\n\t\t */\n\t\tprotected List<Dir> dirs = new ArrayList<>();\n\t\tprivate String name; // 当前文件或文件夹的名称\n\t\tpublic Dir(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\t\t/**\n\t\t * 添加一个文件或文件夹\n\t\t * @param dir 文件或文件夹\n\t\t */\n\t\tpublic abstract void addDir(Dir dir);\n\t\t/**\n\t\t * 移除一个文件或文件夹\n\t\t * @param dir 文件或文件夹\n\t\t */\n\t\tpublic abstract void rmDir(Dir dir);\n\t\t/**\n\t\t * 清空文件夹下所有元素\n\t\t */\n\t\tpublic abstract void clear();\n\t\t/**\n\t\t * 输出文件夹目录结构\n\t\t */\n\t\tpublic abstract void print();\n\t\t/**\n\t\t * 获取文件夹下所有的文件或文件夹\n\t\t * @return 文件夹下所有的文件或文件夹\n\t\t */\n\t\tpublic abstract List<Dir> getFiles();\n\t\t/**\n\t\t * 获取文件或文件夹的名称\n\t\t * @return 文件或文件夹的名称\n\t\t */\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\t}\n\t\n\t// 表示文件夹的类\n\tpublic class Folder extends Dir {\n\t\tpublic Folder(String name) {\n\t\t\tsuper(name);\n\t\t}\n\t\t@Override\n\t\tpublic void addDir(Dir dir) {\n\t\t\tdirs.add(dir);\n\t\t}\n\t\t@Override\n\t\tpublic void rmDir(Dir dir) {\n\t\t\tdirs.remove(dir);\n\t\t}\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tdirs.clear();\n\t\t}\n\t\t@Override\n\t\tpublic void print() {\n\t\t\tSystem.out.println( getName() + \"(\" );\n\t\t\tIterator<Dir> iterator = dirs.iterator();\n\t\t\twhile( iterator.hasNext() ) {\n\t\t\t\tDir dir = iterator.next();\n\t\t\t\tdir.print();\n\t\t\t\tif( iterator.hasNext() ) {\n\t\t\t\t\tSystem.out.println(\",\\t\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\")\");\n\t\t}\n\t\t@Override\n\t\tpublic List<Dir> getFiles() {\n\t\t\treturn dirs;\n\t\t} \n\t}\n\t\n\t// 表示文件的类\n\tpublic class File extends Dir {\n\t\tpublic File(String name) {\n\t\t\tsuper(name);\n\t\t}\n\t\t@Override\n\t\tpublic void addDir(Dir dir) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"文件类不能作为文件夹类来使用，即文件不支持添加也不支持删除\");\n\t\t}\n\t\t@Override\n\t\tpublic void rmDir(Dir dir) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"文件类不能作为文件夹类来使用，即文件不支持添加也不支持删除\");\n\t\t\t}\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"文件类不能作为文件夹类来使用，即文件不支持添加也不支持删除\");\n\t\t}\n\t\t@Override\n\t\tpublic void print() {\n\t\t\tSystem.out.println(getName());\n\t\t}\n\t\t@Override\n\t\tpublic List<Dir> getFiles() {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"文件类不能作为文件夹类来使用\");\n\t\t} \n\t}\n\t\n\t// 客户端实现\n\tpublic class Client {\n\t\tpublic static void main(String[] args) {\n\t\t\t// 构造一个目录对象表示 C 盘根目录\n\t\t\tDir diskC = new Folder(\"C\");\n\t\t\t// C 盘根目录下有一个文件 FileLog.txt\n\t\t\tdiskC.addDir( new File(\"Filelog.txt\") );\t\n\t\t\t// C 盘根目录下有3个子目录 windows、perflogs 和 Program File\n\t\t\tDir dirWin = new File(\"windows\");\n\t\t\tDir dirPerf = new File(\"perflogs\");\n\t\t\tDir dirProg = new File(\"Program File\");\n\t\t\t// windows 目录下有文件 explorer.exe\n\t\t\t// perflogs 目录下有文件 perflogs.txt\n\t\t\t// Program File 目录下有文件 syslogs.txt\n\t\t\tdirWin.addDir( new File(\"explorer.exe\") );\n\t\t\tdirPerf.addDir( new File(\"perflogs.txt\") );\n\t\t\tdirProg.addDir( new File(\"syslogs.txt\") );\n\t\t\n\t\t\tdiskC.add(dirWin);\n\t\t\tdiskC.add(dirPerf);\n\t\t\tdiskC.add(dirProg);\t\t\n\t\t\tdiskC.print();\n\t\t}\n\t}\n\t```\n\n#### 总结\n- 组合模式与解释器模式有一定的类同，两者在迭代对象时都涉及递归的调用，但组合模式所提供的属性层次结构使我们能 `一视同仁` 对待单个对象的对象集合。\n- 组合模式的优点  \n\t- 清楚定义分层次的复杂对象，表示对象的全部或部分层次，让高层模块忽略了层次差异，方便对整个层次结构进行控制。  \n\t- 高层模块可一致地使用一个组合结构或其中单个对象。  \n\t- 在组合模式中增加新的枝干结构和叶子构件很方便，无须对类库进行修改。  \n\t- 通过叶子对象和枝干对象的递归组合，形成复杂的树形结构，但对其控制却非常简单。\n- 组合模式的缺点  \n\t- 新增构件时，不好对枝干中的构件类型进行限制，不能依赖类型系统来施加这些约束，因为大多数情况下他们来自相同的抽象层。  \n\t- 因此必须进行类型检查来实现。\n\t\n### 适配器模式\n#### 适配器模式的介绍\n- ListView、GirdView、RecyclerView 都需要使用 Adapter。\n- 两个没有关系的类型之间交互，一种解决方法是修改各自类接口，另一种则是使用一个 Adapter。在两种接口间创建一个 “混血儿” 接口，将两接口兼容。\n\n#### 适配器模式的定义\n- 把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法一起工作的两个类能一起工作。\n\n#### 适配器模式的使用场景\n- 系统需要使用现存类，而此类接口不符系统需求，即接口不兼容。\n- 需一个统一的输出接口，而输入端的类型不可预知。\n\n#### 适配器模式的 UML 类图\n- 适配器模式也分两种，即类适配器模式和对象适配器模式。\n\t- 类适配器模式，如图 2-41 所示。\n\n\t\t![类适配器的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-41.svg)\n\t\t<center>图 2-41 类适配器的 UML 类图</center>\n\n\t\t目标接口需要的是 operation2()，而 Adaptee 对象中有一个 operation3()，因此不兼容。故通过 Adapter 实现一个 operation2() 将 Adapter 的 operation3() 转换为 Target() 需要的 operation2()。\n\n\t- 对象适配器模式，如图 2-42 所示。\n\n\t\t![对象适配器的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-42.svg)\n\t\t\n\t<center>图 2-42 对象适配器的 UML 类图</center>\n\t\n\t这种实现方式直接将要被适配的对象传递到 Adapter 中，使用组合的形式实现接口兼容的效果。即带来的好处有，在被适配的对象中不暴露方法细节；且相对类适配器，由于继承了被适配对象，在 Adapter 类中出现一些奇怪接口。因此对象适配器模式的实现更加灵活。\n\n#### 适配器模式的简单示例\n- 以电源适配器为例，分别以类适配器和对象适配器模式阐述具体情况。\n\t- 5V 电压是 Target 接口。\n\t- 220V 电压是 Adaptee 类。\n\t- 将电压 220V 转换到 5V 是 Adapter 类。 \n\n\t```Java\n\t/* 以类适配器模式实现 */\n\t\n\t// Target 角色\n\tpublic interface FiveVolt {\n\t\tpublic int getvolt5();\n\t}\n\t// Adaptee 角色，需被转换的对象\n\tpublic class Volt220 {\n\t\tpublic int getVolt220(){\n\t\t\treturn 220;\n\t\t}\n\t}\n\t// Adapter 角色，将 220V 的电压转换为 5V 电压\n\tpublic class VoltAdapter extends Volt220 implements FiveVolt {\n\t\t@OVerride\n\t\tpublic int getVolt5() {\n\t\t\treturn 5;\n\t\t}\n\t}\n\t\n\t// 客户端实现\n\tpublic class Test {\n\t\tpublic static void main(String[] args) {\n\t\t\tVoltAdapter adpter = new VoltAdapter();\n\t\t\tSystem.out.println(输出电压：adapter.getVolt5);\n\t\t}\n\t}\n\t\n\t/* 以对象适配器模式实现 */\n\t\n\t// Target 角色\n\tpublic interface FiveVolt {\n\t\tpublic int getvolt5();\n\t}\n\t\n\t// Adaptee 角色，需被转换的对象\n\tpublic class Volt220 {\n\t\tpublic int getVolt220(){\n\t\t\treturn 220;\n\t\t}\n\t}\n\t\n\t// Adapter 角色，将 220V 的电压转换为 5V 电压\n\tpublic class VoltAdapter implements FiveVolt {\n\t\tVolt220 mVolt220;\n\t\tpublic VoltAdapter(Volt220 adaptee) {\n\t\t\tmVolt220 = adaptee;\n\t\t}\n\t\tpublic int getVolt220() {\n\t\t\treturn mVolt220.getVolt220();\n\t\t}\n\t\t@OVerride\n\t\tpublic int getVolt5() {\n\t\t\treturn 5;\n\t\t}\n\t}\n\t\n\t// 客户端实现\n\tpublic class Test {\n\t\tpublic static void main(String[] args) {\n\t\t\tVoltAdapter adpter = new VoltAdapter( new Volt220() );\n\t\t\tSystem.out.println(输出电压：adapter.getVolt5);\n\t\t}\n\t}\n\t```\n\n#### 总结\n- 适配器模式的优点  \n\t- 更好的复用性：系统需使用现有的类，而此类的接口不符系统需求，则通过适配器模式可让这些功能得到更好的复用。  \n\t- 更好的扩展性。  \n- 适配器模式的缺点：若可对系统重构尽可能不使用适配器，过多使用适配器容易让系统凌乱，不易整体把握。\n\n### 装饰模式\n#### 装饰模式的介绍\n- 又称为 `包装模式`，结构性设计模式。\n- 使用一种对客户端以透明方式来动态扩展对象的功能，同时它也是继承关系的一种替代方案。\n\n#### 装饰模式的定义\n- 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式相比生成子类更为灵活。\n\n#### 装饰模式的使用场景\n- 需要透明地、动态地扩展类的功能时，装饰模式不失一种理想方案。\n\n#### 装饰模式的 UML 类图\n- 装饰模式的 UML 类图如图 2-43 所示。\n\n\t![装饰模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-43.svg)\n\t<center>图 2-43 装饰模式的 UML 类图</center>\n\n\t- **Component 抽象组件**：可以是一个接口或者抽象类，充当被装饰的原始对象。\n\t- **ConcreteComponent 组件具体实现类**：该类是 Component 类的基本实现，也是我们装饰的具体对象。\n\t- **Decorator 抽象装饰者**：其承担的职责是为了装饰我们的组件对象，其内部一定要有一个指向组件对象的引用。\n\t- **ConcreteDecorator 抽象装饰者**：对抽象装饰者做出具体实现。\n\n- 装饰模式的简单代码实现：\n\n\t```Java\n\t// 抽象组件类\n\tpublic abstract class Component {\n\t\t/**\n\t\t * 抽象的方法：自由增加你需要的抽象方法\n\t\t */\n\t\tpublic abstract void operate();\n\t}\n\t\n\t// 组件具体实现类\n\tpublic class ConcreteComponent extends Component {\n\t\t@Override\n\t\tpublic void operate() {\n\t\t\t// 忽略实现细节\n\t\t}\n\t}\n\t\n\t// 抽象装饰者\n\tpublic abstract class Decorator extends Component {\n\t\tprivate Component component; // 持有一个 Component 对象的引用\n\t\t/**\n\t\t * 必要的构造方法，需要一个 Component 类型的对象\n\t\t * @param component Component 对象\n\t\t */\n\t\tpublic Decorator(Component component) {\n\t\t\tthis.component = component;\n\t\t}\n\t\t@Override\n\t\tpublic void operate() {\n\t\t\tcomponent.operate();\n\t\t}\n\t}\n\t\n\t// 装饰者具体实现类\n\tpublic class ConcreteDecoratorA extends Decorator {\n\t\tprotected ConcreteDecoratorA(Component component) {\n\t\t\tsuper(component);\n\t\t}\n\t\t@Override\n\t\tpublic void operate() {\n\t\t\toperateA();\n\t\t\tsuper.operate();\n\t\t\toperateB();\n\t\t}\n\t\tpublic void operateA() { // 自定义的装饰方法 A\n\t\t\t// 装饰方法逻辑\n\t\t}\n\t\tpublic void operateB() { // 自定义的装饰方法 B\n\t\t\t// 装饰方法逻辑\n\t\t}\n\t}\n\t\n\t// 客户端实现\n\tpublic class Client {\n\t\tpublic static void main(String[] args) {\n\t\t\t// 构造被装饰的组件对象\n\t\t\tComponent component = new ConcreteComponent();\t\t\n\t\t\t// 根据组件对象构造装饰者对象并调用，即给组件对象增加装饰者的功能方法\n\t\t\tDecorator.decoratorA = new ConcreteDecoratorA(component);\n\t\t\tdecoratorA.operate();\n\t\t\tDecorator.decoratorB = new ConcreteDecoratorB(component);\n\t\t\tdecoratorB.operate();\n\t\t}\t\n\t}\n\t```\n\n#### 总结\n- 装饰模式与代理模式的区别 (容易混淆)\n\t- 装饰模式：以对客户端透明的方式 `扩展对象的功能`，即 `继承关系` 的一种 `替代方案`。\n\t- 代理模式：给一个对象提供一个代理对象，并由 `代理对象` 来控制对原有对象引用。 \n\n### 享元模式\n#### 享元模式的介绍\n- 又称 FlyWeight，代表轻量级的意思，结构型设计模式。\n- `对象池` 的一种实现。\n- 享元模式用来是尽可能减少内存使用量，它适用于可能存在大量重复对象的场景。  \n\t\n\t> 目的：缓存可共享的对象，达到对象共享，避免过多创建对象，即提升性能、避免内存移除。\n\n- 享元对象\n\t- 内存状态：可共享，不随环境变化\n\t- 外部状态：不可共享，随环境变化\n\t- 对象容器：在经典的享元模式中，对象容器为一 Map，它的 `键` 是享元对象的 `内部状态`，它的 `值` 是 `享元对象本身`。\n\n- 客户端通过这个内部状态从享元工厂中获取享元对象，若有缓存则使用缓存对象，否则创建一个享元对象并存入容器中。\n\n#### 享元模式的定义\n- 使用共享对象可有效地支持大量的细粒度的对象。\n\n#### 享元模式的使用场景\n- 系统中存在大量的 `相似对象`。\n- 细粒度的对象都具备较接近的外部状态，且内部状态与环境无关，即对象没有特定身份。\n- 需要 `缓冲池` 的场景。\n\n#### 享元模式的 UML 类图\n- 享元模式的 UML 类图如图 2-44 所示。\n\n\t![享元模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-44.svg)\n\t\n\t<center>图 2-44 享元模式的 UML 类图</center>\n\n#### 享元模式的简单示例\n- 例1. 过年回家买火车票，无数人在客户端上订票 (有多次购票、刷票的情况)，即不断向服务端发送请求。\n\t- 而每次查询，服务器必须做出回应，具体地，用户查询输入出发地和目的地，查询结构返回值只有一趟列车的车票。而数以万计的人有同样需求，即不间断请求数据，每次重新创建一个查询的车票结果，即造成大量重复对象创建、销毁，使得服务器压力加重。\n\t- 享元模式正好适合解决该情形的问题，例如 A 到 B 地的车辆是有限的，车上铺位分硬卧、软卧和坐票三种，将这些可公用的对象缓存起来。用户查询时优先使用缓存，反之则重新创建。\n\n- 便于理解，本示例的 UML 类图如图 2-45 所示。\n\n\t![网上订票系统的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-45.svg)\n\t\n\t<center>图 2-45 网上订票系统的 UML 类图</center>\n\t\n- 本示例的代码实现：\n\n\t```Java\n\tpublic interface Ticket {\n\t\tpublic void showTicketInfo(String bunk);\n\t}\n\t\t\n\t// 火车票\n\tpublic class TrainTicket implements Ticket {\n\t\tpublic String from; // 始发地\n\t\tpublic String to; // 目的地\n\t\tpublic String bunk; // 铺位\n\t\tTrainTicket(String from, String to) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t}\n\t\t@Override\n\t\tpublic void showTicketInfo(String bunk) {\n\t\t\tprice = new Random().nextInt(300);\n\t\t\tSystem.out.println(\"From:\" + from\n\t\t\t\t+ \"To:\" + to\n\t\t\t\t+ \"Bunk:\" + bunk\n\t\t\t\t+ \"Price:\" + price);\n\t\t}\n\t}\n\t\n\tpublic class TicketFactory {\n\t\tstatic Map<String, Ticket> sTicketMap = \n\t\t\tnew ConcurrentHashMap<String, Ticket>();\n\t\tpublic static Ticket getTicket(String from, String to) {\n\t\t\tString key = from + \"-\" + to;\n\t\t\tif( sTicketMap.containsKey(key) ) { // 使用缓存\n\t\t\t\treturn sTicketMap.get(key);\n\t\t\t} else { // 创建对象\n\t\t\t\tTicket ticket = new TrainTicket(from, to);\n\t\t\t\tsTicketMap.put(key, ticket);\n\t\t\t\treturn ticket;\n\t\t\t}\n\t\t}\n\t}\n\t```\n\t\n- 例2. 我们知道 Java 中 String 是存在于常量池中，即一个 String 被定义之后它就被缓存到了常量池中，当其他地方使用同样的字符串，则直接使用缓存，而非创建。\n\n\t```Java\n\tpublic void testString() {\n\t\tString str1 = \"Hello World\";\n\t\tString str2 = new String(\"Hello World\");\n\t\tString str3 = \"Hello \" + \"World\";\n\t\tSystem.out.println( \"\\nStr1 - Str3: \" + str1.equals(str3)\n\t\t\t+  \"\\nStr2 - Str3: \" + str2.equals(str3)\n\t\t\t+  \"\\nStr1 - Str2: \" + str1.equals(str1));\n\t\n\t\t// 输出的结果分别是：true，false，false\n\t}\n\t```\n\n#### 总结\n- 享元模式的优点：大幅度地降低内存中对象的数量。\n- 享元模式的缺点  \n\t- 为了使对象可共享，需将一些状态外部化，使程序的逻辑复杂化。  \n\t- 将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。  \n\n### 外观模式\n#### 外观模式的介绍\n- 又称门面模式 （Facade 模式），结构型设计模式。\n- 通过一个外观类使得整个系统中接口只有一个 `统一的高层接口`，即这样降低用户使用成本，也对用户屏蔽了很多实现细节。\n- 外观模式是 `封装API` 的常用手段。\n\n#### 外观模式的定义\n- 要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。\n- 外观模式提供一个高层次接口，使得子系统更易于使用。\n\n#### 外观模式的使用场景\n- 为一个复杂的子系统提供一个简单接口。\n\n\t> 对于系统进行定制、修改，这种易变性，使得隐藏子系统的具体实现变得尤为重要，对外隐藏子系统的具体实现，隔离变化。\n\n- 构建一层次结构的子系统，子系统间相互依赖，则通过 Facade 接口进行通信，从而简化他们的依赖关系。\n\n#### 外观模式的 UML 类图\n- 外观模式的 UML 类图如图 2-46 所示。\n\n\t![外观模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-46.svg)\n\t\n\t<center>图 2-46 外观模式的 UML 类图</center>\n\n#### 总结\n- 外观模式的精髓在于 `封装`。通过一高层次结构为用户提供统一的 API 入口，使得用户通过一个类就基本能够操作整个系统。\n- 外观模式的优点  \n\t- 对客户端隐藏子系统细节，因而减少客户对于子系统的耦合。  \n\t- 外观类对子系统的接口封装，使得系统更易于使用。  \n- 外观模式的缺点：外观类没有遵循开闭原则，当业务出现变更时，可能需要直接修改外观类。\n\n### 桥接模式\n#### 桥接模式的介绍\n- 又称桥梁模式，结构型设计模式。\n- 承接者连接 `两边` 的作用，两边指 `抽象部分` 和 `实现部分`。\n\n#### 桥接模式的定义\n- 将 `抽象部分` 和 `实现部分` 分离，使它们都可以独立地进行变化。\n\n#### 桥接模式的使用场景\n- 对于不希望使用继承或因多层次继承导致系统类的个数急剧增加的系统，考虑使用桥接模式。\n- 需要在构件的抽象化角色和具体角色之间增加更多灵活性，避免两层次间建立静态的继承关系，可通过桥接模式使它们在抽象层建立一个关联关系。\n- 一个类存在两个独立变化的维度，且这两个维度都需进行扩展。\n- 任何多维度变化类或多个树状类之间的耦合可通过桥接模式解耦。\n\n#### 桥接模式的 UML 类图\n- 桥接模式的 UML 类图如图 2-47 所示。\n\n\t![桥接模式的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-47.svg)\n\t<center>图 2-47 桥接模式的 UML 类图</center>\n\n\t- **Abstraction 抽象部分**：该类保持一个对实现部分对象的引用，抽象部分中的方法需要调用实现部分的对象来实现。该类一般为抽象类。\n\t- **RefinedAbstraction 优化的抽象部分**：抽象部分的具体实现，该类一般是对抽象部分的方法进行完善和扩展。\n\t- **Implementor 实现部分**：可以为接口或抽象类，其方法不一定要与抽象部分中的一致，一般情况下是由实现部分提供基本的操作，而抽象部分定义的则是基于实现部分这些基本操作的业务方法。\n\t- **ConcreteImplementorA/B 实现部分的具体实现**：完成实现部分中定义的具体逻辑。\n\n- 桥接模式的简单代码实现：\n\n\t```Java\n\t// 实现部分的抽象接口\n\tpublic interface Implementor {\n\t\t// 实现抽象部分的具体方法\n\t\tpublic void operationImpl();\n\t}\n\t\n\t// 实现部分具体的实现\n\tpublic class ConcreteImplementorA implements Implementor {\n\t\t@Override\n\t\tpublic void operationImpl() {\n\t\t\t// 忽略实现逻辑\n\t\t}\n\t}\n\t\n\t// 抽象部分\n\tpublic abstract class Abstraction {\n\t\t// 声明一私有成员变量引用实现部分的对象\n\t\tprivate Implementor mImplementor; \n\t\t/**\n\t\t * 通过实现部分对象的引用构造抽象部分的对象\n\t\t * @param implementor 实现部分对象的引用\n\t\t */\n\t\tpublic Abstraction(Implementor implementor) {\n\t\t\tmImplementor = implementor;\n\t\t}\n\t\t// 通过调用实现部分具体的方法实现具体的功能\n\t\tpublic void operation() {\n\t\t\tmImplementor.operationImpl();\n\t\t}\t\n\t}\n\t\n\t// 优化的抽象部分\n\tpublic class RefinedAbstraction extends Abstraction {\n\t\tpublic RefinedAbstraction(Implementor implementor) {\n\t\t\tsuper(implementor);\n\t\t}\n\t\t// 对 Abstraction 中的方法进行扩展\n\t\tpublic void refinedOperation() {\n\t\t\t// 忽略实现逻辑\n\t\t}\n\t}\n\t\n\t// 客户端实现\n\tpublic class Client {\n\t\tpublic static void main(String[] args) {\n\t\t\tRefinedAbstraction abstration = \n\t\t\t\tnew RefinedAbstraction( new ConcreteImplementorA );\n\t\t\tabstraction.operation();\n\t\t\tabstraction.refinedOperation();\n\t\t}\n\t}\n\t```\n\n#### 桥接模式实战\n- View 的视图层级与执行真正的硬件绘制相关类之间的关系可看作是一种桥接模式。即模仿这种行为，我们可自定义控件以桥接的方式提供多种不同的实现机制。\n- 以进度条为例，我们可继承 View 类来实现进度条控件，自定义水平、垂直和圆形等不同形式的进度条。\n- 便于理解，本示例的 UML 类图如图 2-48 所示。\n\n\t![进度条框架的UML类图](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-48.svg)\n\t\n\t<center>图 2-48 进度条框架的 UML 类图</center>\n\n#### 总结\n- 桥接模式，分离抽象与实现，其优点毋庸置疑，即灵活的扩展以及对客户来说透明的是实现。但不足之处在于运用桥接模式进行设计，是有一定难度的，需多加推敲与研究。\n\n## 叁 MVC 与 MVP 模式\n### MVC\n![MVC模式的三个角色](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_3-2.svg)\n<center>图 3-2 MVC模式的三个角色</center>\n\n- 模型-视图-控制器 (Model-View-Controller，MVC)：是一种 `框架模式` ，而非设计模式。\n\n\t> GOF 把 MVC 看作 3 种设计模式，即观察者模式、策略模式与组合模式的合体，也就是一个基于 `发布/订阅者模型` 的框架。\n\n- 软件开发领域的 3 种级别重用：\n\t- 内部重用：同一应用中能公共使用的抽象块。\n\t- 代码重用：将通用模块组合成库或工具集，以便在多个应用和领域都能使用。\n\t- 应用框架重用：为专用领域提供通用的或者现成的基础结构，以获得最高级别的重用性。\n\n\t> 平时开发过程中，常见的框架模式除了 MVC 外，还有 MVVC、MTV、CBD、ORM 和 MVP。\n\n- MVC 模式的优点：表现层与业务层分离实现，各司其职。若在实际项目中，即前端工程师专注界面的研发，后端工程师致力于业务逻辑。\n- MVC 模式的缺点：  \n\t- Model 和 View 严格分离，在调试应用程序时较困难。  \n\t- 小规模项目采用 MVC 模式反而显得工序更加繁琐。  \n\t\n### MVP\n![MVP模式的三个角色](/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_3-1.svg)\n<center>图 3-1 MVP模式的三个角色</center>\n\n- 数据存取-用户界面-交互中间人 (Model-View-Presenter，MVP)：分离显示层和逻辑层，它们之间通过接口进行通信，降低耦合。\n- MVP 模式的三个角色\n\t- **Presenter 交互中间人**：View 和 Model 沟通的桥梁。它从 Model 层检索数据后，返回给 View 层，使得 View 和 Model 之间没有耦合，也将业务逻辑从 View 角色上抽离。\n\t- **View 用户界面**：在 Android 中，通常指 Activity、Fragment 或某个 View 控件，它含有一个 Presenter 成员变量，且 View 需实现以逻辑接口。将 View 上操作通过转交给 Presenter 实现，最后 Presenter 调用 View 逻辑接口将结果返回给 View。 \n\t- **Model 数据的存取**：主要提供数据的存取功能。Presenter 需通过 Model 层存储、获取数据。\n\n- 区别于 MVC 模式：MVC 的主要特点  \n\t- 1) 用户可向 View 发送指令，再由 View 直接要求 Model 改变状态。  \n\t- 2) 用户可向 Controller 发送指令，再由 Controller 发送给 View。  \n\t- 3) Controller 起到时间路由的作用，同时业务逻辑都部署在 Controller 中。  \n\n\t> View 可直接访问 Model，即 MVC 模式的耦合性还是相对较高的。","tags":["UML","Android","Java","设计模式"],"categories":["Reading"]},{"title":"零成本：基于 Hexo 在 Github 上搭建博客","url":"/2018/01/Hexo-Installation-Guide.html","content":"\nHexo $^{[1]}$，一个快速、简洁且高效的博客框架，若以个人博文为主导需求，它的强大毋庸置疑。    \n\nHexo 支持 GitHub Flavored Markdown 的所有功能；且基于 Node.js 所带来的超快生成速度，百页博文秒级渲染；开放性 API 以及丰富的插件等，即功能来得纯粹，不失个性化定制，上手容易且操作便捷。更重要的一点，它是开源的、免费的博客框架，数据保存在本地以及 Github 上，相信在众多博客产品中选择、博弈，相信 Hexo 的表现不会令你失望。\n\n对于 Hexo 的安装、使用教程尽量遵照官方使用文档的流程操作，而本文则将侧重于 Hexo 的优化体验、实用插件等方面的内容分享。\n\n若想了解详情可访问「[hexo.io](https://hexo.io/)」。\n\n<!-- more -->\n\n## 更新进程\n- 2018.01.22：完成文章初稿；\n- 2018.10.25：纠正有纰漏的地方，并重新排版；\n\n## 壹 搭建环境\n- Mac OS、Windows 环境下的配置流程和步骤大同小异，而搭建环境的大致流程为：  \n\t- Git 环境配置 ( Windows 平台需要配置 )；\n\t- Node.js 环境配置；\n\t- Github 账号注册和配置；\n\t- Hexo 的安装和配置.\n- 考虑到是流程操作类的文章，为简单起见，则我们以 MacOS 和 Windows 版本分别说明情况：\n\t- [MacOS 版本](#MacOS-版本)\n\t- [Windows 版本](#Windows-版本)\n\n### MacOS 版本\n#### 配置环境\n\n-  `Xcode` : Hexo 的编译依赖于 Xcode，故我们得在 Mac 上安装 Xcoce。\n\t- Xcode 可自行到 `Apple App Store` 下载、安装。\n\t- 启动 Xcode 并进入 Preferences -> Download -> Command Line Tools -> Install 安装命令行工具。\n\t\n-  `Node.js` : Hexo 是基于 Node.js 开发的，即得配置 Hexo 的运行环境。\n\t- Node.js：[官方下载](https://nodejs.org/)；\n\t- 本地安装，文件包为 `Node-Vx.x.x.pkg`\n\t- 检测是否安装成功，当然返回版本信息即成功安装..\n\n\t\t```bash\n\t\t# 终端下输入命令:  \n\t\tnode -v  \n\t\tnpm -v\n\t\t```\n\n- `Github` 账户注册与建立 `Repository`：\n\n\t> 已有账号、项目可忽略此步骤，但注意代码库的配置属性。\n\t\n\t- 注册账号：[GitHub 社区注册入口](https://github.com/) ；\n\t- 创建代码库：\n\t\t- Step.01. `Add ( 右上角「+」图标 ) -> New Repository`；  \n\t\t- Step.02. Repository Name，填写 `yourname.github.io`；        \n\t\t- Step.03. Repository Description，填写`简单描述`.\n\n\t- 配置代码库：\n\t\t- Step.01. 进入项目 `yourname.github.io`；  \n\t\t- Step.02. `Settings -> GitHub Pages`，开启 `GH-Pages` 功能；  \n\t\t- Step.03. 点击 `Launch Automatic Page Generator`.\n\n\t\t\t> Github 将会自动替你创建出一个 `GH-Pages` 的页面。若配置没有问题，约15分钟后，`yourname.github.io` 就可以正常访问了，配置结束。\n\t\n#### 安装 HEXO\n##### 安装 HEXO\n- 本地选择安装目录：\n\n \t```bash\n \tcd your-hexo-site \n \t```\n\n- 在线安装 HEXO ( [NPM淘宝源](http://npm.taobao.org/) )：\n\n\t```bash\n\tnpm install hexo-cli -g  \n\thexo init  \n\thexo install\n\t```\n\t\n- 检测是否安装成功，当然返回版本信息即成功安装：\n\n \t```bash\n \thexo -v\n \t```\n\n##### 运作 HEXO \n- 本地运作 HEXO：\n\n\t```bash\n\thexo server # 或简写 hexo s\n\t```\n\n- 当终端提示以下信息，则本地配置工作基本完成：\n\n\t> Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.\n\n##### 使用 HEXO\n\n> 注意：此项操作，需要确保在 Hexo 安装目录下执行。\n\n- 新建一篇博文 ( 当然，更新过往的文章只需修改 `Hexo -> Source -> _Posts` 目录下相对应的 MarkDown 文件即可 )\n\n\t```bash\n\thexo new post \"Article Title\"\n\t```\n\t\n- 生成博文 ( 生成静态网页 )\n\n\t```bash\n\thexo generate\n\t```\n\n##### 部署至 GitHub\n- 部署至 Git 的准备工作：\n\n\t```bash\n\t# 在部署前，还需要安装「Git部署插件」:  \n\tnpm install hexo-deployer-git --save\n \n\t# 若没有安装该插件，会出现情况：\n\t# deloyer not found:git\n\t```\n\n- 再者，与 Github 连接前需要获得授权，不然会出现以下情况 ( 本机没有配置 Public Key ):\n  \n\t> Permission denied (publickey).  \n\t> fatal: Could not read from remote repository.  \n\t> Please make sure you have the correct access rights and the repository exists.\n\t\n- 配置 `SSH KEY / Public KEY` ( [RSA 认证](https://zh.wikipedia.org/wiki/RSA加密演算法) )：\n\n\t> [注意] 若之前机器上配置了 Git 的信息，请跳过该步骤。\n  \n\t```bash\n\t# 1. 配置 Git 的 UserName 和 Email \n\t# “YourAnonymousName\"，可以替换成自己的用户名   \n\tgit config --global user.name \"YourAnonymousName\"  \n\t# \"UserName@xxx.com\"，替换成自己的邮箱  \n\tgit config --global user.email \"UserName@xxx.com\"  \n\t\n\t# 2. 检查是否已经有 SSH KEY\t \n\t# Step01. 列出该目录下的文件；\n\t# Step02. 看是否存在「id_isa」和「id_isa.pub」文件；\n\tcd ~/.ssh\n\tls\n\t \n\t# Step03. 若存在则跳过，没有则执行此步骤「生成密钥」.\n\t# 邮箱「UserName@xxx.com」替换成自己的邮箱\n\tssh-keygen -t rsa -C \"UserName@xxx.com\"\n\t\t\n\t# 3. 登陆 Github, 添加 SSH KEY\n\t# Step01. Avatar(头像) > Settings > Personal Settings > SSH and GPG keys； \n\t# Step02. New SSH KEY，把「id_isa.pub」的密钥粘贴过去即可.  \n\t \n\t# 4. 测试是否配置成功\t\n\tssh -T git@github.com\n\t# 提示「Hi YourName! You've successfully authenticated, but GitHub does not provide shell. access.」即成功配置。\n\t```\n\n- 配置 `_config.yml` 文件 ：\n\n\t- 在 Hexo 安装目录下找到 `_config.yml` 文件，如 `~/你的安装目录/Hexo/_config.yml`。找到 `deploy` 字段，修改配置。\n\n\t```bash\n\tdeploy:  \n\ttype: git  \n\trepo: https://github.com/yourname/yourname.github.io.git  \n\tbranch: master \n\t```\n\n\t- 注意: 冒号后面含一个空格；使用 Github 不用 branch 字段；若使用多个 deployer，则有：\n\t\n\t```bash\n\tdeploy:\n\t- type: git\n\t  repo:\n\t- type: heroku \n\t  repo:\n\t```\n\n- 部署至 Git：\n\n\t```bash\n\thexo deploy\t  \n\thexo d -g # 即在部署之前先生成\n\t```\n\n### Windows 版本\n#### 配置环境\n\n> Github 账号注册和配置和 Hexo 的安装和配置，在 Windows 与 MacOS 上是通用的。因此，在 Windows 版本中，主要阐述 Node.Js和 Git 的安装和配置即可。\n\n- `Node.js` 的安装和准备：\n\t- 下载并安装：[Node.Js for Windows x86/x64 bit](https://nodejs.org/en/download/)。\n\t- 检测是否安装成功，当然返回版本信息即成功安装。\n\n\t```bash  \n\tnode -v  \n\tnpm -v\n\t```\n\t\n- Git 的安装和准备：\n\t- 下载并安装：[Git for Windows x86/x64 bit](https://git-scm.com/download/win)。\n\t- 检测是否安装成功，当然返回版本信息即成功安装。\n\n\t```bash \n\tgit --version\n\t```\n\n## 贰 优化拓展\t\n至此，Hexo 的安装以及 GitHub 的配置工作暂告一段落。能正常运行使用 Hexo 是没问题的，而下面的章节则是对 Hexo 的扩展和个性化定制，根据自己的需求挑选阅读、实践。\n\n### 套用一款主题\n\n- Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。\n\n- 在 Hexo 中有 `两份` 主要的 `配置文件`，其名称都是 `_config.yml`。 其中，一份位于 `站点根目录` 下，主要包含 Hexo 本身的配置；另一份位于 `主题目录` 下，这份配置由主题作者提供，主要用于配置主题相关的选项。\n\n\t为了描述方便，在以下说明中，将前者称为 `站点配置文件`， 后者称为 `主题配置文件`。具体以 NexT $^{[2]}$ 为例说明，安装步骤如下。\n\n#### 下载主题  \n\n- 如果你熟悉 Git， 建议你使用 `克隆最新版本` 的方式，之后的更新可以通过 `git pull` 来快速更新， 而不用再次下载压缩包替换。\n\n\t```bash\n\t# 克隆最新版本\n\tcd your-hexo-site  \n\tgit clone https://github.com/iissnan/hexo-theme-next. themes/next\n\t\n\t# 快速更新\n\tcd themes/next\n\tgit pull\n\t```\n\n#### 启用主题  \n- 与所有 Hexo 主题启用的模式一样。 当 `克隆/下载` 完成后，打开 站点配置文件， 找到 `theme` 字段，并将其值更改为 `next`。\n\n\t```bash\n\ttheme: next\n\t```\n\n- 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 `hexo clean` 来清除 Hexo 的缓存。\n\n\t```bash\n\n \thexo clean\n \t```\n\n#### 主题设定\n\n##### 外观设定\n- 选择 `Scheme`：Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以在 Scheme 之间共用。目前 NexT 支持三种 Scheme：\n\n\t- `Muse`：默认 Scheme，黑白主调，大量留白。\n\t- `Mist`：Muse 的紧凑版本，整洁有序的单栏外观。\n\t- `Pisces`：双栏 Scheme，小家碧玉似的清新。\n\n\t```bash\n\t#scheme: Muse\n\t#scheme: Mist\n\tscheme: Pisces\n\t```\n\n\t> Scheme 的切换通过更改 `主题配置文件`，搜索 `scheme` 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 `#` 去除即可。\n\t\n##### 设置语言\n- 设置语言：编辑`站点配置文件`， 将 `language` 设置成你所需要的语言，例如 `language: zh-Hans `。建议明确设置你所需要的语言，例如选用简体中文，配置如下 ( 更多请语言配置请参考下述表格 )：\n\n| 语言 | 代码 | 设定示例 |\n| :---- | :---- | :---- |\n| English | en | language: en |\n| 简体中文 | zh-Hans\t| language: zh-Hans |\n| Français | fr-FR | language: fr-FR |\n| Português | pt | language: pt or pt-BR |\n| 繁體中文 | zh-hk | language: zh-hk |\n| Русский\t | язык\tru | language: ru |\n| Deutsch | de | language: de |\n| 日本語 | ja | language: ja |\n| Indonesian | id | language: id |\n| Korean | ko | language: ko |\n\n##### 设置菜单\n\n- 菜单配置包括三个部分，第一是菜单项 ( `名称和链接` )，第二是菜单项的 `显示文本`，第三是菜单项对应的 `图标`。\n\n- NexT 使用的是 [Font Awesome](http://fontawesome.io/) $^{[3]}$ 提供的图标，600+ 的图标可满足大部分需求，且适配 Retina 屏幕。\n\n- 编辑 `主题配置文件`，修改以下内容：\n\n\t{% note warning %} 请注意键值（ 如 `home` ）的大小写要严格匹配。 {% endnote %}\n\n\t- 设定菜单内容，对应的字段是 `menu`，菜单内容的设置格式是：`item name: link`。其中 `item name` 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。\n\n\t```bash\n\tmenu:\n\thome: /\n\tarchives: /archives\n\t#about: /about\n\t#categories: /categories\n\ttags: /tags\n\t#commonweal: /404.html\n\t\n\t# 若你的站点运行在子目录中，请将链接前缀的/去掉\n\t```\n\n\t- NexT 默认的菜单项有 ( 标注 `*` 的项表示需要手动创建这个页面 )：\n\n| 键值 | 设定值| 显示文本(简体中文) | \n| :--- | :--- | :--- |  \n| home | home: / | 主页 |  \n| archives | archives: /archives | 归档页 |  \n| categories | categories: /categories | 分类页 `*` |  \n| tags | tags: /tags | 标签页 `*` |  \n| about | about: /about | \t关于页面 `*` |  \n| commonweal | commonweal: /404.html\t | 公益 404 `*` |  \n\n- 设置菜单项的显示文本，在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用这个名称查找对应的语言翻译，并提取显示文本。\n\n\t 这些翻译文本放置在 NexT 主题目录下的 `languages/{language}.yml` （ {language} 为你所使用的语言 )。以简体中文为例，若你需要添加一个菜单项，比如 `something`。那么就需要修改简体中文对应的翻译文件`languages/zh-Hans.yml`，在`menu`字段下添加一项：\n\t\n\t ```bash\n\t menu:\n\t home: 首页\n\t archives: 归档\n\t categories: 分类\n\t tags: 标签\n\t about: 关于\n\t search: 搜索\n\t commonweal: 404\n\t something: 有料\n\t ```\n\n- 设定菜单项的图标，对应的字段是 `menu_icons`。\n\n\t ```bash\n\t menu_icons:\n\t enable: true\n\t # Icon Mapping.\n\t home: home\n\t about: user\n\t categories: th\n\t tags: tags\n\t archives: archive\n\t commonweal: heartbeat\n\t \n\t #  此设定格式是「item name: icon name」\n\t # 「item name」与上一步所配置的菜单名字对应\n\t # 「icon name」是 Font Awesome 图标的名字\n\t # 「enable」用于控制是否显示图标，你可以设置成「false」来去掉图标\n\t```\n\t\n#### 设置侧栏 \n- 可以通过修改 `主题配置文件` 中的 `sidebar` 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是 `侧栏的位置`， 其二是 `侧栏显示的时机`。\n\n- 设置侧栏的位置，修改 `sidebar.position` 的值，支持的选项有：\n\n\t> left - 靠左放置  \n\t> right - 靠右放置  \n\n\t目前仅 Pisces Scheme 支持 position 配置。影响版本 `5.0.0` 及更低版本。\n\n\t```bash\n\tsidebar:  \n\tposition: left\n\t```\n\n- 设置侧栏显示的时机，修改 `sidebar.display` 的值，支持的选项有：\n\n\t> post - 默认行为，在文章页面（ 拥有目录列表 ）时显示  \n\t> always - 在所有页面中都显示  \n\t> hide - 在所有页面中都隐藏（ 可以手动展开 ）  \n\t> remove - 完全移除  \n\n\t```bash\n\tsidebar:\n\tdisplay: post\n\t```\n\n\t 已知侧栏在 `use motion: false` 的情况下不会展示。影响版本 `5.0.0` 及更低版本。\n\t\n#### 设置头像\n- 编辑 `主题配置文件`， 修改字段 `avatar`，值设置成头像的链接地址。其中，头像的链接地址可以是：\n\n\t- 站外链接：`avatar: http://example.com/avatar.png`\n\t- 站内资源：放置在 `source/images/` 目录下，images 为自建目录，字段配置为 `avatar: /images/avatar.png`。\n\t\n### 揽收实用插件\n\n## 叁 参考资料\n\n[[1] HexoJs. 使用文档. 2018](https://hexo.io/docs/)  \n[[2] NexT. 使用文档. 2018](http://theme-next.iissnan.com/getting-started.html)  \n[[3] Dave Gandy. Font Awesome Accessibility](http://fontawesome.io/accessibility/)  \n[[4] 徐俊. 手把手教你搭建属于自己的博客. CSDN. 2017](http://blog.csdn.net/gdutxiaoxu/article/details/53576018) ","tags":["hexo"],"categories":["Project"]},{"title":"Java 快速上手教程","url":"/2017/09/Java-in-a-Nutshell.html","content":"\n由于对图灵出品的 O'Reilly 动物书情有独钟，至此本篇文章以动物书系列之 [Java 技术手册](https://book.douban.com/subject/26674131/) 为主要框架，开启我的 Java 语言学习旅程。\n\n当然，通读一遍本书之后，你会发现本书对 Java 基础知识部分的讲述一定是有所欠缺的，所以课后补充工作很有必要。如通过参考其他 Java 书籍（下文中有参考书目推荐）、优秀博文的补充，核心需求就是要输出一份便于常翻阅、可复用的读书笔记、学习笔记。\n\n需要说明的是，笔记当中会包含实际项目当中深入了解、研究的知识点，如 Class 类文件结构、Java 范型等。既经由分析、解决、随之文档化的过程，这不仅仅可作为自己的案例库，也可用于分享、交流。毕竟自身的知识面是非常有限的，有不恰当之处、不正确的地方，欢迎广大朋友的帮忙、斧正，互为补足。\n\n<!-- more -->\n\n> 参考书目\n\n- 基础篇：《 Java 技术手册 》:  O'Reilly 动物书系列，因本书籍不会刻意去阐述面向对象编程（Object Oriented Programming，OOP）的相关概念、内容，适合对 OOP、Java 编程语言有一定了解后，所使用的学习材料。\n- 进阶篇：《 Java编程思想 / Thinking in Java 》：待阅读。贴上本书豆瓣的书评，供朋友评判，做出抉择。[TIJ(中文第四版)](https://book.douban.com/subject/2130190/) | [TIJ(英文第四版)](https://book.douban.com/subject/2061172/)\n\n> 优秀博文\n\n- [ 索引 - 小土刀. Java 资源索引. 2012. wdxtub.com](http://wdxtub.com/2012/09/11/awesome-java/) \n- [ 索引 - Akullpp. Awsome Java. 2018. github.com](https://github.com/akullpp/awesome-java)\n- [ 规范 - BlankJ. Java / Android 开发规范. 2017. github.com](https://github.com/Blankj/AndroidStandardDevelop)\n- [ API - BieZhi. 30 Seconds Of Java8. 2018. github.com](https://github.com/biezhi/30-seconds-of-java8)\n\n> 开源项目\n\n- [ BieZhi. Awesome Java Leetcode. 2018. github.com](https://github.com/Blankj/awesome-java-leetcode) ( 学习数据结构和算法或打算刷 LeetCode 的伙伴们推荐阅读 )\n- [ CTOlib. Java 实战类库与框架. 2018. ctolib.com](https://www.ctolib.com/java/categoriesallsub.html)\n\n## 更新进程\n- 2017.09.01：整理 Notes 草稿；\n- 2017.09.14：输出 Markdown 文档；  \n- 2018.01.30：完成序言；\n- 2018.03.20：更新正文 ( 共 10 章 )；\n- 2018.04.30：更新完毕；\n- 2019.10.07：更新 Java 集合章节内容；删除第六章节的内容。\n\n## 内容总览\n- [壹 Java 环境介绍](#壹-Java-环境介绍)  \n- [贰 Java 基本句法](#贰-Java-基本句法)\n- [叁 Java 面向对象编程](#叁-Java-面向对象编程)\n- [肆 Java 类型系统](#肆-Java-类型系统)  \n- [伍 Java 的面向对象设计](#伍-Java-的面向对象设计)  \n- [陆 Java 实现内存管理和并发编程](#陆-Java-实现内存管理和并发编程)  \n- [柒 编程和文档约定](#柒-编程和文档约定)  \n- [捌 使用 Java 集合](#捌-使用-Java-集合)  \n- [玖 处理常见的数据格式](#玖-处理常见的数据格式)  \n- [拾 处理文件和 I/O](#拾-处理文件和-I-O)  \n- [拾壹 类加载、反射和方法句柄](#拾壹-类加载、反射和方法句柄)  \n\n## 壹 Java 环境介绍\n### JVM - 程序、环境\n- Java 虚拟机 (Java Virtual Machine，JVM)。\n- JVM 是一个程序，提供运行 Java 程序所需的运行时环境。\n- 应用代码的容器。\n- 提供一个安全、跨平台的执行环境。\n- Java 源码 -> Java 字节码 (*.class) -> JVM (即字节码格式程序的解码器，即图 1-1 中的解释器)。\n\n### Java 程序的生命周期\n- Java 代码的编译和加载：\n\t- 整个流程从 Java 源码开始，经过 `Javac` 程序处理后得到 `类文件`，类文件保存的是编译源码后得到的 Java 字节码。类文件是 Java 平台能处理的最小功能单位，也是把新代码传给运行中程序的唯一方式。\n\t- 新的类文件通过类加载机制载入虚拟机，从而把新类型提供给解释器执行。\n\t- Java 代码的编译和加载过程，如图 1-1 所示。\n\n\t\t![Java代码的编译和加载过程](/images/illustration/Programme/2017/09/Java_in_a_Nutshell_1-1.png)\n\t\t<center>图 1-1 Java 代码的编译和加载过程</center>\n\n- 其中，涉及了 `机器码` 与 `字节码` 的概念：\n\t- 机器码 (Machine Code)，学名机器语言指令，有时也被称为原生码 (Native Code)，是电脑的 CPU 可直接解读的数据。  \n\n\t\t> 通常意义上来理解的话，机器码就是计算机可以直接执行，并且执行速度最快的代码。\n\t\n\t- 字节码 (Bytecode)，是一种包含执行程序、由一序列 `数据对` 组成的二进制文件。字节码是一种中间码，它比机器码更抽象，需要直译器转译后才能成为机器码的中间代码。  \n\n\t\t- 通常情况下字节码通常不像源码一样可以让人阅读，而是编码后的数值常量、引用、指令等构成的序列。\n\t\t- 关于 `字节码文件`，即 Class 类文件，根据Java虚拟机规范的规定，Class 文件格式采用一种类似于 C 语言结构体的伪结构表示，如下述代码所示。    \n\t\t- 若想了解更多 Class 文件结构的内容，可参考周志明老师写的《深入理解Java虚拟机》\\\\(^{[1]}\\\\)，其中有对 Class 文件结构的详细介绍。\n\n\t\t\t> 延伸：其实每种类型的文件的头都有着 4 个字节的作用域，则把其称为 `魔数`，它的作用是唯一标识该文件所属类型。  \n\n\t\t\t```Java\n\t\t\tClassFile {  \n\t\t      u4 magic;  \n\t\t      u2 minor_version;  \n\t\t      u2 major_version;  \n\t\t      u2 constant_pool_count;  \n\t\t      cp_info constant_pool[constant_pool_count-1];  \n\t\t      u2 access_flags;  \n\t\t      u2 this_class;  \n\t\t      u2 super_class;  \n\t\t      u2 interfaces_count;  \n\t\t      u2 interfaces[interfaces_count];  \n\t\t      u2 fields_count;  \n\t\t      field_info fields[fields_count];  \n\t\t      u2 methods_count;  \n\t\t      method_info methods[methods_count];  \n\t\t      u2 attributes_count;  \n\t\t      attribute_info attributes[attributes_count];  \n\t\t\t}  \n\t\t\t```\n\t\t\t\n###  Java 和其他语言比较\n\n<center>表 1-1 Java 与 C 语言的区别</center>\n\n| Java | C    |\n| :--- | :--- |\n| Java 是面向对象的语言 | C 是面向过程的语言 |\n| 通过类文件实现可移植性 | C 需要重新编译实现移植 |\n| 没有指针 | 有指针 |\n| 垃圾回收提供了自动内存管理功能 | 无法从低层布局内存 (结构体) |\n\n<center>表 1-2 Java 与 PHP 语言的区别</center>\n\n| Java | PHP  |\n| :--- | :--- |\n| Java 是静态类型语言 | PHP 是动态类型语言 |\n| Java 支持多线程操作 | PHP 不支持多线程 |\n\n- 在本书中，关于静态语言与动态语言的区别，即在于编译时或是运行时 `检测错误`。\n\n\t> 对于类型系统的概念，众说纷纭，如何理解静态、动态类型语言，推荐知乎 [rainoftime](https://www.zhihu.com/question/19918532/answer/21647195) 的回答。 \n\n\t- `Program Errors`：  \n\t\t- `Trapped errors`：导致程序终止执行，例如：零为被除数、Java 数组越界访问。  \n\t\t- `Untrapped errors`：出错后继续执行，但可能出现任意行为。如 C 里的缓冲区溢出、Jump 到错误地址。\n\t\n\t- `Forbidden Behaviours`：语言设计时，可以定义一组 Forbidden behaviors，它必须包括所有 Untrapped errors，但可能包含 Trapped errors。\n\t\n\t- `Well behaved` 与 `ill behaved`：  \n\t\t- `well behaved`: 如果程序执行不可能出现 Forbidden behaviors, 则为 Well behaved。   \n\t\t- `ill behaved`: 否则为 ill behaved。  \n\n- 有了上面的概念，再讨论强、弱类型，静态、动态类型：\n\t- `强类型` (Strongly typed)：如果一种语言的所有程序都是 Well behaved，即不可能出现 Forbidden behaviors，则该语言为 Strongly typed。\n\t- `弱类型` (Weakly typed)：否则为 Weakly typed。譬如 C 语言的缓冲区溢出，属于 Trapped errors，即属于 Forbidden behaviors，故 C 是弱类型。 \n\t\n\t\t弱类型语言类型检查更不严格，如偏向于容忍隐式类型转换。譬如说 C 语言的 int 型可强转为 double 型。这样的结果是：容易产生 Forbidden behaviours，所以是弱类型的。\n\n\t- `静态类型` (Statically)：如果在 `编译时` 拒绝 ill behaved 程序，则是 Statically typed。\n\t- `动态类型` (Dynamiclly)：如果在 `运行时` 拒绝 ill behaviors, 则是 Dynamiclly typed。\n\n<center>表 1-3 Java 与 JavaScript 语言的区别</center>\n\n| Java | JavaScript (Js) |\n| :--- | :--- |\n| Java 是静态类型语言 | Js 是动态类型语言 |\n| Java 使用基于类的对象 | JS 使用基于原型的对象 |\n| Java 提供良好的对象封装 | -- |\n| Java 支持多线程操作 | Js 不支持多线程 |\n\n## 贰 Java 基本句法\n### 词法结构\n{% note success %} \n说明：词法结构的内容与 Java / Android 开发规范的内容有所交集，可参阅上述推荐的优秀博文：  \n[BlankJ. Java / Android 开发规范. 2017. github.com](https://github.com/Blankj/AndroidStandardDevelop)。\n{% endnote %}\n\n- Java 编码使用的是 Unicode 字符集。\n- 需要区分大小写与空白的情况：\n\t- 关键字使用小写 (class、interface、abstract、public、static 等)；\n\t- 函数、方法名称使用 `驼峰式命名法`；\n\t- `宏定义` 使用全大写字母的命名风格；\n- 注释：单行注释、多行注释和块注释：\n\n\t```java\n\t// 单行注释：注释的内容\n\n\t/* 多行注释：注释的内容 */\n\n\t/**\n\t * 块注释的风格：\n\t * 注释的内容 1\n\t * 注释的内容 2\n\t */\n\t```\n\n- 保留字：\n如 interface、class、public、private、protected、true、null 等，是不能单用来命名变量名称和类名称的。\n- 标识符：Java 程序中某个部分的名称，例如类、类中方法和方法中声明的变量。\n\t- 不能以数字开头；\n\t- 不能包含标点符号；\n\t- 可以使用货币符号 (¥或$)；\n\t\n\t\t> 货币符号主要用在自动生成的源码中，例如 Javac 生成的代码。不在标识符中使用货币符号，可避免自己的标识符和自动生成的标识符冲突。\n\t\n- 字面量：直接出现在 Java 源码中的值，包括：\n\t- 整数 `1`、浮点数 `3.141`；\n\t- 单引号字符 `'A'`、双引号字符 `\"Hello\"` ;\n\t- 保留字 `true、false、null`。\n\n### 基本数据类型\n\n| 类型  | 取值 | 默认值 | 大小 | 范围 |\n| :--- | :--- | :--- | :--- | :--- |\n| boolean | true/false  | false | 1 位 | NA |\n| char    | Unicode 字符 | \\u0000 | 16 位 | \\u0000 ~ \\uFFFF |\n| byte    | 有符号的整数  | 0 | 8 位 | [-128, 127] |\n| short   | 有符号的整数  | 0 | 16 位 | [-32768, 32767] |\n| int     | 有符号的整数  | 0 | 32 位 | [-2147483648, 2147483647] |\n| long    | 有符号的整数  | 0 | 64 位 | [-9223372036854775808, 9223372036854775807] |\n| float   | IEEE 154 浮点数 | 0.0 | 32 位 | [1.4E-25, 3.4028235E+38] |\n| double  | IEEE 754 浮点数 | 0.0 | 64 位 | [4.9E-324, 1.7976931348623157E+308] |\n\n#### 布尔类型\n- 表示两种个逻辑状态，可表示开或关，也可是与否。\n- 零或非零表逻辑：\n\n\t```java\n\twhile(1) { // -7,-1,1,8...等非零数值都可作为条件体 \n\t    // 永真循环\n\t}\n\t```\n\n- 对象体表逻辑：\n\n\t```java\n\tObject obj = new Object();\n\t\n\tif( null != obj) {\n\t    // 忽略实现细节\n\t}\n\t```\n\t\n#### 字符类型\n- 普通字符\n- 转义字符\n\n| 名称  | 符号 |\n| :--- | :--- |\n| 退格符\t\t| \\b |\n| 水平制表符\t| \\t |\n| 换行符\t\t| \\n |\n| 换页符\t\t| \\f |\n| 回车符\t\t| \\r |\n| 双引号\t\t| \\\\\" |\n| 八进制\t\t| \\000 |\n| 十六进制     | \\u0000 |\n\n> 在上表中，以取双引号为例，只需附加上反斜杆 `\\` 即可。  \n> 例如：`\\\\`、`\\\"` `\\'`。\n\n### 表达式和运算符\n- 运算符概述：\n\t- 优先级：与 [C语言类同](https://www.kofes.cn/2017/04/C-Programming-Design-Learning.html#4-1-关系运算符及其优先次序) (单目运算符 > 双目运算符 > 三目运算符)\n\t- 结合方式：从左向右\n\t\n- 算术运算符：加 `+`、减 `-`、乘 `*`、除 `/`、求模 `%`、负号 `-`。\n\n- 字符串连接符：`\"Hello\" + \"World\"` 相当于 `“HelloWorld”`。\n\n- 递增、递减运算符：操作数必须是变量、数组中的元素或对象的字段。\n\n- 比较运算符：等于 `==`、不等于 `!=`、小于 `<`、大于 `>`、大于等于 `>=`、小于等于 `<=`。\n\n- 逻辑运算符：条件与 `&&`、条件或 `||`、逻辑非 `!`。\n\n- 位运算符和位移运算符：\n\t- 按位补码 `~`：把操作数的每一位反相，0 变 1，1 变 0  \n\t~12 => ~00001100 => 11110011 => -13\n\t- 位与 `&`   \n\t10 & 7 => 00001010 & 00000111\t=>\t00000010 => 2\n\t- 位或 `|`  \n\t10 | 7 => 00001010 | 00000111\t=>\t00001111 => 15\n\t- 位异或 `^`：相异为真  \n\t10 ^ 7 => 00001010 ^ 00000111\t=>\t00001101 => 13\n\t\n- 左移 `<<`：高位丢掉，右边补零，向左移动 n 位，相当于乘以 2\\\\(^{n}\\\\)。\n\n\t```Java\n\t左移运算的实例：\n\n\t10 << 1 => 00001010 << 1 => 00010100 => 20 => 10 * 2\n\t07 << 3 => 00000111 << 3 => 00111000 => 56 => 07 * 2^3\n\t-1 << 2 => 11111111 << 2 => 11111100 => -4 => -1 * 2^2\n\n\t// -1<<2 => 11111111<<2：即负数是补码形式存储的。\n\t```\n\n- 带符号右移 `>>`：高位 `补符号`，左侧操作数为正数则 `高位补0`，左侧操作数为负数则 `高位补1`。向右移动 n 位，相当于除以 2\\\\(^{n}\\\\)。\n\n\t```java\n\t10 >> 1  => 00001010 >> 1 => 0 0000101 => 05 => 10 / 2\n\t27 >> 3  => 00011011 >> 3 => 000 00011 => 03 => 27 / 2^3\n\t-50 >> 2 => 11001110 >> 2 => 11 110011 => -13\n\t```\n\n- 赋值运算符与条件运算符：\n\n\t```java\n\te = a < b ? c :d; // 条件运算符鼻赋值运算符优先级高\n\t```\n\n- 特殊运算符：\n\t- 访问对象成员 `.`\n\t- 访问数组中元素 `[]`\n\t- 调用方法 `()`\n\t- lambda 表达式 `->`\n\t- 创建对象 `new`\n\t- 类型转换及校正 `()`，\n\n### 语句\n- 选择结构和循环结构和 C 语言的相差无几，这里就不详细列举。\n\n- synchronized 语句：\n\t- `Expression` 表达式的计算结果必须是一个 `对象` 或 `数组`。`Statements` 是能导致破坏的代码块 (指同步互斥)。\n\t- 即 Java 解析器为 `Expression` 计算得到的对象或数组获取一个排它锁，直到语句块执行完毕再释放。只要某个线程拥有对象的排它锁，其他线程就不能再获取这个锁。\n\n\t\t```java\n\t\tsynchronized( Expression ) {\n\t\t    // Statements\n\t\t}\n\t\t```\n\n- throw 语句：\n\n\t```java\n\t// throw expression;\n\tpublic static double factorial(int x) {\n\tdouble fact;\n\t\n\tif( x < 0 ) {\n\t    throw new IllegalArgumentException(\"x must be >= 0.\");\n\t} else {\n\t    for(fact=1.0; x > 1; fact *= x, x--) {\n\t        // Nothing\n\t    }\n\t}\n\treturn fact;\n\t}\n\t```\n\n- try/catch/finall 语句：\n\n\t```java\n\ttry {\n        // 正常情况，从上往下执行\n        // 也有可能跑出异常，或是 throw 语句直接抛出异常\n\t} catch( SomeException e1 ) {\n        // 处理 SomeException 或其子类型的异常对象\n        // 使用名称 e1 引用那个异常对象\n\t} catch( AnotherException e2 ) {\n        // 处理 AnotherException，使用名称 e2 引用传入的异常对象\n\t} finally {\n        // 不管 try 子句的结束方式如何，这段代码都会执行。\n        // 但是 try 子句中调用了 System.exit()，解析器会马上退出，而不执 finally 子句。\n\t}\n\t```\n\n\t即 Java 解析器执行 throw 语句，会立即停止常规程序执行，开始捕获或处理异常的异常处理程序 ( try/catch/finally 语句编写 )。\n\n### 方法\n#### 定义方法\n- 方法的定义都是以签名开头，后面跟着方法主体。方法主体，即放在花括号里的任意语句序列。方法签名包括下述内容：\n\n\t- 方法名称；\n\t- 方法所用参数的数量、顺序、类型和名称；\n\t- 方法的返回值类型；\n\t- 方法抛出的已检异常 ( 下述有解释：已检异常和未检异常 )；\n\t- 提供方法额外信息的多个方法修饰符.\n\n- 方法签名的格式：`modifiers` `type` `name(paramlist)` [ throws `exceptions` ]  \n\t- `modifiers` : 指零个或多个特殊的修饰符关键字；  \n\t- `type` : 指明方法的返回类型；  \n\t- `name` : 即方法名称；  \n\t- `paramlist` : 指形参列表；  \n\t- `exceptions` : 抛出已检异常.  \n\n#### 方法修饰符\n| 修饰符 | 作用描述 |\n| :---- | :------ |\n| abstract | abstract 修饰方法，类本身也必须声明 abstract。 |\n| final | final 修饰的方法不能被子类覆盖或隐藏。 |\n| public、protected、private | 这些访问修饰符指定方法是否能在定义它的类之外使用，或能在何处使用。 |\n| synchronized | synchronized 修饰符的作用是实现线程安全的方法 (避免两个线程同时执行该方法)。 |\n| static | static 声明的方法是类方法。 |\n\n#### 已检异常和未检异常\n- 已检异常和未检异常 -- `什么情况抛出异常`\n\t- 已检异常：明确的特定情况下抛出。\n\t> 例如：FileNotFoundException -- 打开某个文件却不在目录中。\n\t\n\t- 未检异常：任何方法任何时候都可能抛出。\n\t> 例如：OutOfMemoryError、NullPointerException。\n\t\n- 区分已检和未检异常，记两点：  \n\t1. 异常是 Throwable 对象；  \n\t2. 异常分两种类型：Error (未检) 和 Exception (已检).\n\n- 处理已检异常：在方法签名的 throws 子句中声明这个异常。Java 编译器检查方法签名，若没有声明会导致编译出错，故叫已检异常。\n\t\n\t```java\n\tpublic static estimateHomePageSize(String host) throw IOException {\n\t    URL url = new URL(\"htts://\" + host);\n\t    try( InputStream in = url.openStream() ) {\n\t        return in.available();\n\t    }\n\t}\n\t```\n\t\n#### 变长参数列表\n- 变长参数列表：方法可声明为数量不定的参数。\n\n\t```java\n\tpublic static int max(int first, int...rest) { \n        // int...rest 相当于 int[] rest\n        // 省略实现细节\n\t}\n\t```\n\n### 介绍类和对象\n> 关于类最重要的事情是，它们定义了一种新数据类型。例如定义一个 Point 类表示笛卡尔二维坐标系中的数据点。\n\n- 定义类：\n\n\t```java\n\tpublic class Point {\n\t    public double x, y;\n\t    public Point(double x, double y) {\n\t        this.x = x;\n\t        this.y = y;\n\t    }\n\t    public double distanceFromOrigin() {\n\t        return Math.sqrt(x*x,y*y);\n\t    }\n\t}\n\t```\n\n- 创建对象与使用对象：\n\n\t```java\n\tPoint point = new Point(2.0, 3.5);\n\tSystem.out.println( \"Sqrt(x, y):\" + point.distanceFromOrigin() );\n\t```\n\n- 再谈数据类型：谈论数据类型时，得分开数据类型和数据类型的值。Char 类型的值表示某个具体的字符，而 Point 类是一种新的数据类型，用于表示坐标 (x, y)，Point 类为引用类型，即聚合类型，而 Point 类表示的值是对象。\n\n| 数据类型 | 数据类型的值 |\n| :------ | :--------- | \n| char   | unicode 字符 |\n| Point 类 | point 对象 |\n\n- lambda 表达式：其实就是没有名称的函数，`某个类中定义的匿名方法`。  \n\n\t> 某个类中定义的匿名方法：Java 不允许脱离类的概念运行方法。\n\n\t定义 lambda 表达式：( paramlist ) -> { Statements }\n\t\n\t```java\n\tRunable r = () -> { System.out.println(\"Hello World.\"); }\n\t```\n\n### 数组\n#### 数组的类型\n- 数组中元素的类型可是任何有效的 Java 类型，包括数组类型。\n\n\t```java\n\t// byte 是基本类型\n\tbyte b;\n\t\n\t// byte[] 是由 byte 类型的值组成的数组\n\tbyte[] arrayOfBytes;\n\t\n\t// byte[][] 是由 byte[] 类型的值组成的数组\n\tbyte[][] arrayOfArrayOfBytes;\n\t\n\t// String[] 是由字符串组成的数组\n\tString[] points;\n\t```\n\n#### 创建和初始化数组\n- Java 在运行时 `初始化数组` 有个推论：数组初始化程序中的 `表达式` 可能会在运算时计算，而且不一定非要使用 `编译时常量`。\n\n\t```java\n\tPoint[] point = \n\t\t{circle1.getCenterPoint(), circle2.getCenterPoint()}\n\t\t\t\n\tString[] lines = new String[50]; // 中括号中使用非负整数\n\tString[] greetings = \n\t\tnew String[] {\"Hello\", \"World\", \"I'm Kofes.\"}\n\t```\n\n#### 使用数组\n- 数组的边界：a[ 0...a.length-1 ]\n- 迭代数组：遍历数组\n\n\t```java\n\tint[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23 };\n\tint sumOfPrimes = 0;\n\t\t\n\tfor( int = 0; i < primes.length; i++ ) {\n\t    sumOfPrimes += prime[i];\n\t}\n\t\t\n\t// 等价于上一个 for 循环\n\tfor( int p : primes ) sumOfPrimes += p;\n\t```\n\n#### 多维数组\n- 多维数组的定义和初始化：\n\n\t```java\n\tint[][] products = new int[10][]; // 正确\n\tint[][] products = new int[][10]; // 错误，指定的维度必须位于最左边\n\t\n\tfor( int i = 0; i < 10; i++ ) {\n\t    products[i] = new int[10];\n\t}\n\t```\n\n### 引用类型\n- 引用类型与基本类型：\n\t- 引用类型：\n\t\t- 1) 引用类型由用户定义，可有无限多个。  \n\t\t- 2) 即聚合类型，保存零或多个基本值或对象。\n\t- 基本类型：  \n\t\t- 1) 8 种基本类型由 Java 语言定义，不能由我们自己定义新基本类型。  \n\t\t- 2) 基本类型表示单个值。  \n\t\t- 3) 基本类型需要 1 到 8 字节的内存空间。\n\n- 处理对象和引用副本：\n\n\t```java\n\tPoint p = new Point(1.0, 2.0);\n\tPoint q = p; // 因变量 p 和 q 保存的引用都指向同一对象。\n\tSystem.out.println(p.x); // 1.0\n\tq.x = 13.0;\n\tSystem.out.println(p.x); // 13.0\n\t```\n\n- 比较对象，即 `==` 与 `obj.equal()` 的区别：\n\t- `==` 比较引用类型时，比较的是引用是否指向同一对象。\n\t- `obj.equal()` 比较的是对象内容是否一样。\n\t\n\t```Java\n\tString letter = \"O\";\n\tString s = \"Hello\";\n\tString t = \"Hell\" + letter;\n\t\n\tif( s==t ) {\n\t    System.out.println(\"equal\"); // 显然不等\n\t}\n\tif( s.equal(t) ) {\n\t    System.out.println(\"equal\"); // 内容相等\n\t}\n\t```\n\n### 包和 Java 命名空间\n- 声明包：`package org.apache.commons.net;`\n\n\t> package 指定类属于哪个包 (Java 代码的第一行标记，除注释和空格外)\n\t\n- 导入类型：\n\t\n\t```java\n\t// 现不用输入 java.io.File 了，输入 File 定义即可\n\timport java.io.File; \n\tFile file = new File();\t\n\t\n\t// java.io 包中的所有类都可以使用简称\n\timport java.io.*;\n\t```\n\n- 导入静态成员：\n\n\t```java\n\timport static java.lang.Math.*;\n\tMath.sqrt( abs(sin(x)) ); // 直接使用 sqrt( abs(sin(x)) );\n\t```\n\n- Java 文件结构：\n\t- `一个` 可选的 package 指令；\n\t- `零个或多个` import 或者 import static 指令；\n\t- Java 文件中 `只有一个` 声明 public 的类，且类名必须与文件名相同.\n\t\n\t\t> public 类的目的是供其他包中的类使用。不管类是否为 public，一个文件只定义一个类，并且名称相同，是良好的编程习惯。\n\n## 叁 Java 面向对象编程\n### 类\n#### 面向对象的基本概念\n- 类：\n\t- 由一些保存值的 `数据字段` 和处理这些值的 `方法` 组成。\n\t- 类定义一种新的引用类型。\n\n\t\t> 例如：Point 类，表示所有笛卡尔二维坐标点。\n\t\n- 对象：类的实例，对象一般通过实例化类来创建。\n\n#### 定义类的句法\n\n```java\npublic class IntegerNumber extends Number\n\timplements Serialzable, Comparable {\n\t// 类的成员 (成员变量和成员方法)\n}\n```\n\n### 字段和方法\n- `类字段`、`类方法`：关联在类自身上的 `类成员` (静态变量)。\n- `实例字段`、`实例方法`：关联在类的单个实例 (对象) 身上的 `实例成员`。\n\t\n\t```java\n\tpublic class Circle {\n\t    // 类字段\n\t    public static final double PI = 3.14159; \n\t    \n\t    // 类方法\n\t    public static double radiusToDegrees(double radius) {\n\t        return radius * 180 / PI;\n\t    }\n\t    \n\t    // 实例字段，即实例化后获得参数\n\t    public double r; \n\t    \n\t    // 实例方法\n\t    public double area() { \n\t        return PI * r * r;\n\t    }\n\t}\n\t```\n\t\n- this 引用的工作方式：只要 Java 方法在类中访问 `实例字段`，都默认方法 this 参数指向的对象中的字段。\n\n\t```java\n\tdouble radius;\n\t\n\tpublic void setRadius(double radius) {\n\t    this.radius = radius; // 把参数赋值给类字段\n\t}\n\t```\n\n\t- 一般地，若实参变量名称与类字段不一致，可省略 this，例如形参为 `double r`，即  `radius = r` 。在该例子中省略会让编译器报错，即无法理解值是谁赋给谁。\n\t- 实例方法可以使用 this 关键字，相反类方法不能使用。\n\n### 创建和初始化对象\n- 定义构造方法：\n\n\t```java\n\tpublic class Circle {\n        protected double r;\n        public Circle(double r) {\n            this.r = r;\n        }\n\t}\n\t```\n\n\t- 构造放方法的成名始终和类名一样。\n\t- 声明构造方法时不指定返回值类型，连 void 都不用。\n\n- 定义多个构造方法：只要构造方法的参数列表不同，为一个类定义多个构造方法是可以的。\n\n\t```Java\n\tpublic class Circle {\n\t    protected double r;\n\t    public Circle() {\n\t        r = 1.0;\n\t    }\n\t    public Circle(double r) {\n\t        this.r = r;\n\t    }\n\t}\n\t```\n\n- 字段的默认值和初始化程序：类中的字段不一定要初始化，因为字段自己使用默认值初始化。\n\t\n\t> 良好的编程习惯，或字段的默认值不适合情景。建议显式提供初始值。\n\t\n### 子类的继承\n#### 扩展类\n\n```Java\npublic  class PlanCircle extends Circle { // 自动继承了 Circle 类的字段和方法\n    private final double x, y;\n    public PlanCircle(double r, double x, double y) {\n    \n        // 调用超类的构造方法 Circle()\n        super(r);\n        \n        this.cx = x;\n        this.cy = y;\n    }\n}\n```\n\n#### 构造方法链和默认构造方法\n- 创建类的实例，Java 保证会调用这个类的构造方法。\n- 创建任何子类的实例，Java 保证会调用超类的构造方法。\n- 若构造方法没有调用超类的构造方法，Java 会隐式调用。\n- 若类没有声明构造方法，Java 会为类隐式添加一个构造方法。\n\n\t> 若超类没有声明无参数的构造方法，这种隐式调用会导致编译出错。所以，若类中没有定义任何构造方法，默认会为其提供一个无参数的构造方法。\n\t\n#### 覆盖超类的方法\n> 注意，覆盖不是遮盖。\n\n- 类中定义的某个实例方法和超类的某个方法有相同 `名称`、`返回类型`、`参数`，那么这个方法会覆盖，即 `@Override`。\n\n### 数据隐藏和封装\n- 封装：把数据隐藏在类中，只能通过方法获取。\n\t- 隐藏类的内部细节。\n\t- 保护类，如一些相互依赖的字段。\n- 访问控制\n\t- 访问包：\n\t\t- 1) 访问控制一般在类和类的成员这些层级完成。  \n\t\t- 2) 访问其他包，import 导入相关包即可。  \n\n\t- 访问类：默认情况，顶层类在定义它的包中可以访问。\n\n\t- 访问成员：类的成员在类的主体里始终可以访问。\n\t\t- public、private、protected (default) 作为修饰符，修饰类的成员。  \n\t\t- public => 类的任何地方都可访问这个成员。  \n\t\t- private => 除了类内部能访问。  \n\t\t- protected => 包里的所有类都能访问这个成员，只限制在同一包内进行访问。  \n\t\n\t- 访问控制和继承：\n\n\t\t > 不继承类字段、类方法。\n\t\n\t\t- 使用 `private` 声明的字段和方法绝不会被继承，类字段和类方法也一样。\n\t\t- 构造方法不会被继承，而不是链在一起调用。\n\t\t- 子类和超类： \n\t\t\t- 1) 同一包中，子类继承所有没使用 `private` 声明的实例字段和方法。  \n\t\t\t- 2) 不同包中，子类继承所有使用 `protected` 和 `public` 声明的实例字段和方法。\n\n### 抽象类和方法\n- 类中有一 abstract 方法，则该类为 abstract，若是 final 关键字声明的类不能有任何 abstract 方法。\n- abstract 类无法实例化。\n\n#### 转换引用类型\n- 对象不能转换不相关的类型。\n\n\t> String 对象 -> Point 对象\n\t\n- 对象可以转成超类类型，或任何祖先类型。即放大转换，因此不需要校正。\n- 对象可以转换成子类型，缩小转换，但需确保转换有效。\n\n#### 修饰符总结\n\n| 修饰符 | 用于 | 意义 |\n| :---- | :-- | :--- |\n| abstract | 类 | 这个类不能实例化，且可能包含未实现的方法 |\n|  | 接口 | 所有接口都是抽象的，声明接口时这个修饰符是可选的 |\n|  | 方法 | 这个方法没有主体，主体由子类提供，签名后面紧接一个分号。所在的类必须也是抽象的 |\n| default | 方法 | 这个接口方法的实现是可选的。 |\n| final | 类 | 不能创建这个类的子类 |\n|  | 方法 | 不能覆盖这个方法 |\n|  | 字段 | 这个字段的值不能改变 |\n|  | 变量 | 值不能改变的局部变量、方法参数或异常参数 |\n| 无(包) | 类 | 包级私有：没有声明 public 的类只能在包中访问 |\n|  | 接口 | 包级私有：没有声明 public 的接口只能在包中访问 |\n|  | 成员 | 包级私有：没有声明 public、private 或 protected 的成员只能在包中访问 |\n| private | 成员 | 该成员只在定义它的类中可以访问 |\n| protected | 成员 | 该成员只在定义它的包中和子类中可以访问 |\n| public | 类 | 能访问所在包的地方都能访问这个类 |\n|  | 接口 | 能访问所在包的地方都能访问这个接口 |\n|  | 成员 | 能访问所在类的地方都能访问这个成员 |\n| static | 类 | 使用 static 声明的内部类是顶层类，而不是所在类的成员 |\n|  | 方法 | static 方法是类方法，不隐式传入 this 对象引用，可通过类名调用 |\n|  | 字段 | static 字段是类字段，不管创建多少类实例，这个字段只有一个实例，可通过类名访问 |\n|  | 初始化程序 | 这个初始化程序在加载类时运行，而不是创建实例时运行 |\n| synchronized | 方法 | 这个方法对类或实例执行非原子操作，故得确保不能让两个线程同时修改类或实例。对 static 方法来说，执行方法前先为类获取一个锁；对非 static 方法来说，会为具体的对象实例获取一个锁 |\n| volatile | 字段 | 该字段能被异步线程访问，因此必须对其做些特定的优化 |\n\n## 肆 Java 类型系统\n- Java 是一种静态语言，如果把不兼容型的值赋给变量，会导致编译出错。而在运作时检查类型兼容性的语言叫做动态类型语言，如 Javascript。  \n\n\t> 在 [第壹章：Java 和其他语言比较](#Java-和其他语言比较) 中有对语言类型的深入了解。\n\n### 接口\n- 接口的作用只是描述 API，接口提供类型的描述信息，以及实现这个 API 的类应提供的方法 (和签名)。\n- Java 的接口不为它描述的方法提供实现代码，这些方法是强制要实现的。\n\n#### 定义接口\n\n```Java\ninterface Centered {\n    void setCenter(double x, double y);\n    double getCenterX();\n    double getCenterY();\n}\n```\n\n- 特别说明：\n\t- 接口中所有强制方法都隐式使用 abstract 声明，不能有方法主体，以分号结束。\n\t- 接口定义公开的 API，接口所有成员都隐式使用了 public 声明。\n\n\t\t> 使用 protected 或 private 定义方法，将会编译出错。\n\t\n\t- 接口不能实例化，因此不定义构造方法。\n\t- 接口中可包含嵌套类型。\n\t- 接口中可包含静态方法。\n\n#### 扩展接口\n- 继承父接口的所有方法和常量，且可定义新方法和常量。接口的 extends 子句可包含多个父接口。\n\n\t> 注意：实现这个接口的类必须实现这个 `接口直接定义` 的抽象方法，包括所有 `父接口` 中继承的全部抽象方法。\n\n\t```Java\n\tinterface Transformable extends Scalable, Translateble, rotalable {\n\t    // 忽略细节\n\t}\n\t```\n\n#### 实现接口\n- 实现多个接口：一个类即可实现一个接口，也可实现多个接口，后者表明的这个类要实现所有接口中的全部抽象方法 (强制方法)。\n\n\t```Java\n\tpublic class SuperDuperSquare extends Shape \n\t    implements Centered, UpperRightCornered, Scalable {\n\t    // 忽略细节\n\t}\n\t```\n\n#### 默认方法\n- 向后兼容性：前一版平台编写 (或已编译) 的代码在最新版平台中必须能继续使用。\n- 实现默认方法：若升级某一接口，重新定义接口后，尝试在为旧接口编写的代码中使用这个新接口，不会成功。  \n\n\t即抛出 `NoClassDefError` 异常，如下例中添加新的强制方法。\n\t\n\t```Java\n\tinterface Positionable extends Centered {\n\t    void setUpperRightCorner(double x, double y);\n\t    double getUpperRightX();\n\t    double getUpperRightY();\n\t\t\n\t    // 在此接口增加以下强制方法，是不会成功的。后续的解决办法是使用抽象类\n\t    void setLowerLeftCorner(double x, double y);\n\t    double getowerLeftX();\n\t    double getowerLeftY();\n\t}\n\t```\n\n### Java 泛型\n#### 介绍泛型\n- 使用泛型增强程序的安全性，使编译时信息避免简单的类型错误。具体以下述的引例展开学习。\n\n\t```java\n\tList shapes = new ArrayList();\n\tshapes.add( new CenteredCircle(1.0, 1.0, 1.0) );\n\tshapes.add( new CenteredSquare(2.5, 2, 3) );\n\n\t// list::get() 返回 Object 对象，想得到 CenteredCircle 对象必须校正\n\tCenteredCircle circle0 = (CenteredCircle) shapes.get(0);\n\n\t// 运行此代码时会导致运行失败\n\tCenteredCircle circle1 = (CenteredCircle) shapes.get(1);\n\t```\n\n- `CenteredCircle circle1 = (CenteredCircle) shapes.get(1);` 运行失败的原因，即把不同类型的对象放在同一容器中，一切正常运行。但若做了不合法的校正，程序就会崩溃。\n\n\t为了解决此类问题，Java 提供了一种句法，即指明某中类型是一个容器，这个容器中保存着其他引用类型的实例。容器中保存的 `负载类型` 在尖括号中指定：\n\n\t```java\n\tList<CenteredCircle> shapes = new ArrayList<CenteredCircle>();\n\tshapes.add( new CenteredCircle(1.0, 1.0, 1.0) );\n\tshapes.add( new CenteredCircle(2.5, 2, 3) );\n\t```\n\n- `容器类型` 一般称为泛型：\n\n\t```java\n\tinterface Box<T> {\n\t    void box(T t);\n\t    T unbox();\n\t}\n\t```\n\n#### 泛型和类型参数\n- `<T> 句法`，也称 `类型参数`，因此泛型还有一个名称 `参数化类型`。\n- 定义有参数的类型，要使用一种不对类型参数做任何假设的方式指定具体的值。且类型参数可在方法的签名和主体中使用，就像真正的类型一样。\n\n\t```java\n\tinterface List<E> extends Collection<E> {\n\t    boolean add(E e);\n\t    E get(int index);\n\t}\n\t```\n\n#### 菱形句法\n- 使用菱形句法创建一个由 CenteredCircle 对象组成的 List。\n\n\t```java\n\t// 后一个 <> 内为空，但编译器能推导出类型参数的值\n\tList<CenteredCircle> shapes = new ArrayList<>(); \n\t```\n\n#### 类型擦除\n- Java 平台十分看重向后兼容性，问题的关键是，如果让类型系统既能使用旧的非泛型集合类又能使用新的泛型集合类，则设计者们选择 `校正` 的解决方案。\n\n\t下述代码表明，`List` 与 `List<String>` 是兼容的，Java 通过类型擦除实现这种兼容性。\n\n\t```java\n\tList someThings = getSomeThing();\n\t// 这种校正不安全，即使 someThings 的内容确定是字符串\n\tList<String> myStrings = (List<String>) SomeThings;\n\t```\n\n- 类型擦除机制还能禁止使用某些其他定义方式。\n\n\t下述代码看似合法，其实是无法编译的。其实当擦除类型后，两方法的签名变成 `int totalOrder(Map);`，Java 语言规范把这种句法列为不合法的句法。\n\n\t```java\n\tinterface OrderCounter {\n\t    int totalOrder( Map<String, List<String>> orders );\n\t    int totalOrder( Map<String, Integer> orders );\n\t}\n\t```\n\n#### 通配符\n- 受限通配符，限制类型参数的值能使用哪些类型。\n\t- 类型协变：表示`容器类型之间` 和 `负载类型之间` 具有 `相同` 的关系，这种关系通过 `extends` 关键字表示。\n\t- 类型逆变：表示`容器类型之间` 和 `负载类型之间` 具有 `相反` 的关系，这种关系通过 `super` 关键字表示。\n\t\n- 例如，Cat 类 扩展 Pet 类，`List<Cat>` 是 `List<? extends Pet>` 的子类型。List 是 Cat 对象的制造者，应使用关键字 extends。\n\n\t> [Joshua Bloch](https://baike.baidu.com/item/Josh%20Bloch/4419184?fr=aladdin) 把这种用法总结为 PECS. `Producer Extends, Consumer Super` 原则，即使用者使用 super，制造者使用 extends。\n\t\n- 使用和设计泛型\n\t- 使用者：理解类型擦除的基本知识。\n\t- 设计者：泛型更多功能。如通配符、\"Capture of\" 错误信息等。\n\n### 枚举和注解\n#### 枚举\n\n```java\npublic enum RegularPolygon {\n    // 带参数的枚举必须使用分号\n    TRIANGLE(3), SQUARE(4), PENTAGON(5), HEXAGON(6);\n    \n    private Shape shape; \n    \n    public Shape getShape {\n        return this.shape;\n    }\n    \n    // 因枚举实例在 Java 运行时创建，在外部不能实例化，故把构造方法声明为私有。\n    // 只能有一个私有的构造方法 (或默认访问权限，即不写)。\n    private RegularPolygon(int sides) {\n        switch(sides) {\n            case 3: // 三角形\n                shape = new Triangle(1, 1, 1, 60, 60, 60);\n                break;\n            case 4: // 矩形\n                shape = new Rectangle(1, 1);\n                break;\n            case 5: // 五边形\n                shape = new Pentagon(\n                    1, 1, 1, 1, 1, 108, 108, 108, 108, 108);\n                break;\n            case 6: // 六边形\n                shape = new Hexagon(\n                    1, 1, 1, 1, 1, 1, 120, 120, 120, 120, 120, 120);\n                break;\n        }\n    }\n}\n\n// 实际使用\nRegularPolygon polygon = \n    new RegularPolygon( RegularPolygon.TRIANGLE );\n```\n\n- 注意：\n\t- 枚举不能泛型化，不能被扩展；\n\t- 可以实现接口；\n\t- 只能有一个私有的构造方法 (或使用默认访问权限，不声明任何关键字).\n\n#### 注解\n- 注解是一种特殊的接口，其作用是注解 Java 程序的某个部分。\n- 能为编译器和集成环境 (IDE) 提供有用的提示。\n- 注解没有直接作用，例如 `@Override` 为注解的方法提供额外信息，注明这个方法覆盖了超类中的方法。\n- Java 平台中常见的基本注解：\n\t- `@Override` - 注明方法是覆盖的。\n\t- `@Deprecated` - 注明方法已经废弃了。\n\t- `@SuppressWarnings` - 注明编译器生成的警告。\n\t- `@SafeVarargs` - 为变长参数方法提供增强的警告静态方法、默认方法功能\n\t- `@FunctionalInterface` - 接口是一正确的函数式接口，注解能够更好地让编译器进行检查。\n\n#### 自定义注解\n- 使用 `@interface` 关键字定义新的注解类型，与定义类和接口的方式差不多。\n- 自定义注解的关键是使用 `元注解`，他们是用来注解新注解类型的定义，必须使用两个基本元注解 `@Target` 和 `@Retention`。\n\t- `@Target`：指明自定义的新注解能在 Java 源码的什么地方使用。可用的值在枚举 `ElementType` 中定义，其中包括：\n\t\t- TYPE - 类、接口 (包括注解类型) 或 Enum 声明\n\t\t- FIELD - 域声明 (包括 Enum 实例)\n\t\t- METHOD - 方法声明\n\t\t- PARAMETER - 参数声明\n\t\t- CONSTRUCTOR - 构造器声明\n\t\t- LOCAL_VARIABLE - 局部变量声明\n\t\t- ANNOTATION_TYPE - 注解\n\t\t- PACKAGE - 包声明\n\t- `@Retention`：指明 Javac 和 Java 运行时如何处理自定义的注解类型。可用的值得在枚举 `RetentionPolicy` 中定义，其中包括：\n\t\t- SOURCE - 表示注解将被编译器丢弃。\n\t\t- CLASS - 表示注解会出现在类文件中，但运行时 JVM 无法访问。\n\t\t- RUNTIME - JVM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。\n\t- `@Documented`：将此注解包含在 Javadoc 中。\n\t- `@Inherited`：允许子类继承父类中的注解。\n- 便于理解，这里定义一个名为 @Nickname 的注解，使用这个注解为方法指定一个昵称，运行时使用反射可以找到这个方法。\n\n\t```java\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface Nickname {\n\t    String[] value() default {};\n\t}\n\t```\n\t\n#### 嵌套类型\n- 顶层类型：诸如类、接口和枚举类型都定义为顶层类型，即都是包中的直接成员。\n- 嵌套类型：也称为 `内部类`，不能作为完全独立的实体真实存在，类型通过四种不同方式嵌套在其他类型中。\n- 四种嵌套方式：\n\t- 静态成员类型：嵌套的接口，枚举和注解 (既使不使用 static 关键字)。\n\t- 非静态成员类型：没有 static 关键字声明，只有类才能作为非静态成员类型。\n\t- 局部类：Java 代码块中定义的类，只是这个块可见。\n\t- 匿名类：局部类，匿名类是不能有名字的类，在创建 new 语句来声明它们。\n\n\t\t```java\n\t\tRunnable runnable = new Runnable() {\n\t\t    public void run() {\n\t\t        // 忽略细节\n\t\t    }\n\t\t}\n\t\t\n\t\tThread thread = new Thread();\n\t\trunnable.start();\n\t\t```\n\t\n- 嵌套类型的运作方式：对于 Java 解析器而言，并没有所谓的嵌套类型，`所有类型都是普通的顶层类`。为了实现嵌套类型，Javac 把每个嵌套类型编译为 `单独类文件`，得到的类文件使用 `特殊命名约定`。\n\t- 静态 / 非静态成员类型：以 `EnclosingType$Member.class` 格式命名成员类型的类文件。\n\n\t\t> 例如在 LinkedStack 类中，定义一个 Linkable 的静态成员接口。  \n\t\t> 在编译这个 LinkedStack 类时，编译器会生成两个类文件，分别是 LinkedStack.class 和 LinkedStack$Linkable.class。\n\t\n\t- 匿名类：类文件的名称由实现细节决定，例如 Oracle 或 OpenJDK 中 Javac 使用数字表示匿名类的名称，即 `EnclosingType$1.class`.\n\t- 局部类：综合使用前两种方式命名，例如 `EnclosingType$1Member.class`。\n\n#### Lambda 表达式\n- 列出目录中文件名以 \".java\" 结尾的文件。\n\n\t```java\n\tFile dir = new File(\"/src\");\n\t\n\t// 调用 list() 方法，参数的值是匿名类实现的 FilenameFilter\n\tString[] fileList = dir.list( new FilenameFilter() {\n\t    public boolean accept(File file, String str) {\n\t        return str.endsWith(\".java\");\n\t    }\n\t});\n\t\n\t// Lambda 表达式\n\tString[] fileList = dir.list( \n\t    (file, str) -> {return str.endsWith(\".java\"); }\n\t);\n\t```\n\n- 转换 lambda 表达式：必须满足以下条件才算是合法的 Java 代码。 \n\t- 必须出现在期望使用接口类型实例的地方；\n\t- 期望使用接口类型必须只有一个强制方法；\n\t- 该强制方法的签名要完全匹配 lambda 表达式).\n\n- 方法引用：\n\n\t```Java\n\t// 该接口只有一个非默认方法：\n\t// 该方法接受一个 MyObject 类型的参数，返回类型为 String\n\t(MyObject myobject) -> { myobject.toString(); }\n\t\n\t// 方法引用：Java 8 提供了更简洁的句法\n\tMyObject::toString;\n\t```\n\n## 伍 Java 的面向对象设计\n### Java 的值\n- Java 的值有两种类型，基本值和对象引用，只有这两种值才能赋值给变量。\n\n\t- 基本值：基本值不能改，2永远是2。\n\t- 对象引用：对象引用的内容一般能修改，一般为对象内容的变化。\n\t\n\t\t> [说明] Java 不是 \"引用传递\" 的语言。\n\t\t\n\t\t```java\n\t\tpublic void manipulate(Circle circle) {\n\t\t    circle = new Circle(3);\n\t\t}\n\t\t\n\t\tCircle circle = new Circle(2);\n\t\tmanipulate(circle);\n\t\t\n\t\t// 还是输出 => Radius:2\n\t\tSystem.out.println(\"Radius:\" + circle.getRadius() ); \n\t\t```\n\n#### 面向对象的设计要略\n- 常量：实现某个接口的任何类都会继承这个接口中定义的常量。特别是在多给类中使用的一组常量。\n\n- 高度抽象：选择接口还是抽象类：\n\t- 在已定义的接口添加一个新的强制方法，那么已经实现这个接口的所有类都会出现问题，即接口中添加新方法必须为默认方法，并提供实现。\n\t- 抽象类，可放心添加非抽象方法。子类必须实现抽象方法，但非抽象方法不要求。\n\n- 实例方法还是类方法：\n\t- 类方法：static 声明的静态方法。\n\t- 实例方法：关联在类的单个实例 (对象) 身上的实例成员。\n\n\t\t> 选择实例方法还是类方法，视设计方式决定，哪个方便来哪种。\n\t\n- 合成还是继承：可参考 `装饰模式`。\n- 字段继承和访问器：\n\t- `protected` 修饰字段，允许子类直接访问这些字段。\n\t- 提供访问器，即字段声明为私有，对外隐藏细节。\n\n\t\t```Java\n\t\tprivate double radius;\n\t\tpublic double getRadius() {\n\t\t    return radius;\n\t\t}\n\t\t```\n\n- 单例 ：单例模式，只需要为类创建一个实例。更多设计模式可参考：\n\n\t> 原书笔记：[Android 设计模式之实践与案例](https://www.kofes.cn/2018/01/Design-Pattern-Based-on-Android.html)\n\n#### 异常和异常处理\n- 设计异常机制，应遵循下述良好的做法：\n\t- 异常也是对象，即考虑要在异常中存储什么额外状态；\n\t- Exception 类有四个公开构造。一般情况，自定义异常类需要实现这四个构造方法，可用于初始化额外的状态，定制异常消息；\n\t- 不要捕获异常而不处理；  \t\n\t- 不要捕获异常，记录日志后再次抛出异常.  \n\t\n\t\t```java\n\t\t// 不要捕获异常而不处理\n\t\ttry {\n\t\t    SomeMethodThatMightThrow();\n\t\t} catch(Exception e) {\n\t\t    // 处理异常的细节\n\t\t}\n\t\t\n\t\t// 不要捕获异常，记录日志后再次抛出异常\n\t\ttry {\n\t\t    SomeMethodThatMightThrow();\n\t\t} catch(SpecificException e) {\n\t\t    log(e);\n\t\t    throw e; // 不要再异常处理中再抛出异常\n\t\t}\n\t```\n\n## 陆 Java 实现内存管理和并发编程\n- 本书对 Java 内存管理和高效并发的综述较为模糊，建议阅读周志明老师的《深入理解 Java 虚拟机》的第五部分 `高效并发` $^{[1]}$。\n\n## 柒 编程和文档约定\n### 命名和大小写约定\n- `包`：小写字母，常见做法是把公司的网站域名倒过来。\n\n\t> 例如：cn.kofes.javanutshell\n\n- `引用类型`：`类` 的名称应大写字母开头，混用小写字母；若名称中有部分是 `简称`，则简称全大写。\n\t- 类和枚举类型，表示对象，名称多使用 `名词`。如 `Thread`、`FormatConvertor`。\n\t- 接口，为实现这个接口的类提供额外信息，接口名称一般使用 `形容词`。如 `Runnable`、`Cloneable`。\n- `方法`：`名词 + 名词`；`动词 + 名词` 且遵循 `驼峰式` 命名规则。\n\n\t> 例如：ListenerCollection()、insertObjectA()\n\t\n- `字段和常量`：声明为 `static final` 的常量，名称使用 `全大写形式`，若常量名词包含多个单词，单词之间应使用下划线分割。枚举类型定义的常量往往也全部使用大写字母。\n- `参数`：尽量清楚表明参数作用的名称，尽量使用一个单词命名参数。\n\n\t> 例如：`WidgetProcessor widget;`、`ImageLoader image;`\n\n### Java 文档注释\n- 文档注释是普通的多行注释，即 `/* 块注释的内容. */`。文档包含简单的 Html 格式化标签，还可以包含其他特殊关键字，提供额外信息。\n\n\tJavadoc 程序会把文档注释提取出来，自己转换成 Html 格式的在线文档。\n\n\t```java\n\t/**\n\t * 创建一个新 Complex 对象，表示复数 <i> x + y * i </i>\n\t * @param x 复数的实部\n\t * @param y 复数的虚部\n\t */\n\t public Complex(double x, double y) {\n\t \tthis.x = x;\n\t \tthis.y = y;\n\t }\n\t```\n\n- 文档注释标签：\n\t- `@author name` 声明作者，例如 `@author BenEvans`。\n\t- `@version text`，声明版本信息，例如 `@version 1.3.2，08/26/2017`。\n\n\t\t> 这个标签常和支持自动排序版本号的版本控制系统一起使用，如：git、son。\n\t\n\t- `@param parameter-name description`，声明参数信息。例如 `@param circle Circle 类实例化的对象`。\n\t- `@return description`，声明返回信息。\n\t\n\t\t> @return `<code>true</code>` 成功插入对象。  \n\t\t> @return `<code>false</code>` 列表中已包含要插入的对象。\n\n\t- `@exception full-classname description` 或 `@throw full-classname description`，声明异常。例如 `@exception java.io.FileNotFoundException 如果找不到指定的文件`。\n\n- 关于 Html 标签的使用说明：\n\t- `<i></i>`：用于强调文字内容。\n\t- `<code></code>`：用于显示类、方法和字段的名称。\n\t- `<pre></pre>`：用于显示多行代码示例。\n\n## 捌 使用 Java 集合\n### 介绍集合 API\n#### 两种基本数据结构\n- 容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对的映射表。\n- Collection：对象的集合，如图 8-1 所示。 \n\n\t![Collection数据结构](/images/illustration/Programme/2017/09/Java_in_a_Nutshell_8-1.png)\n<center>图 8-1 Collection 数据结构</center>\n\n- Map：对象间的一系列映射或关联关系，即 `键值对`，如图 8-2 所示。 \n\n\t![Map数据结构](/images/illustration/Programme/2017/09/Java_in_a_Nutshell_8-2.png)\n\t<center>图 8-2 Map 数据结构</center>\n\n- 关于图 8-1 中，部分数据结构的说明：  \n\t- `Set`、`List` 是 `Collection`。Set 没有重复对象，Set 实现都不会对元素排序；List 可能有重复，且其元素按顺序排列。\n\t- `SortedSet` 和 `SortedMap` 是特殊的集合映射，其中的元素按顺序排序。\n\n#### Collection 接口\n- `Collection<E>`，参数化接口，表示由泛型 E 对象组成的集合。\n- 该接口定义了很多方法，如：集合中添加、删除、遍历对象，测试对象是否存在集合中，集合中的元素转换成数组，返回集合大小。\n\n#### Set 接口\n- 无重复对象组成的集合\n\t- 不可能有两个引用指向同一对象；\n\t- 不可能有两个指向 Null 的引用；\n\t- `a.equals(b)`，即 a，b 两对象不能同时出现在集合中.\n- 多数通用的 Set 实现 `都不会对元素排序`，但并不禁止使用 `有序集`。\n\n\t> `有序集`：例如 SortedSet、LinkedHashSet。\n\t\n- 实现 Set 接口的类\n\n| 类 | 内部表示 | 元素排序 | 成员限制 | 基本操作 | 迭代性能 | 备注 |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| HashSet | 哈希表 | 无 | 无 | O(1) | O(capacity) | 失去元素的插入顺序信息，使用 Iterator 遍历得到的结果是不确定的 |\n| LinkedHashSet | 哈希链表 | 插入顺序 | 无 | O(1) | O(n) | 内部使用双向链表维护元素的插入顺序 |\n| TreeSet | 红黑树 | 升序排列 | 可比较 | O(lgn) | O(n) | 元素所需要的类型要实现 Comparable 接口或 Comparator 接口 |\n| CopyOnWriteArraySet | 数组 | 插入顺序 | 无 | O(n) | O(n) | 不使用同步方法也能保证线程安全 |\n\n#### List 接口\n- List 是一组 `有序` 的对象集合。\n- 列表中的每个元素都有特定的位置，且 List 接口定义了一些方法，用于查询或设定特定位置 (或叫索引) 的元素。从这个角度看，`List 对象和数组类似`，不过`列表的大小能按需变化`。\n- 和集不同，列表允许出现重复的元素。\n- 遍历循环和迭代，即依次处理每个元素。\n\n\t```java\n\tListCollection<String> c = new ArrayList<String>();\n\tfor( String word : c ) {\n\t\tSystem.out.println(word); // 遍历循环\n\t}\n\t\n\t// for 循环迭代判断是否还有下一个值\n\tfor( Iterator<String> i = c.iterator(); i.hasNext(); ) {\n\t\tSystem.out.println( i.next() );\n\t}\n\t\n\tIterator<String> iterator = c.iterator();\n\twhile( iterator.hasNext() ) {\n\t\tSystem.out.println( iterator.next() );\n\t}\n\t```\n\n- 实现 List 接口的类\n\n| 类 | 表示方式 | 随机访问 | 备注 |\n| :---- | :---- | :---- | :---- |\n| ArrayList | 数组 | 能 | 高效查找和修改 |\n| LinkedList | 双向链表 | 否 | 高效插入和删除 |\n| CopyOnWriteArrayList | 数组 | 能 | 线程安全；遍历快；修改慢 |\n\n#### Map 接口\n- 映射，一系列键值对，一个键对应一个值。\n- Map 是参数化类型，即 `Map<k,v>`，`k` 表示映射中键的类型，`v` 表示键对应的值，如：`Map<String, Integer>`\n- 实现 Map 接口的类\n\n| 类 | 表示方式 | Null 键 | Nul 值 | 备注 |\n| :--- | :---- | :---- | :---- | :---- |\n| HashMap | 哈希表 | 是 | 是 | 无 |\n| ConcurrentHashMap | 哈希表 | 否 | 否 | 线程安全 (详情请参阅 JDK API) |\n| ConcurrentSkipListMap | 哈希表 | 否 | 否 | 线程安全 (详情请参阅 JDK API)  |\n| LinkedHashMap | 哈希表 + 列表 | 是 | 是 | 保留插入或访问顺序 |\n| TreeMap | 红黑树 | 否 | 是 | 按照键排序 |\n| WeakHashMap | 哈希表 | 是 | 是 | 不会阻止垃圾回收键 |\n\n#### Queue、BlockingQueue 接口\n- 队列是一组有序的元素，提取元素时按顺序从对头读取。队列插入元素的顺序实现，可分类为：\n\t- FIFO：先进先出 -- `队列` 的特性。\n\t- LIFO：后进先出 -- `栈` 的特性。\n- 把元素添加队列中：\n\t- `add()`：Collection 接口定义，常规的方式添加元素。对有界的队列来说，若队列已满，这个方法会抛出异常。\n\t- `offer()`：Queue 接口中定义，若有界的队列已满，这个方法返回 false。\n\t- `put()`：BlockingQueue 接口中定义，会 `阻塞操作`。即队列已满，而无法插入元素，put() 方法会一直等待，直至其他线程从队列中移除元素，有空间插入新元素为止。\n- 把元素从队列中移除：\n\t- `remove()`：\n\t\t- Collection 接口定义，把指定元素从队列中移除。\n\t\t- Queue 接口中定义，则是没有参数的 remove()，移除并返回对头元素 (出队)，若队为空，则抛出 `NoSuchElementException` 异常。\n\t- `poll()`：Queue 接口中定义，移除并返回对头元素，若队列为空，则返回 null。\n\n\t> BlockingQueue 接口中定义了超时版的 poll()，指定时间内等待元素添加到空队列中。\n\t\n\t- `take()`：BlockingQueue 接口定义，用于删除并返回队头元素 (出队)，若队为空，`这个方法会等待`，直到其他线程把元素添加到队列中为止。\n\t- `drainTo()`：BlockingQueue 接口定义，把队列中的所有元素都移除，再把这些元素添加到指定的 Collection 对象中。这个方法不会阻塞操作。\n- 查询：就队列而言，查询时访问队头元素，但不将其从队列中移除。\n\t- `element()`：Queue 接口中定义，作用时返回队头元素，但不将其从队列中移除，若队为空，则抛出 `NoSuchElementException` 异常。\n\t- `peek()`：Queue 接口中定义，作用和 element() 类似，但队为空时返回 null。\n- 特别说明：  \n\t- 如果想在操作成功前一直阻塞，应选 put() 与 take()。  \n\t- 如果想检查方法返回值，应选 offer() 和 poll()。  \n\n#### 实现方法\n- `java.util.Collections` 类定义了一些静态实用方法，用于处理集合。\n- `包装集合`：把集合本身没有提供的功能绑定到集合上。即包装集合能提供的功能有：线程安全性、写保护和运行时类型检查。\n\t- 为包装集合提供线程安全性。\n\t- 不能修改底层集合，即得到的集合只读。\n\n\t```java\n\t// 为包装集合提供线程安全性\n\tList<String> list = Collections.sychronizedList( \n\t\tnew ArrayList<String>() );\n\tSet<Integer> set = Collections.sychronizedSet( \n\t\tnew HashSet<Integer>() );\n\tMap<String, Integer> map = Collections.sychronizedMap( \n\t\tnew HashMap<String, Integer>() );\n\t\n\t// 不能修改底层集合，即得到的集合只读\n\tList<Integer> primes = new ArrayList<Integer>();\n\tList<Integer> readonly = Collections.unmodifiableList(primes);\n\tprimes.add( Arrays.asList(2, 3, 4, 5) ); // 正常\n\treadonly.add(23); // 抛出 UnsupportedOperationException 异常\n\t```\n\n- `操作集合`：\n\n\t```java\n\t// 二分查找前，必须使列表变有序\n\tCollections.sort(list);\n\tint pos = Collections.binarySearch(list, \"key\");\n\t\n\t// 把 list2 的元素复制到 list1，覆盖 list1\n\tCollections.copy(list1, list2); \t\n\t\n\t// 使用对象 obj 去填充 list\n\tCollections.fill(list, obj); \n\t\n\t// 找出集合 list 中最大、小的元素\n\tCollections.max(list);\n\tCollections.min(list);\n\t\n\t// 反转列表\n\tCollections.reverse(list); \n\t\n\t// 打乱列表\n\tCollections.shuffle(list);\n\t```\n\n- `返回集合`：若方法需返回一个集合，若返回值为空，建议返回空集合，代替返回 `null`。\n\t- `Set<Integer> set_list = Collections.emptySet();`  \n\t- `List<String> list = Collections.emptyList();`  \n\t- `Set<String, Integer> map_list = Collections.emptyMap();`  \n\n#### 数组和辅助方法\n- 对象组成的数组和集合的作用类似，二者间可相互转换。\n\t\n\t```java\n\tString[] str = {\"this\", \"is\", \"a\", \"sample\"}; // 数组\n\t\n\t// 数组转换成大小不可变的列表\n\tList<String> list = Array.asList(str); \n\t\n\t// 创建一个大小可变的副本\n\tList<String> list2 = new ArrayList<String>(list); \n\t```\n\n- Array 类还定义了一些静态方法：\n\n\t```java\n\tArray.sort(array); // 原地排序数组\n\tArray.binary(array, 7); // 在 Array 中找 7\n\tArray.equals(array1, array2); // 比较两个数组是否相等\n\t```\n\n## 玖 处理常见的数据格式\n### 文本\n#### 字符串的特殊句法\n- 字符串字面量：Java 允许把一系列字符放在双引号中创建字面量字符串对象。\n\n\t```java\n\tString pet = \"Cat\";\n\tsystem.out.println(\"Dog\",.length());\n\t```\n\n- toString()：作用是方便把任何对象转换成字符串。\n- 字符串连接：\"StringA\" + \"StringB\"。  \n连接字符串时，先创建一个使用 StringBuilder 对象表示的一个工作区 (暂存区)，其内容和原始字符串中的字符序列一样。然后更新 StringBuilder 对象，把另一个字符串中的字符源加到末尾。最后，在 StringBuilder 对象上调用 toString() 得到一个新字符串。\n\n#### 字符串的不可变性\n- String1 + String2 => StringBuilder对象 (暂存区) => toString()，则输出的字符串为 `String1 + String2`。\n\n#### 正则表达式 \n- 正则表达式，用于扫描和匹配文本的搜索模式。\n- Java 使用 Pattern 类表示正则表达式。\n\n\t> `?` 为元字符。\n\t\n\t```Java\n\tPattern p = Pattern.compile(\"honou?r\");\n\tString caesarUK = \"For Brutus is an honourable man.\";\n\tMatcher mUK = p.matcher(caesarUK);\n\t\n\tString caesarUS =\"For Brutus is an honorable man.\";\n\tMathcher mUS = p.matcher(caesarUS);\n\tSystem.out.println(\"Matches.UK Spelling?\" + mUK.find());\n\tSystem.out.println(\"Matches.US Spelling?\" + mUS.find());\n\t```\n\n- 正则表达式元字符：\n\n| 元字符 | 意义 | 备注 |\n| :---- | :--- | :--- |\n| ? | 可选字符出现0或1次 |  |\n| * | 前一个字符出现0或多次 |  |\n| + | 前一个字符出现1或多次 |  |\n| {m, n} | 前一个字符出现m到n次 |  |\n| \\d | 一个数字 |  |\n| \\D | 一个不是数字的字符 |  |\n| \\w | 一个组成单词的字符 | 数字、字母和 _ |\n| \\W | 一个不能组成单词的字符 |  |\n| \\s | 一个空白字符 |  |\n| \\S | 一个不是空白的字符 |  |\n| \\n | 换行符 |  |\n| \\t | 制表符 |  |\n| . | 任意一个字符 | 在 Java 中不包括换行符 |\n| [] | 方括号中的任意字符 | 叫作字符组 |\n| [^] | 不在方括号中的任意一字符 | 叫作排除字符组 |\n| () | 构成一组模式元素 | 叫作组 (捕获组) |\n| 或的符号 | 定义可选值 | 实现逻辑或 |\n| ^ | 字符串的开头 |  |\n| $ | 字符串的末尾 |  |\n\n{% note success %} 工欲善其事，必先利其器。为更快速、准确上手正则，这些现成的、实用的表达式助你一臂之力。\n[技匠. 知道这20个正则表达式能让你少写 1,000 行代码. 2016. jianshu.com](https://www.jianshu.com/p/e7bb97218946)\\\\(^{[2]}\\\\) {% endnote %}\n\n### 数字和数学运算\n#### Java 表示整数类型的方式\n- 以 Java 的 Byte 类型为例，说明 Java 是如何表示整数的。Byte 类型的数字占8位，设定 Byte 类型数字的最高位用于表示正、负号。故有128个正数，128个负数。\n\n\t```Java\n\tbyte b = 0b0000_0001; // 1\n\tbyte b = 0b0111_1111; // 127\n\t\n\t// 负数是以补码形式存储的，而正数，原码、反码、补码一致\n\tbyte b = 0b1111_1111; // -1\n\tbyte b = 0b1111_1111; // -2\n\t```\n\n## 拾 处理文件和 I/O\n### 网络\n- Java 对网络支持的核心 API 在 java.net 包中，其他扩展 API 则由 javax.net 包提供，尤其是 `java.net.ssl`。\n\n#### 超文本传输协议 (HTTP)\n- URL 是关键的类，其原生支持 `http://`、`https://`、`ftp://`、`file://` 形式的 URL。\n\n\t```Java\n\t// 下载指定 URL 对应页面的内容\n\tURL url = new URL(\"http://www.baidu.com\");\n\ttry( InputStream in = url.openStream() ) {\n\t    File.copy(in, Paths.get(\"output.txt\"));\n\t} catch( IOException ex ) {\n\t    ex.printStackTrace();\n\t}\n\t\n\t// 深入低层控制，可使用 URLConnection 类\n\ttry {\n\t    URLConnection conn = url.openConnection();\n\t    String type = conn.getContectType();\n\t    int length = conn.getContentLength();\n\t    InputStream in = conn.getInputStream();\n\t} catch( IOException e ) {\n\t    // TODO\n\t}\n\t```\n\n- HTTP 定义了多个“请求方法”，客户端使用这些操作远程资源。这些方法有：`GET`、`POST`、`HEAD`、`PUT`、`DELETE`、`OPTIONS`、`TRACE`。\n\t- GET：用于取文档，不能执行任何副作用；\n\t- HEAD：与 GET 的作用一样，但不返回主体，用于检查 URL 对应的网址的页面是否有变化。\n\t- POST：把数据发给服务器处理。\n\n#### 传输控制协议 (TCP)\n- TCP具有下列特征 (特性)：\n\t- 基于连接：数据属于单个逻辑流 (连接)。\n\t- 保证送达：`三次握手`，如果未收到数据包，会一直重新发送，知道送达为止。\n\t- 错误检查：能检测到网络传输导致的损坏，并自动修复。\n\n- Java 使用 Socket 和 ServerSocket 类表示 TCP。\n\t- 例1：我们既要从客户端套接字中读取数据，也要把数据写入客户端套接字，且构建请求时要遵守 HTTP 标准 (RFC 2616)。\n\n\t```java\n\tString hostname = \"www.example.com\";\n\tint port = 80;\n\tString filename = \"/index.html\";\n\t\n\ttry(\n\t    Socket socket = new Socket(hostname, port);\n\t    BufferedReader from = new BufferedReader(\n\t        new InputStreamReader( socket.getInputStream() )\n\t    );\n\t    PrintWriter to = new PrintWriter(\n\t        new OutputStreamWriter( socket.getOutputStream() )\n\t    );\n\t) {\n\t    to.print(\"GET\" + filename + \n\t        \"HTTP/1.1\\r\\nHost:\" + hostname + \"\\r\\n\\r\\n\");\n\t    to.flush();\n\t    \n\t    for( String l = null; (l = from.readLine()) != null; ) {\n\t        System.out.println(l);\n\t    }\n\t}\n\t```\n\n\t- 例2：在服务器端，可能需要处理多个连入连接。编写一个服务器的主循环，使用 `accept()` 从操作系统中接收一个新连接。随后，要迅速把这个新连接传给单独的类处理，好让服务器主循环继续监听新连接。\n\n\t```java\n\t// 处理连接的类\n\tprivate static class HTTPHandler implements Runnable { \n\t    private final Socket socket;\n\t    HTTPHandler(Socket client) {\n\t        this.socket = client;\n\t    }\n\t    public void run() {\n\t        try(\n\t            Buffered in = new BufferedReader(\n\t                new InputStreamReader( socket.getInputStream() )\n\t            );\n\t            PrintWriter out = new PrintWriter(\n\t                new OutputStreamWriter( socket.getOutputStream() )\n\t            );\n\t        ) {\n\t            out.print(\"HTTP/1.0 200 /r/nContent-Type:text/plain\");\n\t            String line;\n\t            while( (line = in.readLine()) != null ) {\n\t                if( 0 == line.length()) break;\n\t                out.println(line);\n\t            }\n\t        } catch( Exception e ) {\n\t            // TODO\n\t        }\n\t    }\n\t}\n\t\n\t// 服务器主循环\n\tpublic static void main(String[] args) {\n\t    try{\n\t        int port = Integer.parseInt( args[0] );\n\t        ServerSocket ss = new ServerSocket(port);\n\t        for(;;) {\n\t            Socket client = ss.accept();\n\t            HTTPHandler handler = new HTTPHandler(client);\n\t            new Thread(handler).start();\n\t        }\n\t    } catch( Exception e ) {\n\t        // TODO\n\t    }\n\t\n\t}\n\t```\n\t\n#### 互联网协议 (IP)\n- 传输数据的最低层标准，抽象了把自己从 A 设备移动到 B 设备的物理网络技术。\n- 与 TCP 不同，IP 数据包不能保证送达，在传输路径中，任何过载系统都可能会丢掉数据包。\n- Java 使用 `DatagramSocket` 类实现这种功能。\n\n## 参考资料\n[[1] 周志明. 深入理解 Java 虚拟机 [M]. 第2版. 机械工业出版社, 2013](https://book.douban.com/subject/24722612/)  \n[[2] 技匠. 知道这20个正则表达式能让你少写 1,000 行代码. 2016. jianshu.com](https://www.jianshu.com/p/e7bb97218946)","tags":["java"],"categories":["Programme"]},{"title":"C 语言应试复习框架","url":"/2017/04/C-Programming-Design-Learning.html","content":"\n从标题中得知，本系列文章是围绕 “C语言” 展开学习的笔记总结。且目的很明确，笔记内容偏应试，适用于计算机等级考试、考研专业课 ( C语言 ) 等的复习使用。文章推崇总结性、对比性的学习方法，对于模糊的知识模块需自行查阅参考书目，深化理解以取得理想效果。\n\n<!-- More -->\n\n针对 C 语言程序，推荐几本辅导复习的书目：\n\n> 基础篇\n\n- `《谭浩强: C 语言程序设计》`: 必不可少的经典教程，权威性的标准答案源 ( 当然仅限于应试范围 )。例如，因讨论条件而异，如编译系统不同，部分题目的答案就具有了争议性。 \n- `《明解 C 语言》`: 入门基础教学。值得称赞的是，每个知识模块都附有实例，且实例的源码结构清晰，代码规范及注释到位，适合入门使用。\n\n> 进阶篇\n\n- `《征服 C 指针》`: C 语言的学习过程中，指针的运用是最大的难关。无论是在实际应用、应试中都是不可忽视的。对于作者前桥和弥，其一针见血的文风，在掌握一定基础之后，是深入了解 C 语言的一位不可多得 “良师益友” ( 书中有不少作者交谈式的独白，别有一番阅读风味 )。\n\n## 内容总览\n\n- [壹 程序设计和 C 语言](#壹-程序设计和-C-语言)\n- [贰 程序之魂：算法](#贰-程序之魂：算法)\n- [叁 简单的 C 语言程序设计](#叁-简单的-C-语言程序设计)\n- [肆 选择结构程序设计](#肆-选择结构程序设计)\n- [伍 循环结构程序设计](#伍-循环结构程序设计)\n- [陆 数组](#陆-数组)\n- [柒 函数](#柒-函数)\n- [捌 指针](#捌-指针)\n- [玖 构造类型：用户自己建立数据结构](#玖-构造类型：用户自己建立数据结构)\n- [拾 文件处理](#拾-文件处理)\n\n## 壹 程序设计和 C 语言\n### 计算机程序与语言\n- 程序：计算机能识别和执行的指令。  \n- 语言：人和计算机交流、人和计算机能识别的语言。\n- 计算机语言发展阶段：   \n\n| 机器语言 | 符号语言 | 高级语言 ( 面向过程、面向对象 ) |\n| :----: | :----: | :----: |\n| 0和1指针 | 英文、数字表示指令 | 人类自然语言和数字语言 |\n\n### C语言\n- 特点：\n\t- 语言简洁、紧凑，使用方便、灵活；\n\t- 运算符丰富 ( 单目、双目、三目运算符 )；\n\t- 数据类型丰富，其中包括：整型、浮点型、字符型、数组类型、指针类型、结构体类型、共用体类型、枚举型 )；\n\t- 结构体控制语句；\n\t- 直接访问物理地址 ( 对硬件直接操作 )；\n\t- 可移植性好.\n- 结构：\n\t- 以程序由一个或着多个 `源文件` 组成， 源文件中包括：  \n\t\t- 预处理命令 ( #include、#define、#typedef 等 )；\n\t\t- 全局声明 ( 全局变量、局部变量 )；\n\t\t- 函数定义 ( 参考函数原型 ).\n\t- 函数是 C 程序的主要组成部分。\n\t- 函数包括 `函数首部` 和 `函数体`。  函数体包括 `声明部分` 和 `执行部分`。\n\t- 程序总是从 main() 函数开始执行的。且 main() 函数有且仅有一个。\n\t- C 程序对计算机的操作有 C 语言完成。\n\t- 数据声明和语句必须有分号 ( 作为结束 )。\n\t- C 本身不提供输入输出语句。\n\n### 程序设计的任务\n- 程序设计的任务：\n\t- 问题分析；\n\t- 设计算法；\n\t- 编写程序；\n\t- 对源文件编辑、编译 ( \\*.obj ) 和连接 ( \\*.exe )；\n\t- 运行程序并分析结果；  \n\t- 编写程序文档.\n- 对于编译，预编译和连接的概念及比对： \n\t- 编译：检索语言错误；把源程序转为二进制形式的目标程序。\n\t- 预编译：通过预处理得到的信息与程序其他部分一起，组成完整的、可以正式编译的源程序。\n\t- 连接：与函数库相连接。\n\n\n## 贰 程序之魂：算法\n### 引入\n- 对数据的描述：所用数据的类型和数据的 `组织形式`。 \n\n\t> `组织形式`：数据结构，特定关系的数据元素的集合。\n\n- 对操作的描述：计算机进行操作的步骤 -- `算法`。\n- 从简理解：`数据结构 + 算法 = 程序`。\n\n### 算法\n- 概念：对特定问题求解的方法和描述。\n- 特征：\n\t- 有穷性：`有穷时间` 执行结束；\n\t- 确定性：算法 `唯一执行路径`，既相同输入执行相同路径；\n\t- 可行性：`有限次`；\n\t- 零或一个以上的 `输入`；\n\t- 一个或以上的 `输出`；\n- 要求：\n\t- 正确性；\n\t- 可读性；\n\t- 健壮性；\n\t- 效率与低存储量需求 ( 时间复杂度和空间复杂度 )  \n- 时间复杂度：\n\t- 时间复杂度：也称渐进时间复杂度，即算法执行时间的增长率和 f(n) 的增长率相同。  \n\t- 渐进时间复杂度：$T(n) = O(f(n))$  \n\t- $f(n)$ 为问题规模 n 的某个函数。  \n\t- 算法中的基本运算 ( 最深层循环内的语句 ) 的频度与 T(n) 同数量级。  \n- 空间复杂度：\n\t- 空间复杂度：算法所需存储空间的量度。  \n\t- 渐进空间复杂度：$S(n) = O(f(n))$  \n\t- 原地工作：额外空间相对输入的数据量来说是常数。\n\t\n### 三种基本结构和改进流程图\n- 三种基本结构：\n\t- 顺序结构；\n\t- 选择结构；\n\t- 循环结构：当型循环结构 / 直到型循环结构；\n- 改进的流程图：N-S 流程图\n\n### 结构化程序设计方法\n- 自顶向下；\n- 逐步细化；\n- 模块化设计：`分而治之`；\t`注意模块独立性`\n- 结构化编码；\n\n## 叁 简单的 C 语言程序设计\n### 数据的表现形式及运算\n#### 常量\n- 概念：程序运行期间，其值不能改变。\n- 类型：\n\t- 整型常量  \n\t- 字符常量 ( 与常变量作比对 **[ 注释1 ]** )\n\t\t- 普通字符  \n\t\t- 转移字符：`\\n`, `\\t`, `\\012` ( 8 进制 ), `\\x41` ( 16 进制 )\n\t\t- 符号常量：`#define PI 3.14159`\n\t- 实型常量\n\t\t- 10 进制小数形式：`3.14L`\n\t\t- 指数形式 ( 科学计数法 ):  \n\t\t\n\t\t\t```c\n\t\t\t8.7e-25;  // 正确\n\t\t\t8.7e-2.5; // 错误  \n\t\t\t87e+25; // 正确\n\t\t\t87e-25; // 正确\n\t\t\t```\n\t\t\n> [ 注释1 ] 符号常量与常变量的比较。\n\n| 符号常量 | 常变量 |\n| :---- | :---- |\n| 不占内存单元，预编译后符号不复存在 | 占存储单元 |\n| 不能重新赋值 | 不能改变其值 |\n\n#### 变量\t\n\n> 先定义，后使用。\n\n- 概念：程序运行期间，其值可以改变。\n- 包含属性：\n\t- 数据类型 ( 整型、浮点型、字符型 )\n\t- 存储类别 ( 自动变量，静态变量 )\n- 类型：\n\t- 常变量：变量存在期间其值不能改变。 `const int a = 10`  \n\t- 自动变量与静态变量  \n\t- 全局变量与局部变量  \n\t\n\t\t> 从存储位置、生存周期、作用区域讨论差异性。**[ 注释2 ]**\n\t\n- 标识符：一个对象的名称。除关键字外，字符、数字和下划线组成。且要求只能是字母或下划线开头。\t\n\n> [ 注释2 ] 局部变量与全局变量，自动变量与静态变量，内部函数与外部函数的比较。\n\n| 局部变量 | 全局变量 |  |\n| :---- | :---- | :---- |\n| 存放于动态存储区 | 存放于静态存储区 | 位置 |\n| 在定义函数内起作用 | 自定义位置开始，本文件起作用 | 作用域 |\n| 函数调用完释放内存 | 程序结束时释放内存 | 生存期 |\n\n- 静态的局部变量，存放于静态存储区，程序结束时释放内存。\n- 静态的全局变量，不是因声明 static，而误解全局变量才存放于静态存储区。\n- 局部变量，声明存储类型指变量存储区以及产生的生存期问题。  \n- 全局变量，声明存储类型指变量作用域的扩展问题。\n\t\n| 自动变量 | 静态变量 |\n| :---- | :---- |\n| 1. 声明该变量的语句块被执行结束释放内存(**栈**) | 1. 程序结束时才释放内存 |\n| 2. 每次函数调用时赋值 | 2. 保留上一步的赋值 |\n|  | 3. 在编时赋予初值0或'\\0' | \n\n- 对比 malloc() 函数分配的内存，需调用 free() 函数释放内存 ( **堆** )。\n\n| 内部函数 | 外部函数 (default) |\n| :---- | :---- |\n| 本文件内使用(不限位置) | 可供其他文件使用(不限位置) |\n| 定义：static 函数类型 函数名 | 定义：(extern) 函数类型 函数名 |\n\n#### 数据类型\n- 基本类型：\n\n|  | 关键字 | 字节 | 取值范围 |\n| :---- | :---- | :---- | :---- |\n| 整型 | int | 2/4 | $-2^{15}$ ~ $-2^{15}-1$ / $-2^{31}$ ~ $2^{31}-1$ |\n|      | unsigned int | 2/4 | 0 ~ $-2^{16}-1$ / 0 ~ $-2^{32}-1$ |\n| 字符型 | char | 1 | $-2^7$ ~ $2^7-1$ |\n|  | unsigned char | 1 | 0 ~ $2^8-1$ |\n| 单浮点 | float (有效小数：6) | 4 | -- |\n| 双浮点 | double (有效小数：15) | 8 | -- |\n\n- 关于基本类型的特别说明： \n\t- 字符是按其 ASCII 形式存储的。\n\t- 单浮点定义：`float a = 3.14f`\n\t- 双浮点定义：`double a = 3.14`\n\t- 长浮点定义：`long double a = 3.14L`\n- 派生类型：\n\t- 指针类型：指向函数的指针、多重指针\n\t- 数组类型：指针数组\n- 构造类型：[详情见第玖章：构造类型](#玖-构造类型：用户自己建立数据结构)\n\t- 结构体类型\n\t- 共同体类型\n\t- 枚举类型  \t\n- 类型转换：  \n\t- 低精度向高精度转换；  \n\t- 强制转换括号加类型；   `int a = (int)3.14`  \n\t- 多类型变量混合运算，取最高精度的类型；\n\n## 肆 选择结构程序设计\n### 关系运算符及其优先次序\n- 各类运算符的优先级：\n\t- 单目运算符 > 双目运算符 (算术、关系、逻辑) > 三目运算符\n\t- 优先级由高到低排序：  \n\t\t- 初等运算符：`()，[]，->，.`  \n\t\t- 单目运算符：`!，++，--，~`  \n\t\t- 算术运算符：`*，/，%`，`+，-`  \n\t\t- 关系运算符：`>，<，>=，<=`，`!=，==`  \n\t\t- 逻辑运算符：`&&，||`  \n\t\t- 条件运算符：`a > b : a : b`  \n\t\t- 赋值运算符：`a += 1`  \n\t\t- 逗号运算符：`(a,b)`  \t\n\t- 结合方式：\n\n\t\t> 同一级的运算符，由结合方式决定优先级。\n\t\t\n\t\t- 自左向右：`初等、单目、关系、逻辑、逗号运算符`\n\t\t- 自右向左：`条件、赋值运算符`  \n\t\n\t\t\t\n\n### 表达式\n- 算术表达式：先乘除模，后加减，再由“自左向右”原则运算。\n- 混合运算\n\t- 优先级：遵循各运算符的优先次序。\n\t- 结合性：算术运算符 (自左向右)；赋值运算符 (自右向左)。\n\t- 不同类型的混合运算：结果的类型为 **最高精度** 的数据类型。\n\n### 运算符与表达式\n- 关系运算符和关系表达式 ( a+b>c ) -> True or False?  \n\n\t> 0 表示假，!0 表示真。\n\n- 逻辑运算符和逻辑表达式\n\t- 逻辑运算：5 && 4 => 1；5 && 0 => 0；  \n\t- 按位逻辑：5 & 4 => 4；  \n\t\n\t\t> 关于逻辑运算与按位逻辑的比较：  \n\t\t> 优先级：按位逻辑运算 > 逻辑运算  \n\t\t> 按位逻辑的巧用：取最大 `max = a | b`；取最小 `min = a & b`    \n\n- 条件运算符和条件表达式：`a > b ? a : b`\n\n### 选择结构的嵌套 \n- `if` 语句只有两个分支可供选择，`else` 总是与它上面最近的未配对的 `if()` 配对。\n\n\t```c\n\tif(express1){\n\t\tif(express2){\n\t\t\t...\n\t\t} else {\n\t\t\t...\n\t\t}\n\t} else {\n\t\tif(express3){\n\t\t\t...\n\t\t} else {\n\t\t\t...\n\t\t}\n\t}\n\t```\n\t\n- `switch` 语句实现多分支选择结构。\n\n\t```c\n\tswitch(express1){ // 整型、字符型\n\t\tcase 常量/常量表达式:\n\t\t\t语句1;\n\t\t\tbreak; // break 为拦截作用\n\t\tcase 常量/常量表达式:\n\t\t\t语句2;\n\t\t\tbreak;\n\t\tdefault: 语句3;\n\t}\n\t```\n\n## 伍 循环结构程序设计\n- `while` 语句实现：\n\n\t```c\n\texpress1;\n\twhile(express2){\n\t\texpress3;\n\t\t...\n\t}\n\t```\n\n- `for` 语句实现循环：\n\n\t```c\n\tfor(express1; express2; express3){\n\t\t...\n\t}\n\t```\n- `do...while()` 语句实现循环：\n\n\t```c\n\texpress1;\n\t\n\tdo{\n\t\texpress3;\n\t} while(express2);\n\t```\n\n- `break`、`continue` 与 `goto` 语句：\n\t- break：从循环体内跳出循环体。多层嵌套循环，跳出相邻一层循环。\n\t- continue：提前结束本次循环。\n\t- goto：跳出多层循环。\n\n\n## 陆 数组\n### 概念\n- 一组有序数据的集合。\n- 数组中每一元素同属一个数据类型。\n- sname[0] <=> *(p+0) <=> 第一个数组元素。  \n\n### 定义\n#### 一维数组\n- 定义：\n\t- `类型符 数组名[常量表达式]`：正确的定义方式。\n\t- `类型符 数组名[变量]`： 错误的定义方式，不能为变量。\n\n- 初始化：\n\n\t```c\n\tint array[] = {1, 2, 3, 4, 5};  \n\tin array[5] = {0}; // 5个元素都为 0。\n\t```\n\n- 引用：\n\n\t```c\n\tint *p = &array[0];\t// 等同于 int *p = array\n\tp++;\t// 指针运算\n\t*(p+i);\t// 取第i位元素\n\t```\n\n#### 二维数组\n- 定义：类型符 数组名[常量表达式][常量表达式]\n\n- 初始化：\n\n\t```c\n\tint array[2][2] = { {1, 2}, {3, 4} };\n\tint array[2][2] = { 1, 2, 3, 4 };\n\tint array[][2] = { {1, 2}, {3, 4} };\t// 既只允许最外层元素个数定义时为空\n\t\n\tint array[][2] = { {0}, {3, 4} };\t// 正确 \n\tint array[][2] = { {}, {3, 4} };\t// 错误\n\t```\n\t\n- 引用：\n\n\t```c\n\tint num = array[1][1];\n\tint *p = array;\n\t*(*(p+j)+j); // 等同于array[i][j];\n\t```\n\n#### 字符数组\n- 定义：`char array[10]; <=> int array[10];`\n\n\t> 字符型数组是以整型形式存放的 ( ASCII )。\n  \n- 初始化：\n\t- 字符串常量不可以数组形式取具体位置进行元素修改。\n\t- ( array == \"Hello\" ) => True or False ? \n\t\n\t\t> False，array 与字符串常量比较的是内存地址。\n\n\t\t```c\n\t\tchar array[0] = 'A';\n\t\t\n\t\tchar array[] = {\"Hello\"};\n\t\t// 字符数组的存储情况：| H | e | l | l | o | \\0 |\n\t\t// sizeof() -- 6\n\t\t// strlen() -- 5\n\t\t\n\t\tchar array[] = {'H', 'e', 'l', 'l', 'o'};\n\t\t// sizeof() -- 5\n\t\t// strlen() -- 5\n\t\t\t\n\t\tint array[] = {\"Hello\"};\n\t\t// sizeof() -- 4\n\t\t// strlen() -- 1\n\t\t\t\n\t\tint array[] = {'H', 'e', 'l', 'l', 'o'};\n\t\t// sizeof() -- 20\n\t\t// strlen() -- 4\n\t\t\t\n\t\tchar *array = \"Hello\"; // 字符串常量\n\t\t```\n\n- 引用：\n\t- 若字符数组中，存在 '\\0' 两个或以上，系统则以第一次出现的位置提前终止字符输出。  \n\t- stdin 和 gets() 搭配，可获得换行符、空格等字符。 ( 需结束标记符来终止输入 )\n  \n\t\t```c\n\t\tscanf(\"%c\", &array[0]);\n\t\tprintf(\"%c\", array[0]);\n\t\t\n\t\tscanf(\"%s\", array);\n\t\tprintf(\"%s\", array);\n\t\t```\n\n- 应用：\n\t- gets(字符数组) -- 输入一字符串到字符数组中\n\t- puts(字符数组) -- 输出一字符串到终端\n\t- strlen(字符数组) -- 测一字符串的实际长度\n\t- strcat(char \\*src1, const char \\*src2);\n\t\n\t\t> 数组src2后接于src1，src1中的'\\0'被覆盖。且数组src1必须足够大，以容纳数组src2。\n\t\n\t- strcpy(char \\*src1, const char \\*src2);\n\t\n\t\t> 数组src1必须足够大，以容纳数组src2。\n\t\n\t- strcmp(const char \\*src1, const char \\*src2);\n\t\n\t\t> 实际为ASCII的比较，其返回值为 <0、==0，>0 的情况。\n\t\n\t- strlwr(字符串) -- 将字符串中大写字母转为小写字母\n\t- strupr(字符串) -- 将字符串中小写字母转为大写字母\n\t- atoi(字符串) -- 字符串转int型\n\t- atol(字符串) -- 字符串转long型\n\t- atof(字符串) -- 字符串转double型   \n\n\t\t> 有几点需要特别声明：   \n\t\t> 1) 字符串处理函数需加入头文件：`#include <string.h>`.   \n\t\t> 2) 需掌握字符串函数自定义方法实现。  \n\t\t> 3) 大部份字符串处理函数多数以标记量'\\0'为临界点，若字符数组中含两个或或以上，需注意实际的结果。  \n\t\t> 4) 引用atoi()、atol()、atof()函数需引用`#include <stdlib.h>`\n\n## 柒 函数\n### 为什么要用函数\n- 模块化程序设计：每一函数实现一特定的功能，函数的名称既反映功能。\n- 更好地代码复用：使用库函数；使用自己编写的函数。 \n\n\t> `代码复用`：减少重复编码程序段的工作量。对于所有完成相同功能的组件，应抽象出一个接口，它们都实现该接口。具体在 Java 中，所有完成相同功能的组件都 `实现该接口` 或 `从该抽象类中的继承`。\n\t\n### 定义函数  \n\n> 建立存储空间的声明。\n\n- 定义函数：`函数返回类型` `函数名` `函数参数` `函数体` (变量定义、声明，执行语句)\n\t- 函数返回类型：基本数据类型 / void型；  \n\t- 函数名：驼峰式命名法；  \n\t- 函数参数：实参、形参.  \n\n### 函数声明\n\n> 不需要建立存储空间的声明。\n\n- 函数原型 (Prototype)：函数返回类型、函数名、参数类型、参数个数、参数顺序。\n- 函数声明的方法：\n\t- 使用函数原型；\n\t- 同一源文件，在调用该函数的前面定义 (可打包到自定义头文件中)。\n\n### 函数调用\n- 嵌套调用、递归调用 ( 直接或间接调用该函数本身 )。\n- 实参和形参：\n\t- 概念：\n\t\t- 实参：常量、变量或表达式、函数 (返回值)  \n\t\t- 形参：函数调用期间临时分配内存，值从实参中获得，调用结束后释放内存空间。\n\t- 实质：值传递、地址传递\n\n\n## 捌 指针\n### 指针是什么\n- 指针变量：保存变量地址的变量。\n- 指针类型：\n\t- 指针类型的变量：存放地址\n\t- 指针类型的值：对应内存地址存放的值\n\t  \n\t\t> 在 `swap(int \\*a, int \\*b);` 的案例中可以形象说明两者的区别。\n\n### 指针移动 (运算：加、减)\n- 对指针加一、减一运算，即地址会增加或减少一单位长度。\n- 单位长度具体指当前指针所指向数据类型的所占空间大小。\n\n### 指针类型\n#### 空指针\n- 确保没有指向任何一个对象的指针，通常以宏定义 NULL(0) 表示空指针的常量值。\n- 关于 `NULL`、`0`和 `'\\0'`，大部分情况都为零。特别地：\n\n\t```c\n\tint *p = 0;\t// 正确，编译器将指针指向内存地址为 0 处。 \n\tint *p = 3;\t// 错误，赋值的数据类型不相符。\n\t```\n\n#### 指针类型的派生\n- 指向函数的指针：\n\n\t```c\n\tvoid (*func(int));\n\t```\n\n- 指向数组的指针 ( `多重指针` )：\n\n\t```c\n\tint (*p)[5];\n\t```\n\n#### 数组类型的派生\n- 指针数组：\n\n\t```c\n\tint *p[5]; // 存放5个指向int类型的指针。\n\t```\n\n- 用英语解读各种各样的C语言声明：\n\n| C语言 | 英语表示 | 中文表示 |\n| :---- | :---- | :---- |\n| int huge; | huge is int | hoge是int型 |\n| int huge[10]; | huge is array[10] of int | hoge是int型的数组 |\n| int huge[2][4]; | huge is array[2] of array[4] of int | hoge是int型的数组的数组 |\n| int \\*huge[10]; | huge is array[10] of point to int | hoge是指向int型的指针的数组(存放指针变量) |\n| int (\\*huge)[10]; | hoge is pointer to array[10] of int | hoge是指向int型的数组的指针 |\n| int func(int a); | func is function(int a) returning int | func是返回int型的函数 |\n| int (*func)(int a); | func is pointer to function(int a) returning int | func是指向返回int型值的函数的指针 |\n\n### 指针的应用\n#### 指针与数组\n- 一维：\n\n\t```c\n\tp[i]\t// 等同于 *(p+i)\n\ti[p]\t// 等同于 *(i+p)\n\t&p[i]\t// 等同于 (p+i)，即第i个元素的地址\n\t```\n- 二维：\n\n\t```c\n\thuge[i]\t\t// 等同于 *(huge+i)，即第i行的首地址\n\t*(huge+i)[j]\t// 等同于 *(*(p+j)+j)，即 huge[i][j]\n\t```\n\n#### 指针与字符串\n##### 字符指针变量\n- 定义：\n\n\t```c\n\tchar *array = \"World\";\n\tarray = \"hello\";\t// 改变指向\n\t\t\n\tchar array[] = \"Hello\";\n\tarray = \"World\";\t// 错误的做法\n\t\n\tchar *array = \"Hello World\";\n\tarray += 6;\t\t// 改变指向 (首地址改变)\n\n \t```\n\n##### 字符数组\n- 定义: `int array[] = \"Hello\"`\n\n- 使用：`printf(\"%c\", array[0])`\n\n\t> 字符指针变量的值是不能改变的，即已是字符串常量。\n\n\t```c\n\tchar *array = \"Hello\";\n\tarray[0] = 'W';\n\t```\n\n#### 指针与函数\n##### 作为参数\n即传递的是指向初始元素的指针。\n\n- 数组名作函数参数：\n\t- `int func( int array[] )` \n\t- `int func( int \\*array )`\n- 多维数组作函数参数：\n\t- `int func( int (\\*huge)[10] )`\n\t- `int func( int huge[2][4] )`\n- 指向函数的指针作函数参数：`int func( int (\\*p)(int) )` \n- 指针数组作main函数形参：`int func( int argc, char \\*argv[] )`\n\t\n\t> argv: 文件名 + 其他参数\n\t\n- 字符指针作函数参数。\n\n##### 作为返回值\n返回指针值的函数，即返回的是地址。比如，返回的指针指向结构体变量、字符变量等。\n\n## 玖 构造类型\n> 构造类型：用户自己建立数据结构\n\n### 结构体类型\n- 定义：\n\n\t```c\n\tstruct Name {\n\t\tint num;\n\t\tchar word[59];\n\t} *p, name[5];\n\t```\n\n- 初始化：所有成员一起赋值。\n\n- 使用：\n\n\t```c\n\tname[i].num;\n\tp->word[i];\n\t(*p).num;\n\t\n\tstruct Name *tmp;\n\ttmp = name;\n\t(tmp++)->num;\t// 先'++'操作，后'->'操作\n\t```\n\t\n- 大小：成员变量所占内存长度总和。\n\n### 共用体类型\n- 定义：\n\n\t```c\n\tunion Name {\n\t\tint num;\n\t\tdouble digital;\n\t\tchar word;\n\t} *p, name[5];\n\t```\n\n- 初始化：只允许给一个成员变量赋值。\n\n\t```c\n\tunion Name tmp = {10};\n\tunion Name tmp = {.word = 'Y'};\n\tt.digital = 2.0;\n\tt.word = 'N';\t// 最终的赋值\n\t```\n\n- 使用：\n\n\t```c\n\tname[i].num;\n\tp->word[i];\n\t(*p).num;\n\t```\n\t\n- 大小：成员变量所占内存长度最大者。\n\n\t> 关于结构体、共用体类型的内存长度问题，遵循 4 字节倍数的原则进行内存布局对齐。  \n\t\n\t```c\n\tsizeof(struct Name) // ==> 64 (63)  \n\tsizeof(union Name) // ==> 4 (4)\n\t```\n\n### 枚举类型\n- 定义：\n\t\n\t```c\n\tenum Week {\n\t\tsun, mon, tue, wed, thu, fir, sat // 默认参数从0开始\n\t} week;\n\t```\n\t\n- 初始化：\n\n\t```c\n\tenum Week {\n\t\tmon = 1, tue = 2, wed = 3, \n\t\tthu = 4, fir = 5, sat = 6，sun = 7 // 默认参数从 0 开始\n\t} week;\n\t```\n\n- 使用：`week.mon`;\n\n### Typedef 声明新类型名\n- 含义：引入变量别名，而不是另外地给变量分配空间。\n- 使用：\n\t\n\t```c\n\ttypedef int Integer;\n\t// 若编译器中，int 为 2 字节，满足移值需求可以 long 型替换。\n\ttypedef long Integer;\t\n\tInterger num = 1;\n\t```\n\n- 与 `#define` 宏定义的区别：\n\t- `#typedef`：编译阶段处理。\n\t- `#define`：预编译阶段处理，实质是字符串替换。\n\t\n## 拾 文件处理\n### 文件与流\n- `stdin`：标准输入流，用于读取普通输入的流，在大多数环境中为键盘输入。scanf() 与 getchar() 等函数会从这个流中读取字符。\n- `stdout`：标准输入流，用于写入普通输入的流，在大多数环境中为输出至显示器界面。printf()、puts() 与 putchar() 等函数会向这个流写入字符。\n- `stderr`：标准错误流，用于写出错误的流，在大多数环境中为输出至显示器界面。\n\n### 文件分类\n- ASCII 文件 ( 文本文件 )：每一字节存放一字符的 ASCII 代码。\n- 二进制文件：\n\t- 优：节约存储空间\n\t- 劣：精度有限\n\n\t\t> 例如：整数 10000，ASCII 形式存储空间为 5 字节，二进制形式存储空间为 4 字节。\n\t\n### 文件类型指针：FILE 型\n- 需引用 `#include <stdio.h>`\n\n\t> 指向文件的指针变量并不是指向外部介质上的数据文件开头，而是指向内存中的文件信息区的开头。\n\n### 打开文件\n- 原型：`FILE *fopen(const char *filename, const char *mode);`\n- 定义：`FILE *fp = fopen(\"example.txt\", \"r\");`\n\n| 文件类型 | 文本文件 | 二进制文件 |\n| :---- | :---- | :---- |\n| 模式 | r   w   a | rb   wb   ab |\n|  | 只读；只写(文件存在，则长度清零)；追加 | 只读；只写(文件存在，则长度清零)；追加 |\n|  | r+   w+   a+ | rb+   wb+   ab+ |\n|  | 读和写(打开文件)；读和写(建立文件；文件存在，则长度清零)；读和写(打开文件) | 读和写(打开文件；文件存在，则长度清零)；读和写(建立文件)；读和写(打开文件) |\n\n### 关闭文件\n- 原型：`int fclose(FILE *stream);`\n\t- 返回值 ( True：0；False：EOF(-1) )  \n\t- 数据存储的过程：数据 --> 缓存区 (充满) --> 文件\n\t- 若不关闭文件，将会造成数据丢失。 \n\t- 若突然关闭文件，缓存区传输到文件的过程给中断，造成数据丢失。\n\n### 顺序读写数据文件\n- 格式化读取文件：\n\n\t```c\n\tint fscanf(FILE *stream, const char *format, ...);\n\t// 返回值：\n\t// Ture - 返回成功赋值的输入项数\n\t// False - 返回文件结束标记EOF(-1)\n\t\n\t// 使用实例\n\tfscanf(fp, \"%s%lf%lf\", name, &height, &weight);\n\t```\n\t\n- 格式化写入文件：\n\n\t```c\n\tint fprintf(FILE *stream, const char *format, ...);\n\t// 返回值：\n\t// Ture - 返回发送的字符数\n\t// False - 返回文件结束标记EOF(-1)\n\t\n\t// 使用实例：获得当前运行时间，并存入文本中\n\ttime_t current = time(NULL);\n\tstruct tm *timer = Localtime(&current);\n\t\n\t// 将日历时间time_t型的值转换为分解时间tm结构体类型的值\n\t// 其中，tm结构体为：\n\tstruct tm {\n\t\tint tm_sec;\t// 秒(0 - 61)\n\t\tint tm_min;\t// 分 (0 - 59)\n\t\tint tm_hour;\t// 时 (0 - 24)\n\t\tint tm_mday;\t// 日 (1 - 31)\n\t\tint tm_mon;\t// 月 (0 - 11)\n\t\tint tm_year;\t// 从1900至今，经历了多少年\n\t\tint tm_wday;\t// 星期 (0 - 6)\n\t\tint tm_yday;\t// 经历天数 (从1月1日计起)\n\t\tint tm_tm_isdst;\t// 夏时令 (夏季时间将提前1小时)\n\t};\n\t\n\tfprintf(fp, \"%d %d %d %d %d\", \n\t\ttimer->tm_year + 1900, timer->tm_mon + 1,\n\t\ttimer->tm_day, timer->tm_hour, \n\t\ttimer->tm_min, timer->tm_sec);\n\tfclose(fp);\n\t```\n\n- 读入／写入一个字符：\n\n\t```c\n\tint fgetc(FILE *stream);\t// 读入一个字符\n\t\n\tint fputc(FILE *stream);\t// 写入一个字符\n\t// 返回值：\n\t// Ture - 返回所读的字符数\n\t// False - 返回文件结束标记EOF(-1)\n\t```\n\t\n- 用二进制方式向文件读写一组数据：\n\n\t```c\n\tsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\n\t// 从ptr指向的数组中将最多nmemb个长度为size的元素写入stream指向的流中。\n\t\n\tsize_t fread(const void *ptr, size_t size, szie_t nmemb, FILE *stream);\n\t// 从stream流中读取nmemb个长度为size的元素写入到ptr数组。\n\t```\n\n### 随机读写数据文件\n#### 文件位置标记及其定位\n- 文件位置标记：文件头、读写当前位置、文件尾。\n- 文件位置标记的定位：`fseek(文件类型指针, 位移量, 起始点);`。\n\t- 文件开始位置 -> SEEK_SET -> 0  \n\t- 文件当前位置 -> SEEK_CUR -> 1  \n\t- 文件末尾位置 -> SEEK_END -> 2  \n\n#### 随机读写\n- 结合 `fseek()` 与 `fread()` 函数实现。例如，读取第 1，3，5，7，9 个学生数据并输出。\n\n\t```c\n\tfor(i = 0; i<10; i+=2){\n\t\tfseek(fp, i*sizeof(struct Student), 0);\n\t\tfread(&student[i], sizeof(struct Student), 1, fp);\n\t}\n\t```","tags":["C","考试"],"categories":["Programme"]}]