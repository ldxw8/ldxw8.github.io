[{"title":"论文 | 基于根因分析的报警聚类算法","url":"%2F2019%2F08%2Froot-cause-analysis-alarm-clustering.html","content":"\n{% note default %}\n原文：Clustering intrusion detection alarms to support root cause analysis\n作者：Klaus Julisch\n来源：ACM Transactions on Information and System Security, 2003, 6(4):443-471.\n{% endnote %}\n\n## 背景\n- 系统出现故障时，运维人员一般先查看错误日志定位故障原因。\n- 业务流量小、逻辑复杂度低时，应用出现故障时错误日志一般较少，运维人员根据错误日志迅速定位到问题。但随着业务逻辑的迭代，系统接入的依赖服务不断增多、引入的组件不断增多，当系统出现故障时，`错误日志的量级急剧增加`。极端情况下更甚出现 \"疯狂报错\" 的现象，这时错误日志的内容会存在 `相互掩埋`、`相互影响` 的问题，运维人员面对报错一时难以理清逻辑， 失去焦点，没能第一时间解决最核心问题。\n- 若在报警流出现时，通过处理程序将报警进行聚类，整理出一段时间内的报警摘要。运维人员就可以在摘要信息的帮助下，先对当前的故障有一个大致的轮廓，再结合技术知识与业务知识定位故障的根本原因。\n- 围绕上面描述的问题，以及对于报警聚类处理的分析假设，本文主要做了以下事情：  \n\t- `选定算法`：选定聚类算法，简单描述算法基本原理，并给出针对报警日志聚类的一种具体实现方案。  \n\t- `验证算法`：在分布式业务服务的系统下构造了三种不同实验场景，验证了算法的效果，并且对算法的不足进行分析阐述。\n\n<!-- More -->\n\n## 目标\n- 我们希望这些泛化报警既要具有很强的概括性，同时尽可能地保留细节。这样运维人员在收到报警时，便能快速定位故障的大致方向，从而提高故障排查的效率。\n- 对一段时间内的报警进行聚类处理，将具有相同根因的报警归纳为能够涵盖报警内容的泛化报警，最终形成仅有几条泛化报警的报警摘要，如图 1-1 所示。\n\n\t![](/images/illustration/Paper/2019/alarm-clustering_1-1.jpg)\n\t<center>图 1-1 通过聚类算法泛化报警日志</center>\n\n## 概述\n- 如图 1-2 所示，文章主要分三个部分阐述：提取报警特征、算法实现以及展示报警摘要。\n- 首先，是根据根因分析提取报警关键特征，并生成报警信息的泛化层次结构。其次，则是从泛化层次结构中计算得不同报警对象之间的不相似度度量，以确定最具象化的泛化表示、最大程度涵盖原始报警集合的泛化层次结构。最后，经由聚类算法获得泛化报警簇群，以簇群代表某一类报警信息。\n\n\t> 聚类算法还涉及 `min_size` 与 `聚类停止条件` 的调参问题，详情见下文描述。\n\n\t![](/images/illustration/Paper/2019/alarm-clustering_1-2.png)\n\t<center>图 1-2 文章的章节布局</center>\n\n## 正文\n### 泛化初探\n- 将报警信息抽象表达、逐层分解，形成类似于 `树结构` 或者 `有向无环图` 的泛化层次结构。\n\n\t如图 1-3 所示，可将服务器的报警抽象为 “全部服务器 网络调用 故障”，也可以抽象为 “server_room_a 服务器 网络调用 产品信息获取失败” 和 “server_room_b 服务器 RPC 获取产品类型信息失败”。\n\n\t> 前者泛化范围较广、抽象层次较高，细节越少；后者包含的范围较小、抽象层次低，则包含的无用信息可能越多。当然不局限于一种层次关系，你也可以用其他层次的抽象来表达这个报警集群。\n\n\t![](/images/illustration/Paper/2019/alarm-clustering_1-3.jpg)\n\t<center>图 1-3 服务器的报警泛化初探</center>\n\n### 算法定义\n- 为了确定报警聚类泛化的程度，我们需要先了解一些定义：\n\t- `属性` ( Attribute )：构成报警日志的基本信息，如机器、环境、时间等，记作 $A_i$。\n\t- `值域` ( Domain )：属性 $A_i$  的值域 ( 取值范围 )，记作 $Dom(A_i)$。\n\t- `泛化层次结构` ( Generalization Hierarchy )：对于每个属性 $A_i$，都有一个对应的泛化层次结构，记作 $G_i$。\n\t- `不相似度` ( Dissimilarity )：定义为 $d(\\mathcal{a_1}, \\mathcal{a_2})$。它接受两个报警 $\\mathcal{a_1}$、$\\mathcal{a_2}$ 作为输入，并返回一个数值量，表示这两个报警不相似的程度。当 $d(\\mathcal{a_1}, \\mathcal{a_2})$ 较小时，表示报警 $\\mathcal{a_1}$ 和报警 $\\mathcal{a_2}$ 越相似，相反越大则越不相似。为了计算不相似度，则需要用户预先定义好报警信息的 `泛化层次结构`。\n- 计算 $d(\\mathcal{a_1}, \\mathcal{a_2})$，我们先定义两个属性值的不相似度：令 $x_1$、$x_2$ 为 $\\mathcal{a_1}$、$\\mathcal{a_2}$ 某个属性 $A_i$ 的两个不同的值，$x_1、x_2 \\in Dom(A_i)$。\n\t-  在属性 $A_i$ 的泛化层次结构 $G_i$ 中，通过一个公共点父节点 $p$ 连接 $x_1$、$x_2$ 的最短路径长度。$\\delta(·,·)$ 表示两节点的最短路径长度，把它们累加起来以表示两个属性的不相似度。\n\n\t$$\n\td(x_1, x_2) := \\min \\left\\{\n\t\t\\delta(x_1, p) + \\delta(x_2, p) \\mid \n\t\tp \\in G_i, x1 \\trianglelefteq p, x2 \\trianglelefteq p\n\t\\right\\}\n\t\\tag{1}\n\t$$\n\t\t\n\t> 举例：在图 1-3 的泛化层次结构中：  \n\t> d(\"Thrift\", \"Pigeon\") = d(\"RPC\", \"Thrift\") + d(\"RPC\", \"Pigeon\") =  1 + 1 = 2  \n\t\t\n\t- 接下来把警报的所有属性都加入计算，累加报警的所有属性的不相似度，即可表示报警的不相似度。对于两个报警 $\\mathcal{a_1}$、$\\mathcal{a_2}$，其不相似度的计算公式为：\n\n\t$$\n\td(\\mathcal{a_1}, \\mathcal{a_2}) := \n\t\t\\sum_{i=1}^n d(\\mathcal{a_1}[A_i], \\mathcal{a_2}[A_i])\n\t\\tag{2}\n\t$$\n\t\t\n\t> 举例：参考图 1-3 的泛化层次结构：  \n\t> $\\mathcal{a_1}$ = (\"server_room_b-biz_tag-offline02\", \"Thrift\")     \n\t> $\\mathcal{a_2}$ = (\"server_room_a-biz_tag-online01\", \"Pigeon\")  \n\t> \n\t> $d(\\mathcal{a_1}, \\mathcal{a_2})$ =  \n\t> d(\"server_room_b-biz_tag-offline02\", \"server_room_a-biz_tag-online01\") +   \n\t> d(\"Thrift\", \"Pigeon\")  \n\t> \n\t> $d(\\mathcal{a_1}, \\mathcal{a_2})$ =  \n\t> d(\"server_room_b-biz_tag-offline02\", \"服务器\") +  \n\t> d(\"server_room_a-biz_tag-online01\", \"服务器\") +   \n\t> d(\"RPC\", \"Thrift\") +  \n\t> d(\"RPC\",  \"Pigeon\")  \n\t> = 2 + 2 + 1 + 1 = 6\n\n- 对于某个报警聚类来说，我们如何获得既能够涵盖它的集合又有最具象化的泛化表示？回答问题前，我们预先完成一些定义：\n\t- 一个警报对象是 n 维属性空间 $dom(A_1) \\times dom(A_2) ... \\times dom(A_n)$ 上的元组，记作 $\\mathcal{X}_{i = 1}^{n} Dom(A_i)$。\n\t- 我们用 $C$ 表示报警集合，$\\mathbf{g}$ 是 $C$ 的一个泛化表示，满足 $\\forall \\mathcal{a} \\in C, \\mathcal{a} \\trianglelefteq \\mathcal{g}$。\n\n\t\t> 以报警集合 {\"dx-trip-package-api02 Thrift get deal list error\", \"dx-trip-package-api01 Thrift get deal list error\"} 为例，`dx服务器 thrift调用 获取产品信息失败` 是一个泛化表示，`服务器 网络调用 获取产品信息失败` 也是一个泛化表示。\n\t\t\n\t- 定义 $d_i := d(\\mathcal{g}, a_i), i = 1, 2$，$d_i$ 表示在警报 $a_i$ 中需要多少个属性即可让 $\\mathcal{g}$ 泛化表示 $\\mathcal{a_i}$。当 $d_1 + d_2$ 越小，$\\mathcal{g}$ 从警报 $\\mathcal{a_1}、\\mathcal{a_2}$ 中获得泛化表示的步数越少，说明 $\\mathcal{g}$ 对 $\\mathcal{a_1}、\\mathcal{a_2}$ 覆盖越充分。相反，当 $d_1 + d_2$ 越大，由于过于抽象或者未能有效捕获警报 $\\mathcal{a_1}、\\mathcal {a_2}$ 的详细信息，说明当前 $\\mathcal{g}$ 的覆盖效果不好。\n\n\t- 因此，明确我们的目标是计算得 `最小化的报警不相似度` 以获得 `最具象化的泛化表示`。为了解决这个问题，定义以下两个指标：\n\n\t$$\n\t\\overline{d} (\\mathcal{g}, \\mathcal{C}) := \n\t\t1 / | \\mathcal{C} | \n\t\t\\times \\sum _{\\mathcal{a} \\in C} d (\\mathcal{g}, \\mathcal{a})\n\t\\tag{3}\n\t$$\n\t\t\n\t$$\n\tH(C) := \\min \\left\\{\n\t\t\\overline {d}(\\mathcal{g} , C) \\mid\n\t\t\\mathcal {g} \\in \\mathcal{X}_{i = 1}^{n} Dom(A_i),\n\t\t\\forall \\mathcal {a} \\in C : \\mathcal{a} \\trianglelefteq \\mathcal{g}\n\t\\right\\} \\tag{4}\n\t$$\n\t\n\t> $H(C)$ 代表一个报警簇群 $C$ 的相异性度量，$\\overline{d} (\\mathcal{g}, \\mathcal{C})$ 代表一个报警簇群的平均相异性度量。$H(C)$ 值最小时对应的 $\\mathcal{g}$ 就是我们要找的最适合的泛化表示，我们称 $\\mathcal{g}$ 为 $C$ 的覆盖。\n\n- 基于以上的概念，将报警日志聚类问题定义为：\n\t- 定义 $L$ 为一个日志集合，$G_i(i = 1, 2, 3……n)$ 为属性 $A_i$ 的泛化层次结构，$\\mathcal{min\\_size} \\in \\mathbb{N}$ 为一个预设的常量。\n\t- 目标是找到一个 $L$ 的子集 $C$，簇群中元素数量满足 $|C| \\geq \\mathcal{min\\_size}$，且 $H(C)$ 值最小。\n\t\n\t\t> $\\mathcal{min\\_size}$ 是用来控制抽象程度的，即一个簇群至少包含的元素个数。若 $\\mathcal{min\\_size}$ 与 $L$ 集合的大小一样，那么我们只能使用终极抽象了；若 $\\mathcal{min\\_size} = 1$ ，则每个报警日志是它自己的抽象。\n\t\t\n\t- 找到一个聚类之后，我们可以去除这些元素，然后在 $L$ 剩下的集合里找其他的聚类。\n\n- 不幸的是，这是个 NP 完全问题 ( [分团问题](https://en.wikipedia.org/wiki/Clique_problem) )。因此论文 $^{[2]}$ 提出了一种启发式算法，该算法满足 $|C| \\geq \\mathcal{min\\_size}$，使 $H(C)$ 值尽量小 ( 并不一定要最小化的 $H(C)$  )。\n\n### 算法描述\n- 启发式 Alarm-Clustering 算法：面向属性归纳的改进算法 (Attribute-oriented induction, AOI) $^{[3]}$。\n\n\t> `面向属性归纳的改进算法`：1) 对比经典的 AOI 算法更保守地概括属性；2) 使用了类似基于密度聚类的聚类终止条件。  \n\n\t- `Step.01`: 算法假设所有的泛化层次结构 $G_i$ 都是树，这样每个报警集群都有一个唯一的、最顶层的泛化结果。\n\t- `Step.02`: 将 $L$ 定义为一个原始的报警日志集合，算法选择一个属性 $A_i$，将 $L$ 中所有报警的 $A_i$ 值替换为 $G_i$ 中 $A_i$ 的父值，通过这一操作不断对报警进行泛化。\n\t- `Step.03`: 持续步骤 2 的操作，直到找到至少可以将原始报警泛化为报警簇群的最小值  $\\mathcal{min\\_size}$。\n\t- `Step.04`: 输出步骤 3 中找到的报警。\n\n- 算法的伪代码描述： \n\t- `Input`：(报警日志集合 $L$，$\\mathcal{min\\_size}$，每个属性的泛化层次结构 $G_1、...、G_n$)\n\t- `Output`：(泛化报警日志集合 $L$，$\\mathcal{min\\_size}$，每个属性的泛化层次结构 $G_1、...、G_n$)\n\n\t```r\n\t/* 将报警日志集合 L 保存至表 T，且表中每一列代表报警的一项属性 Ai */\n\tT := L\n\t\t\n\t/* count 是统计当前报警记录数量的变量 (可理解为报警簇群的大小)\n\t * count 初始化为 1 可理解为当前报警为一个仅且包含它本身的簇群 */\n\tfor all alarms a in T do a[count] = 1; \n\t\t\n\t/* 开始对报警进行泛化操作 */\n\twhile ∀a∈T:a[count] < min_size do {\n\t\t\n\t\t// Step.1 使用启发算法选择一个属性 Ai\n\t\t\n\t\t// Step.2 对 L 中所有报警进行泛化：\n\t\t// 即把报警的属性 Ai 替换为泛化层次结构 Gi 中 Ai 的父值\n\t\tfor all alarms a in T do {\n\t\t\ta[Ai] := parent of a[Ai] in Gi;\n\t\t}\n\t\t\t\n\t\t// Step.3 如果 a[Ai] == a’[Ai], i = 1, 2, ..., n\n\t\t// 即报警的所有属性 Ai 都相同\n\t\twhile identical alarms a, a' exist do {\n\t\t\t// 合并相同警报于同一个泛化报警 a 中并更新泛化警报的计数\n\t\t\tSet a[count] := a[count] + a'[count];\n\t\t\t// 完成统计后移除报警记录 a'\n\t\t\tDelete a' from T;\n\t\t}\n\t}\n\t```\n\n#### 启发式选择属性泛化报警\n\n> 其中第 11 行的启发算法为:\n\n- 统计在 $A_i$ 属性上值为 $v$ 的报警的数量，记作 $f_i(v)$：\n\n\t```sql\n\tfi(v) := SELECT sum(count) FROM T WHERE Ai = v\n\t```\n\t\n- 让 $F_i$ 记作每个属性 $A_i$ 的最大值函数 ：\n        \n\t$$\n\tF_i := \\max \\left\\{\n\t\tf_i(v) | v \\in Dom(A_i)\n\t\\right\\} \\tag{5}\n\t$$\n\n- 这里的逻辑是：\n\t- 若有一个报警 $\\mathcal{a}$ 满足 $\\mathcal{a}[count] \\geq \\mathcal{min\\_size}$，那么对于所有属性 $A_i$ 均能满足 $F_i \\geq f_i(\\mathcal{a}[A_i]) \\geq \\mathcal{min\\_size}$。\n\t- 相反，如果有一个属性 $A_i$ 的 $F_i < \\mathcal{min\\_size}$，那么 $\\mathcal{a}[count]$ 就不可能大于 $\\mathcal{min\\_size}$。所以选择 $F_i$ 值最小的属性 $A_i$ 进行泛化。\n\t\n\t> 类似于木桶定律，装水量由最短的木板决定。\n\n#### DAG 形式的泛化层次结构\n- 当泛化层次结构是一个有向无环图 (Directed Acyclic Graph, DAG)，而不是一颗树时，结构上的任何一个节点都有可能包含多个父节点，那么一个属性值存在多个父节点将其泛化。\n\n\t针对此问题，基于经典的 AOI 提出两种解决策略：\n\n- `选择其一法`：基于用户定义的规则解决歧义问题。例如，考虑运行在同一 IP 下的 HTTP 服务器和 FTP 服务器，我们通过附加端口值进行准确泛化。\n\n\t```r\n\tif a[Destination-port] = 80\n\t\tthen generalize ip to HTTP-server \n\telse generalize ip to FTP-server;\n\t```\n\t\n- `探索所有法`：并行地探索所有可能的泛化结果 (穷举法)。改写上述代码 16 行即可实现：\n\n\t```r\n\t// Step.2 对 L 中所有报警进行泛化\n\tfor all alarms a in T do {\n\t\tT := T \\ {a};\n\t\t// 由属性 Ai 泛化报警的所有可能性都加入 T 中\n\t\tfor all parents p that a[Ai] has in Gi do {\n\t\t\ta' := a; \n\t\t\ta'[Ai] := p; \n\t\t\tT := T ∪ {a'};\n\t\t}\n\t}\n\t```\n\n#### MINSIZE 参数自适应算法\n- 此外，关于 $\\mathcal{min\\_size}$ 的选择，如果选择了一个过大的 $\\mathcal{min\\_size}$，那么会迫使算法合并具有不同根源的报警。另一方面，如果过小，那么聚类可能会提前结束，具有相同根源的报警可能会出现在不同的聚类中。\n- 因此，设置一个初始值，可以记作 $ms_0$。定义一个较小的值 $\\varepsilon (0 < \\varepsilon < 1)$，当 $\\mathcal{min\\_size}$ 取值为 $ms_0$、$ms_0 \\times (1 - \\varepsilon )$、$ms_0 \\times (1 + \\varepsilon )$ 时的聚类结果相同时，我们就说此时聚类是 $ \\varepsilon$-鲁棒的。\n- 如果不相同，则使 $ms_1 = ms_0 * (1 - \\varepsilon)$，重复这个测试，直到找到一个鲁棒的最小值。\n        \n\t> 需要注意的是，$ \\varepsilon$-鲁棒性与特定的报警日志相关。因此，给定的最小值，可能相对于一个报警日志来说是鲁棒的，而对于另一个报警日志来说是不鲁棒的。\n\n## 案例实现\n### 提取报警特征\n- 根据线上问题排查的经验，运维人员通常关注的指标包括时间、机器 ( 机房、环境 )、异常来源、报警日志文本提示、故障所在位置 ( 代码行数、接口、类 )、Case 相关的特殊 ID ( 订单号、产品编号、用户ID ) 等。\n- 在本案例中，实际应用场景都是线上准实时场景，时间间隔短，因此我们不需要关注时间指标；同时，Case 相关的特殊 ID 不符合抽象描述的要求，因此也无需关注此项指标。\n- 综上所述，我们选择的特征包括：`机房`、`环境`、`异常来源`、`报警日志文本摘要`、`故障所在位置` ( 接口、类 )。\n\n### 提取关键特征\n> 我们的数据来源是日志中心已经格式化过的报警日志信息，这些信息主要包含：报警日志产生的时间、服务标记、在代码中的位置、日志内容等。在定义泛化层次结构前夕，我们需要从已知的数据源中梳理出关键特征。\n\n- `机房和环境`：提取这两个指标比较简单，在此不做详细赘述。\n- `异常来源`：获得故障所在位置后，优先使用此信息确定异常报警的来源；若不能获取，则在日志内容中根据关键字匹配。需要说明的是，两者都需要预先定义词典支持。\n- `报警日志文本摘要`：优先查找日志内容中是否有异常堆栈，若存在，则查找最后一个异常 ( 通常为真正的故障原因 )；若不能获取，则在日志中查找是否存在 “code=……, message=……” 这样形式的错误提示；若不能获取，则取日志内容的第一行内容 ( 以换行符为界 )，并去除其中可能存在的 Case 相关的提示信息。\n- `故障所在位置`：优先查找是否有异常堆栈，如存在则查找第一个本地代码的位置； 若不存在，则取日志打印位置。\n\n### 泛化层次结构\n- 泛化层次结构，用于记录属性的泛化关系，是泛化时向上抽象的依据，需要预先定义。\n- 根据实验所用项目的实际使用环境，根据 `关键特性` 定义的 `泛化层次结构` 如下：\n\n\t![](/images/illustration/Paper/2019/alarm-clustering_1-4.png)\n\t<center>图 1-4 机房泛化层次结构</center>\n\t\n\t![](/images/illustration/Paper/2019/alarm-clustering_1-5.png)\n\t<center>图 1-5 环境泛化层次结构</center>\n\t\n\t![](/images/illustration/Paper/2019/alarm-clustering_1-6.png)\n\t<center>图 1-6 异常来源的泛化层次结构</center>\n\t\n\t![](/images/illustration/Paper/2019/alarm-clustering_1-7.png)\n\t<center>图 1-7 报警日志文本摘要的泛化层次结构</center>\n\t\n- `故障所在位置` 此属性无需泛化层次结构，每次泛化时直接按照包路径向上层截断，直到系统包名。\n\n### 报警聚类算法\n- 算法的执行流程，我们以图 1-8 来表述：\n\n\t![](/images/illustration/Paper/2019/alarm-clustering_1-8.png)\n\t<center>图 1-8 报警日志聚类流程图</center>\n\n- `min_size` 参数设定：考虑到日志数据中可能包含种类极多，且根据小规模数据实验表明，$\\mathcal{min\\_size} = \\frac15 \\times$ 报警日志数量时，算法已经有较好的表现，再高会增加过度聚合的风险，因此我们取 $\\mathcal{min\\_size} = \\frac15 \\times$ 报警日志数量，$\\varepsilon$ 参考论文中的实验取 0.05。\n\n- `聚类停止条件`：考虑到部分场景下，报警日志可能较少，因此 min_size 的值也较少，此时聚类已无太大意义，因此设定聚类停止条件为：聚类结果的报警摘要数量小于等于 20 或已经存在某个类别的 count 值达到 min_size 的阈值，即停止聚类。\n\n## 延伸探究\n- 在论文中，警报 $\\mathcal{a_x}$、$\\mathcal{a_y}$ 的不相似度量定义为 $d(\\mathcal{a_x}, \\mathcal{a_y}) := \\sum_{i=1}^n d(\\mathcal{a_x}[A_i], \\mathcal{a_y}[A_i])$，$d(·,·)$ 即把警报 a 中每个属性的不相似度量累加起来。\n\n\t> 在现实条件下，警报对象包含的属性值理应是有主次、重要性之分。我们计算警报的不相似度，具体计算不同的属性的不相似度时，是否考虑加入权重计算系统。\n\n- 关于泛化层次结构的表现形式包括 `有向无环图` 和 `树`。针对有向无环图形式的泛化层次结构，一个结构节点可能存在多个父节点，即一个属性值存在多个父节点将其泛化，故论文基于经典的 AOI 提出两种解决策略，以准确地选择唯一父节点去泛化报警。\n\n\t首先，是结合领域知识的 `选择其一法`，满足基本要求但需要人为因素干预。而现在问题是，若采取 `探索所有法` 将所有的泛化报警都加入集合 T 中，然而存在重复加入泛化报警的可能性，那么由原始方法构建簇群将是不正确的 (上述伪代码 23 行)。\n\t\t\n\t> 原论文描述解决办法：重新扫描原始警报日志，并确定与之匹配的原始警报的数量？细节和意图不明确，是否有替代方案？\n\t\n## 参考资料\n - [1] [美团技术团队. 根因分析初探：一种报警聚类算法在业务系统的落地实施. 2019. tech.meituan.com](https://tech.meituan.com/2019/02/28/root-clause-analysis.html)\n - [2] Julisch K . Clustering intrusion detection alarms to support root cause analysis[J]. ACM Transactions on Information and System Security, 2003, 6(4):443-471.\n - [3] Jiawei Han 等著; 范明等译. 数据挖掘:概念与技术 (原书第3版) [M]. 机械工业出版社., 2012. 111-116.","tags":["根因分析"],"categories":["Paper"]},{"title":"框架 | Django 框架入门到应用","url":"%2F2019%2F02%2FDjango.html","content":"\nDjango 是基于 MVC 模式，由 Python 写成的开源 Web 应用框架。在 Django 中，控制器接受用户输入的部分由框架自行处理，而 Django 里更关注的是模型 ( Model )、模板 ( Template ) 和视图 ( Views )，为此也称其为 MTV 模式的 Web 框架。\n\n当然，基于 Python 的 Web 框架不仅这一家，如  flask、tornado、web2py 等。而任何一款框架的产生都有自身的亮点和缺陷 $^{[2, 3]}$，综合自我诉求、性能要求等诸多因素考量，选择适合的框架即可。在本次开发中，我们只需要一款数据库驱动的内容发布与管理系统，而 Django 的中间件 [ORM](https://baike.baidu.com/item/对象关系映射) 设计，使得我们在具体操作业务对象时，不需要和复杂的 SQL 语句打交道，只要像平时操作对象一样操作即可。为此，本着轻量开发的原则选择了 Django。\n\n<!-- More -->\n\n## 教学资源\n- 📺 | 视频 | [老男孩.Python 全栈: Django 框架入门到应用. 2018. bilibili.com](https://www.bilibili.com/video/av22606568/?p=3)\n- 📄 | 文章 | [Django.Django 快速入门&中文使用文档. djangoproject.com](https://docs.djangoproject.com/zh-hans/2.1/)\n\n## 快速上手\n### 安装与配置\n- 安装：命令行模式安装 ( Mac / Linux 用户注意管理员权限 )\n\n\t```bash\n\tpip install django\n\tpip install django == x.xx.xx\n\t```\n\t\n- 配置：配置 Django 项目并初次启动它。\n\t- 创建项目：可通过命令模式启动项目 ( 多用于部署环境 )，也可通过 PyCharm 启动、运行项目。\n\t\t- 命令模式：`django-admin startproject mysite`\n\t\t- PyCharm：通过 PyCharm 一步到位，即 `新建工程 > Django > ( 建立单独的 Venv ) > mysite`。\n\n\t\t\t> Virtualenv：为一个应用创建一套“隔离”的 Python 运行环境，具体配置方法可参考 [1]。\n\t\t\n\t- 项目目录结构说明\n\t\t- `mysite`：同名目录，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名，比如 mysite.urls。\n\t\t- `__init__.py`：空文件，标识这个目录应识别为 Python 包。\n\t\t- `settings.py`：Django 的项目配置文件。\n\t\t- `urls.py`：Django 项目的 URL 声明。\n\t\t- `wsgi.py`：Web 服务网关接口 ( Socket )。\n\t\t- `manage.py`：对网络所有管理是通过其来实现的。\n\t\t\n\t\t\t```bash\n\t\t\tmysite\n\t\t\t  ├─── mysite\n\t\t\t  │ ├── init__.py\n\t\t\t  │ ├── settings.py\n\t\t\t  │ ├── urls.py\n\t\t\t  │ ├── wsgi.gy\n\t\t\t  └─── manage.py\n\t\t\t```\n\t\t\t\n- 使用：以命令模式启动本地服务器为例，当然可以使用 Pycharm 一键运行。\n\t\n\t```bash\n\tpython manage.py runserver 127.0.0.1:8000\n\t```\n\t\t\n### 请求与响应\n#### 返回内容至页面\n返回内容 ( Html 元素或对象 ) 至页面，代码应包含在 `urls.py` 文件中。\n\n- 下述是返回字符串或 Html 元素的示例代码：\n\n\t```python\n\tfrom django.shortcuts import HttpResponse\n\t'''\n\targuments:\n\t\t@param request 放置用户请求相关的所有信息\n\t@return 响应与返回处理结果\n\t'''\n\tdef info(request):\n\t\t# 1. 可返回字符串\n\t\treturn HttpResponse(\"Hello World!\")\n\t\t# 2. 可返回 Html 元素 (对象)\n\t\t# return HttpResponse(\"<input type='text' />\")\n\t\t\n\t# 访问 Site 根目录\n\turlpatterns = [ url('', info), ]\t\n\t```\n\n#### 返回独立 Html 页面\t\n返回独立 Html 页面，且尝试把数据返回到页面中。\n\n- Html 页面放置 `tempates` 目录下；\n- `settings.py` 中配置模板的路径 ( 告诉程序网页模板在哪个目录下 )；\n\n\t```python\n\tTEMPLATES = [\n\t\t'DIRS': [os.path.join(BASE_DIR, 'templates')]\n\t]\n\t```\n\t\t\n- `urs.py` 中加入调用代码，绑定请求地址与处理函数；\n\n\t```python\n\tdef info(request):\n\t    # render 能抓取页面全部信息 ( 它也调用了 HttpResponse )\n\t    return render(request, 'info.html')\n\t```\n\t\t\t\n- 若要引用资源目录，如存放 images、css 等，则需要在 `settings.py` 中加入声明语句。\n\t\t\n\t引用资源时，需要加入 `static`。例如 `<link rel=\"stylesheet\" href=\"static/style.css\">`。\n\n\t```python\n\tSTATIC_URL = '/static/'\n\tSTATICFILES_DIRS = (\n\t    # '文件名' 是自由命名的，这里取 'static' 是为了统一命名\n\t    os.path.join(BASE_DIR, 'static'), \n\t)\n\t```\n\n### 简单登录功能\n\n> 本实例主要展示的是，在 Django 框架下 Web 前后端的交互过程。\n\n- 首先，我们在 `urls.py` 中配置路由关系，并绑定路由触发的函数以实现功能。\n\n\t```python\n\tfrom django.shortcuts import HttpResponse, render, redirect\n\tfrom django.urls import path\n\t\n\t# 首次加载页面调用的函数\n\tdef login(request):\n\t\t# GET 可通过请求的链接地址传参，如 url?page=1\n\t\tif ('GET' == request.method):\n\t\t\t## render() 是抓取页面全部信息 ( 它也调用了 HttpResponse )\n\t\t\treturn render(request, 'login.html')\n\t\t\t\t\t\n\t# 登录成功后把数据回传到目标页面\n\tdef index(request):\n\t\tuser = request.POST\n\t\treturn render(request, 'index.html', {\n\t\t\t'username': str(user.get('username')),\n\t\t\t'password': {\n\t\t\t\t'origin': user.get('password'),\n\t\t\t\t'encode': base64.b64encode( (user.get('password') + user.get('password')).encode('utf-8') )\n\t\t\t}}\n\t\t)\n    \n\t# path(相对地址, 调用函数)，如请求地址为根目录，故这里填写 '' \n\turlpatterns = [ \n\t    path('', login), \n\t    path('index', index), \n\t]\n\t```\n\t\t\t\n- 最后附上相关联的 `login.html` 和 `index.html`。\n\n\t```html\n\t<!-- login.html -->\n\t<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>Information Page</title>\n\t\t<link rel=\"stylesheet\" href=\"static/css/style.css\">\n\t</head>\n\t<body>\n\t\t<h2>Hello World!</h1>\n\t\t<h2>Welcome to use the exhibation page.</h2>\n\t\t<form method=\"POST\" action=\"index\">\n\t\t\t<input name=\"username\" type=\"text\" />\n\t\t\t<input name=\"password\" type=\"password\" />\n\t\t\t<input value=\"login\" type=\"submit\" />\n\t\t</form>\n\t</body>\n\t</html>\n\t\n\t<!-- index.html -->\n\t<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>Home Index</title>\n\t\t<link rel=\"stylesheet\" href=\"static/css/style.css\">\n\t</head>\n\t<body>\t\n\t\t<!-- 1. 模板中接受函数体返回的属性 -->\n\t\t<!-- {{}} 特殊占位符: Django render() 会自动解析它 -->\n\t\t<h2>username</h2> {{ username }}\n\t\t<h2>password</h2> {{ password.origin }} => {{ password.encode }}\n\n\t\t<p><!-- 换行 --></p>\n\n\t\t<!-- 2. 模板中调用对象的方法和属性，例如循环体 -->\n\t\t<table border=\"1\">\n\t\t\t<tr>\n\t\t\t\t<td>Username</td><td>{{ username }}</td>\n\t\t\t</tr>\n\t\t\t{% for key, value in password.items %}\n\t\t\t<tr>\n\t\t\t\t<td>Password:{{ key }}</td><td>{{ value }}</td>\n\t\t\t</tr>\n\t\t\t{% endfor %}\n\t\t</table>\n\t</body>\n\t</html>\n\t```\n\t\n### 增删改查系统\n\n> 本实例主要展示的是 Python 与数据库的交互过程。\n\n#### 建立数据表\n数据关系：这里以学生 ( Student )、任教老师 ( Teacher ) 和课程 ( Course ) 三个实体为例，构建数据表。\n\n- ER 图，如图 4-1 所示：\n\t- 学生可以选修多门课程，一门课程可以多个学生参与，即多对多关系。\n\t- 老师只能任教一门课程，但是一门课程有多个老师开课，即一对多关系。\n\n![django_1-1](/images/illustration/Programme/2019/02/django_1-1.jpg)\n<center>图 1-1 演示数据库的数据关系</center>\n\n- 关系模式：\n\t- 学生实体(学生序号, 学生姓名) == t_student(_sid_, name)\n\t- 课程实体(课程序号, 课堂名称) == t_course(_cid_, name)\n\t- 老师实体(老师序号, 老师姓名) == t_teacher(_tid_, name, cid)\n\t- 选课关系(学生序号, 课程序号, 成绩) == Student2Course(_sid_, _cid_, score)\n\n#### 前 / 后端交互原理\n- Web 程序的前后端交互原理如图 4-2 所示。\n\n![django_1-2](/images/illustration/Programme/2019/02/django_1-2.jpg)\n<center>图 1-2 Web 程序的前后端交互原理</center>\n\n#### 原生代码操作数据\n- Python 的 MySQL 驱动有 `MySQLdb`、`PyMySQL` 以及 `MySQLClient`。\n- 在 Python 2.7 版本，主要是用 MySQLdb，而 Python 3.x 版本多数使用 PyMySQL 以及 MySQLClient。两者操作风格类似，本文则以 PyMySQL 展开探讨。\n\n\t```python\n\t# 封装连接数据库的信息\n\tdb_infos = {\n\t\t'host': \"IP 地址\",\n\t\t'port': 3306,\n\t\t'user': \"数据库账户\",\n\t\t'password': \"数据库密码\",\n\t\t'db': \"数据库名称\",\n\t\t'charset': \"utf8\",\n\t\t'cursorclass': pymysql.cursors.DictCursor\n\t}\n\t\n\timport pymysql\n\tdb = pymysql.connect(db_infos)\n\t\n\tSQL = \"SELECT * FROM t_student\"\n\t\n\ttry:\n\t\twith db.cursor() as cursor:\n\t\t\tcursor.excute(SQL) # 执行 SQL 语句\n\t\t\tdb.commit() # 提交修改数据请求\n\texcept:\n\t\tdb.rollback() # 回滚\n\tfinally:\n\t\tdb.close() # 关闭数据库连接\n\t```\n\n#### Ajax 方式交互数据\n- 借助 Ajax，实现数据的本地刷新，而不需要重新加载、渲染网页。\n\n\t```js\n\t$.ajax({\n\t    url: '提交地址',\n\t    type: 'POST' // POST / GET\n\t    data: {'key_1': 'value_1', ..., 'key_n': 'value_n' }\n\t    success: function(data){\n\t        // 当前服务端处理数据，自动执行回调函数\n\t    }\n\t})\n\t```\n\n## 框架正文\n\n本章节的内容参考 [Django 官方文档 v2.1](https://docs.djangoproject.com/zh-hans/2.1/) 整理所得，即把模型、模板和视图的概念更加细化，通过一个投票应用的实例以讲述如何搭建一个 `MTV模式` 的 Web 框架，如图 3-1 所示。\n\n![django_2-1](/images/illustration/Programme/2019/02/django_2-1.jpg)\n<center>图 2-1 MTV 模式的 Web 框架</center>\n\n### 数据库配置\n- 编辑 `mysite/settings.py` 文件前，先设置 [TIME_ZONE](https://docs.djangoproject.com/zh-hans/2.1/ref/settings/#std:setting-TIME_ZONE) 为你自己时区，可参考 Wikipedia 的 [List of time zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)。\n\t\n\t> 新建立的项目，默认时区为 `UTC`。\n\n- 打开 `mysite/settings.py`，通常这个配置文件使用 SQLite 作为默认数据库。\n\t- `ENGINE`：选值 `django.db.backends.sqlite3`。\n\t- `NAME`：数据库的名称。若使用 [SQLite](https://baike.baidu.com/item/SQLite/375020?fr=aladdin)，数据库将是你电脑上的一个文件，NAME 应该是此文件的绝对路径 + 文件名，默认值 `os.path.join(BASE_DIR, 'db.sqlite3')` 将会把数据库文件储存在项目的根目录。\n\n\t\t```python\n\t\tDATABASES = {\n\t\t    'default': {\n\t\t        'ENGINE': 'django.db.backends.sqlite3',\n\t\t        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),\n\t\t    }\n\t\t}\n\t\t```\n\n\t- 若使用了 SQLite 以外的数据库，请确认在使用前已经 `创建了数据库`。连接到其他数据库时 ( MySQL，Oracle 或 PostgreSQL )，参考 [ENGINE](https://docs.djangoproject.com/zh-hans/2.1/ref/settings/#std:setting-DATABASE-ENGINE) 的设置来连接其他数据库。例如连接 MySQL 的配置如下所示：\n\n\t\t```python\n\t\tDATABASES = {\n\t\t    'default': {\n\t\t        'ENGINE': 'django.db.backends.mysql',\n\t\t        'NAME': 'mydatabase',\n\t\t        'USER': 'mydatabaseuser',\n\t\t        'PASSWORD': 'mypassword',\n\t\t        'HOST': '127.0.0.1',\n\t\t        'PORT': '3306',\n\t\t    }\n\t\t}\n\t\t```\n\n- 此外，关注一下文件头部的 `INSTALLED_APPS` 设置项。这里包括了项目中启用的所有 Django 应用。应用能在多个项目中使用，也可以打包并且发布应用，让别人使用它们。通常 INSTALLED_APPS 默认包括了以下 Django 的自带应用：\n\n\t```python\n\tINSTALLED_APPS = [\n\t    # 因为 ApplicationConfig 类写在文件 polls/apps.py 中，\n\t    # 所以它的点式路径是 'polls.apps.ApplicationConfig'\n\t    'polls.apps.ApplicationConfig',\t# 激活模型\n\t    'django.contrib.admin',\t\t# 管理员站点\n\t    'django.contrib.auth',\t\t# 认证授权系统\n\t    'django.contrib.contenttypes',\t# 内容类型框架\n\t    'django.contrib.sessions',\t\t# 会话框架\n\t    'django.contrib.messages',\t\t# 消息框架\n\t    'django.contrib.staticfiles',\t# 管理静态文件的框架\n\t]\n\t```\n\t\t\n- 默认开启的某些应用需要至少一个数据表，故在使用他们前需要在数据库中创建一些表。请执行命令：\n\n\t```shell\n\t# MacOS / Linux\n\tpython manage.py migrate\n\n\t# Windows ( 下述代码同理，基本上 \"py\" 对应于 \"python\" )\n\tpy manage.py migrate\n\t```\n\n### 模型和站点管理\n\n#### 创建模型\n- 定义模型 ( Model )，即数据库结构设计和附加的其它元数据。在 Django 中，你只需要定义数据模型，其中的实现代码不用理会，它们会自动从模型生成。\n\n\t> 模型是真实数据的简单明确的描述，它包含了储存的数据所必要的字段和行为。\n\n- 例如，在本案例中 ( 投票应用 )，需要创建两个模型：问题 Question 和选项 Choice。\n\t- Question 模型：包括问题描述和发布时间。\n\t- Choice 模型：包括选项描述和当前得票数。每个选项属于一个问题 ( 一对一关系 )。\n\n- 这些概念可通过 Python 类来描述。按照下面的例子来编辑 `polls/models.py` 文件：\n\t- 每个模型被表示为 `django.db.models.Model` 类的子类。每个模型有一些类变量，它们都表示模型里的一个数据库字段。\n\t- 每个字段都是 `Field` 类的实例，这将告诉 Django 每个字段要处理的数据类型。比如，字符字段被表示为 `CharField`，日期时间字段被表示为 `DateTimeField`。\n\t- 定义某些 Field 类实例需要参数，例如 CharField 需要一个 max_length 参数。\n\t\t\n\t\t> 这个参数的用处不止于用来定义数据库结构，也用于验证数据。\n\n\t- Django 支持所有常用的数据库关系：一对一、一对多和多对多，我们使用外键 `ForeignKey` 定义了一个关系。例如，每个 Choice 对象都关联到一个 Question 对象。\n\t- 数据表最重要的 `主键` 会被自动创建，当然也可以自定义。\n\n\t\t```python\n\t\tfrom django.db import models\n\t\n\t\tclass Question(models.Model):\n\t\t    question_text = models.CharField(max_ length=200)\n\t\t    pub_date = models.DateTimeField('date published')\n\t\t    \n\t\t    # Question.objects.all() 返回信息对我们用处不大，如下所示：\n\t\t    # <QuerySet [<Question: Question object (1)>]>\n\t\t    # 可尝试通过 __str__() 方法返回一些字段信息\n\t\t    def __str__(self):\n\t\t    \treturn self.question_text\n\t\n\t\tclass Choice(models.Model):\n\t\t    question = models.ForeignKey(Question, on_delete=models.CASCADE)\n\t\t    choice_text = models.CharField(max_length=200)\n\t\t    votes = models.IntegerField(default=0)\n\t\t    def __str__(self):\n\t\t    \treturn self.choice_text\n\t\t```\n\n#### 激活模型\n-  从上述用于创建模型的代码可知，Django 可实现：\n\t- 为这个应用创建数据库 `schema` ( 生成 CREATE TABLE 语句 )。\n\t- 创建与 Question 和 Choice 对象与数据库进行交互的 `API` ( Python 版本 )。\n\n- 但是首先得把 polls 应用安装到我们的项目里。具体地， 在文件 `mysite/settings.py` 中 `INSTALLED_APPS` 子项添加点式路径：\n\n\t```python\n\tINSTALLED_APPS = [\n\t    # 因为 ApplicationConfig 类写在文件 polls/apps.py 中，\n\t    # 所以它的点式路径是 'polls.apps.ApplicationConfig'\n\t    'polls.apps.ApplicationConfig',\t# 激活模型\n\t    'django.contrib.admin',\t\t\t# 管理员站点\n\t    'django.contrib.auth',\t\t\t# 认证授权系统\n\t    'django.contrib.contenttypes',\t# 内容类型框架\n\t    'django.contrib.sessions',\t\t# 会话框架\n\t    'django.contrib.messages',\t\t# 消息框架\n\t    'django.contrib.staticfiles',\t# 管理静态文件的框架\n\t]\n\t```\n- 现在你的 Django 项目会包含 polls 应用。接着通过运行 `makemigrations` 命令，Django 会检测你对模型文件的修改 ( 在这种情况下刚创建的可理解为最新修改的  )，并且把修改的部分储存为一次 `迁移`。\n\n\t> 迁移：Django 对于模型定义，也就是你的数据库结构的变化的储存形式。它们其实也只是一些你磁盘上的文件。\n\n\t```shell\n\tpython manage.py makemigrations polls\n\t```\n\t\n- Django 有一个自动执行 `数据库迁移` 并同步管理你的数据库结构的命令：\n\n\t```shell\n\tpython manage.py migrate\n\t```\n\t\n- 当然，你是否会好奇，迁移是怎样的过程，迁移命令会执行哪些 SQL 语句？那么，`sqlmigrate` 命令接收一个迁移的名称，然后返回对应的 SQL。\n\t\n\t```shell\n\t# sqlmigrate 命令\n\t# 并没有真正在数据库中的执行迁移，它只是把命令输出到屏幕上\n\tpython manage.py sqlmigrate polls 0001\n\t```\n\t\n- 输入以上命令，你将看到如下结果 ( 格式化输出 SQL )：\n\t\n\t```SQL\n\t-- 输出示例使用的是 PostgreSQL / MySQL --\n\tBEGIN;\n\t-- Create model Choice\n\tCREATE TABLE \"polls_choice\" (\n\t    \"id\" serial NOT NULL PRIMARY KEY,\n\t    \"choice_text\" varchar(200) NOT NULL,\n\t    \"votes\" integer NOT NULL\n\t);\n\t-- Create model Question\n\tCREATE TABLE \"polls_question\" (\n\t    \"id\" serial NOT NULL PRIMARY KEY,\n\t    \"question_text\" varchar(200) NOT NULL,\n\t    \"pub_date\" timestamp with time zone NOT NULL\n\t);\n\t-- 省略剩余语句，具体可自行测试 --\n\tCOMMIT;\n\t```\n\n- 从格式化的 SQL 语句可注意到：\n\n\t- 数据库的表名是由应用名 ( polls ) 和模型名的小写形式 ( question 和 choice ) 连接而来。\n\n\t- 主键 ( id ) 会被自动创建，当然你也可以自定义。\n\n\t- 默认 Django 会在外键字段名后追加字符串 \"_id\" ，同样也可以自定义。\n\n\t- 生成的 SQL 语句是为你所用的数据库定制的，所以那些和数据库有关的字段类型，比如 auto_increment ( MySQL )、 serial ( PostgreSQL ) 和 integer primary key autoincrement ( SQLite )，Django 会帮你自动处理。那些和引号相关的事情，比如使用单引号还是双引号，也一样会被自动处理。\n\n- 总结：迁移是非常强大的功能，它能让你在开发过程中持续的改变数据库结构而不需要重新删除和创建表，即它专注于使数据库平滑升级而不会丢失数据。**现在改变模型只需要记住这三步**：\n\n\t- 编辑 `models.py` 文件，改变模型。\n\n\t- 运行 `python manage.py makemigrations` 为模型的改变 `生成` 迁移文件。\n\n\t- 运行 `python manage.py migrate` 来 `应用` 数据库迁移。\n\n#### 数据操作\n- 当完成 `创建模型` ( 定义数据实体和数据关系 ) 与 `激活模型` ( 模型驱动自动生成 SQL 代码 ) 的工作，即表明数据表已建立起来，紧接着便可操作数据库了。\n- 关于操作数据库的 Python API 所有细节可在 [Database API For Python](https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/) 参考文档中找到。\n\n##### 创建对象\n- 假设模型存在于文件中 mysite/polls/models.py：\n\n\t```python\n\tfrom polls.models import Choice, Question\n\t# 使用模型类的关键字参数对其实例化，再调用 save() 以将其保存到数据库中\n\tq = Question(question_text=\"What's new?\", pub_date=timezone.now())\n\t# 创建和保存对象则使用 create() 方法\n\tq.save()\n\t```\n\t\n##### 更新对象\n- UPDATE 在幕后执行 SQL 语句：\n\n\t```python\n\t# 保存对象的更改\n\tq.question = \"What do you think about?\"\n\tq.save()\n\t```\n\t\n- 保存 ForeignKey 字段：更新 ForeignKey 字段的工作方式与保存普通字段的方式完全相同，只需将正确类型的对象分配给相关字段即可。\n\n\t```python\n\t# 一般情况 pk ( Primary Key ) 和 id 是一样的，只有 id 不是主键时才不一样\n\tchoice = Choice.objects.get(pk=1)\n\tquestion = Question.objects.get('What do you think about?')\n\tchoice.question = question\n\tchoice.save()\n\t```\n\t\n-  更新ManyToManyField 工作的方式略有不同 ：使用 add() 字段上的方法向关系添加记录。\n\n##### 检索对象\n- 使用 all() 返回所有对象：例如，返回 Question 数据库中所有对象。\n\n\t```python\n\tall_question = Question.objects.all()\n\t```\n \n- `使用过滤器检索特定对象`：若我们仅需要选择整个对象集的子集，则需要向 QuerySet 添加过滤条件。两种最常见的改进方法：\n\t- `filter(**kwargs)`：返回 QuerySet 包含与给定查找参数匹配的新对象。\n\t- `exclude(**kwargs)`：返回 QuerySet 包含与给定查找参数不匹配的新对象。\n\t\t\n\t\t```python\n\t\t# 例如：获取 2018 年间所有问题记录\n\t\tQuestion.objects.filter(pub_date__year=2017)\n\t\t```\n\t\t\n- `链接过滤器`：QuerySet 检索结果本身也是 QuerySet 对象，故可使用多个过滤器。作用与 `多条件查询` 类似效果。\n\n\t```python\n\t# 例如：获取以“What”开头，在 2018 年 1 月 1 日至当天前的所有记录\n\tQuestion.objects.filter(\n\t\theadline__startswith='What'\n\t).exclude(\n\t\tpub_date__gte=datetime.date.today()\n\t).filter(\n\t\tpub_date__gte=datetime.date(2018, 1, 1)\n\t)\n\t```\n\t\n- 使用 get() 检索单个对象：\n\n\t```python\n\tone_question = Question.objects.get(pk=1)\n\t# Question 没有主键为 1 的对象，Django 将引发异常 Entry.DoesNotExist。\n\t```\n\t\n- 限制 QuerySet 返回集合的大小：使用 Python 的数组切片语法将限制 QuerySet 为一定数量的结果。这相当于 SQL 中 `LIMIT` 和 `OFFSET` 子句。\n\n\t- 注意 1：`Entry.objects.all()[-1]` 不支持负索引。\n\t- 注意 2：`Entry.objects.all()[:10:2]` 不支持使用步进 ( Step ) 取值。\n\n\t\t```python\n\t\t# 例如：返回前5个对象（）：LIMIT 5\n\t\tQuestion.objects.all()[:5]\n\t\t# 例如：返回第6到第10个对象：OFFSET 5 LIMIT 5\n\t\tQuestion.objects.all()[5:10]\n\t\t```\n\n#### 站点管理\n\n##### 开篇引言\n- 相信你也有过同样的经历，例如为你的员工或客户生成一个用户添加、修改和删除内容的管理后台，即简单的增删改查操作 ( CRUD ) ，但它却是一项缺乏创造性和乏味的工作。因此，Django 全自动地根据模型创建界面化的管理后台。\n- 管理界面不是为了网站的访问者，而是为管理者准备的。需要客制化的后台管理界面还需自行实现。\n\n##### 创建管理员账号\n- 首先，我们得创建一个能登录管理页面的用户。请运行下面的命令：\n\n\t```bash\n\tpython manage.py createsuperuser\n\t# Username: kofe\n\t# Email address: kofe@example.com\n\t# Password: **********\n\t# Password (again): *********\n\t# Superuser created successfully.\n\t```\n\n##### 启动开发服务器\n- Django 的管理界面默认就是启用的。让我们启动开发服务器。当然，你可以通过 PyCharm 启动服务器，也可以通过命令启动：\n\n\t```bash\n\tpython manage.py runserver\n\t```\n\n- 打开浏览器即可访问：`http://127.0.0.1:8000/admin/`\n\n##### 管理页添加应用\n- 在索引页面中，我们并没有看到应用，如本例中的投票应用 `polls`。所以我们得告诉管理页面，问题 `Question` 对象需要被管理。打开 `polls/admin.py` 文件，把它编辑成下面这样：\n\n\t```python\n\tfrom django.contrib import admin\n\tfrom .models import Question\n\tadmin.site.register(Question)\n\t```\n\t\n### 模板和视图\n#### 开篇引言\n- 每个视图必须要做的只有两件事：返回一个包含被请求页面内容的 `HttpResponse` 对象或者抛出一个 `异常`，比如 HTTP 404。\n\n\t> Django 只要求返回的是一个 HttpResponse ，或抛出一个异常。\n\n- 视图可以从数据库里读取记录，可使用一个模板引擎 ( Django 自带或者其他第三方的 )，生成一个 PDF 文件、输出一个 XML、创建一个 ZIP 文件等，你可以使用任何你想用的 Python 库，实现你想做的事。\n- Django 自带的 [Database API](https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/) 很方便，与试图结合使用即可实现数据的基本交互操作。\n\n\t```python\n\t# 在 index() 函数里插入了一些新内容\n\t# 让它能展示数据库里以发布日期排序的最近5个投票问题\n\tfrom django.http import HttpResponse\n\tfrom .models import Question\n\tdef index(request):\n\t\tlatest_question_list = Question.objects.order_by('-pub_date')[0:5]\n\t\toutput = ', '.join([q.question_text for q in latest_question_list])\n\t\treturn HttpResponse(output)\n\t```\n\t\n#### 模板系统\n- 这里有个问题：页面的设计写死在视图函数的代码里的。如果你想改变页面的样子，你需要编辑 Python 代码。我们是否能将此过程相互分离，即 `视图负责处理、组装数据`；`模板则负责样式`。\n\t- 首先，在你的项目根目录里创建一个 `templates` 目录。Django 将会在这个目录里查找模板文件。\n\t- 在 `templates` 目录里，再创建一个目录 `polls`，然后在其中新建一个文件 `index.html`。\n\t- 换句话说，你的模板文件的路径应该是 `mysite/templates/polls/index.html`。因为 Django 会寻找到对应的 `app_directories`，所以你只需要使用 `polls/index.html` 就可引用到这一模板了。\n\n\t\t> `模板命名空间`：虽然可将模板文件直接放在 mysite/templates 目录下，但若有一个模板文件正好和另一个应用中的某个模板文件重名，则 Django 没有办法区分它们，从而选择第一个匹配的模板文件，造成不能准确匹配的状况。\n\t\t\n\t\t> 帮助 Django 正确选择模板，最简单的方法是把他们放入各自的 `命名空间` 中，即把这些模板放入一个和 `自身应用重名` 的子文件夹里，如本例中的 `polls`。\n\n#### 小试牛刀\n- 我们将下面的代码输入到刚刚创建的模板文件中：\n\n\t```html\n\t<!-- mysite/templates/polls/index.html -->\n\t{% if latest_question_list %}\n\t\t<ul>\n\t\t{% for question in latest_question_list %}\n\t\t\t<li><a href=\"/polls/{{ question.id }}/\">\n\t\t\t\t{{ question.question_text }}\n\t\t\t</a></li>\n\t\t{% endfor %}\n\t\t</ul>\n\t{% else %}\n\t\t<p>No polls are available.</p>\n\t{% endif %}\n\t```\n\t\n- 然后，让我们更新一下 polls/views.py 里的 index 视图来使用模板：\n\n\t```python\n\tfrom django.http import HttpResponse\n\tfrom django.template import loader\n\tfrom .models import Question\n\n\tdef index(request):\n\t\tlatest_question_list = Question.objects.order_by('-pub_date')[:5]\n\t\ttemplate = loader.get_template('polls/index.html')\n\t\tcontext = {\n\t\t\t'latest_question_list': latest_question_list,\n\t\t}\n\t\treturn HttpResponse(template.render(context, request))\n\t```\n\t\n- 载入模板，填充上下文，再返回由它生成的 HttpResponse 对象，这里引入一个便捷函数 render() 函数。它已经把此过程封装一起，调用即可使用。\n\n\trender() 函数的第一个参数是 request 对象，第二个参数是模板名，第三个参数是字典。它返回给定上下文呈现的给定模板的 HttpResponse 对象。\n\t\n\t```python\n\tdef index(request):\n\t\tlatest_question_list = Question.objects.order_by('-pub_date')[:5]\n\t\tcontext = {'latest_question_list': latest_question_list}\n\t\treturn render(request, 'polls/index.html', context)\n\t```\n\t\n- 用你的浏览器访问 `http://127.0.0.1:8000/polls/`，你将会看见一个无序列表。\n\n#### 使用模板系统\n\n> 使用模板系统的过程，更像是前端与后端信息交互的过程，即前端访问请求地址获取数据的过程。\n\n- 模板系统统一使用 `点符号` 来访问变量的属性。在示例 {% raw %}{{ question.question_text }}{% endraw %} 中，首先 Django 尝试对 question 对象使用字典查找 ( 也就是使用 obj.get(str) 操作 )，如果失败了就尝试属性查找 ( 也就是 obj.str 操作 )，结果是成功了。如果这一操作也失败的话，将会尝试列表查找 ( 也就是 obj[int] 操作 )。\n- 在{% raw %}{% for %}{% endraw %}循环中发生的函数调用：question.choice_set.all 被解释为 Python 代码 question.choice_set.all()，将会返回一个可迭代的 Choice 对象，这一对象可以在 {% raw %}{% for %}{% endraw %} 标签内部使用。\n- 查看 [模板指南](https://docs.djangoproject.com/zh-hans/2.1/topics/templates/) 可以了解关于模板的更多信息。\n\n#### 去除模板中的硬编码 URL\n- 硬编码：硬编码和强耦合的链接，对于一个包含很多应用的项目来说，修改起来是十分困难的。\n\n\t```html\n\t<li><a href=\"/polls/{{ question.id }}/\">\n\t\t{{ question.question_text }}\n\t</a></li>\n\t```\n\n- 软编码：然而，因为你在 polls.urls 的 url() 函数中通过 name 参数为 URL 定义了名字，你可以使用 {% raw %}{% url %}{% endraw %} 标签代替它。\n\n\t```html\n\t<!--\n\t | 具有名字 'detail' 的 URL 在 polls/url.py 中定义为：\n\t | path('<int:question_id>/', views.detail, name='detail')\n\t-->\t\n\t<li><a href=\"{% url 'detail' question.id %}\">\n\t\t{{ question.question_text }}\n\t</a></li>\n\t\n\t<!-- \n\t | 若你想改变投票详情视图的 URL，比如 polls/specifics/12/\n\t | 不用在模板里修改任何东西 (包括模板)，只在 polls/urls.py 稍微修改就行\n\t | path('specifics/<int:question_id>/', views.detail, name='detail')\n\t-->\n\t```\n\n#### 为 URL 名称添加命名空间\n- 在一个真实的 Django 项目中，可能会有多个应用，Django 如何分辨重名的 URL 呢？具体情况则是，{% raw %}{% url %}{% endraw %} 标签到底对应哪一个应用的 URL 呢？\n- 在根 `URLconf` 中添加命名空间。在 polls/urls.py 文件中稍作修改，加上 `app_name` 设置命名空间：\n\n\t```python\n\tfrom django.urls import path\n\tfrom . import views\n\tapp_name = 'polls'\n\turlpatterns = [\n\t\tpath('', views.index, name='index'),\n\t\tpath('<int:question_id>/', views.detail, name='detail'),\n\t\tpath('<int:question_id>/results/', views.results, name='results'),\n\t\tpath('<int:question_id>/vote/', views.vote, name='vote'),\n\t]\n\t```\n\t\t\n- 修改为指向具有命名空间的详细视图：\n\n\t```html\n\t<li><a href=\"{% url 'polls:detail' question.id %}\">\n\t\t{{ question.question_text }}\n\t</a></li>\n\t```\n\n### 表单和通用视图\n#### 表单\n\n> 在此小节中，通过表单接收数据，再通过 Django 视图来处理提交的数据。此过程，更像是前端打包数据通过 GET/POST 请求，把数据传送到后端，交由后端视图处理数据。\n\n- 编写一个简单的表单：让我们更新一下在上一个教程中编写的投票详细页面的模板  `polls/detail.html`，让它包含一个 HTML `<form>` 元素：\n\n\t```html\n\t<!-- mystie/templates/polls/detail.html -->\n\t<h1>{{ question.question_text }}</h1>\n\t{% if error_message %}\n\t\t<p><strong>{{ error_message }}</strong></p>\n\t{% endif %}\n\t<form action=\"{% url 'polls:vote' question.id %}\" method=\"post\">\n\t<!--\n\t | 跨站点请求伪造保护：\n\t | 在 Django 中，所有针对内部 URL 的 POST 表单，\n\t | 都应该使用  {% csrf_token %} 模板标签。\n\t-->\n\t{% csrf_token %}\n\t{% for choice in question.choice_set.all %}\n\t\t<input type=\"radio\" name=\"choice\" id=\"choice{{ forloop.counter }}\" value=\"{{ choice.id }}\">\n\t\t<!-- 指示 for 标签已经循环多少次 -->\n\t\t<label for=\"choice{{ forloop.counter }}\">{{ choice.choice_text }}</label><br>\n\t{% endfor %}\n\t<input type=\"submit\" value=\"Vote\">\n\t</form>\n\t```\n\n\t> [跨站点请求伪造保护](https://docs.djangoproject.com/zh-hans/2.1/ref/csrf/)：当恶意网站包含链接，表单按钮或某些旨在在您的网站上执行某些操作的JavaScript时，会发生此类攻击，使用登录用户访问其浏览器中的恶意网站的凭据。一种相关类型的攻击，“登录CSRF”，攻击网站欺骗用户的浏览器以其他人的凭据登录网站也受到保护。\n\t\n- 我们为投票应用创建了一个 URLconf ，即新增一行 `path()`：\n\n\t```python\n\t# polls/urls.py\n\tpath('<int:question_id>/vote/', views.vote, name='vote')\n\t```\n\t\n- 创建一个 `vote()` 函数，来处理相关的数据请求：\n\n\t```python\n\t# polls/views.py\n\tfrom django.http import HttpResponse, HttpResponseRedirect\n\tfrom django.shortcuts import get_object_or_404, render\n\tfrom django.urls import reverse\n\tfrom .models import Choice, Question\n\n\tdef vote(request, question_id):\n\t\tquestion = get_object_or_404(Question, pk=question_id)\n\t\ttry:\n\t\t\tselected_choice = question.choice_set.get(pk=request.POST['choice'])\n\t\texcept (KeyError, Choice.DoesNotExist):\n\t\t\t# Redisplay the question voting form.\n\t\t\treturn render(request, 'polls/detail.html', {\n\t\t\t\t'question': question,\n\t\t\t\t'error_message': \"You didn't select a choice.\",\n\t\t\t})\n\t\telse:\n\t\t\tselected_choice.votes += 1\n\t\t\tselected_choice.save()\n\t\t\t# Always return an HttpResponseRedirect after successfully dealing\n\t\t\t# with POST data. This prevents data from being posted twice if a\n\t\t\t# user hits the Back button.\n\t\t\treturn HttpResponseRedirect(reverse('polls:results', args=(question.id,)))\n\t```\n\n\t- 代码返回一个 HttpResponseRedirect 而不是常用的 HttpResponse；\n\t- HttpResponseRedirect 只接收一个参数：用户将要被重定向的 URL；\n\t- 在 HttpResponseRedirect 的构造函数中使用 reverse() 函数。这个函数避免了我们在视图函数中硬编码 URL。\n\n\t\t> reverse() 调用将返回一个这样的字符串 `/polls/3/results/`。\n\t\t> 其中 3 是 question.id 的值。重定向的 URL 将调用 'results' 视图来显示最终的页面。\n\t\t\n- 当对 Question 进行投票后，vote() 视图将请求重定向到 Question 的结果界面。让我们来编写这个视图 ( 这和上一章节中的 detail() 视图几乎一模一样，唯一的不同是模板的名字。 我们将在稍后解决这个冗余问题 )：\n\n\t```python\n\t# polls/views.py\n\tfrom django.shortcuts import get_object_or_404, render\n\n\tdef results(request, question_id):\n\t\tquestion = get_object_or_404(Question, pk=question_id)\n\t\treturn render(request, 'polls/results.html', {'question': question})\n\t```\n\t\n- 再创建一个 `polls/results.html` 模板：\n\n\t```html\n\t<!-- polls/templates/polls/results.html -->\n\t<h1>{{ question.question_text }}</h1>\n\n\t<ul>\n\t{% for choice in question.choice_set.all %}<li>\n\t\t{{ choice.choice_text }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}\n\t</li>{% endfor %}\n\t</ul>\n\n\t<a href=\"{% url 'polls:detail' question.id %}\">Vote again?</a>\n\t```\n\n#### 通用视图\n\n> 猜想：通用视图是否是通用模板的思想，即使用统一的界面展示数据？\n\n- detail() 和 results() 视图都很简单。并且，像上面提到的那样，存在冗余问题。\n- 这些视图反映基本的 Web 开发中的一个常见情况：根据 URL 中的参数从数据库中获取数据、载入模板文件然后返回渲染后的模板。 由于这种情况特别常见，Django 提供一种快捷方式，叫做“通用视图”系统。\n- 通用视图将常见的模式抽象化，可以使你在编写应用时甚至不需要编写 Python 代码。\n\n\t> 一般来说，当编写一个 Django 应用时，你应该先评估一下通用视图是否可以解决你的问题，你应该在一开始使用它，而不是进行到一半时重构代码。\n\n- 让我们将我们的投票应用转换成使用通用视图系统，这样我们可以删除许多我们的代码。我们仅仅需要做以下几步来完成转换，我们将：\n\t- 转换 URLconf。\n\t- 删除一些旧的、不再需要的视图。\n\t- 基于 Django 的通用视图引入新的视图。\n\n##### 改良 URLconf\n- 首先，打开 polls/urls.py 这个 URLconf 并将它修改成：\n\n\t```python\n\tfrom django.urls import path\n\tfrom . import views\n\n\tapp_name = 'polls'\n\turlpatterns = [\n\t\tpath('', views.IndexView.as_view(), name='index'),\n\t\t# 路径字符串中匹配模式的名称已经由 <question_id> 改为 <pk>\n\t\tpath('<int:pk>/', views.DetailView.as_view(), name='detail'),\n\t\tpath('<int:pk>/results/', views.ResultsView.as_view(), name='results'),\n\t\tpath('<int:question_id>/vote/', views.vote, name='vote'),\n\t]\n\t```\n\n##### 改良视图\n- 下一步，我们将删除旧的 index, detail, 和 results 视图，并用 Django 的通用视图代替。打开 polls/views.py 文件，并将它修改成：\n\n\t```python\n\tfrom django.http import HttpResponseRedirect\n\tfrom django.shortcuts import get_object_or_404, render\n\tfrom django.urls import reverse\n\tfrom django.views import generic\n\tfrom .models import Choice, Question\n\n\tclass IndexView(generic.ListView):\n\t\ttemplate_name = 'polls/index.html'\n\t\tcontext_object_name = 'latest_question_list'\n\n\t\tdef get_queryset(self):\n        \t\t# Return the last five published questions.\n        \t\treturn Question.objects.order_by('-pub_date')[:5]\n\n\tclass DetailView(generic.DetailView):\n\t\tmodel = Question\n\t\ttemplate_name = 'polls/detail.html'\n\n\tclass ResultsView(generic.DetailView):\n\t\tmodel = Question\n\t\ttemplate_name = 'polls/results.html'\n\n\t\tdef vote(request, question_id):\n\t\t\t# Same as above, no changes needed.\n\t```\n\n- 上述代码详细解释：\t\t\n\t- 默认情况下，通用视图 DetailView 使用一个叫做 `<app name>/<model name>_detail.html` 的模板。在我们的例子中，它将使用 `polls/question_detail.html` 模板。\n\t- `template_name` 属性是用来告诉 Django 使用一个指定的模板名字，而不是自动生成的默认名字。 \n\t- 我们也为 results 列表视图和 detail 视图指定了 template_name。即使它们在后台都是同一个 DetailView，results 视图和 detail 视图在渲染时具有不同的访问名称。\n\t- 类似地，ListView 使用一个叫做 `<app name>/<model name>_list.html` 的默认模板；我们使用 template_name 来告诉 ListView 使用我们创建的已经存在的 `polls/index.html` 模板。\n\t- 在之前的教程中，提供模板文件时都带有一个包含 question 和 latest_question_list 变量的 context。\n\t\t- 对于 DetailView ， question 变量会自动提供—— 因为我们使用 Django 的模型 (Question)， Django 能够为 context 变量决定一个合适的名字。\n\t\t- 对于 ListView， 自动生成的 context 变量是 question_list。为了覆盖这个行为，我们提供 `context_object_name` 属性，表示我们想使用 `latest_question_list`。\n\n### 自动化测试\n#### 为什么你需要写测试\n- `测试将节约你的时间`：在复杂的应用程序中，组件之间可能会有数十个复杂的交互。改变其中某一组件的行为，也有可能会造成意想不到的结果。判断「代码是否正常工作」意味着你需要用大量的数据来完整的测试全部代码的功能，以确保你的小修改没有对应用整体造成破坏，可想而知其中的工作量。\n- `测试不仅能发现错误且能预防错误`：测试是开发的对立面，这种思想是不对的，开发其实更像是一个不断试错的过程。\n\n#### 开始写一个测试程序\n- 约定俗称，Django 应用的测试应该写在应用的 `tests.py` 文件里，测试系统会自动的在所有以 tests 开头的文件里寻找并执行测试代码。\n- 制造一个 BUG：继续上述提及的应用 Polls，要求 Question 是在一天之内发布， 则 Question.was_published_recently() 方法将会返回 True 。然而现在这个方法在 Question 的 pub_date 字段比当前时间还晚 ( 未来的时间 ) 时也会返回 True。\n\n\t```python\n\timport datetime\n\tfrom django.utils import timezone\n\tfrom polls.models import Question\n\t# create a Question instance with pub_date 30 days in the future\n\ttime = timezone.now() + datetime.timedelta(days=30)\n\tfuture_question = Question(pub_date=time)\n\t# was it published recently? ==> True\n\tfuture_question.was_published_recently()\n\t```\n\n- 创造一个测试用例：创建一个 `django.test.TestCase` 的子类。\n\n\t```python\n\timport datetime\n\tfrom django.utils import timezone\n\tfrom .models import Question\n\tfrom django.test import TestCase\n\n\tclass QuestionModelTests(TestCase):\n\t    def test_was_published_recently_with_future_question(self):\n\t        \"\"\"\n\t        was_published_recently() returns False \n\t        for questions whose pub_date is in the future.\n\t        \"\"\"\n\t        time = timezone.now() + datetime.timedelta(days=30)\n\t        future_question = Question(pub_date=time)\n\t        self.assertIs(future_question.was_published_recently(), False)\n\t```\n- 最后，我们可通过 PyCharm 单独运行测试用例，也可以通过终端命令运行自动化测试。\n\n\t```bash\n\tpython manage.py test polls\n\t```\n\n- 发生了什么呢？以下是自动化测试的运行过程：\n\t- `python manage.py test polls` 将会寻找 Polls 应用里的测试代码，它找到了 django.test.TestCase 的一个子类，并创建一个特殊的数据库供测试使用；\n\t- 在类中寻找测试方法 ( 以 test 开头的 )，在 `test_was_published_recently_with_future_question` 方法中，它创建了一个 pub_date 值为 30 天后的 Question 实例。\n\t- 接着使用 `assertls()` 方法，发现 `was_published_recently()` 返回了 True，而我们期望它返回 False。\n\n## 参考资料\n- [1] [廖雪峰. Python 教程之 virtualenv. 2017. liaoxuefeng.com](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432712108300322c61f256c74803b43bfd65c6f8d0d0000)\n- [2] [地球的外星人君. Python Web 框架大乱斗：哪个框架适合你. 2017. zhihu.com](https://zhuanlan.zhihu.com/p/31447222)\n- [3] [知乎问答. Python 有哪些好的 Web 框架. zhihu.com](https://www.zhihu.com/question/20706333)","tags":["django"],"categories":["Project"]},{"title":"框架 | FastDFS 入门到应用","url":"%2F2019%2F02%2FFastDFS.html","content":"\n余庆老师在他的 Github 上介绍关于 [FastDFS](https://github.com/happyfish100/fastdfs) 开源项目的描述：FastDFS 是一个开源的高性能分布式文件系统 ( DFS )。 它的主要功能包括文件存储，文件同步和文件访问，以及高容量和负载平衡。\n\n<!-- More -->\n\n## FastDFS 简单介绍\n### FastDFS 核心组件\n- `Tracker Server`：跟踪服务器，负责维持集群的信息；负责管理所有的 Storage Server 和 Group，每个 Storage 在启动后会连接 Tracker，告知自己所属 group 等信息，并保持周期性心跳。\n- `Storage server`：存储服务器，以 Group 为单位进行组织，任何一个 Storage Server 都应该属于某个 Group；一个 Group 可含多个 Storage server；在同一个 Group 内部，各 Storage Server 的数据自行同步、备份。\n- `Client`：客户端，上传、下载数据的服务器，也就是我们自己的项目所部署在的服务器。\n\n\t>核心组件的介绍参考了 [1]、[2] 的概念叙述。\n\n### FastDFS 组织架构\n- 结合组件的功能描述可知，FastDFS 的组织架构 $^{[2]}$ 如图 1-1 所示。\n\n\t![fastdfs_1-1](/images/illustration/Project/2019/02/fastdfs_1-1.jpg)\n\t<center>图 1-1 FastDFS 的组织架构</center>\n\n### FastDFS 文件传输\n- 通过时序图，分析 FastDFS 文件上传、文件下载等操作的流程，如图 1-2 所示。\n\n\t![fastdfs_1-2](/images/illustration/Project/2019/02/fastdfs_1-2.jpg)\n\t<center>图 1-2 FastDFS 文件上传、下载的时序图</center>\n\t\n- 文件上传流程：\n\t- 1) Client 询问 Tracker，发送上传文件的请求；\n\t- 2) Tracker 返回可调用的 `Storage ID: Port`；\n\t- 3) Client 直接与目标 Storage 通讯，完成文件上传；\n\t- 4) Storage 返回 `文件ID`，文件ID 为 `Group ID + FileName`。\n- 文件下载流程：\n\t- 1) Client 询问 Tracker  下载文件所在的 Storage ( 参数为 `文件ID` )；\n\t- 2) Tracker 返回可调用的 `Storage ID: Port`；\n\t- 3) Client 直接与目标 Storage 通讯，完成文件下载；\n\t- 4) Storage 返回 `文件内容`。\n\n## FastDFS 客户端\n\n### Java 客户端\n- 调用余庆老师封装的 [FastDFS Client Java SDK](https://github.com/happyfish100/fastdfs-client-java)，即可实现客户端访问 FastDFS。\n\n### Python 客户端\n- `安装环境`：网上教程一般都是指 Python 2.7，在 Python 3.x 版本下跑不了，即使是通过 `pip3 install fdfs-client-py` 安装也跑不通，这里建议通过源码方式安装 $^{[3, 4]}$。\n\n\t> 源码地址：[Hay86. fdfs_client-py. Last Updated on Sept.9, 2018](https://github.com/jefforeilly/fdfs_client-py.git)\n\n\t```bash\n\t# Case.01.通过 pip 安装\n\tpip install fdfs_client-py-master.zip\n\t'''\n\tCase.02.通过 python 安装\n\t解压 fdfs_client-py-master.zip，进入目录 /fdfs_client-py-master\n\tpython steup.py install\n\t'''\n\t# 安装完成后，若导入时提示缺少 mutagen、requests，请继续安装依赖包\n\tpip install mutagen\n\tpip install requests\n\t```\n\n- `安装指南`：当然，安装指南和 [API Reference](https://github.com/hay86/fdfs_client-py#api-reference) 请参考源码的官方文档。\n\n- `生成配置`：在测试代码前夕，我们还需要创建一配置文件 `client.conf`。注意配置文件名称就是 **client.conf**，更改为其他名称好像行不通。\n\n\t```python\n\t# connect timeout in seconds\n\t# default value is 30s\n\tconnect_timeout=30\n\n\t# network timeout in seconds\n\t# default value is 30s\n\tnetwork_timeout=30\n\n\t# the base path to store log files\n\tbase_path=log\n\n\t# tracker_server can ocur more than once, and tracker_server format is\n\t# \"host:port\", host can be hostname or ip address\n\ttracker_server=192.168.200.221:22122\n\n\t# standard log level as syslog, case insensitive, value list:\n\t### emerge for emergency\n\t### alert\n\t### crit for critical\n\t### error\n\t### warn for warning\n\t### notice\n\t### info\n\t### debug\n\tlog_level=info\n\n\t# if use connection pool\n\t# default value is false\n\t# since V4.05\n\tuse_connection_pool = false\n\n\t# connections whose the idle time exceeds this time will be closed\n\t# unit: second\n\t# default value is 3600\n\t# since V4.05\n\tconnection_pool_max_idle_time = 3600\n\n\t# if load FastDFS parameters from tracker server\n\t# since V4.05\n\t# default value is false\n\tload_fdfs_parameters_from_tracker=false\n\n\t# if use storage ID instead of IP address\n\t# same as tracker.conf\n\t# valid only when load_fdfs_parameters_from_tracker is false\n\t# default value is false\n\t# since V4.05\n\tuse_storage_id = false\n\n\t# specify storage ids filename, can use relative or absolute path\n\t# same as tracker.conf\n\t# valid only when load_fdfs_parameters_from_tracker is false\n\t# since V4.05\n\tstorage_ids_filename = storage_ids.conf\n\n\n\t# HTTP settings\n\thttp.tracker_server_port=80\n\n\t# use \"#include\" directive to include HTTP other settings\n\t## include http.conf\n\t```\n\n- `测试代码`：这里假设你已成功安装了 `fdfs-client-py`，那么以一段测试代码正式开始使用。\n\n\t```python\n\t# Step.01. import fdfs_client.client module\n\t# Step.02. instantiate class Fdfs_client\n\t# Step.03. call memeber functions\n\n\tfrom fdfs_client.client import *\n\t# client.conf 配置文件放在 .py 文件同目录下\n\tclient = Fdfs_client('client.conf')\n\n\t# 上传文件\n\tret = client.upload_by_filename('upload.txt')\n\tprint(ret)\n\t## 等待 3 秒，否则下载时会报错文件不存在\n\ttime.sleep(3)  \n\t## 新版本文件存放 Remote file_id 格式变化\n\tfile_id = ret['Remote file_id'].replace('\\\\', '/')\n\t\n\t# 下载文件\n\tret_download = client.download_to_file('download.txt', file_id)\n\tprint(ret_download)\n\t```\n\n- `说明文档`：关于 `Fdfs_client` 类的成员函数详细说明请参考 [API Reference](https://github.com/hay86/fdfs_client-py#api-reference)：\n\t- upload_by_filename(self, filename, meta_dict = None)\n\t- upload_by_buffer(self, filebuffer, file_ext_name = None, meta_dict = None)\n\t- upload_slave_by_filename(self, filename, remote_file_id, prefix_name, meta_dict = None)\n\t- upload_slave_by_buffer(self, filebuffer, remote_file_id, meta_dict = None, file_ext_name = None)\n\t- upload_appender_by_filename(self, local_filename, meta_dict = None)\n\t- upload_appender_by_buffer(self, filebuffer, file_ext_name = None, meta_dict = None)\n\t- delete_file(self, remote_file_id)\n\t- download_to_file(self, local_filename, remote_file_id, offset = 0, down_bytes = 0)\n\t- download_to_buffer(self, remote_file_id, offset = 0, down_bytes = 0)\n\t- list_one_group(self, group_name)\n\t- list_all_groups(self)\n\t- list_servers(self, group_name, storage_ip = None)\n\t- get_meta_data(self, remote_file_id)\n\t- append_by_filename(self, local_filename, remote_fileid)\n\t- append_by_buffer(self, file_buffer, remote_fileid)\n\t- truncate_file(self, truncated_filesize, appender_fileid)\n\t- modify_by_filename(self, filename, appender_fileid, offset = 0)\n\t- modify_by_buffer(self, filebuffer, appender_fileid, offset = 0)\n\n\n## 参考资料\n- [1] [Mafly. 分布式文件系统 FastDFS 简单了解. 2016. cnblogs.com](https://www.cnblogs.com/mafly/p/fastdfs.html)\n- [2] [shenxm. FastDFS 的介绍. 2018. cnblogs.com](https://www.cnblogs.com/shenxm/p/8459292.html)\n- [3] [小草. FastDFS 的 Python 客户端. 2017. zifuchuan.com](http://zifuchuan.com/me/index.php/python/725-1.html)\n- [4] [ZbyFt. Django-FDFS 配置. 2018. csdn.net](https://blog.csdn.net/weixin_42149982/article/details/82391218)\n","tags":["DFS"],"categories":["Project"]},{"title":"极客 | 树莓派能做什么？","url":"%2F2019%2F01%2FRaspbian-Guideline.html","content":"\n树莓派能做什么？关于此命题，最直观感受就是看看树莓派实验室整理的一些[案例](http://shumeipai.nxez.com/what-raspi-used-for)，相信你心目中会有答案的。例如，打造一个家庭媒体中心 ( KODI )、配置无线路由器、搭建 BT 下载服务器、搭建代码托管服务器 ( SVN、GIt )、搭建网站服务器、搭建 Shadowsocks、用 HomeKit + Siri 声控家里电器等，即可把树莓派想象成嵌入式、微小型的服务器，这一过程就好比操作系统 ( Linux ) 赋予硬件生命，编程 ( Python、Java )、程序灌入灵魂，借助树莓派低能耗、移动便携性、GPIO 等特性，很多想法不是不可能，相信树莓派会给你创造更多的惊喜！\n\n<!-- more -->\n\n需要说明的是，本文将围绕两大方面去探索树莓派，即基础应用和解决方案两大部分，也可理解为基础到进阶的过程。\n\n- [基础应用](#基础应用)：介绍使用树莓派必须的应用或组件，这些应用和组件主要作用是：一方面是增强系统功能，另一方面则是为解决方案建立软件基础。\n- [解决方案](#解决方案)：诸如引言中谈及的，搭建服务器、智能家居控制中心等，即针对某部分需求集成为服务，学术说法称其为某某即服务 ( XaaS )。\n\n## 版本信息\n- 树莓派型号：树莓派 3B+\n- 树莓派系统：[Raspbian v.3.0.0](https://www.raspberrypi.org/downloads/noobs/)\n\n## 更新进度\n\n- 2019.01.21：完成初稿，形成笔记的整体框架；\n- 2019.02.25：更新「Jupyter 服务器」 章节内容；\n- 2019.02.26：更新「Conda 服务器」 章节内容；\n\n## 教学资源\n\n- 🚩 | 社区 | [树莓派实验室](http://shumeipai.nxez.com/) | 教程、创意、作品、资讯、硬件五位一体的爱好者交流社区。\n- 🚩 | 社区 | [趣无尽](https://www.quwj.com/) | 树莓派高端、创意的玩法探索博客站。\n- 📄 | 资料 | [亚博智能官方资料. 树莓派3代B型开发板](https://www.yahboom.com/study/raspberry) | [资料打包下载 ( bwnr )](https://pan.baidu.com/s/1OUa0KszF7sxim5FcUdqccQ)\n\n## 基础应用\n\n### TeamViewer 远程控制\n\n#### 引言\n\n访问树莓派有多种方式，如直连显示器交互使用、通过 SSH 远程登录访问、通过软件实现控制使用等。其中，TeamViewer 是通过软件方式实现对树莓派的远程控制，其拥有有以下几种特性：\n\n- 可穿透局域网，支持外网连接；\n- 实时 GUI 界面显示；\n- 支持文件双向传输。\n\n#### 配置\n\n在本节，则单独介绍 TeamViewer 的配置与使用，当然教程是参考文章 [[5]](http://www.52pi.net/archives/549)、[[6]](https://blog.csdn.net/realDonaldTrump/article/details/79694196) 整理而得。\n\n##### 删除 TeamViewer\n\n删除 TeamViewer，用于安装出错时，清理残留软件包，方便从头再来。😂\n\n> 此步骤是非必要执行的步骤。\n\n```bash\nsudo apt-get remove teamviewer-host\n# 清除所有已删除包的残余配置文件\n# 若报错误 dpkg: –purge needs at least one package name argument\n# 证明你的系统中没有残留配置文件了\ndpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P\n```\n\n##### 安装 TeamViewer\n\nStep.01：进入 [官方下载](https://www.teamviewer.com/en-us/download/linux/)，在「TeamViewer Host for Raspberry Pi」模块，复制安装包地址，接着正式开始安装：\n\n```bash\n# 通过 wget 在线下载安装包\nwget https://download.teamviewer.com/download/linux/teamviewer-host_armhf.deb\n# 安装本地软件包，但不解决依赖关系\nsudo dpkg -i teamviewer-host_armhf.deb\n# 修复损坏的软件包，尝试卸载出错的包，重新安装正确版本的\nsudo apt-get -f install\n\t\t\n# 若提示未找到依赖包，可安装 Gdebi，通过 Gdebi 安装解决依赖问题\n# 使用 Gdebi 可代替软件中心接管 deb 软件包的安装\n# 它会根据软件仓库这一实用的特性来解算依赖关系\nsudo apt-get install gdebi\nsudo gdebi teamviewer-host_armhf.deb\n```\n\n##### 配置 TeamViewer\n\nStep.02：因为我们烧写的系统有图形界面，默认 TeamViewer 要在图形界面进行配置，如远程控制的账号、密码设置等。若有条件支持，可移步图形化界面操作，即可忽略此步骤。\n\n- 没有图形界面，则我们需要在命令行下配置。使用 `raspi-config` 配置 Raspbian 仅命令行模式运行。\n\t\t\n\t```bash\n\tsudo raspi-config\n\t\t\n\t# 命令模式的操作界面\n\t# 依次选择操作 ( 同理，还原桌面模式也是类似操作 )\n\t# Boot Options -> Desktop / CLI -> Console AutoLogin ->\n\t# Finished\n\t```\n\t\t\n- 配置保存后，树莓派会自动重启，那么重新远程登录继续操作。\n\n\t```bash\n\tsudo teamviewer setup\n\t# 1. Accept License Agreement? (y/n) y\n\t# 2. 输入用户名和密码的步骤无法跳过，没有账号请移步「官网完成注册」\n\t# \t 注册地址：https://login.teamviewer.com/LogOn\n\t# \t Please enter your e-mail / username: kofe\n\t# \t Please enter your password: ******\n\t# 3. 然后 TeamViewer 会发一份设备授权邮件，请移步「邮箱处理」\n\t# 4. 重新输入用户名和密码登录，提示分组信息，点击 y：\n\t# \t Adding this machine as 'raspberrypi' to ... \n\t#\t Do you want to continue? (y/n) [n]  y\n\t# 5. 提示 \"Successfully....\" 即表示已经完成配置工作了\n\t```\n\t\t\t\n- 完成初始化配置后，只需设置远程控制密码即可使用了。\n\n\t```bash\n\t# 查看本机 ID\n\tteamviewer info\n\t# 设置本机密码\n\tteamviewer passwd [你的密码]\n\t```\n\t\t\t\n- 当然，我们还需要把 Raspbian 还原为图形化操作界面。\n\n\t```bash\n\tsudo raspi-config\n\t# Boot Options -> Desktop / CLI -> Desktop AutoLogin ->\n\t# Finished\n\t```\n\t\t\t\n#### 使用\n\t\t\t\n- 一般情况下，我们主要是通过命令模式访问树莓派、配置 TeamViewer。当然也可以通过图形界面完成配置操作，按照文字提示操作即可，这里就不详细阐述了。附上 TeamViewer 常用的命令：\n\n\t```bash\n\t# 查看帮助信息\n\tteamviewer help\n\t# 查看本机 ID\n\tteamviewer info\n\t# 设置本机密码\n\tsudo teamviewer passwd [你的密码]\n\t# 启动 TeamViewer 服务\n\tsudo teamviewer --daemon start\n\t# 开启 TeamViewer 服务随机启动\n\tsudo teamviewer --daemon enable\n\t```\n\n- 最后，关于图形化界面显示方面，可能还有分辨率调整与存在黑边的问题，详细可参考以下文章解决问题：\n\t- [树莓派. 官方使用文档之 CONFIG-TXT. raspberrypi.org](https://www.raspberrypi.org/documentation/configuration/config-txt/README.md)\n\t- [FishChina. 树莓派有黑边不能全屏解决方法. 2017. csdn.net](https://blog.csdn.net/fishchina/article/details/54564395)\n\t\t\n### MySQL 数据库\n\n#### 引言\n\n数据库的用途毋庸置疑，若在树莓派上跑脚本、程序、网站系统等，少不了数据的交互，为此我们需要一款数据库作为数据储存的媒介。MySQL，是一款开源免费的数据库，也是关系型数据库管理系统，支持多种存储引擎 $^{[1, 2]}$，对于个人开发和日常使用足矣。\n\n以下将介绍，在树莓派 Raspbian 上安装 Mysql  服务，并开启远程访问。\n\n#### 安装 MySQL\n\n- 删除 MySQL：安装前，确保系统没有旧版的 MySQL。\n\n\t```bash\n\tsudo apt-get autoremove --purge mysql-server\n\tsudo apt-get remove mysql-common\n\t\n\t# 清除所有已删除包的残馀配置文件\n\t# 若报错误 dpkg: –purge needs at least one package name argument\n\t# 证明你的系统中没有残留配置文件了\n\tdpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P\n\t```\n\t\n- 安装 MySQL：\n\n\t```bash\n\tsudo apt-get install mysql-server\n\tsudo apt-get install mysql-client\n\tsudo apt-get install python-mysqldb # 安装 Python 接口的 MySQL\n\t```\n\t\n#### 配置 MySQL\n\t\n- 命令行安装，默认是不用配置用户和密码信息，故我们首先配置登录信息 $^{[3]}$：\n\t\t\n\t```sql\n\tsudo mysql -u root # 无密码登录 MySQL\n\tuse mysql;\n\t\t\n\t# 加密方式选择，系统默认是 'unix_socket'，这里暂为空\n\tUPDATE user SET plugin='' WHERE user='root';\n\t\t\n\tUPDATE user SET password=PASSWORD('你自己的密码') WHERE user='root';\n\n\tflush privileges; # 清空缓存\n\texit;\n\t```\n- 操作数据库 ( 配置完信息，重启 MySQL 以让设置生效 )\n\n\t```bash\n\t# sudo /etc/init.d/mysql status/start/stop/restart\n\tsudo /etc/init.d/mysql restart\n\t\t\n\t# 当然可通过 systemctl 命令管理系统服务\n\t# sudo systemctl restart mysql # 重启系统服务\n\t# sudo systemctl status mysql # 查看系统状态\n\t```\n\n#### 开启远程访问\n\n以上配置工作完成后，即可本地使用 MySQL 数据库了。若需要开启远程访问服务，我们还需要实现以下工作：防火墙与访问规则配置和远程登录的账号配置。\n\n##### 外网访问\n若在树莓派下测试，让数据库允许外网访问，注意得关闭防火墙或添加规则允许某端口的访问权限 $^{[4]}$。\n\n- Case.01：本机和服务器端 ( 树莓派 ) 互相 Ping 对方 IP，以检验网络是否畅通、是否拒绝访问。\n- Case.02：若网络畅通、没有拒绝访问，还要留意对应端口是否有权限访问，通过 nc -vz IP 端口检验，返回 Succeeded 即成功。\n\n\t```bash\n\t# MacOS：nc -vz IP地址 端口号\n\tnc -vz 192.168.x.x 3306\n\t# Windows：telnet IP地址 端口号\n\ttelnet 192.168.x.x 22 # SSH 远程访问\n\ttelnet 192.168.x.x 3306 # MySQL 数据库\n\t```\n\n##### 防火墙与访问规则\n\t\t\n针对上述两种情况，则可通过关闭防火墙或者添加端口的访问规则，以授权 IP 和相关端口接受访问。\n\n- 配置防火墙：\n\n\t```bash\n\t# 安装 ufw ( 已安装忽略 )\n\tsudo apt-get install ufw\n\t# 设置默认规则为 allow，除指明打开的端口，所有端口默认关闭\n\tufw default deny\n\t# 启用 /关闭 ufw\n\tufw enable/disable\n\t# 查看防火墙状态\n\tufw status\n\t```\n\t\t\t\n- 配置访问规则：\n\n\t```bash\n\t# 例如：打开 SSH 远程登录\n\tsudo ufw allow 22\n\t# 删除添加过的规则\n\tsudo ufw delete allow 22\n\t```\n\n##### 远程登录的账号\n\n最后，我们还需要设置可远程登录的账号。\n\n- 修改 MySQL 配置：\n\n\t```bash\n\tsudo vim /etc/mysql/mariadb.conf.d/50-server.cnf\n\t# 找到 bind-address 这行注释掉，然后重启\n\tsudo systemctl restart mysql\n\t```\n\t\t\n- 修改 MySQL 账号信息：在配置 `登录信息` 时已授权，此项可日后用作远程登录账号的配置。\n\t\n\t```sql\n\tmysql -u root -p\n\tuse mysql;\n\tGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root账号密码' WITH GRANT OPTION;\n\tflush privileges;\n\t```\n\n### Jupyter 服务器\n#### 引言\nJupyter Notebooks 是什么？相信做数据科学项目的同学都清楚，Jupyter 其提供了一个集成环境，无需更多附加操作就可在其中编写你的代码、运行代码、查看输出、可视化数据并查看结果。\n\n作为一款可执行端到端的数据科学工作流程的便捷工具，它不仅支持数据清理、统计建模、构建和训练机器学习模型、可视化数据等数据科学工作，而且其强大的交互性，使得它可以更具教学性的方式展示代码。\n\n> 当然 Jupyter 也能运行其他 Python 程序，这里只是为了代入特定场景介绍它。\n\n\n#### 安装 Jupyter Notebook\n\n- 在此之前，需要确保你安装了 `Python` 以及 `pip` 模块。\n\n\t```bash\n\t# 树莓派 Raspbian 原生内置了 Python 2.7\n\t# 我们需要基于 Python 3.x 基础上运作 Jupyter，则需要先安装 Python 3.x\n\tsudo apt-get install python3.5 python3-pip\n\t```\n\n- 安装 Jupyter Notebook：\n\n\t> 若你已经有使用 virtualenv 的经验，强烈建议在虚拟环境中安装所需版本的 jupyter notebook。\n\n\t```bash\n\t# 基于 Python 2.7\n\tpip install --upgrade jupyter\n\t# 基于 Python 3.x\n\tpip3 install --upgrade jupyter\n\t\n\t# 检查是否安装成功，成功返回版本号\n\tjupyter --version\n\t```\n\n#### 配置 Jupyter Notebook\n\n配置 Jupyter Notebook，参考了文档 [[7]](https://www.jianshu.com/p/639c8d939643)：\n\n- 生成配置文件：注意不同用户组，生成的配置文件是存放在不同位置的。\n\n\t```bash\n\t# 配置文件存放于 /root/.jupyter/jupyter_notebook_config.py \n\tsudo jupyter notebook --generate-config\n\t# 配置文件存放于 /home/pi/.jupyter/jupyter_notebook_config.py ( 推荐 )\n\t# /home/pi/ 为当前登录用户的工作目录\n\tjupyter notebook --generate-config\n\t```\n\n- 设置密码：终端进入 iPython / Python 环境，借助 Python 生成 SHA 密钥：\n\n\t> 若不开启远程服务，则可跳过此步骤。\n\n\t```python\n\t>>> from notebook.auth import passwd # 导入授权模块设置密码\n\t>>> passwd() # 提示键入密码\n\tEnter password: your password\n\tVerify password: your password again\n\t# 密码的哈希值，用于配置文件中设置密码\n\t'sha1:67c9e601de......7d111089e11aed' \n\t```\n\n- 进入配置文件：\n\n\t```bash\n\tsudo vim /home/pi/.jupyter/jupyter_notebook_config.py \n\t```\n\t\t\n- 修改配置内容：配置选项非常丰富，关于其他配置的选项用途详细可参考 `jupyter_notebook_config.py` 内的注释。\n\n\t```bash\n\t# 注意开启配置选项，记得去掉 #，才能使配置生效！\n\t# 允许所有 IP 访问\n\tc.NotebookApp.ip='*'\n\t# 远程访问密钥\n\tc.NotebookApp.password = u'sha:67c9e......11aed'\n\t# 不在本机自动打开浏览器\n\tc.NotebookApp.open_browser = False\n\t# 指定监听端口\n\tc.NotebookApp.port =8888\n\t# Jupyter 的默认工作目录\n\tc.NotebookApp.notebook_dir = '/home/pi/ipynb/'\n\t# 允许使用 root 用户启动 jupyter\n\t# c.NotebookApp.allow_root = True\n\t```\n\t\t\n- 启动 Jupyter Notebook：`jupyter notebook`\n\n#### 拓展 Jupyter Notebook\n##### 开启远程访问\nJupyter Notebook 开启远程访问 ( 远程访问这里指同一局域网，其他终端访问树莓派，若是要外网访问请参阅内网穿透相关内容 )，但端口被拒绝访问。\n\n- 在配置文件中，我们只设置了 `0.0.0.0` 或 `*` 的 IP 地址，在局域网环境运行能正常访问。但对于远程访问，归根结底，我们还需要知道树莓派的 IP 才能访问到服务端的 Jupyter，故我们是这样解决访问问题的 $^{[7]}$。\n\n\t```bash\n\t# nohup: 一直执行命令，即使关闭了 SSH。\n\t# --ip: 指定在 192.168.10.200 ( 树莓派的IP ) 上监听活动。\n\t# &: 在后台运行这条命令。\n\tnohup jupyter notebook --ip 192.168.10.200 &\n\t```\n\n- 最后，我们需要确保该端口是否在安全策略下已经开启，详细可参考 MySQL 数据库的 [防火墙与访问规则](#防火墙与访问规则) 章节内容。\n\n##### 开启自启服务\n搭建 Jupyter 服务器，Jupyter 挂靠后台服务，且开通断电自动重启功能，参考了文档 [[8]](https://blog.csdn.net/q361949240/article/details/83179560)。\n\n- 在 `/etc/systemd/system` 下创建 `jupyter.service` 输入如下内容：\n\n\t```bash\n\tsudo vim /etc/sytemd/system/jupyter.service\n\t```\n\n- `jupyter.service` 内容填写如下：\n\n\t```bash\n\t[Unit]\n\tDescription=Jupyter Notebook\n\tAfter=network.target\n\n\t[Service]\n\tType=simple\n\t# 这里在 /run 目录下没有 jupyter.pid\n\t# 这个是进程产生之后出现的，虽然在启动前没有，但是可以使用\n\tPIDFile=/run/jupyter.pid\n\t# ExecStart 是执行文件 jupyter-notebook\n\t# config 是配置文件 jupyter_notebook_config.py\n\t# ip 是树莓派的地址\n\tExecStart=/usr/local/bin/jupyter-notebook --config=/home/pi/.jupyter/jupyter_notebook_config.py --ip=192.168.10.200\n\tUser=pi\n\t# 查看用户组 groups pi，发现属于 pi 组\n\tGroup=pi\n\t# 自己设置的工作目录\n\t# 需同时在 jupyter_notebook_config.py 中设置\n\t# c.NotebookApp.notebook_dir = '/home/pi/ipynb/'\n\tWorkingDirectory=/home/pi/ipynb/\n\tRestart=always\n\tRestartSec=10\n\n\t[Install]\n\tWantedBy=multi-user.target\n\t```\n\n- 使服务自启动：`systemctl enable jupyter`\n- 启动服务：`service jupyter start`\n\n##### 加载虚拟环境\n- 首先，我们为 Jupyter Notebook 创建隔绝的虚拟环境，从而便捷、更针对地管理软件包。\n\n\t> 比如，某个 Python 程序需要 Python 2.7 特定环境运行，而我们编译的环境是 Python 3.x ，即为了运行该程序需要把原来的 Python 3.x 给替换成 Python 2.7。同理，对于程序的依赖包，即使是同一个软件包也存在不同版本的要求。那么问题就出现在这，在同一台电脑上，为让更多程序兼容运行，这正是虚拟环境的作用之一。  \n\t\n- 再者，引入 [Conda 管理器](#Conda-管理器) 的概念，简单来说 Conda 是一款包管理系统。conda 与 pip 类似，它会根据你的键入需求，且自行交代清楚相互依赖的包，并实现自动化地下载、安装它们。\n\n- 基于以上两点的理解，我们正式进入正题，开始配置一个虚拟环境，并让 Jupyter Notebook 使用起来：\n\n\t```bash\n\t# 1. 参考 Conda 管理器的 BerryConda 小节，完成 BerryConda 的安装\n\t# 2. 建立一个虚拟环境运作 Conda 以方便管理各种包\n\tconda create -n your_venv_name python=3.6\n\t# 3. 激活环境\n\tsource activate your_venv_name\n\t# 4. 安装 Jupyter 包：上述内容中，Jupyter 是安装在原生环境下的\n\t# 考虑到兼容性的情况 (例如第5点的情况)，在该虚拟环境中重新安装一个 Jupyter\n\tconda install jupyter\n\t# 给该环境下载其他软件包也是类似操作\n\t# conda install scipy numpy scikit-learn...\n\t# 5. 指定版本安装 tornado，不然 Jupyter 会报错\n\tconda install tornado=4.5\n\t# 6. 安装 nb_conda 包，让 Jupyter 支持使用虚拟环境\n\tconda install nb_conda\n\t```\n\n- 若使用虚拟环境中的 Jupyter ( 自启服务的 ExecStart 设置同理 )，此时启动 Jupyter 的程序应该改为：\n\n\t```bash\n\t# /home/pi/ 为当前登录用户的工作目录\n\t/home/pi/berryconda3/envs/your_venv_name/bin/jupyter-notebook\n\t```\n\n##### 打造科学环境\n###### Tensorflow \n值得庆贺的是，[Tensorflow 1.9](https://medium.com/tensorflow/tensorflow-1-9-officially-supports-the-raspberry-pi-b91669b0aa0) 官方版本开始支持树莓派 RaspBerry Pi 了，没有繁琐的步骤即可体验 Tensorflow！具体的安装方法大概参考 [Tensorflow 官方说明文档](https://tensorflow.google.cn/install/pip)。\n\n- 但在实操过程中还是碰到了不可预计的情况：\n\n\t```bash\n\t# 1. 安装 libatlas-base-dev (Required for Numpy)\n\tsudo apt install libatlas-base-dev\n\t# 2. 同样，在虚拟环境内安装 tensorflow，虚拟环境的 Python 版本为 3.6\n\tsource activate your_venv_name\n\t# 3. 安装 h5py、hdf5，不然 tf 安装过程中会报错 ( 缺少 hdf5.h 文件 )：\n\t# /tmp/pip-install-ve4RnJ/h5py/h5py/api_compat.h:27:18: \n\t# fatal error: hdf5.h: No such file or directory\n\t# 4. 通过 conda 安装 h5py ( 好像 pip (Python3.x) 安装 h5py 会遇到缺少文件的问题？)\n\tconda install h5py \n\t# 5. 正式安装 tensorflow\n\t# pip --version 查看是否是虚拟环境的 pip，不然未能安装在当前环境\n\tpip install --upgrade --user tensorflow\n\t```\n\t\n- 若中途不出错、不提示错误，等待安装成功即可。然后输入代码测试验证：\n\n\t```bash\n\tpython # 命令进入 ipython / python 模式\n\t>>> import tensorflow as tf\n\t>>> tf.enable_eager_execution()\n\t>>> print( tf.reduce_sum(tf.random_normal([1000, 1000])) )\n\t```\n\n- 当然，还可能遇到 tensorflow 部分模块的 Python 版本跟编译环境的 Python 版本对不上，则可通过针对 ( 编译环境的 ) Python 版本的 pip 升级 tensorflow 解决此问题：\n\n\t```bash\n\t# 异常的情况大概如下：\n\t# /usr/lib/python3.6/importlib/_bootstrap.py:219: \n\t# RuntimeWarning: compiletime version 3.5 of module 'tensorflow.python.framework.fast_tensor_util' \n\t# does not match runtime version 3.6\n\tpython3.6 -m pip install --upgrade --user tensorflow\n\t```\n\n###### Keras\n- 安装过程演示：\n\n\t```bash\n\t# 1. 同样，在虚拟环境内安装 keras，虚拟环境的 Python 版本为 3.6\n\tsource activate your_venv_name\n\t# 2. 正式安装 keras\n\t# pip --version 查看是否是虚拟环境的 pip，不然未能安装在当前环境\n\tpip install --upgrade --user keras\n\t```\n\t\n- 当然，还可能遇到版本对不上的异常，参考 上述解决方案：\n\n\t```bash\n\tpython3.6 -m pip install --upgrade --user keras\n\t```\n\n##### 常见问题整理\n- 当新建或修改 ipynb 文档时，出现 `Permission denied: Untitled.ipynb` 权限异常，检查工作目录是否具有操作权限、当前用户是否有操作权限。\n\n\t```bash\n\t# 确保 Jupyter 工作目录属于当前登录用户 pi\n\tsudo chown -R pi:pi /home/pi/ipynb\n\t# 确保 Jupyter 工作目录有可读、可写和可执行的权限\n\t# 更新后的权限情况：drwxrwxr--\n\tchmod ug=rwx /home/pi/ipynb\n\t```\n\n### Conda 管理器\n#### 引言\n无论是使用 Jupyter Notebook，亦或是原生 Python 环境做 `数据科学` 相关工作，难免需要 `安装各种科学计算包`，而且还涉及众多依赖包的安装。那么如何管理包变成了一门 \"手艺活\" 了，此时推荐你使用 Conda 包管理系统，繁琐的包安装工作交由 Conda 处理，你只管专心地开展数据科学工作。\n\n参考 [树莓派 Raspbian 系统可安装 Anaconda 吗？](https://www.zhihu.com/question/65430209)，得知树莓派安装 Conda 共有两种选择：\n\n- [MiniConda](https://conda.io/en/latest/miniconda.html)：年久未更，目前 Python 只停留在 Python 3.4 版本。\n- [BerryConda](https://github.com/jjhelmus/berryconda)：是一款为树莓派定制基于 Conda Python 发行版的开源软件。Berryconda 提供了 Python 2.7 的 Berryconda 2 和 Python 3.6 的 Berryconda 3，同时还支持树莓派 0、1、2、3 各个系列，我们可根据树莓派的版本选择适合的软件版本安装即可。\n\n#### Miniconda\nMiniconda 与 Anaconda 同为发行版本的 Conda 包管理系统，Miniconda 则是最小的 Conda 安装环境。以下直接安装操作演示，安装过程参考了 [[9]](https://blog.csdn.net/tju_cc/article/details/80024721)、[[10]](https://www.jianshu.com/p/edaa744ea47d)。\n\n\n##### 安装 MiniConda\n- 首先，确保安装了 `wget` 和 `bzip2`：\n\t\t\n\t```bash\n\t# 查看是否有反馈，有则表示已安装\n\twget --help\n\tbzip2 --help\n\tsudo apt-get install -y wget bzip2\n\t```\n\t\t\t\n- 下载安装脚本：\n\n\t```bash\n\t# wget 不添加参数，默认是保存到当前路径\n\t# wget -O /path/name 指定路径及文件名\n\twget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-armv7l.sh   \n\t```\n\t\t\t\n- 运行安装脚本：\n\n\t> 安装过程中不需要使用 sudo，程序默认会安装到 /home/pi/miniconda3 中。当然，也是为了确保 miniconda3 工作目录属于当前登录用户 pi。\n\n\t```bash\n\tbash Miniconda3-latest-Linux-armv7l.sh\n\t# 安装过程中，需要阅读一份声明，后面需要输入两次 Yes 确认\n\t# 第一个 Yes 是是否同意声明，若回车跳过则是默认输入了 No\n\t# 第二个 Yes 是添加到环境变量，否则需要自己手动添加到环境变量\n\t# --------- 若选择了 No 则需进行以下步骤的操作 --------- #\n\t# 1. 编辑 /bashrc 文件\n\tvim /home/pi/.bashrc\n\t# 2. 添加以下内容 (根据自己的安装路径修改)：\n\t# export PATH=\"/home/pi/miniconda3/bin:$PATH\"\n\t# 3. 添加完成后记得让其生效 ( 启动时才执行原则 )\n\t# export 生成的环境变量是临时的，关闭终端即结束 ( 可改永久性环境变量 )\n\tsource /home/pi/.bashrc\n\t```\n\n##### 使用 MiniConda\n- 检查 conda 是否安装成功，返回版本信息：\n\n\t```bash\n\t# 检查 conda 是否安装成功，返回版本信息\n\tconda --version\n\t# 显示当前已经安装好的包\n\tconda list \n\t```\n\n- `创建虚拟环境`，以避免 \"污染\" 环境，便于管理各种 Python 包：\n\n\t```bash\n\t# 建立一个虚拟环境运作 Conda 以方便管理各种包\n\tconda create -n your_venv_name python=3.4\n\t# 删除一个虚拟环境：\n\t# conda env remove -n your_venv_name\n\t# 激活环境 <---> 关闭环境：source deactivate\n\tsource activate your_venv_name \n\t```\n\t\n- 更改国内源，优化安装包下载速度：\n\n\t```bash\n\t# 添加国内下载源 ( 例如: 清华源 )\n\tconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n\tconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\n\tconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/\n\t# 替换源后记得更新 Conda 以促使配置生效\n\tconda update conda\n\t```\n\t\n- 使用 Conda 安装包:\n\n\t```bash\n\t# 事先查找指定软件是否存在\n\tconda search numpy\n\t# 安装指定软件\n\tconda install numpy\n\t# 安装特定版本的软件，Conda 会先卸载已安装版本，然后重新安装指定版本\n\tconda install 软件名=版本号\n\t# 更新指定软件\n\tconda update numpy\n\t# 卸载指定软件\n\tconda remove numpy\n\t```\n\n##### 卸载 MiniConda\n- 卸载 MiniConda 的方法：\n\n\t```bash\n\t# 1. 在 /home/pi/.bashrc 移除环境变量 ( 注释掉 )\n\t# export PATH=\"/home/pi/miniconda3/bin:$PATH\"\n\t# 2. 删除 miniconda 整个文件\n\trm -rf miniconda3/\n\t# 3. 重新激活 .bashrc\n\tsource /home/pi/.bashrc\n\t```\n\n#### BerryConda\nBerryConda 是一款为树莓派定制基于 conda python 发行版的开源软件。安装过程参考了 [[11]](https://www.jianshu.com/p/ccad38dbb897)。\n\n##### 安装 BerryConda\n- 参考 [BerryConda](https://github.com/jjhelmus/berryconda) 文档，根据自己的机器版本 ( 树莓派 3B+ / Armv7l 架构 )，并确定 Python 版本号 ( Python 3.x )，为此选择了 Berryconda 3 版本安装，安装方法与 Miniconda 类似。\n\n- 下载安装脚本：\n\n\t> 安装过程中不需要使用 sudo，程序默认会安装到 /home/pi/berryconda3 中。当然，也是为了确保 berryconda3 工作目录属于当前登录用户 pi。\n\n\t```bash\n\twget https://github.com/jjhelmus/berryconda/releases/download/v2.0.0/Berryconda3-2.0.0-Linux-armv7l.sh\n\t```\n\t\n- 执行安装脚本：\n\t\n\t```bash\n\tbash Berryconda3-2.0.0-Linux-armv7l.sh\n\t# 安装过程中，需要阅读一份声明，后面需要输入两次 Yes 确认\n\t# 第一个 Yes 是是否同意声明，若回车跳过则是默认输入了 No\n\t# 第二个 Yes 是添加到环境变量，否则需要自己手动添加到环境变量\n\t# --------- 若选择了 No 则需进行以下步骤的操作 --------- #\n\t# 1. 编辑 /bashrc 文件\n\tvim /home/pi/.bashrc\n\t# 2. 添加以下内容 (根据自己的安装路径修改)：\n\t# export PATH=\"/home/pi/miniconda3/bin:$PATH\"\n\t# 3. 添加完成后记得让其生效\n\t# export 生成的环境变量是临时的，关闭终端即结束 ( 可改永久性环境变量 )\n\tsource /home/pi/.bashrc\n\t```\n\n##### 使用 BerryConda\n- 至此，BerryConda 已经安装完成，查看版本信息检验是否安装成功，剩余的 Conda 操作参考 [使用 MiniConda](#使用-MiniConda) 章节即可。\n\n\t```bash\n\t# 检查 conda 是否安装成功，返回版本信息\n\tconda --version\n\t# 显示当前已经安装好的包\n\tconda list \n\t```\n\n## 解决方案\n\n## 参考资料\n\n- [1] [百度百科. 存储引擎. baike.baidu.com](https://baike.baidu.com/item/存储引擎)\n- [2] [jaywcjlove. mysql-tutorial. 2017. github.com](https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md)\n- [3] [编程浪子. 树莓派3之安装Mysql服务. 2018. cnblogs.com](https://www.cnblogs.com/apanly/p/9061803.html)\n- [4] [farYang. 树莓派安装mysql并开启远程访问. 2016. csdn.net](https://blog.csdn.net/faryang/article/details/50788795)\n- [5] [Li, TaterLi. 十步配置TeamViewer远程控制Pi. 2017. 52pi.net](http://www.52pi.net/archives/549)\n- [6] [萝是carrot夢是Dream. 树莓派安装配置TeamViewer实现外网远程控制. 2018. csdn.net](https://blog.csdn.net/realDonaldTrump/article/details/79694196)\n- [7] [终可见. 树莓派 3B 搭建 Jupyter notebook. 2018. jianshu.com](https://www.jianshu.com/p/639c8d939643)\n- [8] [齐志刚. 树莓派 3B Jupyter notebook 设置为后台服务. 2018. csdn.net](https://blog.csdn.net/q361949240/article/details/83179560)\n- [9] [Holy_C. 树莓派 miniconda3+opencv3.3+tensorflow1.7 踩坑总结. 2018. csdn.net](https://blog.csdn.net/tju_cc/article/details/80024721)\n- [10] [卖萌哥. Conda 的安装与使用. 2018. jiansu.com](https://www.jianshu.com/p/edaa744ea47d)\n- [11] [Speculatecat. 解决 Raspbian Miniconda 无法安装最新 Python3.6. 2018. jianshu.com](https://www.jianshu.com/p/ccad38dbb897)","tags":["数据科学"],"categories":["Technique"]},{"title":"讲座 | 利用 t-SNE 降维并可视化数据","url":"%2F2018%2F11%2FThe-Best-Way-to-Visualize-a-Dataset-Easily.html","content":"\n{% note default %}  \n作者：Siraj Raval  \n课堂：The Best Way to Visualize a Dataset Easily | [Bilibili](https://www.bilibili.com/video/av35768109) | [Youtube](https://www.youtube.com/watch?v=yQsOFWqpjkE)  \n源码：llSourcell.Visualize_dataset_demo | [Github](https://github.com/llSourcell/visualize_dataset_demo)  \n{% endnote %}\n\n- `目标`：在本次课堂中，将对人类活动识别 ( Human Activity Recognition，HAR ) 数据集进行数据可视化呈现，并进行探索性分析以发现知识。而本课堂具体目标则是人类活动状态识别，活动状态包括：Sitting-down，Standing-up，Standing，Walking，Sitting。\n\n\t具体地，通过降维方法 `t-SNE` 实现不同活动状态的数据自动 \"分类\" ( 更准确地说应该是聚类 )，从而在低维度 ( 二维 ) 下复现数据 ( 的特征 )，以便我们理解数据、统计分析数据。\n\t\n- `问题`：若我们要将要描述如此复杂的数据，即它们拥有的特征 ( 维度 ) 过多了，相对于人类大脑只能理解二维或三维的层面，如此复杂数据我们是难以从中发现知识的。\n\n- `解决`：通过可视化数据来描述它们的特征，具体措施是使用机器学习中的降维方法 `T-SNE` ( Distributed Stochastic Neighbor Embedding )，把高维空间中的数据以二维或三维的形式表示。\n\n<!-- More -->\n\n- HAR 数据集的数据来源：参与者绑上健身追踪设备，当它们运动起来时，追踪设备会记录这些身体指标数据。\n\n\t> 关于HAR 数据集更详细的描述请参考：[HAR Set 介绍](http://groupware.les.inf.puc-rio.br/har#ixzz4Mt0Teae2) | [HAR Set 下载](https://d396qusza40orc.cloudfront.net/predmachlearn/pml-training.csv)\n\n## 观察数据\n- 每一行数据代表不同的人。\n- 每一列代表某人的身体指标测量数据，如手臂或者前臂的空间位置 ( x，y，z 坐标 )。\n- 在人类活动识别数据集中，每一行 ( 实体 ) 都有类标签标记。且共有 5 种标签：Sitting-down，Standing-up，Standing，Walking，Sitting。\n\n## 预处理数据\n\n> 关于 `预处理数据` 的详细解释，可参考另外一篇文章：[Kofe. 如何轻松有效地预处理数据](https://www.kofes.cn/2018/11/the-best-way-to-prepare-a-dataset-easily.html)\n\n- `数据清洗`：缺失值处理、光滑噪声数据、识别和删除离群点。\n\n\t> 关于数据清洗，也推荐阅读具有实操意义的一篇博文：[TowardsDataScience. How to Handle Missing Data](https://towardsdatascience.com/how-to-handle-missing-data-8646b18db0d4)\n\n- `数据集成`：多个数据源的数据合并，存放于同一个数据仓库中。\n\t- `实体识别问题`：来自多个信息源，各数据源中的实体之间如何匹配，这涉及实体识别问题。如不同数据来源于不同数据库中，现实意义上它们是同一实体，但它们属性的元数据表达却不同 ( 如主键 )。\n\t- `冗余和相关分析`：集成多个数据源，数据中可能有多组属性重复存在。而冗余可被相关分析检测到，如分类 ( 标称 ) 属性的卡方检验、数值属性的相关系数、数值属性的方差和协方差。\n\t- `元组重复`：元组级检测重复。\n- `数据归约`：在海量数据上进行复杂的数据分析和挖掘，需要时间很长且不显示。在尽可能保持数据原貌前提下，最大限度精简数据量。策略包括：\n\t- `维归约`：也称为特征归约，减少所考虑的属性的个数。方法包括：小波变换、主成分分析、属性子集选择等。当然利用冗余和相关分析也是可行的。\n\t- `数量归约`：用替代的、较小的数据表示形式替换原数据 ( 是否可理解为合并多组特征成为新的特征 )。方法包括：参数的方法，回归和对数线性模型；非参数的方法，聚类、降维、直方图、抽样和数据立方体聚集。\n\n\t\t> 在本课堂中则使用了降维方法进行属性数量的归约，其中降维方法有：PCA、t-SNE $^{[4]}$、LargeVis $^{[5, 6]}$ 等。\n\t\t\n- `数据变换`：主要思想是将数据变换或统一成适合数据挖掘的形式。方法可以是数据归一化、数据离散化、概念分层等。\n\t- `特征构造`：由给定的属性构造新的属性并添加至属性集中。\n\t- `聚集分解`：对数据进行 `汇总` 或者 `聚集`。如聚集季度销售数据。与之相对的是 `分解`，如常见的 “日期” 属性，不同的需求，我们要解构的粒度是不同的。如预测当日的气温变化，则我们可把年和月份剔除。\n\t- `归一化`：针对每一个特征 ( 维度 )，去均值和方差归一化。即把属性数据按比例缩放，让所有特征在统一数量级上运作，如此一来数据指标之间就有了可比性。\n\t- `离散化`：数值属性的原始值用区间标签或者概念标签替换，即这些标签可递归地组织成更高层概念，导致数值属性的 `概念分层`。\n\t\t\n\t\t> 例如，我们\t对年龄进行分层：1 to 17 为 Adolescent；18 to 45 为 Adult；46 以上为 Senior。\n\n## 数据可视化\n### 降维方法\n#### 降维目的\n- 通过降维算法来寻找 `数据内部的本质结构特征`，如特征选择或特征提取。\n\t- `特征选择`：假定数据中包含大量冗余或无关变量 ( 或称特征、属性、指标等 )，旨在从原有变量中找出主要变量。其代表方法为 [LASSO](https://zh.wikipedia.org/wiki/Lasso%E7%AE%97%E6%B3%95)。\n\t- `特征提取`：是将高维数据转化为低维数据的过程。在此过程中可能舍弃原有数据、创造新的变量。其代表方法为 [PCA](https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90)。\n- 在原始的高维空间中，包含有冗余信息、噪音信息。通过降维方法，`减少冗余信息` 所造成的误差，以提高模型的精度。\n\n#### 降维本质\n- 机器学习领域中，降维指采用某种映射方法将原高维空间中的数据点映射到低维度的空间中。\n- 降维的本质是学习一个映射函数 $ f : x \\to y$，其中 $x$ 是原始数据点的表达，$y$ 是数据点映射后的低维向量表达 ( 通常 $y$ 的维度小于 $x$ 的维度 )。$f$ 可能是显式的或隐式的、线性的或非线性的映射函数 ( 例如本例提及的 PCA 或者 t-SNE )。\n- 当我们意识到需要降维时，一般是发现了特征间的高度线性相关。若我们发现了线性相关，则适合使用 PCA 处理 $^{[1]}$，而 t-SNE 主打的是非线性降维。\n\n#### 降维算法\n##### PCA\n- `PCA`：主成分分析算法 ( Principal Component Analysis，PCA )，是最常用的 `线性降维方法`。它通过某种线性投影，将高维的数据映射到低维的空间中表示。具体工作原理是，从原始的空间中顺序地找一组相互正交的坐标轴，而且新的坐标轴选择与数据本身是密切相关的。其中，第一个新坐标轴选择是原始数据中方差最大的方向，第二个新坐标轴选取是与第一个坐标轴正交的平面中使得方差最大的方向，若继续添加第三个坐标轴，第三个轴与第一、二个轴正交的平面中方差最大的。依次类推，可以得到 $n$ 个这样的坐标轴。\n\n\t而实际情况，大部分方差都包含在前面 $k$ 个坐标轴中，后面的坐标轴所含的方差几乎为 0。事实上实现对数据特征的降维处理，相当于只保留包含绝大部分方差的维度，而忽略包含方差几乎为 0 的维度。\n\n##### SNE\n- `t-SNE` 可理解为 `SNE` 的特殊形式，我们先了解 SNE 的基本原理，再延伸学习 t-SNE ( 本小节可参考多篇博文比对学习，如参考资料中的 [2] - [3] )。\n\n- SNE 是通过 [仿射变换](https://www.zhihu.com/question/20666664) 将数据点映射到概率分布上，主要包括两个步骤：\n\n\t- SNE 构建一个高维对象之间的概率分布，使得相似的对象有更高的概率被选择，而不相似的对象有较低的概率被选择。\n\n\t- SNE在低维空间里在构建这些点的概率分布，使之与高维度的概率分布之间尽可能相似。\n\n- SNE 的实现原理：\n\t- 原始 SNE 先将 `欧几里得距离` 转换为 `条件概率` 来表达点与点之间的相似度。具体地，给定一个 $N$ 个高维的数据 $x_1, x_2, ..., x_N$，$x_i$ 和 $x_j$ 之间的相似度可表示为 ( $x_i$ 为中心点 )： \n\n\t\t$$\n\t\tp_{j|i} = \\frac{\n\t\t\texp({-||x^{(i)} - x^{(j)}||}^2 / {\n\t\t\t2\\sigma_i^2})\n\t\t}{ \n\t\t\t\\sum_{k \\neq i} exp({-||x^{(i)} - x^{(k)}||}^2 / {\n\t\t\t2\\sigma_i^2})\n\t\t}\n\t\t\\tag{1}\n\t\t$$\n\t\n\t\t这里的有一个参数是 $\\sigma_i$，其表示以 $x_i$ 为中心点的高斯分布的方差。且对于不同的点 $x_i$ 取值不一样 $^{[2]}$ ( 具体参详 SNE 的困惑度 ( Perplexity ) )。再者，由于我们只关心不同点两两之间的相似度，所以设定 $p_{i|i} = 0$。\n\n\t- 在把数据映射到低维空间后，高维数据点之间的相似性也应该在低维空间的数据点上体现出来。这里同样用条件概率的形式描述，对于低维度下的 $y_i$，我们可以指定高斯分布为方差为 $\\frac{1}{\\sqrt2}$。因此它们之间的相似度为:\n\n\t$$\n\tq_{j|i} = \\frac{\n\t\texp( {-||y^{(i)} - y^{(j)}||}^2 )\n\t}{ \n\t\t\\sum_{k \\neq i} exp( {-||y^{(i)} - y^{(k)}||}^2 )\n\t}\n\t\\tag{2}\n\t$$\n\n\t- 同理，设定 $q_{i|i} = 0$。这样一来，若 $y_i$ 和 $y_j$ 真实反映了高维数据点 $x_i$ 和 $x_j$ 之间的关系，那么条件概率 $p_{j|i}$ 与 $q_{j|i}$ 应该完全相等。\n\n\t\t这里我们只考虑 $x_i$ 与 $x_j$ 之间的条件概率，则它们可构成一个条件概率分布函数 $P$。同理，只考虑 $y_i$ 与 $y_j$ 之间的条件概率，在低维空间存在一个条件概率分布 $Q$，且应该与 $P$ 是一致的。\n\t\t\n\t\t如何衡量两个分布之间的相似性？则我们可通过优化两分布的距离，即 `K-L 散度` ( Kullback-Leibler Divergence )。SNE 最终目标就是对所有数据点最小化这个 K-L 散度，具体地，我们可使用 `梯度下降算法` 最小化以下代价函数：\n\t\t\n\t\t$$\n\t\tC = D_{KL}(P || Q) = \\sum_{i} \\sum_{j} p_{j|i} log \\frac{p_{j|i}}{q_{j|i}}\n\t\t\\tag{3}\n\t\t$$\n\t\t\n\t\tSNE 代价函数对 $y_i$ 求梯度后的形式如下：\n\n\t\t$$\n\t\t\\frac{\\delta C}{\\delta y_i} = \n\t\t2 \\sum_j ( p_{j|i} - q_{j|i} + p_{i|j} - q_{i|j} )( y_i - y_j )\n\t\t\\tag{4}\n\t\t$$\n\t\n\t- 似乎到这里问题就解决了，得到代价函数，利用梯度下降算法进行训练了。但事情远没有那么简单，因为 K-L 散度是一个非对称的度量，最小化代价函数的目的是让 $pj|i$ 和 $qj|i$ 的值尽可能的接近，即低维空间中点的相似性应当与高维空间中点的相似性一致。\n\t\t- 但从代价函数的形式就可以看出，考虑到离群点的情况，当 $p_{j|i}$ 较大，$q_{j|i}$ 较小时，即高维空间中两个数据点距离较近，而映射到低维空间后距离较远，那么将得到一个很高的惩罚，这没什么问题；\n\t\t- 而$p_{j|i}$ 较小，$q_{j|i}$ 较大时，即高维空间中两个数据点距离较远，而映射到低维空间距离较近，将得到一个很低的惩罚值。然而这就是问题所在，理应得到一个较高的惩罚才对。换句话说，SNE 的代价函数更关注局部结构，而忽视了全局结构。\n\n##### t-SNE\n\n{% note success %}\n论文中对 t-SNE 原理描述是基于数学形式化的，更多细节或难以理解的，比如距离度量如何转化为概率度量、如何确定 $\\sigma$、如何求梯度下降值等，建议阅读 t-SNE 的代码实现。\n\n推荐 [karpathy.tsnejs](https://github.com/karpathy/tsnejs) 和 [bindog.t-sne.js](https://gist.github.com/bindog/0ac283fc4dbdeb4c954990ea5c3dcd87) (请科学上网)，需要说明的是，bindog 的版本是基于 karpathy 的，具体工作是添加了注释和 [算法流程图](https://upload-images.jianshu.io/upload_images/415974-ab098a421189c1d0.png) $^{[8]}$。\n{% endnote %}\n\n- 在原始 SNE 中，$p_{i|j}$ 与 $p_{j|i}$ 是不相等的，低维空间中 $q_{i|j}$ 与 $q_{j|i}$ 也是不相等的。若我们分别在高维和低维空间构造更加通用的联合概率分布 $P$ 和 $Q$，使得对任意 i, j，均有 $p_{i|j} = p_{j|i}, \\, q_{i|j} = q_{j|i}$。而这种 SNE 称之为对称 SNE ( Symmetric SNE )，因此它们的概率分布可改写为 ( 同理，我们只关注不同点两两之间的相似性，故设定 $p_{i||i} = 0, q_{i||i} = 0$ ):\n\n\t$$\n\tp_{i, j} = \\frac{\n\t\t\texp({-||x^{(i)} - x^{(j)}||}^2 / {\n\t\t\t2\\sigma_i^2})\n\t\t}{ \n\t\t\t\\sum_{k \\neq l} exp({-||x^{(k)} - x^{(l)}||}^2 / {\n\t\t\t2\\sigma_i^2})\n\t\t} \\\\\n\tq_{i, j} = \\frac{\n\t\texp( {-||y^{(i)} - y^{(j)}||}^2 )\n\t}{ \n\t\t\\sum_{k \\neq l} exp( {-||y^{(k)} - y^{(l)}||}^2 )\n\t}\n\t\\tag{5}\n\t$$\n\n- 这样表达方式使得整体简洁了很多。但是会引入异常值的问题。比如，$x_i$ 是异常值，那么 $||x^{(i)} - x^{(j)}||^2$ 会很大，对应的所有的 $j$, $p_{i, j}$ 都会很小，导致低维映射下的 $y_i$ 无论处在什么位置，对代价函数影响很小。\n\n\t为了解决这个问题，我们将联合概率分布改写为：\n\n\t$$\n\tp_{i,j} = \\frac{\n\t\tp_{j|i} + p_{i|j} \n\t}{2N} \\\\\n\t( p_{j|i} = \\frac{p_{i,j}}{p_i}, \\,\n\tp_{i|j} = \\frac{p_{i,j}}{p_j}, \\,\n\tp_i = p_j = \\frac1N )\n\t\\tag{6}\n\t$$\n\t\n- 其中 N 为数据点的总数，这样定义即满足了对称性，又保证了 $x_i$ 的惩罚值不会过小。此时可以利用 KL 距离写出如下代价函数：\n\t\n\t$$\n\tC = D_{KL}(P || Q) = \\sum_{i} \\sum_{j} p_{i, j} log \\frac{p_{i, j}}{q_{i, j}}\n\t\\tag{7}\n\t$$\n\t\n- 对称 SNE 的最大优点，即梯度计算变得简单了：\n\n\t$$\n\t\\frac{\\delta C}{\\delta y_i} = \n\t4 \\sum_j ( p_{i, j} - q_{i, j})( y_i - y_j )\n\t\\tag{8}\n\t$$\n\t\n\t但是Maaten 还指出 $^{[4]}$，对称 SNE 的效果只是略微优于原始 SNE 的效果，依然没有从根本上解决问题。我们还需要解决 `拥挤问题`。\n\t\n- `拥挤问题`：就是说各个簇聚集在一起，无法区分。这是由于高维空间距离分布和低维空间距离分布的差异造成的。比如，有一高维度数据在降维到 10 维下可以有很好的表达，但是降维到两维后无法得到 \"可信\" 映射。\n\n\t进一步说明，假设一个以数据点 $x_i$ 为中心，半径为 $r$ 的 $m$ 维球 ( 三维空间就是球 )，其体积是按 $r^m$ 增长的，假设数据点是在 m 维球中均匀分布的，我们来看看其他数据点与 $x_i$ 的距离随维度增大而产生的变化。具体，我们可参考代码 $^{[3]}$：\n\t\n\t```python\n\timport numpy as np\n\tfrom numpy.linalg import norm\n\timport matplotlib.pyplot as plt\n\n\tnpoints = 1000\t# 抽取 1000 个 m 维球内均匀分布的点\n\tplt.figure( figsize=(20, 4) )\n\tfor i, m in enumerate((2, 3, 5, 8)):\n\t    # 这里模拟 m 维球中的均匀分布用到了拒绝采样\n\t    # 即先生成 m 维立方中的均匀分布，再剔除 m 维球外部的点\n\t    accepts = []\n\t    while len(accepts) < 1000:\n\t        points = np.random.rand(500, m)\n\t        accepts.extend(\n\t            [d for d in norm(points, axis=1) if d <= 1.0]\n\t        ) # 拒绝采样\n\t    accepts = accepts[:npoints]\n\t    ax = plt.subplot(1, 4, i+1)\n\t    ax.set_xlabel('distance') # x 轴表示点到圆心的距离\n\t    if i == 0:\n\t        ax.set_ylabel('count') # y 轴表示点的数量\n\t    ax.hist(accepts, bins=np.linspace(0., 1., 50), color='green')\n\t    ax.set_title('m={0}'.format(str(m)), loc='left')\n\tplt.show()\n\t```\n\n- 运行结果如图 2-1 所示。据图示反映，随着维度的增大，大部分数据点都聚集在 m 维球的表面附近，与点 $x_i$ 的距离分布极不均衡。若直接将这种距离关系保留到低维，肯定会出现拥挤问题。如何解决呢？这个时候就需要请出 $\\tau$ 分布了。\n\t\n\t![图2-1半径为 r 的 m 维球上的数据分布](/images/illustration/Project/2018/11/The-Best-Way-to-Visualize-a-Dataset-Easily_2-1.jpg)\n\t<center>图 2-1 半径为 r 的 m 维球上的数据分布</center>\n\n- 减轻 `拥挤问题` 的方法：在高维空间下我们使用 `高斯分布` 将距离转换为概率分布；在低维空间下，我们使用更加 `偏重长尾分布` 的方式来将距离转换为概率分布，使得高维度下中低等的距离在映射后能够有一个较大的距离。使用了自由度为 1 的 $\\tau$ 分布之后的 $q$ 变化，如下:\n\n\t$$\n\tq_{i,j} = \\frac{\n\t\t(1 + ||y^{(i)} - y^{(j)}||^2)^{-1}\n\t}{ \n\t\t\\sum_{k \\neq l} (1 + ||y^{(k)} - y^{(l)}||^2)^{-1}\n\t}\n\t\\tag{9}\n\t$$\n\t\n\t依然用 K-L 距离衡量两个分布之间的相似性，此时梯度变为：\n\t\n\t$$\n\t\\frac{\\delta C}{\\delta y_i} = \n\t4 \\sum_j ( p_{i, j} - q_{i, j})( y_i - y_j )(1 + ||y^{(i)} - y^{(j)}||^2)^{-1}\n\t\\tag{10}\n\t$$\n\t\n- `总结`：综上所述，从不对称的 SNE 算法到 t-SNE 算法，所做的改进工作：\n\t- 把 SNE 变为对称 SNE；\n\t- 在低维空间中采用了 $\\tau$ 分布代替原来的高斯分布，高维空间不变。\n\t- 具体算法步骤可参考了文章 [7] 的 [t-SNE](https://zhuanlan.zhihu.com/p/33722444) 图文解释，如图 2-2 所示。\n\n\t![图2-2t-SNE的算法步骤](/images/illustration/Project/2018/11/The-Best-Way-to-Visualize-a-Dataset-Easily_2-2.jpg)\n\t<center>图 2-2 t-SNE 的算法步骤</center>\n\t\n### 数据展示\n\t\n## 参考资料\n- [1] [微调. t-SNE 数据可视化算法的作用是为了降维还是认识数据. zhihu.com](https://www.zhihu.com/question/52022955/answer/387753267)\n- [2] [Chrispher. t-SNE 完整笔记 [OL]. datakit.cn. 2017](http://www.datakit.cn/blog/2017/02/05/t_sne_full.html#12-sne原理推导)\n- [3] [Bindog. 从 SNE 到 t-SNE 再到 LargeVis. bindog.github.io. 2016](http://bindog.github.io/blog/2016/06/04/from-sne-to-tsne-to-largevis/)\n- [4] Maaten L, Hinton G. Visualizing data using t-SNE [J]. Journal of machine learning r/esearch, 2008, 9(Nov): 2579-2605.\n- [5] Tang J, Liu J, Zhang M, et al. Visualizing large-scale and high-dimensional data[C]. International World Wide Web Conferences Steering Committee, 2016: 287-297.\n- [6] Tang J, Qu M, Wang M, et al. Line: Large-scale information network embedding[C]. International World Wide Web Conferences Steering Committee, 2015: 1067-1077.\n- [7] [徐小贱民. 降维技术解析：PCA, t-SNE and Auto Encoders. zhihu.com](https://zhuanlan.zhihu.com/p/33722444)\n- [8] [Bindog. t-SNE使用过程中的一些坑. jianshu.com. 2018](https://www.jianshu.com/p/631d6529e0df)","tags":["t-SNE"],"categories":["Project"]},{"title":"讲座 | 如何轻松有效地预处理数据","url":"%2F2018%2F11%2Fthe-best-way-to-prepare-a-dataset-easily.html","content":"\n{% note default %}  \n作者：Siraj Raval  \n课堂：The Best Way to Prepare a Dataset Easily | [Bilibili](https://www.bilibili.com/video/av35419601) | [Youtube](https://www.youtube.com/watch?v=0xVqLJe9_CY)  \n源码：llSourcell.Prepare dataset challenge | [Github](https://github.com/llSourcell/prepare_dataset_challenge)  \n{% endnote %}\n\n本课堂的核心是讲述数据分析前夕的数据预处理过程，包括准备数据阶段和处理数据阶段。再具体以实例：通过大脑扫描公共数据集来建模、分析，预测某人是否在冥想。\n\n<!-- More -->\n\n## 更新进度\n- 2018.11.20：重新整理「数据预处理」章节，细化了预处理的细节，且重新整理了预处理的结构；\n\n## 准备数据\n- `准备数据阶段`：决定使用何种数据，这跟你试图解决的问题相关。\n- `关于数据来源`：能使用公共数据集解决的问题，尽量使用公共数据集。若公共数据集无法满足你的需求，引用毛主席的老话：没有条件便自己创造条件。即我们通过网络爬虫形式，把原始网页中的数据扒取下来，自己来 \"创造\" 数据集。\n\t- `公共数据集`：[Google 高级搜索](https://www.google.com/advanced_search?hl=zh-CN&fg=1)、[Kaggle](https://www.kaggle.com/)。\n\t- `网络爬虫`：网站提供 API 接口、Python 扒取网页数据。\n\n### 公共数据集\n#### 谷歌高级搜索\n- `官方网址`：[Google 高级搜索](https://www.google.com/advanced_search?hl=zh-CN&fg=1)\n- `使用方式`：顾名思义，即通过高级搜索的限制条件去获得更精确的搜索结果。具体地，我们侧重关注以下检索项，可获得意想不到的效果。\n\t- `关键字部分`：填写问题相关的关键词；\n\t- `网站或域名`：填写 `.edu`、`.gov`、`.org` 等，即为确保数据的权威可靠性，尽可能从教育、政府、组织机构中获取公共数据集；\n\t- `文件类型`：可指定为 csv ( 逗号分隔值 )、xls ( Microsoft Excel ) 等文件类型，Python 对 csv、xls 提供了较好的库支持，为了更便捷进行数据处理，则优先选择此类格式的文件。\n\n#### Kaggle\n- `官方网址`：[Kaggle](https://www.kaggle.com/)\n- `推荐理由`：Kaggle 由 Anthony Goldbloom 创立，主要为开发商和数据科学家提供举办机器学习竞赛、托管数据库、编写和分享代码的平台 ( [与谷歌达成合作关系](http://blog.kaggle.com/2017/03/08/kaggle-joins-google-cloud/) )。由此可见：\n\t- Kaggle 的每个竞赛都是独立的，无需设置项目范围然后收集数据，这让你有时间专注其它技能。\n\t- Kaggle 的每个数据集都有要解决的现实问题，要面向参与竞赛的人群，让参赛者更容易掌握业务知识和数据集的结构特征，因此数据集的描述是不可缺少的。\n\n\t\t> 不妨体验下 Kaggle 社区提供的入门案例 `泰坦尼克：灾难中的机器学习`，其相关的数据集描述：[Titanic: Machine Learning from Disaster](https://www.kaggle.com/c/titanic/data)\n\n- `入门指南`：参考文章 [机器之心. Kaggle 如何入门. zhihu.com](https://www.zhihu.com/question/23987009) 整理而得。\n\n\t- `选择一种编程语言`：你是一个毫无经验的新手，推荐 `Python`，因这是一种通用编程语言，你可以在整个流程中都使用它。\n\n\t- `学习探索数据的基础`：加载、浏览和绘制你的数据（`即探索性分析`）的能力，因为它可以为你将在模型训练过程中做的各种决策提供信息。  \n\n\t\t若你选择了 Python 路线，推荐使用专门为这个目的设计的 `Seaborn` 库。其中有高层面的绘图函数，可以绘制许多最常见和有用的图表。可参考资料：\n\n\t\t- [Seaborn 官网](https://seaborn.pydata.org/)\n\n\t\t- [Seaborn 教程. EliteDataScience.com](https://elitedatascience.com/python-seaborn-tutorial)\n\n\t\t- [机器之心. 数据科学相关的 Python 库介绍](https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650726730&idx=2&sn=89d176a782875afaafc69dd40cbee006&chksm=871b2534b06cac22a9235168a8d8867b97f795d2fba4435a2c7ec18b1039703903e4a79560bd&scene=21#wechat_redirect)\n\n\t- `训练你的第一个机器学习模型`：将数据集分成独立的训练集和测试集，交叉验证避免过拟合以及使用合适的表现评价指标。对于 Python，最好的通用机器学习库是 Scikit-Learn。可参考资料：\n\n\t\t- [Scikit-Learn 官网](https://link.zhihu.com/?target=http%3A//scikit-learn.org/stable/) | [Scikit-Learn 官方文档中文版](http://sklearn.apachecn.org)\n\n\t\t- [Scikit-Learn 教程. EliteDataScience.com](https://elitedatascience.com/python-machine-learning-tutorial-scikit-learn)\n\n\t\t- [机器之心. 从零开始掌握 Python 机器学习](https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650724242&idx=1&sn=703d242700e29813d6c482daf6b211c5&chksm=871b13ecb06c9afa28f8aad729496620078985e4eae8a1296fc407dbd70c1d70fabb3b2817fa&scene=21#wechat_redirect)\n\n\t\t- [Ben Hamner (Kaggle CTO). 机器学习的八个步骤](https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650725654&idx=4&sn=505ababb07a6bee5d42a6254a7493a7e&chksm=871b1968b06c907e9f84888ecb2ced8d3f52f0129720872e97f923b94deb34383eacefb4a5cf&scene=21#wechat_redirect)\n\n\t- `解决入门级竞赛`：[Getting Started](https://www.kaggle.com/competitions?sortBy=grouped&group=general&page=1&pageSize=20&category=gettingStarted) 竞赛非常适合初学者，因为它们给你提供了低风险的学习环境，并且还有很多社区创造的教程。\n\n\t\t> Kaggle 的竞赛分成四个类别：  \n\t\t> `Featured`：通常是由公司、组织甚至政府赞助的，奖金池最大。     \n\t\t> `Research`：研究方向的竞赛，只有很少或没有奖金。它们也有非传统的提交流程。  \n\t\t> `Recruitment`：这些是由想要招聘数据科学家的公司赞助的。目前仍然相对少见。  \n\t\t> `Getting Started`：这些竞赛的结构和 Featured 竞赛类似，但没有奖金。它们有更简单的数据集、大量教程和滚动的提交窗口让你可以随时输入。\n\n### 网络爬虫\n#### 网站 API\n- 当公共数据集无法满足我们的需求时，则需要自定义采集数据。而采集数据则通过网络爬虫实现。值得注意的是，并不是所有的网页，都需要我们花费大功夫去扒取获得，而是它们本身就提供了调用数据的 API。\n- 当然，也有 Github 大神搜集并整理了较实用的 API：[TonnyL. Awesome APIs](https://github.com/TonnyL/Awesome_APIs/blob/master/README-zh.md)\n\n#### 网页爬虫\n- [Beautiful Soup](https://www.crummy.com/software/BeautifulSoup/)：Beautiful Soup 是一个可以从 HTML 或 XML 文件中提取数据的 `Python` 库。\n- [Web Magic](http://webmagic.io/)：Web Magic 是一个简单灵活的 `Java` 爬虫框架。基于 WebMagic，你可以快速开发出一个高效、易维护的爬虫。\n\n## 处理数据\n- 为什么要对数据预处理：确保数据质量，以保证预测的结果更精确。而数据质量涉及许多因素，例如准确性、完整性、一致性、可信性和可解释性，针对不同的特性，都有对应的 `处理策略`。\n\n\t> 注意，数据预处理的主要任务之间存在许多重叠工作，若前面章节有阐述的，后面涉及的则略过。\n\n- 数据预处理的主要任务：\n\t- `数据清洗`：缺失值处理、光滑噪声数据、识别和删除离群点。\n\n\t\t> 关于数据清洗，也推荐阅读具有实操意义的一篇博文：[TowardsDataScience. How to Handle Missing Data](https://towardsdatascience.com/how-to-handle-missing-data-8646b18db0d4)\n\t\n\t- `数据集成`：多个数据源的数据合并，存放于同一个数据仓库中。\n\t\t- `实体识别问题`：来自多个信息源，各数据源中的实体之间如何匹配，这涉及实体识别问题。如不同数据来源于不同数据库中，现实意义上它们是同一实体，但它们属性的元数据表达却不同 ( 如主键 )。\n\t\t- `冗余和相关分析`：集成多个数据源，数据中可能有多组属性重复存在。而冗余可被相关分析检测到，如针对分类 ( 标称 ) 属性的卡方检验、数值属性的相关系数、数值属性的方差和协方差。\n\t\t- `元组重复`：元组级检测重复。\n\t- `数据归约`：在尽可能保持数据原貌前提下，最大限度精简数据量。策略包括：\n\t\t- `维归约`：也称为特征归约，减少所考虑的属性的个数。方法包括：小波变换、主成分分析、属性子集选择等。当然利用冗余和相关分析也是可行的。\n\t\t- `数量归约`：用替代的、较小的数据表示形式替换原数据。方法包括：回归和对数-线性模型、聚类、降维等。\n\t- `数据变换`：主要思想是将数据变换或统一成适合数据挖掘的形式。方法可以是数据归一化、数据离散化、概念分层等。\n\t\t- `特征构造`：由给定的属性构造新的属性并添加至属性集中。\n\t\t- `聚集分解`：对数据进行 `汇总` 或者 `聚集`。如聚集日销售数据。与之相对的是 `分解`，如常见的 “日期” 属性，不同的需求，我们要解构的粒度是不同的。如预测当日的气温变化，则我们可把年和月份剔除。\n\t\t- `归一化`：针对每一个特征 ( 维度 )，去均值和方差归一化。即把属性数据按比例缩放，让所有特征在统一数量级上运作，如此一来数据指标之间就有了可比性。\n\t\t- `离散化`：把属性值的原始值用区间标签或者概念标签替换，即这些标签可递归地组织成更高层概念，导致数值属性的 `概念分层`。\n\t\t\n\t\t\t> 例如，我们\t对年龄进行分层：1 to 17 为 Adolescent；18 to 45 为 Adult；46 以上为 Senior。\n\t\n### 数据清洗\n- `缺失值处理`：某些实例数据中属性值为空，我们通过遍历数据集将其剔除。若数据集中存在大量实例含有缺失值的情况，则我们采用 `填补缺失值` 的方法。值得注意的是，根据不同情况，填补缺失值有多种方式：\n\t- 人工填写缺失值。\n\t- 使用全局常量填充缺失值：`N/A` 或者 $\\infty $。\n\t- 使用属性的中心度量：若是对称的数据分布，则使用均值；若是倾斜的数据分布，则使用中位数。\n\t- 使用最可能的值填充缺失值：回归、贝叶斯形式化的推理工具或决策树。\n\n\t\t> 某些情况下，缺失值并不意味数据有错误。例如在申请信用卡时，要求填写申请人的驾驶执照号，没有的人可填写 \"无\" 或者不填。\n\t\n- `光滑噪声`：噪声指数据中存在着错误或异常 ( 偏离期望值 ) 的数据，这些数据对数据的分析造成了干扰。我们可通过 `分箱`、`回归`、`离群点分析` 等噪声光滑技术来消除噪声。\n\t- `分箱`：考察数据的近邻 ( 周围的值 ) 来光滑有序数据值。\n\t- `回归`：用一个函数拟合数据来光滑数据。\n\t- `离群点分析`：五数概括 ( 中位数、四分位数、最大最小观测值 )、箱线图与离群点；或通过聚类来检测离群点。\n\n### 数据集成\n- `实体识别问题`：\n\t- 问题描述：来自多个信息源，各数据源中的实体之间如何匹配，这涉及实体识别问题。如不同数据来源于不同数据库中，现实意义上它们是同一实体，但它们属性的元数据表达却不同 ( 如主键 )。\n\t- 解决方法：每个属性的元数据包含名字、含义、数据类型和属性的允许值范围，以及处理空值的空值规则。这样的元数据可帮助我们避免模式集成的错误。\n- `冗余和相关分析`：这里讨论的冗余是对应于数据的属性 ( 特征 ) 层面讨论的。\n\t- 分类 ( 标称 ) 属性的 `卡方检验` ( $\\chi^2$ )，发现属性 A、B 之间的相关联系。\n\t- 数值数据的 `相关系数`：计算属性 A、B 之间的相关系数 ( 又称 Pearson 积矩系数 )，估计这两个属性的相关度。\n\t- 数值数据的 `协方差`：协方差和方差是两个类似的度量 ( 方差可理解为协方差的特殊形式 )，其作用是评述两个属性如何一起变化。\n\n### 数据归约\n- `维归约`：也称为特征归约，减少所考虑的属性的个数。\n\t- 通俗理解：即从原有的特征中删除不重要或不相关的特征。比如，某些实例数据中属性值与所研究的问题无关，我们可以选择性地剔除。\n\n\t\t> 本课堂实例中，是预测志愿者是否在冥想。而相关数据集呈现三种特征：精神专注度、冷静度以及志愿者的年龄。而志愿者是否发生冥想活动，很明显与性别无关，则可选择性地剔除该属性。\n\n\t- 方法包括：小波变换、主成分分析、属性子集选择等。当然利用冗余和相关分析也是可行的。\n\n- `数量规约`：用替代的、较小的数据表示形式替换原数据。\n\t- 通俗理解：即通过对特征进行重组来减少特征的个数。比如，某些实例数据中属性 ( 维度 ) 太多，我们人类大脑是难以理解它的，则我们可通过降维方法以及可视化工具，以二维或者三维的的形式复现数据 ( 的特征 )。\n\t- 方法包括：参数的方法，回归和对数线性模型；非参数的方法，聚类、降维、直方图、抽样和数据立方体聚集。\n\n### 数据变换\n- `归一化`：针对每一个特征 ( 维度 )，去均值和方差归一化。即把属性数据按比例缩放，让所有特征在统一数量级上运作，如此一来数据指标之间就有了可比性。\n- `离散化`：把值用区间标签或者概念标签替换，即这些标签可递归地组织成更高层概念，导致数值属性的 `概念分层`。\n\t- `数值属性`：在实际操作中，即把连续型特征的值离散化，使之成为少量的区间，每个区间映射到一个离散符号。这种技术的好处在于简化了数据描述，并易于理解数据和最终的挖掘结果。\n\t- `标称 (分类) 属性`：标称属性具有有穷多个不同值，且值之间无序。例如地位位置、年龄层次等。对于标称属性，我们需要人工定义概念分层。\n- `向量化`：当我们已基本完成数据处理阶段的工作，得到可供使用的数据集。那么紧接着的步骤，即把实例数据转换成 `特征向量` ( 向量是特征的数值表示形式 )，所有实例的特征向量组成 `特征矩阵`。然后，在 `Python` 中通过 `Numpy` 和 `Pandas` 包装，即实际上让 `narray` 数组成为特征矩阵的存储和运算的媒介。\n\n\t当完成以上流程后，数据预处理阶段即可告一段落，紧接着便可开始开始训练模型了。\n\n\t> 由于篇幅的缘故，数据预处理的讨论暂到此为止。当然，数据预处理的内容不仅如此，更详细的理论细节可参详 Jiewei Han 的《数据挖掘：概念与技术》$^{[1]}$。 而数据预处理在 Python 中如何实现，则参考 Keras 之父弗朗索瓦·肖莱的 《Python深度学习》$^{[2]}$。\n\n## 参考资料\n- [1] [Jiewei Han, Micheline Kamber and Jian Pei. 数据挖掘 (第三版) [M]. 机械工业出版社, 2018, 56-79.](https://book.douban.com/subject/2038599/)\n- [2] [弗朗索瓦·肖莱，张亮 (译). Python 深度学习 [M]. 人民邮电出版社, 2018, 80-82.](https://book.douban.com/subject/30293801/)","tags":["数据预处理"],"categories":["Project"]},{"title":"极客 | 多套软件解决方案助你提高生产力","url":"%2F2018%2F11%2Fsoftware-solution.html","content":"\n在输出本博文之初，意图是很纯粹的，即把平日里体验佳、少折腾、踩过坑的种种软件整理成册，以便于日后装机或朋友间安利、分享。\n\n再者，在平日的工作、娱乐环境中，单一的软件远远不够满足我们的需求。软件虽然一定程度上解放了我们的生产力，而随着个人的需求日益增长、消费水平升级，享受的服务逐渐被分散细化，我们的工作效率提升了，但人与软件更密切的交互让我们紧密地捆绑在一起，似乎我们并没有被真正意义地 \"解放\" 出来？其次，每款软件终究是一个体，一些连贯性的交互需求，它们是很难或无法独自完成的，故我们需要更高阶的完整软件解决方案。例如，智能路由系统 ( 网络中心 + 控制中心 )、个人博客 ( 笔记 + 储存 + 分享 )、个人私有云 ( 储存 + 远程 + 共享 )、智能家居控制中心 ( 跨平台 + 控制中心 )、家庭影院中心等。即我们通过专职的服务器，运作相应的操作系统和应用程序，以提供完整的软件解决方案。\n\n最后，谈起专职的服务器便是组装一台 `家用服务器`。在服务器中，我们可通过 `虚拟机` 实现私有云、智能路由系统、Web 服务器、代码托管服务器等，把以上系统方案整合到 N in 1 的服务器中，既充分重利用了硬件资源，同时也节约了房间的物理空间。\t\n<!-- More -->\n\t\n## 更新进度\n- 2018.10.22：完成初稿；\n- 2018.10.25：完成系统解决方案的「 个人博客解决方案 」章节内容；\n- 2018.11.02：更新「 常备软件清单 」章节内容；\n- 2018.11.03：更新「浏览器插件」章节内容；\n- 2018.11.05：完成系统解决方案的「代码托管方案：Svn」章节内容；\n- 2019.01.28：新增「信仰装机 」章节内容；\n- 2019.02.20：更新「信仰装机 」章节内容；\n\t\n## 办公利器：常备软件清单\n### 开篇引言\n- `选应用的意图`：常备软件清单，覆盖了办公、开发、设计、写作、影音、系统等几大类别的应用，且选应用的意图都是很明确的，即办公类应用，应尽可能地提升效率以提高生产力；娱乐类应用，应更便捷地交互体验以提升幸福感；系统类应用，应融洽地接入系统以焕发 Mac 本该拥有的强大本质。\n- `选应用的方法`：再者，为什么推荐这些应用，主要考虑因素是：\n\t- 方案一：一方面是针对平台优化的独占平台应用，另一方面则是个人的主战装备是 Macbook Pro，故推荐应用以 `MacOS` 先入为主，再考虑其他方案；\n\t- 方案二：则是 `全平台通用` 的方案。\n\t- 方案三：总有功能性应用是独占平台的，遇到此情况则提供 `退阶方案`，即寻找同类功能的优秀应用作为替代方案。\n- `选应用的准则`：其次，我们秉承 `免费开源` 的理念来寻找高质量应用，但并不会一味追求免费而错过或放弃收费的应用。由于方案初制定，后期会不断补充内容，造成不便请谅解。\n\n### 影音媒体\n#### IINA\n- 应用类型：📺 | 媒体播放器\n- 是否收费：🆓 | 开源免费\n- 支持平台：`MacOS`\n- 官方地址：[IINA 中文](https://lhc70000.github.io/iina/zh-cn/) | [IINA 英文](https://lhc70000.github.io/iina/) | [Github 开源](https://github.com/lhc70000/iina)\n- 推荐理由：\n\t- 开源且完全免费  ( GPLv3 )；\n\t- 在线字幕搜索和智能本地字幕匹配；\n\t- 满足你关于视频、音频、字幕等相关的基本功能；\n\t- 基于 MPV ( 神级开源解码工具 ) 的媒体播放器，支持几乎所有常用媒体播放，且稳定解码并输出高质量的影像。\n\n#### MPV\n- 应用类型：📺 | 媒体播放器\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS` | `Windows` | `Linux` | `Android`\n- 官方地址：[MPV 介绍](https://mpv.io/) | [MPV 下载](https://mpv.io/installation/) | [MPV 手册](https://mpv.io/manual/master/) | [Github 开源](https://github.com/mpv-player/mpv)\n- 推荐理由：\n\t- 开源且完全免费 ( GPLv2 或更高版本 )；\n\t- IINA 的退阶产品，MPV 的特性与前者相仿，但支持多平台使用。\n\n#### MusicLake\n- 应用类型：🎵 | 音乐播放器\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS` | `Windows` | `Linux` | `Android`\n- 官方地址：[Github 开源/介绍](https://github.com/sunzongzheng/music) | [MusicLake 下载](https://github.com/sunzongzheng/music/releases)\n- 推荐理由：\n\t- 开源免费 ( 目前免费 )；\n\t- 跨平台音乐播放器，可搜网易云、QQ 音乐、虾米音乐，且支持一键导入音乐平台歌单；\n\t- 支持云歌单同步，但需要在应用内登录；\n\t- 支持第三方授权登录 ( [OAuth](https://baike.baidu.com/item/oAuth/7153134?fr=aladdin) )，免去繁琐注册、账号隐私泄漏等问题，目前支持微博、微信、QQ、Twiter、Google 授权登录。\n\n### 媒体编辑\n#### Permute\n- 应用类型：📽 | 格式转换\n- 是否付费：💵 | 付费应用\n- 支持平台：`MacOS`\n- 官方地址：[Permute 官方](https://software.charliemonroe.net/permute.php)\n- 推荐理由：\n\t- 主要与 [Downie](#Downie) 配合使用，用于网络流媒体的分段视频拼接、格式转换；\n\t- 作为媒体编辑应用，足够应付基本的视频、音频、图片格式转换；\n\t- 拖拽方式操作即可实现视频拼接、音轨视频一键合成。\n\n#### FFmpeg\n- 应用类型：📽 | 格式转换\n- 是否付费：🆓 | 免费开源\n- 支持平台：`MacOS` | `Windows` | `Linux`\n- 官方地址：[FFmpeg 官方](http://www.ffmpeg.org/) | [FFmpeg 下载](http://www.ffmpeg.org/download.html) | [FFmpeg 文档](http://www.ffmpeg.org/documentation.html)\n- 推荐理由：\n\t- 开源且完全免费  ( GPLv2 或更高版本、LGPLv2.1 或更高版本 )；\n\t- Permute 的退阶产品，而退阶并不是它功能比前者弱，而是它作为 `音视频的完整解决方案`，入门成本较高；\n\t- 跨平台剪辑、转码、合成音频和视频；\n\n#### ArcTime\n- 应用类型：🎞 | 媒体编辑\n- 是否付费：💵 | 增值服务内购\n- 支持平台：`MacOS` | `Windows` | `Linux`\n- 官方地址：[ArcTime 官方](http://www.arctime.cn/zh/index.html) | [ArcTime 下载](http://www.arctime.cn/zh/download.html)\n- 推荐理由：\n\t- 跨平台的字幕制作软件；\n\t- 语音识别文字，机器翻译 ( 点击了解 [增值服务](http://arctime.cn/zh/service.html) )；\n\t- 导出多种字幕格式，且支持导出面向非编软件的软字幕；\n\t- 无缝支持所有主流非编软件的工程文件互导入、导出。\n\n### 高效办公\n#### MacDown\n- 应用类型：📝 | 文档编辑\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS`\n- 官方地址： [MacDown 官方](http://macdown.uranusjr.com/blog/macdown-help/) | [Github 开源](https://github.com/MacDownApp/macdown)\n- 推荐理由：\n\t- 开源且完全免费；\n\t- 稳定且渲染速度快；\n\t- 纯粹的 Markdown 文本编辑器，支持本地化管理 `MD` 文档 ( 即功能类似 Windows 的 TXT 文本编辑器 )。\n\n#### MWeb\n- 应用类型：📝 | 文档编辑\n- 是否付费：💵 | 付费应用\n- 支持平台：`MacOS` | `iOS`\n- 官方地址：[MWeb 官方](https://zh.mweb.im/) | [少数派评测](https://sspai.com/post/33855)\n- 推荐理由：\n\t- 苹果全家桶可支持多终端云同步、云办公；\n\t- 支持丰富的 `Github Flavored Markdown (GFM)` 语法，另外还支持表格、TOC、LaTeX、代码块、任务列表、脚注等；\n\t- 内建文档分类、文档贴标签功能，即支持快速检索文章内容，也支持一体化的文档管理；\n\t- 丰富的 Markdown 导出配置，具体支持有：`jpg`、`html`、`epub`、`pdf`、`rtf`、`docx`；\n\t- 支持一键发布功能，直接发布至 `Wordpress`、`印象笔记`、`Blogger` 等。\n\n#### Yu Writer\n- 应用类型：📝 | 文档编辑\n- 是否付费：🆓 | 免费应用\n- 支持平台：`MacOS` | `Windows` | `Linux` ( Coming soon )\n- 官方地址：[Yu Writer 官网](https://ivarptr.github.io/yu-writer.site/)\n- 推荐理由：\n\t- 开源免费 ( 可付费升级至 Pro 版本 )；\n\t- MWeb 的退阶产品，功能几乎与 MWeb 一样，特色是多平台支持。\n\n### 设计工具\n#### Adobe Series\n- 应用类型：📐 | 设计套件\n- 是否付费：💵 | 付费应用\n- 支持平台：`MacOS` | `Windows`\n- 推荐理由：Adobe 全家桶，设计师必备套件。\n\n### 开发工具\n#### Parallels Desktop\n- 应用类型：🖥 | 虚拟机软件\n- 是否付费：💵 | 付费应用\n- 支持平台：`MacOS`\n- 官方地址：[PD 官网](https://www.parallels.com/cn/)\n- 推荐理由：Mac 上性能首屈一指的虚拟机工具。\n\n\t> 在自己的机器上，分别用 VMware 和 PD 测试运行 Windows 10，日常使用强度 ( 编码、浏览网页、看视频等 )。相比于 VMware，PD 运行流畅且发热程度更低。当然，一两台机器的测试结果并不具有参考性，故 PD 在 MacOS 上的优势可自行体验后再决定购入使用 ( 都有试用版本体验 )。\n\n#### VMware\n- 应用类型：🖥 | 虚拟机软件\n- 是否付费：💵 | 付费应用\n- 支持平台：\n\t- `MacOS`：支持产品 VMware  Fusion\n\t- `Window、Linux`：支持产品 Workstation Pro\n\t- `Window、Linux`：支持产品 Workstation Player\n- 官方地址：[VMware Fusion](https://www.vmware.com/cn/products/fusion.html) | [Workstation Pro](https://www.vmware.com/cn/products/workstation-pro.html) | [Workstation Player](https://www.vmware.com/cn/products/workstation-player.html)\n- 推荐理由： 跨平台虚拟化软件，即它可安装在 Windows、Linux、MacOS 的操作系统上使用。\n\n#### VirtualBox\n- 应用类型：🖥 | 虚拟机软件\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS` | `Windows` | `Linux`\n- 官方地址：[VirtualBox 官网](https://www.virtualbox.org/) | [VirtualBox 下载](https://www.virtualbox.org/wiki/Downloads) | [用户手册](https://www.virtualbox.org/wiki/End-user_documentation) | [开源手册](https://www.virtualbox.org/wiki/Technical_documentation)\n- 推荐理由：\n\t- 开源且完全免费；\n\t- 跨平台虚拟化软件，即它可安装在 Windows、Linux、MacOS 的操作系统上使用；\n\t- 可虚拟的操作系统包括 Windows、Mac OS X、Linux、OpenBSD、Solaris、IBM OS2、Android 等。\n\n#### DBeaver\n- 应用类型：🗄 | 数据库管理\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS` | `Windows` | `Linux`\n- 官方地址：[DBeaver 官网](https://dbeaver.io/) | [DBeaver 下载](https://dbeaver.io/download/) | [Github 开源](https://github.com/dbeaver/dbeaver/)\n- 推荐理由：\n\t- 开源且完全免费 ( 可付费升级 [企业版](https://dbeaver.com/) )；\n\t- `通用数据库管理工具` 和 `SQL 客户端`，支持 MySQL, PostgreSQL, Oracle, DB2, MSSQL, Sybase, Mimer, HSQLDB, Derby 及兼容 JDBC 的数据库。\n\t- 它可以处理任何的 `外部数据源` ( 数据源包含数据库服务器的名称和位置、数据库驱动程序以及在登录数据库时所需的信息 )。\n\n#### Sequel Pro\n- 应用类型：🗄 | 数据库管理\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS`\n- 官方地址：[Sequel Pro 官网](http://www.sequelpro.com/) | [Github 开源](https://github.com/sequelpro/sequelpro)\n- 推荐理由：\n\t- 开源且完全免费；\n\t- MacOS 平台独占应用，专门管理 `MySQL` 和 `MariaDB` 数据库的工具，操作界面非常友好，若仅是处理 MySQL 数据库，Sequel Pro 是你开发的最佳伴侣。\n\n#### FileZilla\n- 应用类型：📤 | 文件传输\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS` | `Windows` | `Linux`\n- 官网网址：[FileZilla 官方](https://filezilla-project.org/) | [FileZilla 客户端](https://filezilla-project.org/download.php?type=client) | [FileZilla 服务端](https://filezilla-project.org/download.php?type=server) | [源代码](https://filezilla-project.org/sourcecode.php)\n- 推荐理由：\n\t- 开源且完全免费 ( 可付费升级 [企业版](https://filezillapro.com/) )；\n\t- 跨平台的 `FTP` 解决方案，支持 FTP、FTPS、SFTP 等文件传输协议；\n\n#### CornerStone\n- 应用类型：⌨️ | 代码管理\n- 是否付费：💵 | 付费应用\n- 支持平台：`MacOS`\n- 官方地址：[CornerStone 官网](https://cornerstone.assembla.com/)\n- 推荐理由：面向 Svn ( 开放源代码的版本控制系统 )，即 CornerStone 是一款拥有界面交互的 Svn 客户端。\n\n#### TortoiseSVN\n- 应用类型：⌨️ | 代码管理\n- 是否付费：🆓 | 开源免费\n- 支持平台：`Windows`\n- 官方地址：[TortoiseSVN 官网](https://tortoisesvn.net/) | [TortoiseSVN  下载](https://tortoisesvn.net/downloads.html)\n- 推荐理由：面向 Svn ( 开放源代码的版本控制系统 )，即 TortoiseSVN 是一款拥有界面交互的 Svn 客户端。\n\t\n#### Git GUI Clients\n- 应用类型：⌨️ | 代码管理\n- 是否付费：🆓 | 免费使用\n- 支持平台：`MacOS` | `Windows` | `Linux` | `Android` | `iOS`\n- 官方地址：[Git 官网](https://git-scm.com/) | [Git 下载](https://git-scm.com/downloads/guis)\n- 推荐理由：面向 Git ( 开源的分布式版本控制系统 )，即 Git GUI 是一款拥有界面交互的 Git 客户端。\n\n### 网络工具\n#### Downie\n- 应用类型：📥 |  网络下载\n- 是否付费：💵 | 付费应用\n- 支持平台：`MacOS`\n- 官方下载：[Downie 官方](https://software.charliemonroe.net/downie.php) | [少数派评测](https://sspai.com/post/40999)\n- 推荐理由：\n\t- 超过 1000+ 流媒体网站的视频下载 ( YouTube、Vimeo、Bilibili、优酷、爱奇艺等 )；\n\t- 直接拖拽链接即可下载，但注意部分视频源以分片段形式下载，与 [Permute](#Permute) 搭配使用即可；\n\t- 内置资源搜索功能。\n\n### 系统补全\n#### Xcode\n- 应用类型：⚙️ | 系统内置 ( 包含大部分应用所需要的运行环境 )\n- 是否付费：🆓 | 免费使用\n- 支持平台：`MacOS`\n- 推荐理由：\n\t-  用于 MacOS 和 iOS 应用程序开发的集成开发工具 ( IDE )；\n\t- 既使不以开发者角度考虑，它包含了大部分应用运行所需要的依赖库 ( 运行环境 )，推荐安装。\n\n#### Automator\n- 应用类型：⚙️ | 系统内置\n- 是否付费：🆓 | 免费使用\n- 支持平台：`MacOS`\n- 官方地址：[Automator 官方](https://support.apple.com/zh-cn/guide/automator/welcome/mac) | [少数派评测](https://sspai.com/post/36667)\n- 推荐理由：iOS 上大名鼎鼎的 `Workflow`、`捷径`，相信大伙不会陌生，而作为提升工作效率的神器，在 Mac 端也同样有替代的方案，它就是 `Automator` ，俗称 \"扛炮\"。\n\n#### iStatistic\n- 应用类型：🌡 | 系统监控\n- 是否付费：💵 | 付费应用\n- 支持平台：`MacOS` | `iOS`\n- 推荐理由：\n\t- 系统监测软件，包括性能、能耗及温度情况监测；\n\t- 动态化、图表化显示数据 ( 支持 Web DashBoard )，喜欢装机的朋友不妨在机箱内挂小屏幕做展示，科技感十足。\n\n#### 加速大师\n- 应用类型：🌡 | 系统优化\n- 是否付费：🆓 | 免费使用\n- 支持平台：`MacOS`\n- 官方地址：暂无 ( 只能从 [Mac App Store](https://itunes.apple.com/cn/app/%E5%8A%A0%E9%80%9F%E5%A4%A7%E5%B8%88/id1144825078?mt=12) 中下载，请认准小火箭的图标。但后面发现作者以另一款软件 [iCare 3](https://itunes.apple.com/cn/app/icare-3/id1142437192) 更新项目 )\n- 推荐理由：\n\t- 轻量级系统垃圾清理工具，卸载管理工具，开机自启项管理工具；\n\t- 支持性能监测 ( 内存、CPU、网络 I/O ) 和内存释放的功能；\n\n#### Keka\n- 应用类型：📦 | 解压缩工具\n- 是否付费：🆓 | 开源免费\n- 支持平台：`MacOS`\n- 官方地址：[Keka 官网](https://www.keka.io/zh-cn/) | [Github 开源](https://github.com/aonez/Keka)\n- 推荐理由：\n\t- 开源且完全免费 ( GPL )；\n\t- MacOS 平台独占应用，支持 `解、压缩` 文件；\n\t- 且支持 `7z` 文件和 `Zip 2.0` 文件使用 `AES-256` 加密 ；\n\t- 可支持创建 7Z, ZIP, TAR, GZIP, BZIP2, XZ, LZIP, DMG, ISO 格式文件；\n\t- 可支持解压 7Z, RAR, TAR, GZIP, BZIP2, XZ, LZIP, DMG, ISO, LZMA, EXE, CAB, WIM, PAX, JAR, APK, APPX, CPGZ, CPIO 格式文件。\n\n#### 7-Zip\n- 应用类型：📦 | 解压缩工具\n- 是否付费：🆓 | 开源免费\n- 支持平台：`Windows` | `Linux`\n- 官方地址：[7-Zip 官网](https://www.7-zip.org/) | [7-Zip 下载](https://www.7-zip.org/download.html)\n- 推荐理由：\n\t- 开源且完全免费 ( LGPL )；\n\t- 国内的解压缩工具不敢恭维，不谈性能，内嵌广告行为就是耍流氓；\n\t- 可支持解、压缩格式：7z, XZ, BZIP2, GZIP, TAR, ZIP, WIM\n\t- 仅可解压格式：ARJ, CAB, CHM, CPIO, CramFS, DEB, DMG, FAT, HFS, ISO, LZH, LZMA, MBR, MSI, NSIS, NTFS, RAR, RPM, SquashFS, UDF, VHD, WIM, XAR。\n\n### 论文写作\n#### Grammarly\n- 应用类型：📄 | 论文写作\n- 是否付费：💵 | 增值服务内购\n- 支持平台：`MacOS` | `Windows` | `MS Office` ( 仅 Windows ) | `浏览器插件` ( Safari、Chrome、firebox、IE )\n- 官方地址：[Grammarly 官网](https://www.grammarly.com/) | [瞎洛 ( 小姐姐 ) 评测](https://www.bilibili.com/video/av28844962)\n- 推荐理由：\n\t- 英文写作辅助神器；\n\t- 英语检查软件，可自动地单词纠错，标点符号纠错和语法纠错。\n\n#### Endnote\n- 应用类型：📄 | 文档管理\n- 是否付费：💵 | 增值服务内购\n\n## 需求升级：系统解决方案\n### 开篇引言\n- 完整软件解决方案：运作相应的 `操作系统` 和 `应用程序`，以提供完整的软件解决方案。\n- 下述所有 `解决方案`，原则上可在一台服务器实现的。实现原理即服务器上多开 `虚拟机`，让每台虚拟机各司其职，运作相应的 `操作系统` 和 `应用程序`，提供相应的功能或服务。\n- 这也是近些年想达成的小目标：感谢 liuspy 的文章 $^{[1]}$ 启发，才有想法去组一台 `家用服务器`，实现 `个人私有云 (黑群晖)`、`软路由 (OpenWrt/iKuai)`、`Web 服务器`、`代码托管服务器` 等。当然，在条件允许情况下，尽量把攒机过程中所做过的调研资料整理并输出文章，以便同样有折腾需求的朋友复用。\n  \n### 路由系统解决方案\n- 需求定位：突破普通路由器诸多的瓶颈和限制，除了享受高性能的网络体验，且获得更高阶的 `服务体验` 和 `玩法`。\n\t\n\t> 关于服务体验和玩法，具体可参考市面上的智能路由产品，它们表现的花样已经足够多了，如 `科学上网`、`去广告`、`文件服务器 (FTP/SMB)`、`运行 Python 程序` 等，有兴致的朋友可以自行了解详情。\n\n\t- 路由系统可分为软路由和硬路由，在介绍前夕，先弄明白两者的 `概念` $^{[2, 3]}$：\n\t\t- `软路由`：指利用台式机或服务器配合软件 ( 虚拟机 ) 而形成的路由解决方案。简单理解，即 `PC + 操作系统 ( Linux / Windows )  + 专用路由程序` 组成的路由解决方案；\n\t\t- `硬路由`：采用特定的硬件设备，基于嵌入式系统架构，以自行开发或是现成的嵌入式操作系统配合自行开发的路由软件，提供专门的路由器功能。当然，也可理解为 `厂家推出的整体路由解决方案`，例如网件、华硕、华为、小米、TP-LINK 等生产的路由产品。\n\n\t- 事实上，路由其实没有软、硬之分，任何路由器都由处理器、内存、路由程序存储器、网络接口模块、电源模块、输入输出部分与系统构成的。\n\n\t\t而区分两者的概念，主要是为了更精确定位，尽量在满足自己性能需求的前提下，最大化地 `节约硬件成本` 和 `运作成本` ( 主要是耗电成本 )。\n\n- `涉及系统`：根据路由的形式，硬件架构、系统架构是不同的，故各有自适用的路由系统，选择正确的路由系统以发挥其最大效能。\n\t- 针对软路由：[OpenWrt (LEDE)](https://openwrt.org/start?id=zh/start)、[iKuai]()、[海蜘蛛](http://www.hi-spider.com/zh)、[梅林 (koolshare)](http://firmware.koolshare.cn/LEDE_X64_fw867/)\n\t-  针对硬路由：[OpenWrt (LEDE)](https://openwrt.org/start?id=zh/start)、[Padavan (荒野无灯)](http://p4davan.80x86.io/)、[梅林 (支持硬件有限)](http://firmware.koolshare.cn/)\n\n- `涉及硬件`：硬路由器的硬件架构则是专为路由器而设计的，而软路由器的硬件架构是通用的，故我们只能针对软路由器的方案制定 `硬件需求方案`，考虑本章节的主题是路由器，则硬件需求方案将留至 `装机篇章` 讲述。\n\n- 搭建流程：\n\n### 个人博客解决方案\n- 需求定位：\n\t- 纯粹的图文静态博客，仅以内容即可驱动的博客载体，且不需要额外的运营成本 ( 团队运营、服务器等 )。\n\t- Hexo 博客框架的免费开源性质，官方提供强大的 API，还有丰富的社区资源 ( 教程、插件、主题等 )，基本能满足你的个性化服务和需求。\n\t- Hexo 支持 Markdown，上百页面秒级的渲染速度，一键即可部署至 Github。\n\n- 涉及框架：`Hexo`\n\n- 涉及技术：分布式版本控制系统 `Git`。而这里，使用到的主要功能是代码托管，而托管平台我们选择 `Github` ( 当然限于国内的访问速度，你可同时部署多个平台，例如：[Coding](https://coding.net/)、[Gitee](https://gitee.com/)\n\n- 搭建流程：\n\t- 📖 | [Hexo. 官方使用文档. hexo.io](https://hexo.io/zh-cn/docs/) \n\t- 📝 | [Kofe. 基于 Hexo 框架在 Github 上搭建博客. kofes.cn](https://www.kofes.cn/2018/01/Hexo-Installation-Guide.html)\n\t- 📝 | [Panbaixin. Hexo + Github 搭建个人博客. baixin.io](http://baixin.io/2015/08/HEXO搭建个人博客/)\n\t- 📝 | [C.J.Scarlett. How to Create a Blog with Hexo On Ubuntu. digitalocean.com]()\n\n### 个人私有云解决方案\n暂未定更新日期。\n\n### 跨平台智能家居方案\n暂未定更新日期。\n\n### 科学上网解决方案\n暂未定更新日期。\n\n### 虚拟专用网络方案\n暂未定更新日期。\n\n### 代码托管方案：Svn\n- 需求定位：作为 `集中式` 源代码版本控制系统，其适合于企业内部由项目经理统一协调的多个并行项目的开发。有趣的是，更甚有企业把 Svn 当作云端文件夹，毕竟其入门门槛比较低。而在 Git 盛行的环境下，我们学习 Svn 的理由更多的是适应公司的开发模式。至于 Svn 与 Git 的优劣，还是视具体使用环境而言，有兴趣可以参阅参考文章 [4]，其中描述了 Git 与 Svn 的详细对比，它们各自的优劣心中自有标准。  \n- 涉及技术：集中式的源代码版本控制系统 `Svn`。\n- 涉及软件：\n\t- 服务端：[Widnows Server](https://www.visualsvn.com/server/download/)\n\t- 客户端：[TortoiseSVN for Windows](https://tortoisesvn.net/downloads.html) | [Cornerstone for MacOS](https://cornerstone.assembla.com/)\n- 搭建流程：\n\t- 📝 | [Kofe. SVN 环境搭建与使用. kofes.cn](https://www.kofes.cn/2018/08/building-a-svn-server.html)\n\n### 代码托管方案：Git\n暂未定更新日期。\n\n## 好马配好鞍：浏览器插件\n### Violentmonkey\n- 插件性质：辅助\n- 支持平台：`Chrome` | `Firefox` | `Opera` | `Maxthon`\n- 官方地址：[Violentmonkey 官网](https://violentmonkey.github.io/) | [Violentmonkey 下载](https://violentmonkey.github.io/get-it/) | [Github 开源](https://github.com/violentmonkey/violentmonkey)\n- 推荐理由：开源的用户脚本管理器。\n\n\t> 用户脚本是什么：是一段代码，它们能够优化您的网页浏览体验。安装之后，有些脚本能为网站添加新的功能，有些能使网站的界面更加易用，有些则能隐藏网站上烦人的部分内容。\n\n- 脚本库：[GreasyFork](https://greasyfork.org/zh-CN) | [OpenUserJs](https://openuserjs.org/)\n\n- 优秀脚本推荐：\n\t- [本地 Youtube 下载器](https://greasyfork.org/zh-CN/scripts/369400-local-youtube-downloader)：不需要透过第三方的服务就能下载 YouTube 影片。当然，Youtube 的高码率 ( 1080P、1440P、2160P ) 的媒体是音频、视频分体的，具体可使用 [FFmpeg](#FFmpeg) 或 Premiere、Final Cut、iMovie 等视频编辑工具合成。\n\t- [网盘自动提取提取码](https://greasyfork.org/zh-CN/scripts/18733-网盘提取工具)：网盘自动提取、输入提取码，省心、省力、不折腾。\n\n### Tampermonkey\n- 插件性质：辅助\n- 支持平台：`Chrome` | `Firefox` | `Opera` | `Edge` | `Safari` | `Dolphin`\n- 官方地址：[Tampermonkey 官网](https://tampermonkey.net/) | [谷歌应用商店](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?utm_source=chrome-ntp-icon)\n- 推荐理由：用户脚本管理器。\n\n### 广告终结者\n- 插件性质：辅助\n- 支持平台：`Chrome` | `360 浏览器` | `搜狗浏览器` | `UC 浏览器` | `猎豹浏览器` | `百度浏览器`\n- 官方地址：[官方网站](http://www.adtchrome.com/) | [谷歌应用商店](https://chrome.google.com/webstore/detail/广告终结者/fpdnjdlbdmifoocedhkighhlbchbiikl?utm_source=chrome-ntp-icon)\n- 推荐理由：\n\t- 可过滤网页中几乎所有的横幅、弹窗、视频广告；\n\t- 手动屏蔽网页广告：最喜欢的功能之一，\"以氓治氓\" 形容也不为过哈。\n\n### 谷歌学术搜索按钮\n- 插件性质：辅助\n- 支持平台：`Chrome`\n- 官方地址：[谷歌应用商店](https://chrome.google.com/webstore/detail/google-scholar-button/ldipcbpaocekfooobnbcddclnhejkcpn?utm_source=chrome-ntp-icon)\n- 推荐理由：快速检索学术论文、文献，一键下载，一键导出多种标准的引用格式；\n\n## 信仰装机：学娱并进 PC\n### 需求定义\n- `价格`：不谈价格选配置，浪费时间不止且无意义。为此，我们控制在 8.0k 到 11.4k 的价格区间内，不追求一步到位，可迭代式升级硬件以达成装机目标。具体地，装机计划以阶段目标执行：\n\t- `第一阶段` (5.3k-8.1k)：机箱 (0.4k-1.0k)，主板 (1.0k-1.5k)，CPU (1.8k-2.3k)，电源 (0.6k-0.8k)，M.2 512GB 固态硬盘 (0.4k-0.8k)，8GB 内存 (0.5k-0.9k)，散热 (0.6k-0.8k)\n\t- `第二阶段` (2.7k-4.0k)：显卡 (2.5k-3.5k)，风扇 (0.2k-0.5k)\n\t- `第三阶段` (1.5k-2.2k)：屏幕 (1.5k-2.2k)\n\n\t\t> 提示：各硬件的售卖价格主要参考各硬件的京东旗舰店定价，且有效统计截止于 2019 年 3 月。\n\t\n- `外观`：基于工作环境的因素考量，首先偏向于 ITX 规格或者适中规格的机箱；再者是材质方面，钢化玻璃侧透机箱或铝制机箱，且前者可考虑加入 RGB 灯光系统。\n\n\t> 机箱规格分别有：ITX，M-ATX，ATX $^{[5]}$。\n\n- `硬件`：\n\t- `机箱`：中等紧凑型，再考虑标准型 ( 兼容 ATX 的小机箱 )；优先考虑钢化玻璃侧透机箱，再到一体成型铝材机箱。\n\t- `主板`：华硕 ROG 系列，没有超频需求；接口支持丰富；包含 WI-FI 以及蓝牙模组；mATX、ITX 规模的主板 ( 从左到右的优先顺序 )。\n\t- `处理`：散装 CPU ( 散热器自由购置 )。\n\t- `电源`：充足的功率支持，便于日后升级之需。注意机箱对电源的尺寸要求。\n\t- `硬盘`：M.2 SSD 512GB；2T 希捷机械盘 7200 转。\n\t- `内存`：不限条件，自由选择。功率在 2666-3000 足矣。\n\t- `散热`：尽可能静音；支持华硕 AURA 灯光同步系统。\n\t- `显卡`：限定为 NVDIA ，且 CUDA 程序良好支持、Tensorflow 良好支持的显卡。\n\t- `屏幕`：2k 分辨率，23.8 / 27 尺寸，当然资金充足可考虑 HDR 10。\n\n### 装机预习\n- [知乎问题. DIY 装机有哪些误区. zhihu.com](https://www.zhihu.com/question/35911743)\n- [3DMGAME. 电脑检测跑分工具大全. 3dmgame.com](https://dl.3dmgame.com/patch/paofenruanjian.html)\n- [卖一手. 台式机电源选购经验篇一：品牌、代工及选购点. 2015. smzdm.com](https://post.smzdm.com/p/106088/)\n- [子希兄弟. 超详细电脑组装、电脑安装教程教学. 2018. bilibili.com](https://www.bilibili.com/video/av25211498)\n\n### 硬件挑选\n- `机箱`：\n\t-  Sunmilo BG2 黑红色版 ( MOD 机箱 )\n\t\n\t\t> [Sunmilo. 官方样张. taobao.com](https://item.taobao.com/item.htm?spm=a1z10.1-c.w4004-9691348913.8.65186580AZGN5m&id=538855908500) | [Griffyn. 桌面 show. chiphell.com](https://www.chiphell.com/thread-1933774-1-1.html)\n\t- 乔思伯 RM3 标准版，其中此型号还有炫彩灯光的版本，支持订制铭牌。\n\n\t\t> 关于 RM3 的样机演示可参考官网组图：[RM3 装机实物展示图](http://www.jonsbo.com/products_30_2.html)\n- `主板`：华硕 ROG B360/Z370/H370 系列 + I/G/F Gaming\n\t- `选择什么系列` $^{[6]}$：主板是衔接所有硬件的媒介，结合需求选择适用的主板。\n\t\t- Z370、Z390 是针对是否有超频需求的产品，需求不强则选择 B360。\n\t\t- H370 主打的是扩展性。其定位很尴尬，若你选择 iTX / mATX 规格的主板，考量性能差距、价格差距则没有必要上 H370。\n\t- `具体型号说明`：F 为 ATX 规格主板，含 RGB 灯效模块；I 为 ITX 规格主板，含 RGB 灯效模块；G、H，分别是 mATX 和 ATX 规格主板，但不含 RGB 模块，价格相对最便宜。当然，是否需要 PCIe 拓展槽也是需考量的因素。\n\t- `明确最终需求`：对以上主板型号有了宏观认识后即可挑选具体的主板。\n\t\t- 首先，明确需要组装机的规格为 ITX / mATX，同样限制了主板尺寸大小；\n\t\t- 其次，我们要打造一套灯光系统，故华硕的 `AURA` 神光同步是不可缺少的；\n\t\t- 最后，选择 `华硕 ROG B360-I Gaming` / `华硕 TUF Z390M Pro`。\n- `电源`：因为小机箱缘故，且要求走背线，故金牌全模组电源是必须的。\n\t- EVGA G3 金牌全模组 650W\n\t- 海韵 550W 金牌全模组 FOCUS+ 550FX\n\t- 海盗船 SF600  金牌全模组 600W\n- `CPU`：Intel i7 8700 \n- `内存`：支持 AURA 灯效的内存，频率保持 2666-3000 Hz 水平左右。\n\t- 十铨 DDR4 3200 RGB 灯条 8GB \\* 2\n\t- 芝奇 DDR4 3000 幻光戟 8GB  \\* 2\n- `硬盘`：\n\t- `固态`：浦科特  M9PeG 512GB M.2 NVMe\n\t- `机械`：希捷 ST2000DM008 2TB 7200 SATA\n- `散热`：\n\t- 利民 银箭 130 Plus + NF-A12  2000 PWM 散热风扇 * 1\n\t- 猫头鹰 D15S 石墨烯版本 + NF-A14 1500 PWM 散热风扇 * 1\n- `风扇`：MOD 定制的机箱，用于机箱的风扇需要 5 个。\n\t- 机箱底进风：出于 AURA 灯光同步系统的考量，暂考虑超频三 皓月 RGB\n\t- 机箱后排风：猫头鹰 NF-A8 2200 PWM 散热风扇 * 2\n- `显卡`：华硕 ROG STRIX RTX2060 / 技嘉 RTX2060 小雕\n- `屏幕`：戴尔 2518DR\n\n### 购买渠道\n- 基于价格、供货渠道、维修售后保障，选择购买硬件的电商平台：\n\t- 线下：CPU、显卡\n\t- 淘宝：机箱、线材\n\t- 京东：主板、电源、内存、硬盘、散热、风扇、显示器\n\t- 闲鱼：显示器\n\n### 案例搜集\n- 关于装机的案例，主要围绕以下需求进行搜集：\n\t- 基于工作环境的因素考量，首先偏向于 ITX / mATX 规格的案例。\n\t- 机箱是钢化玻璃材质侧透机箱，拥有透视内部结构效果，考虑 RGB 灯光系统，且注重 RGB 系统的可控性。\n\t- 注重走线工整性，最理想的则是包含安装过程与教程的案例。\n\n#### ITX 规格\n- 案例：[80it电脑网. 灵魂走线系列19. 2018. bilibili.com](https://www.bilibili.com/video/av35835083)\n\t- 机箱：迎广 in win A1 ( ITX )\n\t- 主板：华硕 Strix ROG Z390-I Gaming ( mini-ITX )\n\t- 电源：海盗船 SF600 全模组\n\t- CPU：Intel i7 9700k\n\t- 内存：芝奇 Trident Z RGB * 3\n\t- 硬盘：三星 M.2 SSD 970 EVO 500GB\n\t- 显卡：华硕 Strix ROG 2080 8G 猛禽\n\t- 散热：华硕 ROG 龙王 120 ( CPU 散热 )\n\t- 风扇：海盗船 LL120 RGB * 3 ( 机箱散热 )\n- 案例：[ITX实验室. ITX 业界标杆 MK3S & StarWars 主题装机. 2019. bilibili.com](https://www.bilibili.com/video/av41426930)\n\t- 机箱：MK3S 定制机箱 ( 工期很长，必须有很强信仰才敢买啊 )\n\t- 主板：华擎 Z390 ITX 幻影电竞\n\t- 电源：海盗船 SF600 全模组\n\t- CPU：Intel i7 9900k\n\t- 内存：十铨 王者之剑 夜鹰 RGB\n\t- 硬盘：惠普 M.2 SSD EX920 1TB\n\t- 显卡：TITAN XP Starwars 限定\n\t- 散热：利民 银箭130 + 猫头鹰 NF-F12 industrialPPC-3000 PWM ( CPU 散热 )\n\t- 风扇：Tt Luna 8cm RED RGB * 2 ( 机箱散热 )\n- 案例：[FUSION II. 极限性能TX迷你小钢炮装机摄影. 2017. bilibili.com](https://www.bilibili.com/video/av16513351) \n\t- 机箱：NCASE M1 ( ITX )\n\t- 主板：微星 Z370I Pro CarBon AC ( mini-ITX )\n\t- 电源：海盗船 SF600 全模组\n\t- CPU：Intel i5 8600k\n\t- 内存：海盗船 白金统治者 16G 2666MHz * 2\n\t- 硬盘：三星 M.2 SSD 960 EVO 250GB\n\t- 显卡：EVGA GTX1080TI SC2\n\t- 散热：猫头鹰 D9L ( CPU 散热 ) \n\t- 风扇：EK Vardar EVO 12cm 2200RPM ( 机箱散热 )\n\n#### mATX 规格\n- 案例：[FUSION II. 价值$3300美刀极限性能装机. 2018.bilibili.com](https://www.bilibili.com/video/av21497419)\n\t- 机箱：Meshify C Mini\n\t- 主板：华擎 X399M 太极 ( mATX )\n\t- 电源：海盗船 SF600 全模组\n\t- CPU：Intel i5 8600k\n\t- 内存：海盗船 复仇者 8GB DDR4 3000 MHz * 2\n\t- 硬盘：三星 M.2 SSD 960 EVO 250GB\n\t- 显卡：EVGA GTX1080TI SC2\n\t- 散热：安耐美 LiqTech TR4 240 一体水冷散热器 ( CPU 散热 )\n\t- 风扇：酷冷至尊 MasterFan Pro 120 RGB 风扇套装 ( 机箱散热 )\n\n\t\t> 本套方案包含安装过程的详细解说以及走线演示，推荐观看。\n\t\n- 案例：[Okeydokey科技. 超干净的无RGB恩杰装机. 2018.bilibili.com](https://www.bilibili.com/video/av32759959)\n\t- 机箱：恩杰 H400i\n\t- 主板：华硕 ROG Strix Z370-G ( mATX )\n\t- 电源：海盗船 RM650X 全模组电源\n\t- CPU：Intel i7 8700k\n\t- 内存：十铨 DARK PRO 32GB DDR4\n\t- 硬盘：三星 M.2 SSD 960 EVO 250GB\n\t- 显卡：EVGA GTX 1080 Ti SC2\n\t- 散热：EK Coolstream 280mm ( CPU 水冷散热 )\n\t- 散热：猫头鹰 NH-U9S + NF-B9 \\* 2 ( CPU 风冷散热 )\n\t- 风扇：EK Vardar EVO 120mm \\* 2 + 140mm \\* 2 ( 机箱散热 )  \n\n\t\t> 本套方案尝试了两套散热系统，分别是猫头鹰的风冷套装和 EK 的水冷套装。\n\n## 参考资料\n- [1] [Liuspy. 千元 DIY 搞定 7*24 小时 N in 1 服务器. smzdm.com](https://post.smzdm.com/p/674680/)\n- [2] [周晓锋. 软路由 Vs. 硬路由. 2011. 51cto.com](http://blog.51cto.com/likespc/714064)\n- [3] [云上小悟. 软路由 Vs 硬路由. 2013. maixj.net](http://www.maixj.net/ict/ruanluyou-yingluyou-5723)\n- [4] [跪着行走的boY. Git 和 Svn 的详细对比. cnblogs.com. 2017](http://www.cnblogs.com/dazhidacheng/p/7478438.html)\n- [5] [古方日月已使用. 电脑主板板型怎么选 ATX、ITX还傻傻分不清. 2017. zol.com.cn](http://bbs.zol.com.cn/diybbs/d402_9829.html)\n- [6] [太平洋电脑网. Z370/H370/B360/H310主板怎么选. 2018. baijiahao.baidu.com](http://baijiahao.baidu.com/s?id=1601905877566591798&wfr=spider&for=pc)","tags":["sunmilo"],"categories":["Technique"]},{"title":"笔记 | 数据分析学习框架","url":"%2F2018%2F09%2Fdata-analysis-learning-framework.html","content":"\n本笔记以秦路老师的文章「如何七周成为数据分析师」为内容框架，整合相关的论文、书籍、视频资料，输出学习笔记。主要目的是检验自己的学习效果和日常复习之需。\n\n初入数据分析的大门，笔记大部门的知识模块以阅读原资料总结整理而得，难免有理解偏差、错误的地方，若有不正当的解释还望朋友们不吝指教！\n\n<!-- More -->\n\n## 更新进度\n- 2018.09.29：完成初稿，形成笔记的整体框架；\n- 2018.09.30：更新「数据分析入门」章节；\n\n## 学习框架\n- `整体框架`：本笔记以秦路老师的文章「如何七周成为数据分析师」$^{[1]}$ 为内容框架，整合相关的论文、书籍、视频资料，输出学习笔记。\n- `数学部分`：数据分析，离不开数学。关于学习资料的选择，推荐盛骤老师的《概率论与数理统计·第4版》和张宇老师的《带你学概率论与数理统计·浙大4版》。\n\n\t> 数学并不是自己擅长的科目，出于这样的考虑，故选择了 `大学教材` 和 `考研辅导书`，希望借以习题辅导书复习教材内容，以短时间获得最大成效比。\n\n\t- 📖 | 书籍 | [盛骤. 概率论与数理统计·第4版. 高等教育出版社](https://book.douban.com/subject/3165271/)\n\n\t- 📖 | 书籍 | [张宇. 带你学概率论与数理统计·浙大4版. 北京理工大学出版社](https://book.douban.com/subject/26630236/)\n\n\t- 📺 | 视频 | [张宇. 2018 考研概率论强化课程. bilibili.com](https://www.bilibili.com/video/av14690558?from=search&seid=2673720085936060940)\n\n\t- 📝 | 文章 | [Kofe | 笔记 | 概率论与数理统计](https://www.kofes.cn/2018/09/probability-and-statistics.html)\n\n- `统计部分`：很遗憾对此部分知识不了解，在此不具体展开探讨。但《概率论与数理统计》的数理统计部分可以预先复习。\n\n- `数据库部分`：在秦路老师的文章中，数据库部分侧重 SQL ( 结构化查询语言 ) 的讲解，当然这也是操作性和实用性很强的一模块。且据以往语言学习的经历，`多写、多练` 是必不可少的阶段，SQL 也不例外，附带的练习题目中有不少经典的实例，作为入门训练材料刚好合适。\n\n\t当然，数据库的知识不仅如此，有需求的朋友可继续参阅书籍《数据库系统概念》$^{[2]}$，即以数据库工程师的角度出发，从需求到维护的流程化学习过程，整体架构上学习数据库这门学科。\n\t\n\t- 📝 | 文章 | [W3CSchool SQL 教程 & 练习题](http://www.w3school.com.cn/sql/index.asp)\n\n\t- 📝 | 文章 | [LeetCode SQL 练习题](https://leetcode-cn.com/problemset/database/)\n\n\t- 📖 | 书籍 | [Abraham Silberschatz. 数据库系统概念. 机械工业出版社](https://book.douban.com/subject/10548379/)\n\n\t- 📖 | 书籍 | [福达(Ben Forta). SQL 必知必会. 人民邮电出版社](https://book.douban.com/subject/24250054/)\n\t\n- `编程部分`：主导 Python 语言编程。由于篇幅的缘故，该部分内容请参阅另一篇博文：\n\n\t- 📝 | 文章 | [Kofe | 笔记 | Python 3 入门系列教程](https://www.kofes.cn/2018/09/life-is-short-we-need-python.html)\n\n\t- 📝 | 文章 | [廖雪峰. Python 教程. 2018. liaoxuefeng.com](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)\n\n\t\t> 当然，Python 的学习还可以参考廖雪峰老师的教程。\n\n\t- 📖 | 书籍 | [Iamseancheney (译). Python 数据分析 (第二版). 2017. github.com](https://github.com/iamseancheney/python_for_data_analysis_2nd_chinese_version)\n\n\t\t> 本书是 2017 年 10 月 20 号正式出版的，和第一版的不同之处有：  \n\t\t> 1) 包括 Python 教程内的所有代码升级为 `Python 3.6`；  \n\t\t> 2) 更新了 Anaconda 和其它包的 Python 安装方法；   \n\t\t> 3) 更新了 Pandas 为 2017 最新版；  \n\t\t> 4) 新增 `高级的 Pandas 工具` 章节；   \n\t\t> 5) 简要介绍和使用 `StatsModels` 和 `scikit-learn`.  \n\n- `研究部分`：自己课题的需求，数据科学方向的研究是必不可少的环节。篇幅原因，则细节在下文中展开探讨。按照惯例，为了便于知识的引用和问题的探讨，以下罗列自己所使用到的学习资料。\n\t- 🍉 | 书籍 | [周志华. 机器学习 (西瓜书). 清华大学出版社](https://book.douban.com/subject/26708119/)\n\n\t- 🌼 | 书籍 | [[美] 伊恩·古德费洛. 深度学习 (花书). 人民邮电出版社](https://book.douban.com/subject/27087503/)\n\n\t- 📺 | 视频 | [深度学习. 读书会分享视频集. bilibili.com](https://www.bilibili.com/video/av15558220)\n\n\t\t> 视频转载自：[Alena Kruchkova. Deep Learning Book Live Streams. youtube.com](https://www.youtube.com/playlist?list=PLsXu9MHQGs8eO64mazCnCU3bc9l25Z1ZZ)  \n\t\t> 若有条件科学上网的朋友，可至 Youtube 搭配在线字幕观看。\n\t\n\t- 📖 | 书籍 | [李航. 统计学习方法. 清华大学出版社](https://book.douban.com/subject/10590856/)\n\n\t- 📖 | 书籍 | [[美] Jiawei Han. 数据挖掘：概念与技术 (原书第3版). 机械工业出版社](https://book.douban.com/subject/11542972/)\n\n## 数据分析入门\n\n### Excel：不考虑性能和数据量\n- 掌握各类功能强大的函数 -- [常见 Excel 函数](https://ask.hellobi.com/blog/qinlu/5976)\n\t- 清洗处理类：trim、concatenate、replace、substitute、left/right/mid、len/lenb、find、search、text\n\t- 关联匹配类：lookup、vlookup、index、match、row、column、offset\n\t- 逻辑运算类：if、and、or、is系列\n\t- 计算统计类：sum/sumif/sumifs、sumproduct、count/countif/countifs、max、min、rank、rand/randbetween、averagea、quartile、stdev、`substotal`、int/round\n\t- 时间序列类：year、month、weekday、weeknum、day、date、now、today、`datedif`\n- Excel 常用工具 -- [数据分析：Excel 技巧大揭秘](https://ask.hellobi.com/blog/qinlu/5977)\n\t- `格式转换`：自定义格式规范时间。\n\t\t\n\t\t> 2016/11/11 写成 yyyy/MM/dd  \n\t\t> 2016-11-11 23:59:59 写成 yyyy-MM-dd HH:mm:ss\n\t\t\n\t- `分列`：分列功能可以将某一列按照特定规则拆分，常常用来进行数据清洗。\n\t- `数据透视表`：数据透视表的核心思想是聚合运算，将字段名相同的数据聚合起来，所谓数以类分。\n\n\t\t> 列和行的设置，则是按不同轴向展现数据。简单说，你想要什么结构的报表，就用什么样的拖拽方式。\n\t\t\n\t- `删除重复项`：一种数据清洗和检验的快速方式。想要验证某一列有多少个唯一值，或者数据清洗，都可以使用。\n\t- `自定义下拉菜单` (数据有效性)：数据有效性是一种约束，针对单元格限制其输入，也就是让其只能固定几个值。下拉菜单是一种高阶应用，通过允许下拉箭头即可。\n\t- `查找公式错误`：公式报错也不知道错在哪里时候可以使用该功能，尤其是各类IF嵌套或者多表关联，逻辑复杂时。查找公式错误是逐步运算的，以方便定位。\n\t- `分组和分级显示`：常用在报表中，在报表行数多到一定程度时，通过分组达到快速切换和隐藏的目的。\n\t- **`分析工具库`**：分析工具库是高阶分析的利器，包含很多统计计算，检验功能等工具。Excel是默认不安装的，要安装需要加载项，在工具菜单下（不同版本安装方式会有一点小差异）。\n\t\n\t   > 分析工具库是统计包，如随机数发生器、排位与百分比排位、回归、抽样、t-检验等。\n\t\t\n- Excel 实战教程 -- [数据分析：手把手教你Excel实战](https://ask.hellobi.com/blog/qinlu/5978)\n\t- 明确目的\n\t\t- 数据用来解决什么问题？\n\t\t- 汇总统计制作报表？\n\t\t- 数据可视化，作为一张信息图？\n\t\t- 验证某一类业务假设？\n\t\t- 提高某一个指标的KPI？\n\t- 观察数据\n\t\t- 数据有无缺失值\n\t\t  - 某一字段缺失数据较多，要考虑是否删除该字段（超过 50% 即没有业务意义了）\n\t\t- 数据是否一致化\n\t\t- 数据是否有脏数据：乱码，错位，重复值，未匹配数据，加密数据\n\t\t- 数据标准结构\n\t- 数据清洗：结合 `观察数据` 阶段完成的工作，对数据进行 `预处理操作`。\n\t- 分析过程\n\t   - 数据透视表\n- 单元格格式：数据分析师会和各种数据类型打交道，包括各类 timestamp，date，string，int，bigint，char，factor，float 等。\n- 了解中文编码：UTF-8、GBK、ASCII 码。\n\n### Excel：数据可视化\n- Excel：多种经典图表\n\t- [数据可视化：你想知道的经典图表全在这](https://ask.hellobi.com/blog/qinlu/5986)\n\t   - 散点图：表示两个变量之间的关系。后续的学习中，多次借用到散点，统计中的 `回归分析`，比如数据挖掘中的 `聚类`。\n\t   - 折线图：了解某一维度在时间上的规律或者趋势。\n\t   - 柱形图：堆积柱形图，瀑布图，横向条形图，横轴正负图。\n\t   - 地理图：一切和空间属性有关的分析都可以用到地理图。\n\t   - 饼图\n\t   - 雷达图：也叫蛛网图，适合用在固定的框架内表达某种已知的结果。\n\t   - 箱线图：它能准确地反映数据维度的离散（最大数、最小数、中位数、四分数）情况。凡是离散的数据都适用箱线图。\n\t   - 热力图：以高亮形式展现数据。\n\t   - 关系图\n\t   - 矩形树图：柱形图不适合表达过多类目（比如上百）的数据，那应该怎么办？矩形树图出现了，它直观地以面积表示数值，以颜色表示类目。\n\t   - 桑基图：常表示信息的变化和流动状态。\n\t   - 漏斗图\n\t- [数据可视化：教你打造升职加薪的报表](https://ask.hellobi.com/blog/qinlu/5987)\n- PowerBI：Dashboard 仪表盘，由多个图表集合成的图表仪盘 -- [数据可视化：手把手打造BI](https://ask.hellobi.com/blog/qinlu/5989)\n\t- 商业智能（Business Intelligence，BI），在传统企业中，它是一套完整的解决方案。将企业的数据有效整合，快速制作出报表以作出决策。涉及 `数据仓库`，`ETL`，`OLAP`，`权限控制` 等模块。\n\n## 数据分析思维\n- 麦肯锡的分析思维：结构化思考，MECE原则，假设先行，关键驱动等方法论。 -- [快速掌握麦肯锡的分析思维](https://ask.hellobi.com/blog/qinlu/6002)\n- 分析思维框架：SMART、5W2H、SWOT、4P4C、六顶思考帽等 -- [如何建立数据分析的思维框架](https://ask.hellobi.com/blog/qinlu/6003)\n\n## 业务知识\n\n## 课题研究\n\n## 参考资料\n- \\[1\\] [秦路. 如何七周成为数据分析师. hellobi.com. 2017](https://ask.hellobi.com/blog/qinlu/8930)\n- \\[2\\] [Abraham Silberschatz. 数据库系统概念 (原书第6版) [M]. 机械工业出版社, 2012](https://book.douban.com/subject/10548379/)","tags":["数据库"],"categories":["Reading"]},{"title":"笔记 | 概率论与数理统计","url":"%2F2018%2F09%2Fprobability-and-statistics.html","content":"\n本笔记是备战考研时，跟着张宇老师的概率论课程学习整理所得。且输出本笔记的主要目的是快速构建概率的基础知识体系，以便于日后复习查阅和问题探究。或是更具体的应用场景，如 `机器学习`、`数据挖掘`、`经济统计` 等领域，概率论作为这些领域的 `先修课程`，理论基础尤为重要。由此，无论是初入门还是温故知新，学习基础学科为必经阶段，不妨选择张宇老师的概率论课程，这不失一种高效的复习方案。\n\n当然，笔记仅是对知识点的整理和归纳，并不能代表原本知识点的严谨定义。若有更进阶的需求，还请查阅概率论相关教材，或重温课程。\n\n<!-- More -->\n\n## 更新进度\n- 2018.10.04：完成初稿，并更新「如何处理复杂事件」章节 ( 共 4 节 )；\n\n## 学习资料\n- 推荐盛骤老师的《概率论与数理统计·第4版》和张宇老师的《带你学概率论与数理统计·浙大4版》。\n\n\t> 数学并不是自己擅长的科目，出于这样的考虑，故选择了 `大学教材` 和 `考研辅导书`，希望借以习题辅导书复习教材内容，以短时间获得最大成效比。\n\t\n\t- 📖 | 书籍 | [盛骤. 概率论与数理统计·第4版. 高等教育出版社](https://book.douban.com/subject/3165271/)\n\t- 📖 | 书籍 | [张宇. 带你学概率论与数理统计·浙大4版. 北京理工大学出版社](https://book.douban.com/subject/26630236/)\n\t- 📺 | 视频 | [张宇. 2018 考研概率论强化课程. bilibili.com](https://www.bilibili.com/video/av14690558?from=search&seid=2673720085936060940)\n\n## 学习目标\n- 以`张宇老师` 的概率论课程为框架的，围绕 `五大问题` 展开学习与探讨：在导课部分就明确了 `课程体系` 和 `学习目标`，即学习什么、学了怎么用都在浓缩于五大问题当中。\n\t- 如何处理复杂事件 $P(A)$；\n\t- 如何求分布 $F(x)$、$F(x, y)$；\n\t- 如何求数字特征 $EX$、$DX$、$Cov(x, y)$、$\\rho_{x,y}$；\n\t- 如何使用极限定理 ( 大样本， $n \\to \\infty$ );\n\t- 如何做估计与评价.\n\n- 前 `四大问题` 主要讨论的是 `概率论` 部分的内容，`最后一问题` 则是 `数理统计` 的内容探讨。\n- 事不宜迟，定下小目标，让自己赶紧行动起来！\n\t\n## 壹 如何处理复杂事件\n\t\n### 随机试验与样本空间\n#### 随机试验\n- 随机试验，记作 $E$：\n\t- 同条件下可重复。\n\t- 试验结果明确可知，且不止一个。\n\t- 试验前不知哪个结果会发生。\n\n#### 基本概念\n- `试验结果` 中每一个最简单、最基本 (不可再分的结果) 叫 `样本点` (基本事件)，记作 $\\omega$。\n- $\\omega$ 的全体叫 `样本空间`，记作 $\\Omega$。\n- `样本空间的子集` 叫 `随机事件`，记作 $A, B, C, ...$，即英文大写字母表示。\n- 子集中：\n\t- $\\Omega$ 本身为必然事件。\n\t- $\\emptyset$ 为不可能事件。\n\n### 古典概型\n#### 概念梳理\n- 若随机事件 $E$ 的样本空间 $\\Omega$ 中满足下述两种条件，称其为古典概型：\n\t- 存在 `有限个` 样本点；\n\t- 样本点的发生具有 `等可能性`.\n- 则其概率表达式为：\n\n$$\nP(A) = \\frac{A中含样本点个数}{\\Omega 中含样本点总数}\n\\tag{1}\n$$\n\t\n- 对于概率表达式 (1)，我们侧重关注其 `计数方法`：\n\t- `穷举法`：个数不多时，直接计数即可。\n\t- `集合对应法`：\n\t\t- `加法原理`：完成一件事有 $n$ 类方法，第一类方法有 $m_1$ 种方法，第二类有 $m_2$ 种方法，完成此事共 $\\sum_{i = 1}^n m_i$ 种方法。\n\t\t- `乘法原理`：完成一件事有 $n$ 个步骤，第一步有 $m_1$ 种方法，第二步有 $m_2$ 种方法，第 $n$ 步有 $m_n$ 种方法，故完成此事共 $\\prod_{i=1}^n m_i$ 种方法。\n\t\t- `排列`：从 $n$ 个不同的元素中取出 $m(\\leq n)$ 个元素，并按照一定顺序排成一列，叫做排序。所有排列的个数叫排列数，记作：\n\n\t\t$$\n\t\tA_n^m = n(n-1)···(n - m + 1) = \\frac{n!}{(n - m)!}\n\t\t\\tag{2}\n\t\t$$\n\t\t\n\t\t`全排列`：当 $m = n$ 时，$A_n^m = \\frac{n!}{0!} = n!$ 称为全排列。\n\t\t\n\t\t- `组合`：从 $n$ 个不同元素中取出 $m(\\leq n)$ 个元素，并成一组，叫组合。所有组合个数叫组合数，记作：\n\n\t\t$$\n\t\tC_n^m = \\frac{A_n^m}{m!}\n\t\t\\tag{3}\n\t\t$$\n\t\t\t\n\t\t> 注意：按照欧美规范，对于 $A_n^m$ 或是 $C_n^m$，m 和 n 的上下位置与我们平常见的是相反的，国内的教材以相反为主。\n\t\t\n\t- `对立事件思想`：若研究对象是复杂的，则转而研究对立事件 $\\overline{A}$，故有：\n\t\n\t$$\n\tn - n_{\\overline{A}} = n_A\n\t\\tag{4}\n\t$$\n\t\t\n#### 练习巩固\n##### 例题一\n- [题目] 从 0 到 9 个数字中任取 3 个不同数字，求：  \n\t- $A_1$ = {三个数中不含 0 和 5}\n\t- $A_2$ = {三个数中不含 0 或 5}\n\t- $A_3$ = {三个数中含 0，但不含 5}\n- [分析]  令含数字 0 的事件为 $B_1$，含数字 5 的事件为 $B_2$：\n\t- $P(A_1) = \\frac{ C_8^3 }{ C_{10}^3 } = \\frac{7}{15}$\n\t\n\t- $P(A_2) = \\frac{ C_{10}^3 - C_1^1·C_1^1·C_8^1 }{ C_{10}^3 } = \\frac{14}{15}$\n\n\t\t> $A_2$ 事件可通 `对立事件思想` 解题，即所有数字取值可能减去三个数中含 0 且含 5 的情况，即 $A_2 = \\overline{ B_1 \\bigcup B_2 } = \\overline{B_1} \\bigcap \\overline{B_2}$。\n\t\n\t- $P(A_3) = \\frac{ C_1^1·C_8^2 }{ C_{10}^3 } = \\frac{7}{30}$\n\n##### 例题二\n- [题目] 袋中有 5 球，3 白 2 黑：\n\t- 先后有放回取 2 球，求 $B_1$ = {至少一白球}\n\t- 先后无放回取 2 球，求 $B_2$ = {至少一白球} \n\t- 任取 2 球，求 $B_3$ = {至少一白球}\n- [分析] 注意 `有放回` 和 `无放回` 的情况，是有区别的：\n\t- $P(B_1) = \\frac{ C_5^1·C_5^1 - C_2^1·C_2^1 }{ C_5^1·C_5^1 } = \\frac{21}{25}$\n\n\t- $P(B_2) = \\frac{ C_5^1·C_4^1 - C_2^1·C_1^1 }{ C_5^1·C_4^1 } = \\frac{9}{10}$\n\n\t- 通过 `对立事件思想` 解题，先求 $\\overline{B_3}$ = {任取两球全黑} 的概率：\n\n\t$$\n\tP(\\overline{B_3}) = \\frac{ C_2^2 }{ C_5^2 } = \\frac{1}{10} \\\\\n\tP(B_3) = 1 - P(\\overline{B_3}) = \\frac{9}{10}\n\t$$\n\t\n- 我们注意到，$P${先后无放回取，至少一白球} 等于 $P${任取两球，至少一白球} 的概率，即 $P(B_2) = P(B_3)$。\n\t- `得出结论`：`P{先后无放回} = P{任取}`\n\t- `证明方式`：分别用 `先后无放回取两球` 的方式和 `任取两球` 的方式，求 `P{两球全黑}`，再通过 `1 - P{两球全黑}` 求 `P{至少一白球}`： \n\n\t\t$$\n\t\tp(\\text{先后无放回取得两球全黑}) = \n\t\t    \\frac{ C_2^1·C_1^1 }{ C_5^1·C_4^1 } = \\frac{1}{10} \\\\\n\t\tp(\\text{任取两球全黑}) =\n\t\t    \\frac{ C_2^2 }{ C_5^2 } = \\frac{1}{10}\n\t\t$$\n\t\n\t\t当然，任取涉及先后顺序问题，应该对任取结果作排列，但由于上下同乘一种顺序故可略去。\n\t\n\t\t$$\n\t\t\\require{cancel}\n\t\tp(\\text{任取两球全黑}) =\n\t\t    \\frac{ C_2^2·\\bcancel{A_2^2} }{ C_5^2 ·\\bcancel{A_2^2} } = \\frac{1}{10}\n\t\t$$\n\t\t\t\n\t- 通过此结论，计算 `先后无放回` 抽取问题会有很大帮助。例如，从 100 个球中，先后无放回取 40 个球，则可理解为 `一把抓 40 个球`。\n\n##### 例题三\n- [题目] 袋有 100 个球，40 白 60 黑：\n\t- 先后 `无放回` 取 20 个球，求 $C_1$ = {15 白 5 黑}\n\t- 先后 `无放回` 取 20 个球，求 $C_2$ = {第 20 次取到白球}\n\t- 先后 `有放回` 取 20 个球，求 $C_3$ = {15 白 5 黑}\n\t- 先后 `有放回` 取 20 个球，求 $C_4$ = {第 20 次取到白球}\n- [分析] 根据例题二的结论，无放回抽取可等同于任意抽取。\n\t- $P(C_1) = \\frac{ C_{40}^{15}·C_{60}^5 }{ C_{100}^{20} }$\n\n\t- $P(C_2) = \\frac{C_{40}^1·99!}{100!} = \\frac{40}{100}$ \n\n\t\t- 1) 利用 `抓阄模型` 进行解题。即在本题中可理解为：袋中装有 100 个“灰球”，按概率摸球，则有 40% 可能摸到白球，60% 可能摸到黑球。\n\t\t- 2) 在本题中，我们可把 100 个球想象成 100 个位置，从左往右排列，位置与次数匹配。例如，我们求第 20 次取到白球的概率，即往 20 的位置只考虑放入白球的情况，剩余位置自由排列即可，故有 $C_{40}^1·99!$。\n\n\t\t![图1-1抓阄模型演示](/images/illustration/Reading/2018/10/probability-and-statistics_1-1.png)\n\t\t<center>图1-1 抓阄模型演示</center>\n\n\t- $P(C_3) = C_{20}^{15}·(\\frac{40}{100})^{15}·(\\frac{60}{100})^5$\n\n\t\t- 符合二项分布，记取到白球的次数为 X (实验无非取到黑/白两种球)，则可根据公式求解：\n\t\t$$P\\{X = k\\} = C_n^k·p^k·(1-p)^{n-k}, k = 0, 1, 2, ..., n$$\n\n\t- $P(C_4) = \\frac{40}{100}$\n\n### 几何概型\n\n#### 概念梳理\n- 定义 $\\Omega$ 是一个可度量的几何区域，每个样本点的发生具有等可能性。即样本点落入 $\\Omega$ 中的某一可度量子区域 $A$ 的可能性大小与 $A$ 的 `几何度量` 成正比，而与 $A$ 的位置及形状无关。则称其为 `几何概型`，记作：\n\n\t$$\n\tP(A) = \\frac{ A 的测度 }{ \\Omega 的测度 }\n\t\\tag{5}\n\t$$\n\n#### 练习巩固\n##### 例题一\n- [题目] 假设我上午 8:00-9:00 时间段内进入教室：\n\t- 求 $A_1$ = {我在 8:30-9:00 时间段进教室} 的概率\n\t- 求 $A_2$ = {我恰好在 8:30 进入教室} 的概率\n- [分析] 如图 1-2 所示，设 8:00-9:00 的时间段为单位 1：\n\t- $P(A_1) = \\frac{ \\frac12 }{1} = \\frac12$\n\n\t- $P(A_2) = \\frac01 = 0$\n\n\t\t> 在 8:30 这一刻所占长度为 \"0\"，只是数据研究工具的缺陷，致使测不出来。所以 $P(A) = 0$ 并不能推导 $A_2$ 为不可能事件。\n\n\t![图1-2单位1长时间段](/images/illustration/Reading/2018/10/probability-and-statistics_1-2.png)\n\t<center>图1-2 单位 1 长时间段</center>\n\n##### 例题二\n- [题目] 君子有约，9:00-10:00 甲、乙在校门口见面，等 20 分钟即离开：\n\t- 求 $B$ = {甲、乙能见面} 的概率\n- [分析] 设甲出现的时间为 $x$，乙出现的时间为 $y$：\n\t- 则两方的时间差为 $|x - y| \\leq 20, 0 \\leq x \\leq 60, 0 \\leq y \\leq 60$\n\n\t![图1-3函数图像](/images/illustration/Reading/2018/10/probability-and-statistics_1-3.png)\n\t<center>图1-3  $|x - y| \\leq 20$ 的函数图像</center>\n\n\t- 根据上述函数的图像可得 $P(B) = \\frac{ \\int_A }{ \\int_\\Omega } = \\frac{ 1 - (\\frac{40}{60})^2 }{1} = \\frac59$\n\n##### 例题三\n- [题目] 在 (0, 1) 内随机取两个数，$P\\{两数之和小于 \\leq \\frac65\\}$\n- [解析] 由题意可得，则有：\n\n\t![图1-4函数图像](/images/illustration/Reading/2018/10/probability-and-statistics_1-4.png)\n\t<center>图1-4  $x + y \\leq \\frac65$ 的函数图像</center>\n\n\t$$P\\{ x + y < \\frac65\\} = \\frac{1 - \\frac45*\\frac45*\\frac12}{1} = \\frac{17}{25}$$\n\n### 重要公式求概率\n\n#### 概念梳理\n##### 对立事件\n$$\nP(A) = 1- P(\\overline{A})\n\\tag{6}\n$$\n\n##### 减法公式\n$$\nP(A - B) = P(A) - P(AB)\n\\tag{7}\n$$\n\n##### 加法公式\n\n- 一般情况 ( 通用公式 )：\n \n\t$$\n\tP(A + B) = P(A) + P(B) - P(AB)\n\t\\tag{9}\n\t$$\n\t\n\t$$\n\tP(A + B + C) = P(A) + P(B) + P(C) - P(AB) - P(AC) - P(BC) + P(ABC)\n\t$$\n\n- 若 $A_1, A_2, ..., A_n (n > 3)$ `两两互斥 (互不相容)`，则可得：\n\n\t$$\n\tP(A_1 + A_2 + ... + A_n) = \\sum_{i = 1}^n P(A_i)\n\t\\tag{6}\n\t$$\n\t\n- 若 $A_1, A_2, ..., A_n (n > 3)$  `相互独立`，则可得：\n\t\n\t$$\n\tP(A_1 + A_2 + ... + A_n) = 1 - P ( \\overline{A_1 + A_2 + ... + A_n} ) \\\\\n\t = 1 - P( \\overline{A_1}·\\overline{A_2}·...·\\overline{A_n} ) = 1 - \\prod_{i=1}^n P(\\overline{A_i})\n\t\\tag{10}\n\t$$\n\t\n\t- `相互独立`：设 $A_1, A_2, ..., A_n $，若对其中任意有限个 $A_{i_1}, A_{i_2}, ..., A_{i_k}$ 都有 $P(A_{i_1})·P(A_{i_2})·...·P(A_{i_k})$，则称 $A_1, A_2, ..., A_n $ 相互独立。  \n\t- `妇唱夫随`：$n$ 个事件相互独立 $\\Longleftrightarrow$ 它们中任意一部分事件换成其各自的对立事件，所得的 $n$ 个新事件也是相互独立的。\n\n![图1-5上述公式图解](/images/illustration/Reading/2018/10/probability-and-statistics_1-5.png)\n<center>图 1-5 上述公式图解</center>\n\n##### 条件概率公式\n> 标志性词汇：已知...，当...发生了。\n\n$$\nP(A | B) = \\frac{ P(AB) } { P(B) }, P(B) > 0\n\\tag{11}\n$$\n\t\n##### 乘法公式\n$$\nP(AB) = P(A | B)·P(B) \\\\\nP(AB) = P(B | A)·P(A)\n\\tag{12}\n$$\n\t\n一般地，推广至 $P(A_1A_2...A_n)$：\n\n$$\nP(A_1A_2...A_n) = \\\\\nP(A_n | A_1A_2...A_{n-1})·P(A_{n-1} | A_1A_2...A_{n-2})·...P(A_2 | A_1)·P(A_1)\n\\tag{13}\n$$\n\t\n##### 全集分解公式\n> 也称 `全概率公式`，已知第一阶段，求第二阶段。\n\t\n- 引例：设一个村子和三个小偷，小偷分别为 $A_1、A_2、A_3$，B = {村子失窃}\n\t- 阶段 (I). 什么人去偷：$A_1, A_2, A_3$\n\t\n\t- 阶段 (II). 村子失窃，各小偷去偷的概率：$P(B | A_1) = 0, P(B | A_2) = \\frac12, P(B | A_3) = 1$\n\n\t- 则村子失窃的概率：\n\t\n\t\t$$P(B) = P(A_1)·P(B | A_1) + P(A_2)·P(B | A_2) + P(A_3)·P(B | A_3) \\\\\n\t\t= \\frac13 * 0 + \\frac13 * \\frac12 + \\frac13 * 1 = \\frac12\n\t\t$$\n\t\n- 定义与公式，设一随机事件 $E$ 可分两个阶段：\n\t- 阶段 (I) $\\bigcup_{i = 1}^n A_i = \\Omega, A_iA_j = \\emptyset (两两互斥), i \\neq j$，则称 $A_1, A_1,..., A_n$ 为 $\\Omega$ 的一个划分，也叫 `完备事件组`。\n\t- 阶段 (II) 事件 $B$ 发生的概率：\n\t\t- $P(B\\Omega) = P(B·(\\bigcup_{i = 1}^n A_i) )$ 为全集分解过程。\n\t\t- $B$ 为第 (II) 阶段，$A_i$ 为第 (I) 阶段。\n\n\t\t$$\n\t\tP(B) = P(B\\Omega) = P(B·(\\bigcup_{i = 1}^n A_i) ) = P( B\\bigcap(A_1 + A_2 + ... + A_n) ) \\\\\n\t\t= P(BA_1 + BA_2 + ... + BA_n) = \\sum_{i = 1}^n P(BA_i) \\\\\n\t\t= \\sum_{i = 1}^n P(B | A_i)·P(A_i)\n\t\t\\tag{13}\n\t\t$$\n\n##### 贝叶斯\n> 也称 `逆概率公式`，已知第二阶段反推第一阶段 ( 执果索因 )。\n\n- 设一随机事件 $E$ 分成两个阶段：\n\t- 阶段 (I) $\\bigcup_{j = 1}^n A_j = \\Omega, A_iA_j = \\emptyset (两两互斥), j \\neq i$，则称 $A_1, A_1,..., A_n$ 为 $\\Omega$ 的一个划分，也叫 `完备事件组`。\n\t- 阶段 (II) 已知 $B$ 发生了，求 $P(A_j | B)$：\n\t\t- $P(B | A_j)$ 是已知的。\n\t\t- 一个事件分两个阶段，考虑全概率公式。\n\n\t\t$$\n\t\tP(A_j | B) = \\frac{ P(A_jB) }{ P(B) }\n\t\t= \\frac{\n\t\t    P(B | A_j)·P(A_j)\n\t\t}{\n\t\t    \\sum_{i = 1}^n P(B | A_i)·P(A_i)\n\t\t}\n\t\t\\tag{14}\n\t\t$$\n \n#### 练习巩固\n##### 例题一\n- [题目] 有甲、乙两名射击手，轮流独立射击打靶，甲命中的概率为 $\\alpha$，乙命中的概率为 $\\beta$。甲先射击，谁先命中谁获胜，求 $P$ = {甲获胜} 的概率。\n- [分析] 记 $A_i = \\{第 i 次命中\\}, i = 1, 2, ...$，则有：\n\n\t- 根据独立互斥条件，结合题意可得：\n\n\t$$\n\tP\\{甲获胜\\} = P\\{ A_1 + \\overline A_1 \\overline A_2 A_3 + \\overline A_1 \\overline A_2 \\overline A_3 \\overline A_4 A_5 + ... \\}\n\t= P(A_1) + P(\\overline A_1 \\overline A_2 A_3) + P(\\overline A_1 \\overline A_2 \\overline A_3 \\overline A_4 A_5) + ... \\\\\n\t= P(A_1) + P(\\overline A_1)P(\\overline A_2)P(A_3) + P(\\overline A_1)P(\\overline A_2)P(\\overline A_3)P(\\overline A_4)P(A_5) + ... \\\\\n\t= \\alpha + (1 - \\alpha)(1 - \\beta)\\alpha + (1 - \\alpha)^2(1 - \\beta)^2\\alpha + ... \\\\\n\t$$\n\t\n\t- 观察上述式子，我们可设公比 $q = (1 - \\alpha)(1 - \\beta)$，则公式继续往下推演：\n\n\t$$\n\t\\int_n^{\\infty} \\alpha + \\alpha q + \\alpha q^2 + ... + \\alpha q^{n-1}\n\t= \\int_n^{\\infty} \\frac{\\alpha (1 - q^n)}{1 - q}\n\t= \\frac{a}{1 - q} = \\frac{a}{1 - (1 - \\alpha)(1 - \\beta)}\n\t$$\n\t\n- [注意] $P$ = {甲获胜} 的概率：\n\n\t$$\n\tP\\{乙获胜\\} = 1 - P\\{甲获胜\\} = \\frac{\\beta (1 - \\alpha)}{1 - (1 - \\alpha)(1 - \\beta)}\n\t$$\n\t\n\t若 $\\alpha = \\beta = p$，则有：\n\t\n\t$$\n\tP\\{甲获胜\\}  = \\frac{p}{1 - (1 - p)^2}, 令 \\, p + q = 1, \\, \n\t= \\frac{p}{1-q^2} = \\frac{p}{(1 + q)(1 - q)} = \\frac{1}{1 + q} \\\\\n\tP\\{乙获胜\\} = 1 - P\\{甲获胜\\} = \\frac{q}{1 + q}\n\t$$\n\t\n\t由此可见，**先下手为强**。即谁先射击，谁的胜率高。\n\n##### 题目二\n- [题目] 某彩票每周开奖一次，中奖概率为十万分之一，且每周开奖相互独立。某人每周买一次，坚持十年 ( 每年 52 周 )，则求 $P$ = {此人从未中奖} 的概率。\n- [分析] 记 $A_i = \\{第 i 次中奖\\}, \\, i. = 1, 2, ... 52, 且 \\, p = 10^{-5}$，则有：\n\n\t$$\n\tP\\{此人从未中奖\\} = \n\tP\\{ \\overline A_1 \\overline A_2 ... \\overline A_{52} \\} = \n\t(1 - 10^{-5})^{52} = 0.9948\n\t$$\n\t\n\t由此可见，**天上是不会平白无故掉馅饼**。\n\n##### 题目三\n- 10 份报名表， 3 女 7 男，先后无放回抽取，则:\n\t- (1) $A_1$ = {第三次取到女的报名表} 的概率\n\t- (2) $A_2$ = {第三次才取到女的报名表} 的概率\n\t- (3) $A_3$ = {已知前两次均取到男，第三次才取到女} 的概率\n\n- [分析] \n\t- (1) 由题意可知，利用 `抓阄模型` 进行解题，即使用 `绝对概率` 求解：\n\n\t\t$$\n\t\tP(A_1) = \\frac{C_3^1 9!}{10!} = \\frac{3}{10}\n\t\t$$\n\t\t\n\t- (2) 由题意可知，使用 `积事件概率` 求解：\n\n\t\t$$\n\t\t记 A_i = \\{第 i 次取到女的报名表\\}, \\,  i = 1,2, ... \\\\\n\t\t则 P(A_2) = P(\\overline A_1 \\overline A_2 A_3) = \n\t\tP(A_3 | \\overline A_1 \\overline A_2 )P(A_2 | \\overline A_1 )P(A_1)\n\t\t\\\\ = \\frac{3}{8} * \\frac{6}{9} * \\frac{7}{10}= \\frac{7}{40}\n\t\t$$\n\t\t\n\t- (3) 由题意可知，使用 `条件概率` 求解：\n\n\t\t$$\n\t\tP(A_3) = P(A_3 | \\overline A_1 \\overline A_2) = \\frac38\n\t\t$$\n\n##### 题目四\n- [题目] 设两批数量相同的零件，有一批全部合格，另一批 25% 不合格，75% 合格。从两批产品中任取一件，经检验为合格品，放回原处，并从该处再取一件，求这一件为不合格的概率。\n\n- [分析] 从两批零件中取得不合格的事件，可分为两个阶段：\n\t- (Ⅰ) 选批次：第一批记作 $H_1$，第二批记作 $H_2$。\n\t- (Ⅱ) 取零件：合格记作 $A$，不合格记作 $\\overline A$。\n\n\t\t由题意可知， $P(H_1) = P(H_2) = \\frac12, P(A | H_1) = 1, P(A | H_2) = \\frac34$\n\t\t\n\t\t首先，从两批产品中任取一件零件为合格品的概率，由全概率公式求得：\n\t\t\n\t\t$$\n\t\tP(A) = P(A \\Omega) = P(A | H_1)P(H_1) + P(A | H_2)P(H_2) = \\frac78\n\t\t$$\n\t\t\n\t\t再者，执因索果，已知第一次所取零件为合格品，则选自第一批、第二批的概率由贝叶斯公式可得：\n\t\t\n\t\t$$\n\t\tP(H_1 | A) =\n\t\t\\frac{P(AH_1)}{P(A)} = \\frac{P(A | H_1)P(H_1)}{\\frac78} = \\frac47 \\\\\n\t\tP(H_2 | A) = \n\t\t\\frac{P(AH_2)}{P(A)} = \\frac{P(A | H_2)P(H_2)}{\\frac78} = \\frac37\n\t\t$$\n\t\t\n\t\t于是，设 $C_i = \\{第二次是从第 i 批中取得零件的\\}, i = 1, 2$，则有：\n\t\t\n\t\t$$\n\t\tP(C_1) = P(H_1 | A) = \\frac47, \\, P(C_2) = P(H_2 | A) = \\frac37 \\\\\n\t\t$$\n\t\t\n\t\t则第二次从该处取得不合格零件的概率为：\n\t\t\n\t\t$$\n\t\tP(\\overline A) =\n\t\tP(\\overline A | C_1)P(C_1) + P(\\overline A | C_2)P(C_2) = \n\t\t0 * \\frac47 + \\frac14 * \\frac 37 = \\frac{3}{28}\n\t\t$$\n\n##### 题目五\n- [题目] 设有两箱同种零件，第一箱 50 件，10 件一等品；第二箱 30 件，18 件一等品。先从中随机挑出一箱，再从该箱中先后无放回取出两个零件，求：\n\t- (1) $P$ = {第一次取到一等品} 的概率\n\t- (2) $Q$ = {在第一次取出的是一等品的条件下，第二次仍取到一等品} 的概率\n- [分析] 从两箱中取得一等品零件的事件，可分为两个阶段：\n\t- (Ⅰ) 选箱子：第一箱记作 $H_1$，第二箱记作 $H_2$。\n\t- (Ⅱ) 取零件：第一次取到一等品记作 $B_1$，第二次取到一等品记作  $B_2$。\n\n\t\t由题意可知， $P(H_1) = P(H_2) = \\frac12, P(B_1 | H_1) = \\frac{10}{50}, P(B_1 | H_2) = \\frac{18}{30}$\n\t\t\n\t\t(1) 由此可得，$P$ = {第一次取到一等品} 的概率为：\n\n\t\t$$\n\t\tP = P(B_1\\Omega) = P(B_1 | H_1)P(H_1) + P(B_1 | H_2)P(H_2) = \n\t\t\\frac{10}{50} * \\frac12 + \\frac{18}{30} * \\frac12 = \\frac{4}{10}\n\t\t$$\n\t\t\n\t\t(2) 依题意，可使用条件概率公式求 $P$ = {在第一次取出是一等品的条件下，第二次仍取到一等品}：\n\t\t\n\t\t$$\n\t\tP(B_2 | B_1) = \\frac{P(B_1B_2)}{P(B_1)} = \n\t\t\\frac{ P(B_1B_2 | H_1)P(H_1) + P(B_1B_2 | H_2)P(H_2) }{\\frac{4}{10}} \\\\\n\t\t= \\frac{10}{4} * (\n\t\t\t\\frac{10}{50} * \\frac{9}{49} * \\frac12 + \n\t\t\t\\frac{18}{30} * \\frac{17}{29} * \\frac12\n\t\t) = 0.486\n\t\t$$\n\t\t\n\t\t当然，也可以参照例题四的思路解题 ( 贝叶斯 )：\n\t\t\n\t\t$$\n\t\tP(H_1 | B_1) = \\frac{ P(B_1 | H_1)P(H_1)}{P(B_1)} = \n\t\t\\frac{ \\frac{10}{50} * \\frac12 }{ \\frac{4}{10} } = \\frac{1}{4}\\\\\n\t\tP(H_1 | B_1) = \\frac{ P(B_1 | H_2)P(H_2)}{P(B_1)} = \n\t\t\\frac{ \\frac{18}{30} * \\frac12 }{ \\frac{4}{10} } = \\frac34 \\\\\n\t\tP(B_2 | B_1) = P(H_1 | B_1) * \\frac{9}{49} + P(H_2 | B_1) * \\frac{17}{29} = 0.486\n\t\t$$\n\n## 贰 如何求分布\n\n### 基本概念\n#### 随机变量\n#### 分布函数\n##### 离散型随机变量\n##### 连续型随机变量\n\n### 常见一维分布\n#### 两点分布\n#### 二项分布\n#### 几何分布\n#### 超几何分布\n#### 泊松分布\n#### 均匀分布\n#### 指数分布\n#### 正态分布\n\n### 一维随机变量及其分布函数\n\n### 二维随机变量及其分布函数\n\n## 叁 如何求数字特征\n\n### 数学期望\n### 方差\n### 协方差\n### 相关系数\n\n## 肆 如何使用极限定理\n\n### 依概率收敛\n\n### 极限定理\n#### 大数定律\n#### 中心极限定理\n\n## 伍 如何作估计\n\n### 总体与样本\n### 估计方法\n#### 矩估计\n#### 最大似然估计","tags":["数字特征"],"categories":["Reading"]},{"title":"笔记 | Python 3 入门系列教程","url":"%2F2018%2F09%2Flife-is-short-we-need-python.html","content":"\n- 本文章主要以黑马程序员的「[传智播客 Python 就业班 (ij6g)](https://pan.baidu.com/s/1oBnk19WfBWQ1Pwd7rNGixw)」、「 [Python 从入门到精通教程](https://www.bilibili.com/video/av14184325) 」和「 [廖雪峰的 Python 教程](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000) 」为主线，输出学习笔记，目的是检验自己的学习效果和日常复习之需。作为入门 Python 的参考资料，除了视频的基础内容外，文章还会补充视频中讲解不详细或遗漏的必要知识点。\n\n- 文章的内容和知识框架，与「廖雪峰的 Python 教程」和「传智播客的视频」大体保持一致：  \n\n\t文章以模块分块阐述：`Linux 基础`、`Python 基础`、`Python 面向对象`、`项目实战` ( 实战部分以爬虫、数据分析为主的项目实战 )。\n\n\t每个模块按知识点区分：  \n\t1) Linux 基础部分参考 `传智播客 Python 从入门到精通教程`；  \n\t2) Python 基础部分参考 `廖雪峰 Python 教程`；  \n\t3) 项目实践，即数据分析部分参考书籍 `利用 Python 进行数据分析` $^{[5]}$；  \n\n- 最后，正如 Bruce Eckel 所述 `Life is short, you need python`，Python 的高效只有切身体验才会深有体会，期待您早日加入 Python 队伍中来。\n\n<!-- More -->\n\n## 更新进度\n- 2018.09.03：完成初稿，且完成 Linux 基础部分的内容；\n- 2018.09.18：更新 Python 基础部分内容「语言基础、函数、高级特性」；\n- 2018.09.21：更新 Python 基础部分内容「函数式编程」；\n- 2018.10.10：更新 Python 基础部分内容「模块、面向对象编程」；\n- 2018.10.12：更新 Python 基础部分内容「面向对象高级编程」；\n- 2018.10.13：更新 Python 基础部分内容「错误/调试/测试」；\n- 2018.10.14：更新 Python 基础部分内容「面向 I/O 编程」；\n- 2018.11.05：更新 Python 基础部分内容「装饰器」；\n\n## 参考书目\n- `Python 基础`\n\t- 📖 | 埃里克·马瑟斯.《 Python 编程：从入门到实践 》：[豆瓣评分](https://book.douban.com/subject/26829016/)\n\t- 📖 | Albert Sweigart.《 Python 编程快速上手 》：[豆瓣评分](https://book.douban.com/subject/26836700/) \n- `Python 进阶`\n\t- 📖 | David M. Beazley / Brian K. Jones.《 Python Cookbook 》：[中文版](https://book.douban.com/subject/26381341/) | [英文版](https://book.douban.com/subject/20491078/)\n\t- 📖 | Luciano Ramalho. 《 Fluent Python 》：[中文版](https://book.douban.com/subject/27028517/) | [英文版](https://book.douban.com/subject/26278021/)\n- `Python 实践`\n\t- 📖 | Wes Mckinney.《 利用 Python 进行数据分析 》：[豆瓣评分](https://book.douban.com/subject/25779298/)\n\t- 📖 | Clinton W. Brownley.《 Python数据分析基础 》：[豆瓣评分](https://book.douban.com/subject/27100480/)\n\n## 教学资源\n- 📖 | 文章 | [廖雪峰. Python 3 教程. liaoxuefeng.com](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)\n- 📺 | 视频 | [黑马程序员. Python 从入门到精通教程. 2017. bilibili.com](https://www.bilibili.com/video/av14184325)\n- 📺 | 视频 | [传智播客. Python 就业班. 2017. BaiduCloud](https://pan.baidu.com/s/1oBnk19WfBWQ1Pwd7rNGixw) | Pwd: ij6g\n\n\t> 本文章的学习笔记是基于此系列教学视频所得的。\n\n## Linux 基础\n\n### Linux 常用终端命令\n> 仅列举一些项目中常用的命令。\n\n- LS 命令与通配符\n\t- `*`：代表任意个数个字符。\n\t- `?`：代表任意一个字符。\n\t- `[]`：表示可匹配字符组中任意一个。\n\t- `[abc]`：匹配 a、b、c 中的任意一个字符。\n\t- `[a-f]`：匹配从 a 到 f 范围内的任意一个字符。\n\n\t> 常使用 `ls -al` 显示当前文件目录所有文件的详细信息。\n\n- CD 命令与切换目录\n\t- 相对路径：最前面不是 `/` 或 `~`，表示相对 `当前目录` 所在的目录位置。\n\t- 绝对路径：最前面是 `/` 或 `~`，表示从 `根目录 / Home 目录` 开始的具体目录位置。\n\n\t\t```bash\n\t\t# 相对路径：返回上两级目录\n\t\tcd ../../ \n\t\t\n\t\t# 绝对路径：相当于 cd /Users/your username/\n\t\tcd ~\n\t\t```\n\t\t\n- Tree 命令：以树状结构显示文件目录结构，若 `tree -d` 则显示目录，不显示文件。\n\n- 查看文件内容\n\t- `cat 文件名`：查看文件内容、创建文件、文件合并、追加文件内容等功能。\n\t- `more 文件名`：分屏显示文件内容。\n\t- `grep 搜索文本的文件名`：搜索文件文件内容。\n\t\t- 例如搜索包含单词 “hello” 的文本，即 `grep \"hello\" sample.txt`。\n\t\t- 选项参数：`-n` 显示匹配行号；`-v` 显示不包含匹配文本的所有行；`-i` 忽略大小写。\n\n- Echo 命令与重定向\n\t- `echo` 命令：在终端中显示参数指定的文字。\n\t- 重定向 `>` 和 `>>`：\n\t\t- `>` 表示输出，会覆盖文件原有内容。\n\t\t- `>>` 表示追加，会将内容追加到已有文件的末尾。\n\t- `echo` 命令常结合 `重定向` 使用：\n\n\t\t```bash\n\t\t# 将字符串 \"Hello World\" 追加到\n\t\techo \"Hello World\" >> sample.txt\n\t\t```\n\t\t\n- 管道符 `|`\n\t- Linux 允许将一个命令的输出通过管道作为另一个命令的输入。\n\t- ls 命令与 grep 命令的结合使用，如从 Home 目录下搜索包含 \"python\" 关键字的文件或者文件夹：\n\n\t\t```bash\n\t\t# 从 Home 目录下搜索包含 \"python\" 关键字的文件或者文件夹\n\t\tls -al ~ | grep python\n\t\t```\n\t\n- Ifconfig 命令与 Ping 命令\n\t- `ifconfig` 命令可查看/配置计算机当前的网卡配置。\n\t- `ping` 命令一般用于检测当前计算机到目标计算机之间的网络是否畅通。\n\n\t\t```bash\n\t\t# 快速查看网卡对应的 IP 地址\n\t\tifconfig | grep inet\n\t\t```\n\n### 远程登录和复制文件\n\n#### 远程登录\n- 远程登录即通过 `SSH 客户端` 连接运行了 `SSH 服务器` 的远程机器上。\n- SSH 是目前较可靠，专为 `远程登录会话` 和 `其他网络服务` 提供安全性协议。\n\t- 有效防止远程管理过程中的信息泄露。\n\t- 对所有传输的数据进行加密，也能防止 DNS 欺骗和 IP 欺骗。\n- SSH 客户端是一种使用 `Secure Shell` 协议连接到远程计算机的软件程序。\n- SSH 客户端简单使用访问服务器：`ssh [-p port] user@remote`\n\t- `user` 是远程机器上的用户名。\n\t- `remote` 是远程机器地址，可为 IP、域名或别名。\n\t- `port` 是 SSH 服务器监听的端口，若不指定端口默认为 22。\n\n#### 复制文件\n- SCP 即 `Secure Copy`，是一个在 Linux 下用来进行 `远程拷贝文件` 的命令。\n\n\t```bash\n\t# 从本地复制文件到远程机器桌面上\n\tscp -P sample.py user@remote:Desktop/sample.py\n\t\n\t# 从远程机器桌面上复制文件夹到本地上\n\tscp -P port -r user@remote:Desktop/sample ~/Desktop/sample\n\t```\n\n#### SSH 高级用法\n\n##### 免密码登录\n免密码登录：即客户端访问服务端时，需要密码验证身份登录。\n\n- Step.01. 配置公钥：执行 `ssh-keygen` 即生成 SSH 密钥。\n- Step.02. 上传公钥到服务器：执行 `ssh-copy-id -p port user@remote`，让远程服务器记住我们的 `公钥`。\n\t\n\t> 1) 有关 SSH 配置信息都保存在 `/Home/your username/.ssh` 目录下。  \n\t> 2) 免密登录使用的是非对称加密算法 ( RSA )，即使用公钥加密的数据，需要使用私钥解密；使用私钥加密的数据，需要使用公钥解密。若有兴趣了解 `RSA 算法` 的原理及计算，可参考引用文章 [1]、[2]。\n\t\t\n\t![图5-2-1免密码登录实现原理图](/images/illustration/Programme/2018/09/life-is-short-we-need-python_5-2-1.png)\n\t<center>图 5-2-1 免密码登录实现原理图</center>\n\t\t\n##### 配置别名\n配置别名：每次输入 `ssh -p port user@remote` 是非常繁琐重复的工作，配置别名的方式以替代上述这么一串命令代码。\n\n- 在 `/.ssh/config` 文件下追加以下内容 ( 需建立 Config 文件 )：\n\n\t```vim\n\tHost mac\n\tHostName 192.168.10.1\n\tUser user\n\tPort 22\n\t```\n\t\n- 命令输入 `ssh mac` 即可实现远程登录操作 ( SCP 同样原理 )。\n\n\t```bash\n\t# 若配置别名后，待验证命令的格式:\n\t# 是否为: scp -r ~/Desktop/Sample mac:Desktop/Sample\n\t# 还是: scp -P 22 -r ~/Desktop/Sample mac:Desktop/Sample\n\t```\n\n### 用户和权限\n\n#### 基本概念\n- 在 Linux 中，可指定每一用户针对不同的文件或者目录的不同权限。\n- 对文件 / 目录包含的权限有：\n\n<center>表 5-3-1 文件/目录权限属性说明</center>\n\n| 权限 | 英文 | 缩写 | 数字代号 |\n| :---: | :---: | :---: | :---: |\n| 读 | read | r | 4 |\n| 写 | write | w | 2 |\n| 执行 | excute | x | 1 |\n\t\n#### 组\n- 为方便用户管理，提出组的概念。在实际开发中，可预先针对组设置好权限，然后将不同的用户添加到对应组中，从而不用依次为每个用户设置权限。\n\n| 权限名称 | 权限参数 | 说明 |\n| :---: | :---: | :---: |\n| user | u | 文件的拥有者，一般指当前用户 |\n| group | g | 文件所属的群组 |\n| other | o | 其他用户 |\n\n#### LL 命令\n- LL 命令即 LS 命令的扩展用法 `ls -al`。\n- LL 命令可查看文件夹下文件的详细信息，从左往右依次是：\n\t- 权限：第一个字符是 `d`，表示目录；`-` 表示文件；\n\t- 硬链接数：通俗理解即有多少种方式可访问到当前目录 / 文件；\n\t- 拥有者：当前用户；\n\t- 组：当前用户所属的组；\n\t- 文件大小，修改时间，文件 / 目录名称.\n\n<center>表 5-3-2 \"ls -al\" 查看文件的权限信息说明</center>\n\n| 目录 | 拥有者权限 | 组权限 | 其他用户权限 | 备注 |\n| :---: | :---: | :---: | :---: | :---: |\n| - | r w - |  r w -  |  r - -  | 文件权限示例 |\n| d |  r w x | r w x | r - x | 目录权限示例 |\n\n#### Chmod 命令\n- Chmod 命令：可修改 `用户/组` 对 `文件/目录` 的权限。\n\n\t```bash\n\t# 一次性修改拥有者/组的权限\n\tchmod +/-rwx 文件名/目录名\n\t# 一次性定制给某拥有者/组赋予某文件或者目录权限\n\t# 给予当前用户及所属群组对于该文件可读、可写、可执行权限\n\tchmod ug=rwx 文件名\n\t# 给予当前用户及所属群组对于该目录下所有文件可读、可写、可执行权限\n\tchmod ug=rwx -R 目录名\n\t```\n\n#### Sudo 命令\n- Sudo 命令：使用预设 ( root, 系统管理员 ) 的身份来执行命令。\n\n\t> Linux 系统中，通常使用标准用户登录及使用系统，通常 `sudo` 命令临时获得权限用于系统的维护与和管理。在执行一些模块的安装过程或者配置过程中，你会经常用到它的。\n\t\n### 系统信息相关命令\n- 查询时间和日期\n\t- `date`：查看系统时间。\n\t- `cal`：查看当月日历，`cal -y` 查看当年的日历。\n- 磁盘和目录空间\n\t- df：`df -h`，Disk Free 显示磁盘剩余空间。\n\t- du：`du -h`，Disk Usage 显示目录下的文件大小。\n- 进程信息\n\t- ps：`ps aux`，即 Process Status，查看进程的详细状况。\n\t- top：动态显示运行中的进程并排序。\n\t- kill：`kill [-9] 进程代号`，`-9` 表示强行终止，终止指定代号的进程。\n\n\t\t> 使用 `kill` 命令时，最好终止当前用户开启的进程，而不是终止 `root` 身份开启的进程。\n\t\t\n### 其他终端命令\n\n#### 查找文件\n查找文件：`find` 命令功能非常强大，通常在特定目录下搜索符合条件的文件。\n\n- 若省略路径，表示在当前文件夹下查找。\n- `find` 命令可结合 `通配符` 一起使用。\n\n\t```bash\n\tfind [路径] -name \"*.py\"\n\t```\n\t\n#### 软链接\n软链接：建立文件的软链接，通俗理解即 PC/MacOS 上的 `快捷方式`。\n\n- 源文件要使用绝对路径，即便于移动链接文件 (快捷方式) 仍能正常使用。\n- 没有 `-s` 选项是建立一个硬链接文件。\n\n\t```bash\n\tln -s 被链接的源文件 快捷方式的名称\n\t```\n\t\n- 在 Linux 中，文件名和文件的数据是分开储存的。\n\n\t![图5-5-1软、硬链接访问文件数据](/images/illustration/Programme/2018/09/life-is-short-we-need-python_5-5-1.png)\n\t<center>图 5-5-1 软、硬链接访问文件数据</center>\n\n#### 打包压缩\n- `tar` 是 Linux 中最常用的备份工具 ( **打包并不压缩** )，其命令格式如下：\n\n\t```bash\n\t# 选项 c：生成档案文件 (.tar)\n\t# 选项 x：解开档案文件\n\t# 选项 v：列出归档/解档的详细过程，显示进程\n\t# 选项 f：指定档案文件名称，选项 f 后应该紧跟 .tar 文件\n\t\n\t# 打包文件：打包放于同一目录下\n\ttar -cvf 打包文件.tar. 被打包文件路径\n\t\n\t# 解包文件\n\ttar - xvf 打包文件 [-C 目标路径]\n\t```\n\t\n- `tar` 与 `gzip` 命令结合可实现文件 `打包和压缩`，即 `tar` 只负责打包文件， `gzip` 负责压缩文件。\n\n\t```bash\n\t# 压缩文件：压缩文件放于同一目录下\n\ttar - zcvf 打包文件.tar.gz 被压缩文件路径\n\t\n\t# 解压缩文件\n\ttar -zxvf 打包文件.tar.gz\n\t\n\t# 解压缩文件到指定路径\n\ttar -zxvf 打包文件.tar.gz [-C 目标路径]\n\t```\n\n\t\t\n## Python 基础\n\n### 引入\n\n#### Python 优缺点\n- Python 是面向对象 / 过程的语言 ( 对象和过程语言各有自己的优缺点 )：\n\t- 面向对象：由 `数据` 和 `功能组合而成的对象` 构建而成的程序。\n\t- 面向过程：由 `过程` 或仅仅是 `可重用代码` 构建起来的程序。\n\n#### Python 应用场景\n- Web 端程序：\n\t- mod_wsgi 模块：Apache 可运行用 Python 编写 Web 程序。\n\t- 常见 Web 框架：Django、TurboGears、Web2py、Zope 等。\n- 操作系统管理：服务器运维的自动化脚本。\n- 科学计算：NumPy、SciPy、Matplotlib 等。\n- 桌面端程序：PyQt、PySide、wxPython、PyGTK 等。\n- 服务端程序：Twisted ( 支持异步网络编程和多数标准的网络协议，包括客户端和服务端 )。\n\n#### Python 解释器\n- 当我们编写 Python 代码时，我们得到的是一个包含 Python 代码的以 `.py` 为扩展名的文本文件。要运行代码，就需要 Python 解释器去执行 `xxx.py` 文件。\n\n- CPython  \n\t- 当我们从 Python [官方网站下载](https://www.python.org/downloads/) 并安装好 Python 3.x 后，我们就直接获得了一个官方版本的解释器：`CPython` ( C 语言开发的 )。\n\t- 在命令行下运行  `python` 就是启动 CPython 解释器。\n\n- iPython   \n\t- iPython 是基于 CPython 之上的一个交互式解释器，即 iPython 只是在交互方式上有所增强，但是执行 Python 代码的功能和 CPython 是完全一样的。\n\t- 在命令行下运行  `ipython` 即可启动 iPython 交互式解释器。\n\t- CPython 用 `>>>` 作为提示符，而 IPython 用 `In [序号]:` 作为提示符。\n\n\t![图6-1-1Python与iPython提示符表现形式](/images/illustration/Programme/2018/09/life-is-short-we-need-python_6-1-1.jpg)\n\t<center>图 6-1-1 Python 与 iPython 提示符表现形式</center>\n\t\n- PyCharm\n\n\t工欲善其事，必先利其器。为帮助开发者更便捷、更高效来开发 Python 程序，一款集成开发编辑器 ( IDE ) 显得格外重要。IDE 除了快捷键、插件外，重要的是它还支持 `调试程序`。\n\n\t> 当然，支持 Python 程序开发的 IDE 还有很多优秀的产品：如：[Eclipse with PyDev](http://marketplace.eclipse.org/content/pydev-python-ide-eclipse)\n\t\n#### 第一个程序\n\n- 新建并运行 python 程序：`vi python_sample.py` 开始编写程序；通过 `python python_sample.py` 执行程序。以下为简单的 Python 示例：\n\n\t```bash\n\t# 声明部分\n\t# 取机器 Path 中指定的第一个 python 来执行脚本\n\t#!/usr/bin/env python\n\t# python.py 文件中包含中文字符，Python2 在文件头加入以下语句 ( Python3 是默认支持的 )：\n\t# -*- coding=utf-8 -*-\t\n\t\n\t# 代码部分\n\tprint(\"Life is short, you need python.\")\n\t\n\ta = 100\n\tA = 200\n\t\n\tif a >= 100: # 冒号 \":\" 结尾，缩进的语句即为代码块\n\t    print(a)\n\telse:\n\t    print(-A) # Python 是大小写敏感的\t\n\t```\n\n### 语言基础\n\n#### 注释\n- 行注释、块注释：行注释的风格与 Linux 中 Shell 脚本的注释相同，即以 `#` 开头的注释；块注释使用三个单引号 `'` 或三个双引号 `\"` 包裹实现。\n\n\t```python\n\t# 行注释\n\t# line 1...\n\t# line 2...\n\t\n\t'''\n\t' 单引号块注释\n\t' line 1\n\t' line 2\n\t'''\n\t\n\t\"\"\"\n\t\" 双引号块注释\n\t\" line 1\n\t\" line 2\n\t\"\"\"\n\t```\n\n#### 数据类型\n- `整型`：可处理 `任意大小` 的整数，当然包括 `负整数`。例如 0，1，100，-8080 等。\n- `浮点型`：即含有小数点的数，如 1.23，1.23e9 ( 1.23x10$^9$ )，1.23e-5 ( 1.23x10$^{-5}$ )\n\n\t> 1) 整数和浮点数在计算机内部存储的方式是不同的；  \n\t> 2) 整数运算永远是精确的，而浮点数运算则可能会有四舍五入的误差。\n\t\n- `字符型`：以单引号 `' ` 或双引号 `\"` ( 表示方式不同而已 ) 括起来的任意文本。例如 `'(1+2)\\%3 == 0'`，或者 `\"The 'a' is a lowercase letter of 'A'\"`。\n- `布尔型`：True / Flase 两种值。\n\t- 布尔运算：and、or、not，例如 `(3 > 2) and (1 > 2)`，输出 Flase。\n- `空值`：None，注意 None 不能理解为 0，因为 0 是有意义的，而 None 是一个特殊的空值。\n\n> Python 中的数据类型是没有大小限制的，若想定义无限大，可定义为无限大，即 `inf`。\n\n#### 常量变量\n\n##### 常量\n- 常量：例如定义 `PI = 3.14159`，其实际也是变量，只是约定俗成罢了。\n\n##### 变量\n- 形如 `param = value` 的形式赋予变量值，但不用赋变量数据类型。\n- 变量的输入与输出：\n\n\t```python\n\thigh = int( input(Please enter your high:) )\n\t# input() 默认输出 String 类型\n\tprint(\"Your high is: %d\" % high);\n\t```\n\n#### 字符编码\n- 一个字节，表示的最大的整数就是 255，即十进制为 255，二进制为 `11111111`。若想表示更大的整数则需要更多的字节。\n- `ASCII`：127 个字符编码，即大小写字母、数字和一些特殊字符。例如大些字母 A，对应的 ASCII 为 65。\n\n\t> 但处理中文显然一个字节是不够的 ( 至少两个字节 )，且还不能与 ASCII 编码冲突，所以中国制定了`GB2312` 编码。  \n\t>\n\t> 然而，世界有上百种语言，日本把日文编到 `Shift_JIS` 里，韩国把韩文编到 `Euc-kr` 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。   \n\t>\n\t> 因此，Unicode 应运而生 $^{[3]}$。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。\n\t\n- `Unicode`：2 字节及以上。\n\n\t> 为节约空间，把 Unicode 编码转化为“可变长编码”的 UTF-8 编码。\n\t\n- `UTF-8`：根据数字大小编写 1 ~ 6 字节，英文字母 1 字节，汉字 3 字节 ( 生僻字符用到 4 ~ 6 字节 )。\n\n- ACSII、Unicode 与 UTF-8 的关系\n\n<center>表 6-2-1 ACSII、Unicode 与 UTF-8 的关系</center>\n\n| 字符 | ASCII | Unicode | UTF-8 |\n| :---: | :---: | :---: | :---: |\n| A | 0100 0001 | 00000000 01000001 | 01000001 |\n| 中 | -- | 01001110 00101101 | 11100100 10111000 1010 1101 |\n\n- 启示：计算机系统通用的字符编码工作方式，如图 6-2-1 所示。\n\t- 用记事本编辑时，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，当保存的时再把 Unicode 转换为 UTF-8 保存到文件；\n\t- 浏览网页时，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器。\n\n\t![图6-2-1计算机系统通用的字符编码工作方式](/images/illustration/Programme/2018/09/life-is-short-we-need-python_6-2-1.png)\n\t<center>图 6-2-1 计算机系统通用的字符编码工作方式</center>\n\t\n#### 字符串/列表/元组/字典\n\n##### 字符串 Str\n- Python 3 中，字符串是以 Unicode 编码的。\n\t- Python 的字符串类型为 String，内存中以 Unicode 表示。若在网络中传输，则可以把 string 类型的数据变成以字节为单位的 `bytes`。\n\t- `encode()` 与 `decode()`：\n\t\t- 英文字符可用 ASCII 编码 Bytes，即 `\"ABC\".encode(\"ascii\")`。\n\t\t- 中文字符可用 UTF-8 编码，即 `\"中国\".encode(\"utf-8\")`。\n\n\t\t> 含有中文的 str 无法用 ASCII 编码，因中文编码的范围超过了 ASCII 编码的范围。强制编码会抛出异常：  \n\t\t> `'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)\n`。\n\t\t\n- 常用数据类型转换，见表 6-2-2 所示：\n\n<center>表 6-2-2 常用数据类型转换说明表</center>\n\n| 函数格式 | 使用示例 | 描述 |\n| --- | --- | --- |\n| int(x [,base]) | int(\"8\") 或 int('A', base = 16) | 可转换的包括 String 类型和其他数字类型，但高精度转换会丢失精度 |\n| float(x) | float(1) 或 float(\"1\") | 可转换 String 和其他数字类型，不足的位数用 0 补齐，例如 1 会变成 1.0 |\n| comple(real,imag) | complex(\"1\") 或 complex(1,2) | 第一个参数可以是 String 或者数字，第二个参数只能为数字类型，第二个参数没有时默认为 0 |\n| str(x) | str(1) | 将数字转化为 String |\n| repr(x) | repr(Object) | 返回一个对象的 String 格式 |\n| eval(str) | eval(\"12+23\") | 执行一个字符串表达式，返回计算的结果，如例子中返回 35 |\n| tuple(seq) | tuple((1,2,3,4)) | 参数可以是元组、列表或字典。若为字典时，返回字典的 key 组成的集合 |\n| list(s) | list((1,2,3,4)) | 将序列转变成一个列表，参数可为元组、字典、列表。若为字典时，返回字典的 key 组成的集合 |\n| set(s) | set(['b', 'r', 'u', 'o', 'n'])或者set(\"asdfg\") | 将一个可迭代对象转变为可变集合且去重复，返回结果可以用来计算差集 `x - y`、并集 `x l y`、交集 `x & y` |\n| frozenset(s) | frozenset([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) | 将一个可迭代对象转变成不可变集合，参数为元组、字典、列表等 |\n| chr(x) | chr(0x30) | chr() 用一个范围在 range (0～255) 内的整数作参数，返回一个对应的字符。返回值是当前整数对应的 ASCII 字符。 |\n| ord(x) | ord('a') | 返回对应的 ASCII 数值，或者 Unicode 数值 |\n| hex(x) | hex(12) | 把整数 x 转换为 16 进制字符串 |\n| oct(x) | oct(12) | 把整数 x 转换为 8 进制字符串 |\n\n- 字符串输入和输出：\n\n\t```python\n\tname = input(\"Enter your name:\")\n\tage = int( input(\"Enter your age:\") )\n\tprint(\"name: %s, age: %d\" % (name, age))\n\t```\n\t\n- 组成字符串的方式：\n\n\t```python\n\tstr1 = \"Hello\"\n\tstr2 = \"World\"\n\t\n\t# str3 组装成 \"HelloWorld\"\n\tstr3 = str1 + str2\n\t\n\t# 组装成 \"===HelloWorld===\"，此方式常用拼凑字符串\n\t\"===%s===\" % (str1 + str2)\n\t```\n\t\n- 字符串下标与取值：\n\n\t```python\n\tarray = \"ABCDE\"\n\t\n\tprint( array[0] ) # 输出 A\n\tprint( array[4] ) # 输出 E\n\tprint( array[-1] ) # 输出 E\n\t\n\t# 切片\n\tprint( array[0:3] ) # 输出 ABC\n\tprint( array[0:-1] ) # 输出 ABCD\n\tprint( array[0:] ) # 输出 ABCDE\n\t\n\t# 即以 2 为步进距离，从下标 0 开始取值至末尾，输出 ACE\n\tprint( array[0::2] )\n\t\n\t# 即以 -1 为步进距离，从末尾开始取值至开端，逆序输出\n\tprint( array[-1::-1] )\n\t```\n\t\n- 字符串常见操作\n\t- `find(s)` 与 `index(s)`：从目标字符串中寻找子串，找到会返回子串的起始下标；若找不到则返回 `-1`。index() 找到目标的情况和 find() 相同，找不到目标则会抛出异常。\n\n\t\t> 当然还有 rfind(s) 和 rindex()，即从右端开始寻找子字符串。\n\t\n\t- `count(str, start, end)`：即在目标字符串 `myStr`，求得 `str` 在位置 start 和 end 之间出现的次数。\n\n\t\t> 例如：`myStr.count(str, start = 0, end = len(myStr))`，\n\t\n\t- `replace(原始字符串, 目标字符串)` 或 `replace(原始字符串, 目标字符串，替代次数)`：\n\n\t\t> 例如：`myStr.replace(\"world\", \"python\")`\n\t\t\n\t- `split(str)`：根据 `str` 把原字符串切开。\n\t- `splitlines(str)`：将字符串中的每一行切割开来。\n\n\t\t> re.split(正则表达式, 目标字符串)，根据正则表达式切割字符。\n\n\t- `capitalize()` 与 `title()`：前者是把字符串中的第一个字符转为大写字母，后者是把字符串中每个单词的首字母转为大写。\n\t- `startsWith(str)` 与 `endsWith(str)`：前者是判断目标字符是否以字符串 str 开头，后者则是判断目标字符是否以字符串 str 结尾。\n\t- `lower()` 与 `upper()`：前者是将目标字符串全转为小写字母，后者是将字符串全转为大写字母。\n\t- `rstrip()`、`lstrip()` 与 `strip()`：去除字符串左边、右边或者两端的空白字符。\n\t- `partition(str)`：以 str 为中心，将目标字符串划分成左、中 ( str 本身 )、右三部分的字符串。\n\t- `isalpha()`、`isdigit()` 与 `isalnum()`：分别用于判断是否为字符，是否为数字和是否全为数字。\n\t- `join()`：例如 `str.join(array)`，即使用 str 将列表 array 的内容拼接起来。\n\n\t\t```python\n\t\tarray = ['A', 'B', 'C']\n\t\tstr1 = '&'\n\t\t# str2 被组装成 A&B&C，即将 str1 组装到字符数组中\n\t\tstr2 = str1.join(array) \n\t\t```\n\n##### 列表 List\n- 定义一个列表：`list = ['A', 'B', 'C', 'D']` 或者 `student = ['lucy', 25, 'female']`。\n- 列表的增删改查 ：\n\t- 增加：  \n\t1) 在列表尾部追加元素：`list.append('D')`   \n\t2) 自定义插入位置：`list.insert(位置，添加的内容)`   \n\t3) 往一列表中添加另一个列表：`student + list` 或者 `student.extend(list)`  \n\t- 删除：  \n\t1) 出栈：`list.pop()` / 入栈：`list.append()`  \n\t2) 根据下标来删除：`del list[0]`，清空列表 `del list[0::1]`  \n\t- 查询：  \n\t1) `('B' in list)` 结果为 Ture  \n\t2) `('D' not in list)` 结果为 Ture\n\n##### 元组 Tuple\n- 有序列表元组 ( Tuple )，与 List 不同，`Tuple 一旦初始化就不能修改`。\n\n\t> 定义一些常量参数时可用 Tuple。\n\n- 定义：`tuples = ('A', 'B', 'C')`。\n- 歧义：`tuple = (1)` 相当于 `tuple = 1`；`tuple(-1, )` 才是元组列表。\n- 事实： Tuple 中存储的是 `引用`。\n\n\t```python\n\ttuple = ('a', 'b', ['A', 'B'])\n\ttuple[2][0] = 'X'\n\ttuple[2][1] = 'Y'\n\t\n\t# 事实上，'A' 和 'B' 被改变为 'X' 和 'Y'\n\t# 即 Tuple 定义是不变的，只是 Tuple 上存储的 List 为引用\n \t```\n \n - 再议不可变对象：replace() 并没有改变字符串的内容，我们理解 `str` 是变量，`abc` 是字符串对象。replace() 相当于创建了新的字符串对象 `Abc`。\n\n\t```python\n\tstr = 'abc'\n\tprint( str.replace('a', 'A') ) # 输出 Abc\n\tprint(str) # 输出 abc\n\t```\n\n##### 字典 Dict\n- 字典 ( Dict )，其他语言中又称 Map，使用键值 ( key-value ) 存储。\n- 定义：`dict = {'name': 'Lucy', 'age'：25, 'gender': 'female}`。\n- 字典的增删改查：\n\t- 增加：`dict['high'] = 175`，若对应键值存在即修改的效果。\n\t- 删除：`dict.pop('high')` / `del dict['high']`\n\t- 查询：`dict.get('name')`，若找不到对应键值则抛出异常。\n\n##### 集合 Set\n- Set 与 Dict 类似，是一组 key 的集合，但不存储 value。\n- Set 可看成数学意义上的 `无序` 和 `无重复` 元素的集合。\n\n\t```python\n\tprint( set([1, 1, 2, 3, 4, 4, 5]) ) # 输出 [1, 2, 3, 4, 5]\n\t```\n\n#### 条件判断\n- 标准条件判断语句：\n \n\t```python\n\tif <condition 1>:\n\t    <action 1>\n\telif <condition 2>:\n\t    <action 2>\n\telse:\n\t    if <condition 3>: # if 嵌套\n\t        <action 3>\n\t```\n\n- 三元表达式：在 Python 中，可将 `if-else` 语句放到一行里，语法如下：\n\n\t```python\n\t# true-expr 或 false-expr 可以是任何 Python 代码\n\tvalue = true-expr if condition else false-expr\n\t\n\t# 上述三元表达式等同于标准条件判断语句的写法\n\tif condition:\n\t    value = true-expr\n\telse:\n\t    value = false-expr\n\t```\n\n#### 循环结构\n\n- `For` 循环与 `While` 循环\n\n\t```python\n\t# For 循环\n\tnames = ['LiMing', 'ZhangWei']\n\tfor name in names\n\t    print(name)\n    \n\t# While 循环\n\tsum = 0\n\ti = 0\n\twhile( i<100 ):\n\t    sum += 1\n\t    i += 1\n\t```\n\n- `Break` 与 `Continue`\n\t- Break：终止 ( 跳出 ) 循环。\n\t- Continue：中断本次循环。\n\n### 函数\n\n#### 定义函数\n- 定义函数使用 `def` 语句，依次写 `函数名`、`括号`、( 还可以包括 `参数` )、`冒号`。然后是 `函数体` ( 需缩进编写 )。\n\n\t```python\n\tdef FuncName(param):\n\t    <action>\n\t    return [返回参数]\n\t```\n\t\n- 空函数：模块化设计，即先架构后编码。\n\n\t```python\n\tdef FuncName(param):   \n\t    pass # 占位符：暂不书写代码逻辑\n\t```\n\t\n- 返回多个值：\n\n\t```python\n\tdef move(x, y):\n\t    x = x + 1\n\t    y = y + 1\n\t    return x, y\n\t    \n\tx, y = move(100, 100) # 其实返回的是一个 Tuple，即 (x, y)\n\t```\n\n#### 函数参数\n- 默认参数 ( 缺省参数 )：最大好处是降低调用函数难度，类似注册时，多数用户只关心核心的信息，即其余信息设置为默认值。\n\n\t> 注意：定义默认参数时，必须指向不变对象。如 n = 2，不能 n = m ( m 为变量 )\n\t\n\t```python\n\tdef power(x, n = 2):\n\t\ts = 1\n\t\twhile(n > 0):\n\t\t    n = n - 1\n\t\t    s = s * x\n\t\treturn s\n\t\t\n\tprint( power(5) ) # 输出 25\n\tprint( power(5, 3) ) # 计算 5 的 3 次方，输出 125\n\t```\n\t\n- 可变参数：顾名思义，可变参数就是传入的参数个数是可变的。\n\n\t```python\n\t# def calculator(numbers)，即理解 numbers 为一个 tuple\n\tdef calculator(*numbers): \n\t    sum = 0\n\t    for n in numbers:\n\t        sum = sum + n ** 2\n\t    return sum\n\t\n\t# 等价于 calculator( (1, 3, 5, 7) )\n\tprint( calculator(1, 3, 5, 7) ) # 输出 84\n\t```\n\t\n- 关键字参数：  \n\t`可变参数` 允许你传入 0 个或任意个参数，这些参数在函数调用时自动组装为一个 `元组` ( Tuple )。  \n\t`关键字参数` 允许你传入 0 个或任意个参数，这些关键字参数在函数内部自动组装成为一个 `词典` ( Dict )。  \n\n\t```python\n\tdef person(name, age, **kw): \n\t    print(' name:', name, ' age:', age, ' others:', kw)\n\t\n\tperson('Lucy', 35, city = 'Guangzhou', gender = 'M')\n\t# 输出  name: Lucy  age: 35  others: {'city': 'Guangzhou', 'gender': 'M'}\n\t\n\t# 当然，我们可先组装词典 dict，然后把该 dict 转换为关键字参数传进去\n\textra = {'city': 'Guangzhou', 'gender': 'M'}\t\n\t\n\t# 将字典中的元素，拆分成独立的 Key-Value 键值，引用时前缀也要加 \"**\"\n\tperson('Jack Ma', 50, **extra)\n\t# 输出 name: Jack Ma  age: 50  others: {'city': 'Guangzhou', 'gender': 'M'}\n\t```\n\t\n- 参数组合：Python 中定义函数，可多种参数组合使用，但必须满足一下参数定义顺序：`必选参数`、`默认参数`、`可变参数`、`命名关键字` 和 `关键字参数`。\n\n\t```python\n\tdef func(a, b, c = 0, *args, **kw):\n\t    print(' a=', a, ' b=', b, ' c=', c, ' args=', args, ' kw=', kw)\n\t\n\t# 输出 a=1 b=2 c=3 args=('a', 'b') kw={'x'=99}\n\tfunc(1, 2, 3, 'a', 'b', 'x'=99)\n\t```\n\n- 结合 `tuple` 和 `dict`：即通过类似 `func(*args, **kw)` 形式调用函数。参数虽可自由组合使用，但不要组合太复杂，以造成可理解性较差的结果。\n\n\t```python\n\targs = (1, 2, 3)\n\tkw = {'x' = 5, 'y' = 6}\n\tfunc(*args, **kw)\n\t```\n\n#### 递归函数\n- 函数内部可以调用其他函数。若一个函数内部调用了其自身，即该函数为 `递归函数`。\n\n\t```python\n\tdef fact(n):\n\t    if n == 1:\n\t        return 1\n\t    return n * fact(n - 1)\n\t```\n\t\n- 递归的过深调用会导致栈溢出。可通过 `尾递归` 优化。\n- 尾递归优化：解决递归调用栈溢出的方法，即函数返回时调用本身，并且 return 语句不能包含表达式。\n\n\t- 区别上述的 fact(n) 函数，由于 `return n * fact(n - 1)` 引入了乘法表达式，即非尾递归。\n\t- 而 `return fact_iter(num - 1, num * product)` 仅仅返回函数本身。\n\t- 这样，编译器 / 解释器就可对尾递归做优化，即使递归本身调用 n 次，都只占用一个栈帧，不会出现栈溢出的情况。\n\n\t```python\n\tdef fact():\n\t    return fact_iter(n, 1)\n\t    \n\tdef fact_iter(num, product):\n\t    if num == 1:\n\t        return product\n\t    return fact_iter(num -1, num * product)\n\t```\n\n### 高级特性\n\n#### 切片\n- 切片操作符：在 List 中指定 `索引范围` 的操作。  \n\t索引范围具体为： `起始位置:结束位置:步进` ，注意步进数 ( 默认为 1，不能为 0 )。\n\n\t```python\n\tlist = [11, 22, 33, 44, 55]\n\t\n\t# 输出 [11, 22, 33]，即从小标为 0 开始，步进为 1，取前 3 个元素\n\tprint( list[0:3:1] )\n\t```\n\n- 倒数切片：\n\n\t```python\n\tlist = ['A', 'B', 'C', 'D', 'E']\n\t\n\t# 输出 ['A', 'B', 'C', 'D']，即从下标为 0 开始，切片至倒数第一个元素 (不含其本身)\n\tprint( list[0:-1] )\n\t```\n\t\n- 字符串切片：\n\n\t```python\n\tstr = 'ABCDE'\n\t\n\t# 输出 ACE，即对字符串中所有字符作用，每隔两位取值\n\tprint( str[::2] )\n\t```\n\t\n- 注意：`Tuple` 也是一种 `List`，唯一不同的是 Tuple 不可变，因此 Tuple 不可用切片操作。\n\n#### 迭代\n- 迭代：给定一个 List 或 Tuple，通过 For 循环遍历这个 List 或 Tuple。\n\n\t```python\n\tlist = ['A', 'B', 'C', 'D', 'E']\n\t\n\tfor str in list:\n\t    print(str) # 输出 ABCDE\n\t```\n\t\n- `enumerate` 函数可以把一个 list 变成 `索引-元素树`，这样就可以在 For 循环中同时迭代 `索引` 和 `元素本身`。\n\n\t```python\n\tlist = ['A', 'B', 'C', 'D', 'E']\n\t\n\tfor i, value in enumerate(list):\n\t    print(i, value)\n\t```\n \n#### 列表生成式\n- 列表生成式：List Comprehensions，用于创建 List 的生成式。\n\n\t```python\n\tlist1 = []\n\n\tlist1 = [x**2 for num in range(1, 10)]\n\t# 输出 1x1，2x2，3x3, ..., 9x9\n\tprint(list1)\n\n\t'''\n\t等价于：\n\tfor num in range(1, 10):\n\t    list1.append(num ** 2)\n\t'''\n\t    \n\t# for 循环与 if 判断配合，例如取得 10 以内的偶数，求其平方数\n\tlist2 = [ num**2 for num in range(1, 10) if num%2 == 0 ]\n\t# 输出 2x2, 4x4, 6x6, 8x8\n\tprint(list2)\n\t\n\t# 两层 for 循环\n\tlist3 = [ m+str(n) for m in 'ABC' for n in range(1,4) ]\n\t# 输出 ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']\n\tprint(list3)\n\t\n\tlist4 = [ m*n for m in 'ABC' for n in range(1,4) ]\n\t# 输出 ['A', 'AA', 'AAA', 'B', 'BB', 'BBB', 'C', 'CC', 'CCC']\n\tprint(list4)\n\t\n\t# 列出当前目录下所有文件和目录名\n\timport os # 导入 os 模块\n\tlist = [d for d in os.listdir('.')] \n\t```\n\n#### 生成器\n- 引入：`列表生成式`，可直接创建一个列表。但受到内存限制，列表容量肯定是有限的。例如：我们需要一个包含 100 万个元素的列表 ( 列表中的元素按照某种算法推算出来 )，直接创建是不太现实的，那么我们是否可通过某种过程，实现 `动态推算` 并 `输出元素` ？ \n- Generator：`生成器`，即不用一步到位创建 list 对象，而是通过循环过程中不断推算出后续的元素。在 Python中，把这种一边循环一边计算的机制称作 `Generator`。\n- 创建 Generator：把列表生成式的 `[]` 改成 `()` 即可。\n\n\t```python\n\t# 受到内存限制，运行过程中可能会崩掉\n\tlist = [ x for x in range(1, int(10e10)) ]\n\t\n\t# 简单生成器\n\tgenerator = ( x for x in range(1, int(10e10)) )\n\tfor n in generator:\n\t    print(n)\n   \n\t# 简单示例：带 yield 的 Generator 函数\n\t# 1) 在每次循环时都执行，遇到 yield 语句返回\n\t# 2) 再次执行时，从上次返回的 yield 语句处继续执行\n\tdef odd():\n\t    print('First Return: ')\n\t    yield [1, 2, 3]\n\t    print('Second Return:')\n\t    yield (1, 2, 3)\n\t    print('Third Return:')\n\t    yield {'key': 'value'}\n\t    \n\tfor n in odd():\n\t    print(n)\n\t    \n\t# Fibonacci 数列\n\tdef fibonacci(times):\n\t    n, a, b = 0, 0, 1\n\t    while n < times:\n\t        yield b\n\t        (a, b) = (b, a+b)\n\t        n = n + 1\n\t    return 'done'\n\t    \n\tfor n in fibonacci(10):\n\t    print(n)\n\t```\n\n#### 迭代器\n- 可用于 for 循环的数据类型：\n\t- 集合数据类型：list、tuple、dict (字典)、set、str (字符串)\n\t- Generator 生成器和带 `yield` 的 Generator 函数\n- 可用于 for 循环的对象统称为可迭代对象 `Iterable`。\n\n\t```python\n\t# 使用 isinstance() 判断一个对象是否为 Iterable 对象\n\tform collections import Iterable\n\t\n\tisinstance([], Iterable) # True\n\tisinstance((x for x in range(1, 10)), Iterable) # True\n\tisinstance(100, Iterable) # False\n\t```\n\n- 生成器是 `Iterator` 对象；List、Dict、Str 虽然是 Iterable 对象，但却不是 `Iterator`。\n\t我们可以通过 `iter()` 函数，把 List、Dict、Str 等 Iterable 转换达成 `Iterator`。\n\t\n\t> Python 的迭代器 ( Iterator ) 对象表示的是一个数据流，即 Iterator 对象可被 `next()` 函数调用并不断返回下一个数据，直至没有数据时抛出 `StopIteration` 异常。\n\t\n\t```python\n\tisinstance(iter([]), Iterator) # True\n\tisinstance(iter('abc'), Iterator) # True\n\t```\n\t\n### 函数式编程\n\n- 函数：\n\t- `模块化编程`，即把大段功能代码拆分、封装成模块，通过层层调用，把复杂任务解构成简单任务。\n\t- 这种分解称之为 `面向过程` 的程序设计。\n\t- 函数是面向过程程序设计的 `基本单元`。\n- 函数式编程：\n\t- 就是一种抽象程序很高的 `编程范式`；\n\t- 纯粹的函数式编程语言编写的函数没有变量；\n\t- 函数式编程的特点：允许函数作为 `参数`，作为另一函数的 `输入`。\n\n#### 高阶函数\n- 变量可指向函数：\n\n\t```python\n\t# 直接调用函数\n\tx = abs(-10)\n\t\n\t# 变量可指向函数\n\tf = abs\n\tx = f(-10)\n\n\t# x 的结果都为 10\n\t```\n\t\n- 函数名也是变量：函数名其实就是指向函数的变量。\n\n\t> 注意：  \n\t> 1) 而在实际编码当中，绝对不能这样写，只是为了说明函数名也是变量。  \n\t> 2) 若需恢复 abs 函数，请重启 Python 交互环境。  \n\n\t```python\n\tabs = 10\n\tabs(-1)\n\t\n\t# 抛出异常\n\t# 即 abs 已指向一个整数 10，而不是指向求绝对值的函数。  \n\tTraceback (most recent call last):\n\t    File \"<stdin>\", line 1, in <module>\n\tTypeError: 'int' object is not callble\n\t```\n\t\n- 传入函数：一个函数接收另一个函数作为参数，称为 `高阶函数`。\n\n\t```python\n\tdef add(x, y, f):\n\t    return f(x) + f(y)\n\t    \n\t# 调用 add(-5, 6 abs) 时，计算的过程为：\n\t# x = -5\n\t# y = -6\n\t# f = abs\n\t# f(x) + f(y)\n\t```\n\n##### MapReduce\n- Python 内建了 map() 和 reduce() 函数。\n- Map / Reduce 的概念 ：\n\t- MapReduce 是一种编程模型，是 `处理` 和 `生成` 大型数据集的相关实现。\n\t- 用户指定一映射函数 `map()` 处理键/值对，以生成一组`中间键/值对`；同时也指定 `reduce()` 函数用以 `合并` 含相同中间键所关联的所有中间值。\n\n\t> 为了更加透彻理解 MapReduce，可研读  Google 关于 MapReduce 的论文：  \n\t> `MapReduce: Simplified Data Processing on Large Clusters` $^{[4]}$。\n\t\n###### Map 函数\n- map() 函数：其接收 `两个参数`，第一个是 `函数`，第二个是 `Iterable`。即 map 将传入的 `函数` 依次 `作用` 到序列的 `每个元素`，并把结果作为新的 `Iterator` 返回。\n\n\t```python\n\t# 例 1：有一个函数 f(x) = x*x，将其作用于一个 list = [1, 2, 3, 4, 5]\n\tdef f(x):\n\t    return x ** 2\n\t\n\t# 1) map() 函数\n\tr = map(f, [1, 2, 3, 4, 5])\n\tprint(list(r)) # 输出 [1, 4, 9, 16, 25]\n\t\n\t# 2) 不需要 map() 函数的等价写法\n\tlist = []\n\tfor n in [1, 2, 3, 4, 5]\n\t    list.append( f(n) )\n\tprint(list) # 输出 [1, 4, 9, 16, 25]\n\t\n\t# 例 2：map 作为高阶函数，事实上它把运算规则抽象了，如把 list 中数字转字符串\n\tlist( map(str, [1, 2, 3, 4, 5]) ) # 输出 ['1', '2', '3', '4', '5']\n\t```\n\t\n###### Reduce 函数\n- reduce() 函数：其接收 `两个参数`，第一个是 `函数`，第二个是 `Iterable`。即 reduce 把结果继续和序列的 `下一个元素` 做 `累积计算`。\n\n\t> reduce(f, [x1, x2, x3, x4]) 等价于 f( f( f(x1, x2), x3 ), x4 )\n\t\n\t```python\n\tfrom functools import reduce\n\tdef add(x, y):\n\t    return x + y\n\n\tprint( reduce(add, [1, 2, 3, 4, 5]) )\n\t```\n- 当然，上述的实例只是为了描述原理而设定，下面将结合 map() 与 reduce() 举例：\n\n\t```python\n\tfrom functools import reduce\n\t\n\t# 定义一计算公式\n\tdef fn(x, y):\n\t    return x * 10 + y\n\t\n\t# 定义一字符转数字的函数\n\tdef char2num(s):\n\t    digits = {'0': 10, '1': 20, '2': 30, '3': 40}\n\t    return digits[s]\n\t    \n\t# map/reduce 实现处理与计算的功能\n\tprint( reduce(fn, map(char2num, '0123')) )\n\t```\n\n##### Filter\n- Python 内建了 `filter()` 函数，用于过滤序列。\n- filter() 函数：接收 `两个参数`，一个是 `函数`，另一个是 `序列`。即 filter 把传入的函数作用于每个元素，然后根据返回值是 `True/False` 决定是否 `保留/丢弃` 该元素。\n\n\t> filter() 函数返回的是一个 Iterator，即一个惰性序列，故需要强迫 filter() 完成计算结果，如 list() 函数获得所有结果。\n\t\n\t```python\n\t# 在一个 list 中，删掉偶数，只保留奇数\n\tdef isOdd(n):\n\t    return n % 2 == 1\n\t    \n\t# 输出 [1, 3, 5]\n\tlist( filter(isOdd, [1, 2, 3, 4, 5]) )\n\t\n\t# 把一个序列中的空字符剔除\n\tdef rejectBlankStr(s):\n\t    return s and s.strip()\n\t    \n\t# 输出 ABC\n\tlist( filter(rejectBlankStr, ['A', 'B', '', None, 'C']) )\n\t```\n\n##### Sorted\n- 排序算法：排序的核心是 `比较两元素的大小`。若是数字则直接比较；但比较的若是字符串或两个字典，则比较过程需通过函数抽象实现。\n\n\t```python\n\t# 输出 [-6, 2, 12, 24, 36]\n\tprint( sorted( [36, 24, -6, 12, 2] ) )\n\t```\n\t\n- `sorted()` 也是一高阶函数，可接收一个 key 函数来自定义排序:\n\n\t```python\n\t# 输出 [2, -6, 12, 24, 36]\n\tprint( sorted([36, 24, -6, 12, 2], key = abs) )\n\t\n\t# 忽略大小写，实现字符串排序\n\t# 实现字符串的比较是根据 ASCII 实现比较的\n\tprint( sorted(['Bob', 'Lucy', 'Zoo', 'Danny'], key = str.lower) ) \n\t\n\t# 进行反向排序，可传入第三个参数实现\n\tprint( sorted(['Bob', 'Lucy', 'Zoo', 'Danny'], key = str.lower, reverse = True) )\n\t```\n\n#### 返回函数\n\n##### 函数作为返回值\n- 函数作为返回值：高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。\n\n\t```python\n\t# 通常情况实现一个可变参数的求和\n\tdef calcSum(*args):\n\t    ax = 0\n\t    for n in args:\n\t        ax = ax + n\n\t    return ax\n\t    \n\t# 若不想立刻求和，可不返回求和结果，而是求和函数\n\tdef lazySum(*args):\n\t    def sum():\n\t        ax = 0\n\t        for n in args:\n\t            ax = ax + n\n\t        return ax\n\t    return sum\n\t\n\t# 调用 lazySum() 时，返回函数而不是结果\n\tf = lazySum(1, 3, 5, 7, 9)\n\t\n\t# 调用 f，才真正计算求和的结果\n\tf()\n\t\n\t# 当每次调用 lazySum() 时，都会返回一个新的函数，既使传入参数相同\n\tf1 = lazySum(1, 3, 5, 7, 9)\n\tf2 = lazySum(1, 3, 5, 7, 9)\n\tprint( f1 == f2 ) # 输出 False\n\t```\n\n##### 闭包\n- 注意到上述例子返回的函数在其定义内部引用了局部变量 `args`，故当一个函数返回一个函数后，其内部的局部变量还被新函数引用。\n- 注意返回的函数并没有立刻执行，而是调用了 `f()` 才执行。\n\n\t```python\n\tdef count():\n\t    fs = []\n\t    for i in range(1, 4):\n\t        def f():\n\t            return i ** 2\n\t        fs.append(f)\n\t    return fs\n\t    \n\tf1, f2, f3 = count()\n\t# 输出 9::9::9\n\tprint( str(f1()) + '::' + str(f2()) + '::' + str(f3()) ) \n\n\t\"\"\"\n\t\" 实际结果为：f1() --> 9，f2() --> 9, f3() --> 9\n\t\" 全部结果都为 9，原因在于返回的函数引用了变量 i，但它并非立刻执行\n\t\" 需等到 3 个函数都返回时，它们所引用的变量 i 已经变成了 3，故最终结果是 9\n\t\"\"\"\n\t\n\t# 若需引用循环的变量\n\tdef count():\n\t    def f(j):\n\t        def g():\n\t            return j * j\n\t        return g\n\t    \n\t    fs = []\n\t    for i in range(1, 4):\n\t        fs.append( f(i) ) # f(i) 立刻执行，i 的当前值被传入 f()\n\t    return fs\n\t    \n\tf1, f2, f3 = count()\n\t# 输出 1::4::9\n\tprint( str(f1()) + '::' + str(f2()) + '::' + str(f3()) )\n\t```\n\n\t{% note danger %}\n\t返回闭包时牢记一点：返回函数不要引用任何循环变量，或后续会发生变化的变量。\n\t{% endnote %}\n\n#### 匿名函数\n- 当函数作为 `传入参数` 时，我们不需要显式地定义函数，直接传入匿名函数更便捷。\n- 关键字 `lambda` 表示匿名函数，冒号前面表示传入参数，后面为返回值 ( 一般为表达式运算后的结果 )，如 `lambda x, y : x+y`\n\n\t```python\n\t# 以 map() 函数为例\n\t# 输出 [1, 4, 9, 16, 25]\n\tprint( list(map(lambda x : x ** 2, [1, 2, 3, 4, 5])) )\n\t\n\t# 匿名函数实际为：\n\tdef f(x):\n\t    return x ** 2\n\t```\n\n- 匿名函数有一好处，即不必担心 `函数名冲突`。此外，匿名函数也是一个函数对象，可把匿名函数赋值给一个变量，再利用变量来调用。\n\n\t```python\n\tf = lambda x : x ** 2\n\tprint( f(5) ) # 输出 25\n\t```\n\t\n- 匿名函数作为返回值返回：\n\n\t```python\n\tdef build(x, y):\n\t    return lambda: x * x + y * y\n\t```\n\t\n#### 装饰器\n- 提示：对于装饰器，除了廖雪峰老师的教程外 ( 侧重原理讲解 )，还可参考程序员大咖的推文 [Python 装饰器的诞生过程](https://mp.weixin.qq.com/s/0nZTAjeftR3Xa9T9TbQc-g) ( 侧重具体实现讲解 )。\n\n- 引例：假设我们有 time() 函数，我们要增强 time() 函数的功能，比如在函数调用前后自动打印日志，但又不希望修改 time() 函数的定义。\n\n\t这种在代码运行期间动态增加功能的方式，称之为 `装饰器 (Decorator)`。\n\n\t```python    \n\tdef log(func):\n\t    def wrapper(*args, **kw):\n\t        print('call %s():' % func.__name__)\n\t        return func(*args, **kw)\n\t    return wrapper\n\t    \n\t@log\n\tdef time():\n\t    print('2018-11-11 23:11')\n\t```\n\n\n- 那么装饰器是如何实现的？在实现装饰器之前，我们有必要回顾函数的特性：\n\t- `函数作为变量传递`：函数作为变量来传递，代表的是一个函数对象。若函数不加括号，是不会执行的；\n\t- `函数作为参数传递`：一个函数可以接受另一个函数对象作为自己的参数，并对函数对象进行处理；\n\t- `函数作为返回值`：一个函数的返回值可以是另一个函数对象。\n\t- `函数嵌套及跨域访问`：一个函数 (主函数) 内部是可以嵌套另一个函数 (子函数) 的；\n\n\t```python\n\t# 函数作为变量传递\n\tdef add(x):\n\t    return x + 1\n\ta = add # 作为变量\n\t\n\t# 函数作为参数传递\n\tdef add(x):\n\t    return x + 1\n\tdef excute(f):\n\t    return f(3)\n\texcute(add) # 作为参数\n\t\n\t# 函数作为返回值\n\tdef add(x):\n\t    return x + 1\n\tdef get_add():\n\t    return add # 作为返回值\n\t\n\t# 函数嵌套及跨域访问\n\tdef outer():\n\t    x = 1\n\t    def inner():\n\t        print(x) # 被嵌套函数 inner 内部的 x 变量可以到封装域去获取\n\t    inner()\n\t    \n\touter()\n\t```\n\n- Python 中的装饰器是通过闭包实现的，即闭包就是引用了外部变量的内部函数，而闭包的实现正是利用了以上函数特性。具体实现：\n\t- `问题`：观察打印结果，从 func() 到 closure()，func 变成了closure，具体是怎么装饰的呢？\n\t- `解释`：closure 实际上是 outer(func)，func 作为参数传进 outer，outer 的子函数 inner 对 func 返回的结果进行了一番装饰，返回了一个装饰后的结果，最后 outer 返回 inner，可以说 inner 就是装饰后的 func，这就是一个函数被装饰的过程，重点在于执行 outer(func) 这个步骤，即执行 closure()。\n\n\t```python\n\tdef func():\n\t    return '函数 func'\n\n\tdef outer(x):\n\t    def inner(): # 函数嵌套\n\t        return '戴了 inner 帽子的' + x() # 跨域访问，引用了外部变量 x\n\t    return inner # 函数作为返回值\n\n\t# 函数 func 作为 outer 的参数，函数作为变量赋给 closure\n\tclosure = outer(func) \n\n\tprint( func() ) # 执行原始函数\n\tprint( closure() ) # 执行闭包\n\t\n\t# 执行结果：\n\t# 函数 func\n\t# 戴了 inner 帽子的函数 func\n\t```\n\n- 装饰器语法糖 `@`：Python 给我们提供了语法糖 `@`，我们想执行 outer(func)，只需要把 outer 函数 @ 到 func 函数的上即可。具体实现：\n\n\t```python\n\tdef outer(x):\n\t    def inner():\n\t        return '戴了 inner 帽子的' + x()\n\t    return inner\n\n\t@outer\n\tdef func():\n\t    return '函数 func'\n\n\tprint( func() ) # 输出：戴了 inner 帽子的函数 func\n\t```\n\n#### 偏函数\n- 例：int() 函数可把字符串转为整数，当且仅当传入字符串时，int() 函数默认按照 `10 进制转换`。\n\n\t```python\n\tprint( int('12345') ) # 输出 12345\n\t\n\t# int() 函数提供额外 base 参数，默认值为 10\n\t# 若传入 base 参数即可做 N 进制转换 ( N 进制转到 10 进制 )\n\tprint( int('10', base = 8) ) # 输出 8\n\tprint( int('A', base = 16) ) # 输出 10\n\t\n\t# 若我们要转换大量二进制字符串，则可通过定义函数\n\tdef int2(x, base = 2):\n\t    return int(x, base)\n\t    \n\t# 这样转换二进制就非常便捷了\n\tprint( int2('10000000') ) # 输出 128\n\tprint( int2('10101010') ) # 输出 170\n\t```\n\n- 其实 `functools.partial` 就是帮助我们创建一个偏函数，即其作用就是把一个函数的某些参数固定住 ( 设置默认值 )，返回一个新函数。\n\n\t```python\n\timport functools\n\tint2 = functools.partial(int, base = 2)\n\t```\n\t\n- 创建偏函数时，实际可接收 `函数对象`、`*args` 和 `**kw` 这三个参数。\n\n\t```python\n\tint2 = functools.partial(int, base = 2)\n\t\n\t# 相当于：\n\targs = '10001000'\n\tkw = {'base': 2}\t\n\tint(*args, **kw)\n\t```\n\t\n### 模块\n\n#### 基本概念\n- 一个 `.py` 文件称之为一个模块 (Module)，模块可避免函数名和变量名冲突。\n\n\t> ⚠️ 尽量不与 Python 内置函数名称相冲突，详细可参考 Python 标准函数库 $^{[6]}$。\n\t\n- 按目录来组织模块的方法，称为包 (Package)，可避免模块名称的冲突。\n\n\t> ⚠️ 创建模块的名称不能和 Python 自带的模块名称相冲突。例如系统自带 `sys` 模块。\n\n\t- `__init__.py` 该文件必须存在，否则 Python 就把当前 目录当作普通目录，而不是一个包了。\n\t- `__init__.py` 可以是空文件，也可含有代码。\n\t- `samplye.py` 的模块名称为 `mypython.sample`。\n\t- `__init__.py` 的模块名称为 `mypython`。\n\n\t```bash\n\tmypython\n\t  ├─ __init__.py\n\t  ├─ sample.py\n\t  └─ example.py\n\t```\n\t\n#### 使用模块\n- 以内建的 `sys` 模块为例，编写 `sample` 模块:\n\n\t```python\n\timport sys\n\t\n\tdef test():\n\t    args = sys.argv\n\t    if len(args) > 2:\n\t        for str in args:\n\t            print('%s' % str)\n\t    else:\n\t        print('Empty paramter')\n\t```\n\t\n- 作用域：在一模块中，我们可能会定义很多函数和变量。或许我们有这样的需求：有的函数和变量仅希望是在模块内部使用。Python 中通过 `_` 前缀实现的。\n\t- 正常的函数和变量名是公开的 (public)，可被直接引用。例如，`abc`、`x1`、`PI` 等。\n\t\t\n\t- 非公开的函数和变量 (private)，不应该被直接引用。例如 `_xxx`、`__xxx`。\n\n\t\t> `不应该` 被直接引用，而不是不能被直接引用，因为 Python 并没有一种方法可以完全限制访问 private 函数或者变量。\n\t\t\n\t- 使用 `private` 函数，实现代码封装和抽象的方法：\n\n\t\t```python\n\t\tdef __sayHello(name):\n\t\t    print('Hello' + name)\n\t\t\n\t\tdef greeting(name):\n\t\t    __sayHello(name)\n\t\t\n\t\t# 调用函数\n\t\tgreeting('Bob')\n\t\t```\n\t\t\n#### 第三方模块\n- Python 中，安装第三方模块是通过包管理工具 `pip` 完成的。 \n\t- 若是 `Mac/Linux` 用户，可跳过安装 `pip` 的步骤。\n\t- 若是 `Windows` 用户，则需要安装 `pip` 工具。( 安装方法自行搜索或参考 [7] )\n- 安装完包管理工具 `pip`，可通过 `pip install Pillow` (Python 2.x) 或 `pip3 install Pillow` (Python 3.x) 命令安装 Python Imaging Library (处理图像的工具库)。\n- 当然，Python 使用过程中需要安装和使用大量的第三方库，若通过上述方式安装未免太过繁琐，故我们可考虑直接安装 [Anaconda](https://www.baidu.com/link?url=wU4ubxmhQWv3nZxRpf8-49yE1jNiaKCbtn0a1tfl9V4OOvw4KG0FH0mbdC4REMDf&wd=&eqid=f287538e0000a002000000065bbc170c)。\n\n\tAnaconda，其是一个基于 Python 的数据处理和科学计算的平台，他已经内置了许多非常有用的第三方库。在完整完 Anaconda 后，重新在命令行中键入 `python`，出现以下信息即安装成功，可正常导库使用：\n\t\n\t```python\n\tpython\n\tpython 3.x.x | Anconda, Inc. | ... on darwin\n\t>>> import numpy # 直接倒入第三方模块即可\n\t```\n\t\n#### 模块搜索路径\n- 当我们试图搜索某一模块，若找不到会报错。\n\n\t```python\n\t>>> import mymodule\n\tTraceback (most recent call last)\n\t    File \"<stdin>\", line 1, in <module>\n\tModuleNotFoundError: No module named 'mymodule'\n\t```\n\t\n- 默认情况，Python 解释器会搜索当前目录，所有已安装内置模块和第三方模块，`搜索路径` 存放在 `sys 模块` 的 `path 变量` 中：\n\n\t```python\n\t# 若需要添加搜索目录\n\timport sys\n\tsys.path.append('/User/kofe/mypython')\n\tprint(sys.path) # 查看是否已添加\n\t```\n\n### 面向对象编程\n- `面向对象编程`，Object Oriented Programming，简称 OOP。是一种程序设计思想。其把对象作为 `程序基本单元`，且对象中包含了 `数据` 和 `操作的函数`。\n\n\t> 面向对象的程序设计把计算机程序视为一组对象集合，而每个对象都可接收其他对象发送的消息并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。\n\n- 面向对象的程序可理解为：`程序 = 对象 + 对象`；`对象 = 成员变量 + 成员函数`。\n- 对比 `面向过程编程`，即把计算机程序视为一系列的命令集合，或可理解为一组函数的顺序执行。\n- 面向过程的程序可理解：`程序 = 函数 + 算法`。 \n\n- 在 Python 中，所有数据都可视为对象。当然，可以通过类来自定义对象的数据类型。例如，我们定义一个 `Student` 类型来代表学生的范畴：\n\n\t```python\n\tclass Student(object):\n\t    # __xxx__ 为特殊变量或方法，有特殊用途，会在后面章节详细讲解\n\t    def __init__(self, name, score):\n\t        self.name = name\n\t        self.score = score\n\t    \n\t    def printScore(self):\n\t        print('name: %s, score: %s' % (self.name, self.score))\n\t        \n\tstu1 = Student('Lucy', 80)\n\tstu2 = Student('Danny', 90)\n\t\n\t# 给对象发送消息实际就是调用对应的关联函数\n\tstu1.printScore()\n\tstu2.printScore()\n\t```\n\t\n#### 类和实例\n- 面向对象的核心概念是 `类 (Class)` 和 `实例 (Instance)`，牢记类是抽象的模板。例如，上述的 `Student 类`，实例即根据类创建出一个个具体的对象 `stu1`、`stu2`。\n- 通过 `class` 关键字定义类：\n\t\n\t```python\n\t# 若没有合适的继承类，则默认使用 object 类，这是所有类最终都会继承的类\n\tclass Student(object):\n\t    pass\n\t```\n\t\n- 创建类的实例，如 `stu = Student()`\n\n- 由于类起到模板的作用，因此可在创建实例时，通过特殊方法 `__init__()`，把属性绑定进去。\n\n\t```python\n\tclass Student(object):\n\t    def __init__(self, name, score):\n\t        self.name = name\n\t        self.score = score\n\t\n\t#创建实例时，不需要传入 self，即实例本身\n\tstu = Student('Lucy', 95)\n\t```\n\n- `数据封装`：访问实例本身的数据，不通过外部函数访问，而是通过类的内部定义访问数据的函数，这样实现数据封装。\n\n\t```python\n\tclass Student(object):\n\t    def printInfo(self):\n\t        print('name: %s, score: %s' % (self.name, self.score))\n\t```\n\n#### 访问限制\n- `私有变量`：让内部属性不被外部访问，在 Python 中，通过双下划线 `__` 开头，变量变成私有变量。\n\n\t```python\n\tclass Student(object):\n\t    def __init__(self, name, score):\n\t        self.__name = name\n\t        self.__score = score\n\t     \n\t    # Getter 方法\n\t    def getName(self):\n\t        return self.__name  \n\n\t    def getScore(self):\n\t        return self.__score\n\t        \n\t    # Setter 方法\n\t    def setName(self, name):\n\t        self.__name = name\n\n\t    def setScore(self, score):\n\t        # Setter 方法修改属性值的好处，可定义规则约束有效值\n\t        if  0  <= score <= 100:\n\t            self.__score = score\n\t        else:\n\t            raise ValueError('Bad Score')\n\t\n\tstu = Student('Bob', 90)\n\t\n\t# 直接访问会报错误:\n\t# AttributeError: 'Student' object has no attribute '__name'\n\tprint( stu.__name ) \n\t\n\t# 实现数据封装后\n\t# 使用 Getter 函数访问属性\n\tprint( stu.getName() )\n\t# 使用 Setter 函数修改属性\n\tstu.setName('Lucy')\n\t```\n\n- 在 Python 中，类似 `__xxx__` 的变量名，是 `特殊变量`，可直接访问。\n- 在 Python 中，私有变量 `_xxx` 和 `__xxx`，也是可以外部访问的。其实 Python 编译器是会把变量名修改为 `_类名__变量名`，致使直接访问报错。例如：`_Student__name`，通过 `stu. _Student__name ` 可实现外部访问 “私有变量”。\n\n\t> ⚠️ 当然，我们不建议这样做。因为不同版本的 Python 解释器可能会把 `__xxx` 改成不同变量名称。我们还是按照 `约定俗成` 的规定，视 `__xxx` 为私有变量。\n\n#### 继承和多态\n- `继承`：在面向对象程序设计中，可从某个现有类继承，新的类称为 `子类`，被继承的类称为 `基类、父类或超类`，例如：\n\n\t```python\n\tclass Animal(object):\n\t    def run():\n\t        print('Animal is running...')\n\t \n\t# Animal 实现了 run() 方法，Dog 继承 Animal 类\n\t# Dog 作为子类自然也拥有了 run() 方法\n\tclass Dog(Animal):\n\t    def run():\n\t        print('Dog is running...')\n\n\t# 当然，子类还可以重写方法和增加方法\n\tclass Cat(Animal):\n\t    def run():\n\t        print('Cat is running...')\n\t    def call():\n\t        print('Miao, Miao, Miao...')\n\t    \n\t```\n\n- `多态`：把不同子类对象都当作父类来看，可屏蔽不同子类对象之间的差异，写出通用代码。具体地，我们可从实例中理解多态：\n\n\t```python\n\tdef runTwice(animal):\n\t    animal.run()\n\t    animal.run()\n\t    \n\trunTwice( Animal() ) # 输出：Animal is running...\n\trunTwice( Dog() ) # 输出：Dog is running...\n\trunTwice( Cat() ) # 输出：Cat is running...\n\t```\n\n#### 获取对象信息\n- `type()` 函数：可判断对象类型\n\t\n\t```python\n\t# 基本类型\n\ttype(12345) # <class 'int'>\n\ttype('hello') # <class 'str'>\n\ttype(None) # <type(None) 'NoneType'>\n\n\t# 变量指向函数或者类\n\ttype(abs) # <class 'builtin_function_or_method'>\n\n\t# type() 函数返回类型\n\ttype(12345) == int # True\n\ttype('HelloWorld') == str # True\n\t\n\t# 判断其他类型\n\timport types\n\ttype(abs) == types.BuiltinFunctionType # True\n\ttype(lambda x:x) == types.lambdaType # True\n\ttype( (x for x in range(10)) ) == types.GeneratorType # True\n\t```\n\t\n- `isinstance()` 函数\n\t- 判断基本类型：`isinstance('abc', str)`，`isinstance(b'a', bytes)`  \n\t- 判断 class 类型：如有继承关系，如 `object -> Animal -> Dog`，则有：  \n\ta = Animal() => isinstance(a, Animal) =>True  \n\td = Dog() => isinstance(d, Animal) =>True  \n\td = Dog() => isinstance(d, Dog) =>True  \n\n- `dir()` 函数：若要获得一个对象的 `所有属性和方法`，可使用该函数。它返回一个包含字符串的 `list`。例如，获得一个 str 对象的所有属性和方法。\n\t\n\t```python\n\t# 输出：['__add__', '__class__', ... 'zfill']\n\tdir('abc') \n\t```\n\t\n- 类似 `__xxx___` 的属性和方法在 Python 中都有特殊用途。如 `__len__()` 方法返回长度。调用 `len()` 函数，在函数内部实际是它自动地去调用该对象的 `__len__（)` 方法，故下面代码是等价的。\n\t\n\t```python\n\tlen('abc') == 'abc'.__len__() # 输出 True\n\t```\n\t\n- 仅仅把属性和方法列出来是不够的，配合 `getattr()`、`setattr()` 及 `hasattr()`，我们可直接操作一个 `对象的状态`。\n\n\t```python\n\tclass Retangle(object):\n\t    def __init__(self):\n\t        self.x = x\n\t        self.y = y\n\t    def area(self):\n\t        return self.x * self.y\n\t\n\trectangle = Rectangle(5, 10)\n\t\n\thasattr(rectangle, 'z') # 是否含有属性 z\n\tsetattr(rectangle, 'z', 1) # 设置一个属性 z，令其等于 1\n\tgetattr(rectangle, 'z') # 获取属性 z\n\t\n\t# 也可以获得对象方法\n\tif hasattr(rectangle, 'area'):\n\t    fn = getattr(rectangle, 'area')\n\t```\n\n#### 实例属性和类属性\n- 给实例绑定属性的方法是通过 `实例变量` 赋值，或通过 `self 变量` 赋值。\n\n\t```python\n\tclass Student(object):\n\t    # self 变量赋值\n\t    def __init__(self, name, score):\n\t        self.name = name\n\t        self.score = score\n\t\n\tstu = Student('Bob', 80)\n\t# 实例变量赋值\n\tstu.gender = 'male'\n\t```\n\t\n- 给类绑定属性，直接在 `class` 中定义属性即可。\n\n\t> Tips：编写程序时，不要对 `实例属性` 和 `类属性` 使用相同名称，若含有相同名称的实例属性，将屏蔽掉同名称的类属性。\n\t\n\t```python\n\tclass Student(object):\n\t    grade = 'postgraduate'\n\t    \n\tstu = Student('Lucy', 95)\n\tprint( stu.grade ) # 与 print(Student.grade()) 效果相同\n\t```\n\n### 面向对象高级编程\n\n#### 使用 @property\n- `引入`：在「[访问限制](https://www.kofes.cn/2018/09/life-is-short-we-need-python.html#访问限制)」章节中，我们通过 setScore() 和 getScore() 方法实现修改数据和获取数据，以实现数据封装。\n\n\t那么本节提及 `@property`  属性，到底是何意图？先看看原始的 Setter 和 Getter 使用方法：\n\t\n\t```python\n\tclass Student(object):\n\t    # Getter 方法\n\t    def getScore(self):\n\t        return self.__score\n        \n\t    # Setter 方法\n\t    # setXXX() 方法还可书写规则以约束输入数据或检查数据\n\t    def setScore(self, score):\t        \n\t        if  0  <= score <= 100:\n\t            self.__score = score\n\t        else:\n\t            raise ValueError('Bad Score')\n\t\n\tstu = Student()\n\tstu.set_score(90)\n\tprint( stu.get_score() )\n\t```\n\t\n- `改进`：在操作逻辑层面，Python 还提供了更多特性，既直接 `调用变量的方式操作属性`，又不破坏数据的封装特性，`@property 装饰器` 的作用就在于此。\n\n\t```python\n\tclass Student(object):\n\n\t@property\n\tdef score(self):\n\t    return self.__score\n\n\t@score.setter\n\tdef score(self, value):\n\t    if not isinstance(value, int):\n\t        raise ValueError('Score must be an integer!')\n\t    if value < 0 or value > 100:\n\t        raise ValueError('score must between 0 ~ 100!')\n\t    self.__score = value\n\t    \n\tstu = Student()\n\tstu.score = 90 # 实际转化为 s.set_score(90)\n\tprint( stu.score ) # 输出 90\n\t```\n\n#### 多重继承\n- 继承是面向对象编程的一个重要的特性。通过继承，子类可以扩展父类的功能。\n- 在 Python 中，多实现多重继承，子类就可同时获得多个父类的所有功能。这种设计模式也叫 `MixIn`。\n\n\t> ⚠️ 同样是面向对象编程的语言，Java 只允许单继承，即一个类最多只能显示地继承于一个父类。当然，Java 要获得更多 “属性能力”，也可通过实现接口的方式实现。\n\t\n\t```python\n\t# 需求：我们赋予不同动物不同的能力\n\t\n\tclass Walking(object):\n\t    def walk(self):\n\t        print('Walking...')\n\t\n\tclass Swimming(object):\n\t    def swim(self):\n\t        print('Swimming...')\n\n\tclass Flying(object):\n\t    def fly(self):\n\t        print('Flying...')\n\t\n\t# 定义一双栖动物：通过继承父类，从而获得对应能力\n\tclass Amphibian(Walking, Swimming):\n\t    pass\n\t    \n\t# 定义一只天鹅：能走能飞能游泳\n\tclass Swan(Walking, Flying, Swimming):\n\t    pass\n\t```\n\n#### 定制类\n- 形如 `__xxx__` 的变量或者函数名在 Python 中是有特殊用途的。例如：`__slots__` 用于限制能绑定的属性，`__len__()` 方法返回对象本身的长度。\n\n\t除此之外，Python 的 class 中还有许多这样有特殊用途的 `属性` 和 `函数`，可帮助我们定制属性和定制类。\n\n#####  \\_\\_slots\\_\\_\n- 当我们创建一 class 实例后，可给该实例绑定 `任何` 属性和方法，这正体现了动态语言的灵活性。\n\n\t```python\n\tclass Student(object):\n\t    pass\n\t\n\t# 创建实例\n\tstu = Student()\n\t\n\t# 绑定属性\n\tstu.name = 'Bob'\n\tstu.score = 80\n\t\n\t# 绑定方法\n\tfrom types import MethodType\n\t\n\tdef setAge(self, age):\n\t    self.age = age\t\n\tstu.setAge = MethodType(setAge, stu) # 给实例绑定方法\n\tstu.setAge(25)\n\t\n\t# 上述方式只对本实例对象有效，若要所有实例对象起效，则需给 class 绑定方法\n\tdef setGrage(self, grade):\n\t    self.grade = grade\n\tStudent.setGrage = setGrage\n\t```\n\n- `动态绑定`：允许我们在程序运行的过程中动态给 class 添加功能 (方法)。\n- `限定实例的属性`：定义特殊变量 `__slots__`，可限制 class 实例能添加的属性。\n\t- 当子类定义了 slots 时，子类会继承父类的 slots，那么子类实例能添加的属性是子类与父类 slots 的 `并集`。\n\t- 当子类定义中没有 slots 时，父类的 slots 对子类不起作用。\n\n\t```python\n\tclass Student(object):\n\t    __slots__ = ('name', 'score', 'gender', 'age')\n\t    \n\tstu = Student()\n\tstu.email = 'admin@kofes.cn' # email 不在限定内，会报 AttributeError 错误\n\t```\n\n##### \\_\\_getattr\\_\\_\n- 正常情况下，当我们调用类的方法或属性，若不存在则会报错。例如定义 Student 类：\n\n\t```python\n\tclass Student(object):\n\t    def __init__(self):\n\t        self.name = 'Bob'\n        \n\tstu = Student()\n\tprint(stu.name) # 输出 Bob\n\tprint(stu.score) # 没有对应属性故会报 AttributeError 错误\n\t```\n\t\n- 要避免这个错误，除了补上 score 属性外，Python 还有另一个机制，即通过 `__getattr__()` 方法，动态返回一个属性。\n\n\t```python\n\tclass Student(object):\n\t    def __init__(self):\n\t        self.name = 'Bob'\n\t    def __getattr__(self, attr):\n\t        if 'score' == attr:\n\t            return 90\n\t            \n\t# 注意：只有在没有找到属性的情况下，才调用 __getattr__\n\t# 已有的属性，不会在 __getattr__ 中查找\n\tprint(stu.score) # 输出 90\n\t\n\t# 注意：若在 __getattr__ 也没有匹配属性，则返回 None\n\t# __getattr__ 默认返回 None\n\tprint(stu.age) # 输出 None\n\t```\n\t\n- 要让 class 只响应特定的几个属性，我们就要按照约定，抛出 `AttributeError` 错误即可：\n\n\t```python\n\tclass Student(object):\n\t    def __init__(self):\n\t        self.name = 'Bob'\n\t    def __getattr__(self, attr):\n\t        if 'score' == attr:\n\t            return 90\n\t        raise AttributeError(\n\t            '\\'Student\\' object has no attribute \\'%s\\'' % attr)\n\t```\n\t\n##### \\_\\_iter\\_\\_\n- 若想让一个类用于 `for ... in` 循环，类似 list 或 tuple 那样，就必须实现一个 `__iter__()` 方法，该方法返回一个 `迭代对象`，然后 Python 的 For 循环就会不断调用该迭代对象的 `__next__()` 方法拿到循环的下一个值，直到遇到 `StopIteration` 错误时退出循环。\n\n\t我们以斐波那契数列为例，写一个 Fib 类作用于 For 循环 ：\n\n\t```python\n\tclass Fib(object):\n\t    def __init__(self):\n\t        self.a, self.b = 0, 1 # 初始化两个计数器 a，b\n\t\n\t    # 方法重写\n\t    def __iter__(self):\n\t        return self # 实例本身就是迭代对象，故返回自己\n\t\t\n\t    # 方法重写\n\t    def __next__(self):\n\t        self.a, self.b = self.b, self.a + self.b # 计算下一个值\n\t        if self.a > 100000: # 退出循环的条件\n\t            raise StopIteration()\n\t        return self.a # 返回下一个值\n\t\n\t# Fib 实例作用于 For 循环：  \n\tfor n in Fib():\n\t    print(n)\n\t```\n\n- 对于定制类，我们让其实现了 `__iter__()` 和 `__next__()` 方法，那么它就是一个 `Iterator` 类型的，这正是动态语言的特性。  \n\n\t{% note success %}\n\t这种特性称为 `动态语言` 的 `鸭子类型`，动态语言并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。\n\t{% endnote %}\n\n##### \\_\\_call\\_\\_\n- 一个对象实例可以有自己的属性和方法，当我们调用实例方法时，使用 `instance.method()` 来调用。能不能直接在实例本身上调用呢？\n\n\t答案是可以的。任何类，只需要定义一个 `__call__()` 方法，就可以直接对实例进行调用。\n\t\n\t```python\n\tclass Student(object):\n\t    def __init__(self, name):\n\t        self.name = name\n\t    def __call__(self):\n\t        print('My name is %s.' % self.name)\n\t\n\t# 调用方式\n\tstu = Student('Bob')\n\tstu() # 输出 My name is Bob.\n\t```\n\n#####  更多定制\n- Python的 class 允许定义许多定制方法，让我们非常方便地生成特定的类。更多的定制方法请参考 Python 的官方文档：[Special Method Names](https://docs.python.org/3/reference/datamodel.html#special-method-names)。\n\n#### 使用枚举类\n- 在 Python 中，我们定义常量是采用 `约定俗成` 的方法来定义的，例如：`PI = 3.14159`。但其本质仍然是 `变量`。\n- 而本节介绍的枚举类，通过 `Enum` 定义一个 `class` 类型，然后，每个常量都是 class 的一个 `唯一实例`。例如：定义 `Month` 类型的枚举类。\n\n\t```python\n\tfrom enum import Enum\n\tMonth = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n\t    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))\n\t\n\tfor name, member in Month.__members__.items():\n\t    # value 属性：则是自动赋给成员的 int 常量，默认从 1 开始计数\n\t    print(name, '=>', member, ',', member.value)\n\t\n\t'''\n\t' 输出结果：\n\t' Jan => Month.Jan , 1\n\t' Feb => Month.Feb , 2\n\t' Mar => Month.Mar , 3\n\t' Apr => Month.Apr , 4\n\t' May => Month.May , 5\n\t' Jun => Month.Jun , 6\n\t' Jul => Month.Jul , 7\n\t' Aug => Month.Aug , 8\n\t' Sep => Month.Sep , 9\n\t' Oct => Month.Oct , 10\n\t' Nov => Month.Nov , 11\n\t' Dec => Month.Dec , 12\n\t'''\n\t\n\t# 当然，我们还可以这样访问枚举类\n\tprint( Month.Jan ) # 输出 Month.Jan\n\tprint( Month(1) ) # 输出 Month.Jan\n\tprint( Month['Jan'] ) # 输出 Month.Jan\n\tprint( Month.Jan.value ) # 输出 1\n\t```\n\t\n- 若有需求，我们可精确地控制枚举类型，即从 `Enum` 派生出自定义类：\n\n\t```python\n\tfrom enum import Enum, unique\n\n\t@unique\n\t# @unique 装饰器可以帮助我们检查保证没有重复值\n\tclass Weekday(Enum):\n\t    Sun = 0\n\t    Mon = 1\n\t    Tue = 2\n\t    Wed = 3\n\t    Thu = 4\n\t    Fri = 5\n\t    Sat = 6\n\t```\n\n### 错误/调试/测试\n\n#### 错误处理\n##### 返回错误码\n- 在操作系统提供的调用中，返回错误码非常常见。比如打开文件的函数 open()，成功时返回文件描述符 (就是一个整数)，出错时返回 `-1`。同理，我们设计函数时，也可相仿地设置返回代码。\n\n\t```python\n\tRESULT_OK = 0\n\tRESULT_FALSE = -1\n\t\n\tdef test():\n\t    if false:\n\t        return RESULT_FALSE\n\t    return RESULT_OK\n\t```\n\t\n##### 异常错误\n- 高级语言通常都内置了一套 `try...except...finally...` 的错误处理机制，Python 也不例外，使用方法见实例：\n\n\t```python\n\ttry:\n\t    result = 10 / int('2')\n\t    # result = 10 / 0\n\t    print('result:', result)\n\texcept ValueError as e:\n\t    # 抛出非数值异常错误\n\t    print('ValueError:', e)\n\texcept ZeroDivisionError as e:\n\t    # 抛出被除数为零的异常错误\n\t    print('ZeroDivisionError:', e)\n\telse:\n\t    # 若没有错误发生可在 except 语句块后加一个 else\n\t    # 当没有错误发生时，会自动执行else语句\n\t    print('no error!')\n\tfinally:\n\t    # 若设置了 finally 则一定会被执行，但可不设置 finally 语句\n\t    print('finally...')\n\t```\n\t\n- Python 的异常类型其实也是 class，所有的异常类型都继承自 BaseException，常见的错误类型和继承关系见：[Python. Exception hierarchy](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)\n\n\t故在使用 except 时需要注意的是：它不但捕获该类型的错误，还把其子类也 “一网打尽”，例如：\n\t\n\t```python\n\ttry:\n\t    foo()\n\texcept ValueError as e:\n\t    print('ValueError')\n\texcept UnicodeError as e:\n\t    print('UnicodeError')\n\t    \n\t# 假设 foo() 函数运行错误，则输出 \"ValueError\"\n\t# 第二个 except 永远也捕获不到 UnicodeError\n\t# 因为 UnicodeError 是 ValueError 的子类，即异常被第一个 except 给捕获了\n\t```\n\n##### 调用栈\n- 在函数嵌套调用中，若错误没有被捕获，它就会一直往上抛，直至被 Python 解释器捕获，并打印一个错误信息然后程序退出。因此当发生错误时，一定要分析错误的 `调用栈` 信息，定位错误的位置，找出 `错误根源`。\n\n\t```python\n\t# err.py\n\t# 定义函数\n\tdef foo(src):\n\t    return 10 / int(src)\n\tdef bar(src):\n\t    return foo(src) * 2\n\tdef main():\n\t    bar('0')\n\n\tmain() # 调用函数\n\n\t# 抛出异常错误，错误的跟踪信息如下：\n\tTraceback (most recent call last):\n\tFile \"err.py\", line 11, in <module>\n\t    main()\n\tFile \"err.py\", line 9, in main\n\t    bar('0')\n\tFile \"err.py\", line 6, in bar\n\t    return foo(s) * 2\n\tFile \"err.py\", line 3, in foo\n\t    return 10 / int(s)\n\tZeroDivisionError: division by zero\n\t```\n\n##### 抛出异常\n- 异常类型属于 class，捕获一个异常就是捕获到该 class 的一个实例。因此，异常并不是凭空产生而是 `有意` 创建并抛出的。Python 的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出异常。\n\n\t如果要抛出错误，首先根据需要定义一个异常的 class，并选择好继承关系，然后用 `raise` 语句抛出一个异常实例：\n\t\n\t```python\n\t# 只有在必要的时候才定义我们自己的错误类型\n\t# 尽量使用 Python 内置的错误类型，例如 ValueError，TypeError\n\tclass FooError(ValueError):\n\t    pass\n\n\tdef foo(s):\n\t    n = int(s)\n\t    if 0 == n:\n\t        raise FooError('invalid value: %s' % s)\n\t    return 10 / n\n\n\tfoo('0')\n\t```\n \n#### 调试\n- 推荐 IDE 调试，即设置断点、单步执行，就需要一个支持调试功能的 IDE。目前比较好的 Python IDE 有： `PyCharm` 和 `Eclipse vs pyDev`。\n\n#### 单元测试\n- 单元测试是用来对一个 `模块`、`函数` 或 `类` 来进行正确性检验的 `测试` 工作。\n- 这种以 `测试驱动` 的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的 `测试用例`。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。\n- 为了编写单元测试，我们需要引入 Python 自带的 `unittest` 模块。以下为一个 `单元测试` 的示例：\n\n\t```python\n\timport unittest\n\t\n\t# 继承unittest.TestCase\n\tclass MyTest(unittest.TestCase):  \n\t\n\t    # 每个测试用例执行之后做操作\n\t    def tearDown(self):\n\t        print('After each testcase...')\n\t        \n\t    # 每个测试用例执行之前做操作\n\t    def setUp(self):\n\t        print('Before each testcase...')\n\n\t    @classmethod\n\t    # 必须使用 @classmethod 装饰器，所有 test 运行完后运行一次\n\t    def tearDownClass(self):\n\t        print('After all testing...')\n\t        \n\t    @classmethod\n\t    # 必须使用 @classmethod 装饰器，所有 test 运行前运行一次\n\t    def setUpClass(self):\n\t        print('Before all testing...')\n\n\t    def testTestcaseA(self):\n\t        self.assertEqual(1, 1)  # 测试用例\n        \n\t    def testTestcaseB(self, elem1 = 'a', elem2 = 'A'):\n\t        self.assertEqual(elem1, elem2)  # 测试用例\n      \n\t# 一旦编写好单元测试就可运行单元测试，最简单的运行方式是在最后加上两行代码：\n\tif __name__ == '__main__':\n\t    unittest.main()\n\t```\n\n- 下面是一些常用的断言，也就是校验结果：\n\n\t```python\n\tassertEqual(a, b)\t\t# a == b\n\tassertNotEqual(a, b)\t\t# a != b\n\tassertTrue(x)\t\t\t# bool(x) is True\n\tassertFalse(x)\t\t\t# bool(x) is False\n\tassertIsNone(x)\t\t\t# x is None\n\tassertIsNotNone(x)\t\t# x is not None\n\tassertIn(a, b)\t\t\t# a in b\n\tassertNotIn(a, b)\t\t# a not in b\n\t```\n\n### 面向 I/O 编程\n- `I/O`：即输入/输出 ( Input/Output )。\n\n- `I/O 接口`：是 `主机` 与 `被控对象` 进行 `信息交换` 的纽带。例如，程序运行时数据是在内存中驻留的，由 CPU 来执行计算、控制，其中涉及到的数据交换则由磁盘、网络等实现。具体地，I/O 接口的功能就是负责选址、传送命令、传送数据等。\n\n- `I/O 编程`：`操作 I/O` 是由 `操作系统` 完成的，且操作系统会提供低级 `C 接口`，即对 I/O 操作进行 `封装`，高级语言通过调用 (函数) 的方式实现操作 I/O 的目的。Python 也不例外，即面向 I/O 接口编程。\n\n- 程序完成 I/O 操作会有 Input 和 Output 两个 `数据流`：\n\t- `Stream (流)` 是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。\n\t- `Input Stream` 就是数据从外面 (磁盘、网络) 流进内存，`Output Stream` 就是数据从内存流到外面去。\n\n- 需要知道的是，CPU 的速度远远快于磁盘、网络等 I/O。因此，代码操作 I/O 接口时速度是会产生不匹配的问题，而同步和异步的区别就在于是否等待 I/O 执行的结果，故 I/O 编程有分 `同步模型` 和 `异步模型`。\n\t- `同步 I/O`：在一个线程中，CPU 执行代码的速度极快，然而，一旦遇到 I/O 操作，如读写文件、发送网络数据时，就需要等待 I/O 操作完成才能继续进行下一步操作。\n\n\t\t> 引用廖老师的例子，同步 I/O 指：去麦当劳点餐，你说 “来个汉堡”，服务员告诉你，对不起，汉堡要现做需等 5 分钟，于是你站在收银台前面等了 5 分钟，当拿到汉堡再去逛商场。\n\t\n\t-  `异步 I/O`：当代码需要执行一个耗时的 I/O 操作时，它只发出 I/O 指令并不等待 I/O 结果，然后去执行其他代码。一段时间后，当 I/O 返回结果时，再通知 CPU 进行处理。\n\t\n\t\t> 异步 I/O 指：你说“来个汉堡”，服务员告诉你，汉堡需要等 5 分钟，你可以先去逛商场，等做好了我们再通知你，这样你可以立刻去干别的事情 (逛商场)，这是异步 I/O。\n\n\t- 同步 I/O 与 异步 I/O 模型的实现原理如图 6-10-1 所示：\n\n\t![图 6-10-1 同步 I/O 与 异步 I/O 模型的实现原理](/images/illustration/Programme/2018/09/life-is-short-we-need-python_6-10-1.png)\n\t<center>图 6-10-1 同步 I/O 与 异步 I/O 模型的实现原理</center>\n\n#### 存/取本地数据\n- 读写文件是最常见的 I/O 操作，Python 内置了读写文件的函数，用法和 C 是兼容的。\n- 在磁盘上读写文件的功能都是由操作系统提供的，即读写文件就是请求操作系统打开一个 `文件对象` (通常称为文件描述符)，通过操作系统提供的接口从这个文件对象中读取数据 (读文件)，或把数据写入这个文件对象  (写文件)。\n\n##### 读文件\n- `open()` 函数，传入文件名和标示符：\n\n\t```python\n\ttry:\n\t    # 以只读方式读入 test.txt 文件\n\t    file = open('/Users/kofe/test.txt', 'r', encoding='utf-8') \n\t    \n\t    # 若文件不存在，则抛出 IOError 的错误\n\t    # Traceback (most recent call last):\n\t    # File \"<stdin>\", line 1, in <module>\n\t    # FileNotFoundError: [Errno 2] No such file or directory: '...'\n\t    \n\t    # 若文件打开成功，调用 read() 方法可一次读取文件的全部内容\n\t    # Python 把内容读到内存，用一个 str 对象表示**\n\t    str = f.read()\n\tfinally:\n\t    if file:\n\t        f.close() # 文件使用完毕后必须关闭\n\t           \n\t# 当然，try...finally...  的写法实在太繁琐，故 Python 引入了 with 语句写法：\n\twith open('/Users/kofe/test.txt', 'r') as file:\n\t\tprint( file.read() )\n\t\n\t# 读取文件的方式：\n\t# read()：适合文件较小，可一次性读取文件\n\t# read(size)：若不能确定文件大小，通过反复调用读取文件\n\t# readlines()：若是读取配置文件，行读取最为方便\n\tfor line in f.readlines():\n\t    print(line.strip()) # 把末尾的 '\\n' 删掉\n\t```\n\n##### File-like Object\n- 要想操纵一个文件你需要使用 `open()` 函数打开文件，`open()` 函数返回一个 `类文件对象 (File-like Object)`，这就是这个文件在 python 中的抽象表示。除了 File 外，还可以是内存的字节流，网络流，自定义流等。\n- File-like Object 不要求从特定类继承，就如 [定制类.iter](http://localhost:4000/2018/09/life-is-short-we-need-python.html#iter) 章节所提及的 `鸭子类型`，只要我们让 `class` 实现 `read()` 方法，它就是 File-like Object。\n\n##### 二进制文件\n- 前面的操作是读取文本文件，且是 `UTF-8` 编码的文本文件。要读取二进制文件，例如图片、视频等，用 `rb` 模式打开文件即可：\n\n\t```python\n\tfile = open('/Users/kofe/test.jpg', 'rb')\n\tprint( file.read() )\n\t\n\t# 输出十六进制表示的字节：\n\tb'\\xff\\xd8\\xff\\x18Exif\\x00...'\t\n\t```\n\n##### 写文件\n- 写文件和读文件是一样的，唯一区别是调用 open() 函数时，传入标识符 `w` 或者 `wb` 表示写 `文本文件` 或 `写二进制文件`：\n\n\t```python\n\t# 写入文件后，务必要调用 f.close() 来关闭文件\n\t# 使用 Try...finally... ，或 With 语句的写法：\n\twith open('/Users/kofe/test.txt', 'w') as file:\n\tfile.write('Hello, world!')\n\t```\n\n- 所有模式的定义及含义可参考 Python 官方文档：[Built-in Functions.open()](https://docs.python.org/3/library/functions.html#open)\n\n<center>表 6-10-1 open() 函数操作文件的模式</center>\n\n| 标识符 | 描述 |\n| :---: | :--- |\n| r | 只读模式 (默认) |\n| w | 写入模式 (覆盖原文件) |\n| a |  追加模式 (文件存在则在文件尾部追加，反之则建立) |\n| b | 二进制格式 |\n| + | \t刷新打开的磁盘文件 (读与写) |\n\n#### StringIO/BytesIO\n> `StringIO` 和 `BytesIO` 是在内存中操作 str 和 bytes 的方法。\n\n##### StringIO\n- 数据读写不一定是文件，也可以在内存中读写。\n- StringIO 顾名思义就是在内存中读写 str。要把 str 写入 StringIO，我们需要先创建一个 StringIO，然后像文件一样写入：\n\n\t```python\n\tfrom io import StringIO\n\tfile = StringIO()\n\tfile.write('Welcome to\\n Python World!')\n\t\n\twhile True:\n\t    s = file.readline()\n\t    if '' == s:\n\t        break\n\t    print( s.strip() )\n\t \n\t# 输出结果：\n\tWelcome to\n\tPython World!\n\t```\n\n##### BytesIO\n- StringIO 操作的只能是 str，如果要操作二进制数据，就需要使用 BytesIO。\n- BytesIO 实现了在内存中读写 bytes。\n\n\t```python\n\tfrom io import BytesIO\n\tfile = BytesIO()\n\tfile.write( '中文'.encode('utf-8') )\n\tprint( file.getvalue() )\n\t\n\t# 写入的不是 str，而是经过 UTF-8 编码的 bytes：\n\tb'\\xe4\\xb8\\xad\\xe6\\x96\\x87'\n\t```\n\n#### 操作文件和目录\n- 若我们要操作文件、目录，可在命令行下面输入操作系统提供的各种命令来完成。例如 dir、cp 等命令。\n\n- 若要在 Python 程序中执行这些目录和文件的操作怎么办？其实 Python 内置的 `os` 模块，可以直接调用操作系统提供的 `接口函数`。\n\n\t```python\n\timport os\n\t\n\t# 现实操作系统类型\n\t# posix：Linux、Unix 或 Mac OS X\n\t# nt：Windows\n\tprint( os.name )\n\t```\n\n##### 环境变量\n- 在操作系统中定义的环境变量，全部保存在 `os.environ` 这个变量中，可直接查看：\n\n\t```python\n\timport os\n\n\t# 操作系统中定义的环境变量，全部保存在os.environ 变量中\n\tos.environ\n\t\n\t# 获取某个环境变量的值：os.environ.get('key')\n\tos.environ.get('PATH')\n\t```\n\n##### 操作文件和目录\n- 操作文件和目录的函数一部分放在 `os` 模块中，一部分放在 `os.path` 模块中。\n- 查看、创建和删除目录可以这么调用：\n\n\t```python\n\t# 查看当前目录的绝对路径\n\tos.path.abspath('.')\n\t\n\t# 在某个目录下创建一个新目录 (首先把新目录的完整路径表示出来)\n\tos.path.join('/Users/kofe', 'testdir')\n\t# 然后创建一个目录\n\tos.mkdir('/Users/michael/testdir')\n\t\n\t# 删掉一个目录\n\tos.rmdir('/Users/kofe/testdir')\n\t\n\t# 把两个路径合成一个时，不要直接拼字符串，而要通过 os.path.join() 函数\n\t# 同理，要拆分路径时，也不要直接去拆字符串，而要通过 os.path.split() 函数\n\tos.path.split('/Users/kofe/testdir/file.txt')\n\t('/Users/kofe/testdir', 'file.txt') # 返回一个元组 Tuple \n\n\t# 例如：os.path.splitext() 可直接让你得到文件扩展名\n\tos.path.splitext('/path/to/file.txt')\n\t('/path/to/file', '.txt') # 返回一个元组 Tuple \n\t```\n\t\n- 文件操作：\n\n\t```python\n\t# 对文件重命名\n\tos.rename('test.txt', 'test.py')\n\t\n\t# 删掉文件\n\tos.remove('test.py')\n\t\n\t# 然而在 os 模块中没有关于复制的函数\n\t# 借助 shutil 模块提供了copyfile() 的函数实现复制 (os 模块的补充)\n\t```\n\t\n- 利用 Python 的特性操作文件或目录：\n\n\t```python\n\t# 列出当前目录下的所有目录\n\t[x for x in os.listdir('.') if os.path.isdir(x)]\n\t```\n\n#### 序列化\n- 在程序运行期间，变量都是在内存中存放的。当 `程序结束`，变量所占用的内存将被操作系统 `全部回收`。若在程序运行期间，有需求保存 `变量` 或者 `对象` 的 `数据` 和 `状态信息`，以待下次启动程序时可直接加载该变量或对象。\n- `序列化`：将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。\n- `反序列化`：可通过从存储区中读取或反序列化对象的状态，重新创建该对象。\n- 在 Python 中，序列化称为 `pickling`，在其他语言中也被称为 `serialization`、`marshalling`、`flattening` 等。Python 提供了 `pickle` 模块来实现序列化。\n\n\t```python\n\timport pickle\n\t\t\n\tdict = {'name': 'Bob', 'age': 25, 'score': 90}\n\t\n\t### Case.01. 对象/变量 => Bytes => File 文件\n\t\n\t# dump() 将序列化后的对象 obj 以二进制形式写入文件 file 中\n\twith open('./dump.txt', 'wb') as file:\n\t    pickle.dump(dict, file)\n\t# load() 将序列化的对象从文件 file 中读取出来\n\twith open('./dump.txt', 'rb') as file:\n\t    dict = pickle.load(file)\n\t\n\t### Case.02. 对象/变量 => Bytes\n\t\n\t# dumps() 方法不需要写入文件中，可直接返回一个序列化的 bytes 对象\n\tdump = pickle.dumps(dict)\n\t# loads() 则可直接读取一个序列化的 bytes 对象\n\tdict_sub = pickle.loads(dump) \n\t```\n\n#### JSON 基础\n- `引入`：Pickle 的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于 Python，且可能不同版本的 Python 彼此都不兼容。\n\n\t若我们要在不同的编程语言之间传递对象，就必须把 `对象序列化为标准格式`，例如 XML，但 XML 需要解析读取。但更好的方法是序列化为 JSON，因为 JSON 表示出来就是一个 `字符串`，可以被所有语言读取，且方便地存储到磁盘或者通过网络传输。\n\t\n- `JSON` 表示的对象就是标准的 `JavaScript` 语言的对象，JSON 和 Python 内置的数据类型对应如下：\n\n<center>表 6-10-2 JSON 类型与 Python 类型的数据类型对应表</center>\n\n| JSON 类型 | Python 类型 |\n| :---: | :---: |\n| {} | dict |\n| [] | list |\n| \"String\" | str |\n| 10 / 3.14159 | int / float |\n| true / false | True / False |\n| null | None |\n\n-  Python 内置的 `json` 模块提供了非常完善的 Python 对象到 JSON 格式的转换：\n\n\t```python\n\timport json\n\tdict = {'name': 'Bob', 'age': 25, 'score': 90}\n\t\n\t# dump() 方法可以直接把 JSON 写入一个 File-like Object\n\t# dumps() 方法返回一个字符串，内容就是标准的 JSON\n\tjson_str = json.dumps(dict)\n\t\n\t# load() 方法从一个 File-like Object 中直接反序列化出对象\n\t# loads() 把 JSON 的字符串反序列化为 Python 对象\n\tjson_str = '{\"name\": \"Bob\", \"age\": 25, \"score\": 90}'\n\tjson.loads(json_str)\n\t```\n\t\n- 由于 JSON 标准规定 JSON 编码是 `UTF-8`，所以我们总是能正确地在 Python 的 str 与 JSON 的字符串间转换。\n\n#### JSON 进阶\n- Python 的 `dict = {'key': value}` 对象可直接序列化为 JSON 的 `{\"key\": value}`。但一般情况，我们常用 class 表示对象 ( 例如 `Student` 类 )，再序列化该对象：\n\n\t```python\n\timport json\n\n\tclass Student(object):\n\t    def __init__(self, name, age, score):\n\t        self.name = name\n\t        self.age = age\n\t        self.score = score\n\t\n\t# 运行代码，将会报 TypeError 错误\n\tstu = Student('Bob', 25, 90)\n\tprint(json.dumps(stu))\n\t```\n\n- 造成上述错误的原因是：Student 对象不是一个可序列化为 JSON 的对象。\n\t\n\t其实，仔细观察 `dumps()` 的参数列表，可以发现除了第一个必须的 `obj` 参数外，`dumps()` 方法还提供了一大堆的 [可选参数](https://docs.python.org/3/library/json.html#json.dumps)，这些可选参数可让我们来定制 JSON 序列化：\n\n\t```python\n\t# 默认情况下 dumps() 不知道如何将 Student 实例变为 JSON 的 {\"key\": value}\n\t# 我们只需为 Student 实例专门写一个转换 (组装) 函数\n\tdef student2dict(std):\n\t    return {\n\t        'name': std.name,\n\t        'age': std.age,\n\t        'score': std.score\n\t    }\n\t\n\t# 这样，Student 实例首先被 student2dict() 函数转换成 dict，再被序列化为 JSON\n\tprint( json.dumps(stu, default = student2dict) )\n\t```\n\t\n- 当然，若我们遇到一个 Teacher 类的实例，照样无法序列化为 JSON。其实可以通过一种 `通用方法` 将任意 class 的实例变为 dict。\n\n\t通常 class 的实例都有一个 `__dict__` 属性，它本身一个 `dict`，用来存储实例变量。也有少数例外，比如定义了 `__slots__` 的 class。\n\n\t```python\n\tprint( json.dumps(s, default = lambda obj: obj.__dict__) )\n\t```\n\n- 同理，我们需要把 JSON 反序列化为一个 Student 实例对象，`loads()` 方法首先转换出一个 `dict` 对象，然后我们传入的 [object_hook](https://docs.python.org/3/library/json.html#json.load) 函数，其负责把 dict 转换为 Student 实例对象。\n\n\t```python\n\tdef dict2student(d):\n\t    return Student( d['name'], d['age'], d['score' ])\n\t    \n\tjson_str = '{\"age\": 25, \"score\": 90, \"name\": \"Bob\"}'\n\tprint( json.loads(json_str, object_hook = dict2student) )\n\t```\n\n#### 同步 I/O\n- 在本章引言部分已讲述 同步 I/O 与 异步 I/O 模型的区别，同步模型即按普通顺序写执行代码：\n\n\t```python\n\tdo_some_code()\n\tfile = open('/path/file.txt', 'r')\n\t\n\t# 线程停在此处等待 I/O 操作结果\n\tr = file.read() \n\t\n\t# I/O 操作完成后线程才能继续执行\n\tdo_some_code(r)\n\t```\n\n#### 异步 I/O\n- 在 I/O 操作过程中，由于一个 I/O 操作阻塞了当前线程，导致其他代码无法执行，故我们可使用多线程或者多进程来 `并发` 执行代码。然而，我们通过 `多线程和多进程` 的模型解决了 `并发` 问题，但现实情况是系统不能无上限地增加线程，因为系统切换线程的开销很大，一旦线程数量过多，CPU 花在线程切换上的时间就增多，则导致性能严重下降的结果。\n\t\n\tCPU 高速执行能力和 I/O 设备的读写速度严重不匹配导致线程阻塞。多线程和多进程只是解决这一问题的一种方法，而另一种解决 I/O 问题的方法就是异步 I/O。\n\n- `异步 I/O 模型` 需要一个 `消息循环`。在消息循环中，主线程不断地重复 `读取消息 / 处理消息` 这一过程：\n\n\t```python\n\tloop = get_event_loop()\n\twhile True:\n\t    event = loop.get_event()\n\t    process_event(event)\n\t```\n\n##### 协程\n> 在开始异步 I/O 模型学习前，我们先来了解 `协程` 的概念。\n\n- 协程 ( Coroutine )，又称微线程、纤程。协程不是进程或线程，其执行过程更 `类似于` 子程序，或者说 `不带返回值的函数调用`。  \n\n\t例如：A 调用 B，B 中又调用了 C。C 执行完毕返回，B 执行完毕返回，最后是 A 执行完毕。\n\n\t- 子程序调用是通过栈实现的，`一个线程` 就是执行 `一个子程序`。子程序调用总是 `一个入口`，`一次返回`，且 `调用顺序是明确的`。\n\n\t- 而协程的调用和子程序是不同的。协程看上去也是子程序，但在执行过程中，`调用顺序不固定`，在子程序内部可中断转而执行别的子程序，在适当的时再返回来接着执行原子程序。\n\t\n\t```python\n\tdef A():\n\t    print('1')\n\t    print('2')\n\n\tdef B():\n\t    print('x')\n\t    print('y')\n\t    \n\t# 若由协程执行，在执行 A 的过程中可随时中断去执行 B\n\t# B 也可能在执行过程中中断再去执行 A，则执行结果有：\n\t1\n\tx\n\ty\n\t2\n\t```\n\t\n- 从上述例子结果可看出，A、B 的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？\n\n\t- `协程极高的执行效率`：因为子程序切换不是线程切换，而是由程序自身控制。因此，没有线程切换的开销，和多线程相比，线程数量越多协程的性能优势就越明显。\n\n\t- `不需要多线程的锁机制`：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，故执行效率相对多线程要高。\n\n- 因为协程是一个线程执行，是否可利用多核 CPU 获得更高的性能，若方案可行的话如何操作？最简单的方法是 `多进程` + `协程`，既充分利用多核，又充分发挥协程的高效率。\n\n- Python 对协程的支持是通过 `generator` 实现的，例如：\n\t- 传统 `生产者 - 消费者` 模型是：一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但有很大机率出现 `死锁`。\n\t- 若改用协程，生产者生产消息后，直接通过 `yield` 跳转到消费者开始执行，待消费者执行完毕后切换回生产者继续生产。\n\n\t```python\n\tdef consumer():\n\t    result = ''\n\t    while True:\n\t        # Step.03. consumer 通过 yield 取消息并处理，再通过 yield 把结果回传\n\t        n = yield result\n\t        print('[CONSUMER] Consuming %s...' % n)\n\t        result = 'OK:' + str(n) # result 可能是 I/O 操作或耗时任务\n\n\tdef produce(c):\n\t    # Step.01. 首先调用 c.send(None) 启动生成器\n\t    c.send(None)\n\t    n = 0\n\t    while n < 5:\n\t        n = n + 1\n\t        print('[PRODUCER] Producing %s...' % n)\n\t        # Step.02. 当产生了东西后，通过 c.send(n) 切换到 consumer 执行\n\t        result = c.send(n)\n\t        # Step.04. produce 拿到 consumer 的处理结果，(或) 继续生产下条消息\n\t        print('[PRODUCER] Consumer return: %s' % result)       \n\t    # Step.05. produce 决定不生产了，通过 c.close() 关闭 consumer，整个过程结束\n\t    c.close()\n\n\t# 函数调用\n\tcons = consumer()\n\tproduce(cons)\n\t\n\t# 输出结果\n\t[PRODUCER] Producing 1...\n\t[CONSUMER] Consuming 1...\n\t[PRODUCER] Consumer return: OK:1\n\t[PRODUCER] Producing 2...\n\t[CONSUMER] Consuming 2...\n\t[PRODUCER] Consumer return: OK:2\n\t[PRODUCER] Producing 3...\n\t[CONSUMER] Consuming 3...\n\t[PRODUCER] Consumer return: OK:3\n\t```\n\n##### Asyncio\n- `asyncio` 是 `Python 3.4` 版本引入的标准库，直接内置了对异步 I/O 的支持。\n- `asyncio` 的编程模型是一个 `消息循环`。我们从 asyncio 模块中直接获取一个 `EventLoop` 的引用，然后把需要执行的协程扔到 EventLoop 中执行，就实现了异步 I/O，具体操作实例：\n\t- `@asyncio.coroutine` 把一个 `generator` 标记为 `coroutine` 类型，然后，我们就把这个 coroutine 扔到 EventLoop 中执行。\n\t- `hello()` 会首先打印出 `Hello world!`。然后，`yield from` 语法可以让我们方便地调用另一个 generator。由于 `asyncio.sleep()` 也是一个 `coroutine`，所以线程不会等待 `asyncio.sleep()`，而是直接中断并执行下一个消息循环。当 `asyncio.sleep()` 返回时，线程就可以从 `yield from` 拿到返回值 ( 此处是 None )，然后接着执行下一行语句。\n\n\t\t> 若我们把 asyncio.sleep(1) 看成是一个耗时一秒的 I/O 操作。在此期间，主线程并未等待，而是去执行 EventLoop 中其他可以执行的 coroutine，因此实现了 `并发执行`。\n\n\t```python\n\timport asyncio\n\n\t@asyncio.coroutine\n\tdef hello():\n\t    print(\"Hello world!\")\n\t    # 异步调用 asyncio.sleep(1):\n\t    r = yield from asyncio.sleep(1)\n\t    print(\"Hello again!\")\n\n\t# 获取 EventLoop\n\tloop = asyncio.get_event_loop()\n\t# 执行 coroutine\n\tloop.run_until_complete(hello())\n\tloop.close()\n\t```\n\t\n- `举一反三`：我们尝试用 Task 封装两个 coroutine：\n\n\t```python\n\timport threading\n\timport asyncio\n\n\t@asyncio.coroutine\n\tdef hello():\n\t    print('Hello world! (%s)' % threading.currentThread())\n\t    yield from asyncio.sleep(1)\n\t    print('Hello again! (%s)' % threading.currentThread())\n\n\tloop = asyncio.get_event_loop()\n\ttasks = [hello(), hello()]\n\tloop.run_until_complete(asyncio.wait(tasks))\n\tloop.close()\n\t\n\t# 输出结果\n\t# 由打印当前线程名称可看出，两个 coroutine 由同一个线程并发执行的\n\tHello world! (<_MainThread(MainThread, started 140735195337472)>)\n\tHello world! (<_MainThread(MainThread, started 140735195337472)>)\n\t(暂停约 1 秒)\n\tHello again! (<_MainThread(MainThread, started 140735195337472)>)\n\tHello again! (<_MainThread(MainThread, started 140735195337472)>)\n\t```\n\t\n- `具体应用场景`：我们 asyncio 的异步网络连接来获取 sina、sohu 的首页。\n\n\t```python\n\timport asyncio\n\n\t@asyncio.coroutine\n\tdef wget(host):\n\t    print('wget %s...' % host)\n\t    connect = asyncio.open_connection(host, 80)\n\t    reader, writer = yield from connect\n\t    header = 'GET / HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n' % host\n\t    writer.write(header.encode('utf-8'))\n\t    yield from writer.drain()\n\t    while True:\n\t        line = yield from reader.readline()\n\t        if line == b'\\r\\n':\n\t            break\n\t        print('%s header > %s' % (host, line.decode('utf-8').rstrip()))\n\t    # Ignore the body, close the socket\n\t    writer.close()\n\n\tloop = asyncio.get_event_loop()\n\ttasks = [wget(host) for host in ['www.sina.com.cn', 'www.sohu.com']\n\tloop.run_until_complete(asyncio.wait(tasks))\n\tloop.close()\n\t\n\t# 输出结果\n\twget www.sohu.com...\n\twget www.sina.com.cn...\n\t(打印出sohu的header)\n\twww.sohu.com header > HTTP/1.1 200 OK\n\twww.sohu.com header > Content-Type: text/html\n\t...\n\t(打印出 sina 的 header)\n\twww.sina.com.cn header > HTTP/1.1 200 OK\n\twww.sina.com.cn header > Date: Wed, 20 May 2015 04:56:33 GMT\n\t...\n\t```\n\n##### Async / Await\n- 用 asyncio 提供的 @asyncio.coroutine 可把一个 generator 标记为 coroutine 类型，然后在 coroutine 内部用 yield from 调用另一个 coroutine 实现异步操作。\n- 为简化并更好地标识异步 I/O，从 `Python 3.5` 开始引入了新语法 `async` 和 `await`，可以让 `coroutine` 的代码更简洁易读。请注意，async 和 await 是针对 coroutine 的新语法，即只需要做两步简单的替换：\n\t- 把 `@asyncio.coroutine` 替换为 `async`；\n\t- 把 `yield from` 替换为 `await`.\n\n\t```python\n\t# asyncio 原语法书写\n\t@asyncio.coroutine\n\tdef hello():\n\t    print(\"Hello world!\")\n\t    result = yield from asyncio.sleep(1)\n\t    print(\"Hello again!\")\n\t    \n\t# 用新语法重新编写\n\tasync def hello():\n\t    print(\"Hello world!\")\n\t    result = await asyncio.sleep(1)\n\t    print(\"Hello again!\")\n\t    \n\t# 剩下的代码保持不变\n\t```\n\n##### Aiohttp\n- asyncio 可实现单线程并发 I/O 操作。若仅用在客户端，发挥的威力不大。若在服务器端，例如Web服务器，由于HTTP连接就是 I/O 操作，因此可以用 `单线程 + coroutine` 实现多用户的高并发支持。\n\n\tasyncio 实现了 TCP、UDP、SSL 等协议，`aiohttp` 则是基于 asyncio 实现的 HTTP 框架。\n\n## 参考资料\n- \\[1\\] [Eddie Woo. The RSA Encryption Algorithm. 2017. bilibili.com](https://www.bilibili.com/video/av10742893?from=search&seid=163310817147442185)  \n- \\[2\\] [John cui. 轻松学习RSA加密算法原理. 2018. jianshu.com](https://www.jianshu.com/p/3221e07d3310)  \n- \\[3\\] [廖雪峰. Python 教程. 2018. liaoxuefeng.com](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000)  \n- \\[4\\] [Dean J, Ghemawat S. MapReduce: simplified data processing on large clusters [J].  \nCommunications of the ACM, 2008, 51(1): 107-113.](https://dl.acm.org/citation.cfm?id=1327492)  \n- \\[5\\] [Wes McKinney. 利用 Python 进行数据分析 [M]. 机械工业出版社, 2013](https://book.douban.com/subject/25779298/)  \n- \\[6\\] [Python. The Python Standard Library. python.org](http://docs.python.org/3/library/functions.html) \n- \\[7\\] [渐行渐远silence. Windows 下多版本 Python 安装与 pip 安装和 pip 使用. 2017. csdn.net](https://blog.csdn.net/silence2015/article/details/56483892)","tags":["爬虫"],"categories":["Programme"]},{"title":"项目 | SVN 环境搭建与使用","url":"%2F2018%2F08%2Fbuilding-a-svn-server.html","content":"\n最近有机会接触到公司的新项目，对于多人参与的项目，此刻才感受到 `源代码版本控制` 的重要性。遗憾之余，为了加深理解和复用起见，本文将从 `搭建`、`配置` 和 `使用` 多方面总结 SVN ( Subversion，开放源代码的版本控制系统 )。\n\n当然，版本控制的工具有很多，比如 CVS、GIT、SVN。CVS 几乎淘汰；GIT 适合开源软件项目；SVN 适合企业内部由项目经理统一协调的多个并行项目的开发。考虑到种种因素，我们不能单方面评论每种版本控制工具的优劣，故选择哪款版本控制工具视具体情况而定。\n\n<!-- More -->\n\n## 源代码管理\n\n> 介绍参考了资料 [1]。 \n\n### 管理的意义\n- 目的：为了解决在软件开发过程中，由源代码引发的各种繁琐的问题。\n- 作用：\n\t- 能追踪一个项目从诞生一直到定案的过程；\n\t- 记录一个项目的所有内容变化，方便地查阅特定版本的修订情况.\n- 常见问题：\n\t- **代码冲突**：多人操作同一个文件 ( 团队开发中的常见问题 )；\n\t- 版本备份：费空间 ( 大数据时代，储存成本反而最 \"廉价\" )；\n\t- 权限控制：无法对源代码进行精确的权限控制；\n\n### 管理的工具\n- CVS：历史悠久，现在几乎没人使用。\n- SVN：\n\t- 集中式版本控制的代表；\n\t- CVS 的接班人，速度和功能比 CVS 有很大幅度提升.\n- GIT：\n\t- 分布式源代码管理工具；\n\t- 目前被大多数开源项目使用。\n\n## SVN 概念概述\n- `Subversion` 的简称为 SVN，是一个开放源代码的版本控制系统；\n- SVN 用于多个人共同开发同一个项目，目的是为了资源共享共用；\n- SVN 服务器有 2 种 `运行方式`：独立服务器和借助 Apache。两种方式各有利弊，可自行选择。\n- SVN `存储版本数据` 也有 2 种方式：`Berkeley DB` ( 事务安全型表类型 ) 和 `FSFS` ( 不需要数据库的存储系统 )。因为 Berkeley DB 方式在服务器中断时，有可能锁住数据，故选择 FSFS 的存储方式会更安全一点。\n\n## SVN 环境搭建\n\n### SVN 服务器\n- 安装 SVN Server For `Windows`：[VisualSVN Server](https://www.visualsvn.com/server/download/) \n\n\t配置是通过界面操作完成的，具体安装流程就不阐述了，可参考引用文章完成配置 $^{[1,2]}$。\n\n\t> Tips.01. 安装过程中，其中 SVN 服务器端口配置推荐使用HTTPS 的 `8443` 端口，因为 HTTPS 安全性比較高，尽管 `443` 是标准 HTTPSport。  \n\t> Tips.02. 还有就是用于验证的身份配置：Windows 验证和 Subversion 身份验证，默认是 Subversion 身份验证。\n\n- 安装 SVN Server For `MacOS`：MacOS 自带了 SVN 的服务器端和客户端功能。参考引用文章完成配置即可使用 $^{[3,4]}$。\n\n### SVN 客户端\n- Windows Client：[TortoiseSVN](https://tortoisesvn.net/downloads.html)\n- MacOS Client：[Cornerstone](https://cornerstone.assembla.com/)\n\n\t> 在 MacOS 上可利用 SVN 图形界面工具来管理源代码，可以大大减小使用命令行的痛苦 $^{[5]}$。\n\n### SVN 配置与使用\nWindows 端配置和使用 SVN，可通过图形界面工具即可完成操作，详细的步骤在引用文章 [1]、[2] 中也有提及。故在本章节主要讲述 `Mac` 环境下搭建和配置 SVN。\n\n#### SVN 服务端配置\n\n##### 创建代码仓库\n- Step.01. 新建一个 `svn` 目录，例如 `/Users/kofe/svn`，以后可在 `svn` 目录下创建多个仓库目录。\n- Step.02. 打开终端，创建一个名为 `idea` 仓库，输入指令：\n\n\t```bash\n\t# 指令执行成功后，会发现硬盘上多了个 /Users/kofe/svn/idea 目录\n\tsvnadmin create /Users/kofe/svn/idea\n\t```\n\n##### 配置用户权限\n主要是修改 `/svn/idea/conf` 目录下的三个文件：`svnserve.conf`、`Passwd` 文件和 `Authz` 文件。\n\n- svnserve.conf\n\n\t```bash\n\t# anon-access = read 代表匿名访问的时候是只读的\n\t# anon-access = none 代表禁止匿名访问，需要帐号密码才能访问\n\tanon-access = read\n\tauth-access = write\n\tpassword-db = passwd\n\tauthz-bd = authz\n\t```\n\n- Passwd 文件：在 `[users]` 下面添加账号和密码。\n\n\t```bash\n\t[users]\n\t# 格式：账号 = 密码\n\tkofe = 123456\n\tlucy = 123456\n\t```\n\n- Authz 文件：配置用户组和权限我们可以将在 Passwd 里添加的用户分配到不同的用户组里。以后就可对不同用户组设置不同的权限，没有必要对每个用户进行单独设置权限。即在 `[groups]` 下面添加组名和用户名，多个用户之间用逗号 **,** 隔开。\n\n\t```bash\n\t[groups] \n\tusergroup = kofe, lucy # 格式：组名 = 用户1, 用户2, ...\n\n\t# 使用 [/] 代表 SVN 服务器中的所有资源库\n\t# 某个组有读写权限\n\t[/]\n\t@usergroup = rw\n\n\t# 使用 [/] 代表 SVN 服务器中的所有资源库\n\t# 某个用户有读写权限\n\t# lucy = rw\n\t```\n\n##### 启动关闭服务\n- 在终端输入下列指令：若没有任何提示，恭喜你启动成功。\n\n\t```bash\n\tsvnserve -d -r /Users/kofe/svn\n\t# 或输入: svnserve -d -r /User/kofe/svn/idea\n\t```\n\n- 当然，会启用也要会关闭 SVN 服务器，特别是首次配置完 SVN 服务器需要重启。  \n\tCase.01. 在 `活动监视器` 中搜索 `svn`, 在列表中找到进程 `svnserve`, 点击左上角的`强制退出进程`。  \n\tCase.02. 或者可通过 shell 脚本实现一键关闭。  \n\t\n\t```bash\n\t#!/bin/sh\n\techo \"Current Process List:\"\n\techo \"= = = = = = = = = = =\"\n\tps -A | grep svn\n\techo \"= = = = = = = = = = =\"\n\tkill `pgrep \"svn\"`\n\n\techo \"Kill successfully!\" Current Process Status:\n\techo \"= = = = = = = = = = = = = = = = = = = = = =\"\n\tps -A | grep svn\n\techo \"= = = = = = = = = = = = = = = = = = = = = =\"\n\t```\n\n#### SVN 客户端操作\n\n##### 代码版本控制\n> 当然，充分利用 SVN 图形界面工具 ( [Cornerstone](https://cornerstone.assembla.com/) ) 来管理源代码，可大大减小使用命令行的痛苦，提升使用效率。\n\n- 首次导入工程文件到 SVN 服务器：\n\n\t```bash\n\t# /Users/kofe/procedure/idea/SSM_DEMO，指的是需要导入的工程文件\n\t# svn://localhost/idea 指把工程文件上传到 idea 目录下\n\t# --username=admin --password=123456 指的是校验用户名和密码\n\t# -m \"初始化导入\" 指的是提交的信息注释\n\tsvn import /Users/kofe/procedure/idea/SSM_DEMO svn://localhost/idea --username=kofe --password=123456 -m \"初始化导入\"\n\t```\n\n- 从 SVN 服务器下载工程文件到本地 ( Checkout )：\n\n\t```bash\n\tsvn checkout svn://localhost/idea --username=kofe --password=123456 /Users/kofe/procedure/idea\n\t```\n\t\n- 二次提交代码到服务器：二次提交是有一个前提的, 那就是你首先需要在 SVN服务器上下载代码到本地，然后再去修改这一份代码, 才能够二次提交。\n\n\t```bash\n\tcd /Users/kofe/procedure/idea\n\tsvn commit -m \"修改部分代码 (注释修改的内容)\"\n\t```\n\t\n- SVN 基本操作原理：\n\t- `svn checkout`：将服务器代码完整下载到本地。\n\t- `svn update`：将服务器最新的代码下载到本地。\n\t- `svn commit`：将本地修改的内容提交到服务器。\n\n\t![图3-1SVN 基本操作原理](/images/illustration/Project/2018/08/building-a-svn-server_3-1.png)\n<center>图 3-1 SVN 基本操作原理</center>\n\n##### 代码版本冲突\n- 版本冲突原因：\n\n\t假设 A、B 两用户都在版本号为 100 时更新了 `sample.txt` 文件，A 用户在修改完成之后提交 sample.txt 到服务器，这个时候提交成功，这个时候 sample.txt 文件的版本号已经变成 101 了。同时 B 用户在版本号为 100 的 sample.txt 文件上作修改，修改完成之后提交到服务器时，由于不是在当前最新的 101 版本上作的修改，所以导致提交失败。\n\n- 版本冲突现象：\n\n\t冲突发生时，SVN 会在当前工作目录中保存所有的目标文件版本 [ 上次更新版本、当前获取的版本 ( 即别人提交的版本 )、自己更新的版本、目标文件 ]。  假设文件名是 `sample.txt` ，对应的文件名分别是 ( 同时在目标文件中标记来自不同用户的更改 )：\n\n\t```bash\n\tsample.txt.r101\n\tsample.txt.r102\n\tsample.txt.mine\n\tsample.txt\n\t```\n\t\n- `手工合并` SVN 冲突 $^{[6]}$，开始的时候让人觉得害怕，但有规律可循。例如有以下文本：\n\n\t```java\n\tMayonnaise\n\tLettuce\n\tTomato\n\tProvolone\n\t<<<<<<<.mine\n\tSalami\n\tMortadella\n\tProsciutto\n\t=======\n\tSauerkraut\n\tGrilledChicken\n\t>>>>>>>.r2\n\t```\n\n\t一连串的大于、小于、等于号是 SVN 冲突标记，这些数据得全部删除才可以提交。在 SVN 冲突区中，或许你需要和你的同事沟通来安排冲突区的文本内容，待所有冲突区得到合理的解决之后方可再提交文件。\n\n\t```java\n\t// 是你在冲突区里面做的修改\n\t<<<<<<<.mine\n\tSalami\n\tMortadella\n\tProsciutto\n\t=======\n\n\t// 是别人在冲突区做的修改\n\tSauerkraut\n\tGrilledChicken\n\t>>>>>>>.r2\n\t```\n\t\n- 如何降低冲突解决的复杂度：\n\t- 在提交时写上明确的 Message ( 注释 )，方便以后查找用户更新的原因。\n\t- 养成良好的使用习惯，使用 SVN 时每次都是先提交，后更新。每天 `早上` 打开后，首先要从版本库 `获取最新版本`，每天 `下班前` 必须将已经编辑过的文档都 `提交` 到版本库。\n\n## 参考资料 \n\\[1\\] [PhelanGeek. SVN 服务器搭建教程. jianshu.com. 2016](https://www.jianshu.com/p/96f2db36044b)  \n\\[2\\] [RealLiuNing. Windows 10 搭建独立 SVN 服务器. jianshu.com. 2018](https://juejin.im/post/5b0e50f5f265da08ec33b74e)  \n\\[3\\] [CainLuo. 搭建 MacOS 本地 SVN 服务器. juejin.im. 2016](https://juejin.im/post/58209be1a0bb9f0058c08452)  \n\\[4\\] [Sunny Fight. iOS 版本控制 SVN (Mac 环境下 SVN 的使用). jianshu.com. 2016](https://www.jianshu.com/p/66f085556fb2)  \n\\[5\\] [天蓝. SVN 在 Mac 上使用 Xcode+Cornerstone. jianshu.com. 2017](https://www.jianshu.com/p/650342b0a0ce)  \n\\[6\\] [aaronGao. svn conflict 冲突解决. cnbologs.com. 2016](https://www.cnblogs.com/aaronLinux/p/5521844.html)","tags":["版本控制"],"categories":["Project"]},{"title":"框架 | Java EE 之 SSM 框架配置与使用","url":"%2F2018%2F08%2FJ2EE-SSM-1.html","content":"\n本文章主要围绕 J2EE 中 SSM ( Spring、Spring MVC、MyBatis ) 框架的配置以及使用问题展开学习的，最终目的是输出可复用的版本，以供后续的项目复用。当然，学习和配置的过程难免有不恰当或错误之处，还望朋友指出、斧正。\n\n<!-- More -->\n\n## 更新进度\n- 2018.08.13：完成初稿，梳理 SSM 框架初识章节；\n- 2018.08.20：框架内容，梳理 SSM 框架基本内容；\n- 2018.08.24：框架内容，修正 SSM 框架部分内容；\n- 2018.08.26：框架内容，整合 Spring 和 MyBatis；\n\n## 教学资源\n- 视频 | [黑马程序员. J2EE 进阶. MyBatis 框架由浅入深. 2017. bilibili.com](https://www.bilibili.com/video/av20394903)\n\n\t> 本框架的学习笔记是基于此系列教学视频所得的。\n\t\n- 文章 | [吴操. 搭建一个基于 SSM 框架的人力资源管理系统. 2018. csdn.net](https://blog.csdn.net/noaman_wgs/article/details/79503559)\n\n\t> 发现这位博主搭建的例子 ( [nomico271. SSM_HRMS. Github](https://github.com/nomico271/SSM_HRMS) ) 紧凑、简练，适合初入门时来模仿构建自己的项目。\n\n## IDE 搭建\nIDE 搭建以 [Java EE 之 SSH 框架配置与使用](https://www.kofes.cn/2018/07/J2EE-SSH-SSI-1.html#IDE-搭建) 为参考。\n\n\n## 版本信息\t\n-  框架版本：\n\t- Spring MVC：4.3.x\n\t- Spring：4.3.x\n\t- MyBatis：3.4.x\n- 其他组件：\n\t- MySQL：5.7.x / SQL Server：2008 R2\n\t- Tomcat：9.0.x\n\t- Maven：3.3.9\n\t- JDK：1.8\n- 构建框架，还需要相关依赖库 ( Jar 包 )，为便于你下载 Jar 包或校对依赖是否齐全，具体地，以下列举了 SSM 框架所需要的依赖库。\n\n| Spring | MyBatis |\n| :---- | :---- | \n| spring-core | mybatis | \n| spring-beans | mybatis-spring ( Spring 整合 Mybatis ) |\n| spring-context | pagehelper ( 分页助手 ) |\n| spring-webmvc | &nbsp; |\n| spring-web | &nbsp; |\n| spring-aop ( 整合 Aop ) | &nbsp; |\n| aopalliance ( 整合 Aop ) | &nbsp; |\n| spring-aspect ( 整合 Aop ) | &nbsp; |\n| aspectjweaver ( 整合 Aop ) | &nbsp; |\n| spring-tx ( 整合事务 ) | &nbsp; |\n| spring-jdbc | &nbsp; |\n\n|  其他依赖库 ( Jar 包 ) | 备注 |\n| :---- | :---- |\n| log4j | 日志支持 |\n| log4j-core、log4j-api | 日志支持 |\n| slf4j-api、slf4j-log4j12 | 日志支持 |\n| junit | Junit 单元测试 |\n| c3p0 | c3p0 数据库连接池 |\n| mysql-connector-java | 添加 MySQL 数据库支持 |\n| jackson-databind | Json 数据转化为类对象 |\n| jsp-api | JSP |\n| javax.servlet-api | Servlet |\n| jstl | JSTL 标签库 |\n| taglibs-standard-impl | JSP 标准标签库 |\n\n\n## 框架初识\n- SSM 框架集由 Spring、SpringMVC、MyBatis 三个开源框架整合而成，是继 SSH (Spring、Struts2、Hibernate ) 之后，目前比较主流的 Java EE 企业级框架，适用于搭建各种大型的企业级应用系统。 \n\n\t> SSM 与 SSH 都有各自的优缺点，而根据你的项目特点而选择合适的框架即可。关于 SSH 框架的配置与使用，感兴趣的可参考本博客的文章：[Java EE 之 SSH 框架配置与使用](https://www.kofes.cn/2018/07/J2EE-SSH-SSI-1.html)\n\n### ORM 框架\n- 对象关系映射（Object Relational Mapping，O/R Mapping，ORM）是通过使用描述对象和数据库之间映射的 `元数据`，将面向对象语言程序中的 `对象` 自动 `持久化` 到 `关系数据库` 中。本质上就是将数据从一种形式转换到另外一种形式。 \n- 让 `实体类` 和 `数据库表` 进行一一对应关系 (映射关系)，`实体类属性` 和 `表里面的字段` 对应。操作表对应实体类对象，而不需操作数据库表。\n\n### SSM 框架\n\n#### MyBatis\n\n##### 原生 Jdbc 操作数据库\n在引入 MyBatis ( 或 Hibernate ) 前，一般通过原生 Jdbc 来操作数据库，而这种方式存在很多问题 $^{[2]}$：\n\n- 程序创建数据库连接，即需求时创建，用完后关闭。若频繁的创建、关闭数据库连接，显然存在问题。 ( 可以通过数据库连接池来处理这个问题 )\n\n- 硬编码的地方太多了。例如，数据库连接相关信息，SQL相关信息等。( 可通过使用 XML 配置文件，来避免这个问题 )\n\n- 实质上，我们编写JDBC是有步骤可循的，即先得到数据库连接对象，传入SQL、输入参数、设置参数，再去执行SQL，然后遍历结果集将数据库 SQL 执行的结果对象转化为 JAVA 对象，然后再去业务处理，最后释放资源。\n\n\t那么这个过程，实际上是个 `模板方法`，能不能抽离出来，更好的去完成这个过程呢？\n\n\n##### 框架比较\n-  Hibernate\n\t- 优点：  \n\t1) Hibernate 这个纯粹的 ORM 框架，以面向对象的方式来完成数据库的操作。  \n\t2) Hibernate 不需要编写 SQL 即可完全映射，且可通过 HQL (Hibernate Query Language) 语言对 POJO 操作。  \n\t3) Hibernate 提供了日志、缓存、级联等特性。  \n\t- 缺点：\n\t1) Hibernate 可自由编写 SQL，但非常繁琐，则优化 SQL 实现高性能数据库操作有限制，在互联网项目快速迭代开发中显得过于笨重。\n\t2) Hibernate 的 `级联会造成太多性能的丢失`。\n\t3) Hibernate 不支持存储过程。\n- MyBatis\n\t- 优点：自由书写 SQL、支持动态 SQL、处理列表、动态生成表名、支持存储过程。\n\t- 缺点：需要编写 SQL 和映射规则，工作量相对较大。\n\n##### 基本介绍\n- MyBatis 前身是 Apache 的开源项目 `iBatis`，`iBatis` 一词源于 internet 和 abatis 的组合，是一个基于 Java 的持久层框架。\n\n- MyBatis 是一款持久层框架，它支持定制化 SQL (不屏蔽 SQL)、存储过程以及高级映射。\n- MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。\n- MyBatis 可使用 XML配置文件形式或注解形式来配置和映射原生信息，将接口和 POJOs ( Plain Ordinary Java Object，普通 Java 对象 / 实体类 ) 映射成数据库中的记录。\n\n\t> 我们把 POJO 对象和数据库表相互映射的框架称为对象关系映射框架 ( Object Relational )。\n\n##### 架构原理\n\n![图6-1SSM架构原理图](/images/illustration/Project/2018/08/J2EE-SSM-1_6-1.png)\n<center>图 6-1 SSM架构原理图</center>\n\n- `SqlMapConfig.xml`：MyBatis 全局配置文件，配置数据源、事务等运行环境相关信息；SQL文件即是 `Mapper.xml`。\n\n- `SqlSessionFactory`：会话工厂，用于创建 SqlSession。\n\n- `SqlSession`：即操作数据库的接口，其内部借助 `Executor` 执行器完成对数据库的操作。\n\n- `MappedStatement`：底层封装对象，对操作数据库储存封装，其中包括 SQL 语句 ( Mapper.xml )、输入对象和输出结果类型。\n\n##### 配置文件\n\n- 全局配置文件：在 Src 根目录下建立并配置 `SqlMapConfig.xml`  \n\n\t与 Spring 整合 Hibernate 一样，后期 Spring 整合 MyBatis 后此配置文件可省略。当然，学习阶段代码还是得提供。\n\t\n\t```xml\n\t<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\t<!DOCTYPE configuration\n\t    PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n\t    \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\t<configuration>\n\n\t    <!-- 加载 Java 的配置文件或者声明属性信息 ( 详细见本项目源码 ) -->\n\t    <properties resource=\"c3p0.properties\"></properties>\n\n\t    <!-- 全局参数配置 -->\n\t    <!-- <settings></settings> -->\n\n\t    <!-- 自定义别名 -->\n\t    <typeAliases>\n\t        <!-- 单个别名定义\n\t        <typeAlias type=\"cn.kofes.ssm.pojo.Sample\" alias=\"Sample\"/>\n\t        -->\n\n\t        <!-- 批量别名定义 ( 推荐 )\n\t         | package：指定包名称来为该包下的 pojo 类声明别名，默认的别名就是类名 ( 首字母大小写都可 )\n\t        -->\n\t        <package name=\"cn.kofes.pojo\"/>\n\t    </typeAliases>\n\n\t    <!-- 配置 MyBatis 的环境信息，与 Spring 整合，该信息由spring来管理 -->\n\t    <environments default=\"development\">\n\t        <environment id=\"development\">\n\t            <!-- 配置 Jdbc 事务控制，由 MyBatis 进行管理 -->\n\t            <transactionManager type=\"JDBC\"></transactionManager>\n\t            <!-- 配置数据源，采用 MyBatis 连接池 -->\n\t            <dataSource type=\"POOLED\">\n\t                <property name=\"driver\" value=\"${datasource.driverClass}\"/>\n\t                <property name=\"url\" value=\"${datasource.jdbcUrl}\"/>\n\t                <property name=\"username\" value=\"${datasource.user}\"/>\n\t                <property name=\"password\" value=\"${datasource.password}\"/>\n\t            </dataSource>\n\t        </environment>\n\t    </environments>\n\n\t    <!-- 加载映射文件 -->\n\t    <mappers>\n\t        <!-- 单个映射文件添加 -->\n\t        <mapper resource=\"mapper/SampleMapper.xml\"/>\n\n\t        <!-- 批量加载映射文件：mapper.java 与 mapper.xml 同名，且在同一目录下\n\t        <package name=\"cn.kofes.ssm.mapper\" />\n\t        -->\n\t    </mappers>\n\t</configuration>\n\t```\n\t\n- Mapper 映射文件：例如 `SampleMapper.xml`\n\n\t- 创建实体类对象 ( POJOs )：\n\n\t```java\n\t// cn.kofes.pojo.Sample.java\n\tpublic class Sample {\n\t    private Integer id;\n\t    private String name;\n\t\n\t    public Integer getId() { return id; }\n\t    public void setId(Integer id) { this.id = id; }\n\t    public String getName() { return name; }\n\t    public void setName(String name) { this.name = name; }\n\t}\t\n\t```\n\n\t- 在映射文件中配置 SQL 语句，如建立 `SampleMapper.xml` ( 便于管理，把映射文件统一放置 mapper 文件夹下 )：\n\n\t```xml\n\t<!-- mapper/SampleMapper.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\t<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n\t    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n\n\t<!-- namespace 用于绑定 Mapper 代理开发 -->\n\t<mapper namespace=\"cn.kofes.mapper.SampleMapper\">\n\t    <!--\n\t     | 配置 SQL 语句：例如查找某一元组\n\t     | - id 属性：唯一标识映射文件中的 SQL\n\t     | - parameterType 属性：指定输入参数的类型\n\t     | - resultType 属性：指定输出参数的类型\n\t     |   SQL 语句会封装到 MappedStatement 对象中，故 ID 又称为 Statement 的 ID\n\t     | - #{}：表示一个占位符号\n\t     | - #{id}：id 表示接收输入的参数，参数名称就是 id\n\t    -->\n\t    <select id=\"findCertianTupleById\" parameterType=\"int\" resultType=\"cn.kofes.bean.Sample\">\n\t        SELECT * FROM t_sample WHERE id = #{id}\n\t    </select>\n\t    \n\t    <!-- 插入元组 -->\n\t    <insert id=\"insertOneTuple\" parameterType=\"cn.kofes.pojo.Sample\">\n\t        <!-- 用于自增 ID 的情况，在完成插入后将 ID 返回 user 对象中\n\t        <selectKey keyProperty=\"id\" order=\"AFTER\" resultType=\"java.lang.Integer\">\n\t            SELECT LAST_INSERT_ID()\n\t        </selectKey>\n\t        -->\n\n\t        <!-- 用于非自增 ID 的情况，先产生 ID 放入 user 对象中，再执行保存\n\t        <selectKey keyProperty=\"id\" order=\"BEFORE\" resultType=\"java.lang.String\">\n\t            SELECT UUID()\n\t        </selectKey>\n\t        INSERT INTO t_sample (id, name) VALUES (#{id}, #{name})\n\t        -->\n\t        INSERT TO t_sample(id, name) value(#{id}, #{name})\n\t    </insert>\n\t    \n\t    <!-- 删除一条元组 -->\n\t    <delete id=\"deleteOneTupleById\" parameterType=\"java.lang.Integer\">\n\t        DELETE FROM t_sample WHERE id = #{id}\n\t    </delete>\n\n\t    <!-- 更新一条元组 -->\n\t    <update id=\"updateOneTupleById\" parameterType=\"cn.kofes.pojo.Sample\">\n\t        UPDATE t_sample SET id = #{id}, name = #{name}\n\t        WHERE id = #{id}\n\t    </update>\n\t</mapper>\n\t```\n\t\n##### 案例演示 \n- 单独使用 MyBatis 框架，根据 id 查询指定用户：\n\n\t```java\n\t// 便于检验效果，这里以单元测试类实现\n\tpublic class DBOperatorTest {\n\t    @Test\n\t    public void testDoSomethingInDB() {\n\t        // 加载 MyBatis 配置文件\n\t        String resource  = \"SqlMapConfig.xml\";\n\t        // 得到配置文件流\n\t        InputStream inputStream = Resource.getResourceAsStream(resource);\n\t        // 创建会话工厂\n\t        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder()\n\t            .build(inputStream);\n\t            \n\t        // 通过会话工厂，得到 SqlSession 对象\n\t        SqlSession sqlSession = sqlSessionFactory.openSession();\n\t        \n\t        // 通过 SqlSession 操作数据库\n\t        // 第一个参数：namespace + statement id\n\t        // 第二个参数：指定和映射文件中所匹配的 parameterType 相同属性类型的参数\n\t        \n\t        /* 根据 ID 查询元组\n\t        Sample sample = sqlSession.selectOne(\n\t            \"cn.kofes.mapper.SampleMapper.findCertainTupleById\", 1);\n\t        */\n\n\t        /* 插入一条元组\n\t        Sample sample = new Sample();\n\t        sample.setName(\"邯郸\");\n\t        sqlSession.insert(\n\t            \"cn.kofes.mapper.SampleMapper.insertOneTuple\", sample);\n\t        */\n\t        \n\n\t        /* 根据 ID 修改元组\n\t        Sample sample = new Sample();\n\t        sample.setId(14);\n\t        sample.setName(\"阿斗\");\n\t        sqlSession.update(\n\t            \"cn.kofes.mapper.SampleMapper.updateOneTupleById\", sample);\n\t        */\n\t        \n\t        sqlSession.commit();\n\t        sqlSession.close();\n\t    }\n\t}\n\t```\n\t\n- 案例总结：\n\t- `namespace`：命名空间，作用是隔离 SQL。在 MyBatis 和 Spring 结合使用时具有特殊的意义，这里暂且使用全限定类名。\n\t- `<select>` 等 SQL Command 标签需要一个 ID，还需要输入参数 parameterType，输出参数映射 resultType 等。在 MyBatis 底层封装成了一个 MappedStatement 对象，使用时以 `namespace.id` 的方式引用即可。\n\t- `#{}` 和 `${}`：\n\t\t- `#{}`：表示一个占位符号，用于接收输入参数，类型可以是简单类型，也可是 POJO、HashMap 等。( 通过 `OGNL 表达式` 读取对象的属性值 )\n\t\t- `${}`：表示一个拼接符号，会引入 `SQL注入`，故不建议使用。\n\n- 思考问题：\n\t- 我们重点关注的是 SqlSession，它其实是一个 interface，定义了很多操作数据库的接口，其中实现了 Closeable 接口，很明确是使用完毕后需要 `close()` 的。  \n\t- 它的实现类 DefaultSqlSession 中有一些数据域，比如说 autoCommit，在默认情况下是不开启自动提交的；且方法也并不是 Synchronized 的，这说明 SqlSession 并不是线程安全的，因此我们应该是局部使用 SqlSession，且在使用完毕后 `close()` 关闭 sqlSession。\n\n##### ~~MyBatis 原始方法~~\n\n> 这种方式，重复的代码太多，现阶段基本弃用，目前使用最多的就是 Mapper 代理开发。\n\n- 在开始 Mapper 代理开发前，可了解一种 MyBatis 的原始 Dao 开发方法：\n\t- Step.01.提供 Dao 接口，有增、删、改、查的方法。\n\t- Step.02.提供 Dao 的实现类，在实现类中利用 Spring 注入 SqlSessionFactory，然后在各个方法中得到 SqlSession，进行操作后，关闭 SqlSession 即可。\n- 便于理解，放上实现代码：\n\n\t```java\n\t// DAO 层接口\n\tpublic interface BaseDao {\n\t    public void insertOneTuple(User user) throw Exception;\n\t    public void deleteOneTupleById(int id)  throw Exception;\n\t    public void updateOneTupleById(User user)  throw Exception;\n\t    public User findCertainById(int id) throw Exception;    \n\t}\n\t\n\t// DAO 层实现类\n\tpublic class SampleDaoImpl implements BaseDao {\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    \n\t    public SampleDaoImpl(SqlSessionFactory sqlSessionFactory) \n\t        throw Exception {\n\t        this.sqlSessionFactory = sqlSessionFactory;\n\t    }\n\t    \n\t    @Override\n\t    public User findCertainById(int id) throw Exception { \n\t        // 省略实现逻辑...\n\t    }\n\t    @Override\n\t    public void deleteOneTupleById(int id)  throw Exception { \n\t        // 省略实现逻辑...\n\t    }\n\t    @Override\n\t    public void updateOneTupleById(User user)  throw Exception {\n\t        // 省略实现逻辑...\n\t    }\n\t    @Override\n\t    public User findCertainById(int id) throw Exception {\n\t        // 省略实现逻辑...\n\t    }\n\t}\n\t\n\t// 单元测试类\n\tpublic class SampleDaoTest {\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    \n\t    @Before\n\t    public void setUp() {\n\t        InputStream inputStream = \n\t            Resource.getResourceAsStream(\"SqlMapConfig.xml\");\n\t        SqlSessionFactory sqlSessionFactory = \n\t            new SqlSessionFactoryBuilder().build(inputStream);\n\t    }\n\n\t    @Test\n\t    public void testFindCertainById() {\n\t        BaseDao sampleDao = new SampleDaoImpl(sqlSessionFactory);\n\t        User user = sampleDao.findCertainById(5);\n\t        System.out.println( user.toString() );\n\t    }\n\t}\n\t```\n\n##### Mapper 代理开发\n\n- Mapper 映射文件：上一节配置的映射文件 `SampleMapper.xml`\n\n- Mapper 接口：\n\t-  在 SampleMapper.xml 中 namespace 等于 Mapper 的接口地址 ( `全路径地址` )；\n\t-  在 Mapper 接口中的 `方法名` 和 SampleMapper.xml 中 Statement 的 `ID` 名称一致；\n\t-  在 Mapper 接口中的方法 `输入参数类型` 和 SampleMapper.xml 中 Statement 的 `parameterType` 指定的类型一致。\n\t-  在 Mapper 接口中的 `方法返回值类型` 和 SampleMapper.xml 中 Statement 的 `resultType` 指定的类型一致。\n\n- 关于规范的启示：故我们进行 Mapper 的开发应该遵循一些规范，这样 MyBatis 方可自动生成 `XXXMapper` 类的代理实现类。\n\t- 保证 XXXMapper.xml 中的 `namespace` 同 XXXMapper.java 的 `全限定名称` 一致；\n\t- 保证 XXXMapper.xml 中的 `Statement ID` 同 XXXMapper.java 的 `方法名称` 一致；\n\t- 保证 XXXMapper.xml 中的 Statement 的输入参数的类型 ( `parameterType` )、输出参数的类型 ( `resultType` ) 同 `XXXMapper.java` 的保持一致.\n\n\t![图6-2Mapper代理开发规范](/images/illustration/Project/2018/08/J2EE-SSM-1_6-2.png)\n<center>图6-2 Mapper 代理开发规范</center>\n\n\t```java\n\t// Mapper 接口：cn.kofes.ssm.mapper.SampleMapper.java\n\tpublic interface SampleMapper {\n\t    public void insertOneTuple(Sample sample);\n\t    public void deleteOneTupleById(Integer id);\n\t    public void updateOneTupleById(Sample sample);\n\t    public Sample findCertainTupleById(Integer id);\n\t}\n\t\n\t// 单元测试类\n\tpublic class SampleMapperTest {\n\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    private  SqlSession sqlSession;\n\n\t    @Before\n\t    public void setUp() throws IOException {\n\t        // 加载 MyBatis 配置文件，得到配置文件流\n\t        InputStream inputStream =\n\t            Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n\t        // 创建会话工厂\n\t        SqlSessionFactory sqlSessionFactory =\n\t            new SqlSessionFactoryBuilder().build(inputStream);\n\t        // 通过会话工厂，得到 SqlSession 对象\n\t        sqlSession = sqlSessionFactory.openSession();\n\t    }\n\n\t    @Test\n\t    public void testFindCertainTupleById() {\n\t        SampleMapper sampleMapper = sqlSession.getMapper(SampleMapper.class);\n\t        System.out.println( sampleMapper.findCertainTupleById(15).toString() );\n\t        sqlSession.close();\n\t    }\n\t}\n\t```\n- 当然不要忘记在全局配置文件 `SqlMapConfig.xml` 中加载映射文件 ( 参考上述配置文件 )。\n\n##### POJO 包装类型查询\n\n###### 输入映射\n-  输入映射：通过 parameterType 指定输入参数的类型，类型可以是 `简单类型`，也可以是  `POJO`、`HashMap` 类型。\n\n\t```java\n\t// 定义包装类型 POJO：自定义所需要的查询条件，实现多表查询\n\tpublic class POJOCollection {\n\t    /**\n\t     * 为更加形象、理解，这里引入用户和部门的实体类\n\t     * 一个用户对应一个部门，一个部门包含多个用户\n\t     */\n\t    private User user; // User 实体类\n\t    private Department department; // Department 实体类\n\t    \n\t    // 构造函数初始化\n\t    public POJOCollection() {\n\t        user = new User();\n\t        department = new Department();\n\t    }\n\t\t\n\t    // 生成 Setter 和 Getter 方法\n\t    public void setUser(User user) { this.user = user; }\n\t    public User getUser() { return user; }\n\t    public void setDepartment(Department department) { this.department = department; }\n\t    public Department getDepartment() { return department; }\n\t}\n\t```\n\n- 在映射文件 `SampleMapper.xml` 中配置 SQL 语句：\n \n\t```xml\n\t<!--  自定义所需要的查询条件，实现多表查询 -->\n\t<select id=\"findPOJOList\"\n\t    parameterType=\"cn.kofes.ssm.pojo.POJOCollection\"\n\t    resultType=\"cn.kofes.ssm.pojo.User\">\n\t    SELECT * FROM t_user as u, t_department as d\n\t    WHERE u.uid = #{user.uid} and d.depart_id = #{department.depart_id}\n\t</select>\n\t```\n\n- Mapper 接口：\n\n\t```java\n\t// Mapper 接口：cn.kofes.ssm.mapper.SampleMapper.java\n\tpublic interface SampleMapper {\n\t    public List<Sample> findPOJOList(POJOCollection pojoCollection);\n\t}\n\n\t// 单元测试类\n\tpublic class SampleMapperTest {\n\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    private  SqlSession sqlSession;\n\n\t    @Before\n\t    public void setUp() throws IOException {\n\t        // 同上\n\t    }\n\n\t    @Test\n\t    public void testFindPOJOList() {\n\t        // Mapper 接口代理\n\t        SampleMapper sampleMapper =\n\t            sqlSession.getMapper(SampleMapper.class);\n\n\t        POJOCollection pojoCollection = new POJOCollection();\n\t        pojoCollection.getUser().setUid(50);\n\t        pojoCollection.getDepartment().setDepart_id(1);\n\n\t        List<User> list =\n\t            sampleMapper.findPOJOList(pojoCollection);\n\t        System.out.println( list.get(0).toString() );\n\n\t        sqlSession.close();\n\t    }\n\t}\n\t```\n\n###### 输出映射\n\n- 输出映射：使用 resultType 进行输出映射，查询列名和 POJO 中的属性名一致，该列才会成功映射。\n\n\t> 若查询出来的列名 ( 通过 AS 自定义的列名 ) 和 POJO 的属性名不一致，通过定义一个 resultMap 对列名和属性名之间作一个映射关系。\n\t\n- 定义 resultMap：在映射文件 `SampleMapper.xml` 中定义；\n\n\t```xml\n\t<!--\n\t | id：resultMap 唯一标识\n\t | type：\n\t-->\n\t<resultMap id=\"sampleResultMap\" type=\"cn.kofes.ssm.pojo.Sample\">\n\t    <!--\n\t     | id 表示查询结果集中的唯一标识\n\t     | colum：查询出来的列名 ( AS 自定义列名 )\n\t     | property：type 指定的 POJO 类型中的属性名\n\t    -->\n\t    <id column=\"id_\" property=\"id\" />\n\t    <!--\n\t     | result 对非 ID 的属性进行映射定义\n\t    -->\n\t    <result column=\"name_\" property=\"name\" />\n\t</resultMap>\n\t\n\t<!-- 使用 resultMap 作为 Statement 的输出映射类型 -->\n\t<select id=\"listCustomView\"\n\t    parameterType=\"int\" resultMap=\"sampleResultMap\">\n\t    SELECT id as id_, name as name_\n\t    FROM t_sample\n\t    WHERE id = #{id}\n\t</select>\n\t```\n\n- Mapper 接口：\n\n\t```java\n\t// Mapper 接口：cn.kofes.ssm.mapper.SampleMapper.java\n\tpublic interface SampleMapper {\n\t    public Sample listCustomView(Integer id);\n\t}\n\n\t// 单元测试类\n\tpublic class SampleMapperTest {\n\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    private  SqlSession sqlSession;\n\n\t    @Before\n\t    public void setUp() throws IOException {\n\t        // 同上\n\t    }\n\n\t    @Test\n\t    public void testListCustomView() {\n\t        // Mapper 接口代理\n\t        SampleMapper sampleMapper = \n\t            sqlSession.getMapper(SampleMapper.class);\n            \n\t        System.out.println( sampleMapper.listCustomView(15) );\n\t    }\n\t}\n\t```\n\n###### 映射对比\n- `resultType` 查询出来的列名 ( 通过 AS 自定义的列名 ) 和 POJO 的属性名需一致，该列才会成功映射。  \n\t`resultMap` 可根据查询出来的列名指定 POJO 类型中的应的属性名。\n- `resultType` 返回的是 User 对象，适应较简单的输出结果映射，MyBatis 其实还提供了`resultMap` 作为复杂输出结果映射。在 [高级映射](#高级映射) 章节将对比阐述。\n\t\n##### 动态 SQL\nMyBatis 核心是对 SQL 语句进行灵活操作，通过表达式进行判断，对 SQL 进行灵活拼接、组装。\n\n- SQL 语句 `拼接`，例如 `<where>` 和 `<if>` 标签的组合使用；\n- SLQ 语句 `抽离`，例如 `<sql>` 和 `<include>` 标签的组合使用； \n- Foreach：向 SQL 传递数组或 List 集合，MyBatis 使用 `<foreach>` 标签解析。例如，我们需要查询多个 ID 值；\n\n\t```xml\n\t<!-- 将通用的 SQL 语句抽离，例如：属性名、表名等 -->\n\t<sql id=\"t_sample\">t_sample</sql>\n\n\t<select id=\"findPOJOList\" \n\t    parameterType=\"cn.kofes.ssm.pojo.POJOCollection\"\n\t    resultType=\"cn.kofes.ssm.pojo.Sample\">\n\t    SELECT * FROM <include refid=\"t_sample\" />\n    \n\t    <!-- 自动去掉条件中第一个 AND 或者 OR  -->\n\t    <where>\n\t        <!-- Case.01.注意下面这种写法只适用于 id 类型为 String  -->\n\t        <if test=\" sample.id != null and sample.id != '' \">\n\t            AND sample.id = #{sample.id}\n\t        </if>\n\t        <if test=\" other.id != null and other.id  != '' \">\n\t            AND other.id = #{other.id}\n\t        </if>\n        \n\t        <!-- Case.02.若 id 类型为 Integer 需要以下写法 \n\t        <if test=\"_parameter!=null and _parameter > 0\">\n\t            AND id = #{id}\n\t        </if>\n\t        -->\n\t        \n\t        <!-- Case.03.查询多个 ID 值 -->\n\t        \n\t        <!--  拼接效果：AND(id = ? OR id = ? OR id = ?) \n\t        <if test=\"ids != null\">\n\t            <foreach collection=\"ids\" item=\"id\" \n\t                open=\"AND (\" close=\")\" separator=\"OR\">\n\t                id = #{id}\n\t            </foreach>\n\t        </if>\n\t        -->\n\t        \n\t        <!--  拼接效果：IN(1, 3, 5)\n\t        <if test=\"ids != null\">\n\t            <foreach collection=\"ids\" item=\"id\" \n\t                open=\"IN (\" close=\")\" separator=\",\">\n\t                id = #{id}\n\t            </foreach>\n\t        </if>\n\t        -->\n\t    </where>\n\t</select>\n\t```\n\t\n##### 高级映射\n为便于后续章节的学习，这里以用户表、商品表、订单表和订单明细表的实例来阐述问题：\n\n![图6-3用户购物清单ER图](/images/illustration/Project/2018/08/J2EE-SSM-1_6-3.png)\n<center>图 6-3 用户购物清单 ER 图</center>\n\n- 用户表 ( User )：购买商品的用户信息；\n- 商品表 ( Item )：商品的明细信息；\n- 订单表 ( Order )：用户所创建的订单；\n- 订单明细表 ( OrderDetail )：每一张订单记录购买的商品信息；\n\n\t> 为便于理解，数据表与 POJO ( 实体类 ) 的名称统一命名为相同名称。\n\n###### 一对一映射\n便于理解，我们可以确立一需求：查询订单表，关联查询 `创建订单的用户信息`。\n\nUser 和 Order 的关联查询，关键是查询出来的结果如何映射？是用 resultType，还是用 resultMap？\n\n1) `resultType`  \n\n显然我们的实体类 ( User 仅仅包含用户信息，Order 仅仅包含订单信息，Order 中没有 User 的引用 ) 并不能接受关联查询的结果集，那么我们可以考虑使用 OrderVoUser 映射类，即让它 `extends Orders`，然后在加上一些 User 的属性作为输出结果类型。\n\t\n> OrdersVoUser 映射类的创建原理与上述的 POJOCollection 映射类一样。\n\t\n2) `resultMap`  \n\t\n可满足复杂输出结果映射，例如数据库字段名称与查询的字段名称 ( 或通过 AS 声明了别名 ) 不一致的映射；延迟加载；一对一，一对多，多对多等高级映射特性。\n\t\n> 这里引用实例说明，即使用 resultMap 将查询结果中的订单信息映射到 Other 对象中，在 Order 类中添加 User 属性，将关联查询出来的用户信息映射到 Other 对象中的 User 属性中。 \n\t\n- 配置映射文件 Mapper.xml \n\n\t```xml\n\t<!-- 映射文件 Mapper.xml -->\n\t\n\t<!-- 订单查询映关联查询用户信息的 resultMap  -->\n\t<resultMap id=\"OrderUserResultMap\" type=\"cn.kofes.ssm.pojo.Order\">\n\t    <!-- \n\t     | 配置映射的订单信息\n\t     | colum：订单信息的列名\n\t     | property：订单信息的列名所映射到 POJO 中的属性名\n\t    -->\n\t    <id column=\"order_id\" property=\"order_id\" />\n\t    <result column=\"createtime\" property=\"createtime\" />\n\t    \n\t    <!-- \n\t     | 配置映射的关联用户信息\n\t     | association 标签中 javaType 必须要明确指明类型\n\t     -->\n\t     <association property=\"user\" javaType=\"cn.kofes.ssh.pojo.User\">\n\t         <id column=\"uid\" property=\"uid\" />\n\t         <result column=\"username\" property=\"username\" />\n\t         <result column=\"age\" property=\"age\" />\n\t         <result column=\"phone\" property=\"phone\" />\n\t     </association>\n\t</resultMap>\n\t\n\t<!-- SQL 语句：查询订单表，关联查询创建订单的用户信息  -->\n\t<select id=\"findOrderUserResultMap\" resultMap=\"OrderUserResultMap\">\n\t    SELECT\n\t        u.uid, u,username, u.age, u.phone, \n\t        o.order_id\n\t    FROM\n\t        Order AS o, User AS u\n\t    WHERE\n\t        o.id = u.uid\n\t</select>\n\t```\n\t\n- Mapper 接口：\n\n\t```java\n\t// SampleMapper 接口\n\tpublic interface SampleMapper {\n\t    public List<Order> findOrderUserResultMap();\n\t}\n\n\t// 单元测试类\n\tpublic class SampleMapperTest {\n\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    private  SqlSession sqlSession;\n\n\t    @Before\n\t    public void setUp() throws IOException {\n\t        // 同上\n\t    }\n\n\t    @Test\n\t    public void testFindOrderUserResultMap() {\n\t        // Mapper 接口代理\n\t        SampleMapper sampleMapper = \n\t            sqlSession.getMapper(SampleMapper.class);\n            \n\t        List<Order> list = sampleMapper.findOrderUserResultMap();\n\t    }\n\t}\n\t```\n\n###### 一对多映射\n确立一需求：查询订单及订单明细的信息。\n\n- 实体类配置\n\n\t> 为了满足二级缓存需求，所有实体类实现 `Serializablle` 接口，实现序列化。\n\n\t```java\n\tpublic class User implements Serializable {\n\t\n\t    private Integer uid;\n\t    private String username;\n\t    private Integer age;\n\t    private String phone;\n\t    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t\n\tpublic class Order implements Serializable {\n\t    private Integer order_id;\n\t    private Date createtime;\n\t    \n\t    // 把订单所对应的订单明细映射到 orderDetail 属性中\n\t    private List<OrderDetail> orderDetail;\n\t    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t\n\tpublic class OrderDetail implements Serializable {\n\t    private Integer orderdetail_id;\n\t    private Integer item_id;\n\t    private Integer order_id;\n\t    private Integer amount;\n\t    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\n\tpublic class Item implements Serializable {\n\t    private Integer item_id;\n\t    private String itemname;\n\t    private String itemprice;\n    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t```\n\n- 配置映射文件 Mapper.xml \n\n\t```xml\n\t<!-- 映射文件 Mapper.xml -->\n\t\n\t<!-- 查询订单及关联查询订单明细的 resultMap  -->\n\t<resultMap \n\t    id=\"OrderAndOrderDetailResultMap\"\n\t    type=\"cn.kofes.ssm.pojo.Order\"\n\t    extend=\"OrderUserResultMap\">\n\t\n\t    <!-- 配置映射的订单信息 -->  \n\t    <!-- 配置映射的用户信息 -->\n\t    <!-- 通过继承免去重复配置：extend=\"Objective ResultMap ID\" -->\n\t    \n\t    <!-- \n\t     | 配置映射的订单明细信息：使用 Collection 对关联查询的多条记录\n\t     | 映射到一个 List 集合属性中\n\t     | ofType：指定映射到集合属性中 POJO 的类型\n\t    -->\n\t    <collection property=\"orderDetail\" ofType=\"cn.kofe.ssm.pojo.OrderDetail\">\n\t        <id column=\"orderdetail_id\" property=\"id\">\n\t        <result column=\"item_id\" property=\"username\" />\n\t        <result column=\"order_id\" property=\"username\" />\n\t        <result column=\"amount\" property=\"amount\" />\n\t    </collection>\n\t</resultMap>\n\t\n\t<!-- SQL：查询订单及订单明细的信息 -->\n\t<select \n\t    id=\"findOrderAndOrderDetailResultMap\"\n\t    resultMap=\"OrderAndOrderDetailResultMap\">\n\t    SELECT\n\t        o.order_id, o.createtime, \n\t        od.item_id, od.amount,\n\t        i.itemname\n\t    FROM\n\t        Order AS o, Item AS i, OrderDetail As od\n\t    WHERE \n\t        od.order_id = o.order_id AND \n\t        od.item_id = i.item_id\n\t</select>\n\t```\n\t\n- Mapper 接口：\n\n\t```java\n\t// SampleMapper 接口\n\tpublic interface SampleMapper {\n\t    public List<Order> findOrderAndOrderDetailResultMap();\n\t}\n\n\t// 单元测试类\n\tpublic class SampleMapperTest {\n\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    private  SqlSession sqlSession;\n\n\t    @Before\n\t    public void setUp() throws IOException {\n\t        // 同上\n\t    }\n\n\t    @Test\n\t    public void testFindOrderAndOrderDetailResultMap() {\n\t        // Mapper 接口代理\n\t        SampleMapper sampleMapper = \n\t            sqlSession.getMapper(SampleMapper.class);\n            \n\t        List<Order> list = sampleMapper.findOrderAndOrderDetailResultMap();\n\t    }\n\t}\n\t```\n\n###### 多对多映射\n确立一需求：查询用户及用户购买的商品信息。\n\n在多对多映射中，具体的映射思路是：  \n1) 在 User 实体类中添加订单列表属性 `List<Order> orderList`，将用户创建的订单映射到 orderList。  \n2) 在 Order 实体类中添加订单明细列表属性 `List<OrderDetail> orderDetail`，将订单的明细映射到 orderDetail。  \n3) 在 OrderDetail 实体类中添加 `Item` 属性，将订单明细所对应的商品映射到 item。  \n\n- 实体类配置\n\n\t```java\n\tpublic class User implements Serializable {\n\t    private Integer uid;\n\t    private String username;\n\t    private Integer age;\n\t    private String phone;\n\t    \n\t    // 将用户创建的订单映射到 orderList\n\t    private List<Order> orderList;\n\t    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t\n\tpublic class Order implements Serializable {\n\t    private Integer order_id;\n\t    private Date createtime;\n\t    \n\t    // 将订单所对应的订单明细映射到 orderDetail 属性中\n\t    private List<OrderDetail> orderDetail;\n\t    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t\n\tpublic class OrderDetail implements Serializable {\n\t    private Integer orderdetail_id;\n\t    private Integer item_id;\n\t    private Integer order_id;\n\t    private Integer amount;\n\t    \n\t    private Item item;\n\t    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t\n\tpublic class Item implements Serializable {\n\t    private Integer item_id;\n\t    private String itemname;\n\t    private String itemprice;\n    \n\t    // Getter 和 Setter 方法要实现\n\t}\n\t```\n\n- 配置映射文件 Mapper.xml \n\n\t```xml\n\t<!-- 映射文件 Mapper.xml -->\n\t\n\t<!-- 查询用户及关联查询用户购买的商品信息的 resultMap  -->\n\t<resultMap \n\t    id=\"UserAndItemResultMap\" type=\"cn.kofes.ssm.pojo.User\">\n\t    \n\t    <!-- 配置用户信息 -->\n\t    <id column=\"uid\" property=\"uid\">\n\t    <result column=\"username\" property=\"username\" />\n\t    <result column=\"age\" property=\"age\" />\n\t    <result column=\"phone\" property=\"phone\" />\n\n\t    <!-- \n\t     | 配置映射的订单信息：使用 Collection 对关联查询的多条记录\n\t     | 映射到一个 List 集合属性中\n\t     | ofType：指定映射到集合属性中 POJO 的类型\n\t    -->\n\t    <collection property=\"orderList\" ofType=\"cn.kofe.ssm.pojo.Order\">\n\t    \n\t        <id column=\"order_id\" property=\"order_id\">\n\t        <result column=\"createtime\" property=\"createtime\" />\n\t        \n\t        <!-- 配置映射的订单明细信息：一个订单包含多个订单明细 -->\n\t        <collection property=\"orderDetail\" ofType=\"cn.kofe.ssm.pojo.OrderDetail\">\n\t        \n\t            <id column=\"orderdetail_id\" property=\"id\">\n\t            <result column=\"item_id\" property=\"username\" />\n\t            <result column=\"order_id\" property=\"username\" />\n\t            <result column=\"amount\" property=\"amount\" />\n\t            \n\t            <!-- 配置映射的商品信息：一个订单明细对应一个商品 -->\n\t            <association property=\"item\" javaType=\"cn.kofes.ssm.pojo.Item\">\n\t                <id column=\"item_id\" property=\"item_id\">\n\t                <result column=\"itemname\" property=\"itemname\" />\n\t                <result column=\"itemprice\" property=\"itemprice\" />\n\t            </association>\n\t            \n\t        </collection>\n\t        \n\t    </collection>\n\t    \n\t</resultMap>\n\t\n\t<!-- SQL：查询用户信息和用户购买过的商品信息 -->\n\t<select id=\"findUserAndItemResultMap\" resultMap=\"UserAndItemResultMap\">\n\t    SELECT \n\t        u.uid, u.username, \n\t        o.order_id,\n\t        od.item_id, od.amount\n\t        i.itemname, i.itemprice\n\t    FROM\n\t        Order AS o, User AS u, Item AS i, OrderDetail As od\n\t    WHERE\n\t        o.user_id = u.uid AND\n\t        od.order_id = o.order_id AND\n\t        od.item_id = i.item_id\n\t</select>\n\t```\n\t\n- Mapper 接口：\n\n\t```java\n\t// SampleMapper 接口\n\tpublic interface SampleMapper {\n\t    public List<User> findUserAndItemResultMap();\n\t}\n\n\t// 单元测试类\n\tpublic class SampleMapperTest {\n\n\t    private SqlSessionFactory sqlSessionFactory;\n\t    private  SqlSession sqlSession;\n\n\t    @Before\n\t    public void setUp() throws IOException {\n\t        // 同上\n\t    }\n\n\t    @Test\n\t    public void testFindUserAndItemResultMap() {\n\t        // Mapper 接口代理\n\t        SampleMapper sampleMapper = \n\t            sqlSession.getMapper(SampleMapper.class);\n            \n\t        List<User> list = sampleMapper.findUserAndItemResultMap();\n\t    }\n\t}\n\t```\n\n###### 高级映射总结\n- 一对一映射：在 `Order` 实体对象中引入 `User` 属性，且在配置文件 Mapper.xml 中，通过 `<association>` 标签关联用户信息。\n- 一对多映射：在 `Order` 实体对象中添加订单明细列表属性 `List<OrderDetail> orderDetails`，且在配置文件 Mapper.xml 中，通过 `<collection>` 标签关联订单明细信息。\n- 多对多映射：\n\t- 在 User 实体对象中添加订单列表属性 `List<Order> orderList`，将用户创建的订单映射到 orderList。  \n\t- 在 Order 实体对象中添加订单明细列表属性 `List<OrderDetail> orderDetail`，将订单的明细映射到 orderDetail。  \n\t- 在 OrderDetail 实体对象中添加 `Item` 属性，将订单明细所对应的商品映射到 item。\n\n##### 延迟加载\n- 延迟加载，即需要时才发出 SQL 查询请求。Hibernate 中有延迟加载，MyBatis 同样提供了这个功能，具体以 `<resultMap>` 标签的属性完成配置。当然，我们可具体分析 MyBatis 的延迟加载。\n\n- MyBatis是默认开启延迟加载的么？如果不是，那么显然应该进行延迟加载配置。\n\n\t在 MyBatis 的全局核心配置文件 SqlMapConfig.xml 的 `<settings>` 标签中可设置 lazyLoadingEnabled 以及 aggressiveLazyLoading 属性值。\n\t\n\t- `lazyLoadingEnabled`：全局性设置懒加载，默认值为 flase，即所有相关联的都会被初始化加载。\n\n\t- `aggressiveLazyLoading`：默认值为 ture，懒加载的对象可能被任何懒属性全部加载。否者，每个属性按需加载。\n\n- 要实现延迟加载，就得进行 SQL 拆分 ( 若我们的SQL都写在一起，DB要么执行，要么不执行，根本做不到按需查询，所以要延迟加载就得拆分 SQL ) 那么怎么进行拆分呢？\n\n\t在 resultMap 中的 `<collection>` 以及 `<association>` 标签中有 `select` 属性，也就是说当使用到了 `<collection>` 或者 `<association>` 时才发出 `select` 属性对应的 SQL。\n\t\n\t```xml\n\t<!-- 映射文件 Mapper.xml -->\n\t\n\t<!-- 延迟加载的 resultMap -->\n\t<resultMap\n\t    id=\"OrderUserLazyLoadingResultMap\" type=\"cn.kofes.ssm.pojo.Order\">\n\t    <id column=\"order_id\" property=\"order_id\" />\n\t    <result column=\"createtime\" property=\"createtime\" />\n\n\t    <!-- 实现对用户信息进行延迟加载\n\t     | select 属性：指定延迟加载需要执行的 Statement 的 ID，\n\t     | 即根据 user_id 查询用户信息的 Statement\n\t     | column 属性：订单信息中关联查询用户信息得到的列，\n\t    -->\n\t    <association \n\t        property=\"user\" javaType=\"cn.kofes.ssh.pojo.User\"\n\t        select=\"findUserById\" column=\"user_id\" />\n\t    \n\t</resultMap>\n\t\n\t<!-- Step.01.查询订单管理查询用户信息，用户信息需要延迟加载 -->\n\t<select\n\t    id=\"finOrderUserLazyLoading\" resultMap=\"OrderUserLazyLoadingResultMap\">\n\t    SELECT * FROM Order\n\t</select>\n\t\n\t<!-- Step.02.关联查询用户信息：根据订单信息中的 user_id 去关联查询用户信息 -->\n\t<select\n\t    id=\"findUserById\" parameterType=\"int\" resultType=\"cn.kofes.ssm.pojo.User\">\n\t    SELECT * FROM User WHERE user_id = #{user_id}\n\t</select>\n\t\n\t<!-- \n\t | 执行顺序：即先执行 finOrderUserLazyLoading，\n\t | 当需要查询用户时在再执行 findUserById\n\t-->\n\t```\n\t\n- 我们其实可以借助 MyBatis 去完成延迟加载，也可以自己实现延迟加载。怎么做呢？即有需求时，我们自己调用相应的 Statement 完成即可。\n\n##### 查询缓存\n\n![图6-4MyBatis的一级缓存和二级缓存](/images/illustration/Project/2018/08/J2EE-SSM-1_6-4.png)\n<center>图 6-4 MyBatis 的一级缓存和二级缓存 $^{[3]}$</center>\n\n- MyBatis 提供一级缓存和二级缓存：\n\t- 一级缓存是 sqlSession 级别的缓存。在操作数据库时需要构造 sqlSession 对象，在对象中有一个数据结构 ( HashMap，KEY 主要就是 SqlSession + StatementId 构成 ) 用于存储缓存数据。不同的 sqlSession 之间的缓存数据区域是互不影响的；\n\t- 二级缓存是 Mapper 级别的缓存 ( `按 Namespace 划分` )。多个 sqlSession 去操作同一个 Mapper 的 SQL 语句，多个 sqlSession 去操作数据库得到数据的数据会存到二级缓存中。二级缓存区域是共享的。\n\n###### 一级缓存\n- 一级缓存的工作原理：\n\t- 如图 6-3 所示，当 sqlSession 发起 `查询` 操作，查询结果会 `写入` 到一级缓存中，待二次 `读取` 直接从一次缓存中读取即可；若 sqlSession 发起 `插入、更新、删除` 操作，则会 `清空` 一级缓存区域中的信息，以避免脏读。\n\t- 当 sqlSession 关闭时，sqlSession 缓存也随之失效。\n- MyBatis 是默认支持一级缓存的，无需配置开启。\n\n###### 二级缓存\n- 二级缓存是需要配置开启的：\n\t- 在全局配置文件 `SqlMapConfig.xml` 中指明，即在 `<setting>` 标签中的 `cacheEnabled` 属性，开启全局性缓存开关；\n\t- 其次在需要开启二级缓存的 `XXXMapper.xml` 中指明 `<cache>` 标签。\n\n\t```xml\n\t<mapper namespace=\"cn.kofes.mapper.SampleMapper\">\n\t    <!-- \n\t     | 开启本 Mapper namespace 下的二级缓存\n\t     | type 属性：指定 cache 接口的实现类的类型，默认使用 PerpetualCache\n\t     | \n\t    -->\n\t    <cache type=\"...\"/>\n\t    \n\t    <!-- 当然也可使用分布式缓存：Ehcache\n\t    <cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/>\n\t    -->\n\t</mapper>\n\t```\n\t\n- 所有 POJO 实现序列化接口：若开启二级缓存，其存储介质可在内存、磁盘等，即为了将缓存数据取出执行反序列化操作。\n\n\t```java\n\tpublic class User implements Serializable { /* 省略细节 */ }\n\tpublic class Order implements Serializable { /* 省略细节 */ }\n\t```\n\t\n- 二级缓存的局限性：\n\n\t例如，我们仅仅更新了其中一个信息，那么意味着二级缓存的清空。而我们真正想要的是刷新该商品的缓存信息而不要影响其他商品的缓存信息。\n\t\n##### 整合 ehcache\n- `ehcache` 是一个分布式缓存框架，当然还有 `redis`、`memached` 等。\n- 分布式缓存，系统为了提高系统并发、性能，一般对系统进行分布式部署 ( 集群部署方式 )。\n- 整合方法：MyBatis 提供的 Cache 接口，实现缓存逻辑即实现 Cache 接口即可。\n\t- 提供 ehcache 以及 ehcache 与 MyBatis 整合的依赖 ( 或者 Jar 包 )；\n\t- 在 `<cache>` 标签中，type 属性指明 ehcache 实现 Cache 接口的实现类，既有：  \n\t`<cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/>`；\n\t- 提供相关的 ehcache 配置文件.\n\n\t```java\n\t// MyBatis 提供的 Cache 接口\n\tpublic interface Cache {\n\t    String getId();\n\t    void putObject(Object var1, Object var2);\n\t    Object getObject(Object var1);\n\t    Object removeObject(Object var1);\n\t    void clear();\n\t    int getSize();\n\t    ReadWriteLock getReadWriteLock();\n\t}\n\t```\n\n##### 逆向工程\n- MyBatis 官方提供逆向工程，可针对单表自动生成 MyBatis 执行所需要的代码 ( mapper.java，mapper.xml，pojo 等 )。\n- 企业实际开发中，常用的逆向工程方式：由数据库表生成 Java 代码。\n- 添加依赖或添加 Jar 包：[MyBatis-Generator](http://mvnrepository.com/artifact/org.mybatis.generator/mybatßis-generator-core) ( Maven 中央仓库 )\n\n###### 运行逆向工程\n- 参考官方指南 [MyBatis Generator](http://www.mybatis.org/generator/running/running.html)，运行逆向工程有如下方式：\n\t- 使用命令提示符读取 XML 配置文件；\n\t- 使用 Maven 插件；\n\t- 使用 Java 程序读取 XML 配置文件 ( 推荐，即不依赖 IDE )；\n\t- 使用 IDE 插件 ( Eclipse )；\n\n###### 代码配置文件\n- MyBatis 官方提供了配置文档的范例：[MyBatis GeneratorXML Configuration File Reference](http://www.mybatis.org/generator/configreference/xmlconfig.html)\n\n\t当然，你可以参考下文 $^{[5]}$，搭配注释，互相补充：\n\t\n\t```xml\n\t<!-- generatorConfig.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<!DOCTYPE generatorConfiguration\n\t    PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n\t    \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n\t    \n\t<generatorConfiguration>\n\t    <context id=\"testTables\" targetRuntime=\"MyBatis3\">\n\t    \n\t        <commentGenerator>\n\t            <!-- 是否去除自动生成的注释：true / false -->\n\t            <property name=\"suppressAllComments\" value=\"true\" />\n\t        </commentGenerator>\n\t        \n\t        <!-- ( 必填 ) 数据库连接的信息：驱动类、连接地址、用户名、密码 -->\n\t        \n\t        <!-- 连接 MySQL 数据库 -->\n\t        <jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" \n\t            connectionURL=\"jdbc:mysql://127.0.0.1:3306/db_testdb?characterEncoding=utf-8\" \n\t            userId=\"root\" password=\"123456\">\n\t        </jdbcConnection>\n\t        \n\t        <!-- 连接 Oracle 数据库\n\t        <jdbcConnection driverClass=\"oracle.jdbc.OracleDriver\"\n\t            connectionURL=\"jdbc:oracle:thin:@127.0.0.1:1521:db_testdb\" \n\t            userId=\"kofe\" password=\"123456\">\n\t        </jdbcConnection>\n\t        -->\n\n\t        <!--\n\t         | false ( 默认 )，把 Jdbc Decimal 和 Numeric 类型解析为 Integer\n\t         | true，把 Jdbc Decimal 和 Numeric 类型解析为 java.math.BigDecimal\n\t        -->\n\t        <javaTypeResolver>\n\t            <property name=\"forceBigDecimals\" value=\"false\" />\n\t        </javaTypeResolver>\n\n\t        <!-- targetProject：生成 PO 类的位置 -->\n\t        <javaModelGenerator targetPackage=\"cn.kofes.ssm.pojo\"\n\t            targetProject=\".\\src\">\n\t            <!-- enableSubPackages 是否让 schema 作为包的后缀 -->\n\t            <property name=\"enableSubPackages\" value=\"false\" />\n\t            <!-- 从数据库返回的值被清理前后的空格 -->\n\t            <property name=\"trimStrings\" value=\"true\" />\n\t        </javaModelGenerator>\n\t            \n\t        <!-- targetProject:mapper 映射文件生成的位置 -->\n\t        <sqlMapGenerator targetPackage=\"cn.kofes.ssm.mapper\" \n\t            targetProject=\".\\src\">\n\t            <!-- enableSubPackages 是否让 schema 作为包的后缀 -->\n\t            <property name=\"enableSubPackages\" value=\"false\" />\n\t        </sqlMapGenerator>\n\t            \n\t        <!-- targetPackage:mapper 接口生成的位置 -->\n\t        <javaClientGenerator type=\"XMLMAPPER\"\n\t            targetPackage=\"cn.kofes.ssm.mapper\" \n\t            targetProject=\".\\src\">\n\t            <!-- enableSubPackages 是否让 schema 作为包的后缀 -->\n\t            <property name=\"enableSubPackages\" value=\"false\" />\n\t        </javaClientGenerator>\n\t            \n\t        <!-- 指定数据库表 -->\n\t        <table tableName=\"Item\"></table>\n\t        <table tableName=\"Order\"></table>\n\t        <table tableName=\"Orderdetail\"></table>\n\t        <table tableName=\"User\"></table>\n\t        \n\t        <!--\n\t        <table schema=\"\" tableName=\"sys_user\"></table>\n\t        <table schema=\"\" tableName=\"sys_role\"></table>\n\t        <table schema=\"\" tableName=\"sys_permission\"></table>\n\t        <table schema=\"\" tableName=\"sys_user_role\"></table>\n\t        <table schema=\"\" tableName=\"sys_role_permission\"></table>\n\t        -->\n\n\t        <!-- 有些表的字段需要指定 Java 类型\n\t        <table schema=\"\" tableName=\"\">\n\t            <columnOverride column=\"\" javaType=\"\" />\n\t        </table>\n\t        -->\n\t        \n\t    </context>\n\t</generatorConfiguration>\n\t```\n\n###### 执行逆向工程生成代码\n\n- 配置文件配置完成后，执行以下程序即可生成代码，细节如下：\n\n\t```java\n\tpublic class GeneratorSqlmap {\n\n\t    public void generator() throws Exception{\n\n\t        List<String> warnings = new ArrayList<String>();\n\t        boolean overwrite = true;\n\t        \n\t        //指定逆向工程配置文件\n\t        File configFile = new File(\"generatorConfig.xml\"); \n\t        \n\t        ConfigurationParser cp = new ConfigurationParser(warnings);\n\t        Configuration config = cp.parseConfiguration(configFile);\n\t        DefaultShellCallback callback = new DefaultShellCallback(overwrite);\n\t        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,\n\t            callback, warnings);\n\t        myBatisGenerator.generate(null);\n\t    } \n\t    \n\t    // 调用 generator() 执行逆向工程生成代码\n\t    public static void main(String[] args) throws Exception {\n\t        try {\n\t            GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap();\n\t            generatorSqlmap.generator();\n\t        } catch (Exception e) {\n\t            e.printStackTrace();\n\t        }\n\t    }\n\t    \n\t}\n\t```\n\n- 值得注意的是，除了生成基本的 POJO 类还多了一个类，就是 `xxxExample.java`。这个类是给用户自定义 SQL 使用的。到这里就生成好了，下面我们就把生成的代码 `拷贝` 到自己的工程即可。\n\n\n---\n\n#### Spring\n\n- Spring 框架是 Java 应用最广的框架，其成功源于它的理念，即 `控制反转` ( Inversion of Control，IoC ) 和 `面向切面编程` ( Aspect Oriented Programming，AOP )。\n- Spring 框架也可理解为一个轻量级的 IoC 和 AOP 的容器框架。\n- Spring 框架在 [SSH 部分](https://www.kofes.cn/2018/07/J2EE-SSH-SSI-1.html#Spring) 有阐述，在本章节就不具体展开探讨，笔记以补充和整合部分内容为主。\n\n\t> 在 SSH Spring 章节中，要求导入相关 Jar 包，而本文的 SSM 框架要求导入的 Jar 包 ( 或者 Maven 依赖 ) 以 `版本信息` 的为标准。\n\n##### Spring 整合 MyBatis \nSpring 整合 MyBatis 是通过 `MyBatis-Spring` 的类库实现的，具体配置和使用信息可参考 [MyBatis-Spring 官方使用文档](http://www.mybatis.org/spring/zh/index.html) $^{[4]}$。\n\n###### 原始 DAO 开发\n首先要向 DAO 的实现类中注入 SqlSessionFactory ( 交由 Spring 管理，即 Spring 声明式注入 SqlSessionFactory )，然后在各个方法中得到 SqlSession 进行数据库操作。\n\n> `诉求`：在 Spring 运作中，首先加载 Spring 核心配置文件，再创建对象 ( SqlSessionFactory )。而创建对象可通过 New 的方式创建 ( [原始方法](#MyBatis-原始方法) )，但效率太低，则我们可以把加载配置文件和创建对象过程，在服务器启动时完成。故引入 Spring 声明式注入 SqlSessionFactory。\n\n- 使用封装的方法，即让 Dao 的实现类继承 `SqlSessionDaoSupport`，而 SqlSessionDaoSupport 类中已经存在 `setSqlSessionFactory()` 方法，因此我们可以直接向 Dao 的实现类注入 SqlSessionFactory。\n- 另外 SqlSessionDaoSupport 中有 SqlSession，因此使得操作更加简单；而且都交给 Spring 管理，我们自然不必担心忘记关闭 SqlSession。\n\t\n\t```java\n\t// 下述实现是通过 XML 配置方式加载配置和 Bean ( 注解方式也是可行的，但写法有区别 )\n\t\n\t// Dao 接口\n\tpublic interface BaseDao {\n\t    public List<Sample> findSampleById(int id);\n\t}\n\t\n\t// Dao 层实现类\n\tpublic class SampleDaoImpl extends SqlSessionDaoSupport implements BaseDao {\n\t\n\t    private SqlSession sqlSession;\n\t    \n\t    public SampleDaoImpl() throws Expection {\n\t        sqlSession = this.getSqlSession();\n\t    }\n\t\n\t    public Sample findSampleById(int id) throws Exception {\n\t        return sqlSession.selectOne(\n\t            \"cn.kofes.ssm.mapper.SampleMapper.findSampleById\", id);\n\t    }\n\t}\n\t\n\t// 单元测试类\n\tpublic class SampleDaoTest {\n\t\n\t    private BaseDao baseDao;\n\t    \n\t    @Before\n\t    public void setUp() {\n\t        applicationContext = \n\t            new ClassPathXmlApplicationContext(\"classpath:spring.xml\");\n\t        baseDao = (BaseDao) applicationContext.getBean(\"baseDao\");\n\t    }\n\n\t    @Test\n\t    public void testFindCertainById() {\n\t        System.out.println( baseDao.findSampleById(15).toString() );\n\t    }\n\t}\n\t```\n\n###### Mapper 代理开发\n\n- Mapper 代理开发的具体思路：\n\t- SqlSessionFactory 交给 Spring 管理 ( 单例模式 )。\n\n\t注意到 SqlSessionFactory 的创建显然需要数据库连接相关的信息，因此需要 `数据库连接池 (c3p0)`；除此之外还需要 MyBatis 的主配置文件 `SqlMapConfig.xml`。\n\t\n\t- Spring 和 MyBatis 整合生成代理对象，使用 SqlSessionFactory 创建 SqlSession ( Spring 和 MyBatis 整合后自动完成此过程 )。\n\n\t- 若采用 Mapper 代理的方式开发，我们需要 Spring 管理 Mapper 动态代理实现。\n\n- 在 Spring 配置文件下配置数据库信息，并整合 MyBatis。后者将 SessionFacotry 交由 Spring 管理：\n\n\t> c3p0.properties 配置文件位于 Src 根目录下，键值分离以便修改配置。\n\n\t```xml\n\t<!-- spring.xml -->\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xsi:schemaLocation=\"\n\t    http://www.springframework.org/schema/beans \n\t    http://www.springframework.org/schema/beans/spring-beans.xsd \n\t    http://www.springframework.org/schema/context \n\t    http://www.springframework.org/schema/context/spring-context.xsd\">\n\n\t    <!-- 扫描包下注解，并注册为 Bean -->\n\t    <context:component-scan base-package=\"cn.kofes.ssm\">\n\t        <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\">\n\t        </context:exclude-filter>\n\t    </context:component-scan>\n           \n\t    <!-- 在根目录下新建文件 c3p0.properties，存储数据连接信息 -->\n\t    <context:property-placeholder location=\"classpath:c3p0.properties\" />\n\n\t    <!-- Dao 层的配置，即 Mybatis 的配置 ( 分模块开发思想 ) -->\n\t    <import resource=\"spring/mybatis-spring.xml\"/>\n\t</beans>\n\t\n\t<!-- mybatis-spring.xml -->\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xsi:schemaLocation=\"\n\t    http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\t    \n\t    <!-- 1. 数据源 : DriverManagerDataSource -->\n\t    <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" destroy-method=\"close\">\n\t        <!-- 引用 c3p0.properties 的键值对即可，格式如 ${key.value} -->\n\t        <property name=\"driverClass\" value=\"${datasource.driverClass}\"/>\n\t        <property name=\"jdbcUrl\" value=\"${datasource.jdbcUrl}\"/>\n\t        <property name=\"user\" value=\"${datasource.user}\"/>\n\t        <property name=\"password\" value=\"${datasource.password}\"/>\n\t        <!-- 设置数据库连接池的最大连接数 -->\n\t        <property name=\"maxPoolSize\" value=\"${datasource.maxPoolSize}\"/>\n\t        <!-- 设置数据库连接池的最小连接数 -->\n\t        <property name=\"minPoolSize\" value=\"${datasource.minPoolSize}\"/>\n\t        <!-- 设置数据库连接池的初始化连接数 -->\n\t        <property name=\"initialPoolSize\" value=\"${datasource.initialPoolSize}\"/>\n\t        <!-- 设置数据库连接池的连接最大空闲时间 -->\n\t        <property name=\"maxIdleTime\" value=\"${datasource.maxIdleTime}\"/>\n\t        <!-- c3p0缓存Statement的数量数 -->\n\t        <property name=\"maxStatements\" value=\"${datasource.maxStatements}\"/>\n\t        <!-- 当连接池的连接用完的，从 C3p0 下获取新的连接数 -->\n\t        <property name=\"acquireIncrement\" value=\"${datasource.acquireIncrement}\"/>\n\t        <property name=\"checkoutTimeout\" value=\"${datasource.checkoutTimeout}\"/>\n\t        <property name=\"idleConnectionTestPeriod\" value=\"${datasource.idleConnectionTestPeriod}\"/>\n\t    </bean>\n\n\t    <!-- 2. 配置和 MyBatis 的整合 -->\n\t    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n\t        <property name=\"dataSource\" ref=\"dataSource\"/>\n\t    </bean>\n\n\t    <!-- 3. 配置一个可以执行批量的 SqlSession -->\n\t    <bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n\t        <constructor-arg name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/>\n\t        <constructor-arg name=\"executorType\" value=\"BATCH\"/>\n\t    </bean>\n\n\t    <!--\n\t     | 4. MyBatis 自动扫描加载 Sql 映射文件: MapperScannerConfigurer\n\t     | 自动扫描出的 Mapper Bean 的 ID 名称为首字母小写的类名\n\t     | 且效果与 SqlMapConfig.xml 中配置批量加载映射文件相同，即 <package name=\"cn.kofes.ssm.mapper\"/>\n\t     | 1) 批量加载映射文件：mapper.java 与 mapper.xml 同名，且在同一目录下\n\t     | 2) 当然，你可以建立同样的文件夹目录 (cn/kofes/ssm/mapper)，把 mapper.xml 单独放置资源目录下\n     -->\n\t    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n\t        <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\" />\n\t        <property name=\"basePackage\" value=\"cn.kofes.ssm.mapper\" />\n\t    </bean>\n\n\t</beans>\n\t```\n\n- 代码实现：注解方式实现 Mapper 类的调用：\n\n\t```java\n\t// 下述实现是通过注解方式加载配置和 Bean ( XML 方式也是可行的，但写法有区别 )\n\t\n\t// Mapper 接口\n\tpublic interface SampleMapper {\n\t    public Sample findCertainTupleById(Integer id);\n\t}\n\t\n\t// 单元测试类\n\t@RunWith(SpringJUnit4ClassRunner.class)\n\t@ContextConfiguration(locations = {\"classpath:spring.xml\"})\n\tpublic class SampleMapperTest {\n\t\n\t    @Autowired\n\t    private SampleMapper sampleMapper;\n\n\t    @Test\n\t    public void testFindCertainTupleById() {\n\t        System.out.println( \n\t            sampleMapper.findCertainTupleById(15).toString() );\n\t    }\n\t}\n\t```\n\n---\n\n#### Spring MVC\n\n- MVC ( Model-View-Controller ) 模式把应用程序 ( 输入逻辑、业务逻辑和 UI 逻辑 ）分成不同的方面，同时提供这些元素间的松耦合。\n\t- Model：模型，封装了应用程序的 `数据` 和由它们组成的 `POJO`。\n\t- View：视图，负责把模型数据 `渲染到视图` 上，将数据以一定形式展现给用户。\n\t- Controller：负责 `处理用户请求`，并建立适当的模型把它传递给视图渲染。\n- Spring MVC 把 `模型`、`视图` 和 `控制器` 分层，组合成一个有机灵活的系统。\n- Spring MVC 中可定义逻辑视图，通过其提供的解析器找到对应的视图渲染；或在 Controller 的方法内加入注解 ( `@ResponseBody` )，通过消息转换系统将数据转换为 JSON，提供给前端 Ajax 请求使用。\n\n\n## 参考资料\n\n- \\[1\\] [ 杨开振. Java EE 互联网轻量级框架整合开发 [M]. 电子工业出版社. 2017](https://book.douban.com/subject/27090950/)\n- \\[2\\] [张丰哲. MyBatis + Spring MVC 开发指南 (一). 简书. 2017](https://www.jianshu.com/p/91a32e3d4b26)\n- \\[3\\] [张丰哲. MyBatis + Spring MVC 开发指南 (二). 简书. 2017](https://www.jianshu.com/p/48b78ee24fa3)\n- \\[4\\] [MyBatis. MyBatis-Spring 官方使用文档. mybatis.org](http://www.mybatis.org/spring/zh/index.html)\n- \\[5\\] [李阿昀. MyBatis 逆向工程自动生成代码. csdn.net. 2017](https://blog.csdn.net/yerenyuan_pku/article/details/71909325)\n\n","tags":["Spring MVC"],"categories":["Project"]},{"title":"框架 | Java EE 之 SSH 框架配置与使用","url":"%2F2018%2F07%2FJ2EE-SSH-SSI-1.html","content":"\n本文章主要围绕 J2EE 中 SSH ( Spring、Struts、Hibernate ) 框架的配置以及使用问题展开学习的，最终目的是输出可复用的版本，以供后续的项目复用。当然，学习和配置的过程难免有不恰当或错误之处，还望朋友指出、斧正。\n\n<!-- More -->\n\n## 教学资源\n- 视频 | [黑马程序员. J2EE 进阶. 4 天精通 Hibernate 框架. 2017. bilibili.com](https://www.bilibili.com/video/av14626440)\n- 视频 | [黑马程序员. J2EE 进阶. 60 集精通 Spring 框架. 2017. bilibili.com](https://www.bilibili.com/video/av14839030)\n- 视频 | [黑马程序员. J2EE 进阶. Struts2 框架精品教程. 2017. bilibili.com](https://www.bilibili.com/video/av13748042)\n\n\t> 本框架的学习笔记是基于此系列教学视频所得的。\n\n## 更新进度\n- 2018.07.17：完成初稿，IDE 搭建、框架初识章节；\n- 2018.07.20：更新 SSH 框架 Hibernate 的内容；\n- 2018.07.31：更新 SSH 框架 Spring 的内容；\n- 2018.08.03：整合 SSH 框架 ( 输出基本框架 )；\n- 2018.08.08：补充 SSH 框架 Struts 部分的内容；\n- 2018.08.15：重新整理 SSH 框架项目，见版本信息；\n\n\n## IDE 搭建\n- Step.01：安装 JDK；\n- Step.02：安装 IDE ( `IntelliJ Idea` / Eclipse / MyEclipse )；\n- Step.03：配置 Tomcat 环境；\n\t- 让 Tomcat 可同时运行多个 Module，即在菜单栏 `Run > Run Configurations > Deployment > Application context` 下配置目录访问路径即可 ( 一般规范填写项目名 )。\n\n\t![Tomcat 9.0.x Deployment](/images/illustration/Project/2018/08/J2EE-SSH-SSI-1_4-1.jpg)\n<center>图 4-1 Tomcat 9.0.x Deployment</center>\n\t\n\t- 紧接着，在菜单栏 `File > Project Structure > Artifacts` 下配置，把对应的 module 的 Available Elements `Put into Output Root` 到 `xxx:war_exploded` 下。\n\t\n\t![Project Structure Artifacts](/images/illustration/Project/2018/08/J2EE-SSH-SSI-1_4-2.jpg)\n<center>图 4-2 Project Structure Artifacts</center>\n\t\n- Step.04：配置 MySQL / SQL Server 数据库；\n\t- 命名规范：数据库 `db_dbname`；数据表 `t_tablename`；属性 `attribute`\n\t- 访问外网：若在虚拟机或者本机测试，让数据库允许外网访问，注意得关闭防火墙或添加规则允许某端口的访问权限。\n\n\t\t> Case.01：本机和服务器端互相 `Ping` 对方 IP，以检验网络是否畅通、是否拒绝访问。  \n\t\t> Case.02：若网络畅通、没有拒绝访问，还要留意对应端口是否有权限访问，通过 `nc -vz IP 端口`  检验，返回 `Succeeded` 即成功。  \n    \n\t- 数据库权限：若 MySQL 通过命令安装，需特别注意的权限问题，即账号和密码是默认配置的，用户可自行修改，具体修改细节见参考 [6] - [8] 中的方法 ( 可能实操过程中还会遇到其他问题，推荐翻阅下参考文章，也许对你有帮助 )。\n\n\t\t> 若有需求远程连接数据库，我们需要创建一个新用户，并赋予访问权限 (当然，你可让你的 root 账户也赋予远程连接数据库的权限)。具体地：  \n\t\t> `grant all privileges on *.* to  kofe@\"%\" identified by \"123321\" with grant option;`. \n\t\t> 授权完成后，刷新下账户权限即可：`flush privileges;`。  \n    \n- Step.05：以 IntelliJ Idea IDE 为参考搭建框架，参考 [1] - [3] 中的方法；\n\t- [1] 中 `全注解方式的 SSH 基础框架` 的框架整合的思想不错，推荐在你搭建框架时参详。\n\t- [2] - [3] 的搭建方法都是 `导 Jar 包形式`，但千万要注意相对应的 Jar 包是否已经下载到本地。\n\t- 当然，推荐 `Maven` 管理项目，即它是添加依赖库的方式配置环境的，下述的内容也是基于 Maven 构建框架。\n\n## 版本信息\n- **基于以下版本，打包的 SSH 框架 ( Maven )**：[SSHFrameComposition.2018.08.15](https://pan.baidu.com/s/11czZlhOzSLNX7gB16t1AtQ)\n\n\t> 这是基于 Maven 构建的 SSH 框架项目，若有错误的地方还望指正。\n\n-  框架版本：\n\t- Struts：2.5.16\n\t- Spring：4.3.x\n\t- Hibernate：5.2.x\n- 其他组件：\n\t- MySQL：5.7.x / SQL Server：2008 R2\n\t- Tomcat：9.0.x\n\t- Maven：3.3.9\n\t- JDK：1.8\n- 构建框架，还需要相关依赖库 ( Jar 包 )，详细请参阅 [ioC 入门案例](#ioC-入门案例)。\n\n\t> 为便于你下载 Jar 包或校对依赖是否齐全，具体地，以下列举了 SSH 框架所需要的依赖库。\n\n| Spring | Struts2 | Hibernate |\n| :---- | :---- | :---- | \n| spring-core | asm | antlr | \n| spring-beans | asm-commons | stax2-api |\n| spring-context | asm-tree | geronimo-jta\\_1.1\\_spec |\n| spring-expression | commons-fileupload | hibernate-commons-annotation |\n| spring-web ( 整合 Web ) | commons-io | hibernate-core |\n| spring-aop ( 整合 Aop ) | commons-lang3 | hibernate-jpa |\n| aopalliance ( 整合 Aop ) | freemarker | jandex |\n| spring-aspect ( 整合 Aop ) | javassist | javassist |\n| aspectjweaver ( 整合 Aop ) | log4j-api | jboss-logging |\n| spring-orm | log4j-core | &nbsp; |\n| spring-tx ( 整合事务 ) | ognl | &nbsp; |\n| spring-jdbc ( 整合 Hibernate ) | struts-core | &nbsp; |\n| c3p0 ( 数据库连接池 ) | &nbsp; | &nbsp; |\n\n|  其他依赖库 ( Jar 包 ) | 备注 |\n| :---- | :---- |\n| junit | Junit 单元测试 |\n| mysql-connector-java | 添加 MySQL 数据库支持 |\n| struts2-spring-plugin | Struts 整合 Spring 插件 |\n| struts2-junit-plugin | 便于浏览项目中所有 action 及其与 Jsp View 的映射 |\n| jstl | JSTL 标签库 |\n| taglibs-standard-impl | 标签库 |\n\n\n\n## 框架初识\n\n### ORM 框架\n- 对象关系映射（Object Relational Mapping，O/R Mapping，ORM）是通过使用描述对象和数据库之间映射的 `元数据`，将面向对象语言程序中的 `对象` 自动 `持久化` 到 `关系数据库` 中。本质上就是将数据从一种形式转换到另外一种形式。 \n- 让 `实体类` 和 `数据库表` 进行一一对应关系 (映射关系)，`实体类属性` 和 `表里面的字段` 对应。操作表对应实体类对象，而不需操作数据库表。\n\n### SSH 框架\nSSH 框架：[Spring](http://spring.io/)、[Struts2](http://struts.apache.org/)、[Hibernate](http://hibernate.org/) \n\n集成 SSH 框架的系统从职责上分为四层：`表示层`、`业务逻辑层`、`数据持久层` 和 `域模块层`，以帮助开发人员在短期内搭建结构清晰、可复用性好、维护方便的 Web 应用程序。其中使用 `Struts` 作为 `系统的整体基础架构`，负责 MVC 的分离，在 Struts 框架的模型部分，控制业务跳转，利用 `Hibernate` 框架对 `持久层` 提供支持，`Spring` 做管理，`管理 Struts 和 Hibernate`。\n    \n具体做法是：用面向对象的分析方法根据需求提出一些模型，将这些模型实现为基本的 Java 对象，然后编写基本的 DAO (Data Access Objects) 接口，并给出 Hibernate 的 DAO 实现，采用 Hibernate 架构实现的 DAO 类来实现 Java 类与数据库之间的转换和访问，最后由 Spring 做管理，管理 Struts 和 Hibernate。\n\n---\n\n#### Struts\n主要是用来做 `表示层`，也就所谓的 `界面`，和用户直接打交道，用来处理用户的请求和请求后返回给用户的模型数据。 Struts 对 Model，View 和 Controller 都提供了对应的组件。\n\n##### Struts2 入门\n\n###### Struts2 概述\n- Struts2 框架应用在 Java EE 三层结果中的 Web 层框架；\n- Struts2 解决的问题：\n\n\t![Struts2解决的问题](/images/illustration/Project/2018/08/J2EE-SSH-SSI-1_6-1.png)\n<center>图 6-1 Struts2 解决的问题</center>\n\n###### Struts2 案例\n\n- 创建 Action：\n\n\t```java\n\t// BaseAction.java\n\t\n\tpublic class BaseAction extends ActionSupport {\n\t    @Override\n\t    // 每次访问 action ，默认执行名称 execute() 方法\n\t    public String execute() throws Exception {\n\t        return NONE;\n\t    }\n\t}\n\t```\n\t\n- 配置 Action 类访问路径：需在 Src 根目录下创建核心配置文件 struts.xml，其名称和位置是固定的。\n\n\t```xml\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<!DOCTYPE struts PUBLIC\n\t    \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\"\n\t    \"http://struts.apache.org/dtds/struts-2.3.dtd\">\n\n\t<struts>\n\t    <package name=\"sample\" extends=\"struts-default\" namespace=\"/\">\n\t        <!--\n\t         | Name 属性值填写 action 访问的名称，例如 BaseAciton.action\n\t         | Class 属性值填写目标 Action 的全路径\n\t        -->\n\t        <action name=\"BaseAction\" class=\"cn.kofes.action.BaseAction\">/\n\t            <result name=\"success\">/jsp/success.jsp</result>\n\t        </action>\n\t    </package>\n\t</struts>\n\t```\n\t\n- 配置过滤器：在 web.xml 中添加过滤器\n\t\n\t```xml\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n\t    version=\"4.0\">\n\n\t    <!-- 过滤器模块 -->\n\t    <filter>\n\t        <filter-name>struts2</filter-name>\n\t        <filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>\n\t    </filter>\n\t    <filter-mapping>\n\t        <filter-name>struts2</filter-name>\n\t        <url-pattern>/*</url-pattern>\n\t    </filter-mapping>\n\n\t    <welcome-file-list>\n\t        <welcome-file>index.jsp</welcome-file>\n\t    </welcome-file-list>\n\t</web-app>\n\t```\n\n###### Struts2  底层执行过程\n\n如图 6-2 所示，为 Struts 底层执行过程图示。\n\n![Struts底层执行过程](/images/illustration/Project/2018/08/J2EE-SSH-SSI-1_6-2.png)\n<center>图 6-2 Struts 底层执行过程</center>\n\n###### Struts2 配置\n\n- Struts 核心配置文件 ( Struts2.5.x 版本 )\n\n\t```xml\n\t<!-- Struts 2.5.x 版本的约束 -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<!DOCTYPE struts PUBLIC\n\t    \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\"\n\t    \"http://struts.apache.org/dtds/struts-2.5.dtd\">\n\t<struts>\n\t    <!-- 表单的编码/乱码问题 -->\n\t    <constant name=\"struts.i18n.encoding\" value=\"UTF-8\" />\n\t    <!-- 指定Struts2处于开发阶段，可以进行调试 -->\n\t    <constant name=\"struts.devMode\" value=\"true\" />\n\t    <constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\" />\n\n\t    <!--\n\t     | Name 属性：唯一标识 Package\n\t     | Extends 属性：属性固定的的，即 Package 中配置的类具有 action 功能\n\t     | Namespace 属性：与 action 标签名构成访问路径\n\t    -->\n\t    <package name=\"sample\" namespace=\"/\" extends=\"struts-default\" strict-method-invocation=\"false\">\n\t        <!-- Struts2.5.x 版本特征，提升安全性 -->\n\t        <global-allowed-methods>regex:.*</global-allowed-methods>\n\n\t        <!--\n\t         | Name 属性：唯一标识，与 namespace 构成访问访问路径\n\t         | Class 属性：Action 类的全路径\n\t         | Method 属性：除了 execute() 方法，若绑定 Action 类其他方法则用此属性\n\t        -->\n\t        <action name=\"baseAction\" class=\"cn.kofe.action.baseAction\" method=\"login\">\n\t            <!--\n\t             | 根据 Action 类中方法的返回值，配置到不同的路径里面\n\t             | Name 属性：与 Action 类对应的方法的返回值一样\n\t             | Type 属性：配置如何到路径中 ( 转发或者重定向 )，默认值为转发\n\t            -->\n\t            <result name=\"success\">/success.jsp</result>\n\t        </action>\n\t\n\t        <!-- Add actions here -->\n\n\t    </package>\n\t</struts>\n\t```\n\n###### Struts2 Action 创建\n\n- 创建普通类，不继承任何类，不实现任何接口；\n\n- ~~创建类，实现 Action 接口~~；\n\n\t```java\n\tpublic class BaseAction implements Action {\n\t    @Override\n\t    public String execute throws Exception {\n\t        return NONE; // SUCCESS、ERROR ( 也可自定义字符串 ) ... \n\t    }\n\t}\n\t```\n- 创建类，继承 ActionSupport；\n\n\t```java\n\tpublic class BaseAction extends ActionSupport {\n\t    @Override\n\t    public String execute throws Exception {\n\t        return NONE; // SUCCESS、ERROR ( 也可自定义字符串 ) ... \n\t    }\n\t    \n\t    // 自定义方法\n\t    public String login() { return SUCCESS; }\n\t}\n\t```\n\n###### Struts2 Action 方法访问\n\n- 使用 action 标签中的 method 属性，在属性里写执行的 action 的方法名称；\n\n\t```xml\n\t<package name=\"sample\" namespace=\"/\" extends=\"struts-default\" strict-method-invocation=\"false\">\n\t    <action name=\"login\" class=\"cn.kofes.action.BaseAction\" method=\"login\" />\n\t</package>\n\t```\n\n- 使用通配符方式实现；\n\n\t```xml\n\t<package name=\"sample\" namespace=\"/\" extends=\"struts-default\" strict-method-invocation=\"false\">\n\t    <!-- 例如，访问路径为 http://192.168.x.x/action_login.action -->\n\t    <action name=\"action_*\" class=\"cn.kofes.action.BaseAction\" method=\"{1}\" />\n\t</package>\n\t```\n\n- 动态访问实现；\n\n\t```xml\n\t <!-- 动态方法访问 -->\n\t<constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\" />\n\t\n\t<!-- strict-method-invocation：是否允许使用通配符 ( 默认开启，不需要关闭 ) -->\n\t<package name=\"sample\" namespace=\"/\" extends=\"struts-default\" strict-method-invocation=\"true\">\n\t    <!-- 还可以限制具体哪些方法可以动态访问 -->\n\t    <global-allowed-methods>regex:.*</global-allowed-methods>\n\t    <action name=\"login\" class=\"cn.kofes.action.BaseAction\" method=\"login\" />\n\t</package>\n\t```\n\n- 常见错误：\n\t- 若 action 方法有返回值，在配置文件中没有配置，会出现无法找到页面的错误 (404)。\n\t- action 的名称，action 方法的返回值常量，规范使用 `驼峰式命名` 定义。\n\n##### Struts2 数据操作\n\n###### 结果页面配置\n- 全局结果页面：若多个 Action，方法的返回值相同，到达页面也是相同，则可使用全局结果页面配置。\n\n\t```xml\n\t<package name=\"sample\" namespace=\"/\" extends=\"struts-default\">\n\t    <global-results>\n\t        <result name=\"success\">/success.jsp</result>\n\t    </global-results>\n\t</package>\n\t```\n\n- 局部结果页面：若配置了全局和局部结果页面，以局部为准。\n\n\t```xml\n\t<package name=\"sample\" namespace=\"/\" extends=\"struts-default\">\n\t    <action name=\"login\" class=\"cn.kofes.action.BaseAction\" method=\"login\" />\n\t</package>\n\t```\n\n- Result 标签 的 Type 属性 (值)：\n\t- `dispatcher`：默认值，转发操作。\n\t- `redirect`：重定向操作。\n\t- `redirectAction`：重定向到 action。\n\t- ~~`chain`：转发到 action ( 缓存问题 )~~。\n\n###### 表单数据操作\n- 先构造一个表单：\n\n\t```html\n\t<!-- login.jsp -->\n\t<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n\t<html>\n\t    <head>\n\t        <title>SSH_FRAME_COMP</title>\n\t    </head>\n    \t    \n\t    <body>\n\t        <form action=\"${pageContext.request.contextPath}/form.action\" method=\"post\">\n\t            Username：<input type=\"text\" name=\"username\" /><br/>\n\t            Age：<input type=\"text\" name=\"age\" /><br/>\n\t            Email：<input type=\"text\" name=\"email\" /><br/>\n\t            Phone：<input type=\"text\" name=\"phone\" /><br/>\n\t        <input type=\"submit\" value=\"Submit\" />\n\t        </form>\n\t    </body>\n\t</html>\n\t\n\t<!-- struts.xml -->\n\t<action name=\"FormOperator\" class=\"cn.kofes.action.FormOperator\" method=\"execute\">\n\t    <!-- 若返回 \"success\"，则重定向到另一个 action，即执行登录 -->\n\t    <result name=\"success\" type=\"redirectAction\">login</result>\n\t</action>\n\t```\n\n- action 获取表单提交数据\n\n\t```java\n\tpublic class FormOperator extends ActionSupport {\n\t\n\t    public String execute() throw Exception { \n\t    \n\t        // Case.01.使用 ActionContext 类获取\n\t        ActionContext context = ActionContext.getContext();\n\t        // key 时表单输入项 Name 的属性值，Value 时输入的值 \n\t        Map<String, Object> map = context.getParameters();\n\t        Set<String> keys = map.keySet();\n\t        for(String key : keys) {\n\t            // 数组形式，考虑有复选框的情况\n\t            Object[] obj = (Object[]) map.get(key);\n\t        }\n \t\n\t        // Case.02.使用 ServletActionContext 类获取\n\t        HttpServletRequest request = ServletActionContext.getRequest();\n\t        String username = request.getParamter(\"username\");\n\t        \n\t        rerun NONE;\n\t    }\n\t}\n\t\n\t// Case.03.使用接口注入方式获取\n\tpublic class FormOperator extends ActionSupport implements ServletRequestAware {\n\t\n\t    private HttpServletRequest request;\n\t    \n\t    @Overrride\n\t    public  void setServletRequest(HttpServletRequest request) {\n\t        this.request = request;\n\t    }\n\t    \n\t    public String execute() throw Exception {\n\t        String username = request.getParamter(\"username\");\n\t        return NONE;\n\t    }\n\t}\n\t```\n\t\n- action 操作域对象\n\n\t```java\n\tpublic class FormOperator extends ActionSupport {\n\t\n\t    public String execute() throw Exception { \n\t    \n\t        // 操作域对象\n\t        // Request 域\n\t        HttpServletRequest request = ServletActionContext.getRequest();\n\t        request.setAttribute(\"requestKey\", \"requestValue\");\n\t        \n\t        // Session 域\n\t        HttpSession session = request.getSession();\n\t        session.setAttribute(\"sessionKey\", \"sessionValue\");\n\t        \n\t        // ServletContext 域\n\t        ServletContext context = ServletActionContext.getServletContext();\n\t        context.setAttribute(\"contextKey\", \"contextValue\");\n\t        \n\t        rerun NONE;\n\t    }\n\t}\n\t```\n\n- struts2 提供获取表单数据方式\n\n\t```java\n\t// 原始方式获取表单数据，再封装数据到实体类对象中\n\tUser user = new User();\n\tHttpServletRequest request = ServletActionContext.getRequest();\n\tuser.setUsername( request.getParamter(\"username\") );\n\t\n\t// 属性封装：获取表单数据到属性中  ( Setter 和 Getter 方法补全即可 )\n\t// 在 action 的成员变量位置定义变量 ( 变量名称和表单输入项的 Name 属性值一样 )\n\tprivate String username;\n\tpublic void setUsername(String username) { this.username = username }\n\tpublic String getUsername() { return username; }\n\t// 以此类推...\n\t\n\t// 模型驱动封装\n\t// Step.01. 实现接口 ModelDriven\n\t// Step.02. 实现接口的方法 getModel()，再把创建对象返回\n\t// Step.03. 在 action 里『创建』实体类对象\n\tpublic class FormOperator extends ActionSupport implements ModelDriven<User> {\n\t    private User user = new User();\n\t    @Override\n\t    public User getModel() {\n\t        return user;\n\t    }\n\t    @Override\n\t    public Sring execute() throw EXception {\n\t        return NONE;\n\t    }\n\t}\n\t\n\t// 表达式封装\n\t// Step.01.在 action 中『声明』实体类；\n\t// Step.02.生成实体类变量的 Setter 和 Getter 方法\n\t// Step.03.再表单输入项的 Name 属性值中填写表达式\n\t\n\t// 表达式：<input type=\"text\" name=\"user.username\" />\n\t\n\tpublic class FormOperator extends ActionSupport {\n\t    private User user;\n\t    public void setUser(User user) { this.user = user; }\n\t    public User getUser() { return user; }\n\t    \n\t    @Override\n\t    public Sring execute() throw EXception {\n\t        return NONE;\n\t    }\n\t}\n\t```\n\t\n> 使用模型驱动和属性封装是注意事项：在同一个 action 中，获取表单数据可以是模型驱动合作和属性封装，但不能同时使用二者。`同时使用只会执行模型驱动`。  \n\n- `表达式封装` 和 `模型驱动` 比较：  \n\t- 相同点：使用表达式封装和模型驱动封装都可把数据封装到实体类对象里。\n\t- 不同点：使用模型驱动只能把数据封装到一个实体类对象里。而表达式封装没有限制，即通过表达式封装可把数据封装到多个、不同的实体类对象里面。\n\n- struts2 获取数据封装到集合：\n\t\n\t```xml\n\t<!-- 封装数据到 List 集合 -->\n\t<input type=\"text\" name=\"list[0].username\" />\n\t<input type=\"text\" name=\"list[0].age\" />\n\t<input type=\"text\" name=\"list[1].username\" />\n\t<input type=\"text\" name=\"list[1].age\" />\n\t\n\t<!-- 封装数据到 Map 集合 -->\n\t<input type=\"text\" name=\"map['Lucy'].username\" />\n\t<input type=\"text\" name=\"map['Lucy'].age\" />\n\t<input type=\"text\" name=\"map['Mark'].username\" />\n\t<input type=\"text\" name=\"map['Mark'].age\" />\n\n\t\n\t<!-- 在实现类中声明 -->\n\tpublic class FormOperator extends ActionSupport {\n\t    private List<User> list;\n\t    public void setList(List<User> list) { this.list = list; }\n\t    public List<User> list getUser() { return list; }\n\t     \n\t    // private Map<String, User> map;\n\t    // public void setMap(Map<String, User> map) { this.map = map }\n\t    // public Map<String, User> getMap() { return map; }\n\t    \n\t    @Override\n\t    public Sring execute() throw EXception {\n\t        return NONE;\n\t    }\n\t}\n\t```\n\t\n###### 案例实操展示\n- 新建表单操作页面 `form.jsp` 和数据展示页面 `info.jsp`：\n\n\t```html\n\t<!-- form.jsp -->\n\t<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n\t<html>\n\t    <head>\n\t        <title>SSH_FRAME_COMP</title>\n\t    </head>\n\t    <body>\n\t        <form name=\"loginForm\" action=\"${pageContext.request.contextPath}/form.action\" method=\"post\">\n\t            Username：<input type=\"text\" name=\"user.username\"/><br/>\n\t            Age：<input type=\"text\" name=\"user.age\"/><br/>\n\t            Email：<input type=\"text\" name=\"user.email\"/><br/>\n\t            Phone：<input type=\"text\" name=\"user.phone\"/><br/>\n\t            <input type=\"submit\" value=\"Submit\"/>\n\t        </form>\n\t    </body>\n\t</html>\n\t\n\t<!-- info.jsp -->\n\t```\n\t\n- 在 struts.xml 配置文件中添加 action：\n\n\t```xml\n\t<!-- struts.xml -->\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<!DOCTYPE struts PUBLIC\n\t    \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\"\n\t    \"http://struts.apache.org/dtds/struts-2.5.dtd\">\n\n\t<struts>\n\t    <!-- 表单的编码/乱码问题 -->\n\t    <constant name=\"struts.i18n.encoding\" value=\"UTF-8\" />\n\t    <!-- 动态方法访问 -->\n\t    <constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\" />\n\n\t    <package name=\"sample\" namespace=\"/\" extends=\"struts-default\" strict-method-invocation=\"true\">\n\t        <global-allowed-methods>regex:.*</global-allowed-methods>\n\t        \n\t        <!-- 使用注解创建 FormOperator 对象，直接引用标签值 -->\n\t        <action name=\"form\" class=\"formOperator\" method=\"saveInfo\">\n\t            <result name=\"getinfo\" type=\"redirectAction\">info</result>\n\t        </action>\n\t        \n\t        <!-- 插入数据后加载数据库 -->\n\t        <action name=\"info\" class=\"formOperator\" method=\"getInfo\">\n\t            <result name=\"listinfo\">/jsp/info.jsp</result>\n\t        </action>\n\t        \n\t    </package>\n\t</struts>\n\t```\n\t\n- 在 Action 中实现逻辑处理类：\n\n\t```java\n\t// FormOperator.java\n\t// Action 层：界面交互层\n\t@Controller(value=\"formOperator\")\n\t@Scope(value = \"prototype\")\n\tpublic class FormOperator extends ActionSupport {\n\t    private User user;\n\t    \n\t    // Service 处理业务逻辑\n\t    @Resource(name = \"sampleService\")\n\t    private BaseService service;\n\t    \n\t    @Override\n\t    public Sring execute() throw EXception {\n\t        return NONE;\n\t    }\n\t    \n\t    public String saveInfo() {\n\t        service.saveUserInfo(user);\n\t        return \"info\";\n\t    }\n\t    \n\t    public String getInfo() {\n\t        // 从数据库中加载数据\n\t        return NONE;\n\t    }\n\t}\n\t\n\t// SampleServiceImpl.java\n\t// Servie 层：业务逻辑层\n\t@Service(value = \"sampleService\")\n\t@Transactional\n\tpublic class SampleServiceImpl implements BaseService {\n\n\t    @Resource(name = \"sampleDao\")\n\t    private BaseDao dao;\n\n\t    @Override\n\t    public void saveUserInfo(User user) {\n\t        if( null != dao.queryOneTuple(user.getClass(), user.getUid()) ) {\n\t            dao.updateOneTuple(user);\n\t        } else {\n\t            dao.insertOneTuple(user);\n\t        }\n\t    }\n\t}\n\t\n\t// SampleDaoImpl.java\n\t// Dao 层：数据持久层\n\t@Repository(value = \"sampleDao\")\n\tpublic class SampleDaoImpl implements BaseDao {\n\n\t    @Resource(name = \"hibernateTemplate\")\n\t    private HibernateTemplate hibernateTemplate;\n\n\t    @Override\n\t    public void insertOneTuple(Object entity) {\n\t        hibernateTemplate.save(entity);\n\t    }\n\t    \n\t    @Override\n\t    public void updateOneTuple(Object entity) {\n\t        hibernateTemplate.update(entity);\n\t    }\n\t    \n\t    @Override\n\t    public <T> T queryOneTuple(Class<T> entityClass, Serializable id) {\n\t        T temporary = null;\n\t        if (null != entityClass) {\n\t            temporary = hibernateTemplate.get(entityClass, id);\n\t        }\n\t        return temporary;\n\t    }\n\t}\n\t```\n\n##### Struts2 值栈\n\n###### 值栈概念\n- 什么是值栈：\n\t- Struts 里本身提供一种存储机制，类似于 `域对象`。即值栈，可存储数据也可读取数据。\n\t- Striuts 把数据放到值栈里，在 Jsp 页面中获取到值栈数据。\n\n- Ognl：Web 阶段，EL 表达在 Jsp 中获取域对象中的值。而 Ognl 也是一种表达式。\n\t- Struts 中操作值栈数据，和 `Struts 标签` 一起使用、操作值栈。\n\t- Ognl 不是 Struts 的一部分，可以单独使用。\n- Struts 标签：虽然标签封装了样式，方便操作，但故样式上会有限制。\n\n\t```html\n\t<!-- 在对应的 jsp 页面中引入标签库  -->\n\t<%@ taglib uri=\"/struts-tags\" prefix=\"s\" %>\n\t\n\t<!-- 查看值栈结构和数据 -->\n\t<s:debug />\n\t\n\t<!-- 使用 Ognl + Struts 标签，实现计算字符串长度 -->\n\t<s:property value=\"'str'.length()\" />\n\t\n\t<!-- html 表单标签\n\t | 1) form：action、method、enctype\n\t | 2) 输入项：大部分在 input 中封装 type 值实现各种输入项，例如：\n\t |    text，普通文本输入项\n\t |    password，密码输入项\n\t |    radio，单选输入项\n\t |    checkbox，复选输入项\n\t |    file，文件上传项\n\t |    hidden，隐藏项\n\t |    button，普通按钮\n\t |    submit，提交按钮\n\t |    image，图片提交\n\t |    reset，重置\n\t | 3) select：下拉输入项\n\t | 4) textarea：文本域\n\t-->\n\t<s:form name=\"signupForm\" action=\"form.action' method=\"POST\">\n\t    <!-- 普通输入项 -->\n\t    <s:textfield name=\"username\" label=\"username\" />\n\t    <!-- 密码输入项 -->\n\t    <s:password name=\"password\" label=\"password\" />\n\t    <!-- 单选项 -->\n\t    <s:radio list=\"#{'male':'男', 'female':'女'}\" name=\"gender\" label=\"gender\" />\n\t    <!-- 多选项 -->\n\t    <s:checkboxlist list=\"{'sleep', 'eat'}\" name=\"interest\" label=\"interest\" />\n\t    <!-- 下拉输入框 -->\n\t    <s:select list=\"{'str1', 'str2', 'str3'}\" name=\"sample\" label=\"sample\" />\n\t    <!-- 文件上传项 -->\n\t    <s:file name=\"file\" label=\"file\" />\n\t    <!-- 文本域 -->\n\t    <s:textarea row=\"10\" cols=\"10\" name=\"description\" value=\"description\" />\n\t    <!--  隐藏项 -->\n\t    <s:hidden name=\"hiddenContent\" value=\"hidden content is here\" />\n\t    <!-- 提交按钮 -->\n\t    <s:submit value=\"Submit\" />\n\t</s:form>\n\t\n\t\n\t```\n- Servlet 和 Action 区别：\n\t- Servlet：默认在第一次访问时创建，仅创建一次。( 单实例 )\n\t- Action：访问时候创建，且每次访问时都会创建 action 对象。( 多实例 )\n\n\n###### 获取值栈对象\n- 使用 ActionContext 类的方法获取值栈对象\n\n\t```java\n\t\n\tpublic class FormOperator extends ActionSupport {\n\t    private User user;\n\t    \n\t    @Override\n\t    public Sring execute() throw EXception {\n\t        ActionContext context = ActionContext().getContext();\n\t        ValueStack stack = context.getValueStack();\n\t        return NONE;\n\t    }\n\t}\t\n\t```\n\n###### 值栈内部结构\n值栈主要分为两部分：\n\n- Root：List 集合 `Class Compoundroot extends ArrayList { ... }`\n\t\n- Context：Map 集合 `Class Compoundroot extends Object implements Map { ... }`\n\n\t![Context 存储的对象引用](/images/illustration/Project/2018/08/J2EE-SSH-SSI-1_6-3.png)\n\t<center>图 6-3 Context 存储的对象引用</center>\n\n###### 向值栈存数据\n\n> 结合 `<s:debug />` 标签，可浏览值栈的传值情况。\n\n向值栈存数据的多种方式：\n\n- 获取值栈对象，调用值栈对象的 set 方法。\n- 获取值栈对象，调用值栈对象的 push 方法。\n- 在 action 定义变量，生产变量的 get 方法。\n\t\n\t```java\n\t// 获取值栈对象\n\tActionContext context = ActionContext.getContext();\n\tValueStack stack = context.getValueStack();\n\t\n\t// 向值栈放字符串\n\t// Case.01\n\tstack.set(\"username\", \"AttrSet\");\n\t// Case.02\n\tstack.push(\"PushMethod\");\n\t// Case.03.声明变量，生成 Getter 方法\n\tprivate String str;\n\tpublic String getStr() { return str; }\n\tstr = \"SetStrAttr\";\n\n\t// 向值栈放对象\n\tprivate User user;\n\tpublic User getUser() { return user; }\n\t// user.setXXX();\n\t\n\t// 向值栈放 List 集合\n\tprivate List<User> list;\n\tpublic List<User> getList() { return list; }\n\tlist = getAllUserInfo(User.class);\n\t```\n\n###### 从值栈取数据\n\n- 从值栈获取数据\n\n\t```html\n\t<!-- 在对应的 jsp 页面中引入 struts 标签库  -->\n\t<%@ taglib uri=\"/struts-tags\" prefix=\"s\" %>\n\t\n\t<!-- 在 Jsp 页面中获取属性值 -->\n\t<s:property value=\"str\" />\n\t\n\t<!-- Jsp 页面中获取对象的值 -->\n\t<s:property value=\"user.username\" />\n\t<s:property value=\"user.email\" />\n\t\n\t<!-- Jsp 页面中获取 List 集合：方式 1 -->\n\t<s:iterator value=\"list\">\n\t    <s:property value=\"username\" />\n\t    <s:property value=\"age\" />\n\t    <s:property value=\"email\" />\n\t    <s:property value=\"phone\" />\n\t</s:iterator>\n\t\n\t<!-- Jsp 页面中获取 List 集合：方式 2 -->\n\t<s:iterator value=\"list\" var=\"user\">\n\t    <s:property value=\"#user.username\" />\n\t    <s:property value=\"#user.age\" />\n\t    <s:property value=\"#user.email\" />\n\t    <s:property value=\"#user.phone\" />\n\t</s:iterator>\n\t```\n\n---\n\n#### Spring\n`业务逻辑层`，是一个轻量级的控制反转 (IoC) 和面向切面 (AOP) 的容器框架。\n\n#####  Spring 概念\n- 一站式轻量级开源框架，在 Java EE 三层结构中，每一层提供不同的解决技术。\n\t- `Web 层`：Spring MVC\n\t- `Service 层`：ioC\n\t- `DAO 层`：Spring 的 JdbcTemplate\n- AOP：`面向切面编程`，扩展功能不是通过修改源码实现的，即通过 `动态代理技术`，把各类通知 / 增强织入到它所约定的流程当中。事实上，是通过引入其他类的方法来实现的。\n- ioC：`控制反转`，例如：对象的创建不通过 new 方式实现，而是通过 Spring 配置创建类对象。\n\n##### Spring ioC\n控制反转 (ioC)，是一种通过描述 (在 Java 中可以是 XML 或者注解) 并通过第三方去产生或获取特定对象的方式。\n\n###### ioC 底层原理\n- 使用技术：\n\t- XML 配置文件；\n\t- Dom4j 解析 XML；\n\t- 工厂设计模式；\n\t- 类的反射.\n- 代码实现：\n\t- 创建 XML 配置文件，配置要创建对象类。\n\t- 创建工厂类，使用 Dom4j 解析配置文件，通过反射创建类对象。\n\t\n###### ioC 入门案例\n- Maven 中添加依赖库 ( 对应导入 Jar 包 )：\n\n\t> 下载 Jar 包：到 [Maven Pository](http://mvnrepository.com/) 中搜索目标 Jar 包，在具体页面中的 Files 一栏可下载。例如：[log4j-core.2.11.0](http://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core/2.11.0)\n\n\t```xml\n\t<!-- porm.xml -->\n\t\n\t<!-- Version Control of Jar Dependency  -->\n\n\t<properties>\n\t    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n\t    <spring.version>4.3.18.RELEASE</spring.version>\n\t    <hibernate.version>5.2.17.Final</hibernate.version>\n\t    <struts2.version>2.5.16</struts2.version>\n\t</properties>\n\t\n\t<!-- Foundation of SSH ( Spring、Struts 2、Hibernate ) -->\n\n\t<dependencies>\n\n\t    <!-- spring -->\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-beans</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-core</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-context</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-expression</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n        \n\t    <!-- 以下依赖包为下文所需要的，为方便起见这里统一配置 -->\n\n\t    <!-- struts2 -->\n\t    <dependency>\n\t        <groupId>org.apache.struts</groupId>\n\t        <artifactId>struts2-core</artifactId>\n\t        <version>${struts2.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.ow2.asm</groupId>\n\t        <artifactId>asm</artifactId>\n\t        <version>5.2</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.ow2.asm</groupId>\n\t        <artifactId>asm-commons</artifactId>\n\t        <version>5.2</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.ow2.asm</groupId>\n\t        <artifactId>asm-tree</artifactId>\n\t        <version>5.2</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>commons-fileupload</groupId>\n\t        <artifactId>commons-fileupload</artifactId>\n\t        <version>1.3.3</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>commons-io</groupId>\n\t        <artifactId>commons-io</artifactId>\n\t        <version>2.5</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.apache.commons</groupId>\n\t        <artifactId>commons-lang3</artifactId>\n\t        <version>3.6</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.freemarker</groupId>\n\t        <artifactId>freemarker</artifactId>\n\t        <version>2.3.23</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.javassist</groupId>\n\t        <artifactId>javassist</artifactId>\n\t        <version>3.22.0-GA</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>ognl</groupId>\n\t        <artifactId>ognl</artifactId>\n\t        <version>3.1.15</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>javax</groupId>\n\t        <artifactId>javaee-api</artifactId>\n\t        <version>8.0</version>\n\t        <scope>provided</scope>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>javax.servlet</groupId>\n\t        <artifactId>jstl</artifactId>\n\t        <version>1.2</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.apache.taglibs</groupId>\n\t        <artifactId>taglibs-standard-impl</artifactId>\n\t        <version>1.2.5</version>\n\t    </dependency>\n\n\t    <!-- config-browser-plugin 插件方便浏览项目中的所有 Action 及其与 Jsp View 的映射 -->\n\t    <dependency>\n\t        <groupId>org.apache.struts</groupId>\n\t        <artifactId>struts2-junit-plugin</artifactId>\n\t        <version>${struts2.version}</version>\n\t        <scope>test</scope>\n\t    </dependency>\n\n\t    <!-- Hibernate -->\n\t    <dependency>\n\t        <groupId>org.hibernate</groupId>\n\t        <artifactId>hibernate-core</artifactId>\n\t        <version>${hibernate.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.hibernate.common</groupId>\n\t        <artifactId>hibernate-commons-annotations</artifactId>\n\t        <version>5.0.4.Final</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.hibernate.javax.persistence</groupId>\n\t        <artifactId>hibernate-jpa-2.1-api</artifactId>\n\t        <version>1.0.2.Final</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.jboss</groupId>\n\t        <artifactId>jandex</artifactId>\n\t        <version>2.0.5.Final</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.jboss.logging</groupId>\n\t        <artifactId>jboss-logging</artifactId>\n\t        <version>3.3.2.Final</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>antlr</groupId>\n\t        <artifactId>antlr</artifactId>\n\t        <version>2.7.7</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.codehaus.woodstox</groupId>\n\t        <artifactId>stax2-api</artifactId>\n\t        <version>3.1.4</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.apache.geronimo.specs</groupId>\n\t        <artifactId>geronimo-jta_1.1_spec</artifactId>\n\t        <version>1.1.1</version>\n\t    </dependency>\n\n\t    <!-- Combining with SSH ( Spring、Struts 2、Hibernate ) framework -->\n\n\t    <!-- Spring 整合 Hibernate 和事务 -->\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-jdbc</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-orm</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-tx</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\n\t    <!-- Spring 整合 AOP -->\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-aop</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-aspects</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>aopalliance</groupId>\n\t        <artifactId>aopalliance</artifactId>\n\t        <version>1.0</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.aspectj</groupId>\n\t        <artifactId>aspectjweaver</artifactId>\n\t        <version>1.9.1</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>cglib</groupId>\n\t        <artifactId>cglib-nodep</artifactId>\n\t        <version>3.2.7</version>\n\t    </dependency>\n\n\t    <!-- Spring 整合 Web -->\n\t    <dependency>\n\t        <groupId>org.springframework</groupId>\n\t        <artifactId>spring-web</artifactId>\n\t        <version>${spring.version}</version>\n\t    </dependency>\n\n\t    <!-- Sturts 2 整合 Spring 框架 -->\n\t    <dependency>\n\t        <groupId>org.apache.struts</groupId>\n\t        <artifactId>struts2-spring-plugin</artifactId>\n\t        <version>${struts2.version}</version>\n\t    </dependency>\n\n\t    <!-- Others -->\n\n\t    <!-- 添加对 MySQL 数据库的支持 -->\n\t    <dependency>\n\t        <groupId>mysql</groupId>\n\t        <artifactId>mysql-connector-java</artifactId>\n\t        <version>6.0.6</version>\n\t    </dependency>\n\n\t    <!-- 添加对数据源的支持 -->\n\t    <!-- https://mvnrepository.com/artifact/com.mchange/c3p0 -->\n\t    <dependency>\n\t        <groupId>com.mchange</groupId>\n\t        <artifactId>c3p0</artifactId>\n\t        <version>0.9.5.2</version>\n\t    </dependency>\n\n\t    <!-- c3p0数据库连接池的辅助包 -->\n\t    <dependency>\n\t        <groupId>com.mchange</groupId>\n\t        <artifactId>mchange-commons-java</artifactId>\n\t        <version>0.2.15</version>\n\t    </dependency>\n\n\t    <!-- 日志系统 -->\n\t    <dependency>\n\t        <groupId>org.apache.logging.log4j</groupId>\n\t        <artifactId>log4j-core</artifactId>\n\t        <version>2.10.0</version>\n\t    </dependency>\n\t    <dependency>\n\t        <groupId>org.apache.logging.log4j</groupId>\n\t        <artifactId>log4j-api</artifactId>\n\t        <version>2.10.0</version>\n\t    </dependency>\n\n\t    <!-- Junit -->\n\t    <dependency>\n\t        <groupId>junit</groupId>\n\t        <artifactId>junit</artifactId>\n\t        <version>4.12</version>\n\t        <scope>compile</scope>\n\t    </dependency>\n\n    </dependencies>\n\t```\n\t\n- 创建 Spring 配置文件：在 Src 目录下 (建议)，创建 Spring 核心配置文件 applicationContext.xml。\n\t\n\t```xml\n\t<!-- applicationContext.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xsi:schemaLocation=\"\n\t    http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd>\n\t    <bean id=\"operator\" class=\"cn.entity.UserOperator\"></bean>\n\t</beans>\n\t```\n\n- 再配置创建类，对象创建 (方便演示，以单元测试形式呈现)：\n\n\t```java\n\t// 单元测试类\n\tpublic class ioCTest() {\n\t    @Test\n\t    public void testUser() {\n\t        // Step.01.加载 Spring 配置文件\n\t        ApplicationContext context  = \n\t            new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t            \n\t        // Step.02. 得到配置创建的对象\n\t        UserOperator operator = \n\t            (UserOperator) context.getBean(\"operator\");\n\t    }\n\t}\n\t```\n\n##### Spring Bean 管理 (XML)\n\n###### Bean 标签常用属性\n- ID 属性：Bean 标签的名称，要求只含数字和大小写英文字母。\n- Class 属性：常见对象所在类的全路径。\n- Name 属性：功能和 ID 属性一样，Name 属性可包含特殊字符值。\n- Scope 属性：\n\t- `singleton`：单例的 ( 默认值 )。\n\t- `prototype`：多例的。\n\n###### Bean 实例化的方式\n- 使用类的无参数构造创建对象\n\n\t```java\t\n\tpublic class UserOperator {\n\t   public UserOperator() { }\n\t}\n\t```\n\n- 使用静态工厂创建对象\n\n\t```java\n\tpublic class UserOperatorFactory {\n\t    public static UserOperator getOperator() {\n\t        String className = \"classValue\"; // cn.entity.UserOperator\n\t        Class clz = Class.forName(className);\n\t        return clz.newInstance();\n\t    }\n\t}\n\t```\n\t\n- 上述实例化方法在 applicationContext.xml 中的配置：\n\n\t```xml\n\t<!-- 无参数构造创建对象 -->\n\t<bean id=\"operator\" class=\"cn.kofes.entity.UserOperator\" scope=\"singleton\"></bean>\n   \n\t<!-- 静态工厂创建对象 -->\n\t<bean id=\"operator\" class=\"cn.kofes.entity.UserOperatorFactory\" factory-method=\"getOperator\"></bean>\n    \n\t```\n\n###### 属性注入方式\n- Set() 方法注入\n\n\t```java\n\tpublic class UserOperator {\n\t    private String operationType;\n\t    public void setUsername(String operationType) {\n\t        this.operationType = operationType;\n\t    }\n\t}\n\t```\n\n- 有参数构造注入\n\n\t```java\n\tpublic class UserOperator {\n\t    private String operationType;\n\t    public UserOperator(String operationType) {\n\t        this.operationType = operationType;\n\t    }\n\t}\n\t```\n\t\n- 注入 `对象属性` 类型：\n\n\t```java\n\tpublic class UserOperator {\n\n    private User user;\n    \n    public void setUser(User user) {\n        this.user = user;\n    }\n    \n\t    @Test\n\t    public void operatorTest() {\n\t        ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t        UserOperator operator = (UserOperator) context.getBean(\"operator\");\n\t        // TODO\n\t    }\n\t}\n\t```\n\t\n- 注入 `复杂类型` 属性：\n\t- 数组\n\t- List 集合\n\t- Map 集合\n\t- Properties 类型\n\n\t```java\n\tpublic class UserOperatorXML {\n\t    private String arrs;\t\t// 数组\n\t    private List<String> list;\t\t// List 集合\n\t    private Map<String, String> map;\t// Map 集合\n\t    private Properties properties;\t// Properties 类型\n\t    \n\t    // Setter() 方法此处省略...\n\t    \n\t    @Test\n\t    public void operatorTest() {\n\t        ApplicationContext context = \n\t        \tnew ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t        UserOperatorXML operator =\n\t        \t (UserOperatorXML) context.getBean(\"operator\");\n\t        // TODO\n\t    }\n\t}\n\t```\n\t\n- 上述 `注入方法` 在 applicationContext.xml 中的配置：\n\n\t```xml\n\t<!-- -- 有参数构造注入属性 -- -->\n\t<bean id=\"operator\" class=\"cn.kofes.entity.UserOperatorXML\">\n\t    <constructor-arg name=\"operationType\" value=\"modify\" />\n\t</bean>\n    \n\t<!-- -- Set 方法注入属性 -- -->\n\t<bean id=\"operator\" class=\"cn.kofes.entity.UserOperatorXML\">\n\t    <property name=\"operationType\" value=\"modify\" />\n\t</bean>\n\t\n\t<!-- -- 注入 对象属性 类型 -- -->\n\t<bean id=\"user\" class=\"cn.kofes.entity.User\"></bean>\n\n\t<bean id=\"operator\" class=\"cn.kofes.entity.UserOperatorXML\">\n\t    <!--\n\t     | Name 属性值：类里面的定义属性的名称\n\t     | Ref 属性：定义属性在 Bean 标签中的 ID 值\n\t    -->\n\t    <property name=\"user\" ref=\"user\" />\n\t</bean>\n\t\n\t\n\t<!-- -- 注入 复杂类型 属性 -- -->\n\t<bean id=\"complex\" class=\"cn.kofes.entity.UserOperatorXML\">\n\t    <!-- 数组、List 集合适用 -->\n\t    <property name=\"arrs\">\n\t        <lsit><value>Arrs0</value></lsit>\n\t        <lsit><value>Arrs1</value></lsit>\n\t        <lsit><value>Arrs2</value></lsit>\n\t    </property>\n\n\t    <!-- Map 集合 -->\n\t    <property name=\"map\">\n\t        <map>\n\t            <entry key=\"seq1\" value=\"str1\" />\n\t            <entry key=\"seq2\" value=\"str2\" />\n\t            <entry key=\"seq3\" value=\"str3\" />\n\t        </map>\n\t    </property>\n\n\t    <!-- Properties：例如我们要配置数据库 -->\n\t    <property name=\"properties\">\n\t        <props>\n\t            <prop key=\"driverclass\">com.mysql.jdbc.Driver</prop>\n\t            <prop key=\"username\">root</prop>\n\t            <prop key=\"password\">123456</prop>\n\t        </props>\n\t    </property>\n\t</bean>\n\t```\n\t\n###### Spring DI\nioC 与 DI 的区别\n\n- `ioC`：`控制反转`，把对象创建交给 Spring 进行配置。\n- `DI`：`依赖注入`，向类中的属性设置属性值。\n\t\n\t> 关系：依赖注入不能单独存在，需在 ioC 基础之上完成操作。\n\t\n##### Spring Bean 管理 (注解)\n- 注解格式：`@注解名称(value=\"属性值\")` 或者 `@注解名称(\"属性值\")` \n- `@Component(\"user\")` 相当于 `<bean id=\"user\" class=\"\" />`，其三个衍生注解为：\n\t- @Controller：Web 层，相当于 Struts 中的 Action 层。\n\t- @Service：业务层 ，业务逻辑处理。\n\t- @Repository：持久层，标注数据访问组件，即 DAO 组件。\n\n\t> 功能目前来说是一致的，即创建对象。\n\t\n- `@Scope(\"prototype\")` 或 `@Scope(\"singleton\")`：即配置的对象是单实例还是多实例。\n\n\t```java\n\t@Component(\"BaseAction\")\n\t@Scope(\"prototype\")\n\tpublic class BaseAction { ... }\n\t```\n\n###### 基本内容\n- 使用注解创建对象\n- 使用注解注入对象\n- xml 和注解方式混合使用\n\n###### 小试牛刀\n- 创建类和方法\n\n\t```java\n\tpublic class User { /* 省略实体类的属性 */ }\n\tpublic class Customer { /* 省略实体类的属性 */ }\n\tpublic class Firm { /* 省略实体类的属性 */ }\n\t```\n\n- 创建 Spring 配置文件，并引入约束 (在上述 applicationContext.xml 中追加)\n\t\n\t```xml\n\t<!-- applicationContext.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xsi:schemaLocation=\"\n\t    http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n\t    http://www.springframework.org/schema/context\n\t    http://www.springframework.org/schema/context/spring-context-2.5.xsd\">\n\t    \n\t    <!-- 注解扫描：扫描属性上面的注解 -->\n\t    <context:annotation-config/>\n\t    \n\t    <!-- \n\t     | 注解扫描：到包里扫描类、方法、属性上面的注解，\n\t     | 即使用 Annotation 自动注册 Bean\n\t    -->\n\t    <context:component-scan base-package=\"cn.kofes\"/>\n\t    <context:component-scan base-package=\"cn.kofes.entity\"/>\n\t</beans>\n\t```\n\t\n- 注解中创建对象\n\n\t```java\n\t// 此方式相当于 <bean id=\"user\" class=\"cn.kofes.entity.User\" />\n\t\n\t@Component(value=\"user\")  \n\tpublic class User { \n\t    // 省略实体类的属性...\n\t}\n\n\tpublic class UserOperatorAnn {\n\t    private User user;\n\n\t    @Test\n\t    public void operatorTest() {\n\t        ApplicationContext context = \n\t        \tnew ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t        System.out.println(user);\t // 直接调用 user 对象\n\t    }\n\t}\n\t```\n\n- 注解注入属性\n\n\t```java\n\t// 实体操作类\n\tpublic class UserOperatorAnn {\n\t\n\t    // 相当于 Set 方法注入属性：\n\t    // @Autowired 或者 @Resource(name = \"user\") \n\t    \n\t    @Autowired\t\n\t    private User user;\n\n\t    @Test\n\t    public void operatorTest() {\n\t        ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t        System.out.println(user);\t\n\t        System.out.println(customer);\t\n\t        System.out.println(firm);\t\n\t    }\n\t}\n\t```\n\t\n- XML 配置文件和注解混合使用\n\t- 创建对象操作使用 XML 配置文件方式实现；\n\t- 注入属性的操作使用注解方式实现.\n\n\t```java\n\t/* Start：applicationContext.xml */\n\t\n\t<bean id=\"user\" class=\"cn.kofes.entity.User\" />\n\t<bean id=\"customer\" class=\"cn.kofes.entity.Customer\" />\n\t<bean id=\"firm\" class=\"cn.kofes.entity.Firm\" />\n\t\n\t/* End：applicationContext.xml */\n\t\n\tpublic class UserOperatorAnn {\t\n\t    // 注解方式注入属性\n\t    @Resource(name = \"user\") \n\t    private User user;\n\t    @Resource(name = \"customer\") \n\t    private Customer customer;\n\t    @Resource(name = \"firm\") \n\t    private Firm firm;\n\n\t    @Test\n\t    public void operatorTest() {\n\t        ApplicationContext context = \n\t        \tnew ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t        System.out.println(user);\t\n\t        System.out.println(customer);\t\n\t        System.out.println(firm);\t\n\t    }\n\t}\n\t```\n\n##### Spring AOP\n\n###### AOP 概述\n面向切面编程 (Aspect Oriented Programing，AOP)，扩展功能不通过修改代码实现。AOP 采取 `横向抽取机制` 取代传统 `纵向继承体系` 重复性代码。\n\n- 纵向继承体系：通过继承获得父类的功能 (方法)。\n- 横向抽取机制：动态代理方式。\n\t- 针对有接口的情况，使用 JDK 动态代理。\n\t- 针对没有接口情况，使用 Cglib 动态代理。\n\n\t```java\n\tpublic interface Dao {\n\t    public void add();\n\t}\n\t\n\tpublic class DaoImpl implements Dao {\n\t    public void add() {\n\t        // 具体逻辑\n\t    }\n\t}\n\t```\n\n######  AOP 相关术语\n\n便于理解，引入实体类进行说明：\n\n```java\npublic class User {\n    public void add() {}\n    public void update() {}\n    public void delete() {}\n    public void findAll() {}\n}\n```\n\n- 连接点 (Join Point)：指那些被拦截到的点，在 Spring 这些点指的是方法，因 Spring 只支持方法类型的连接点。\n\n\t> 类中有哪些方法可被增强，这些方法称为连接点。\n\n- `切入点 (Pointcut)`：指我们要对哪些 `Join Point` 进行拦截的定义。\n\n\t> 类中有很多方法被增强，例如实际操作中，只是增强了类中的 add() 和 update() 方法，即称为切入点。\n\t\n- 引介 (Introduction)：一种特殊的通知在不修改类代码的前提下， Introduction 可为类动态地添加一些方法或 Field。\n\n- `通知/增强 (Advice)`：指拦截到 `Join Point` 之后要做的事情就是通知。通知分为前置通知、后置通知、异常通知、最终通知、环绕通知 (切面要完成的功能)。\n\n\t> 增强的逻辑称为增强，例如扩展日志功能，这个日志功能称为增强。  \n\t> 前置通知，在方法之前执行；后置通知，在方法之后执行；  \n\t> 异常通知，方法出现异常；最终通知，在后置之后执行；  \n\t> 环绕通知，在方法之前和之后执行.  \n\n- 目标对象 (Target)：代理的目标对象 (要增强的类)。\n\n- 织入 (Weaving)：把增强应用到目标的过程，即把 Advice 应用到 Target 的过程。\n\n- `切面 (Aspect)`：切入点和通知 (引介) 的结合。\n\n\t> 把增强应用到具体方法上，此过程称为切面。例如把日志功能写进 add() 方法中。\n\t\n- 代理 (Proxy)：一个类被 AOP 织入增强后，产生一个结果代理类。\n\n###### Spring AOP 操作\n\n> (1) 基于 AspectJ 的 Spring AOP 操作。\n\nASpectJ：面向切面的框架，其扩展了 Java 语言。AspectJ 定义了 AOP 语法，故它有一个专门的编译器来生成遵守 Java 字节编码规范的 Class 文件。 \n\nAspectJ 并不是 Spring 一部分，和 Spring 一起使用进行 AOP 操作。\n\n使用 AspectJ 实现 AOP 有两种方式：1) 基于 AspectJ 的 XML 配置；2) 基于 AspectJ 的注解方式。\n\n> (2) 操作基本流程 ( XML 方式 )：\n\n- 使用表达式配置切入点\n\t- execution( <访问修饰符>?<返回类型><方法名>(<参数>)(异常) )\n\n\t> execution( \\* cn.kofes.UserOpertor.add(..) )  -- UserOperator 类中 add() 方法增强\n\t> execution( \\* cn.kofes.UserOperator.\\*(..) )  -- UserOperator 类中所有方法增强\n\t> execution( \\* \\*.\\*(..) )  -- 所有类中所有方法增强  \n\t> execution( \\* save\\*(..) ) -- 所有 save 开头的方法增强\n\t\n- 代码实现\n\n\t```java\n\t// strengthenUserOperator.java\n\tpublic class strengthenUserOperator {\n\n\t    public strengthenUserOperator() { }\n\n\t    /**\n\t     * This's an aspect inserting to the method() the front.\n\t     */\n\t    public void listBeforeOperatorType() {\n\t        System.out.println(\"Inserting to the method() the front.\");\n\t    }\n\n\t    /**\n\t     * This's an aspect inserting to the method() the front and latter.\n\t     * @param proceedingJoinPoint 执行被增强的方法\n\t     * @throws Throwable\n\t     */\n\t    public void listArroundOperatorType(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n\t        System.out.println(\"Inserting to the method() the front.\");\n\t        proceedingJoinPoint.proceed();\n\t        System.out.println(\"Inserting to the method() the latter.\");\n\t    }\n\t}\n\t\n\t// UserOperatorXML.java\n\tpublic class UserOperatorXML {\n\n\t    private User user;\n\n\t    public void setUser(User user) { this.user = user; }\n\n\t    public User getUser() { return user; }\n\n\t    @Test\n\t    public void operatorTest() {\n\t        ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t        UserOperatorXML operator = (UserOperatorXML) context.getBean(\"operator\");\n\t        // 会在用户信息之前输出 “前置增强” 的信息。\n\t        System.out.println( operator.getUser() );\n\t    }\n\t}\n\t```\n\n- 创建 Spring 配置文件，并引入约束 (在上述 applicationContext.xml 中追加)\n\t\n\t```xml\n\t<!-- applicationContext.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n\t    xsi:schemaLocation=\"\n\t    http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n\t    http://www.springframework.org/schema/context\n\t    http://www.springframework.org/schema/context/spring-context-2.5.xsd\n\t    http://www.springframework.org/schema/aop\n\t    http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\">\n\t    \n\t    <!-- 无参数构造创建对象 -->\n\t    <bean id=\"operator\" class=\"cn.kofes.entity.UserOperatorXML\" />\n\t    <bean id=\"strengthenoperator\" class=\"cn.kofes.entity.strengthenUserOperator\" />\n\t    \n\t    <!-- 配置 AOP 操作 -->\n\t    <aop:config>\n\t        <!-- 配置切入点：匹配 UserOperator 类中所有方法 -->\n\t        <aop:pointcut id=\"pointcutA\" expression=\"execution( * cn.kofes.UserOperatorXML.*(..))\" />\n\t        <!-- 配置切面：把增强用到方法上面 -->\n\t        <aop:aspect ref=\"strengthenoperator\">\n\t            <!-- 配置增强类型\n\t             | Aop：增强类型有 before、after、arroud 等\n\t             | Method：增强类里面使用哪个方法作为前置\n\t            -->\n\t            <aop:before method=\"listAllOperatorType\" pointcut-ref=\"pointcutA\" />\n\t        </aop:aspect>\n\t    </aop:config>\n\t    \n\t</beans>\n\t```\n\t\n> (3) 操作基本流程 ( 注解方式 )：\n\n- 创建 Spring 配置文件 (在上述 applicationContext.xml 中追加)，XML 配置创建对象，并开启 AOP 操作：\n\n\t```xml\n\t<!-- 无参数构造创建对象 -->\n\t<bean id=\"strengthenoperator\" class=\"cn.kofes.entity.strengthenUserOperator\" />\n\t\n\t<!-- 开启 AOP 操作 -->\n\t<aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n\t```\n\t\n- 在增强类上面使用注解完成 AOP 操作：\n\n\t```java\n\t// strengthenUserOperator.java\n\t@Aspect\n\tpublic class strengthenUserOperator {\n\n\t    public strengthenUserOperator() { }\n\n\t    /**\n\t     * This's an aspect inserting to the method() the front.\n\t     */\n\t    public void listBeforeOperatorType() {\n\t        System.out.println(\"Inserting to the method() the front.\");\n\t    }\n\n\t    /**\n\t     * This's an aspect inserting to the method() the front and latter.\n\t     * @param proceedingJoinPoint 执行被增强的方法\n\t     * @throws Throwable\n\t     */\n\t    @Around(value=\"execution( * cn.kofes.entity.UserOperatorXML.*(..) )\")\n\t    public void listArroundOperatorType(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n\t        System.out.println(\"Inserting to the method() the front.\");\n\t        proceedingJoinPoint.proceed();\n\t        System.out.println(\"Inserting to the method() the latter.\");\n\t    }\n\t}\n\t```\n\n##### Spring 整合 Web 项目\n`诉求`：在 Spring 运作中，首先加载 Spring 核心配置文件，再创建对象。而创建对象可通过 New 的方式创建，但效率太低，则我们可以把加载配置文件和创建对象过程，在服务器启动时完成。\n\n###### 问题引入\n- Action 调用 Service，Service 调用 Dao。而每次 Action 时都会加载 Spring 配置文件，影响性能。\n\n###### 实现原理\n- ServletContext 对象\n- 监听器 (观察者模式)\n\n###### 操作简叙\n- 在服务器启动时，为每个项目创建一 ServletContext 对象；\n- 在 ServletContext 对象创建时，使用监听器监听 ServletContext 对象在什么时创建；\n- 监听到 ServletContext 对象创建时，加载 Spring 配置文件，把配置文件配对象创建；\n- 把创建的对象放置 ServletContext 域对象里；\n- 到 ServletContext 域中，通过 getAttribute() 方法获取对象。\n\n###### 具体实现\n- 在 `web.xml` 配置文件中添加监听器，并指定 Spring 配置文件 的位置。\n\n\t```xml\n\t<!-- 指定 Spring 配置文件 -->\n\t<context-param>\n\t    <param-name>contextConfigLocation</param-name>\n\t    <param-value>classpath:applicationContext.xml</param-value>\n\t</context-param>\n    \n\t<!-- 监听器模块 -->\n\t<listener>\n\t    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n\t</listener>\n\t```\n\n##### Spring JdbcTemplate 操作\n- Spring 对不同的持久化层技术都进行了封装：\n\t- `Jdbc`\n\t- `Hibernate 5.x`\n\t- `iBatis / MyBatis`\n\t- `JPA`\n- JdbcTemplate 对 Jdbc 进行了封装，以下为实际操作介绍。\n\n###### JdbcTemplate 增删改查\n\n- Step.01.创建对象，设置数据库信息\n- Step.02.创建 jdbcTemplate 对象，设置数据源\n- Step.03.调用 jdbcTemplate 对象，实现其中的方法实现增、删、改、查操作。\n \n\t```java\n\t// Jdbc 模板依赖连接池获得数据库连接，所以必须先构造连接池\n\tDriverManagerDataSource dataSource = new DriverManagerDataSource();\n\tdataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n\tdataSource.setUrl(\"jdbc:mysql://192.168.x.x/db_testdb\");\n\tdataSource.setUsername(\"root\");\n\tdataSource.setPassword(\"123456\");\n \n\t// 创建 Jdbc 模板\n\tJdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n \n\t// 建表 SQL 语句\n\tString sql_create = \"CREATE TABLE \" + \n\t\t\"t_user(id int primary key auto_increment, username varchar(20), password varchar(20))\";\n\tString sql_insert = \"INSERT INTO t_user VALUES(?, ?, ?)\";\n\tString sql_update = \"UPDATE t_user password = ? WHERE username = ?\";\n\tString sql_delete = \"DELETE FROM t_user WHERE username = ?\";\n\n\t// JdbcTemplate 实现增、删、改操作\n\tjdbcTemplate.execute(sql_create); \n\tjdbcTemplate.update(sql_insert, \"Lucy\", \"123456\"); \n\tjdbcTemplate.update(sql_update, \"Lucy\", \"abc123\");\n\tjdbcTemplate.update(sql_delete, \"Lucy\");\n\n\t/**\n\t * JdbcTemplate 实现查询操作，使用 RowMapper 接口，\n\t * 但 JdbcTemplate 没有针对这个接口提供实现类，得到不同的类型数据需要进行数据封装\n\t */\n\n\t// 查询返回某一个值 \n\tsql_select_certain = \"SELECT count(*) FROM t_user\";\n\t// args0：SQL 语句，args1：返回类型 Class\n\tjdbcTemplate.queryForObject(sql_select_certain, Integer.class);\n\t \n\t// 查询返回 list 集合\n\tsql_select_all = \"SELECT * FROM t_user\";\n\tList<User> list = jdbcTemplate.query( sql_select_all, new MyRowMapper() );\n\t\n\t// 查询返回 list 集合，需要创建类实现 RowMapper 接口\n\tpublic class MyRowMapper implements RowMapper<User> {\n\t    @Override\n\t    public User mapRow(ResultSet rs, int num) throws SQLExpection {\n\t        User user = new User();\n\t        user.setUsername( rs.getString(\"username\") );\n\t        user.setPassword( rs.getString(\"password\") );\n\t        return user;\n\t    }\n\t}\n \t```\n\n##### Spring 配置连接池\n- 创建 Spring 配置文件，配置连接池：\n\n\t```xml\n\t<!-- 为便于修改配置，可在根目录下新建文件 c3p0.properties，填写格式如下：\n\t | datasource.driverClass=com.mysql.jdbc.Driver\n\t | datasource.jdbcUrl=jdbc:mysql://192.168.x.x:3306/db_testdb?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC\n\t | datasource.user=root\n\t | ...\n\t-->\n\t<context:property-placeholder location=\"classpath:c3p0.properties\"/>\n\t\n\t<!-- Data Connection Setting -->\n\t<bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n\t    <!-- 引用 c3p0.properties 的键值对即可 -->\n\t    <property name=\"driverClass\" value=\"${datasource.driverClass}\"/>\n\t    <property name=\"jdbcUrl\" value=\"${datasource.jdbcUrl}\"/>\n\t    <property name=\"user\" value=\"${datasource.user}\"/>\n\t    <property name=\"password\" value=\"${datasource.password}\"/>\n\t    <!-- 设置数据库连接池的最大连接数 -->\n\t    <property name=\"maxPoolSize\" value=\"${datasource.maxPoolSize}\"/>\n\t    <!-- 设置数据库连接池的最小连接数 -->\n\t    <property name=\"minPoolSize\" value=\"${datasource.minPoolSize}\"/>\n\t    <!-- 设置数据库连接池的初始化连接数 -->\n\t    <property name=\"initialPoolSize\" value=\"${datasource.initialPoolSize}\"/>\n\t    <!-- 设置数据库连接池的连接最大空闲时间 -->\n\t    <property name=\"maxIdleTime\" value=\"${datasource.maxIdleTime}\"/>\n\t    <!-- c3p0缓存Statement的数量数 -->\n\t    <property name=\"maxStatements\" value=\"${datasource.maxStatements}\"/>\n\t    <!-- 当连接池的连接用完的，从 C3p0 下获取新的连接数 -->\n\t    <property name=\"acquireIncrement\" value=\"${datasource.acquireIncrement}\"/>\n\t    <property name=\"checkoutTimeout\" value=\"${datasource.checkoutTimeout}\"/>\n\t    <property name=\"idleConnectionTestPeriod\" value=\"${datasource.idleConnectionTestPeriod}\"/>\n\t</bean>\n\t\n\t<!-- JdbcTemplate 类中封装了 DataSource 类，以 XML 配置形式注解关系即可 -->\n\t<bean name=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n\t    <property name=\"dataSource\" ref=\"dataSource\" />\n\t</bean>\n\t```\n\t\n- 代码引用：\n\n\t```java\n\t@Resource(name = \"jdbcTemplate\")\n\tprivate JdbcTemplate jdbcTemplate;\n\t\n\tString sql = \"SELECT * FROM t_user\";\n\t    List<User> list = jdbcTemplate.query(sql, new MyRowMapper());\n\t}\n\t```\n\n##### Spring 事务管理\n\n###### 编程式事务管理\n此部分省略。\n\n######  声明式事务管理\n- 创建 Service 类和 Dao 类，再添加注入关系：  \n\t1) Service 层，又称业务逻辑层；  \n\t2) Dao 层，数据持久层，单纯对数据库进行操作.  \n\t\n- 引入问题：ServiceTest 类中制造的异常，即造成了转账的不一致问题，细节如下：\n\n\t```java\n\t// ServiceTest.java\n\tpublic class ServiceTest {\n\t\n\t    private DaoTest daotest;\n\t    \n\t    public void setDaotest(DaoTest daotest) {\n\t        this.daotest = daotest;\n\t    }\n\t    \n\t    /* @Transactional 注解方式时填写 */\n\t    public void executeUpdateInDB() {\n\t        GrowUp();\n\t        int exception = 10 / 0;\t// 人为制造异常\n\t        Dealth();\n\t    }\n\t    public void GrowUp() {\n\t        daotest.updateOneTuple(\"UPDATE t_user SET age=age+1 where username = ?\",\n\t        \tnew Object[]{\"诸葛亮\"}, new int[]{Types.VARCHAR});\n\t    }\n\t    public void Dealth(){\n\t        daotest.updateOneTuple(\"UPDATE t_user SET age=0 where username = ?\",\n\t        \tnew Object[]{\"诸葛亮\"}, new int[]{Types.VARCHAR});\n\t    }\n\t\n\t    }\n\t\n\t// DaoTest.java\n\tpublic class DaoTest {\n\t\n\t    private JdbcTemplate jdbcTemplate;\n\t    \n\t    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {\n\t        this.jdbcTemplate = jdbcTemplate;\n\t    }\n\t    \n\t    /**\n\t     * @param sql 插入元组的 SQL 语句\n\t     * @param obj 插入的属性值，与 SQL 中填写属性名的顺序相同\n\t     * @param types 对应属性值的数据类型\n\t     */\n\t    public void updateOneTuple(String sql, Object[] obj, int[] types) {\n\t        jdbcTemplate.update(sql, obj, types);\n\t    }\n\t}\n\t```\n\n- 基于 XML 配置文件形式实现 ( AOP 的思想 )\n\n\t> 目前为止，Spring 配置文件中约束添加完毕，以后配置复制此段即可。\n\n\t```xml\n\t<!-- 目前为止，Spring 配置文件中约束添加完毕，以后的程序复制此段即可 -->\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n\t    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n\t    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n\t    http://www.springframework.org/schema/context\n\t    http://www.springframework.org/schema/context/spring-context-2.5.xsd\n\t    http://www.springframework.org/schema/aop\n\t    http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\n\t    http://www.springframework.org/schema/tx\n\t    http://www.springframework.org/schema/tx/spring-tx-2.5.xsd\">\n\t    \n\t    <!-- set 方法注入属性 -->\n\t    <bean id=\"service\" class=\"cn.kofes.service.ServiceTest\">\n\t        <property name=\"daotest\" ref=\"dao\" />\n\t    </bean>\n\t    <bean id=\"dao\" class=\"cn.kofes.dao.DaoTest\">\n\t        <!-- 引用上例的 jdbcTemplate bean 即可 -->\n\t        <property name=\"jdbcTemplate\" ref=\"jdbcTemplate\" />\n\t    </bean>\n   \n\t    <!-- 配置事务管理器 -->\n\t    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t        <!-- 注入 dataSource  -->\n\t        <property name=\"dataSource\" ref=\"dataSource\" />\n\t    </bean>\n\n\t    <!-- 配置事务增强 -->\n\t    <tx:advice id=\"txadvice\" transaction-manager=\"transactionManager\">\n\t        <!-- 做事务操作 -->\n\t        <tx:attributes>\n\t            <!--\n\t             | 事务操作方法的匹配规则，若事务操作的方法有规范命名，可以简写为：\n\t             | <tx:method name=\"execute*\" />\n\t            -->\n\t            <tx:method name=\"executeTrading()\" />\n\t        </tx:attributes>\n\t    </tx:advice>\n\t    \n\t    <!-- 配置 AOP 操作 -->\n\t    <aop:config>\n\t        <!-- 切点 -->\n\t        <aop:pointcut id=\"poitncutB\" expression=\"execution( * cn.kofes.service.ServiceTest.executeTrading(..) )\" />\n\t        <!-- 切面 -->\n\t        <aop:advisor advice-ref=\"txadvice\" pointcut-ref=\"pointcutB\" />\n\t    </aop:config>\n\t    \n\t</beans>\n\t```\n\n- 基于注解形式实现\n\n\t在需要事务操作的类上配置注解 `@Transactional`，再配置 applicationContext.xml：\n\t\n\t```xml\n\t<!-- 在 applicationContext.xml 中配置事务管理器 -->\n\t<!-- 配置事务管理器 -->\n\t<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t    <!-- 注入 dataSource  -->\n\t    <property name=\"dataSource\" ref=\"dataSource\" />\n\t</bean>\n\t\n\t<!-- 开启注解事务 -->\n\t<tx:annotation-driven transaction-manager=\"transactionManager\" />\n\t```\n\n---\n\n#### Hibernate\n`数据持久层`，Hibernate 是一个开放源码的 `ORM` 持久层框架。简单的说，Hibernate 只是一个将持久化类与数据库表相映射的工具，`每个持久化类实例均对应于数据库表中的一个数据行而已`。用户只需直接使用面向对象的方法操作此持久化类实例，即可完成对数据库表数据的插入、删除、修改、读取等操作。\n\n##### Hibernate 配置\n- 使用配置文件将映射关系对应起来；\n\n\t```xml\n\t<!-- 配置文件命名规范：*.hbm.xml -->\n\n\t<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\t<!DOCTYPE hibernate-mapping PUBLIC \n\t    \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\t    \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n\t<hibernate-mapping>\n\t    <!--\n\t     | 配置类和表相对应：Class 标签\n\t     | name 属性：实体类全路径\n\t     | table 属性：数据库表名称\n\t    -->\n\t    <class name=\"cn.entity.User\" table=\"t_user\">          \n\t        <!--\n\t         | 配置实体类 ID 与表 ID 对应：ID 标签\n\t         | Hibernate 要求实体类有一个属性唯一值，且要求表有字段作为唯一值\n\t         | name 属性：实体类的 id 属性名称\n\t         | column 属性：生产的表字段名称\n\t        -->\n\t        <id name=\"uid\" column=\"uid\">\n\t            <!-- 设置数据库表 id 增长策略：Class 标签\n\t             | 属性有：increment、hilo、squence、identity、native、uuid、guid 等。\n\t            -->\n\t            <generator class=\"native\" />\n\t        </id>\n                    \n\t        <!-- 配置其他属性和表字段对应：Property 标签 -->\n\t        <!-- 若使用的是 SQL Server 数据库系统，Property 映射对的顺序要和数据库中列 (属性) 的顺序相对应 -->\n\t        <property name=\"username\" column=\"username\" type=\"string\" />\n\t        <property name=\"age\" column=\"age\" type=\"int\" />       \n\t    </class>\n\t</hibernate-mapping> \n\t```\n\t\n> 关于映射配置的一些批注：\n    \n- Note.01：就映射配置来说，这里千万要记住，若访问的是 SQL Server 数据库系统，则 **<property> 映射对的顺序要和数据库中列 (属性) 的顺序相对应**。( 其他数据库系统没有出现此类问题，鉴于阅读与编程的规范，则不管使用哪种数据库系统驱动，都以此种方式编辑 Property 映射对 )\n- Note.02：关于配置中实体类的主键生成策略有多种形式，详细见参考 [4]。\n- Note.03：User 实体类对象的状态：\n\t- `瞬时态`：对象没有 ID 值，且其与 Session 没有关联。\n\t- `持久态`：对象有 ID 值，且其与 Session 有关联。\n\t- `托管态`：对象有 ID 值，但其与 Session 没有关联。\n\n\t```Java\n\t/**\n\t * 下述代码只列举了细节不同的部分，其他细节见源代码\n\t */\n\tUser user = new User();\n            \n\t// 瞬时态：即插入元组\n\tuser.setUserName(\"Sample\");\n\tuser.setAge(25);\n\tsession.saveOrUpdate(user);\n\n\t// 托管态：对数据表中具体 ID 的元组进行数据修改，即更新元祖\n\tuser.setUid(attr_id);\n\tuser.setUserName(\"Sample\");\n\tuser.setAge(25);\n\tsession.saveOrUpdate(user);\n\t// session.save(user); // 注意：此操作为新增元组，但不是全部属性都修改，会引入空值\n            \n\t// 持久态：对数据表中具体 ID 的元组进行数据修改，即更新元祖\n\tuser = session.get(User.class, attr_id);\n\tuser.setUserName(\"Sample\");\n\tuser.setAge(25);\n\tsession.saveOrUpdate(user);\n            \n\t// 启示：从持久态和托管态态的实验结果可知，修改元组，先查再改，防止空值。\n\t```\n\n- 创建 Hibernate 的核心配置文件；\n        \n\t核心配置文件格式是 XML，且核心配置文件名称和位置是 `固定的` ( Src 根目录下，且名称为 `hibernate.cfg.xml` )。Hibernate 操作过程中，仅加载核心配置文件。\n\n\t```xml\n\t<!-- 配置文件命名规范：hibernate.cfg.xml -->\n                \n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<!DOCTYPE hibernate-configuration PUBLIC\n\t    \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n\t    \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\">\n    \n\t<hibernate-configuration>\n\t    <session-factory>\n\t        <!-- (必填) 配置数据库信息：从 hibernate.property 中获取 -->\n\t        <property name=\"hibernate.connection.driver_class\" value=\"com.mysql.jdbc.Driver\" />\n            \n\t        <!-- SQL Server 数据库管理系统的 Driver \n\t        <property name=\"hibernate.connection.driver_class\">com.microsoft.sqlserver.jdbc.SQLServerDriver</property>\n\t        <property name=\"hibernate.connection.url\">\n\t            jdbc:sqlserver://192.168.0.133:1433;DatabaseName=testDB\n\t        </property>\n\t        -->\n            \n\t        <!-- MySQL 数据库管理系统的 Driver -->\n\t        <property name=\"hibernate.connection.driver_class\">com.mysql.jdbc.Driver</property>\n\t        <property name=\"hibernate.connection.url\">\n\t            jdbc:mysql://192.168.0.163:3306/testDB?serverTimezone=UTC\n\t        </property>\n            \n\t        <property name=\"hibernate.connection.username\">sa</property>\n\t        <property name=\"hibernate.connection.password\">pztech753</property>\n                    \n\t        <!-- (可选) 配置 Hibernate 信息：从 hibernate.property 中获取 -->\n\t        <!-- 操作数据库时，向控制台输出 SQL 语句 -->\n\t        <property name=\"hibernate.show_sql\">true</property> \n\t        <!-- 操作数据库时，向控制台输出格式化的 SQL 语句 -->\n\t        <property name=\"hibernate.format_sql\">true</property>\n\t        <!-- Hibernate 配置自动建表：Update，有表更新没表建立 -->\n\t        <property name =\"hibernate.hbm2ddl.auto\">update</property>\n\t        <!-- \n\t         | 例如，实现分页功能：\n\t         | MySQL 里面使用 LIMIT 关键字，Oracle 中使用 ROWNUM 关键字\n\t         | 让 Hibernate 识别不同数据库中特有的语句\n\t        -->\n\t        <property name=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</property>\n                    \n\t        <!-- (必填) 把映射文件放到核心配置文件中 ( 填 Src 之后的路径 ) -->\n\t        <mapping resource=\"cn/entity/User.hbm.xml\" />\n\t    </session-factory>\n\t</hibernate-configuration>\n\t```\n\n> 关于核心配置的一些批注：\n\n> 面对不同的数据库管理系统，对应的配置属性也存在差异，详细见参考 [5]。\n            \n- 通过 Session 保存实体类数据到数据库表中；\n\n    简单演示，详细见下一章节：[Hibernate 使用](#Hibernate-使用)\n        \n    ```java\n    User user = new User();\n    user.setUsername(\"Lucy\");\n    user.setAge(25);\n    Session.save(user);\n    ```\n     \n##### Hibernate 使用\n- 以下代码为 Hibernate 最基本的使用方法，后续将通过优化 Configuration，以及规范事务来优化 Hibernate。\n\n\t```java\n\t// Step.01：加载 Hibernate 核心配置文件 hibernate.cfg.xml\n\tConfiguration cfg = new Configuration();\n\tcfg.configure();\n    \n\t// Step.02：创建 SessionFactory 对象；\n\t// 在此过程中，根据映射关系在数据库中把表创建起来\n\tSessionFactory sessionFactory = cfg.buildSessionFactory();\n\n\t// Step.03：使用 SessionFactory 创建 Session 对象；\n\tSession session = sessionFactory.openSession();\n\n\t// Step.04：手动开始事务；\n\tTransaction trans = session.beginTransaction();\n\n\t// Step.05：写具体逻辑，例如：增删改查；\n\t// 例如添加操作 ( 不操作数据表，而操作实体类 )\n\tUser user = new User();\n\tuser.setUsername(\"Lucy\");\n\tuser.setAge(25);\n\tsession.save(user);\n\n\t// Step.06：提交事务；\n\ttrans.commit();\n\n\t// Step.07：关闭资源；\n\tsession.close();\n\tsessionFactory.close();\n\t```\n\n- Configuration\n    - 到 Src 目录下加载核心配置文件 `hibernate.cfg.xml`；\n- SessionFactory\n    - 根据核心配置文件中数据库配置、映射配置，且根据映射关系，到数据库中把表创建起来。\n    - 创建 SessionFactory 过程中，特别消耗资源，故应该采取优化措施：\n    \n    在 Hibernate 操作中，建议一个项目创建一个 SessionFacotry 对象，以静态的工具类形式封装使用。  \n        \n\t```java\n\tpublic class HibernateUtils {\n\t\tprivate static Configuration cfg = null;\n\t\tprivate static SessionFactory sessionFactory = null;            \n\t\tstatic {\n\t\t    cfg = new Configuration();\n\t\t    cfg.configure();\n\t\t    sessionFactory = cfg.buildSessionFactory();\n\t\t}\n         \n\t\tpublic static SessionFactory getSessionFactory() {\n\t\t    return sessionFactory;\n\t\t}\n\t}\n\t```\n\n- Session\n    - 类似 Jdbc 中的 Connection，可调用 Session 中的不同方法实现 `增、删、改、查` 操作。 \n        - 增加：save()；\n        - 修改：update()；\n        - 删除：delete()；\n        - 查询：get()；\n    - Session 为单线程对象，即不能共用，仅自己使用。\n\t\t- Hibernate 已实现本地线程与 Session 的绑定：在 Hibernate 的核心配置文件中，再调用 sessionFactory 的方法得到。\n        \n\t\t```XML\n\t\t<property name=\"hibernate.current_session_context_class\">thread</property>\n\t\t```\n\n\t\t- 在 HibernateUtils 静态工具类中追加静态方法：\n \n\t\t```java\n\t\tpublic class HibernateUtils {\n\t\t    // 返回与本地线程绑定的 Session\n\t\t    public static Session getSessionObject() {\n\t\t    return sessionFactory.getCurrentSession();\n\t\t    }\n\t\t}\n        \n\t\t/* 在其他类中调用该方法 */\n\t\tSession session = HibernateUtils.getSessionObject();\n\t\t```\n\n- Transaction\n    - 事务概念；\n    - 事务特性：原子性、一致性、隔离性、持久性；\n\n        > 隔离性：不考虑隔离性会产生的问题，如脏读、不可重复读和虚读。当然，可以设置隔离的级别来解决问题。\n         \n    - Hibernate 使用 Transaction 创建事务对象；\n    - 事务的 commit() 与 rollback() 方法 ( `规范用法` )；\n\n\t```java\n\tSessionFactory sessionFactory = null;\n\tSession session = null;\n\tTransaction trans = nu\n\ttry {\n\t    sessionFactory = HibernateUtils.getSessionFactory()\n\t    session = sessionFactory.openSession();\n\t    // 开启事务\n\t    trans = session.beginTransaction();\n            \n\t    // 人为制造异常，被除数不能为零\n\t    User user = ne0w User();\n\t    user.setAge(50/0);\n\t    session.save(user);\n            \n\t    // 提交事务\n\t    trans.commit();\n\t} catch(Exception ex) {\n\t    // 发生异常\n\t    trans.rollback();\n\t} finally {\n\t    session.close();\n\t    sessionFactory.close();\n\t}\n\t```\n    \n##### Hibernate 优化\n\n###### Hibernate 缓存机制\n- 一级缓存：默认是打开的，其使用的范围为 Session 创建到关闭的范围，且存储数据必须为持久态数据。\n- 一级缓存的特性：持久态的数据会自动更新数据库 ( 不用 session.update(user)、session.save(user) )，过程细节如下：\n\n\t```java\n\t// Get() 操作后，将返回持久态对象 user 存于一级缓存中，\n\t// 及存一份到缓存中的快照区 (副本)。\n\tuser = session.get(User.class, attr_id);\n\t// setXXX() 操作，同时修改持久态对象的值和一级缓存中的内容。\n\tuser.setUserName(\"Sample\");\n\t// 当提交事务时，会比较一级缓存和快照区，\n\t// 若不相同，会触发更新数据库操作。\n\ttrans.commit();\n\t```\n        \n- 二级缓存 (替代技术：`redis` )：默认关闭，SessionFactroy 的使用范围。\n\n##### Hibernate 查询\n\n> 在 `Hibernate 查询方式` 小节将详细阐述。\n\n###### Query 对象\n\n> 推荐使用\n\n- 使用 Query 对象，不需要写 SQL 语句，以 HQL 替代。\n    \n    > HQL：Hibernate Query Language，有别于 SQL 语句，即：SQL 操作表和表字段，而 HQL 操作实体类和属性。\n    \n-  Query 对象的使用：\n    \n    ```java\n    // 创建 Query 对象\n    Query query = session.createQuery(\"from User\");\n    // 调用 query 对象的方法得到结果\n    List<User> list = query.list();\n    ```\n        \n###### Criteria 对象\n- Ceiteria 对象的使用： \n\n    ```java\n    // 创建 Criteria 对象　\n    Criteria criteria = session.createCriteria(User.class);\n    // 调用 criteria 对象的方法得到结果\n    List<User> list = criteria.list();\n    ```\n\n###### ~~SQLQuery 对象~~\n- SQLQuery 对象的使用：\n\n\t```java\n\t// 创建 SQLQuery 对象\n\tString sql = \"SELECT * FROM t_user t WHERE t.username= ? AND t.age = ?\";\n\tSQLQuery sqlQuery = session.createSQLQuery(sql)\n\t    .setParameter(0, \"ABC\").setParameter(1, 15);\n    \n\t// Case.01. 以数组形式接收结果\n\t// List<Object []> list = sqlQuery.list();\n    \n\t// Case.02. 返回目标的 User 对象 \n\tsqlQuery.addEntity(User.class);\n\tList<User> list = sqlQuery.list();\n\t```\n\t\n##### Hibernate 多表操作\n- 数据库的多表查询\n\t- 外键\n\t\t- 指定外键关键字： Foreign Key(列名)\n\t\t- 引用外键关键字： References <主表名>(主表主键)\n\t- 关系\n\t\t- 一对一\n\t\t- 一对多\n\t\t- 多对多\n\n###### 一对多操作\n- 一对多映射配置：`实体类配置`\n\t- 创建两个实体类，例如：公司和客户 ( 公司是一，客户是多 )；\n\t- 让两个实体类间互相表示；  \n    \n\t```java\n\t// 客户实体类\n\tpublic class Customer { \n\t    // 省略其他属性\n\t    // ...\n\t    \n\t    // 在客户实体类中表示所属公司，一个客户只属于一个公司\n\t    private Firm firm;\n\t   \n\t    public void setFirm(Firm firm) { this.frim = firm; }\n\t    public Firm getFirm() { return firm; }\n\t}\n    \n\t// 公司实体类\n\tpublic class Firm {\n\t    // 省略其他属性\n\t    // ...\n\t    \n\t    // Set 集合：无序，元素不可重复\n\t    private Set<Customer> customerSet = new HashSet<Customer>();    \n\t    public Set<Customer> getCustomerSet() { return customerSet; }\n\t    public void setCustomerSet(Set<Customer> customerSet) { this.customerSet = customerSet; }\n\t}\n\t```\n\t\t\t\t\n- 一对多映射配置：`XML 配置文件`，一个实体类对应一个映射文件，除了映射文件的基本配置之外，且要在映射文件中配置一对多的关系。\n\n\t```xml\n\t<!-- firm.bhm.xml -->\n\t<class name=\"cn.kofes.entity.Firm\" table=\"t_firm\">\n\t    <!-- \n\t     | 表示公司的所有客户\n\t     | Name 属性：属性值写公司实体类里表示客户 Set 集合的对象名称\n\t    -->\n\t    <set name=\"customerSet\">\n\t        <!--\n\t         | 一对多关系建表，有外键\n\t         | Hibernate 机制，双向维护外键，即在一和多方都配置外键\n\t         | Column 属性：属性值为外键的名称，名称可自定义\n\t        -->\n\t        <key column=\"f_fid\" />\n\t        <!-- 公司的所有客户，即 Class 里写客户实体类全路径 -->\n\t        <one-to-many class=\"cn.entity.Customer\" />\n\t    </set>\n\t</class>\n\n\t<!-- customer.bhm.xml -->\n\t<class name=\"cn.kofes.entity.Customer\" table=\"t_customer\">\n\t    <!--\n\t     | 表示客户所属公司\n\t     | Name 属性：客户实体类中使用 firm 对象表示\n\t     | Class 属性：Firm 实体类的全路径\n\t     | Column 属性：外键名称，名称可自定义\n\t    -->\n\t    <many-to-one name=\"firm\" class=\"cn.entity.Firm\" column=\"c_fid\" />\n\t</class>\n\t```\n\t\n- 核心配置文件中，加入 customer.bhm.xml 和 firm.bhm.xml。\n\n\t```xml\n\t<!-- (必填) 把映射文件放到核心配置文件中 ( 填 Src 之后的路径 ) -->\n\t<mapping resource=\"cn/entity/firm.hbm.xml\" />\n\t<mapping resource=\"cn/entity/customer.hbm.xml\" />\n\t```\n\t\n- 一对多级联的操作实现\n\n\t> 在原生数据库中，对包含外键的元组直接删除，是无法成功执行的。正确操作方式为：先删除外键约束，再删除对应元组。但在 Hibernate 中，不用考虑此类问题，因为内置封装了相关功能组件。\n    \n\t- 一对多级联的保存\n    \n\t```java\n\t// Step.01.建立公司对象和客户对象的关系\n\tFirm firm = new Firm();\n\tCustomer customer = new Customer();\n\t// Step.02.把客户对象放到公司对象的 Set 集合里\n\tfirm.getCustomerSet().add(customer);\n\t// Step.03.把公司对象放到客户对象里\n\tcustomer.setFirm(firm);\n\t\t\n\t/**\n\t * 级联保存：即一方和多方都需配置数据\n\t */\n    \n\tsession.save(customer);\n\tsession.save(firm);\n\t```\n\n\t- 一对多级联的删除：在一方 ( 与多方对立 ) 即公司对象，修改其配置文件。\n\n\t最后，直接在代码中进行删除操作即可。\n\n\t```xml\n\t<!-- firm.bhm.xml -->\n\t<class name=\"cn.kofes.entity.Firm\" table=\"t_firm\">\n\t    <!-- 对 Set 标签的 casade 值为 delete -->\n\t    <set name=\"customerSet\" cascade=\"delete\">\n\t        ...\n\t   </set>\n\t</class>\n\t```\n\t\n    \n- 优化步骤之 `Inverse 属性`\n\n\t> 因为 Hibernate 是双向维护外键，在公司和客户里面都需维护外键 ( 从级联删除的执行过程中可体验出来 )。故我们可以设置其中的一方 `放弃` 维护外键，以优化性能。\n\n\t```xml\n\t<!-- firm.bhm.xml -->\n\t<class name=\"cn.kofes.entity.Firm\" table=\"t_firm\">\n\t\t<!--\n\t\t | Inverse 属性\n\t\t | Flase，表示不放弃关系维护\n\t\t | True，表示放弃关系维护\n\t\t-->\n\t\t<set name=\"customerSet\" cascade=\"save-update, delete\" inverse=\"true\">\n\t\t\t...\n\t\t</set>\n\t</class>\n\t```\n\t\n###### 多对多操作\n- 多对多映射配置：实体类配置\n\t- 创建两个实体类，例如：用户和角色 ( 一个用户可扮演多个角色，一个角色可由多个用户扮演 )；\n\t- 让两个实体类间互相表示；  \n\n\t```java\n\t// 用户实体类\n\tpublic void User {\n\t\t// 省略其他属性\n\t\t// ...\n\t\tprivate Set<Role> roleSet = new HashSet<Role>();\n\t\tpublic Set<Role> getRoleSet() { return roleSet; }\n\t\tpublic void setRoleSet(Set{Role} roleSet) { this.roleSet = roleSet; }\n\t}\n\t\n\t// 角色实体类\n\tpublic void Role {\n\t\t// 省略其他属性\n\t\t// ...\n\t\tprivate Set<User> userSet = new HashSet<User>();\n\t\tpublic Set<User> getUserSet() { return userSet; }\n\t\tpublic void setUserSet(Set<User> userSet { this.userSet = userSet; }\n\t}\n\t```\n\t\n- 多对多映射配置：`XML 配置文件`，一个实体类对应一个映射文件，除了映射文件的基本配置之外，且要在映射文件中配置多对多的关系。\n\n\t```xml\n\t<!-- user.bhm.xml -->\n\t<class name=\"cn.kofes.entity.User\" table=\"t_user\">\n\t    <!--\n\t     | 在用户中，表示所有的角色\n\t     | Name 属性：属性值写用户实体类里表角色 Set 集合的对象名称\n\t     | Table 属性：填写多对多时，两实体的联系转化成表 ( 第三张表 )\n\t    -->\n\t    <set name=\"roleSet\" table=\"t_user_role\">\n\t        <!--\n\t         | 多对多关系建表，有外键\n\t         | Column 属性：当前用户实体，在第三张表中的外键名称 \n\t        -->\n\t        <key column=\"u_fid\" />\n\t        <!-- \n\t         | Class 属性：填写角色实体类全路径\n\t         | Column 属性：角色实体，在第三张表中的外键名称\n\t        -->\n\t        <many-to-many class=\"cn.entity.Role\" column=\"r_fid\" />\n\t    </set>\n\t</class>\n\t\n\t<!-- role.bhm.xml -->\n\t<class name=\"cn.kofes.entity.Role\" table=\"t_role\">\n\t    <!--\n\t     | 在角色中，表示所有的用户\n\t     | Name 属性：属性值写角色实体类里表示用户 Set 集合的对象名称\n\t     | Table 属性：填写多对多时，两实体的联系转化成表 ( 第三张表 )\n\t    -->\n\t    <set name=\"userSet\" table=\"t_user_role\">\n\t        <!--\n\t         | 多对多关系建表，有外键\n\t         | Column 属性：当前角色实体，在第三张表中外键的名称\n\t        -->\n\t        <key column=\"r_fid\" />\n\t        <!-- \n\t         | Class 属性：填写用户实体类全路径\n\t         | Column 属性：用户实体，在第三张表中外键的名称\n\t        -->\n\t        <many-to-many class=\"cn.entity.User\" column=\"u_fid\" />\n\t    </set>\n\t</class>\n\t```\n\t\n- 核心配置文件中，加入 customer.bhm.xml 和 firm.bhm.xml。\n\n\t```xml\n\t<!-- (必填) 把映射文件放到核心配置文件中 ( 填 Src 之后的路径 ) -->\n\t<mapping resource=\"cn/entity/user.hbm.xml\" />\n\t<mapping resource=\"cn/entity/role.hbm.xml\" />\n\t```\n\n- 多对多级联的操作实现\n\t- 多对多级联保存\n\n\t\t```java\n\t\t// 和一对多级联操作一样，在用户配置文件 user.hbm.xml 中，\n\t\t// 对 Set 标签的 casade 值为 save-update\n\t\n\t\t// 多对多级联保存\n\t\tUser user_1 = new User();\n\t\tUser user_2= new User();\n\t\tRole role_1 = new Role();\n\t\tRole role_2 = new Role();\n\t\tRole role_3 = new Role();\n\t\n\t\t// user_1 拥有角色 1、2，user_2 拥有角色 2、3\n\t\tuser_1.getRoleSet().add(role_1);\n\t\tuser_1.getRoleSet().add(role_2);\n\t\tuser_2.getRoleSet().add(role_2);\n\t\tuser_2.getRoleSet().add(role_3);\n\t\n\t\t// 保存用户即可 ( 对应于配置文件中设置了 casade 值的实体 )\n\t\tsession.save(user_1);\n\t\tsession.save(user_2);\n\t\t```\n\t- 多对多级联删除 ( 不推荐 )：配置文件；最后，直接在代码中进行删除操作即可。\n\n\t\t```xml\n\t\t// 和一对多级联操作一样，在用户配置文件 user.hbm.xml 中，\n\t\t// 对 Set 标签的 casade 值为 delete ( 可以与保存的属性共存 )\n\t\t<!-- user.bhm.xml -->\n\t\t<class name=\"cn.kofes.entity.User\" table=\"t_user\">\n\t\t    <set name=\"roleSet\" table=\"t_user_role\" casade=\"save-update, delete\">\n\t\t        ...\n\t\t    </set>\n\t\t</class>\n\t\t```\n\t- 维护多对多的关系，通过维护 `第三张表` ( 两实体的联系转化成的表 ) 实现。\n\n##### Hibernate HQL 查询详解\n\n-  `OID` 查询和 `对象导航` 查询 \n\n```java\n// 单元测试类\npublic class HibernateTest {\n    @Test\n    public void testSelect1() {\n        SessionFactory sessionFactory = null;\n        Session session = null;\n        Transaction trans = null;\n\t\t\n        try {\n            sessionFactory = HibernateUtils.getSessionFactory();\n            session = sessionFactory.openSession();\n            trans = session.beginTransaction();\n\t\t\t\n            // 需求：根据 ID 查询某个公司，再查询这个公司的所有客户\n\t\n            // OID 查询：查询 ID 为 1 的公司\n            Firm firm = session.get(Firm.class, 1); // \n            // 对象导航查询：根据某条记录的 ID，返回对象 (公司的客户)\n            Set<Customer> customer = firm.getCustomerSet();\n            System.out.print( customer.toString() );\n\n            trans.commit();\n        } catch(Exception ex) {\n            e.printStackTrace();\n            transaction.rollback();\n        } finally {\n            session.close();\n            sessionFactory.close();\n        }\t\n    }\t\n}\n```\n\n###### HQL 查询\n\n```java\n// Step.01.创建 Query 对象，写 HQL 语句实现查询\n// Step.02.调用 query 对象的方法得到结果\n\n// 查询所有\nQuery query = session.createQuery(\"FROM t_user\");\nList<User> list = query.list();\n\n// 条件查询\nString sql_obscure = \"FROM t_user WHERE username LIKE ?\"; // 模糊查询\nString sql_accurate = \"FROM t_user WHERE age = ? AND username = ?\"; // 精确查询\nQuery query = session.createQuery(sql_accurate);\n// arg0 为占位符位置，arg1 为参数\nquery.setParameter(0, 25).setParameter(1, \"Lucy\");\nList<User> list = query.list();\n\n// 排序查询：ASC，升序 / DESC，降序\nString sql = \"FROM t_user ORDER BY uid ASC\"; \nQuery query = session.createQuery(sql);\nList<User> list = query.list();\n\n// 分页查询：LIMIT 关键字\nString sql = \"FROM t_user\";\nQuery query = session.createQuery(sql);\nquery.setFirstResult(0);\nquery,.setMaxResults(10);\nList<User> list = query.list();\n\n// 投影查询\nString sql = \"SELECT username, age FROM t_user\";\nQuery query = session.createQuery(sql);\nList<Object> list = query.list();\n\n// 聚集函数\n// COUNT()、SUM()、MAX()、MIN()...\nString sql = \"SELECT COUNT(*) FROM t_user\";\nQuery query = session.createQuery(sql);\n// 将结果以对象形式返回\nObject obj = query.uniqueResult();\n```\n\n###### HQL 多表查询\n- 内连接：连接两个表有关联的数据，忽略两个表中对应不起来的数据。\n\t- SQL：SELECT * FROM t_user AS u, t_role AS r ON  u.uid = r.uid;\n \t- 或者：SELECT * FROM t_user u INNER JOIN t_role r ON  u.uid = r.uid;\n\n- 左外链接：左边表所有元组，右边表关联数据。\n\t- 若左表与右表没有关联数据，则右边表数据补 NULL 值，多了则删除\n\t- SQL：SELECT * FROM t_user u LEFT OUTER JOIN t_role r ON  u.uid = r.uid;\n- 右外链接：与左外链接同理。\n\n```java\n// HQL 内连接 ( 左、右外链接同理 )\nString sql_inner_join = \"FROM t_user u INNER JOIN u.roleSet\";\nQuery query = session.createQuery(sql_inner_join);\nList list = query.list(); // list 返回的每部分都是数组\n\n// HQL 迫切内连接\nString sql_inner_join_fetch = \"FROM t_user u INNER JOIN FETCH u.roleSet\";\nQuery query = session.createQuery(sql_inner_join_fetch);\nList list = query.list();  // list 返回的每部分都是对象\n\n// HQL 迫切左外连接  ( 没有迫切右外连接 )\nString sql_inner_join_fetch = \"FROM t_user u LEFT OUTER JOIN FETCH u.roleSet\";\n```\n\n##### Hibernate 检索策略\n\n###### 立即查询\n根据 ID 查询，调用 get() 方法，则马上发送语句查询数据库。\n\n```java\n// Debug 方式可检验，即执行代码马上发送 SQL 语句\nUser user = session.get(User.class, 1);\n```\n\n###### 延迟查询\n根据 ID 查询，调用 load() 方法，不会马上发送语句查询数据库，只有得到对象的值时，才发送语句查询数据库。\n\n```java\n// 调用 load() 方法之后，并不会马上发送 SQL 语句\nUser user = session.load(User.class, 1);\nSystem.out.println( user.getUid() );\n// 当得到对象里其他值时，即非 ID 值，才发送 SQL 语句进行查询\nSystem.out.println( user.getUsername() );\n```\n\n- 类级别延迟：例如，根据 ID 查询返回实体类对象，调用 load() 方法不会马上发送 SQL 语句。 \n-  关联级别查询：例如上述 `对象导航查询`，查询某个公司后，再查询这间公司的所有客户，查询公司所有客户的过程是否需要延迟，则称其为关联级别延迟。\n\n\t```xml\n\t<!-- \n\t | 在配置文件中实现关联级别延迟\n\t | fetch 属性：select\n\t | lazy 属性：true / false / extra\n\t | \t- True，当得到对象里其他值时，即非 ID 值，才发送 SQL 语句进行查询。\n\t | \t- False，反之，会多执行一次查询 ( getUid() )。\n\t | \t- Extra，需要什么属性，查询什么属性 ( 仅需少量属性时推荐使用 )\n\t-->\n\t<class name=\"cn.kofes.entity.User\" table=\"t_user\">\n\t    <set name=\"roleSet\" table=\"t_user_role\" fetch=\"select\" lazy=\"true\" >\n\t        ...\n\t    </set>\n\t</class>\n\t```\n\t\n###### 批量抓取\n- 例如，我们需要查询所有公司的所有客户，代码实现如下：\n\t\n\t```java\n\tCriteria criteria = session.createCriteria(User.class);\n\tList<Firm> list = criteria.list();\n\tfor(Firm firm : list) {\n\t    System.out.println( firm.getId() + \":\" + firm.getName() );\n\t    Set<Customer> customerSet = firm.getCustomerSet();\n\t    for(Customer customer : customerSet) {\n\t        System.out.println( customer.getUid() + \":\" + customer.getUsername() );\n\t    }\n\t}\n\t\n\t// 但在执行过程中，暴露的问题时：每次循环都执行一次查询，拖沓性能\n\t```\n\t\n- 故我们只需要在实体映射配置文件中，对 Set 标签进行设置属性即可：\n\n\t```xml\n\t<!-- firm.bhm.xml -->\n\t<class name=\"cn.kofes.entity.Firm\" table=\"t_firm\">\n\t    <!-- batch-size 的值为整数即可 -->\n\t    <set name=\"customerSet\" batch-size=\"10\">\n\t        ...\n\t    </set>\n\t</class>\n\t```\n\t\n---\n\n#### SSH 框架总结\n\n##### Struts\n- Action 操作\n\t- Action 创建 (三种方式)：继承 `ActionSupport` 类。\n\t- Action 访问路径：创建 `struts.xml` 配置文件，文件名称和位置 ( Src 目录 ) 固定。\n\t- 访问 Action 的多个方法：使用 `通配符方式` 配置。\n\t- Action 获取表单提交数据：\n\t\t- 获取 Request 对象 ( 使用 `ServletAction` 类 )；\n\t\t- 属性封装；\n\t\t- 模型驱动；\n\t- Action 操作域对象：使用 `ServletAction` 类。\n\t- 配置 Struts2 过滤器。\n- 值栈\n\t- 向值栈放数据：\n\t\t- Set 方法；\n\t\t- Push 方法；\n\t\t- 定义变量，生成 Get 方法.\n\t- 从值栈获取数据：在 JSP 中使用 Struts2 标签 + Ognl 获取\n\t\t- `<s:property />`\n\t\t- `<s:iterator />`\n- 拦截器\n\t- AOP 和责任链模式；\n\t- 自定义拦截器：\n\t\t- 继承 `MethodFilterInterceptor` 类，并重写类方法；\n\t\t- 配置拦截器和 Action 关联.\n\n##### Spring\n- Spring 核心配置文件：\n\t- 名称和位置没有固定要求；\n\t- 在 Spring 核心配置文件中引入 Schema 约束.\n- 创建对象：\n\t- XML 配置方式：`<bean id=\"\" class=\"\" />`；\n\t- 注解方式：`@Component` 或 `@Controller` (Web层)、`@Service` (业务层)、`@Repository` (持久层).\n- 注入属性:\n\t- XML 配置方式：`<bean id=\"\" class=\"\"><property name=\"\" ref=\"\" /></bean>`；\n\t- 注解方式：`@autowired`、`@Resource(name=\"value\")`.\n- 使用 ServletContext 对象和监听器实现\n\t- 在服务器启动时，加载 Spring 配置文件，创建对象；\n\t- 配置 Spring 的监听器；\n\t- 指定 Spring 配置文件位置.\n- Spring JdbcTemplate \n- Spring 事务配置：\n\t- XML 配置方式；\n\t- 注解方式：`@Transational`\n\n##### Hibernate\n- ORM 思想：`对象关系映射`，参考 [ORM 框架](#ORM-框架)；\n- 数据库信息配置：MySQL / SQL Server 2008 R2；\n- Hibernate 信息配置：即配置 Hibernate 核心配置文件 ( `hibernate.cfg.xml` )。\n\n\t> Hibernate 和 Spring 整合时，配置文件的名称和位置是没有固定要求的。\n\t\n- 映射关系配置：即配置 Hibernate 映射配置文件 ( `xxx.hbm.xml` )，实体类和数据表映射关系 ( 使用 ORM 思想 )。\n- Hibernate 操作步骤：Spring 框架对 Hibernate 框架也有封装，即 `HibernateTemplate` 类。\n\n#### SSH 框架整合\n\n![SSH框架整合思想](/images/illustration/Project/2018/08/J2EE-SSH-SSI-1_6-4.png)\n<center>图 6-4 SSH 框架整合思想</center>\n\n- Spring 与 Struts 2 框架的整合\n\t\n\t把 Struts 2 的 Action 对象创建交给 Spring 进行管理。\n\n\t```xml\n\t<bean id=\"\" class=\"\" scope=\"prototype\" />\n\t```\n\n- Spring 与 Hibernate 框架的整合\n\n\t把 Hibernate 的核心配置文件里的数据库配置，直接写在 Spring 配置文件中。且把 SessionFactory 对象创建交给 Spring 管理。\n\t\n#### SSH 整合演示\n\n##### Spring 与 Struts 2 整合\n\n- Action 代码实现：\n\n\t```java\n\t// cn.kofes.dao.BaseAction.java\n\t\n\tpublic class BaseAction extends ActionSupport {\n\t    @Override\n\t    public String execute() throws Exception {\n\t        System.out.println(\"The portion of action has deployed successfully.\");\n\t        return NONE;\n\t    }\n\t}\n\t```\n\t\n- 在 Spring  配置文件下整合 Struts：\n\n\t```xml\n\t<!-- spring.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n\t    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n\t    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n\t    http://www.springframework.org/schema/context\n\t    http://www.springframework.org/schema/context/spring-context-2.5.xsd\n\t    http://www.springframework.org/schema/aop\n\t    http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\n\t    http://www.springframework.org/schema/tx\n\t    http://www.springframework.org/schema/tx/spring-tx-2.5.xsd\">\n\n\t    <!-- 整合 Struts：Action 对象的配置 -->\n\t    <bean id=\"BaseAction\" class=\"cn.kofes.action.BaseAction\" scope=\"prototype\"/>\n\t    \n\t</beans>\n\t```\n\n- 整合 Web，当服务器启动时加载 Spring 配置即初始化，我们需要在 web.xml 下配置监听器：\n\n\t```xml\n\t<!-- web.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n\t    version=\"4.0\">\n\t    \n\t    <!-- 加载 Spring 的配置文件 -->\n\t    <context-param>\n\t        <param-name>contextConfigLocation</param-name>\n\t        <param-value>classpath:spring.xml</param-value>\n\t    </context-param>\n\n\t    <!-- 监听器模块：作用就是启动 Web 容器时,自动装配 spring.xml 文件的配置信息 -->\n\t    <listener>\n\t        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n\t    </listener>\n\n\t    <!-- 过滤器模块 -->\n\t    <filter>\n\t        <filter-name>struts2</filter-name>\n\t        <filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>\n\t    </filter>\n\t    <filter-mapping>\n\t        <filter-name>struts2</filter-name>\n\t        <url-pattern>/*</url-pattern>\n\t    </filter-mapping>\n\n\t    <welcome-file-list>\n\t        <welcome-file>index.jsp</welcome-file>\n\t    </welcome-file-list>\n\t\n\t</web-app>\n\t```\n\t\n- 最后，struts.xml 填入以下配置即可：\n\n\t```xml\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<!DOCTYPE struts PUBLIC\n\t    \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\"\n\t    \"http://struts.apache.org/dtds/struts-2.3.dtd\">\n\n\t<struts>\n\t    <package name=\"sample\" extends=\"struts-default\" namespace=\"/\">\n\t        <!--\n\t         | Class 属性值不写目标 Action 的全路径，原因是防止二次创建对象\n\t         | 引入 Spring 相对应  Action 的 Bean 标签 ID\n\t        -->\n\t        <action name=\"BaseAction\" class=\"BaseAction\" />\n\t    </package>\n\t</struts>\n\t```\n\n##### Spring 与 Hibernate 整合\n\n- 在 Spring  配置文件下配置数据库信息，及整合 Hibernate。后者即将 SessionFacotry 交由 Spring 管理：\n\n\t> `c3p0.properties` 和 `hibernate.properties` 配置文件位于 Src 根目录下，键值分离以便以后修改配置。\n\n\t```xml\n\t<!-- spring.xml -->\n\t\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\t    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t    xmlns:context=\"http://www.springframework.org/schema/context\"\n\t    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n\t    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n\t    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n\t    http://www.springframework.org/schema/context\n\t    http://www.springframework.org/schema/context/spring-context-2.5.xsd\n\t    http://www.springframework.org/schema/aop\n\t    http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\n\t    http://www.springframework.org/schema/tx\n\t    http://www.springframework.org/schema/tx/spring-tx-2.5.xsd\">\n\n\t    <!-- 在根目录下新建文件 c3p0.properties，存储数据库连接信息 -->\n\t    <context:property-placeholder location=\"classpath:c3p0.properties\"/>\n\n\t    <!-- Data Connection Settings -->\n\t    <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n\t        <!-- 引用 c3p0.properties 的键值对即可，格式如 ${key.value} -->\n\t        <property name=\"driverClass\" value=\"${datasource.driverClass}\"/>\n\t        <property name=\"jdbcUrl\" value=\"${datasource.jdbcUrl}\"/>\n\t        <property name=\"user\" value=\"${datasource.user}\"/>\n\t        <property name=\"password\" value=\"${datasource.password}\"/>\n\t        <!-- 设置数据库连接池的最大连接数 -->\n\t        <property name=\"maxPoolSize\" value=\"${datasource.maxPoolSize}\"/>\n\t        <!-- 设置数据库连接池的最小连接数 -->\n\t        <property name=\"minPoolSize\" value=\"${datasource.minPoolSize}\"/>\n\t        <!-- 设置数据库连接池的初始化连接数 -->\n\t        <property name=\"initialPoolSize\" value=\"${datasource.initialPoolSize}\"/>\n\t        <!-- 设置数据库连接池的连接最大空闲时间 -->\n\t        <property name=\"maxIdleTime\" value=\"${datasource.maxIdleTime}\"/>\n\t        <!-- c3p0缓存Statement的数量数 -->\n\t        <property name=\"maxStatements\" value=\"${datasource.maxStatements}\"/>\n\t        <!-- 当连接池的连接用完的，从 C3p0 下获取新的连接数 -->\n\t        <property name=\"acquireIncrement\" value=\"${datasource.acquireIncrement}\"/>\n\t        <property name=\"checkoutTimeout\" value=\"${datasource.checkoutTimeout}\"/>\n\t        <property name=\"idleConnectionTestPeriod\" value=\"${datasource.idleConnectionTestPeriod}\"/>\n\t    </bean>\n\t    \n\t    <!-- 整合 Hibernate：SessionFactory 对象的配置 -->\n\t    <bean id=\"sessionFactory\"\n\t        class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\">\n\t        <!-- (必填信息) 指定数据库 -->\n\t        <property name=\"dataSource\" ref=\"dataSource\" />\n\t        <!-- (可选信息) 配置 Hibernate 信息 -->\n\t        <property name=\"hibernateProperties\" value=\"classpath:hibernate.properties\" />\n\t        <!-- (必填信息) 把映射文件放到核心配置文件中 ( 现直接加载到 LocalSessionFactoryBean 类中即可 )  -->\n\t        <property name=\"mappingResources\">\n\t            <list>\n\t                <value>mapper/sample.hbm.xml</value>\n\t            </list>\n\t        </property>\n\t    </bean>\n\n\t</beans>\n\t```\n\n- 创建实体类：\n\n\t```java\n\t// Employee.java\n\tpublic class Sample { ... }\t\n\n\t```\n\t\n- 创建实体类映射文件 ( 文件位置没有固定要求，建议统一文件夹存储 )：\n\n\t```xml\n\t<!-- src/resource/HbmCollection/sample.hbm.xml -->\n\t\n\t<?xml version='1.0' encoding='UTF-8'?>\n\t<!DOCTYPE hibernate-mapping PUBLIC\n\t    \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\t    \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n\t    \n\t<hibernate-mapping>\n\t    <!--\n\t     | name 属性：实体类全路径\n\t     | table 属性：数据库表名称\n\t    -->\n\t    <class name=\"cn.kofes.bean.Sample\" table=\"t_sample\">\n\t        <!--\n\t         | Hibernate 要求实体类有一个属性唯一值，且要求表有字段作为唯一值\n\t         | name 属性：实体类的 id 属性名称\n\t         | column 属性：数据表字段名称\n\t        -->\n\t        <id name=\"id\" column=\"id\">\n\t            <!-- 设置数据库表 id 增长策略：Class 标签\n\t             | 属性值：increment、hilo、squence、identity、native、uuid、guid 等。\n\t            -->\n\t            <generator class=\"native\"/>\n\t        </id>\n\n\t        <!-- 配置其他属性和表字段对应：Property 标签 -->\n\t        <property name=\"name\" column=\"name\" type=\"string\"/>\n\t    </class> \n\t</hibernate-mapping>\n\t```\n\n- 在 `核心配置文件` 中引入 `映射配置文件`：\n\n\t> 在 Spring 配置文件中已引入映射配置文件，故不需要再单独配置 `hibernate.cfg.xml`。\n\t\n- 事务配置：在 spring.xml 配置文件中配置并开始事务注解，再到 Service 层添加注解 `@Transactional`： \n\n\t```xml\n\t<!-- 配置事务管理器 -->\n\t<bean id=\"transactionManager\"\n\t    class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\">\n\t    <property name=\"sessionFactory\" ref=\"sessionFactory\"/>\n\t</bean>\n\n\t<!--  开始事务注解 -->\n\t<tx:annotation-driven transaction-manager=\"transactionManager\" />\n\t```\n\n##### Spring 分模块开发\n\n- 在 Spring 里配置多个内容，容易造成配置混乱，不利于维护。\n- 把 Spring 核心配置文件中，将一部分配置放到单独的配置文件中，再在 Spring 核心配置文件中引入单独配置文件。\n\n\t```xml\n\t<!-- \n\t | 将原 Spring 中的部分配置放置到独立 xml 中，\n\t | 例如我把 Dao 层的配置独立出来，再到 spring.xml 中引入配置文件 dao.xml 即可。\n\t-->\n\t<import resource=\"classpath:dao.xml\" />\n\t```\n\t\n##### SSH 框架使用演示\n\nSSH 整合工作告一段落，当然你可通过 Maven 打包工程，以便以后复用。\n\n\n### SSM 框架\n\n> 当然，随着框架技术的迭代更新，更加科学、合理的新框架也逐渐在项目中使用起来，如 SSM 框架。具体细节可参考：[Java EE 之 SSM 框架配置与使用](https://www.kofes.cn/2018/08/J2EE-SSM-1.html)\n\n- `SSM 框架`：Spring MVC、Spring、MyBatis\n\n\tSSM ( Spring + SpringMVC + MyBatis ) 框架集由 Spring、SpringMVC、MyBatis 三个开源框架整合而成，常作为数据源较简单的 Web 项目的框架。\n\n- `Spring`：是一个轻量级的控制反转 (IoC) 和面向切面 (AOP) 的容器框架。\n\n\t> 与本文的 Spring 章节内容相同。\n\n- `SpringMVC`：分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。\n- `Mybatis`：[Mybatis](http://blog.mybatis.org/) 是一个支持普通SQL查询，存储过程和高级映射的优秀持久层框架。它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs (Plain Old Java Objects，普通的 Java对象 ) 映射成数据库中的记录。\n\n##参考资料 \n\n- \\[1\\] [ 一枪尽骚 · 魂. 基于全注解方式的SSH基础框架. csdn.net](https://blog.csdn.net/u012377333/article/details/50037825)\n- \\[2\\] [刻下岁月. IntelliJ IDEA 2016.1.2 + Spring + Struts2 + Hibernate ( SSH ). lunhui.ren](http://blog.lunhui.ren/archives/225) \n- \\[3\\] [kent. JavaEE SSH 三大框架整合 ( Spring + Struts2 + Hibernate ). cnblogs.com](https://www.cnblogs.com/xieyupeng/p/7108141.html)\n- \\[4\\] [Starskyhu. Hibernate 各种主键生成策略与配置详解. cnblogs.cn](https://www.cnblogs.com/hoobey/p/5508992.html)\n- \\[5\\] [陈铁锋. Hibernate 连接三种数据库的配置 ( SQL Server、Oracle、MySQL ). csdn.net](https://blog.csdn.net/chentiefeng521/article/details/58775415)\n- \\[6\\] [RoadOfStudy. MySQL 5.7版本的root用户重置密码问题. cnbolgs.com](https://www.cnblogs.com/roadofstudy/p/7446690.html)\n- \\[7\\] [Time Tries All. MySQL 重置密码出现的一系列问题. csdn.net](https://blog.csdn.net/time_tries_all/article/details/78571984)\n- \\[8\\] [Souvc. 连接虚拟机 (Ubuntu16.04) 的 MySQL 服务器. souvc.com](http://www.souvc.com/?p=915)","tags":["Struts"],"categories":["Project"]},{"title":"论文 | 从商用车队的 GPS 数据中归类车辆停留意图信息","url":"%2F2018%2F06%2FStop-purpose-classification-from-GPS-data-of-commercial-vehicle-fleets.html","content":"\n{% note default %}\n原文：Stop purpose classification from GPS data of commercial vehicle fleets\n作者：Sarti L, Bravi L, Sambo F.    \n来源：Data Mining Workshops, 2017 IEEE International Conference on. IEEE, 2017: 280-287.  \n{% endnote %}\n\n## 摘要\n\n从原始 GPS (全球定位系统) 数据中提取 `汽车停靠意图数据` 是大多数位置感知应用程序中的关键任务，且随着从移动设备收集 GPS 数据的不断增长，这项任务变得越来越有趣。近期很多研究都集中在行人 (手机) 数据上 (可理解为红海市场)，而商用车领域几乎没有探索 (蓝海市场)。\n\n在本论文中，针对车辆 GPS 数据的汽车停靠意图的 `识别` 和 `分类` 问题 (利用来自不同行业的商业车队的大型异构数据集)。按照意图分类，旨在把汽车停靠点分为：`工作相关` 和 `非工作相关`，以挖掘相关商业价值。\n\n且还对每个汽车停靠点计算一组含 100 个不同特征的集合，特征可分为四个主要类别：`汽车停靠点特征`，`兴趣点特征`，`汽车停靠点集群特征` 和 `序列特征`。并通过随机森林分类模型，评估四组特征中每个特征对停靠点的相对重要性，以处理不同类型的问题。\n\n实验结果表明，本论文的方法显着地超越了现有商业车辆背景下用于汽车停靠意图的分类模型。\n\n<!-- More -->\n\n## 正文\n\n### 引入\n在过去的十年中，GPS 设备的巨大推广，使得人们越发关注 `数据挖掘算法` 在 `时空数据` (GPS 产生的数据) 中的应用。而许多实际应用需要使用关于用户行为和地理位置的语义信息。例如，下述的两个实例：\n\n- 基于用户的历史位置以衡量用户之间的相似度 $^{[1]}$；\n- 基于位置的兴趣地点推荐系统 $^{[2]}$。\n\n语义标记 GPS 数据，目标旨在 `识别` 和 `归类` GPS 沿途轨迹上的位置信息，即具体工作有 `语义位置的侦察` 和 `汽车停靠或出游的意图识别`。尽管上述问题不是同一类型的问题，但却是强相关的。例如，对多个用户而言具有相同意图的共同定位点，可能是语义上相关联的地方，因为知道某个地方的语义对分类每个汽车停靠点意图有很大的帮助。\n\n通常，对于上述 `识别` 和 `归类` 问题的解决方法分两个阶段执行：\n\n- `侦查兴趣地点`：通常以非监督的方式实现位置侦查 $^{[3,4]}$，而作者提出了基于 `DBSCAN` $^{[5\\,or\\,6]}$ 的修改版本的聚类算法，即利用层次聚类从汽车停靠位置中提取访问点。\n\n\t> 当要处理非常大的数据集时需要考虑计算性能的问题，可参考其他论文中的扩展方法，例如对地点坐标进行哈希散列法 $^{[7,8]}$。\n\n- `对侦查到的地点分类`：对有关地点或汽车停靠点进行分类，可以在文献中找到两种主要方法：\n\t- 基于规则的系统 $^{[9,10]}$，其主要依赖于活动的位置、土地利用的数据以及机器学习方法，即活动本身提取特征；\n\t- 利用 SVM 分类器来区分标识位置内的活动停靠点和非活动停靠点。分类器 (SVM，随机森林或逻辑回归) 利用时间和空间特征 $^{[6]}$，以及隐马尔可夫模型 (HMM) 利用时序特征把这些汽车停靠点分类为预定义类型。\n\n        > 1) SVM 提取三个主要特征：停车驻留时间，每个汽车停靠地段周围的点到质心的平均距离。    \n        > 2) 地点的语义分类是基于GPS数据和卫星图像的组合而定的 $^{[8]}$。  \n\t\n最后说明，本论文解决了与参考文献 [7] 的同样问题，即利用四个不同的特征集，使用一个随机森林分类器，对商业车队的汽车停靠意图数据进行分类。且本文的主要贡献如下：\n\n- 描述了一种方法，即从 GPS Pings (GPS 定位仪) 中提取汽车停靠点信息，并从工作状态停车点一览表 (已知的地点信息) 中給它们分配地面实况标签 (贴标签);\n- 基于带标签的数据集，建立了一个模型，可以自动分类汽车停靠点，即工作状态和非工作状态的停靠点;\n- 提供了严格评估的多类型特征集，便于我们处理不同问题，其中包括：\n\t- 汽车停靠点特征 (Stop-wise features，SWF)；\n\t- 兴趣点特征 (Points of interest features，POIF)；\n\t- 停靠点集群特征 (Stop Cluster，CF)；\n\t- 序列特征 (Sequential features，SeqF).\n\n### 方法\n\n#### GPS和工单数据\n- 本论文采用的数据集由 Fleetmatics 公司 (车队情报公司) 提供。\n- 采集的数据有两种类型，分别是`原始 GPS pings 数据` 和 `工单数据`。\n\t- 原始 GPS Pings 数据\n\t\t- 提供有关车辆位置的信息，工单状态的信息，有关司机执行的工作进度及进度信息；\n\t\t- 设定有一系列的 GPS Pings $\\{P_i\\}_{i=1}^n = \\{P_1, ..., P_n\\}$ 分别描述每辆车行驶的路线。\n\t\t- 每一个 GPS Ping $P_i$ 包含每辆车的状态信息，即有车辆 ID $v_i$，经度和纬度 (位置信息 $p_i$)，里程表 $d_i$，时间戳 $t_i$ 和 事件代码 $e_i$。\n\t- 工单数据\n\t\t- 设定有一系列的工单 $\\{W_i\\}_{i=1}^n = \\{W_1, ..., W_n\\}$。\n\t\t- 每一个工单包含的信息有：车辆 ID $v_i$，经度和纬度 (位置 $p_i$)，时间戳 $t_i$ 和 状态代码 $c_i$ (例如：挂起，启动，完成)。\n\n#### 车辆停靠侦查技术\n正如上述所描述的，关于瞬时车辆位置的原始数据是由 GPS Ping 组成的，将它们汇集起来以描述车辆的活动。为此本论文开发了一个 `时空聚类程序`。\n\n- 首先得为每个 GPS 信息分配一种状态类型 (Engine off，iDling，Journey)，然后把它们聚集成 GPS Ping 群组，并把这个 GPS Ping 群组称为 `汽车停靠点集`。\n- GPS Ping 的状态可分为三种类型：\n\t- `Engine Off (发动机关闭状态)`：发动机关闭事件。即这些 Ping 在发动机关闭的瞬间产生的 (当发动机处于关闭状态时不发送 Ping);\n\t- `iDling (空转/怠速状态)`：发动机处于开启状态，但车辆静止或车辆在小区域内仍然缓慢行驶。对于后者，我们还需要作一些约束，设定 $H(p_i,p_{i-1})$ 表示两点间的半正定距离。然后，对于给定车辆给予一对连续的 Ping $P_{i-1}\\,and\\,P_i$，且满足以下约束，则可定义为怠速：\n\t\t- $s_i = H(p_i,p_{i-1})\\,/\\,(t_i - t_{i-1}) \\leq 1.4\\,m/s\\,(5km/h)$，确定速度接近零；\n\t\t- $H(p_i,p_{i-1}) \\leq 150\\,m$，确保 $P_{i-1}\\,and\\,P_i$ 足够接近，且避免了由于丢失数据而产生的 `伪影`。\n\t- `Journey (行驶状态)`：即不是发动机关闭状态，也不是怠速状态。\n- 当 Ping 被分类后，以每辆车为单位，按时间顺序排序；并把所有连续的怠速状态和发动机关闭状态的 Ping 聚集成集群 (并不会被其中 Journey 状态的 Ping 給分割开来)。\n- 由于丢失数据，导致一组连续的怠速状态 Ping 彼此相对较远地分布开来。故我们得重新执行 `时间-空间` 的约束条件 ($s_i \\leq 1.4\\,m/s$ and $H(p_i,p_{i-1}) \\leq 150\\,m$)。\n\n\t> 无法满足约束条件：即一组连续的怠速状态 Ping 将被分隔得很远，其中的 Journey 状态的 Ping 都给丢失了。 \n\t\n- 以这种方式创建的 `Pings 集群` 代表我们想要分类的 `已识别的汽车停靠点`。综上所述，汽车停靠点被定义为按时间顺序排序的 Ping  集群 (包含怠速状态或发动机关闭状态的 Ping，并且满足进一步的 `时间-空间` 得约束条件。\n- 每个 `汽车停靠点` 都有几个特性 (通过计算其中的 Ping)：Ping 的数量，停靠点的起点和终点 (属于该停靠点的 Ping 的第一个和最后一个时间戳)，驻留时间 (属于该停靠点的起始时间和结束时间) 和形状 (由GPS消息的最大 (最小) 纬度/经度坐标定义)。\n- 所有这些信息对于在第二阶段提取特征工作至关重要，即汽车停靠点意图的分类。\n\n#### 贴标签\n- 首先，对上述程序中获得的汽车停靠点分配 `地面实况标签`；再者，将它们与 `工单数据` 进行匹配。一般来说，若车辆停留点在时间上和空间上与工单数据 $W_i$ 相匹配，则可认为该汽车停靠点即为某一工单数据。\n\t- 对于只包含 idling 和 engine off Pings 的停靠点，我们认为它满足空间上的匹配。\n\t- 对于任何工单，空间上匹配了停留点；如果停留点的驻留时间与工单的时间项 (指示作业已启动的时间和指示服务已结束的时间) 间隔相交，时间的匹配也随着满足。\n\n#### 分类特征\n在 `车辆停靠侦查技术` 章节中描述的，从一系列的 GPS Pings 提取汽车停靠点，并从中提取 100 个不同的特征用于训练随机森林模型，随之将这些特征划分为 4 个不同的组：\n\n- 汽车停靠点特征 ( Stop-wise features，SWF )：\n\t- 驻留时间：(汽车) 停靠点第一个和最后一个 Ping 的时间差。\n\t- 开始时间特征：一天中的小时，一周中的某天，某月某日，某年某日。\n\t- 关闭引擎所花费的时间：对于每一个引擎关闭事件，我们计算当前 Ping 与前一个非引擎关闭状态的 Ping 之间的时间差，以表示引擎启动的时间。由于每个停靠点包含多个引擎关闭状态的 Ping，我们需要使用几个聚合函数聚合取得结果。\n\t- 形状：停靠点的宽度、高度、面积、比例。\n\t- 停靠点类型：发动机关闭状态。\n\t- 停靠点中发动机关闭状态 Ping 的数量。\n\t- 里程表距离：从第一次 Ping 到最后一次 Ping。\n\t- 停靠点内 Ping 的总数。\n\t- 平均速度 (根据停留点中第一次和最后一次 Ping 之间的里程差除以驻留时间计算所得)。\n- 兴趣点特征 ( Points of interest features，POIF)：利用 `PTV xLocate Server` 中提取以下 POI 类型：\n\t- 银行;\n\t- 大学;\n\t- 酒店;\n\t- 餐厅;\n\t- 休息区;\n\t- 杂货店;\n\t- 学校;\n\t- 购物中心;\n\t- 汽油;\n\t- 开放式停车场;\n- 汽车停靠点集群特征 ( Stop cluster features，CF )：其原理是存在一些工单数据和非工单数据趋向于聚类成簇，类似于 [7] 中提出的熵度量方法：对于每个停靠点，查看并收集 250 米半径内的周边环绕的停靠点数据。\n\t- 车辆熵，计算公式为：\n\n\t$$E_v = - \\sum_{\\nu \\in V} \n\t\t\\frac{n_{\\nu}}{N} ln(\\frac{n_{\\nu}}{N})\n\t\t\\tag{1}\n\t$$\n\t\n\t> $V$ 是车队中的车辆集合， $N$ 是 250 米半径范围内车队所有车辆的总停留点数，$n_{\\nu}$ 是车辆 $\\nu$ 在同一区域停靠的总次数。这个熵度量给出了一个区域内同一车队车辆的多样性。\n\t\n\t- 簇中汽车停靠点的平均，总和，最大和最小驻留时间。\n\t- 邻近汽车停靠点的数量 (在其质心250米半径以内)。\n\t\n- 序列特征 (Sequential features，SeqF).\n\n## 不足\n\n- 在车辆停靠点侦查技术章节中，使用的是非监督方式的算法，即基于密度的 DBSCAN 聚类算法。其中涉及密度阈值的设定多少问题，就需要对具体样本量进行考究才能决定。\n\n## 参考\n[1] Horozov T, Narasimhan N, Vasudevan V. Using location for personalized POI recommendations in mobile environments [C]//Applications and the internet, 2006. SAINT 2006. International symposium on. IEEE, 2006: 6 pp.-129.  \n[2] Jiang K, Yin H, Wang P, et al. Learning from contextual information of geo-tagged web photos to rank personalized tourism attractions [J]. Neurocomputing, 2013, 119: 17-25.\n[3] Palma A T, Bogorny V, Kuijpers B, et al. A clustering-based approach for discovering interesting places in trajectories [C]//Proceedings of the 2008 ACM symposium on Applied computing. ACM, 2008: 863-868.  \n[4] Gong L, Sato H, Yamamoto T, et al. Identification of activity stop locations in GPS trajectories by density-based clustering method combined with support vector machines [J]. Journal of Modern Transportation, 2015, 23(3): 202-213.  \n[5] Ester M, Kriegel H P, Sander J, et al. A density-based algorithm for discovering clusters in large spatial databases with noise [C]//Kdd. 1996, 96(34): 226-231.  \n[6] Lv M, Chen L, Xu Z, et al. The discovery of personally semantic places based on trajectory data mining [J]. Neurocomputing, 2016, 173: 1142-1153.  \n[7] Gingerich K, Maoh H, Anderson W. Classifying the purpose of stopped truck events: An application of entropy to GPS data [J]. Transportation Research Part C: Emerging Technologies, 2016, 64: 17-27.  \n[8] Sambo F, Salti S, Bravi L, et al. Integration of GPS and satellite images for detection and classification of fleet hotspots [C]//Intelligent Transportation Systems (ITSC), 2017 IEEE 20th International Conference on. IEEE, 2017: 1-6.  \n[9] Wolf J, Guensler R, Bachman W. Elimination of the travel diary: Experiment to derive trip purpose from global positioning system travel data [J]. Transportation Research Record: Journal of the Transportation Research Board, 2001 (1768): 125-134.  \n[10] Bohte W, Maat K. Deriving and validating trip purposes and travel modes for multi-day GPS-based travel surveys: A large-scale application in the Netherlands [J]. Transportation Research Part C: Emerging Technologies, 2009, 17(3): 285-297.  ","tags":["特征提取"],"categories":["Paper"]},{"title":"论文 | 通过降维方法自动分类细胞表达","url":"%2F2018%2F06%2FAutomatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding.html","content":"\n{% note default %}\n原文：Automatic classification of cellular expression by nonlinear stochastic embedding (ACCENSE)  \n作者：Karthik Shekhar, Petter Brodin, Mark M.Davis and Arup K.Chakraborty.  \n来源：Proceedings of the National Academy of Sciences (PNAS), 2014, 111(1): 202-207.  \n{% endnote %}\n\n## 摘要\n\n质谱流式细胞技术 ( Mass cytometry ) 能够在单细胞水平上识别到近 40 种不同的蛋白质，即提供前所未有的多维信息。由于各式各样的细胞种群数据集的复杂性，要收集有用的生物学知识对计算工具也有新的要求。回顾之前的聚类方法，聚类需要特征 ( 维度 )，而每一种蛋白质 ( 细胞表征由不同蛋白质表示 ) 可当作一种特征，聚类算法就会自动识别不同类型的簇群，即对于不同功能的细胞识别是基于细胞表征相似性来实现区分的。当然，经典方法存在一定局限性，例如单细胞分辨率的损失 ( 特征或维度的减少 )；经典方法需要预知簇中的对象数量 ( 本文中指细胞亚群的规模数量 )。\n\n<!-- More -->\n\n而该论文引入 `ACCENSE` ( Automatic classification of cellular expression by nonlinear stochastic embedding ) 高维单细胞数据分析工具：\n\n- 基于密度划分的非线性降维方法，降维方法采用 `t-Distributed Stochastic Neighbor Embedding (t-SNE)` 算法 $^{[1]}$。\n- 该算法非常适合于探索性数据分析，同时避免任何手动 `阀门(阈值)` 的需要，即有别于基于距离的方法 ( 离群点判定 )、基于密度的方法 ( 密度阈值设定 )。\n- 化繁为简，在二维或三维图上展示不同功能的多元细胞群。\n\n再有，本论文将 ACCENSE 应用于 35 参数的质谱流式细胞技术，检测 CD8+ T 细胞的数量 ( 数据来自于特定的无病原和无菌小鼠 )，并将细胞分层到表型亚群中。需要说明的是，对于具体的聚类算法、降维算法中，**特定的符号名称会以具体的对象名称替代**。\n\n## 正文\n\n### 背景介绍\n- 免疫系统包含了许多类型的细胞，它们在免疫应答过程中表现出多样化的功能和复杂方式的相互作用，即通过不同蛋白质的表征所定义，故个体细胞的功能与其细胞表型密切相关。这里启示我们，对于不同功能的细胞可通过细胞表型相似性进行聚类区分。\n\n- 传统流式细胞技术和质谱流式细胞技术的区别：\n\t- 传统流式细胞技术 ( Flow Cytometry ) $^{[2]}$ 中，用 `荧光基因` 标记的抗体染色，其通过单细胞分辨率的光发射信号对靶标蛋白进行量化。且由于有限的光谱和重叠的发射信号，每个细胞限制为 12-16 个参数进行量化。\n\n\t- 质谱流式细胞技术 ( Mass Cytometry ) $^{[3]}$ ，使用 `金属螯合探针` 可对单个细胞多达 42 个参数的进行量化。\n\n\t- 传统流式细胞技术和质谱流式细胞技术相比，主要有两点不同：  \n\t\t- 标签系统的不同，前者主要使用各种荧光基团作为抗体的标签，后者则使用各种金属元素作为标签；  \n\t\t- 检测系统的不同，前者使用激光器和光电倍增管，而后者使用 ICP 质谱技术。 \n\n### 聚类算法\n- 由 `质谱流式细胞技术产生的高维数据`，以生物学的方式解释是具有挑战性的。然而，很多聚类工具是基于细胞的蛋白表达相似性进行细胞分类的，\n- 例如，`SPADE 算法` $^{[4,5]}$ 使用多元信息定义细胞簇，并在树状结构中显示潜在的表型层次结构。但尚有不足之处：\n\t- 一是单细胞分辨率的损失；\n\t- 二是对目标集群数量的需要预知。\n\n### 降维算法\n\n> 关于 `降维算法` 在另外一篇博文也有提及，不妨参考学习：[利用 t-SNE 降维并可视化数据](https://www.kofes.cn/2018/11/The-Best-Way-to-Visualize-a-Dataset-Easily.html)。\n\n- 同样，降维算法以细胞表征 ( 由不同蛋白质表示 ) 的相似性为依据，把空间组织的细胞群在低维空间上聚类成不同的细胞亚群。以下罗列一些常见的降维算法。\n- `PCA 算法`：PCA 降维的大致思想就是，挑选特征明显的、显得比较重要的信息保留下来。在本论文中，Newell 等人将主成分分析 ( Principal component analysis，PCA ) 应用于 25 参数的质谱流式细胞技术，检测人的 CD8+ T 细胞的数量，且使用前三种主成分 ( 3D-PCA ) 分离细胞亚群。3D-PCA 以三个汇总变量表示数据，每个汇总变量都是原始维度的 `线性组合`，并去捕获投影后数据的方差，直至其取值为最大值。然而，PCA 能在数据中所有的可能线性组合中找到最优表达，但也存在限制条件：线性投影可能太严格而不能产生精确的表示 $^{[6]}$，故作者引入 t-SNE 算法继续展开研究。\n- `t-SNE 算法` $^{[7]}$：t-Distributed Stochastic Neighbor Embedding，数据降维与可视化的方法，具体的算法细节如下：\n\t- 让 $\\{x^{(i)}\\}$ 表示归一化的 N 维蛋白质表达向量编码的细胞表型 i ( i=1, 2, ..., M )。\n\t- 若在 2D 平面图下，$\\{y^{(i)}\\}$ 向量是高维向量 $\\{x^{(i)}\\}$ 对应于低维的映射，它使得具有相似表型的 T 细胞彼此靠近嵌入，表型不相似的则嵌入相对较远的距离。\n\t- 采用细胞 i 和 j 之间的成对概率 $\\{p_{i,j}\\}$ 表示 $\\{x^{(i)}\\}$ 与 $\\{x^{(j)}\\}$ 之间的相似性。\n\t- 若在 2D 平面图下，成对概率 $\\{q_{i,j}\\}$ 表示 $\\{y^{(i)}\\}$ 与 $\\{y^{(j)}\\}$ 之间的相似性。\n\t- 通过最小化 $\\{p_{i,j}\\}$ 与 $\\{q_{i,j}\\}$ 的 KL 散度 ( 可理解为代价函数 )，然后找出 \"最佳\" 嵌入向量 $\\{y^{(i)}\\}$，即它表示的意义是，高维转低维的表示信息能最大程度被保存下来。\n\t\n\t\t> K-L 散度 ( [详细见附录 1](#1-t-SNE-中的概率) )，Kullback-Leibler Divergence，又称相对熵，即描述两概率分布 P 和 Q 的差异。KL 散度公式 (1) 如下：\n\t\n\t$$D_{KL}(\\{p_{i,j}\\}|\\{q_{i,j}\\}) = \\sum_{i,j} p_{i,j} log \\frac{p_{i,j}}{q_{i,j}} \\tag{1}$$\n\t\n\t- $\\{y^{(i)}\\}$ 可以编码非线性关系，不像 PCA 中被约束为 $\\{x^{(i)}\\}$ 的线性组合。\n\t- `最佳嵌入` 是通过数值梯度下降法来确定的，即所有数据点的 KL 散度总和减小到最小 ( [详细见附录 2](#2-数值梯度下降法) )。\n\n### 识别细胞亚群\n- 使用一个高斯核函数，把 t-SNE 的二维细胞散点图加工成 `复合图像`，如图 1-1 (D) 所示。其中，$K_\\gamma(y)$ 通过计算低维空间中所有细胞的位置总和，以表示 t-SNE 二维映射图中细胞的局部密度：\n\n\t$$K_\\gamma(y) = (2 \\pi \\gamma^2)^{-1}\n\t\\sum_{y' \\in Y}exp( -\\frac{||y - y'||^{2}}{2\\gamma^2})\n\t\\tag{2}\n\t$$\n\n- 在本论文中，$K_\\gamma(y)$ 的 `局部最大值` 表示具有共同表型的 CD8+ T 细胞亚群，且使用了 Matlab 的峰值检测算法识别这些局部最大值。\n\n\t> 当然，也可以在嵌入点上使用 K-Means 聚类算法来识别 T 细胞子集，但其要求事先指定簇的数量。\n\t\n- 如何求得 `局部最大值`，关键是对于公式 (2) 中 $\\gamma$ 的参数设定多少有关。即通过比较不同的核-带宽 $\\gamma$ ( 核函数的方差，也可理解为窗口、邻域 ) 产生的结果，则存在一个 $\\gamma$ 值为表型空间中的局部和全局特征提供了准确的粗粒度表示。从图 1-2 中可得，即启示我们可以以数据驱动的方式，求得较合适的 $\\gamma$ 值，以近似地识别 CD8+ T 细胞的细胞亚群。\n\n### 相关图表\n- 如图 1-1 所示，ACCENSE 应用于质谱高维数据。\n\n![图1-1ACCENSE ACCENSE 应用于质谱高维数据](/images/illustration/Paper/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding_1-1.jpg)\n<center>图 1-1 ACCENSE 应用于质谱高维数据</center>\n\n(A) 质谱细胞计数数据集样本的图示。行对应于不同的细胞，而列对应于测量其表达 (细胞表面抗原和细胞内蛋白) 的不同标记的金属螯合抗体。每一元组对应于指示每个标记的表达水平的质荷比变换值 (反双曲函数)。(C) 来自SPF B6 小鼠的 CD8+ T 细胞的 2D t-SNE 图谱。每个点代表来自训练集的一个细胞 (M = 18304)，且数据点是通过对原始数据集进行下采样得到。(D) 通过使用基于高斯核密度变换 ($K_{\\gamma}(y)\\,{,}\\,\\gamma = 7$)，将细胞的局部概率密度嵌入 (C) 的复合图像。并使用标准的峰值检测算法进行识别局部最大值，在二维密度图表示表型亚群的中心。\n\n- 如图 1-2 所示，展示了峰值随着 $\\gamma$ 的增加而变化。\n\n![图1-2展示了峰值随着γ的增加而变化](/images/illustration/Paper/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding_1-2.png)\n<center>图 1-2 展示了峰值随着 $\\gamma$ 的增加而变化</center>\n\n\t\n## 附录\n\n### 1 t-SNE 中的概率\n#### $p_{i,j}$ 概率\n- 基于蛋白质相似性，设 $p_{j|i}$ (i,j = 1, 2, ..., M) 表示细胞 i 将选择细胞 j 作为其最近邻的概率 ( $p_{j|i}$ 越大，$x^{(i)} 和 x^{(j)}$ 越近 )：\n\n$$\np_{j|i} = \\frac{\n\texp({-||x^{(i)} - x^{(j)}||^2} / {\n\t2\\sigma_i^2})\n}{ \n\t\\sum_{k \\neq i} exp({-||x^{(i)} - x^{(k)}||^2} / {\n\t2\\sigma_i^2})\n}, d_{i,j} = ||x^{(i)} - x^{(j)}||_2\n\\tag{3}\n$$\n\n- 对于概率 $p_{j|i}$ 的几点说明：\n\n\t- $d_{i,j}$ 可以使用其他距离范式替代欧式距离范式；\n\t- 原始的 SNE 算法是不对称的，为简化梯度公式，t-SNE 中让公式 (3) 的条件概率是对称的。即初始化 $p_{i|i} = 0$ ( 只考虑不同点两两之间的相似度 )，对于任意的 $p_{i|j} = p_{j|i}$，可得：\n\n\t$$\n\tp_{i,j} = \\frac{\n\t\tp_{j|i} + p_{i|j} \n\t}{2M} = \\frac{\n\t\texp({-d_{i,j}^2} / {\n\t\t2\\sigma_i^2})\n\t}{ \n\t\t\\sum_{k \\neq i} exp({-d_{i,k}^2} / {\n\t\t2\\sigma_i^2})\n\t}\n\tp_{i,j} = \\frac{\n\t\tp_{j|i} + p_{i|j} \n\t}{2N} \\\\\n\t( p_{j|i} = \\frac{p_{i,j}}{p_i}, \\,\n\tp_{i|j} = \\frac{p_{i,j}}{p_j}, \\,\n\tp_i = p_j = \\frac1M )\n\t\\tag{4}\n\t$$ \n\t\n- 不同的点 $x_i$，方差 $\\sigma_i$ 的取值也是不同的。\n\t- 公式 (3) 中的方差 $\\sigma_i$ 是确保对于每一个细胞都有相同的困惑度 ( Complexity )。复杂度可理解为一个点附近的 `有效近邻点个数`。\n\t- 定义复杂度为 $P_i = 2^{H_{j|i}}$，其近似地解释为细胞 i 的最近邻点的数量。\n\t- 定义 $p_{j|i}$ 的香农熵 (信息熵) 为 $H_{j|i} = - \\sum_j p_{j|i} \\log_2 p_{j|i}$，且 $H_{j|i}$ 随着 $\\sigma_i$ 的增加而增加。\n\n\t\t> 在本论文中，t-SNE 图谱的复杂度被设定为 30，即 10-50 范围内的复杂度对最终结果的影响不大 (较好的鲁棒性)。\n\n#### $q_{i,j}$ 概率\n- 对于低维度下的 $\\{y_i\\}$，在原始的 SNE 算法 $^{[7]}$ 中 Hinton 和 Rowers 引用高斯分布函数定义 $q_{i,j}$，但在低维表达中发现了 `拥挤问题`。\n\n\t> `拥挤问题`：就是说各个簇聚集在一起，无法区分。譬如，有一高维度数据在降维到 10 维下可以有很好的表达，但是降维到两维后无法得到可信映射。具体情况是，10 维中有数个点之间两两等距离的，在二维下就无法得到可信的映射结果。  \n\t>\n\t> 进一步说明，假设一个以数据点 $x^i$ 为中心，半径为 r 的 m 维球(三维空间就是球)，其体积是按 $r^m$ 增长的，假设数据点是在 m 维球中均匀分布的，我们来看看其他数据点与 $x^i$ 的距离随维度增大而产生的变化。\n\n- t-SNE 减轻了拥挤问题，即使用更加偏重长尾分布的方式来将距离转换为概率分布 $^{[8]}$，故有 $q_{i,j}$：\n\n\t$$\n\tq_{i,j} = \\frac{\n\t\t(1 + ||y^{(i)} - y^{(j)}||^2)^{-1}\n\t}{ \n\t\t\\sum_{k \\neq i} (1 + ||y^{(i)} - y^{(k)}||^2)^{-1}\n\t}, \\Delta_{i,j} = ||y^{(i)} - y^{(j)}||^2\n\t\\tag{5}\n\t$$\n\n- 同样地，对于概率 $q_{i,j}$ 的几点说明：\n\t- $\\Delta_{i,j}$ 可以使用其他距离范式替代欧式距离范式；\n\t- 原始的 SNE 算法是不对称的，为简化梯度公式，t-SNE 中让公式 (5) 的条件概率是对称的。即初始化 $q_{i|i}=0$，对于任意的 $q_{i|j} = q_{j|i}$。\n\n### 2 数值梯度下降法\n- 在 [7] 中的概述过程，获得优化的梯度公式，如下所示:\n\n\t$$\n\t\\frac{\n\t\t\\partial D_{KL}(\\{p_{i,j}\\} | \\{q_{i,j}\\})\n\t}{\n\t\t\\partial_{y_t}^{(i)}\n\t} = 4 \\sum_j \\frac{\n\t\t(p_{i,j} - q_{i,j})\n\t}{\n\t\t(1 + ||y_t^{(i)} - y_t^{(j)}||^2)\n\t}\n\t(y_t^{(i)} - y_t^{(j)})\n\t\\tag{6}\n\t$$\n\n- 通过梯度下降法迭代计算局部最大值：\n\n\t$$\n\ty_{t+1}^{(i)} = y_{t}^{(i)} + \\eta(t) \\frac{\n\t\t\\partial D_{KL}(\\{p_{i,j}\\} | \\{q_{i,j}\\})\n\t}{\n\t\t\\partial_{y_t}^{(i)}\n\t} + \\alpha(t)(y_{t}^{(i)} - y_{t-1}^{(i)})\n\t\\tag{7}\n\t$$\n\n\t- $y_t^{(i)}$ 表示迭代 t 次的解，$\\eta(t)$ 表示学习速率，$\\alpha(t)$ 表示迭代 t 次的动量。\n\t- 学习速率初始值为 $\\eta(t) = 100\\,^{[9]}$，且动能量 $\\alpha(t)$ 设定为：\n\t\n\t$$\n\t\\alpha(t) = \\begin{cases} 0.8, & t < 300 \\\\\n\t0.5, & t \\geq 300 \\end{cases}\n\t$$\n\n## 不足\n- t-SNE 主要用于可视化，很难用于其他目的。譬如测试集合降维，因为他没有显式的预估部分，不能在测试集合直接降维。\n- 关于核-带宽 $\\gamma$ 参数设定问题：文中展示了 $\\gamma$ 参数的大小与识别细胞亚群能力的数量关系。然而，数据驱动方式虽能实现自动聚类，但缺乏对于 $\\gamma$ 参数设定范围该如何控制的说明。\n\n## 参考\n- [1] Maaten L, Hinton G. Visualizing data using t-SNE [J]. Journal of machine learning research, 2008, 9(Nov): 2579-2605.  \n- [2] Cantor H, Simpson E, Sato V L, et al. And functional studies of peripheral t-cells binding different amounts of fluorescent anti-thy 1.2 (theta) Antibody using a fluorescence--activated cell sorter (FACS) [J]. 1975. \n- [3] Bendall S C, Nolan G P, Roederer M, et al. A deep profiler's guide to cytometry [J]. Trends in immunology, 2012, 33(7): 323-332. \n- [4] Qiu P, Simonds E F, Bendall S C, et al. Extracting a cellular hierarchy from high-dimensional cytometry data with SPADE [J]. Nature biotechnology, 2011, 29(10): 886.  \n- [5] Bendall S C, Simonds E F, Qiu P, et al. Single-cell mass cytometry of differential immune and drug responses across a human hematopoietic continuum [J]. Science, 2011, 332(6030): 687-696.  \n- [6] Van Der Maaten L, Postma E, Van den Herik J. Dimensionality reduction: a comparative [J]. J Mach Learn Res, 2009, 10: 66-71.  \n- [7] Maaten L, Hinton G. Visualizing data using t-SNE [J]. Journal of machine learning research, 2008, 9(Nov): 2579-2605.\n- [[8] Chrispher. t-SNE 完整笔记 [OL]. www.datakit.cn. 2017.](http://www.datakit.cn/blog/2017/02/05/t_sne_full.html)  \n- [9] Jacobs R A. Increased rates of convergence through learning rate adaptation[J]. Neural networks, 1988, 1(4): 295-307.","tags":["机器学习"],"categories":["Paper"]}]