[{"title":"基于 Hexo 框架在 Github 上搭建博客","url":"/2018/01/Hexo-Installation-Guide.html","content":"\n## 序言\n\nHexo\\\\(^{[1]}\\\\)，一个快速、简洁且高效的博客框架，若以个人博文为主导需求，它的强大毋庸置疑。    \n\nHexo 支持 GitHub Flavored Markdown 的所有功能；且基于 Node.Js 所带来的超快生成速度，百页博文秒级渲染；开放性 API 以及丰富的插件等，即功能来得纯粹，不失个性化定制，上手容易且操作便捷。更重要的一点，它是开源的、免费的博客框架，数据保存在本地以及 Github 上，相信在众多博客产品中选择、博弈，相信 Hexo 的表现不会令你失望。\n\n对于 Hexo 的安装、使用教程尽量遵照官方使用文档的流程操作，而本文则将侧重于 Hexo 的优化体验、实用插件等方面的内容分享。\n\n若想了解详情可访问「[hexo.io](https://hexo.io/)」。\n\n<!-- more -->\n\n## 壹 搭建环境\n\n- Mac OS、Windows 环境下的配置流程和步骤大同小异，而搭建环境的大致流程为：  \n - Git 环境配置 ( Windows )\n - Node.Js 环境配置\n - Github 账号注册和配置\n - Hexo 的安装和配置\n- 考虑到是流程操作类的文章，为简单起见，则我们以 MacOS 和 Windows 版本分别说明情况：\n - [MacOS 版本](#MacOS-版本)\n - [Windows 版本](#Windows-版本)\n\n\n### MacOS 版本\n#### 配置环境\n\n-  Xcode: Hexo的编译依赖于 Xcode\n - Xcode 可自行到 Apple App Store 下载\n-  Node.Js: Hexo 是基于 Node.Js 开发的\n - [官方下载](https://nodejs.org/)\n - 本地安装，文件包为「Node-Vx.x.x.pkg」\n - 检测是否安装成功，当然返回版本信息即成功安装\n\n\t```bash\n\t# 终端下输入命令:  \n\tnode -v  \n\tnpm -v\n\t```\n \n- Github Account ( **已有账号、项目可忽略** )\n - 注册账号「[GitHub](https://github.com/)」\n - 创建代码库 \n\n\t> 具体操作步骤:  \n\t> 1. Add ( 右上角「+」图标 ) > New Repository；  \n\t> 2. Repository Name，填写`yourname.github.io`；        \n\t> 3. Repository Description，填写`简单描述`；\n \n - 配置代码库\n \n\t> 具体操作步骤:  \n\t> 1. 进入项目「yourname.github.io」；  \n\t> 2. Settings > GitHub Pages，开启`GH-Pages`功能；  \n\t> 3. 点击「Launch Automatic Page Generator」；\n\n\t> 第三步说明:  \n\t> Github 将会自动替你创建出一个 GH-Pages 的页面。若配置没有问题，约15分钟后，yourname.github.io 就可以正常访问了，配置结束。\n\t\n#### 安装 HEXO\n##### 安装 HEXO\n- 本地选择安装目录\n \n ```bash\n cd your-hexo-site \n ```\n\n- 在线安装 HEXO ( [NPM淘宝源](http://npm.taobao.org/) )\n\n ```bash\n npm install hexo-cli -g  \n hexo init  \n hexo install\n ```\n\t\t\n- 检测是否安装成功，当然返回版本信息即成功安装\n \n ```bash\n hexo -v\n ```\n \n##### 运作 HEXO \n- 本地运作 HEXO\n\n ```bash\n hexo server\t# 或简写 hexo s\n ```\n\n- 当终端提示以下信息，则本地配置工作基本完成。\n\n\t> Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.\n\n##### 使用 HEXO\n\n> [注意] 此项操作，需要确保在 Hexo 安装目录下执行。\n\n- 新建一篇博文 ( 当然，更新过往的文章只需修改「Hexo > Source > _Posts」目录下相应的 MarkDown 文件 )\n\n ```bash\n hexo new post \"Article Title\"\n ```\n\t\n- 生成博文 ( 生成静态网页 )\n \n ```bash\n hexo generate\n ```\n\n##### 部署至 GitHub\n- 部署至 Git 的准备工作\n \n ```bash\n # 在部署前，还需要安装「Git部署插件」:  \n npm install hexo-deployer-git --save\n \n # 若没有安装该插件，会出现情况：\n # deloyer not found:git\n ```\n \n- 再者，与 Github 连接前需要获得授权，不然会出现以下情况 ( 本机没有配置 Public Key ):\n     \n\t> Permission denied (publickey).  \n\t> fatal: Could not read from remote repository.  \n\t> Please make sure you have the correct access rights and the repository exists.\n\t\n- 配置「SSH KEY / Public KEY」\n\n\t> [注意] 若之前机器上配置了 Git 的信息，请跳过该步骤。\n   \n\t```bash\n\t# 1. 配置 Git 的 UserName 和 Email \n\t# “YourAnonymousName\"，可以替换成自己的用户名   \n\tgit config --global user.name \"YourAnonymousName\"  \n\t# \"UserName@xxx.com\"，替换成自己的邮箱  \n\tgit config --global user.email \"UserName@xxx.com\"  \n\t\n\t# 2. 检查是否已经有 SSH KEY\t \n\t# Step01. 列出该目录下的文件；\n\t# Step02. 看是否存在「id_isa」和「id_isa.pub」文件；\n\tcd ~/.ssh\n\tls\n\t \n\t# Step03. 若存在则跳过，没有则执行此步骤「生成密钥」.\n\t# 邮箱「UserName@xxx.com」替换成自己的邮箱\n\tssh-keygen -t rsa -C \"UserName@xxx.com\"\n\t\t\n\t# 3. 登陆 Github, 添加 SSH KEY\n\t# Step01. Avatar(头像) > Settings > Personal Settings > SSH and GPG keys； \n\t# Step02. New SSH KEY，把「id_isa.pub」的密钥粘贴过去即可.  \n\t \n\t# 4. 测试是否配置成功\t\n\tssh -T git@github.com\n\t# 提示「Hi YourName! You've successfully authenticated, but GitHub does not provide shell. access.」即成功配置。\n\t```\n\n- 配置「_config.yml」文件  \n\n - 在 Hexo 安装目录下找到 _config.yml 文件，如「~/你的安装目录/Hexo/_config.yml」。找到「deploy」字段，修改配置。\n\n\t > deploy:  \n\t > type: git  \n\t > repo: https://github.com/yourname/yourname.github.io.git  \n\t > branch: master  \n\n - 注意: 冒号后面含一个空格；使用 Github 不用 branch 字段；若使用多个 deployer，则有：\n\t\n\t ```bash\n\t deploy:\n\t - type: git\n\t repo:\n\t - type: heroku \n\t repo:\n\t ```\n\n- 部署至 Git\n \n\t```bash\n\thexo deploy\t  \n\thexo d -g\t# 即在部署之前先生成\n\t```\n\n### Windows 版本\n#### 配置环境\n\n> Github 账号注册和配置和 Hexo 的安装和配置，在 Windows 与 MacOS 上是通用的。因此，在 Windows 版本中，主要阐述 Node.Js和 Git 的安装和配置即可。\n\n- Node.Js 的安装和准备\n - 下载并安装「[Node.Js for Windows x86/x64 bit](https://nodejs.org/en/download/)」\n - 检测是否安装成功，当然返回版本信息即成功安装\n\n\t```bash  \n\tnode -v  \n\tnpm -v\n\t```\n\t\n- Git 的安装和准备\n - 下载并安装「[Git for Windows x86/x64 bit](https://git-scm.com/download/win)」\n - 检测是否安装成功，当然返回版本信息即成功安装\n\n\t```bash \n\tgit --version\n\t```\n\n## 贰 优化拓展\t\n至此，Hexo 的安装以及 GitHub 的配置工作暂告一段落。能正常运行使用 Hexo 是没问题的，而下面的章节则是对 Hexo 的扩展和个性化定制，根据自己的需求挑选阅读、实践。\n\n### 套用一款主题\n\nHexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。\n\n在 Hexo 中有两份主要的配置文件，其名称都是「_config.yml」。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。\n\n为了描述方便，在以下说明中，将前者称为「`站点配置文件`」， 后者称为「`主题配置文件`」。\n\n具体以 NexT\\\\(^{[2]}\\\\) 为例说明，安装步骤如下。\n\n#### 下载主题  \n\n如果你熟悉 Git， 建议你使用`克隆最新版本`的方式，之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。\n\n```bash\n# 克隆最新版本\ncd your-hexo-site  \ngit clone https://github.com/iissnan/hexo-theme-next. themes/next\n\n# 快速更新\ncd themes/next\ngit pull\n```\n\n#### 启用主题  \n- 与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到`theme`字段，并将其值更改为`next`。\n \n\t> theme: next\n\n- 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。\n \n\t```bash\n \thexo clean\n\t```\n\t\n#### 主题设定\n- 选择 Scheme\n\n Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：\n \n - Muse - 默认 Scheme，黑白主调，大量留白  \n - Mist - Muse 的紧凑版本，整洁有序的单栏外观  \n - Pisces - 双栏 Scheme，小家碧玉似的清新  \n\n\t```bash\n\t#scheme: Muse\n\t#scheme: Mist\n\tscheme: Pisces\n\t```\n\n\t> Scheme 的切换通过更改`主题配置文件`，搜索「scheme」关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。\n\t\n- 设置语言\n\n\t编辑`站点配置文件`， 将`language`设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下 ( 更多请语言配置请参考下述表格 )：\n \n\t> language: zh-Hans  \n\n| 语言 | 代码 | 设定示例 |\n| :---- | :---- | :---- |\n| English | en | language: en |\n| 简体中文 | zh-Hans\t| language: zh-Hans |\n| Français | fr-FR | language: fr-FR |\n| Português | pt | language: pt or pt-BR |\n| 繁體中文 | zh-hk | language: zh-hk |\n| Русский\t | язык\tru | language: ru |\n| Deutsch | de | language: de |\n| 日本語 | ja | language: ja |\n| Indonesian | id | language: id |\n| Korean | ko | language: ko |\n\n- 设置菜单\n\n\t菜单配置包括三个部分，第一是菜单项 ( 名称和链接 )，第二是菜单项的显示文本，第三是菜单项对应的图标。\n \n\tNexT 使用的是 [Font Awesome](http://fontawesome.io/)\\\\(^{[3]}\\\\) 提供的图标，600+ 的图标可满足大部分需求，且适配 Retina 屏幕。\n \n\t编辑`主题配置文件`，修改以下内容：\n \n \t{% note warning %} 请注意键值（如 home）的大小写要严格匹配。 {% endnote %}\n \n - 设定菜单内容，对应的字段是`menu`，菜单内容的设置格式是：`item name: link`。其中`item name`是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。\n\n\t ```bash\n\t menu:\n\t home: /\n\t archives: /archives\n\t #about: /about\n\t #categories: /categories\n\t tags: /tags\n\t #commonweal: /404.html\n\t \n\t # 若你的站点运行在子目录中，请将链接前缀的/去掉\n\t ```\n\n\t NexT 默认的菜单项有( 标注 `*` 的项表示需要手动创建这个页面 )：\n\n| 键值 | 设定值| 显示文本(简体中文) | \n| :--- | :--- | :--- |  \n| home | home: / | 主页 |  \n| archives | archives: /archives | 归档页 |  \n| categories | categories: /categories | 分类页 `*` |  \n| tags | tags: /tags | 标签页 `*` |  \n| about | about: /about | \t关于页面 `*` |  \n| commonweal | commonweal: /404.html\t | 公益 404 `*` |  \n\t\n - 设置菜单项的显示文本，在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用这个名称查找对应的语言翻译，并提取显示文本。\n \n\t 这些翻译文本放置在 NexT 主题目录下的`languages/{language}.yml` （ {language} 为你所使用的语言 )。\n\n\t 以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件`languages/zh-Hans.yml`，在`menu`字段下添加一项：\n\t \n\t ```bash\n\t menu:\n\t home: 首页\n\t archives: 归档\n\t categories: 分类\n\t tags: 标签\n\t about: 关于\n\t search: 搜索\n\t commonweal: 404\n\t something: 有料\n\t ```\n\n - 设定菜单项的图标，对应的字段是`menu_icons`。\n \n\t ```bash\n\t menu_icons:\n\t enable: true\n\t # Icon Mapping.\n\t home: home\n\t about: user\n\t categories: th\n\t tags: tags\n\t archives: archive\n\t commonweal: heartbeat\n\t \n\t #  此设定格式是「item name: icon name」\n\t # 「item name」与上一步所配置的菜单名字对应\n\t # 「icon name」是 Font Awesome 图标的名字\n\t # 「enable」用于控制是否显示图标，你可以设置成「false」来去掉图标\n\t ```\n\t  \n- 设置侧栏 \n\n\t可以通过修改`主题配置文件`中的`sidebar`字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。\n \n - 设置侧栏的位置，修改 sidebar.position 的值，支持的选项有：\n \n\t > left - 靠左放置  \n\t > right - 靠右放置  \n\n\t 目前仅 Pisces Scheme 支持 position 配置。影响版本5.0.0及更低版本。\n\n\t ```bash\n\t sidebar:  \n\t position: left\n\t ```\n\n - 设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有：\n\n\t > post - 默认行为，在文章页面（ 拥有目录列表 ）时显示  \n\t > always - 在所有页面中都显示  \n\t > hide - 在所有页面中都隐藏（ 可以手动展开 ）  \n\t > remove - 完全移除  \n\n\t ```bash\n\t sidebar:\n\t display: post\n\t ```\n\n\t 已知侧栏在 use motion: false 的情况下不会展示。影响版本5.0.0及更低版本。\n\t\n- 设置头像\n\n\t编辑`主题配置文件`， 修改字段`avatar`，值设置成头像的链接地址。其中，头像的链接地址可以是：\n \n - 站外链接\n \n\t > avatar: http://example.com/avatar.png\n\t\n - 站内资源 \n\n\t > 放置在「source/images/」目录下，images 为自建目录   \n\t > avatar: avatar: /images/avatar.png\n\t\n### 揽收实用插件\n\n## 叁 参考资料\n\n[[1] HexoJs.使用文档.2018](https://hexo.io/docs/)  \n[[2] NexT.使用文档.2018](http://theme-next.iissnan.com/getting-started.html)  \n[[3] Dave Gandy.Font Awesome Accessibility](http://fontawesome.io/accessibility/)  \n[[4] 徐俊.手把手教你搭建属于自己的博客.CSDN.2017](http://blog.csdn.net/gdutxiaoxu/article/details/53576018) ","tags":["hexo"],"categories":["Project"]},{"title":"C语言程序设计 ( 应试篇 )","url":"/2017/04/C-Programming-Design-Learning.html","content":"\n## 前言\n\n从标题中透漏的信息可知，本系列文章是围绕 “C语言程序设计” 展开学习的笔记总结，且目的很明确，笔记内容偏应试，适用于计算机等级考试、考研专业课(C语言)等的复习使用。文章推崇总结性、比对性的学习方法，对于模糊的知识模块需自行查阅参考书目，深化理解或可达到理想的效果。\n\n<!-- more -->\n\n针对C语言程序，推荐几本辅导复习的书目：\n\n> - 基础篇 :\n\t- 《谭浩强:C语言程序设计》: 必不可少的经典教程，权威性的标准答案源。( 因讨论条件而异，如编译系统不同，部分题目的答案就具有了争议性 )\n\t- 《明解C语言》: 入门基础教学。值得称赞的是，每个知识模块都符有实例，且实例的源码结构清晰，代码规范及注释到位，非常适合入门使用。\n> - 进阶篇 :\n\t- 《征服C指针》: C语言的学习过程中，指针的运用是最大的难关。无论是在实际应用、应试中都是不可忽视的。对于作者前桥和弥，其一针见血的文风，在掌握一定基础之后，是深入了解C语言的一位不可多得 “良师益友” ( 书中有不少作者交谈式的独白，别有一番阅读风味 )。\n\n\n## 总览\n\n- [壹 程序设计和C语言](#1-壹-程序设计和C语言)\n- [贰 程序之魂：算法](#2-贰-程序之魂：算法)\n- [叁 简单的C语言程序设计](#3-叁-简单的C语言程序设计)\n- [肆 选择结构程序设计](#4-肆-选择结构程序设计)\n- [伍 循环结构程序设计](#5-伍-循环结构程序设计)\n- [陆 数组](#6-陆-数组)\n- [柒 函数](#7-柒-函数)\n- [捌 指针](#8-捌-指针)\n- [玖 构造类型：用户自己建立数据结构](#9-玖-构造类型：用户自己建立数据结构)\n- [拾 文件处理](#10-拾-文件处理)\n\n\n## 1 壹 程序设计和C语言\n### 1.1 计算机程序与语言\n 程序：计算机能识别和执行的指令。  \n 语言：人和计算机交流、人和计算机能识别的语言。\n 计算机语言发展阶段：   \n \n | 机器语言 | 符号语言 | 高级语言 ( 面向过程、面向对象 ) |\n | :----: | :----: | :----: |\n | 0和1指针 | 英文、数字表示指令 | 人类自然语言和数字语言 |\n\n### 1.2 C语言\n- 特点\n\t- 语言简洁、紧凑，使用方便、灵活\n\t- 运算符丰富 ( 单目、双目、三目运算符 )\n\t- 数据类型丰富 ( 整型、浮点型、字符型、数组类型、指针类型、结构体类型、共用体类型、枚举型 )\n\t- 结构体控制语句\n\t- 直接访问物理地址 ( 对硬件直接操作 )\n\t- 可移植性好\n\n- 结构\n\t- 以程序由一个或着多个 **源文件** 组成。  \n\t\t> 源文件中包括：  \n\t\t> 预处理命令 ( #include、#define、#typedef等 )  \n\t\t> 全局声明 ( 全局变量、局部变量 )  \n\t\t> 函数定义 ( 参考函数原型 )\n\t- 函数是C程序的主要组成部分。\n\t- 一函数包括函数首部和 **函数体**。  \n\t\t> 函数体包括：  \n\t\t> 声明部分和执行部分。 \n\t- 程序总是从main函数开始执行的。  \n\t\t> main函数有且仅有一个。\n\t- C程序对计算机的操作有C语言完成。\n\t- 数据声明和语句必须有分号 ( 作为结束 )。\n\t- C本身不提供输入输出语句。\n\n### 1.3 程序设计的任务\n1. 问题分析  \n2. 设计算法  \n3. 编写程序  \n4. 对源文件编辑、编译 ( \\*.obj ) 和连接 ( \\*.exe )  \n5. 运行程序并分析结果  \n6. 编写程序文档 \n\n> [注] 对于编译，预编译和连接的概念及比对： \n> \n> - 编译：检索语言错误；把源程序转为二进制形式的目标程序。\n> - 预编译：通过预处理得到的信息与程序其他部分一起，组成完整的、可以正式编译的源程序。\n> - 连接：与函数库相连接。\n \n \n## 2 贰 程序之魂：算法\n### 2.1 引入\n- 对数据的描述：所用数据的类型和数据的 **组织形式**。  \n> 组织形式：数据结构 -- 特定关系的数据元素的集合\n\n- 对操作的描述：计算机进行操作的步骤 -- 算法\n\n- 从简理解：**数据结构 + 算法 = 程序**\n\n\n### 2.2 算法\n- 概念：对特定问题求解的方法和描述。\n\n- 特征  \n\t- 有穷性：有穷时间执行结束；\n\t- 确定性：算法唯一执行路径，既相同输入执行相同路径；\n\t- 可行性：有限次；\n\t- 零或一个以上的输入；\n\t- 一个或以上的输出；\n\n- 要求  \n\t- 正确性；\n\t- 可读性；\n\t- 健壮性；\n\t- 效率与低存储量需求 ( 时间复杂度和空间复杂度 )  \n\t\n\t> * 时间复杂度 <-- 渐进时间复杂度 <-- 算法执行时间的增长率和f(n)的增长率相同。  \n\t> \t\n\t>> [说明]  \n\t>> 1. 渐进时间复杂度：**T(n) = Big O(f(n))**  \n\t>> 2. f(n)为问题规模n的某个函数。  \n\t>> 3. 算法中的基本运算( 最深层循环内的语句 )的频度与T(n)同数量级。  \n\t>  \n\t> * 空间复杂度 <-- 算法所需存储空间的量度。  \n\t> \n\t>> [说明]  \n\t>> 1. 渐进空间复杂度：**S(n) = Big O(f(n))**  \n\t>> 2. 原地工作：额外空间相对输入的数据量来说是常数。\n\t\n### 2.3 三种基本结构和改进流程图\n- 三种基本结构\n\t- 顺序结构；\n\t- 选择结构；\n\t- 循环结构：当型循环结构 / 直到型循环结构；\n- 改进的流程图：N-S流程图\n\n### 2.4 结构化程序设计方法\n- 自顶向下；\n- 逐步细化；\n- 模块化设计：**分而治之**；\t`注意模块独立性`\n- 结构化编码；\n\n\n## 3 叁 简单的C语言程序设计\n### 3.1 数据的表现形式及运算\n#### 3.1.1 常量\n- 概念：程序运行期间，其值不能改变。\n- 类型    \n\t- 整型常量  \n\t- 字符常量 ( 与常变量作比对 **[注释1]** )\n\t\t- 普通字符  \n\t\t- 转移字符：\\n, \\t, \\012 (8进制), \\x41 (16进制)\n\t\t- 符号常量：`#define PI 3.14159`\n\t- 实型常量\n\t\t- 10进制小数形式：3.14L\n\t\t- 指数形式(科学计数法):  \n\t\t8.7e-25(正确);  \n\t\t8.7e-2.5(错误)；  \n\t\t87e+25(正确);  \n\n#### 3.1.2 变量\t\n\n`先定义，后使用` \n\n- 包含属性\n\t- 数据类型 ( 整型、浮点型、字符型 )  \n\t- 存储类别 ( 自动变量，静态变量 )  \n- 概念：程序运行期间，其值可以改变。\n- 类型\n\t- 常变量：变量存在期间其值不能改变。 `const int a = 10`  \n\t- 自动变量与静态变量  \n\t- 全局变量与局部变量  \n\t> 从存储位置、生存周期、作用区域讨论差异性。**[注释2]**\n\t\t\n- 标识符  \n一个对象的名称。除关键字外，字符、数字和下划线组成。且要求只能是字母或下划线开头。\t\n\n> [注释1] 符号常量与常变量的比较。\n\n| 符号常量 | 常变量 |\n| :---- | :---- |\n| 不占内存单元，预编译后符号不复存在 | 占存储单元 |\n| 不能重新赋值 | 不能改变其值 |\n\n> [注释2] 局部变量与全局变量，自动变量与静态变量，内部函数与外部函数的比较。\n\n| 局部变量 | 全局变量 |  |\n| :---- | :---- | :---- |\n| 存放于动态存储区 | 存放于静态存储区 | 位置 |\n| 在定义函数内起作用 | 自定义位置开始，本文件起作用 | 作用域 |\n| 函数调用完释放内存 | 程序结束时释放内存 | 生存期 |\n> * 静态的局部变量，存放于静态存储区，程序结束时释放内存。\n> * 静态的全局变量，不是因声明static，而误解全局变量才存放于静态存储区。\n> * 局部变量，声明存储类型指变量存储区以及产生的生存期问题。  \n\t全局变量，声明存储类型指变量作用域的扩展问题。\n\t\n| 自动变量 | 静态变量 |\n| :---- | :---- |\n| 1. 声明该变量的语句块被执行结束释放内存(**栈**) | 1. 程序结束时才释放内存 |\n| 2. 每次函数调用时赋值 | 2. 保留上一步的赋值 |\n|  | 3. 在编时赋予初值0或'\\0' | \n> [注] 对比malloc()函数分配的内存，需调用free()函数释放内存。(**堆**)\n\n| 内部函数 | 外部函数 (default) |\n| :---- | :---- |\n| 本文件内使用(不限位置) | 可供其他文件使用(不限位置) |\n| 定义：static 函数类型 函数名 | 定义：(extern) 函数类型 函数名 |\n\t\n#### 3.1.3 数据类型\n- 基本类型\n\n|  | 关键字 | 字节 | 取值范围 |\n| :---- | :---- | :---- | :---- |\n| 整型 | int | 2/4 | $-2^{15}$ ~ $-2^{15}-1$ / $-2^{31}$ ~ $2^{31}-1$ |\n|      | unsigned int | 2/4 | 0 ~ $-2^{16}-1$ / 0 ~ $-2^{32}-1$ |\n| 字符型 | char | 1 | $-2^7$ ~ $2^7-1$ |\n|  | unsigned char | 1 | 0 ~ $2^8-1$ |\n| 单浮点 | float (有效小数：6) | 4 | -- |\n| 双浮点 | double (有效小数：15) | 8 | -- |\n> [注] 关于基本类型的特别说明  \n> \n> * 字符是按其ASCII形式存储的。\n> * 单浮点定义：float a = 3.14f\n> * 双浮点定义：double a = 3.14\n> * 长浮点定义：long double a = 3.14L\n\n- 派生类型\n\t- 指针类型：指向函数的指针、多重指针\n\t- 数组类型：指针数组\n\n- 构造类型\n\t- 结构体类型\n\t- 共同体类型\n\t- 枚举类型  \n\t> 详情见第玖章：构造类型\n\t\n- 类型转换：  \n\t- 低精度向高精度转换；  \n\t- 强制转换括号加类型；   `int a = (int)3.14`  \n\t- 多类型变量混合运算，取最高精度的类型；\n  \n\n## 4 肆 选择结构程序设计\n### 4.1 关系运算符及其优先次序\n- 各类运算符的优先级：\n\t- 单目运算符 > 双目运算符 (算术、关系、逻辑) > 三目运算符\n\t\n\t- 优先级由高到低排序：  \n\t初等运算符：`()，[]，->，.`  \n\t单目运算符：`!，++，--，~`  \n\t算术运算符：`*，/，%`，`+，-`  \n\t关系运算符：`>，<，>=，<=`，`!=，==`  \n\t逻辑运算符：`&&，||`  \n\t条件运算符：`a > b : a : b`  \n\t赋值运算符：`a += 1`  \n\t逗号运算符：`(a,b)`  \t\n\t\n\t- 结合方式  \n\t自左向右：`初等、单目、关系、逻辑、逗号运算符`\n\t自右向左：`条件、赋值运算符`  \n\t\n\t> 同一级的运算符，由结合方式决定优先级。\n\n### 4.2 表达式\n- 算术表达式：先乘除模，后加减，再由“自左向右”原则运算。\n\n- 混合运算\n\t- 优先级：遵循各运算符的优先次序。\n\t- 结合性：算术运算符 (自左向右)；赋值运算符 (自右向左)。\n\t- 不同类型的混合运算：结果的类型为**最高精度**的数据类型。\n\n### 4.3 运算符与表达式\n- 关系运算符和关系表达式 ( a+b>c ) -> True or False?  \n> 0表示假，!0表示真。\n\n- 逻辑运算符和逻辑表达式\n\t- 逻辑运算：5 && 4 => 1；5 && 0 => 0；  \n\t- 按位逻辑：5 & 4 => 4；  \n\t\n\t> [注] 关于逻辑运算与按位逻辑的比较  \n\t> \n\t> * 优先级：按位逻辑运算 > 逻辑运算  \n\t> * max = a & b；min = a | b    \n\n- 条件运算符和条件表达式：a > b ? a : b\n\n### 4.4 选择结构的嵌套 \n- if语句只有两个分支可供选择，else总是与它上面最近的未配对的if()配对。\n\n\t```C\n\tif(express1){\n\t\tif(express2){\n\t\t\t...\n\t\t} else {\n\t\t\t...\n\t\t}\n\t} else {\n\t\tif(express3){\n\t\t\t...\n\t\t} else {\n\t\t\t...\n\t\t}\n\t}\n\t```\n- switch语句实现多分支选择结构\n\n\t```C\n\tswitch(express1){ // 整型、字符型\n\t\tcase 常量/常量表达式:语句1；break; // break为拦截作用\n\t\tcase 常量/常量表达式:语句2；break;\n\t\tdefault: 语句3;\n\t}\n\t```\n\n\n## 5 伍 循环结构程序设计\n### 5.1 while 语句实现\n```C\nexpress1;\nwhile(express2){\n\texpress3;\n\t...\n}\n```\n### 5.2 for 语句实现循环\n```C\nfor(express1; express2; express3){\n\t...\n}\n```\n### 5.3 do...while() 语句实现循环\n```C\nexpress1;\n\ndo{\n\texpress3;\n} while(express2);\n```\n### 5.4 break、continue与goto语句\n- break：从循环体内跳出循环体。多层嵌套循环，跳出相邻一层循环。\n- continue：提前结束本次循环。\n- goto：跳出多层循环。\n\n\n## 6 陆 数组\n### 6.1 概念\n- 一组有序数据的集合。\n- 数组中每一元素同属一个数据类型。\n- sname[0] <=> *(p+0) <=> 第一个数组元素。  \n\n### 6.2 定义\n#### 6.2.1 一维数组\n- 定义  \n类型符 数组名[常量表达式]\t --> 正确  \n类型符 数组名[变量] --> 错误，不能为变量\n \n- 初始化  \n\t```C\n\tint array[] = {1, 2, 3, 4, 5};  \n\tin array[5] = {0}; // 5个元素都为0。\n\t```\n\n- 引用  \n\t```C\n\tint *p = &array[0];\t// 等同于 int *p = array;\n\tp++;\t// 指针运算\n\t*(p+i);\t// 取第i位元素\n\t```\n\n#### 6.2.2 二维数组\n- 定义：类型符 数组名[常量表达式][常量表达式]\n\n- 初始化\n \n\t```C\n\tint array[2][2] = { {1, 2}, {3, 4} };\n\tint array[2][2] = { 1, 2, 3, 4 };\n\tint array[][2] = { {1, 2}, {3, 4} };\t// 既只允许最外层元素个数定义时为空\n\t\n\tint array[][2] = { {0}, {3, 4} };\t// 正确 \n\tint array[][2] = { {}, {3, 4} };\t// 错误\t```\n\t\n- 引用\n\n\t```C\n\tint num = array[1][1];\n\tint *p = array;\n\t*(*(p+j)+j); // 等同于array[i][j];\n\t```\n\n#### 6.2.3 字符数组\n- 定义：char array[10]; <=> int array[10];\n> 字符型数组是以整型形式存放的 (ASCII)。\n  \t\n- 初始化  \n\n\t```C\n\tchar array[0] = 'A';\n\n\tchar array[] = {\"Hello\"};\n\t// 字符数组的存储情况：| H | e | l | l | o | \\0 |\n\t// sizeof() -- 6\n\t// strlen() -- 5\n\n\tchar array[] = {'H', 'e', 'l', 'l', 'o'};\n\t// sizeof() -- 5\n\t// strlen() -- 5\n\t\t\n\tint array[] = {\"Hello\"};\n\t// sizeof() -- 4\n\t// strlen() -- 1\n\t\t\n\tint array[] = {'H', 'e', 'l', 'l', 'o'};\n\t// sizeof() -- 20\n\t// strlen() -- 4\n\t\t\n\tchar *array = \"Hello\"; // 字符串常量\n\t```\n\t> [注]\n\t> \n\t> * 字符串常量不可以数组形式取具体位置进行元素修改。\n\t> * ( array == \"Hello\" ) => True or False ?  \nFalse，array与字符串常量比较的是内存地址。\n \n- 引用 \n  \n\t```C\n\tscanf(\"%c\", &array[0]);\n\tprintf(\"%c\", array[0]);\n\t\n\tscanf(\"%s\", array);\n\tprintf(\"%s\", array);\n\t```\n\t> [注]\n\t> \n\t> * 若字符数组中，存在'\\0'两个或以上，系统则以第一次出现的位置提前终止字符输出。\n\t> * stdin 也 gets() 搭配，可获得换行符、空格等字符。 (需结束标记符来终止输入)\n\n- 应用  \n> * 字符串处理函数：`#include <string.h>`\n> * 需掌握字符串函数自定义方法实现。\n> * 大部份字符串处理函数多数以标记量'\\0'为临界点，若字符数组中含两个或或以上，需注意实际的结果。\n\n\t- gets(字符数组) -- 输入一字符串到字符数组中\n\t- puts(字符数组) -- 输出一字符串到终端\n\t- strlen(字符数组) -- 测一字符串的实际长度\n\t- strcat(char \\*src1, const char \\*src2);\n\t> 数组src2后接于src1，src1中的'\\0'被覆盖。且数组src1必须足够大，以容纳数组src2。\n\t\n\t- strcpy(char \\*src1, const char \\*src2);\n\t> 数组src1必须足够大，以容纳数组src2。\n\t\n\t- strcmp(const char \\*src1, const char \\*src2);\n\t> 实际为ASCII的比较，其返回值为 <0、==0，>0 的情况。\n\t\n\t- strlwr(字符串) -- 将字符串中大写字母转为小写字母\n\t- strupr(字符串) -- 将字符串中小写字母转为大写字母\n\t- atoi(字符串) -- 字符串转int型\n\t- atol(字符串) -- 字符串转long型\n\t- atof(字符串) -- 字符串转double型  \n\t> 引用atoi()、atol()、atof()函数需引用`#include <stdlib.h>`  \n\n\n## 7 柒 函数\n### 7.1 为什么要用函数\n- 模块化程序设计：每一函数实现一特定的功能，函数的名称既反映功能。\n- 更好地代码复用：使用库函数；使用自己编写的函数。 \n \n\t> 代码复用：减少重复编码程序段的工作量。 \n\t>  \n\t> [说明]  \n\t> \n\t> 对于所有完成相同功能的组件，应抽象出一个接口，它们都实现该接口。  \n\t> 具体在Java中，所有完成相同功能的组件都**实现该接口**或**从该抽象类中的继承**。\n\t\n### 7.2 定义函数  \n`建立存储空间的声明`  \n\n函数返回类型 函数名 函数参数 函数体 (变量定义、声明，执行语句)\n> 函数返回类型：基本数据类型 / void型  \n> 函数名：驼峰式命名法  \n> 函数参数：实参、形参  \n\n### 7.3 函数声明\n`不需要建立存储空间的声明`\n\n- 函数原型 (Prototype)：函数返回类型、函数名、参数类型、参数个数、参数顺序\n\n- 函数声明的方法\n\t- 使用函数原型；\n\t- 同一源文件，在调用该函数的前面定义 (可打包到自定义头文件中)；\n\n### 7.4 函数调用\n- 嵌套调用、递归调用 (直接或间接调用该函数本身)\n- 实参和形参\n\t- 概念  \n\t实参：常量、变量或表达式、函数 (返回值)  \n\t形参：函数调用期间临时分配内存，值从实参中获得，调用结束后释放内存空间。\n\t- 实质：值传递、地址传递\n\n\n## 8 捌 指针\n### 8.1 指针是什么\n- 指针变量：保存变量地址的变量。\n- 指针类型\n\t- 指针类型的变量：存放地址\n\t- 指针类型的值：对应内存地址存放的值  \n\t> 在 swap(int \\*a, int \\*b); 的案例中可以形象说明两者的区别。\n\n### 8.2 指针移动 (运算：加、减)\n对指针加一、减一运算，即地址会增加或减少一单位长度。单位长度具体具体指当前指针所指向数据类型的所占空间大小。\n\n### 8.3 指针类型\n#### 8.3.1 空指针\n确保没有指向任何一个对象的指针。通常以宏定义NULL(0)表示空指针的常量值。\n> 关于NULL、0和'\\0'，大部分情况都为零。特别地，  \n> \n```C\nint *p = 0;\t// 正确，编译器将指针指向内存地址为0处。 \nint *p = 3;\t// 错误，赋值的数据类型不相符。\n```\n\n#### 8.3.2 指针类型的派生\n- 指向函数的指针\n```C\nvoid (*func(int));\n```\n\n- 指向数组的指针(多重指针)\n```C\nint (*p)[5];\n```\n\n#### 8.3.3 数组类型的派生\n- 指针数组\n```C\nint *p[5]; // 存放5个指向int类型的指针。\n```\n\n> [附] 用英语解读各种各样的C语言声明\n> \n| C语言 | 英语表示 | 中文表示 |\n| :---- | :---- | :---- |\n| int huge; | huge is int | hoge是int型 |\n| int huge[10]; | huge is array[10] of int | hoge是int型的数组 |\n| int huge[2][4]; | huge is array[2] of array[4] of int | hoge是int型的数组的数组 |\n| int \\*huge[10]; | huge is array[10] of point to int | hoge是指向int型的指针的数组(存放指针变量) |\n| int (\\*huge)[10]; | hoge is pointer to array[10] of int | hoge是指向int型的数组的指针 |\n| int func(int a); | func is function(int a) returning int | func是返回int型的函数 |\n| int (*func)(int a); | func is pointer to function(int a) returning int | func是指向返回int型值的函数的指针 |\n\n\n### 8.4 指针的应用\n#### 8.4.1 指针与数组\n- 一维  \n```C\np[i]\t// 等同于 *(p+i)\ni[p]\t// 等同于 *(i+p)\n&p[i]\t// 等同于 (p+i)，即第i个元素的地址\n```\n- 二维  \n```C\nhuge[i]\t\t// 等同于 *(huge+i)，即第i行的首地址\n*(huge+i)[j]\t// 等同于 *(*(p+j)+j)，即 huge[i][j]\n```\n\n#### 8.4.2 指针与字符串\n##### 8.4.2.1 字符指针变量\n- 定义\n\n\t```C\n\tchar *array = \"World\";\n\tarray = \"hello\";\t// 改变指向\n\t\t\n\tchar array[] = \"Hello\";\n\tarray = \"World\";\t// 错误的做法\n\t\n\tchar *array = \"Hello World\";\n\tarray += 6;\t\t// 改变指向 (首地址改变)\n \t```\n \n##### 8.4.2.2 字符数组\n- 定义: int array[] = \"Hello\";\n\n- 使用：printf(\"%c\", array[0]);\n> 字符指针变量的值是不能改变的，既已是字符串常量。\n\t```C\n\tchar *array = \"Hello\";\n\tarray[0] = 'W';\n\t```\n\n#### 8.4.3 指针与函数\n##### 8.4.3.1 作为参数\n即传递的是指向初始元素的指针。\n\n- 数组名作函数参数\n\t- int func( int array[] ); \n\t- int func( int \\*array );\n- 多维数组作函数参数\n\t- int func( int (\\*huge)[10] );\n\t- int func( int huge[2][4] );\n- 指向函数的指针作函数参数\n\t- int func( int (\\*p)(int) ); \n- 指针数组作main函数形参\n\t- int func( int argc, char \\*argv[] );   \n\t> argv: 文件名 + 其他参数\n- 字符指针作函数参数\n\n##### 8.4.3.2 作为返回值\n返回指针值的函数，即返回的是地址。\n> [如] 返回的指针指向结构体变量、字符变量等。\n\n\n## 9 玖 构造类型：用户自己建立数据结构\n### 9.1 结构体类型\n- 定义\n\n\t```C\n\tstruct Name {\n\t\tint num;\n\t\tchar word[59];\n\t} *p, name[5];\n\t```\n\n- 初始化：所有成员一起赋值。\n\n- 使用\n\n\t```C\n\tname[i].num;\n\tp->word[i];\n\t(*p).num;\n\t\n\tstruct Name *tmp;\n\ttmp = name;\n\t(tmp++)->num;\t// 先'++'操作，后'->'操作\n\t```\n\t\n- 大小：成员变量所占内存长度总和。\n\n### 9.2 共用体类型\n- 定义\n\n\t```C\n\tunion Name {\n\t\tint num;\n\t\tdouble digital;\n\t\tchar word;\n\t} *p, name[5];\n\t```\n\n- 初始化：只允许给一个成员变量赋值。\n\n\t```C\n\tunion Name tmp = {10};\n\tunion Name tmp = {.word = 'Y'};\n\tt.digital = 2.0;\n\tt.word = 'N';\t// 最终的赋值\n\t```\n\n- 使用\n\n\t```C\n\tname[i].num;\n\tp->word[i];\n\t(*p).num;\n\t```\n\t\n- 大小：成员变量所占内存长度最大者。\n\n> [注] 关于结构体、共用体类型的内存长度问题，遵循4字节倍数的原则进行内存布局对齐。  \n> [如]  \n> sizeof(struct Name) = 64 (63)  \n> sizeof(union Name) = 4 (4)\n\n### 9.3 枚举类型\n- 定义\n\t\n\t```C\n\tenum Week {\n\t\tsun, mon, tue, wed, thu, fir, sat // 默认参数从0开始\n\t} week;\n\t```\n\t\n- 初始化\n\n\t```C\n\tenum Week {\n\t\tmon = 1, tue = 2, wed = 3, thu = 4, fir = 5, sat = 6，sun = 7 // 默认参数从0开始\n\t} week;\n\t```\n\n- 使用：week.mon;\n\n### 9.4 Typedef 声明新类型名\n- 含义：引入变量别名，而不是另外地给变量分配空间。\n- 使用\n\t\n\t```C\n\ttypedef int Integer;\n\ttypedef long Integer;\t// 若编译器中，int为2字节，满足移值需求可以long型替换。\n\tInterger num = 1;\n\t```\n\n> 与 #define 宏定义的区别  \n> \\#typedef：编译阶段处理  \n> \\#define：预编译阶段处理，实质是字符串替换 \n\t\n## 10 拾 文件处理\n### 10.1 文件与流\n- stdin -- 标准输入流 -- 用于读取普通输入的流，在大多数环境中为键盘输入。scanf()与getchar()等函数会从这个流中读取字符。\n\n- stdout - 标准输入流 -- 用于写入普通输入的流，在大多数环境中为输出至显示器界面。printf()、puts()与putchar()等函数会向这个流写入字符。\n\n- stderr -- 标准错误流 -- 用于写出错误的流，在大多数环境中为输出至显示器界面。\n\n### 10.2 文件分类\n- ASCII文件 (文本文件)：每一字节存放一字符的ASCII代码。\n- 二进制文件\n\t- 优：节约存储空间\n\t- 劣：精度有限\n\n\t> [如] 整数10000  \n\t> ASCII形式存储空间为5字节   \n\t> 二进制形式存储空间为4字节  \n\t\n### 10.3 文件类型指针：FILE型\n- 需引用 `#include <stdio.h>`\n> [注] 指向文件的指针变量并不是指向外部介质上的数据文件开头，而是指向内存中的文件信息区的开头。\n\n### 10.4 打开文件\n- 原型：FILE \\*fopen(const char \\*filename, const char \\*mode);\n- 定义：FILE \\*fp = fopen(\"example.txt\", \"r\");\n\n| 文件类型 | 文本文件 | 二进制文件 |\n| :----: | :----: | :----: |\n| 模式 | r   w   a | rb   wb   ab |\n|  | 只读；只写(文件存在，则长度清零)；追加 | 只读；只写(文件存在，则长度清零)；追加 |\n|  | r+   w+   a+ | rb+   wb+   ab+ |\n|  | 读和写(打开文件)；读和写(建立文件；文件存在，则长度清零)；读和写(打开文件) | 读和写(打开文件；文件存在，则长度清零)；读和写(建立文件)；读和写(打开文件) |\n\n### 10.5 关闭文件\n- 原型：int fclose(FILE *stream);\n\n\t> * 返回值 ( True：0；False：EOF(-1) )  \n\t> * [注]  \n\t> 若不关闭文件，将会造成数据丢失。  \n\t> 数据存储的过程：数据 --> 缓存区 (充满) --> 文件\n\t> 若突然关闭文件，缓存区传输到文件的过程给中断，造成数据丢失。\n\n### 10.6 顺序读写数据文件\n- 格式化读取文件\n\n\t```C\n\tint fscanf(FILE *stream, const char *format, ...);\n\t// 返回值：\n\t// Ture - 返回成功赋值的输入项数\n\t// False - 返回文件结束标记EOF(-1)\n\t\n\t// 使用实例\n\tfscanf(fp, \"%s%lf%lf\", name, &height, &weight);\n\t```\n\t\n- 格式化写入文件\n\n\t```C\n\tint fprintf(FILE *stream, const char *format, ...);\n\t// 返回值：\n\t// Ture - 返回发送的字符数\n\t// False - 返回文件结束标记EOF(-1)\n\t\n\t// 使用实例：获得当前运行时间，并存入文本中\n\ttime_t current = time(NULL);\n\tstruct tm *timer = Localtime(&current);\n\t\n\t// 将日历时间time_t型的值转换为分解时间tm结构体类型的值\n\t// 其中，tm结构体为：\n\tstruct tm {\n\t\tint tm_sec;\t// 秒(0 - 61)\n\t\tint tm_min;\t// 分 (0 - 59)\n\t\tint tm_hour;\t// 时 (0 - 24)\n\t\tint tm_mday;\t// 日 (1 - 31)\n\t\tint tm_mon;\t// 月 (0 - 11)\n\t\tint tm_year;\t// 从1900至今，经历了多少年\n\t\tint tm_wday;\t// 星期 (0 - 6)\n\t\tint tm_yday;\t// 经历天数 (从1月1日计起)\n\t\tint tm_tm_isdst;\t// 夏时令 (夏季时间将提前1小时)\n\t};\n\t\n\tfprintf(fp, \"%d %d %d %d %d\", \n\t\ttimer->tm_year + 1900, timer->tm_mon + 1,\n\t\ttimer->tm_day, timer->tm_hour, \n\t\ttimer->tm_min, timer->tm_sec);\n\tfclose(fp);\n\t```\n\n- 读入／写入一个字符\n\n\t```C\n\tint fgetc(FILE *stream);\t// 读入一个字符\n\t\n\tint fputc(FILE *stream);\t// 写入一个字符\n\t// 返回值：\n\t// Ture - 返回所读的字符数\n\t// False - 返回文件结束标记EOF(-1)\n\t```\n\t\n- 用二进制方式向文件读写一组数据\n\n\t```C\n\tsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\n\t// 从ptr指向的数组中将最多nmemb个长度为size的元素写入stream指向的流中。\n\t\n\tsize_t fread(const void *ptr, size_t size, szie_t nmemb, FILE *stream);\n\t// 从stream流中读取nmemb个长度为size的元素写入到ptr数组。\n\t```\n\n### 10.7 随机读写数据文件\n#### 10.7.1 文件位置标记及其定位\n- 文件位置标记：文件头、读写当前位置、文件尾\n\n- 文件位置标记的定位：fseek(文件类型指针, 位移量, 起始点);\n> 文件开始位置 -> SEEK_SET -> 0  \n> 文件当前位置 -> SEEK_CUR -> 1  \n> 文件末尾位置 -> SEEK_END -> 2  \n\n#### 10.7.2 随机读写\n结合fseek()与fread()函数实现。\n> [如] 读取第1，3，5，7，9个学生数据并输出。\n\n```C\nfor(i = 0; i<10; i+=2){\n\tfseek(fp, i*sizeof(struct Student), 0);\n\tfread(&student[i], sizeof(struct Student), 1, fp);\n}\n```","tags":["考试"],"categories":["Reading"]}]