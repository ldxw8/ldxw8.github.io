<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KOFE&#39;S BLOG</title>
  
  <subtitle>Reading / Project / Research</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kofes.cn/"/>
  <updated>2018-07-08T07:45:44.373Z</updated>
  <id>http://www.kofes.cn/</id>
  
  <author>
    <name>Kofe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>论文 - 从商用车队的 GPS 数据中归类车辆停留意图信息</title>
    <link href="http://www.kofes.cn/2018/06/Stop-purpose-classification-from-GPS-data-of-commercial-vehicle-fleets.html"/>
    <id>http://www.kofes.cn/2018/06/Stop-purpose-classification-from-GPS-data-of-commercial-vehicle-fleets.html</id>
    <published>2018-06-11T16:58:25.000Z</published>
    <updated>2018-07-08T07:45:44.373Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p>原文：Stop purpose classification from GPS data of commercial vehicle fleets<br>作者：Sarti L, Bravi L, Sambo F.<br>来源：Data Mining Workshops, 2017 IEEE International Conference on. IEEE, 2017: 280-287.  </p></div><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>从原始 GPS (全球定位系统) 数据中提取 <code>汽车停靠意图数据</code> 是大多数位置感知应用程序中的关键任务，且随着从移动设备收集 GPS 数据的不断增长，这项任务变得越来越有趣。近期很多研究都集中在行人 (手机) 数据上 (可理解为红海市场)，而商用车领域几乎没有探索 (蓝海市场)。</p><p>在本论文中，针对车辆 GPS 数据的汽车停靠意图的 <code>识别</code> 和 <code>分类</code> 问题 (利用来自不同行业的商业车队的大型异构数据集)。按照意图分类，旨在把汽车停靠点分为：<code>工作相关</code> 和 <code>非工作相关</code>，以挖掘相关商业价值。</p><p>且还对每个汽车停靠点计算一组含 100 个不同特征的集合，特征可分为四个主要类别：<code>汽车停靠点特征</code>，<code>兴趣点特征</code>，<code>汽车停靠点集群特征</code> 和 <code>序列特征</code>。并通过随机森林分类模型，评估四组特征中每个特征对停靠点的相对重要性，以处理不同类型的问题。</p><p>实验结果表明，本论文的方法显着地超越了现有商业车辆背景下用于汽车停靠意图的分类模型。</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>在过去的十年中，GPS 设备的巨大推广，使得人们越发关注 <code>数据挖掘算法</code> 在 <code>时空数据</code> (GPS 产生的数据) 中的应用。而许多实际应用需要使用关于用户行为和地理位置的语义信息。例如，下述的两个实例：</p><ul><li>基于用户的历史位置以衡量用户之间的相似度 $^{[1]}$；</li><li>基于位置的兴趣地点推荐系统 $^{[2]}$。</li></ul><p>语义标记 GPS 数据，目标旨在 <code>识别</code> 和 <code>归类</code> GPS 沿途轨迹上的位置信息，即具体工作有 <code>语义位置的侦察</code> 和 <code>汽车停靠或出游的意图识别</code>。尽管上述问题不是同一类型的问题，但却是强相关的。例如，对多个用户而言具有相同意图的共同定位点，可能是语义上相关联的地方，因为知道某个地方的语义对分类每个汽车停靠点意图有很大的帮助。</p><p>通常，对于上述 <code>识别</code> 和 <code>归类</code> 问题的解决方法分两个阶段执行：</p><ul><li><p><code>侦查兴趣地点</code>：通常以非监督的方式实现位置侦查 $^{[3,4]}$，而作者提出了基于 <code>DBSCAN</code> $^{[5\,or\,6]}$ 的修改版本的聚类算法，即利用层次聚类从汽车停靠位置中提取访问点。</p><blockquote><p>当要处理非常大的数据集时需要考虑计算性能的问题，可参考其他论文中的扩展方法，例如对地点坐标进行哈希散列法 $^{[7,8]}$。</p></blockquote></li><li><p><code>对侦查到的地点分类</code>：对有关地点或汽车停靠点进行分类，可以在文献中找到两种主要方法：</p><ul><li>基于规则的系统 $^{[9,10]}$，其主要依赖于活动的位置、土地利用的数据以及机器学习方法，即活动本身提取特征；</li><li><p>利用 SVM 分类器来区分标识位置内的活动停靠点和非活动停靠点。分类器 (SVM，随机森林或逻辑回归) 利用时间和空间特征 $^{[6]}$，以及隐马尔可夫模型 (HMM) 利用时序特征把这些汽车停靠点分类为预定义类型。</p><blockquote><p>1) SVM 提取三个主要特征：停车驻留时间，每个汽车停靠地段周围的点到质心的平均距离。<br>2) 地点的语义分类是基于GPS数据和卫星图像的组合而定的 $^{[8]}$。  </p></blockquote></li></ul></li></ul><p>最后说明，本论文解决了与参考文献 [7] 的同样问题，即利用四个不同的特征集，使用一个随机森林分类器，对商业车队的汽车停靠意图数据进行分类。且本文的主要贡献如下：</p><ul><li>描述了一种方法，即从 GPS Pings (GPS 定位仪) 中提取汽车停靠点信息，并从工作状态停车点一览表 (已知的地点信息) 中給它们分配地面实况标签 (贴标签);</li><li>基于带标签的数据集，建立了一个模型，可以自动分类汽车停靠点，即工作状态和非工作状态的停靠点;</li><li>提供了严格评估的多类型特征集，便于我们处理不同问题，其中包括：<ul><li>汽车停靠点特征 (Stop-wise features，SWF)；</li><li>兴趣点特征 (Points of interest features，POIF)；</li><li>停靠点集群特征 (Stop Cluster，CF)；</li><li>序列特征 (Sequential features，SeqF).</li></ul></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="GPS和工单数据"><a href="#GPS和工单数据" class="headerlink" title="GPS和工单数据"></a>GPS和工单数据</h4><ul><li>本论文采用的数据集由 Fleetmatics 公司 (车队情报公司) 提供。</li><li>采集的数据有两种类型，分别是<code>原始 GPS pings 数据</code> 和 <code>工单数据</code>。<ul><li>原始 GPS Pings 数据<ul><li>提供有关车辆位置的信息，工单状态的信息，有关司机执行的工作进度及进度信息；</li><li>设定有一系列的 GPS Pings $\{P_i\}_{i=1}^n = \{P_1, …, P_n\}$ 分别描述每辆车行驶的路线。</li><li>每一个 GPS Ping $P_i$ 包含每辆车的状态信息，即有车辆 ID $v_i$，经度和纬度 (位置信息 $p_i$)，里程表 $d_i$，时间戳 $t_i$ 和 事件代码 $e_i$。</li></ul></li><li>工单数据<ul><li>设定有一系列的工单 $\{W_i\}_{i=1}^n = \{W_1, …, W_n\}$。</li><li>每一个工单包含的信息有：车辆 ID $v_i$，经度和纬度 (位置 $p_i$)，时间戳 $t_i$ 和 状态代码 $c_i$ (例如：挂起，启动，完成)。</li></ul></li></ul></li></ul><h4 id="车辆停靠侦查技术"><a href="#车辆停靠侦查技术" class="headerlink" title="车辆停靠侦查技术"></a>车辆停靠侦查技术</h4><p>正如上述所描述的，关于瞬时车辆位置的原始数据是由 GPS Ping 组成的，将它们汇集起来以描述车辆的活动。为此本论文开发了一个 <code>时空聚类程序</code>。</p><ul><li>首先得为每个 GPS 信息分配一种状态类型 (Engine off，iDling，Journey)，然后把它们聚集成 GPS Ping 群组，并把这个 GPS Ping 群组称为 <code>汽车停靠点集</code>。</li><li>GPS Ping 的状态可分为三种类型：<ul><li><code>Engine Off (发动机关闭状态)</code>：发动机关闭事件。即这些 Ping 在发动机关闭的瞬间产生的 (当发动机处于关闭状态时不发送 Ping);</li><li><code>iDling (空转/怠速状态)</code>：发动机处于开启状态，但车辆静止或车辆在小区域内仍然缓慢行驶。对于后者，我们还需要作一些约束，设定 $H(p_i,p_{i-1})$ 表示两点间的半正定距离。然后，对于给定车辆给予一对连续的 Ping $P_{i-1}\,and\,P_i$，且满足以下约束，则可定义为怠速：<ul><li>$s_i = H(p_i,p_{i-1})\,/\,(t_i - t_{i-1}) \leq 1.4\,m/s\,(5km/h)$，确定速度接近零；</li><li>$H(p_i,p_{i-1}) \leq 150\,m$，确保 $P_{i-1}\,and\,P_i$ 足够接近，且避免了由于丢失数据而产生的 <code>伪影</code>。</li></ul></li><li><code>Journey (行驶状态)</code>：即不是发动机关闭状态，也不是怠速状态。</li></ul></li><li>当 Ping 被分类后，以每辆车为单位，按时间顺序排序；并把所有连续的怠速状态和发动机关闭状态的 Ping 聚集成集群 (并不会被其中 Journey 状态的 Ping 給分割开来)。</li><li><p>由于丢失数据，导致一组连续的怠速状态 Ping 彼此相对较远地分布开来。故我们得重新执行 <code>时间-空间</code> 的约束条件 ($s_i \leq 1.4\,m/s$ and $H(p_i,p_{i-1}) \leq 150\,m$)。</p><blockquote><p>无法满足约束条件：即一组连续的怠速状态 Ping 将被分隔得很远，其中的 Journey 状态的 Ping 都给丢失了。 </p></blockquote></li><li><p>以这种方式创建的 <code>Pings 集群</code> 代表我们想要分类的 <code>已识别的汽车停靠点</code>。综上所述，汽车停靠点被定义为按时间顺序排序的 Ping  集群 (包含怠速状态或发动机关闭状态的 Ping，并且满足进一步的 <code>时间-空间</code> 得约束条件。</p></li><li>每个 <code>汽车停靠点</code> 都有几个特性 (通过计算其中的 Ping)：Ping 的数量，停靠点的起点和终点 (属于该停靠点的 Ping 的第一个和最后一个时间戳)，驻留时间 (属于该停靠点的起始时间和结束时间) 和形状 (由GPS消息的最大 (最小) 纬度/经度坐标定义)。</li><li>所有这些信息对于在第二阶段提取特征工作至关重要，即汽车停靠点意图的分类。</li></ul><h4 id="贴标签"><a href="#贴标签" class="headerlink" title="贴标签"></a>贴标签</h4><ul><li>首先，对上述程序中获得的汽车停靠点分配 <code>地面实况标签</code>；再者，将它们与 <code>工单数据</code> 进行匹配。一般来说，若车辆停留点在时间上和空间上与工单数据 $W_i$ 相匹配，则可认为该汽车停靠点即为某一工单数据。<ul><li>对于只包含 idling 和 engine off Pings 的停靠点，我们认为它满足空间上的匹配。</li><li>对于任何工单，空间上匹配了停留点；如果停留点的驻留时间与工单的时间项 (指示作业已启动的时间和指示服务已结束的时间) 间隔相交，时间的匹配也随着满足。</li></ul></li></ul><h4 id="分类特征"><a href="#分类特征" class="headerlink" title="分类特征"></a>分类特征</h4><p>在 <code>车辆停靠侦查技术</code> 章节中描述的，从一系列的 GPS Pings 提取汽车停靠点，并从中提取 100 个不同的特征用于训练随机森林模型，随之将这些特征划分为 4 个不同的组：</p><ul><li>汽车停靠点特征 ( Stop-wise features，SWF )：<ul><li>驻留时间：(汽车) 停靠点第一个和最后一个 Ping 的时间差。</li><li>开始时间特征：一天中的小时，一周中的某天，某月某日，某年某日。</li><li>关闭引擎所花费的时间：对于每一个引擎关闭事件，我们计算当前 Ping 与前一个非引擎关闭状态的 Ping 之间的时间差，以表示引擎启动的时间。由于每个停靠点包含多个引擎关闭状态的 Ping，我们需要使用几个聚合函数聚合取得结果。</li><li>形状：停靠点的宽度、高度、面积、比例。</li><li>停靠点类型：发动机关闭状态。</li><li>停靠点中发动机关闭状态 Ping 的数量。</li><li>里程表距离：从第一次 Ping 到最后一次 Ping。</li><li>停靠点内 Ping 的总数。</li><li>平均速度 (根据停留点中第一次和最后一次 Ping 之间的里程差除以驻留时间计算所得)。</li></ul></li><li>兴趣点特征 ( Points of interest features，POIF)：利用 <code>PTV xLocate Server</code> 中提取以下 POI 类型：<ul><li>银行;</li><li>大学;</li><li>酒店;</li><li>餐厅;</li><li>休息区;</li><li>杂货店;</li><li>学校;</li><li>购物中心;</li><li>汽油;</li><li>开放式停车场;</li></ul></li><li><p>汽车停靠点集群特征 ( Stop cluster features，CF )：其原理是存在一些工单数据和非工单数据趋向于聚类成簇，类似于 [7] 中提出的熵度量方法：对于每个停靠点，查看并收集 250 米半径内的周边环绕的停靠点数据。</p><ul><li><p>车辆熵，计算公式为：</p><script type="math/tex; mode=display">E_v = - \sum_{\nu \in V}   \frac{n_{\nu}}{N} ln(\frac{n_{\nu}}{N})  \tag{1}</script><blockquote><p>$V$ 是车队中的车辆集合， $N$ 是 250 米半径范围内车队所有车辆的总停留点数，$n_{\nu}$ 是车辆 $\nu$ 在同一区域停靠的总次数。这个熵度量给出了一个区域内同一车队车辆的多样性。</p></blockquote></li><li><p>簇中汽车停靠点的平均，总和，最大和最小驻留时间。</p></li><li>邻近汽车停靠点的数量 (在其质心250米半径以内)。</li></ul></li><li><p>序列特征 (Sequential features，SeqF).</p></li></ul><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul><li>在车辆停靠点侦查技术章节中，使用的是非监督方式的算法，即基于密度的 DBSCAN 聚类算法。其中涉及密度阈值的设定多少问题，就需要对具体样本量进行考究才能决定。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] Horozov T, Narasimhan N, Vasudevan V. Using location for personalized POI recommendations in mobile environments [C]//Applications and the internet, 2006. SAINT 2006. International symposium on. IEEE, 2006: 6 pp.-129.<br>[2] Jiang K, Yin H, Wang P, et al. Learning from contextual information of geo-tagged web photos to rank personalized tourism attractions [J]. Neurocomputing, 2013, 119: 17-25.<br>[3] Palma A T, Bogorny V, Kuijpers B, et al. A clustering-based approach for discovering interesting places in trajectories [C]//Proceedings of the 2008 ACM symposium on Applied computing. ACM, 2008: 863-868.<br>[4] Gong L, Sato H, Yamamoto T, et al. Identification of activity stop locations in GPS trajectories by density-based clustering method combined with support vector machines [J]. Journal of Modern Transportation, 2015, 23(3): 202-213.<br>[5] Ester M, Kriegel H P, Sander J, et al. A density-based algorithm for discovering clusters in large spatial databases with noise [C]//Kdd. 1996, 96(34): 226-231.<br>[6] Lv M, Chen L, Xu Z, et al. The discovery of personally semantic places based on trajectory data mining [J]. Neurocomputing, 2016, 173: 1142-1153.<br>[7] Gingerich K, Maoh H, Anderson W. Classifying the purpose of stopped truck events: An application of entropy to GPS data [J]. Transportation Research Part C: Emerging Technologies, 2016, 64: 17-27.<br>[8] Sambo F, Salti S, Bravi L, et al. Integration of GPS and satellite images for detection and classification of fleet hotspots [C]//Intelligent Transportation Systems (ITSC), 2017 IEEE 20th International Conference on. IEEE, 2017: 1-6.<br>[9] Wolf J, Guensler R, Bachman W. Elimination of the travel diary: Experiment to derive trip purpose from global positioning system travel data [J]. Transportation Research Record: Journal of the Transportation Research Board, 2001 (1768): 125-134.<br>[10] Bohte W, Maat K. Deriving and validating trip purposes and travel modes for multi-day GPS-based travel surveys: A large-scale application in the Netherlands [J]. Transportation Research Part C: Emerging Technologies, 2009, 17(3): 285-297.  </p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;原文：Stop purpose classification from GPS data of commercial vehicle fleets&lt;br&gt;作者：Sarti L, Bravi L, Sambo F.&lt;br&gt;来源：Data Mining Workshops, 2017 IEEE International Conference on. IEEE, 2017: 280-287.  &lt;/p&gt;&lt;/div&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;从原始 GPS (全球定位系统) 数据中提取 &lt;code&gt;汽车停靠意图数据&lt;/code&gt; 是大多数位置感知应用程序中的关键任务，且随着从移动设备收集 GPS 数据的不断增长，这项任务变得越来越有趣。近期很多研究都集中在行人 (手机) 数据上 (可理解为红海市场)，而商用车领域几乎没有探索 (蓝海市场)。&lt;/p&gt;
&lt;p&gt;在本论文中，针对车辆 GPS 数据的汽车停靠意图的 &lt;code&gt;识别&lt;/code&gt; 和 &lt;code&gt;分类&lt;/code&gt; 问题 (利用来自不同行业的商业车队的大型异构数据集)。按照意图分类，旨在把汽车停靠点分为：&lt;code&gt;工作相关&lt;/code&gt; 和 &lt;code&gt;非工作相关&lt;/code&gt;，以挖掘相关商业价值。&lt;/p&gt;
&lt;p&gt;且还对每个汽车停靠点计算一组含 100 个不同特征的集合，特征可分为四个主要类别：&lt;code&gt;汽车停靠点特征&lt;/code&gt;，&lt;code&gt;兴趣点特征&lt;/code&gt;，&lt;code&gt;汽车停靠点集群特征&lt;/code&gt; 和 &lt;code&gt;序列特征&lt;/code&gt;。并通过随机森林分类模型，评估四组特征中每个特征对停靠点的相对重要性，以处理不同类型的问题。&lt;/p&gt;
&lt;p&gt;实验结果表明，本论文的方法显着地超越了现有商业车辆背景下用于汽车停靠意图的分类模型。&lt;/p&gt;
    
    </summary>
    
      <category term="Paper" scheme="http://www.kofes.cn/categories/Paper/"/>
    
    
      <category term="数据挖掘" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="聚类" scheme="http://www.kofes.cn/tags/%E8%81%9A%E7%B1%BB/"/>
    
      <category term="机器学习" scheme="http://www.kofes.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="分类" scheme="http://www.kofes.cn/tags/%E5%88%86%E7%B1%BB/"/>
    
      <category term="特征提取" scheme="http://www.kofes.cn/tags/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>论文 - 通过非线性随机邻近嵌入自动分类细胞表达</title>
    <link href="http://www.kofes.cn/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding.html"/>
    <id>http://www.kofes.cn/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding.html</id>
    <published>2018-06-06T13:14:53.000Z</published>
    <updated>2018-06-11T16:57:11.760Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p>原文：Automatic classification of cellular expression by nonlinear stochastic embedding (ACCENSE)<br>作者：Karthik Shekhar, Petter Brodin, Mark M.Davis and Arup K.Chakraborty.<br>来源：Proceedings of the National Academy of Sciences (PNAS), 2014, 111(1): 202-207.  </p></div><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>质谱流式细胞技术 (Mass cytometry) 能够在单细胞水平上测试近 40 种不同的蛋白质，即提供前所未有的多维信息水平。由于各式各样的细胞种群数据集的复杂性，要收集有用的生物学知识对计算工具也有新的要求。回顾之前的聚类方法，即对于不同功能的细胞识别是基于细胞表征相似性来实现区分的。当然，经典方法存在一定局限性，例如单细胞分辨率的损失；经典方法需要预知簇中的对象数量 (本文中指细胞亚群的规模数量)。</p><a id="more"></a><p>则该论文引入 <code>ACCENSE</code> (Automatic classification of cellular expression by nonlinear stochastic embedding) 高维单细胞数据分析工具：</p><ul><li>基于密度划分的非线性降维方法，降维步骤采用 <code>t-Distributed Stochastic Neighbor Embedding (t-SNE)</code> 算法 $^{[1]}$。</li><li>探索性数据分析，同时避免任何手动 <code>阀门(阈值)</code> 的需要，即有别于基于距离的方法 (离群点判定)、基于密度的方法 (密度阈值)。</li><li>化繁为简，在二维或三维图上展示多元细胞的表型。</li></ul><p>再有，本论文将 ACCENSE 应用于 35 参数的质谱流式细胞技术，检测 CD8+ T 细胞的数量 (数据来自于特定的无病原和无菌小鼠)，并将细胞分层到表型亚群中。即对于具体的聚类算法、降维算法中，特定的符号名称会以具体的对象名称替代。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><ul><li><p>免疫系统包含了许多类型的细胞，它们在免疫应答过程中表现出多样化的功能和复杂方式的相互作用，即通过不同蛋白质的表达水平所定义，故个体细胞的功能与其细胞表型密切相关。这里启示我们，对于不同功能的细胞可通过细胞表型相似性进行聚类区分。</p></li><li><p>传统流式细胞技术和质谱流式细胞技术</p><ul><li><p>传统流式细胞技术 (Flow Cytometry) $^{[2]}$ 中，用 <code>荧光基因</code> 标记的抗体染色，其蛋白质靶标通过单细胞分辨率的光发射信号进行量化。</p><blockquote><p>由于有限的光谱和重叠的发射信号，每个细胞限制为 12-16 个参数。</p></blockquote></li><li><p>质谱流式细胞技术 (Mass Cytometry) $^{[3]}$ ，使用 <code>金属螯合探针</code> 可以对多达 42 个参数的单个细胞进行量化。</p></li><li><p>传统流式细胞技术和质谱流式细胞技术相比，主要有两点不同：  </p><ul><li>标签系统的不同，前者主要使用各种荧光基团作为抗体的标签，后者则使用各种金属元素作为标签；  </li><li>检测系统的不同，前者使用激光器和光电倍增管，而后者使用 ICP 质谱技术。 </li></ul></li></ul></li></ul><h3 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h3><p>由 <code>质谱流式细胞技术产生的高维数据</code>，以具有生物学意义的方式解释是具有挑战性的。然而，很多聚类工具是基于细胞的蛋白表达相似性进行细胞分类的，例如：</p><ul><li><code>SPADE 算法</code> $^{[4,5]}$：SPADE 使用多元信息定义细胞簇，并在树状结构中显示潜在的表型层次结构。但尚有不足之处：<ul><li>一是单细胞分辨率的损失；</li><li>二是对目标集群数量的需要预知。</li></ul></li></ul><h3 id="降维算法"><a href="#降维算法" class="headerlink" title="降维算法"></a>降维算法</h3><p>同样，降维算法以蛋白质表达相似性，把空间组织的细胞群在低维空间聚集成不同的细胞亚群。    </p><ul><li><code>PCA 算法</code>：PCA降维的大致思想就是，挑选特征明显的、显得比较重要的信息保留下来。在本论文中，Newell 等人将主成分分析 (Principal component analysis，PCA) 应用于 25 参数的质谱流式细胞技术，检测人的 CD8+ T 细胞的数量，且使用前三种主成分 (3D-PCA) 分离细胞亚群。3D-PCA 以三个汇总变量表示数据，每个汇总变量都是原始维度的线性组合，并去捕获投影后数据的方差，直至其取值为最大值。然而，PCA 能在数据中所有的可能线性组合中找到最优表达，但也存在限制条件：线性投影可能太严格而不能产生精确的表示 $^{[6]}$ ( 引入 t-SNE 算法 )。</li><li><p><code>t-SNE 算法</code> $^{[7]}$：t-Distributed Stochastic Neighbor Embedding，数据降维与可视化的方法，具体的算法细节如下：</p><ul><li>让 $\{x^{(i)}\}$ 表示归一化 n 维蛋白质表达向量编码的细胞 i 表型 (i=1, 2, …, M)。</li><li>若在 2D 平面图下，$\{y^{(i)}\}$ 向量表示高维 $\{x^{(i)}\}$ 对应于低维的映射，它使得具有相似表型的 T 细胞彼此靠近嵌入，表型不相似的则嵌入相对较远的距离。</li><li>采用细胞 i 和 j 之间的成对概率 $\{p_{i,j}\}$ 表示 $\{x^{(i)}\}$ 与 $\{x^{(j)}\}$ 之间的相似性。</li><li>若在 2D 平面图下，成对概率 $\{q_{i,j}\}$ 表示 $\{y^{(i)}\}$ 与 $\{y^{(j)}\}$ 之间的相似性。</li><li><p>通过最小化 $\{p_{i,j}\}$ 与 $\{q_{i,j}\}$ 的 KL 散度 (可理解为代价函数)，然后找出嵌入向量 $\{y^{(i)}\}$，即它让高维转低维的表示信息能最大程度被保存下来。</p><blockquote><p>KL 散度 (<a href="#1-t-SNE-中的概率">详细见附录 1</a>)，Kullback-Leibler Divergence，又称相对熵，即描述两概率分布 P 和 Q 的差异。KL 散度公式 (1) 如下：</p></blockquote><script type="math/tex; mode=display">D_{KL}(\{p_{i,j}\}|\{q_{i,j}\}) = \sum_{i,j} p_{i,j} log \frac{p_{i,j}}{q_{i,j}} \tag{1}</script></li><li><p>$\{y^{(i)}\}$ 可以编码非线性关系，不像 PCA 中被约束为 $\{x^{(i)}\}$ 的线性组合。</p></li><li><code>最佳嵌入</code> 是通过数值梯度下降法来确定的，即所有数据点的 KL 散度总和减小到最小 (<a href="#2-数值梯度下降法">详细见附录 2</a>)。</li></ul></li></ul><h3 id="识别细胞亚群"><a href="#识别细胞亚群" class="headerlink" title="识别细胞亚群"></a>识别细胞亚群</h3><ul><li><p>使用一个内核密度变换，从 t-SNE 的细胞散布图计算出一个复合图像 $K_\gamma(y)$：</p><script type="math/tex; mode=display">K_\gamma(y) = exp(  -\frac{||y - y'||^{2}}{2\gamma^2}  )\tag{2}</script></li><li><p>在本论文中，$K_\gamma(y)$ 的 <code>局部最大值</code> 表示具有共同表型的 CD8+ T 细胞亚群，且使用了 matlab 的峰值检测算法识别这些局部最大值。</p><blockquote><p>当然，也可以在嵌入点上使用 K-Means 聚类算法来识别 T 细胞子集，但其要求事先指定簇的数量。</p></blockquote></li><li><p>如何求得 <code>局部最大值</code>，关键是对于公式 (2) 中 $\gamma$ 的参数设定多少有关。即通过比较不同的核-宽带 $\gamma$ 产生的结果，则存在一个 $\gamma$ 值为表型空间中存在的局部和全局特征提供了准确的粗粒度表示。从图 1-2 中可得，即启示我们可以以数据驱动的方式，近似地识别 CD8+ T 细胞的亚群。</p></li></ul><h3 id="相关图表"><a href="#相关图表" class="headerlink" title="相关图表"></a>相关图表</h3><ul><li>如图 1-1 所示，ACCENSE 应用于质谱高维数据。</li></ul><p><img src="/images/illustration/Paper/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding_1-1.jpg" alt="图1-1ACCENSE ACCENSE 应用于质谱高维数据"></p><center>图 1-1 ACCENSE 应用于质谱高维数据</center><p>(A) 质谱细胞计数数据集样本的图示。行对应于不同的细胞，而列对应于测量其表达 (细胞表面抗原和细胞内蛋白) 的不同标记的金属螯合抗体。每一元组对应于指示每个标记的表达水平的质荷比变换值 (反双曲函数)。(C) 来自SPF B6 小鼠的 CD8+ T 细胞的 2D t-SNE 图谱。每个点代表来自训练集的一个细胞 (M = 18304)，且数据点是通过对原始数据集进行下采样得到。(D) 通过使用基于内核密度变换 ($K_{\gamma}(y)\,{,}\,\gamma = 7$)，将细胞的局部概率密度嵌入 (C) 的复合图像。并使用标准的峰值检测算法进行识别局部最大值，在二维密度图表示表型亚群的中心。</p><ul><li>如图 1-2 所示，展示了峰值随着 $\gamma$ 的增加而变化。</li></ul><p><img src="/images/illustration/Paper/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding_1-2.png" alt="图1-2展示了峰值随着γ的增加而变化"></p><center>图 1-2 展示了峰值随着 $\gamma$ 的增加而变化</center><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="1-t-SNE-中的概率"><a href="#1-t-SNE-中的概率" class="headerlink" title="1 t-SNE 中的概率"></a>1 t-SNE 中的概率</h3><h4 id="p-i-j-概率"><a href="#p-i-j-概率" class="headerlink" title="$p_{i,j}$ 概率"></a>$p_{i,j}$ 概率</h4><p>基于蛋白质相似性，设 $p_{j|i}$ (i,j = 1, 2, …, M) 表示细胞 i 将选择细胞 j 作为其最近邻的概率 ( $p_{j|i}$ 越大，$x^{(i)} 和 x^{(j)}$ 越近 )：</p><script type="math/tex; mode=display">p_{j|i} = \frac{    exp({-d_{i,j}^2} / {    2\sigma_i^2})}{     \sum_{k \neq i} exp({-d_{i,k}^2} / {    2\sigma_i^2})}, d_{i,j} = ||x^{(i)} - x^{(j)}||_2\tag{3}</script><p>对于概率 $p_{j|i}$ 的几点说明：</p><ul><li>$d_{i,j}$ 可以使用其他距离范式替代欧式距离范式；</li><li><p>原始的 SNE 算法是不对称的，为简化梯度公式，t-SNE 中让公式 (3) 的条件概率是对称的。即初始化 $p_{i|i} = 0$，对于任意的 $p_{i|j} = p_{j|i}$，可得：    </p><script type="math/tex; mode=display">p_{i,j} = \frac{  p_{j|i} + p_{i|j} }{2M} = \frac{  exp({-d_{i,j}^2} / {  2\sigma_i^2})}{   \sum_{k \neq i} exp({-d_{i,k}^2} / {  2\sigma_i^2})}\tag{4}</script></li><li><p>不同的点 $x_i$，带宽 $\sigma_i$ 的取值也是不同的。</p><ul><li>公式 (3) 中的带宽 $\sigma_i$ 是确保对于每一个细胞都有相同的复杂度 (Complexity)。复杂度可理解为一个点附近的 <code>有效近邻点个数</code>。</li><li>定义复杂度为 $P_i = 2^{H_{j|i}}$，其近似地解释为细胞 i 的最近邻点的数量。</li><li><p>定义 $p_{j|i}$ 的香农熵 (信息熵) 为 $H_{j|i} = - \sum_j p_{j|i} \log_2 p_{j|i}$，且 $H_{j|i}$ 随着 $\sigma_i$ 的增加而增加。</p><blockquote><p>在本论文中，t-SNE 图谱的复杂度被设定为 30，即 10-50 范围内的复杂度对最终结果的影响不大 (较好的鲁棒性)。</p></blockquote></li></ul></li></ul><h4 id="q-i-j-概率"><a href="#q-i-j-概率" class="headerlink" title="$q_{i,j}$ 概率"></a>$q_{i,j}$ 概率</h4><p>对于低维度下的 $\{y_i\}$，在原始的 SNE 算法 $^{[7]}$ 中 Hinton 和 Rowers 引用高斯核函数 (Gaussian Kernels) 定义 $q_{i,j}$，但在低维表达中发现了 <code>拥挤问题</code>。</p><blockquote><p><code>拥挤问题</code>：就是说各个簇聚集在一起，无法区分。譬如，有一高维度数据在降维到 10 维下可以有很好的表达，但是降维到两维后无法得到可信映射。具体情况是，10 维中有数个点之间两两等距离的，在二维下就无法得到可信的映射结果。<br>进一步说明，假设一个以数据点 $x^i$ 为中心，半径为 r 的 m 维球(三维空间就是球)，其体积是按 $r^m$ 增长的，假设数据点是在 m 维球中均匀分布的，我们来看看其他数据点与 $x^i$ 的距离随维度增大而产生的变化。</p></blockquote><p>t-SNE 减轻了拥挤问题，即使用更加偏重长尾分布的方式来将距离转换为概率分布 $^{[8]}$，故有 $q_{i,j}$：</p><script type="math/tex; mode=display">q_{i,j} = \frac{    (1 + \Delta_{i,j}^2)^{-1}}{     \sum_{k \neq i} (1 + \Delta_{i,k}^2)^{-1}}, \Delta_{i,j} = ||y^{(i)} - y^{(j)}||_2\tag{5}</script><p>同样地，对于概率 $q_{i,j}$ 的几点说明：</p><ul><li>$\Delta_{i,j}$ 可以使用其他距离范式替代欧式距离范式；</li><li>原始的 SNE 算法是不对称的，为简化梯度公式，t-SNE 中让公式 (5) 的条件概率是对称的。即初始化 $q_{i|i}=0$，对于任意的 $q_{i|j} = q_{j|i}$。</li></ul><h3 id="2-数值梯度下降法"><a href="#2-数值梯度下降法" class="headerlink" title="2 数值梯度下降法"></a>2 数值梯度下降法</h3><ul><li>在 [7] 中的概述过程，获得优化的梯度公式，如下所示:</li></ul><script type="math/tex; mode=display">\frac{    \partial D_{KL}(\{p_{i,j}\} | \{q_{i,j}\})}{    \partial_{y_t}^{(i)}} = 4 \sum_j \frac{        (p_{i,j} - q_{i,j})    }{        (1 + ||y_t^{(i)} - y_t^{(j)}||^2)    }    (y_t^{(i)} - y_t^{(j)})    \tag{6}</script><ul><li><p>通过梯度下降法迭代计算局部最大值：</p><script type="math/tex; mode=display">  y_{t+1}^{(i)} = y_{t}^{(i)} + \eta(t) \frac{      \partial D_{KL}(\{p_{i,j}\} | \{q_{i,j}\})  }{      \partial_{y_t}^{(i)}  }  + \alpha(t)(y_{t}^{(i)} - y_{t-1}^{(i)})  \tag{7}</script><ul><li>$y_t^{(i)}$ 表示迭代 t 次的解，$\eta(t)$ 表示学习速率，$\alpha(t)$ 表示迭代 t 次的动量。</li><li><p>学习速率初始值为 $\eta(t) = 100\,^{[9]}$，且动能量 $\alpha(t)$ 设定为：</p><script type="math/tex; mode=display">\alpha(t) = \begin{cases} 0.8, & t < 300 \\0.5, & t \geq 300 \end{cases}</script></li></ul></li></ul><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul><li>t-SNE 主要用于可视化，很难用于其他目的。譬如测试集合降维，因为他没有显式的预估部分，不能在测试集合直接降维。</li><li>关于核-带宽 $\gamma$ 参数设定问题：文中展示了 $\gamma$ 参数的大小与识别细胞亚群能力的数量关系。然而，数据驱动方式虽能实现自动聚类，但缺乏对于 $\gamma$ 参数设定范围该如何控制的说明。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] Maaten L, Hinton G. Visualizing data using t-SNE [J]. Journal of machine learning research, 2008, 9(Nov): 2579-2605.<br>[2] Cantor H, Simpson E, Sato V L, et al. And functional studies of peripheral t-cells binding different amounts of fluorescent anti-thy 1.2 (theta) Antibody using a fluorescence—activated cell sorter (FACS) [J]. 1975.<br>[3] Bendall S C, Nolan G P, Roederer M, et al. A deep profiler’s guide to cytometry [J]. Trends in immunology, 2012, 33(7): 323-332.<br>[4] Qiu P, Simonds E F, Bendall S C, et al. Extracting a cellular hierarchy from high-dimensional cytometry data with SPADE [J]. Nature biotechnology, 2011, 29(10): 886.<br>[5] Bendall S C, Simonds E F, Qiu P, et al. Single-cell mass cytometry of differential immune and drug responses across a human hematopoietic continuum [J]. Science, 2011, 332(6030): 687-696.<br>[6] Van Der Maaten L, Postma E, Van den Herik J. Dimensionality reduction: a comparative [J]. J Mach Learn Res, 2009, 10: 66-71.<br>[7] Maaten L, Hinton G. Visualizing data using t-SNE [J]. Journal of machine learning research, 2008, 9(Nov): 2579-2605.<br><a href="http://www.datakit.cn/blog/2017/02/05/t_sne_full.html" target="_blank" rel="noopener">[8] Chrispher. t-SNE 完整笔记 [OL]. www.datakit.cn. 2017.</a><br>[9] Jacobs R A. Increased rates of convergence through learning rate adaptation[J]. Neural networks, 1988, 1(4): 295-307.</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;原文：Automatic classification of cellular expression by nonlinear stochastic embedding (ACCENSE)&lt;br&gt;作者：Karthik Shekhar, Petter Brodin, Mark M.Davis and Arup K.Chakraborty.&lt;br&gt;来源：Proceedings of the National Academy of Sciences (PNAS), 2014, 111(1): 202-207.  &lt;/p&gt;&lt;/div&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;质谱流式细胞技术 (Mass cytometry) 能够在单细胞水平上测试近 40 种不同的蛋白质，即提供前所未有的多维信息水平。由于各式各样的细胞种群数据集的复杂性，要收集有用的生物学知识对计算工具也有新的要求。回顾之前的聚类方法，即对于不同功能的细胞识别是基于细胞表征相似性来实现区分的。当然，经典方法存在一定局限性，例如单细胞分辨率的损失；经典方法需要预知簇中的对象数量 (本文中指细胞亚群的规模数量)。&lt;/p&gt;
    
    </summary>
    
      <category term="Paper" scheme="http://www.kofes.cn/categories/Paper/"/>
    
    
      <category term="数据挖掘" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="聚类" scheme="http://www.kofes.cn/tags/%E8%81%9A%E7%B1%BB/"/>
    
      <category term="降维" scheme="http://www.kofes.cn/tags/%E9%99%8D%E7%BB%B4/"/>
    
      <category term="免疫表型" scheme="http://www.kofes.cn/tags/%E5%85%8D%E7%96%AB%E8%A1%A8%E5%9E%8B/"/>
    
      <category term="机器学习" scheme="http://www.kofes.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>论文 - 扩展 K-Means 算法：混合数据类型的聚类方法</title>
    <link href="http://www.kofes.cn/2018/06/Extensions-to-the-k-Means-algorithm-for-custering-large-datasets-with-categorical-values.html"/>
    <id>http://www.kofes.cn/2018/06/Extensions-to-the-k-Means-algorithm-for-custering-large-datasets-with-categorical-values.html</id>
    <published>2018-06-03T12:47:42.000Z</published>
    <updated>2018-06-20T17:00:13.982Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p>原文：Extensions to the k-means algorithm for clustering large datasets with categorical values<br>作者：ZHEXUE HUANG.<br>来源：Data mining and knowledge discovery, 1998, 2(3): 283-304.  </p></div><ul><li>更新进度：<ul><li>2018.06.04: 整理原文，完成初稿；</li><li>2018.06.05: 更新第 3 / 6 章；</li></ul></li></ul><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在早期，大多数聚类工作主要集中在数值数据上，且它们主要是利用数值数据的固有几何特性，即数据点之间的 <code>距离函数</code> (<a href="#1-距离函数">见附录1</a>)。但是，数据挖掘应用程序通常涉及许多数据集，这些数据集是由混合数值属性和标称属性组成的，仅拥有数值数据的测量方法已无法满足混合数据类型的聚类工作。</p><p>本论文基于经典的 K-Means 算法上，提出了两种聚类算法，分别应对 <code>标称域</code> 和 <code>混合数值与标称域</code> 属性值的聚类操作。首先介绍的是<code>K-Modes (K-众数)</code> 聚类算法，他运作的方式与 K-Means 相仿，只是它利用的是相异性度量处理标称对象，聚类中心以众数替代均值，且众数以基于频率的方法去迭代更新，直至 <code>聚类代价函数</code> 的结果最小化停止迭代。其次，是 <code>K-Prototype</code> 聚类算法，它定义了一组合的相异性度量值，进一步整合 <code>K-Means</code> 和 <code>K-Modes</code> 算法，以实现对混合数值与标称属性的对象进行聚类操作。</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>将数据库中的一组对象划分为同构组或集群是数据挖掘中最基本的操作。而讨论划分操作，自然离不开聚类。聚类是把每一组对象划分为一个簇，且同一簇中对象之间相似，而不同簇之间的对象相异。</p><p>数据挖掘最显著的特征是处理复杂的大型数据集。特别地，数据集包含数以百万计由不同类型属性或变量描述的对象，由此数据挖掘操作和算法应充分考虑可扩展性，以应付处理不同类型的属性。</p><p>在本论文中，提出的两个新聚类算法，即利用 <code>K-Means 范式</code> 对拥有标称属性的数据进行聚类。<code>K-Modes (K-众数)</code> 聚类算法，他运作的方式与 K-Means 相仿，只是它利用的是相异性度量处理标称对象，聚类中心以众数替代均值，且众数以基于频率的方法去迭代更新，直至 <code>聚类代价函数</code> 的结果最小化停止迭代。其次，是 <code>K-Prototype</code> 聚类算法，它定义了一组合的相异性度量值 $s^r + \gamma s^c$，以实现对混合数值与标称属性的对象进行聚类操作。其中，$s^r$ 是由 <code>平方欧式距离</code> 定义的 <code>数值属性</code> 的相异性度量值，$s^c$ 是由 <code>两个对象间类别不匹配的数量</code> 定义的 <code>标称属性</code> 的相异性度量值，$\gamma$ 是平衡数值属性和标称属性两部分的的权值，以避免偏向于某一属性。若聚类的效果更青睐于数值属性，则可以设定一个较小的 $\gamma$ 值；反之，设定一较大的 $\gamma$ 值。</p><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><ul><li>假设需要聚类的对象数据集储存在数据集 D 中。<ul><li>集合的属性 $A_1, A_2, … , A_m$ 分别是值域 $D_1, D_2, … , D_m$ 的描述。</li><li>在 D 中的每个对象由元组 t 表示，$t \in D_1 \times D_2 \times … \times D_m$。</li></ul></li><li>针对本文讨论的聚类问题，仅考虑两种常见数据类型：数值类型和标称类型。<ul><li>数值域的取值范围是实数域。</li><li>在多维的密度空间中，每一个数值型的数据点都采用诸如欧式或马氏的距离度量方法。</li><li>若值域 $D_i$ 被定义为有限、无序的标称域，则对象的比较操作只允许在 $D_i$ 中执行，即有 $a, b \in D_i$，either a = b or $a \neq b$。</li></ul></li><li><p>对于数据集中的每一数据对象 $X$，也可由 <code>属性-属性值</code> 的键值对表示，</p><script type="math/tex; mode=display">[A_1=x_1] \bigwedge [A_2=x_2] \bigwedge ... \bigwedge [A_m=x_m]</script></li><li><p>即当 $x_i \in D_i$，for i = 1, 2, …, m。为简单起见，这里以 $X$ 表示元组：</p><script type="math/tex; mode=display">[x_1^r, x_2^r, ...,x_p^r, x_{p+1}^c, ..., x_m^c] \in D_1 \times D_2 \times ... \times D_m</script><blockquote><p>第一个元素 p 为数值对象，其余的都是标称对象。当然，若元组中仅有一种数据类型，可表示为 $[x_1, x_2, …, x_m]$。</p></blockquote></li></ul><h3 id="K-Means-算法"><a href="#K-Means-算法" class="headerlink" title="K-Means 算法"></a>K-Means 算法</h3><ul><li>K-Means，是一种划分或非分层的聚类算法，为进一步阐述细节，需给出如下设定：<ul><li>一组含 $n$ 个数值数据的对象集 $D = \{X_1, X_2, …, X_n\}$；</li><li>距离度量 $d$；</li><li>自然数 $k (\leq n)$，并把 $D$ 划分 $k$ 个非空且相分离的簇群 $C_1, C_2, …, C_k, \, with \, C_i \bigcap C_j = \emptyset \, and \, \bigcup_{i=1}^k C_i = D$。</li></ul></li><li><p>如此一来，使得数据对象与其簇的中心之间的平方误差总和被最小化。然后，根据非线性优化问题，将该问题描述为:</p><script type="math/tex; mode=display">  Minimise P(W,Q) = \sum_{l=1}^k \sum_{i=1}^n w_{i,l} d(X_i, Q_l)  \tag{1}</script><p>  且服从：</p><script type="math/tex; mode=display">  \begin{cases}  \sum_{l=1}^k w_{i,l} = 1, \, i = 1, 2, ..., n   \\ w_{i,l} \in \{0,1\}, \, i = 1, 2, ..., n; l = 1, 2, ..., k  \end{cases}  \tag{2}</script><ul><li>$w_{i,l}$ 指标变量表示对象 $X_i$ 仅属于哪一个簇。即取值为 1 时，表示对象 $X_i $ 在 簇 $C_l$ 中；反之，取值为 0。</li><li><p>$W = \left[ w_{i,l} \right]_{n \times k}$ 是分块矩阵 (见公式 3)，$Q = \{Q_1, Q_2, …, Q_K\}$ 是簇的中心集合，$d(·,·)$ 是两对象间的平方欧式距离 (<a href="#1-距离函数">见附录1</a>)。</p><script type="math/tex; mode=display">W = \left[ w_{i,l} \right]_{n \times k} = \begin{bmatrix} w_{11} & \cdots & w_{1l} & \cdots & w_{1k} \\ \vdots & & \vdots & & \vdots \\w_{i1} & \cdots & w_{il} & \cdots & w_{ik} \\\vdots & & \vdots & & \vdots \\w_{n1} & \cdots & w_{nl} & \cdots & w_{nk} \\ \end{bmatrix}\tag{3}</script></li></ul></li><li><p>紧接着，在约束条件 (2) 下对 (1) 中的 P 进行优化，即对 Q 和 W 进行局部优化。首先，我们先固定 Q 并找出必要条件 W 使 P 最小化。然后，根据 Q 去修正 W 并最小化 P。基于上述几点，若为了达到 P 最小化，K-Means 算法通过 <code>三步迭代</code>，直到 P(W, Q) <code>收敛</code> 到某个 <code>局部最小值</code>。</p><ul><li><code>Step.01</code>： 初始化 $Q^{(0)} = \{Q_1^{(0)}, Q_2^{(0)}, …, Q_k^{(0)}\}$，且设立 $t = 0$。</li><li><code>Step.02</code>：固定 $Q^{(t)}$ 不变，求解 $P(W, Q^{(t)})$ 再去获得 W，即以 Q 作为簇群的中心，将每个对象分配到距离其最近的簇中心的簇群当中。</li><li><p><code>Step.03</code>：固定 $W^{(t)}$  不变，生成 $Q^{(t+1)}$，求解 $P(W^{(t)}, Q^{(t+1)})$。比较 $P(W, Q^{(t)}) \, and \, P(W^{(t)}, Q^{(t+1)})$，若后者为最小化，则根据当前的对象部分构造新的簇群中心。</p><ul><li><p>$Q_t^{t+1} = \{q_{l,1}^{(t+1)}, …, q_{l,m}^{(t+1)}\}, \, for \, l = 1, 2, …, k$，且：</p><script type="math/tex; mode=display">q_{l,j}^{(t+1)} = \frac {  \sum_{i=1}^n w_{i,l}^{(t)} x_{i,j}}{  \sum_{i=1}^n w_{i,l}^{(t)}}, \, j = 1, 2, ..., m\tag{4}</script></li></ul></li><li><p><code>Step.04</code>：当满足收敛或给定的停止条件时 ( <code>局部最优化</code> )，输出结果并停止；反之，令 $t = t + 1$，并继续从 <code>Step.02</code> 开始执行。</p></li></ul></li><li>为了解决 <code>簇间边界不明确</code> 的问题，模糊分区的概念成功地应用到聚类问题中，即模糊聚类 $^{[2,3]}$。但是，我们在本论文中不考虑这个问题。</li><li>综上所述，K-Means 算法具有以下特征：<ul><li>局部最优化为算法结束的终止条件；</li><li>仅适用于数值属性数据的聚类；</li><li>簇群的特征为球形簇.</li></ul></li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="1-距离函数"><a href="#1-距离函数" class="headerlink" title="1 距离函数"></a>1 距离函数</h3><p><code>距离函数</code>：关于数据点之间的距离函数，即数值属性刻画的对象相异性的距离度量。度量方法 $^{[1]}$ 包括闵可夫斯基距离 (闵氏距离)、欧几里得距离 (欧式距离) 和曼哈顿距离。</p><p>令 $i=(x_{i1},x_{i2},…,x_{ih})$ 和 $j=(x_{j1},x_{j2},…,x_{jh})$ 是两个被 h 个属性描述的对象。 </p><p>闵氏距离是欧式距离和曼哈顿距离的推广，定义如下：</p><script type="math/tex; mode=display">d(i, j) = \sqrt[h](    \sum_{f=1}^h |x_{if}-x_{jf}|^{h}),h \geq 1\tag{1}</script><ul><li>当 h = 1 时，它表示 <code>曼哈顿距离</code>，也称 <code>城市块</code> 距离 (城市两点之间的街区距离，如向南 2 个街区，横过 3 个街区，共计五个街区)，其定义如下：</li></ul><script type="math/tex; mode=display">d(i, j) = \sum_{f=1}^h |x_{if}-x_{jf}|,h \geq 1\tag{2}</script><ul><li>当 h = 2 时，它表示 <code>欧式距离</code>，也称 <code>直线或乌鸦飞行</code> 距离，其定义如下：</li></ul><script type="math/tex; mode=display">d(i, j) = \sqrt(\sum_{f=1}^h (x_{if}-x_{jf})^2),h \geq 1\tag{3}</script><ul><li>当 h = $\infty$ 时，它表示 <code>上确界距离</code>，又称 <code>切比雪夫距离</code>，其定义如下L：</li></ul><script type="math/tex; mode=display">d(i, j) = \lim_{h \to \infty} (    \sum_{f=1}^h |x_{if}-x_{jf}|^h)^\frac{1}{h} = max_{f}^h |x_{if}-x_{jf}|\tag{4}</script><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] Jiewei Han, Micheline Kamber and Jian Pei. 数据挖掘 (第三版) [M]. 机械工业出版社, 2018, 48-49.<br>[2] Bezdek J C. A convergence theorem for the fuzzy ISODATA clustering algorithms [J]. IEEE transactions on pattern analysis and machine intelligence, 1980 (1): 1-8.<br>[3] Ismail M A, Selim S Z. Fuzzy c-means: optimality of solutions and effective termination of the algorithm[J]. Pattern recognition, 1986, 19(6): 481-485.</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;原文：Extensions to the k-means algorithm for clustering large datasets with categorical values&lt;br&gt;作者：ZHEXUE HUANG.&lt;br&gt;来源：Data mining and knowledge discovery, 1998, 2(3): 283-304.  &lt;/p&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;更新进度：&lt;ul&gt;
&lt;li&gt;2018.06.04: 整理原文，完成初稿；&lt;/li&gt;
&lt;li&gt;2018.06.05: 更新第 3 / 6 章；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;在早期，大多数聚类工作主要集中在数值数据上，且它们主要是利用数值数据的固有几何特性，即数据点之间的 &lt;code&gt;距离函数&lt;/code&gt; (&lt;a href=&quot;#1-距离函数&quot;&gt;见附录1&lt;/a&gt;)。但是，数据挖掘应用程序通常涉及许多数据集，这些数据集是由混合数值属性和标称属性组成的，仅拥有数值数据的测量方法已无法满足混合数据类型的聚类工作。&lt;/p&gt;
&lt;p&gt;本论文基于经典的 K-Means 算法上，提出了两种聚类算法，分别应对 &lt;code&gt;标称域&lt;/code&gt; 和 &lt;code&gt;混合数值与标称域&lt;/code&gt; 属性值的聚类操作。首先介绍的是&lt;code&gt;K-Modes (K-众数)&lt;/code&gt; 聚类算法，他运作的方式与 K-Means 相仿，只是它利用的是相异性度量处理标称对象，聚类中心以众数替代均值，且众数以基于频率的方法去迭代更新，直至 &lt;code&gt;聚类代价函数&lt;/code&gt; 的结果最小化停止迭代。其次，是 &lt;code&gt;K-Prototype&lt;/code&gt; 聚类算法，它定义了一组合的相异性度量值，进一步整合 &lt;code&gt;K-Means&lt;/code&gt; 和 &lt;code&gt;K-Modes&lt;/code&gt; 算法，以实现对混合数值与标称属性的对象进行聚类操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Paper" scheme="http://www.kofes.cn/categories/Paper/"/>
    
    
      <category term="数据挖掘" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="聚类" scheme="http://www.kofes.cn/tags/%E8%81%9A%E7%B1%BB/"/>
    
      <category term="机器学习" scheme="http://www.kofes.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="混合类型" scheme="http://www.kofes.cn/tags/%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="K-Means" scheme="http://www.kofes.cn/tags/K-Means/"/>
    
  </entry>
  
  <entry>
    <title>论文 - 通过快速查找和发现密度峰值进行聚类</title>
    <link href="http://www.kofes.cn/2018/05/Clustering-by-fast-search-and-find-of-density-peaks.html"/>
    <id>http://www.kofes.cn/2018/05/Clustering-by-fast-search-and-find-of-density-peaks.html</id>
    <published>2018-05-27T01:43:41.000Z</published>
    <updated>2018-06-08T17:06:36.668Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p>原文：Clustering by fast search and find of density peaks<br>作者：Alex Rodriguez and Alessandro Laio<br>来源：Science 344.6191(2014), 1492-1496.</p></div><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>聚类分析的目的在于根据元素的相似性将元素分类。而该论文基于这样一种观点的提出新的方法，即聚类中心的密度高于其邻居，而密度高的点相对较远。这个想法构成了聚类过程的基础，其中簇的数量直观地产生，异常值被自动地发现并从分析中排除，并且聚类被识别，而不管它们的形状和嵌入它们的空间的维度如何。</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="不同的聚类策略"><a href="#不同的聚类策略" class="headerlink" title="不同的聚类策略"></a>不同的聚类策略</h3><h4 id="基于距离的方法"><a href="#基于距离的方法" class="headerlink" title="基于距离的方法"></a>基于距离的方法</h4><p>在 <code>K-means</code> 和 <code>K-medoids</code>，聚类是以距离聚类中心很小的距离为特征的数据集合。</p><p>然而，因为数据点总是被分配到最近的中心，所以该类算法只能发现球形的簇，而在发现任意形状的簇时会遇到困难。</p><blockquote><p>提示：<code>K-均值 (K-Means)</code> 的方法仅当簇中均值有定义时才有意义，而当涉及具有标称属性的数据时，K-均值的方法失效。而这里可采用 <code>K-众数 (K-Modes)</code> 的变体，即采用 <code>基于频率</code> 的方法来更新簇的众数，对具有标称属性的数据进行聚类。当然，还有 <code>K-Prototype</code> $^{[1,2]}$、<code>K-Means++</code> $^{[3]}$ 等优化版本的算法。</p></blockquote><h4 id="基于密度的方法"><a href="#基于密度的方法" class="headerlink" title="基于密度的方法"></a>基于密度的方法</h4><p>通过基于数据点局部密度的方法很容易检测具有任意形状的簇。其主要思想是：在某领域 (对象或数据点的数目) 内，给定密度阈值，将密度低于该阈值的数据点视为噪声丢弃，并将其分配给不连续的高密度领域的其他簇。这样的方法可用来过滤噪声或离群点，发现任意形状的簇。</p><p><code>DBSCAN</code> (Density-Based Spatial Clustering of Applications with Noise) 是一个基于密度的聚类算法，它将簇定义为密度相连的点的最大集合，能够把具有足够高密度的领域划分为簇。在噪声的空间数据库中可发现任意形状的聚类。</p><p>然而，从上述当中可知，除了要选择合适的阈值，且它缺少均值漂移的聚类方法。虽然这种方法允许发现非球形簇，但仅适用于由一组坐标定义的数据。</p><h4 id="本文改进的方法"><a href="#本文改进的方法" class="headerlink" title="本文改进的方法"></a>本文改进的方法</h4><p>首先，该算法提出假设：类簇中心被具有较低局部密度的 <code>邻居点</code> 包围，且与具有较高密度的 <code>任何点</code> 有相对较大的距离。对于每一个数据点 i，要计算 <code>两个量</code>：点的局部密度 $\rho_i$ 和该点到具有更高局部密度的点的距离 $\delta_i$。而这两个值都取决于数据点间的距离 ${d}_{ij}$ (欧几里得距离，也称 <code>欧式距离</code>)。数据点的局部密度定义为：</p><script type="math/tex; mode=display">\rho_i = \sum_j \chi(d_{ij} - d_c)</script><p>其中 $\chi(x)$ 为 0-1 函数，如果 x &lt; 0，那么 $\chi(x) = 1$；否则 $\chi(x) = 0$，$d_{c}$ 是一个 <code>截断距离</code>。基本上，$\rho_i$ 等于与点 i 的距离小于 $d_{c}$ 的点的个数。算法只对不同点 $\rho_i$ 的相对大小敏感，这意味着对于大数据集，分析结果在 $d_{c}$ 的选择方面具有很好 <code>鲁棒性</code>。</p><ul><li><p>$\delta_i$ 是通过计算点之间的 <code>最小距离</code> 来测量的，即数据点 i 与距离它最近的、密度更高的点 j 的距离最小值式：</p><blockquote><p>提示：在图 1-1.(A) 中可知，数据点是按照密度降序排列。</p></blockquote></li></ul><script type="math/tex; mode=display">\delta_i = min_{j:\rho_j>\rho_i}(d_{ij})</script><ul><li>若数据点 i 是密度最大的点，$\delta_i$ 为所有节点中到数据点 i 的最大距离：</li></ul><script type="math/tex; mode=display">\delta_i = max_j(d_{ij})</script><p>如图 1-1 所示，其展示了算法的核心思想。图 1-1.(A) 展示了二维空间中的 28 个点，<code>且 A 中数据点是按照密度降序排列</code>。图 1-1.(B) 中以 $\rho_i$ 作为横坐标，$\delta_i$ 作为纵坐标，画二维图，并称其为决策图。可以发现点 1 和点 10 的  $\rho_i$ 和 $\delta_i$ 最大，故将其作为类簇中心。</p><blockquote><p>点 9 和点 10 的 $\rho_i$ 相似，但 $\delta_i$ 值却有很大差别：点 9 属于点 1 的类簇，且有其它几个更高 $\rho_i$ 的点距其很近，然而点 10 拥有更高密度的最近邻属于其它的类簇。  </p><p>所以，正如预期的那样，只有具有高 $\delta_i$ 和相对较高 $\rho_i$ 的的点才是 <code>类簇中心</code>。因为点 26、27、28 是孤立的，所以有相对较高的 $\delta_i$ 值和低 $\rho_i$ 值，它们可以被看作是由单个点做成的类簇，也就是 <code>异常点</code>。</p></blockquote><p><img src="/images/illustration/Paper/2018/05/Clustering-by-fast-search-and-find-of-density-peaks_1-1.jpg" alt="图1-1算法在二维空间的展示"></p><center>图 1-1 算法在二维空间的展示</center><p>类簇中心找到后，剩余的每个点被归属到它的有更高密度的最近邻所属类簇。类簇分配只需 <code>一步即可完成</code>，不像其它算法要对目标函数进行 <code>迭代优化</code>。</p><p>在聚类分析中，定量的衡量分配的可信度是很重要的。在该算法中，首先为每个类簇定义一个 <code>边界区域</code> (即分配到该类簇的点集合，且与其它类簇的点的距离小于 $d_c$)，然后为每个类簇的找到其边界区域中密度最高的点 $\rho_b$，并以来表示该点的密度。若类簇中局部密度值比 $\rho_b$ 大的点被看作是类簇的核心部分 (即分配到该类簇的可靠性较高)，其他点 (类簇中局部密度值比 $\rho_b$ 小的点) 被看作是类簇的 <code>光晕部分</code> (亦可被看作是噪声)。</p><p><img src="/images/illustration/Paper/2018/05/Clustering-by-fast-search-and-find-of-density-peaks_1-2.jpg" alt="图1-2合成点分布的结果"></p><center>图 1-2 合成点分布的结果</center><p>(A) 为绘制点分布的概率分布。(B和C) 分分别为 4000 和 1000 样本点的点分布。且每个点以其颜色表示所属类簇，黑色点属于光晕类簇 (噪声点)。(D和E) 为 (B和C) 相应的决策图，其中心由相应簇来着色。(F) 作为样本维度的函数，分配给不正确聚类的点的分数。误差线表示平均值的标准误差。</p><p>从图 1-2.(F) 中可以看到，错分点的比例即使在只有 1000 个点的小样本中仍保持在 1% 以下，说明算法有很好的鲁棒性。</p><p>从图 1-3 中可以看到，该算法对于各种数据级都能达到很好的聚类效果 (图中为引用文献中的测试用例结果)。</p><p><img src="/images/illustration/Paper/2018/05/Clustering-by-fast-search-and-find-of-density-peaks_1-3.jpg" alt="图1-3引用文献中的测试用例结果"></p><center>图 1-3 引用文献中的测试用例结果</center><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>摘要部分提到的，异常点能 <code>自动地</code> 被分析出来，但从它的 Matlab 源码可知，还是需要人为判断异常点 (与问题三结合思考)？</li><li>文中提到的截断距离 $d_c$，该设定多少才算较合理？</li><li>文中判断簇中心的两个参数量 $\delta_i$ 和 $\rho_i$，即同时具有相对较高的距离和局部密度可选为簇中心，那么如何定义相对较高的具体值？</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] Huang Z. Clustering large data sets with mixed numeric and categorical values [C]. 1997: 21-34.<br>[2] Huang Z. Extensions to the k-means algorithm for clustering large data sets with categorical values [J]. Data mining and knowledge discovery, 1998, 2(3): 283-304.<br>[3] San O M, Huynh V N, Nakamori Y. A clustering algorithm for mixed numeric and categorical data [J]. Journal of Systems Science and Complexity, 2003, 16(4): 562-571.  </p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;原文：Clustering by fast search and find of density peaks&lt;br&gt;作者：Alex Rodriguez and Alessandro Laio&lt;br&gt;来源：Science 344.6191(2014), 1492-1496.&lt;/p&gt;&lt;/div&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;聚类分析的目的在于根据元素的相似性将元素分类。而该论文基于这样一种观点的提出新的方法，即聚类中心的密度高于其邻居，而密度高的点相对较远。这个想法构成了聚类过程的基础，其中簇的数量直观地产生，异常值被自动地发现并从分析中排除，并且聚类被识别，而不管它们的形状和嵌入它们的空间的维度如何。&lt;/p&gt;
    
    </summary>
    
      <category term="Paper" scheme="http://www.kofes.cn/categories/Paper/"/>
    
    
      <category term="数据挖掘" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="聚类" scheme="http://www.kofes.cn/tags/%E8%81%9A%E7%B1%BB/"/>
    
      <category term="机器学习" scheme="http://www.kofes.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>笔记 - 高级软件工程 &amp; 导论</title>
    <link href="http://www.kofes.cn/2018/05/Sofeware-Engineering.html"/>
    <id>http://www.kofes.cn/2018/05/Sofeware-Engineering.html</id>
    <published>2018-05-02T11:45:02.000Z</published>
    <updated>2018-05-19T12:31:23.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在软工系列课程上，老师常提及的一条等式  <code>软件 = 程序 + 软件工程</code> ( 或 <code>软件 = 程序 + 文档</code>)，即一般情况讨论，一款软件产品的诞生之际总是伴随着一系列的软件过程。</p><p>那么如何充分理解软件工程 (过程)？从本书作者理念出发，我所理解的即应该时刻对软件产品持有 <code>生命周期</code> 的思维模式，将 <code>需求、建模、设计、实现、测试、维护</code> 等工程阶段联系起来，以自身代入案例环境中，去模拟开展软件过程的一系列活动，而非割裂。而这样的动态过程中，不仅仅是枯燥地学习理论、方法，则更像是问题所需、问题导向的理论应用过程。</p><p>当然，软件工程作为一门工程学科，学习过程的最大收获可以说是对 <code>项目思维模式</code> 的掌握。譬如，我们可以抛开软件产品的范畴，谈谈现实生活的实例：假若你需要在一定时限内掌握一门新知识、任务，则我们的做法可以从调研、计划、布局、实施，直至验收，即类似的过程可复用软件工程的方法。</p><p>最后，也是想声明的一点：学习软件工程的过程中，无可避免地将反映本人的一些观点、倾向，当然这也反映该学科需要 <code>多沟通</code> 的特点，若有不恰当、错误之处，欢迎大伙出建议、斧正。</p><a id="more"></a><ul><li><p>参考书目：</p><ul><li>《 软件工程 》. Ian Sommerville 著：计算机科学丛书，且是著名软件工程学家 Ian Sommerille 系统介绍软件工程理论的经典教材。</li><li>《 构建之法(第二版) 》: 待整理。贴上本书豆瓣的书评，供朋友评判，做出抉择。<a href="https://book.douban.com/subject/26577755/" target="_blank" rel="noopener">构建之法(第二版)</a> </li></ul></li><li><p>更新进程</p><ul><li>2018.05.02 - 完成初稿；</li><li>2018.05.04 - 更新正文：导论部分  (第 4 / 8 章)；</li></ul></li></ul><h2 id="零-总览"><a href="#零-总览" class="headerlink" title="零 总览"></a>零 总览</h2><ul><li>软件工程导论<ul><li><a href="#壹-软件过程">壹 软件过程</a></li><li><a href="#贰-敏捷软件开发">贰 敏捷软件开发</a></li><li><a href="#叁-需求工程">叁 需求工程</a></li><li><a href="#肆-系统建模">肆 系统建模</a></li><li><a href="#">伍 体系结构设计</a></li><li><a href="#">陆 设计与实现</a></li><li><a href="#">柒 软件测试</a></li><li><a href="#">捌 软件进化 / 软件维护</a></li></ul></li><li>高级软件工程<ul><li><a href="#">玖 软件复用</a></li><li><a href="#">拾 基于组件的软件工程</a></li></ul></li><li>软件管理<ul><li><a href="#">拾壹 项目管理</a></li><li><a href="#">拾贰 项目规划</a></li></ul></li></ul><h2 id="壹-软件过程"><a href="#壹-软件过程" class="headerlink" title="壹 软件过程"></a>壹 软件过程</h2><ul><li>学习目标<ul><li>3个一般的 <code>软件过程模型</code>；</li><li>了解软件需求工程、开发、测试和进化中所涉及的 <code>基本过程活动</code>；</li><li>理解为什么软件过程要有效地组织以应对软件需求和设计上的变更；</li><li>Rational 统一过程 (RUP).</li></ul></li><li>软件过程必须具有的基本活动<ul><li>软件描述</li><li>软件设计和实现</li><li>软件有效性验证</li><li>软件进化</li></ul></li><li>没有“理想”的软件过程 — 寻找平衡点<ul><li>计划驱动过程：提前计划好所有的过程活动，再按计划去考核过程的执行。</li><li>敏捷过程：计划是增量式的，且容易根据不断变化的客户需求变更过程。更多详细内容见 <code>第叁章</code>。</li></ul></li></ul><h3 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h3><ul><li>软件过程：产生一个软件系统的一系列活动。</li><li>软件过程的简化表示 (抽象表示)。</li><li><p>每个过程模型都是从一个特定的侧面表现软件过程，所以只提供过程的部分信息。</p><blockquote><p>如过程活动模型表现了这些活动和他们的顺序，但可能表现不出人们在这些活动中的角色。</p></blockquote></li></ul><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-1.png" alt="图1-1瀑布模型"></p><center>图 1-1 瀑布模型</center><ul><li>计划驱动模型；</li><li>该模型将基本的过程活动、描述、开发、有效性验证和进化，看成是一些界限分明的独立的过程阶段。<ul><li>需求分析和定义：通过咨询系统用户建立系统的服务、约束和目标，并对其详细定义形成系统描述。</li><li>系统和软件设计<ul><li>系统设计 — 建立系统的总体体系结构，将需求区分为硬件需求和软件需求。</li><li>软件设计 — 识别和描述一些基本的软件系统抽象及其之间的关系。</li></ul></li><li>实现和单元测试<ul><li>软件设计实现 — 实现为一组程序或程序单元。</li><li>单元测试 — 验证每个单元是否符合其描述。</li></ul></li><li>集成和系统测试<ul><li>集成 — 集成单个的程序单元或一组程序。</li><li>系统测试 — 评估系统的可靠性；是否满足软件需求。</li></ul></li><li>运行和维护</li></ul></li></ul><h4 id="增量式开发"><a href="#增量式开发" class="headerlink" title="增量式开发"></a>增量式开发</h4><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-2.png" alt="图1-2增量式开发"></p><center>图 1-2 增量式开发</center><ul><li>即可是计划驱动的，也可是敏捷方法的。<ul><li>系统增量是提前定义好的，即为 <code>计划驱动方法</code>。</li><li>最初的增量是定义好的，但往后的增量的开发取决于项目的进展情况及客户的优先选择，即为 <code>敏捷方法</code>。</li></ul></li><li>系统的开发是建立一系列的版本 (增量) 每个版本添加部分功能到先前版本中。</li><li>增量式开发的特性<ul><li>降低了适应用户需求变更的成本。</li><li>开发过程中及时得到用户已做的开发工作的反馈意见。</li><li>更快地交付和部署有用的软件到客户方。</li></ul></li></ul><h4 id="面向复用的软件工程"><a href="#面向复用的软件工程" class="headerlink" title="面向复用的软件工程"></a>面向复用的软件工程</h4><p>基于复用开发的一般过程模型如图 1-3 所示。初始需求描述阶段、有效性验证阶段与其他过程差不多，面向复用过程的中间阶段是不同的。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-3.png" alt="图1-3面向复用的软件工程"></p><center>图 1-3 面向复用的软件工程</center><ul><li>中间阶段：即组件分析、需求修改、使用复用的系统设计、开发和集成阶段。<ul><li>组件分析：需求描述 -&gt; 搜组件 (往往只提供所需的部分功能)。</li><li>需求修改：根据得到组件信息分析需求，再修改需求以反映可得到的组件。</li><li>使用复用的系统设计：设计系统的框架或者重复使用一个已存在的框架。</li><li>开发和集成</li></ul></li></ul><h3 id="过程活动"><a href="#过程活动" class="headerlink" title="过程活动"></a>过程活动</h3><h4 id="软件描述"><a href="#软件描述" class="headerlink" title="软件描述"></a>软件描述</h4><ul><li>软件描述或需求工程是理解和定义系统需要提供什么样的服务，以及找出开发和运行中受到哪些约束。</li><li>需求工程过程的主要阶段，如图 1-4 所示。<ul><li>可行性研究</li><li>需求导出和分析</li><li>需求描述</li><li>需求有效性验证</li></ul></li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-4.png" alt="图1-4需求工程过程"></p><center>图 1-4 需求工程过程</center><h4 id="软件设计和实现"><a href="#软件设计和实现" class="headerlink" title="软件设计和实现"></a>软件设计和实现</h4><ul><li>软件设计和实现阶段是把系统描述转换成一个可运行的系统的过程。</li><li>软件设计是对实现软件的结构、系统的数据、系统组件间的接口以及所用的算法的描述。这是一反复、迭代的过程。</li></ul><h4 id="软件有效性验证"><a href="#软件有效性验证" class="headerlink" title="软件有效性验证"></a>软件有效性验证</h4><ul><li>程序测试：用模拟测试数据运行系统。</li><li>测试过程各阶段<ul><li>组件 (单元) 测试：每个组件单独测试；组件可是简单实体，如函数、对象类或这些实体的集合。</li><li>系统测试：集成组件形成完整系统，对组件组成的子系统测试。</li><li>接收测试：客户提供真实数据测试系统。</li></ul></li></ul><h4 id="软件进化-软件维护"><a href="#软件进化-软件维护" class="headerlink" title="软件进化/软件维护"></a>软件进化/软件维护</h4><p>软件工程不再是开发和维护两个独立的过程，而是一个进化过程。即软件在其生命内不断随着需求的变更而变更的进化式过程。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-5.png" alt="图1-5系统进化"></p><center>图 1-5 系统进化</center><h3 id="应对变更"><a href="#应对变更" class="headerlink" title="应对变更"></a>应对变更</h3><ul><li>有效降低变更成本<ul><li>变更避免：预测变更，如 <code>原型系统</code> 的开发，客户试用原型，在花费高额的软件生产成本之前重新定义需求。</li><li>变更容忍：<code>增量开发</code>，即使单个增量(系统一小部分)的修改来适应变更，以较低成本处理变更。</li></ul></li><li>应对变更系统需求的方法<ul><li>系统原型：快速开发一个系统版本或系统一部分，以检验客户需求和某些设计决定的可行性，即它支持 <code>变更避免</code>。</li><li>增量交付：系统增量地交付给用户，给用户评审和试用。即它支持 <code>变更避免</code> 和 <code>变更容忍</code>。</li></ul></li></ul><h4 id="原型构造"><a href="#原型构造" class="headerlink" title="原型构造"></a>原型构造</h4><ul><li>原型是一个软件系统的最初版本，用于验证概念、试用设计选项、发现更多的问题和可能的解决方法。</li><li><p>原型开发的过程模型如图 1-6 所示。</p><p>  <img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-6.png" alt="图1-6原型开发的过程"></p>  <center>图 1-6 原型开发的过程</center><blockquote><p>最后一阶段：原型评估，则必须安排用户培训，应根据原型的目标制定一个评估计划。即用户需习惯并适用新系统，一旦他们自然地使用了系统，将可能发现错误和被遗漏的需求。</p></blockquote></li><li><p>不强求原型是可执行的。</p><blockquote><p>基于纸质的模型系统的用户界面，用户和这个界面交互，但他们的请求被传递给一个人，该人员解释此请求并输出相应的响应。</p></blockquote></li></ul><h4 id="增量式交付"><a href="#增量式交付" class="headerlink" title="增量式交付"></a>增量式交付</h4><ul><li><p>增量式开发是软件开发的一种方法，如图 1-7 所示。</p><p>  <img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-7.png" alt="图1-7增量式交付"></p>  <center>图 1-7 增量式交付</center></li><li><p>增量式开发过程的好处</p><ul><li>早期的增量作为原型，从中获得对后面系统增量的需求经验。</li><li>每一增量会满足他们大多数需求，即软件马上就能使用。</li><li>具有高优先权的服务被首先交付，而后继有增量不断被集成进来，使得最重要的系统服务接受了多次测试。</li></ul></li><li>增量式交付存在的问题<ul><li>软件描述和软件本身一起开发是迭代过程的本质。在增量方法中，直到最后的增量描述完成，才会有完整的系统描述。而许多机构 (如政府) 的采购模型是，系统开发合同中附带完整的系统描述，即相互冲突。</li><li>旧系统的所有功能与新系统的部分功能，多数用户宁可选前者，即获取反馈较困难。</li></ul></li></ul><h4 id="Boehm-的螺旋模型"><a href="#Boehm-的螺旋模型" class="headerlink" title="Boehm 的螺旋模型"></a>Boehm 的螺旋模型</h4><ul><li>风险驱动的软件过程框架 (螺旋模型)<ul><li>在螺旋线中每个回路表示软件过程的一个阶段，如最里的回路可能与系统可行性研究有关，下一回路与系统需求定义有关等。</li><li>螺旋线中每个回路被分成4部分：<br>1) 目标设置<br>2) 风险评估和规避<br>3) 开发和有效性验证<br>4) 规划  </li></ul></li></ul><h3 id="Rational-统一过程"><a href="#Rational-统一过程" class="headerlink" title="Rational 统一过程"></a>Rational 统一过程</h3><ul><li>RUP 一般从3个视角描述过程<ul><li>动态视角：给出模型中随时间所经历的各个阶段。</li><li>静态视角：给出所进行的过程活动。</li><li>实践视角：提出在过程中可采用的良好实践建议。</li></ul></li><li><p>RUP 是一阶段化模型，如图 1-8 所示。</p><ul><li>开端  <ul><li>目标是建立系统的一个业务案例。  </li><li>识别所有与系统交互的外部实体 (人和系统) 并定义这些交互。</li><li>适用这些信息评估系统对业务的贡献，若贡献微小，那么项目在此阶段结束。</li></ul></li><li>细化<ul><li>目标是增进对问题域的理解，建立系统的体系框架，给出项目计划并识别关键项目风险。</li><li>输出系统的需求模型 (描述的用例、体系结构描述及开发计划)。</li></ul></li><li>构造：系统设计、编程和测试。</li><li><p>转换：将系统从开发单位转移到用户单位，并使之在真实环境中工作。</p><blockquote><p>1) RUP 中的阶段是紧密与业务关联，而不是与技术层面关联。<br>2) RUP 把 <code>阶段</code> (开端、细化、构造、转换) 和 <code>工作流</code> (需求、分析、设计…) 分离，即各种 RUP 工作流在整个过程的所有阶段都是可能存放的。  </p></blockquote><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-8.png" alt="图1-8Rational统一过程的各阶段"></p><center>图 1-8 Rational 统一过程的各阶段</center></li></ul></li><li><p>实践视角</p><ul><li>迭代地开发软件；</li><li>对需求的管理：记录并跟踪客户的需求；</li><li>使用基于组件的体系结构，将系统体系结构组织成组件形态；</li><li>可视化地建模软件：UML 模型表现软件的静态、动态视图；</li><li>检验软件质量；</li><li>控制对软件的变更：变更管理系统、配置管理程序和工具来管理软件的变更。</li></ul></li><li><p>静态视角</p><ul><li>聚焦在开发过程中所发生的活动上，这些在 RUP 描述中被称为工作流。</li><li><p>此过程中包含6个核心过程工作流，3个核心支持工作流，见图 1-9 所示。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-9.png" alt="图1-9RUP中的静态工作流"></p><center>图 1-9 RUP 中的静态工作流</center></li></ul></li></ul><h2 id="贰-敏捷软件开发"><a href="#贰-敏捷软件开发" class="headerlink" title="贰 敏捷软件开发"></a>贰 敏捷软件开发</h2><div class="note success"><p> 开始敏捷开发篇章前，引入一有趣的例子。Jazz Band 模式，跟 “敏捷的开发模式” 类似，同样也可以产生优秀的作品。( 演奏中，Miles Davis 先用小号吹出主题 ( 类比为架构师 )，然之后到一旁抽烟。曲目交由其他人员即兴发挥。最后， Miles Davis 加入演奏，回应主题 )。</p><p>感兴趣的可以观看视频：<a href="http://v-wb.youku.com/v_show/id_XMTUzNzUxOTEwNA==.html" target="_blank" rel="noopener">Miles Davis So What</a> </p></div><ul><li>学习目标<ul><li>理解敏捷软件开发方法的基本原理、核心内涵，以及它与计划驱动软件开发方法的差别；</li><li>极限编程；</li><li>理解敏捷项目管理的 <code>Scrum</code> 方法；</li><li>应用伸缩的敏捷方法时的事项和问题 -&gt; 大型软件系统开发过程.</li></ul></li></ul><h3 id="敏捷方法"><a href="#敏捷方法" class="headerlink" title="敏捷方法"></a>敏捷方法</h3><ul><li>敏捷方法是一种专注于快速开发的 <code>增量式开发</code>，<code>频繁地发布软件</code>、<code>降低过程开销</code>、生产高质量代码。他们使用户直接参与到开发过程中。</li><li><p>敏捷方法的基本原理体现在 <code>敏捷宣言</code> 中：</p><ul><li>个体和交互胜过工具和过程；</li><li>编写软件胜过书写详尽文档；</li><li>用户合作胜过合同谈判；</li><li><p>响应变更更胜过遵循计划.</p><blockquote><p>即我们更重视左边的项的价值，虽左右两边的项都有价值。</p></blockquote></li></ul></li><li><p>大量的软件工程努力维护和进化现有的软件系统，而由敏捷方法的特性可知，敏捷方法维护的问题有：</p><ul><li>软件交付后的主要困难可能是继续让用户参与到过程中。</li><li>保持开发团队的持续性，因没有参考文档可循，若一个敏捷开发团队解散了，则 <code>依赖于团队成员理解系统</code> 的 <code>隐式知识</code> 旧丢失了。</li></ul></li><li>混成方法：敏捷方法嵌入来自计划计划驱动式开发的某些技术。</li></ul><h3 id="计划驱动开发和敏捷开发"><a href="#计划驱动开发和敏捷开发" class="headerlink" title="计划驱动开发和敏捷开发"></a>计划驱动开发和敏捷开发</h3><p>计划驱动和敏捷描述如图 2-1 所示。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_2-1.png" alt="图2-1计划驱动和敏捷描述"></p><center>图 2-1 计划驱动和敏捷描述</center><ul><li>敏捷方法：<ul><li>迭代发生在所有活动间。</li></ul></li><li><p>计划驱动方法：</p><ul><li><p>迭代发生在各个活动中，用 <code>正式文件</code> 在软件过程中各阶段间沟通。</p><blockquote><p><code>正式文件</code>：可视化作为各阶段的输出产物。</p></blockquote></li></ul></li><li>在计划驱动和敏捷方法之间得到平衡，必须回答以下一些技术的、人员的和机构方面的问题。<ul><li>详尽的描述和设计 -&gt; <code>计划驱动开发</code></li><li>交互用户并快速取得反馈 -&gt; <code>敏捷开发</code></li><li>开发系统的规模；</li><li>开发的系统类型，如有复杂时序需求的实时系统，通常需要相当详细的设计来实现分析 -&gt; <code>计划驱动开发</code></li><li>预想的系统寿命有多长；</li><li>什么样的技术支持系统开发 (敏捷方法通常依赖于工具，以跟踪设计进化)；</li><li>开发团队的组织情况；</li><li>影响系统开发的文化问题 (传统的工程机构有计划驱动的文化)；</li><li>开发团队的成员专业水平；</li><li>系统是否受制于外部法规 (如联邦的航空管理局 FAA 核准一个安全性要求极高的航空操作软件)；</li></ul></li></ul><h3 id="极限编程-XP"><a href="#极限编程-XP" class="headerlink" title="极限编程 (XP)"></a>极限编程 (XP)</h3><ul><li>极限编程所属敏捷方法，它集成了一系列好的编程经验。例如，频繁地软件发布、连续软件改善和客户参与到软件开发团队。</li><li>XP 中，所有的需求都表示为脚本 (称为用户故事情节)，它将直接实现为一系列任务。</li><li>一个 XP 过程，产生了正在开发的系统的一个增量，具体如图 2-2 所示。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_2-2.png" alt="图2-2极限编程的版本循环"></p><center>图 2-2 极限编程的版本循环</center><ul><li>脚本卡是 XP 规划过程的主要输入。<ul><li>开发团队把每个 <code>脚本</code> 拆分成 <code>任务</code>，并估计实现所需人力资源。</li><li>与客户交谈，定义需求，对脚本进行优先权排序。</li></ul></li></ul><h4 id="极限编程中的测试"><a href="#极限编程中的测试" class="headerlink" title="极限编程中的测试"></a>极限编程中的测试</h4><ul><li>很多增量开发方法的测试过程是很不规范的。</li><li>为避免一些测试和系统验证方面的问题，XP 方法更加强调测试过程。</li><li>XP 当中测试的关键特性：<ul><li>测试优先的开发 (先写测试程序再写代码)；</li><li>来自脚本的增量式测试开发；</li><li>用户参与测试开发和有效性验证；</li><li>自动测试系统的使用。将测试写成了可执行的组件，该测试组件是独立的。自动测试框架即是这样的一个系统。譬如 Eclipse 的 JUnit，JUnit 用于单元测试。</li></ul></li></ul><h4 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h4><p>结对编程是有一些质量效益，但却不足以抵消它的开销。但信息共享在结对编程是很重要的，因为当有团队成员离开时，它降低了项目风险。</p><h3 id="敏捷项目管理"><a href="#敏捷项目管理" class="headerlink" title="敏捷项目管理"></a>敏捷项目管理</h3><ul><li>项目管理的标准：计划驱动。</li><li><p>适合增量开发 (敏捷方法) 的管理方法 (框架)：<code>Scrum</code>。</p><ul><li><p>Scrum 的管理过程如图 2-3 所示。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_2-3.png" alt="图2-3Scrum的管理过程"></p><center>图 2-3 Scrum 的管理过程</center></li><li><p>Scrum 的 3 个阶段</p><ul><li>规划纲要阶段：建立大致的项目目标和设计软件体系结构。</li><li>冲刺循环阶段：<ul><li>每个循环开发出一个系统增量；</li><li>每个循环为一个计划单元，其中的工作有评估、特征选择和开发、软件实现；</li></ul></li><li>项目结束阶段：完善文档，如系统帮助和用户手册。</li><li><p>冲刺循环阶段的特征：</p><ul><li>冲刺有固定长度，一般是 2-4 周，在 XP 过程中对对应与一个系统版本的开发。</li><li>规划的起点，即积压的任务 (Backlog)，也是项目中要完成的工作清单。</li><li>评估阶段：Backlog 需经过审查，并对它们进行优先级排序和风险指派。</li><li>选择阶段：项目所有成员都要参加，和用户一起选择冲刺循环中要开发的特性和功能。</li><li>开发阶段：达成共识将组织进行软件开发，每一天团队开发成员参与段时间会议，回顾开发过程，若有必要重新安排工作。且在此阶段开发团队是隔离于客户和机构的。</li><li><p>冲刺循环阶段结束，对已做工作复查并交付给用户。</p><blockquote><p>所有交流都是通过 <code>Scrum Master</code> 进行，SM 可理解为调解人。体现了 Scrum 的思想，即整个团队被赋予决定的权利。</p></blockquote></li></ul></li></ul></li><li><p>Scrum 适合分布式的开发环境。</p></li></ul></li></ul><h3 id="可扩展的敏捷方法"><a href="#可扩展的敏捷方法" class="headerlink" title="可扩展的敏捷方法"></a>可扩展的敏捷方法</h3><ul><li>敏捷方法的开发是为同一房间办公与交流的小团队开发使用，因此常被用于小型系统开发。</li><li>可伸缩的敏捷方法也可适用于开发大型系统。</li><li>大型、小型系统开发的区别 (可理解为可扩展的敏捷方法应用于大型系统的挑战)。<ul><li>大型系统经常由独立的、交互的子系统组成。不同团队独立开发不同子系统，且团队可能在不同地点或不同时区工作。</li><li>大型系统包含了一系列的已存在的系统并与它们进行交互，许多系统需求关注这种交互。</li><li>当一个系统由多个系统集成产生时，开发工作中重要部分是系统配置而不是原始代码开发。这不一定与增量式开发和频繁的系统集成兼容。</li><li>大型系统通常具有不同的信息持有者，将不同的信息持有者加入开发流程中是必要的。</li></ul></li><li>伸缩的敏捷方法的两个观点<ul><li>照搬放大，即关注如何将这些方法应用到哪些 <code>小团队</code> 无法开发的 <code>大型项目</code> 中。</li><li>渗透，即关注如何将敏捷方法介绍 <code>推广</code> 到拥有多年开发经验的 <code>大机构</code> 中。</li></ul></li></ul><h2 id="叁-需求工程"><a href="#叁-需求工程" class="headerlink" title="叁 需求工程"></a>叁 需求工程</h2><ul><li><p>学习目标</p><ul><li>了解用户需求、系统需求；</li><li>了解功能需求、非功能需求；</li><li>如何在软件需求文档中 <code>机构需求</code>；</li><li>了解需求工程活动的内容及他们之间的关系；</li><li>了解需求管理.</li></ul></li><li><p>一些概念</p><ul><li><p>用户需求：用自然语言加图的形式给出的关于系统 <code>需要提供</code> 哪些服务及系统操作受到哪些 <code>声明的约束</code>。</p><blockquote><p>高层 (抽象) 的概要需求。</p></blockquote></li><li><p>系统需求：详细给出系统 <code>将要提供</code> 的服务及系统所受到的约束。系统的需求文档也称功能描述。</p><blockquote><p>系统应提供哪些服务的详细描述。</p></blockquote></li></ul></li></ul><h3 id="功能需求与非功能需求"><a href="#功能需求与非功能需求" class="headerlink" title="功能需求与非功能需求"></a>功能需求与非功能需求</h3><ul><li>功能需求<ul><li>描述系统所提供的功能或服务。</li><li>若是用户需求，就要用可以被系统用户理解的一种抽象方法描述功能需求。</li><li>更具体的功能性系统需求则需要详细地描述系统功能、异常、输入和输出。</li></ul></li><li><p>非功能需求</p><ul><li>指那些不直接关系到系统向用户提供的具体服务的一类需求。简言之，他们对 <code>系统实现</code> 定义了 <code>约束</code>，如 I/O 设备的能力、与其他系统接口的数据的表示。</li><li><p>非功能性系统需求：通常会从总体上规范或约束系统的特性。</p><blockquote><p>若一个非功能系统需求没有满足则可能使整个系统无法使用。</p></blockquote></li><li><p>非功能需求分类：表明非功能需求或是来源于所要求的软件特性 (产品需求)，或是来源于开发软件的机构 (机构需求)，或是来源于外部来源。如图 3-1 所示。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_3-1.png" alt="图3-1非功能需求的类型"></p><center>图 3-1 非功能需求的类型</center></li></ul></li></ul><h3 id="软件需求文档"><a href="#软件需求文档" class="headerlink" title="软件需求文档"></a>软件需求文档</h3><ul><li>如表 3-1 所示，是基于 IEEE 标准的需求文档的结构。<ul><li>需求文档中内容的详细程序，取决于所要开发的系统的类型及所使用的开发过程。</li></ul></li></ul><center>表 3-1 需求文档结构</center><div class="table-container"><table><thead><tr><th style="text-align:left">章节</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">绪言</td><td style="text-align:left">定义文档的读者对象，说明版本的修正历史，包括新版本为什么要创建，每个版本间的变更内容的概要</td></tr><tr><td style="text-align:left">引言</td><td style="text-align:left">描述为什么需要该系统，简要描述系统的功能，解释系统是如何与其他系统协同工作的。描述该系统在机构总体业务目标和战略目标中的位置和作用</td></tr><tr><td style="text-align:left">术语</td><td style="text-align:left">定义文档中的技术术语和词汇。假设文档读者是不具有专业知识和经验的人</td></tr><tr><td style="text-align:left">用户需求定义</td><td style="text-align:left">这一部分要描述系统应该提供的服务以及非功能系统需求，该描述可以使用自然语言、图表或者其他各种客户能理解的标记系统。产品和过程必须遵循的标准也要在此定义</td></tr><tr><td style="text-align:left">系统体系结构</td><td style="text-align:left">这一部分要对待建系统给出体系结构框架，该体系结构要给出功能在各个模块中的分布。能被复用的结构中组件要用醒目方式示意出来</td></tr><tr><td style="text-align:left">系统需求描述</td><td style="text-align:left">这一部分要对功能和非功能需求进行详细描述。如有必要，对非功能需求要再进一步描述，例如定义与其他系统间的接口</td></tr><tr><td style="text-align:left">系统模型</td><td style="text-align:left">这一部分要提出一个或多个系统模型，以表达系统组件、系统以及系统环境之间的关系。这些模型可以是对象模型、数据流模型和语义数据模型</td></tr><tr><td style="text-align:left">系统进化</td><td style="text-align:left">这一部分要描述系统基于的基本设想和定位以及硬件和用户需求改变时所要做的改变。这部分对系统设计人员来说是有用的，因为这有助于他们避免一些设计决策，这些决策可能会限制未来系统的变更</td></tr><tr><td style="text-align:left">附录</td><td style="text-align:left">这一部分要提供与开发的应用有关的详细、专门的信息。该附录的例子是硬件和数据库的描述，硬件需求定义了系统最小和最优配置，数据库需求定义了系统所用的数据的逻辑结构和数据之间的关系</td></tr><tr><td style="text-align:left">索引</td><td style="text-align:left">可以包括文档的几个索引。除了标准的字母顺序索引外，还可以有图标索引、功能索引等</td></tr></tbody></table></div><h3 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h3><ul><li>即在需求文档中写下用户需求和系统需求。<ul><li>用户需求：从用户角度来描述系统功能需求和非功能需求，一般用自然语言、图形叙述。</li><li>系统需求：<ul><li>用户需求的扩展；</li><li>软件工程师开始系统设计的起点；</li><li>解释如何能让系统提供用户需求.</li></ul></li></ul></li><li><p>原则上系统需求应 <code>反描述</code> 系统的 <code>外部行为</code> 和对它的 <code>操作限制</code>，而不是描述系统如何设计、实现。</p><blockquote><p>当然，并不是不提及任何设计信息，这也是不可能的，例如系统初始的体系结构设计。</p></blockquote></li></ul><h4 id="自然语言描述"><a href="#自然语言描述" class="headerlink" title="自然语言描述"></a>自然语言描述</h4><ul><li>在使用自然语言书写需求时，为了尽力 <code>减少误解</code>，应有一些简单的指导原则：<ul><li>设计一个 <code>标准格式</code>，并保证所用的需求定义都遵循此格式书写。</li><li>使用一致性的语言来区分强制性需求和可选性需求。<ul><li>强制性需求：必须支持的，定义时使用 <code>必须</code>。</li><li>可选性需求：不是必要的，定义时使用 <code>应该</code>。</li></ul></li><li>对文本加亮 (粗体、斜体、颜色) 来突出显示关键性需求。</li><li>避免使用专业术语和缩写语 (无法避免时应该在有标注说明)。</li><li>任何情况下，都应尝试把需求原理和每一个用户需求联系起来。</li></ul></li></ul><h4 id="结构化描述"><a href="#结构化描述" class="headerlink" title="结构化描述"></a>结构化描述</h4><ul><li>使用结构化方法来描述系统需求，则先为需求定义一个或多个的 <code>标准模板</code>，并将模板表示成结构化的表格形式。如表 3-2 所示，是胰岛素泵需求的结构化描述。</li></ul><center>表 3-2 胰岛素泵需求的结构化描述</center><div class="table-container"><table><thead><tr><th style="text-align:left">项目名称</th><th style="text-align:left">胰岛素泵/控制软件/SRS/3.3.2</th></tr></thead><tbody><tr><td style="text-align:left">功能</td><td style="text-align:left">计算胰岛素剂量；安全的胰岛素水平</td></tr><tr><td style="text-align:left">描述</td><td style="text-align:left">计算所要传输的胰岛素剂量，这是在当前度量的血糖水平处于 3-7 个单位之间这样正常范围之内时的胰岛素计算</td></tr><tr><td style="text-align:left">输入</td><td style="text-align:left">当前血糖读数 (r2)，先前的两个读数 (r0, r1)</td></tr><tr><td style="text-align:left">来源</td><td style="text-align:left">来自传感器的当前血糖读数。其他读数来自内存</td></tr><tr><td style="text-align:left">输出</td><td style="text-align:left">CompDose：所要传输的胰岛素剂量</td></tr><tr><td style="text-align:left">目的地</td><td style="text-align:left">主控制循环</td></tr><tr><td style="text-align:left">行动</td><td style="text-align:left">如果血糖水平是稳定的或往下掉或是上升但速率下降，则 CompDose 为 0。若血糖的水平是在上升且上升速率也上升，那么 CompDose 的计算方法是求当前血糖水平和先前血糖水平，再除以 4 并取整。若取整的结果为 0，那么 CompDose 就被设置成可以传输的最小剂量</td></tr><tr><td style="text-align:left">需求</td><td style="text-align:left">两个先前的读数，这样血糖变化速率就可以计算出来了</td></tr><tr><td style="text-align:left">前置条件</td><td style="text-align:left">胰岛素池容纳至少是单个传输剂量的最大值</td></tr><tr><td style="text-align:left">后置条件</td><td style="text-align:left">r0 被 r1 替换，然后 r1 被 r2 替换</td></tr><tr><td style="text-align:left">副作用</td><td style="text-align:left">无</td></tr></tbody></table></div><ul><li>标准格式描述功能需求时，应包括下列信息：<ul><li>关于所定义的功能或实体的描述；</li><li>关于输入及输入来源的描述；</li><li>关于输出及输出去向的描述；</li><li>关于计算所需要的信息及系统中所使用的其他实体信息；</li><li>关于所采取的行动的描述；</li><li>如果使用一个功能方法，前置条件、后置条件的设定描述；</li><li>关于操作的副作用，没有则填写无.</li></ul></li></ul><h3 id="需求工程过程"><a href="#需求工程过程" class="headerlink" title="需求工程过程"></a>需求工程过程</h3><ul><li>需求工程过程包括4个高层活动：<ul><li>系统可行性研究：评估系统是否对业务有用。</li><li>需求导出和分析：需求发现。</li><li>需求描述：将需求转变为某种标准格式描述。</li><li>需求有效性验证：检验需求是否正确地定义了客户所希望的系统。</li></ul></li><li>在实际需求工程是一个活动相互交错的迭代过程，如图 3-2 体现了这种交错性。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_3-2.png" alt="图3-2需求工程过程的螺旋模型"></p><center>图 3-2 需求工程过程的螺旋模型</center><h3 id="需求导出和分析过程"><a href="#需求导出和分析过程" class="headerlink" title="需求导出和分析过程"></a>需求导出和分析过程</h3><ul><li>反复的过程，也可看做是一种 <code>螺旋式活动</code>。</li><li>需求发现 (需求导出)<ul><li>对准备建立的系统和正使用的系统进行信收集，并从中提取用户需求和系统需求的过程。</li><li>与 <code>信息持有者</code> 通过交谈和观察进行交互，即可使用 <code>用例</code> 和 <code>原型</code> 来帮助对方理解系统。</li></ul></li><li>采访<ul><li>封闭式采访：即信息持有者回答一组 <code>锁定的问题</code>。</li><li>开放式采访：需求工程团队 <code>即兴访问</code>，更深层次了解对方需求是什么。</li></ul></li><li>脚本<ul><li>脚本是对 <code>交互实例片段</code> 的描述。</li><li>脚本开始于一个 <code>交互框架</code>，在导出过程中细节增加，直至产生一完整的交互描述。</li><li>脚本的内容<ul><li>开始部分有一系统和用户期望的描述；</li><li>标准事件流的描述；</li><li>处理错误的描述；</li><li>完成后系统状态的描述.    </li></ul></li></ul></li><li>用例<ul><li>统一建模语言 (UML) 的基本特征。</li><li>用例的集合代表所有将会在系统需求中出现的交互。过程中的角色可为人、其他系统等。</li><li>UML 对于面向对象模型来说，是一约定俗成的标准，因此基于用例的导出被广泛应用于需求导出中。</li></ul></li><li>深入实际：如图 3-3 所示的需求分析的深入实际方法和原型法。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_3-3.png" alt="图3-3需求分析的深入实际方法和原型法"></p><center>图 3-3 需求分析的深入实际方法和原型法</center><h3 id="需求有效性验证"><a href="#需求有效性验证" class="headerlink" title="需求有效性验证"></a>需求有效性验证</h3><ul><li>有效性检查：任何一组需求都不可避免地要在不同用户之间协商。</li><li>一致性检查：需求不应该彼此冲突。</li><li>完备性检查：需求文档应包括所有系统用户想要的功能和约束。</li><li>真实性检查：检查需求以保证需求能真正实现。</li><li>可检验性检查：检查方法 -&gt; 验证需交付的系统 -&gt; 满足定义的需求。<ul><li>需求评审：主要是错误检查和不一致检查。</li><li>原型建立：提供一可执行的系统模型，客户和最终用户在此基础检查系统。</li><li>测试用例生成。</li></ul></li></ul><h3 id="需求管理"><a href="#需求管理" class="headerlink" title="需求管理"></a>需求管理</h3><ul><li>大型软件系统的需求总是在变化的，即开发这些系统需满足某些棘手问题，则这些问题不可能被完全定义。如图 3-4 所示为需求进化的过程。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_3-4.png" alt="图3-4需求进化过程"></p><center>图 3-4 需求进化过程</center><h4 id="需求管理规划"><a href="#需求管理规划" class="headerlink" title="需求管理规划"></a>需求管理规划</h4><ul><li>需求识别：每一需求有 <code>唯一标识码</code>。</li><li>变更管理过程：变更带来的影响和成本的评估活动。</li><li>可追溯策略：<code>策略</code> 定义了需求间和需求与系统设计间的 <code>关系</code>；关系是要记录的，并附有记录的 <code>维护方法</code>。</li><li><p>工具支持</p><ul><li>需求存储</li><li>变更管理：如图 3-5 所示，即变更过程由有效工具来支持。</li><li><p><code>可追溯性</code> 管理：需求间的 <code>关联</code> &lt;- 自然语言处理技术 (NLP)</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_3-5.png" alt="图3-5需求变更管理"></p><center>图 3-5 需求变更管理</center></li></ul></li></ul><h4 id="需求变更管理"><a href="#需求变更管理" class="headerlink" title="需求变更管理"></a>需求变更管理</h4><ul><li>问题分析和变更描述：问题或变更 -&gt; 检验有效性 -&gt; 反馈变更请求者 -&gt; 导致两种结果：<ul><li>更加详尽的需求变更、提议；</li><li>取消本次变更.</li></ul></li><li>变更分析和成本计算：需求文档修改、系统设计和实现的成本估算。</li><li>变更实现：与编写程序类似，文档的 <code>可追溯性</code> 即 <code>关联性</code> 是通过最小化外部引用和尽量使之模块化来实现的。</li></ul><h2 id="肆-系统建模"><a href="#肆-系统建模" class="headerlink" title="肆 系统建模"></a>肆 系统建模</h2><ul><li>学习目标<ul><li>如何用图形模型表示软件系统；</li><li>基本的建模角度 (如上下文、交互、结构、行为等)；</li><li>统一建模语言 (UML)；</li><li>模型驱动工程.</li></ul></li><li>系统建模：建立系统抽象模型的过程<ul><li>图形建模；</li><li>形式化建模 (数学模型). </li></ul></li><li>不同角度表述系统 <code>与 第陆章 中的「4+1」视图相仿</code><ul><li><code>外部</code> — 上下文模型：系统上下文；系统环境；</li><li><code>交互</code> — 交互模型：系统与环境之间；系统各组成部分之间；</li><li><code>结构</code> — 结构模型：系统的体系结构；</li><li><code>行为</code> — 行为模型：系统的动态行为和它对事件响应方式.</li></ul></li></ul><h3 id="上下文模型"><a href="#上下文模型" class="headerlink" title="上下文模型"></a>上下文模型</h3><ul><li>定义系统边界：定义系统上下文和系统与环境之间的依赖关系。</li><li>上下文模型表示某一环境包括几个其他的自动系统 (忽略子系统之间及待描述的系统与它们之间的关联关系的类型)。</li><li><p>结合业务过程模型 </p><ul><li><p>活动图：如图 4-1 所示。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-1.png" alt="图4-1活动图"></p><center>图 4-1 活动图</center></li></ul></li></ul><h3 id="交互模型"><a href="#交互模型" class="headerlink" title="交互模型"></a>交互模型</h3><ul><li>为用户交互建模 -&gt; 识别用户需求。</li><li>为系统各部分之间的交互建模 -&gt; 系统结构能否实现系统所需的功能及其可靠性。</li></ul><h4 id="用例建模"><a href="#用例建模" class="headerlink" title="用例建模"></a>用例建模</h4><ul><li>用例图：如图 4-2 所示。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-2.png" alt="图4-2用例图"><br>    <center>图 4-2 用例图</center></p><ul><li>时序图：表示在特定用例中的交互发生顺序。如图 4-3 所示。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-3.png" alt="图4-3时序图"><br>    <center>图 4-3 时序图</center></p><h3 id="结构模型"><a href="#结构模型" class="headerlink" title="结构模型"></a>结构模型</h3><blockquote><p>课本第 6、18、19 章讲述软件体系结构的不同方面和软件体系结构建模。</p></blockquote><ul><li>静态模型：表示系统设计的结构。</li><li>动态模型：表示系统执行时的构成。</li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><ul><li><p>类图可表示系统中的类和这些类之间的关联。</p><blockquote><p>类与类之间的链接，表示类与类之间具有某种关系。</p></blockquote><ul><li><p>简单类图：如图 4-4 所示。其中一对多关系的类图，类似于语义数据模型，即数据实体、与他们相关的属性。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-4.png" alt="图4-4简单类图"></p><center>图 4-4 简单类图</center></li><li><p>扩展类图：如图 4-5 所示。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-5.png" alt="图4-5扩展类图"></p><center>图 4-5 扩展类图</center></li></ul></li></ul><h4 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h4><ul><li>推断一些类的成员具有的某些共同特征，针对类的所有成员给出一般性的描述。如图 4-6 所示。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-6.png" alt="图4-6泛化关系"></p><center>图 4-6 泛化关系</center><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><ul><li>一个对象 (全体) 可有由其他对象 (部分) 组成。如表示一条病人记录由 Patient 和一个不确定的 Consulation 组成。如图 4-7 所示，表示了一条病人记录由 Patient 和一个不确定的 Consulation 组成。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-7.png" alt="图4-7聚合关系"></p><center>图 4-7 聚合关系</center><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>如图 4-8 所示，展示了依赖关系。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-8.png" alt="图4-8依赖关系"></p><center>图 4-8 依赖关系</center><h3 id="行为模型"><a href="#行为模型" class="headerlink" title="行为模型"></a>行为模型</h3><ul><li>描述系统运行时的动态行为的模型，表示系统响应于所处环境的刺激所发生或可能发生的事情。</li><li>刺激：<code>数据</code>、<code>事件</code><ul><li>数据：一些数据到达必须由系统处理。</li><li>事件：某些触发系统处理的事件的发生。</li></ul></li></ul><h4 id="数据驱动的建模"><a href="#数据驱动的建模" class="headerlink" title="数据驱动的建模"></a>数据驱动的建模</h4><ul><li><p>数据驱动模型描述一个 <code>动作序列</code>，该动作序列涉及输入数据的处理和相关 <code>输出的产生</code>。</p><blockquote><p><code>输出的产生</code>：指系统的响应。</p></blockquote></li><li><p>处理序列的方法：</p><ul><li><code>时序图</code>：强调系统中的对象。</li><li><code>数据流图</code> (DFD)：关注于功能。</li></ul></li></ul><h4 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h4><ul><li>事件驱动模型表示系统对内、外部事件的响应方式。</li><li>基于事件的模型表示方法：状态图，表示系统状态和引起状态和引起状态改变的事件。其中状态图的表示如图 4-9 所示。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-9.png" alt="图4-9状态图"></p><center>图 4-9 状态图</center><h3 id="模型驱动工程"><a href="#模型驱动工程" class="headerlink" title="模型驱动工程"></a>模型驱动工程</h3><ul><li>模型驱动工程 (MDE) 起源于模型驱动体系结构 (MDA)，该体系由对象管理组织 (OMG) 提出。</li><li>支持者与反对方：<ul><li><code>支持者</code>：更高的抽象水平上考虑系统，不用关心实现细节，减少出错可能性，加速设计和实现过程，且可复用。</li><li><code>反对方</code>：并不是模型所支持的抽象都是正确的、可实现的。</li></ul></li></ul><h4 id="模型驱动体系结构"><a href="#模型驱动体系结构" class="headerlink" title="模型驱动体系结构"></a>模型驱动体系结构</h4><ul><li>计算独立模型 (CIM) — <code>领域建模</code> — 不同的 CIM 反映系统的不同方面。</li><li>平台独立模型 (PIM) — 表示静态系统结构和系统对内外事件的响应。</li><li>平台特定模型 (PSM) — PIM -&gt; PSM。如图 4-10 所示，为一个复合平台特定模型实例。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-10.png" alt="图4-10复合平台特定模型"></p><center>图 4-10 复合平台特定模型</center><h4 id="可执行-UML：xUML"><a href="#可执行-UML：xUML" class="headerlink" title="可执行 UML：xUML"></a>可执行 UML：xUML</h4><ul><li>为建立一 UML 可执行子集，模型类型可分为：<ul><li>领域模型：识别出系统的主要关注点，由 UML 的类图定义，包括对象、属性和关联。</li><li>类模型：定义类及它们的属性和操作。</li><li>状态模型：每一状态与一个类相关联，并且用来描述类的生命周期。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;在软工系列课程上，老师常提及的一条等式  &lt;code&gt;软件 = 程序 + 软件工程&lt;/code&gt; ( 或 &lt;code&gt;软件 = 程序 + 文档&lt;/code&gt;)，即一般情况讨论，一款软件产品的诞生之际总是伴随着一系列的软件过程。&lt;/p&gt;
&lt;p&gt;那么如何充分理解软件工程 (过程)？从本书作者理念出发，我所理解的即应该时刻对软件产品持有 &lt;code&gt;生命周期&lt;/code&gt; 的思维模式，将 &lt;code&gt;需求、建模、设计、实现、测试、维护&lt;/code&gt; 等工程阶段联系起来，以自身代入案例环境中，去模拟开展软件过程的一系列活动，而非割裂。而这样的动态过程中，不仅仅是枯燥地学习理论、方法，则更像是问题所需、问题导向的理论应用过程。&lt;/p&gt;
&lt;p&gt;当然，软件工程作为一门工程学科，学习过程的最大收获可以说是对 &lt;code&gt;项目思维模式&lt;/code&gt; 的掌握。譬如，我们可以抛开软件产品的范畴，谈谈现实生活的实例：假若你需要在一定时限内掌握一门新知识、任务，则我们的做法可以从调研、计划、布局、实施，直至验收，即类似的过程可复用软件工程的方法。&lt;/p&gt;
&lt;p&gt;最后，也是想声明的一点：学习软件工程的过程中，无可避免地将反映本人的一些观点、倾向，当然这也反映该学科需要 &lt;code&gt;多沟通&lt;/code&gt; 的特点，若有不恰当、错误之处，欢迎大伙出建议、斧正。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://www.kofes.cn/categories/Reading/"/>
    
    
      <category term="软件工程" scheme="http://www.kofes.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="需求工程" scheme="http://www.kofes.cn/tags/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="系统建模" scheme="http://www.kofes.cn/tags/%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="UML" scheme="http://www.kofes.cn/tags/UML/"/>
    
  </entry>
  
</feed>
