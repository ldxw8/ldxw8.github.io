<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KOFE&#39;S BLOG</title>
  
  <subtitle>Reading / Project / Research</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kofes.cn/"/>
  <updated>2018-05-29T16:19:19.710Z</updated>
  <id>http://www.kofes.cn/</id>
  
  <author>
    <name>Kofe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>论文 - 通过快速查找和发现密度峰值进行聚类</title>
    <link href="http://www.kofes.cn/2018/05/Clustering-by-fast-search-and-find-of-density-peaks.html"/>
    <id>http://www.kofes.cn/2018/05/Clustering-by-fast-search-and-find-of-density-peaks.html</id>
    <published>2018-05-27T01:43:41.000Z</published>
    <updated>2018-05-29T16:19:19.710Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p>原文：Clustering by fast search and find of density peaks<br>作者：Alex Rodriguez and Alessandro Laio<br>来源：Science 344.6191(2014), 1492-1496.</p></div><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>聚类分析的目的在于根据元素的相似性将元素分类。而该论文基于这样一种观点的提出新的方法，即聚类中心的密度高于其邻居，而密度高的点相对较远。这个想法构成了聚类过程的基础，其中簇的数量直观地产生，异常值被自动地发现并从分析中排除，并且聚类被识别，而不管它们的形状和嵌入它们的空间的维度如何。</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="不同的聚类策略"><a href="#不同的聚类策略" class="headerlink" title="不同的聚类策略"></a>不同的聚类策略</h3><h4 id="基于距离的方法"><a href="#基于距离的方法" class="headerlink" title="基于距离的方法"></a>基于距离的方法</h4><p>在 <code>K-means</code> 和 <code>K-medoids</code>，聚类是以距离聚类中心很小的距离为特征的数据集合。</p><p>然而，因为数据点总是被分配到最近的中心，所以该类算法只能发现球形的簇，而在发现任意形状的簇时会遇到困难。</p><blockquote><p>提示：<code>K-均值 (K-Means)</code> 的方法仅当簇中均值有定义时才有意义，而当涉及具有标称属性的数据时，K-均值的方法失效。而这里可采用 <code>K-众数 (K-Modes)</code> 的变体，即采用 <code>基于频率</code> 的方法来更新簇的众数，对具有标称属性的数据进行聚类。当然，还有 <code>K-Prototype</code> $^{[1,2]}$、<code>K-Means++</code> $^{[3]}$ 等优化版本的算法。</p></blockquote><h4 id="基于密度的方法"><a href="#基于密度的方法" class="headerlink" title="基于密度的方法"></a>基于密度的方法</h4><p>通过基于数据点局部密度的方法很容易检测具有任意形状的簇。其主要思想是：在某领域 (对象或数据点的数目) 内，给定密度阈值，将密度低于该阈值的数据点视为噪声丢弃，并将其分配给不连续的高密度领域的其他簇。这样的方法可用来过滤噪声或离群点，发现任意形状的簇。</p><p><code>DBSCAN</code> (Density-Based Spatial Clustering of Applications with Noise) 是一个基于密度的聚类算法，它将簇定义为密度相连的点的最大集合，能够把具有足够高密度的领域划分为簇。在噪声的空间数据库中可发现任意形状的聚类。</p><p>然而，从上述当中可知，除了要选择合适的阈值，且它缺少均值漂移的聚类方法。虽然这种方法允许发现非球形簇，但仅适用于由一组坐标定义的数据。</p><h4 id="本文改进的方法"><a href="#本文改进的方法" class="headerlink" title="本文改进的方法"></a>本文改进的方法</h4><p>首先，该算法提出假设：类簇中心被具有较低局部密度的 <code>邻居点</code> 包围，且与具有较高密度的 <code>任何点</code> 有相对较大的距离。对于每一个数据点 i，要计算 <code>两个量</code>：点的局部密度 $\rho_i$ 和该点到具有更高局部密度的点的距离 $\delta_i$。而这两个值都取决于数据点间的距离 ${d}_{ij}$ (欧几里得距离，也称 <code>欧式距离</code>)。数据点的局部密度定义为：</p><script type="math/tex; mode=display">\rho_i = \sum_j \chi(d_{ij} - d_c)</script><p>其中 $\chi(x)$ 为 0-1 函数，如果 x &lt; 0，那么 $\chi(x) = 1$；否则 $\chi(x) = 0$，$d_{c}$ 是一个 <code>截断距离</code>。基本上，$\rho_i$ 等于与点 i 的距离小于 $d_{c}$ 的点的个数。算法只对不同点 $\rho_i$ 的相对大小敏感，这意味着对于大数据集，分析结果在 $d_{c}$ 的选择方面具有很好 <code>鲁棒性</code>。</p><ul><li><p>$\delta_i$ 是通过计算点之间的 <code>最小距离</code> 来测量的，即数据点 i 与距离它最近的、密度更高的点 j 的距离最小值式：</p><blockquote><p>提示：在图 1-1.(A) 中可知，数据点是按照密度降序排列。</p></blockquote></li></ul><script type="math/tex; mode=display">\delta_i = min_{j:\rho_j>\rho_i}(d_{ij})</script><ul><li>若数据点 i 是密度最大的点，$\delta_i$ 为所有节点中到数据点 i 的最大距离：</li></ul><script type="math/tex; mode=display">\delta_i = max_j(d_{ij})</script><p>如图 1-1 所示，其展示了算法的核心思想。图 1-1.(A) 展示了二维空间中的 28 个点，<code>且 A 中数据点是按照密度降序排列</code>。图 1-1.(B) 中以 $\rho_i$ 作为横坐标，$\delta_i$ 作为纵坐标，画二维图，并称其为决策图。可以发现点 1 和点 10 的  $\rho_i$ 和 $\delta_i$ 最大，故将其作为类簇中心。</p><blockquote><p>点 9 和点 10 的 $\rho_i$ 相似，但 $\delta_i$ 值却有很大差别：点 9 属于点 1 的类簇，且有其它几个更高 $\rho_i$ 的点距其很近，然而点 10 拥有更高密度的最近邻属于其它的类簇。  </p><p>所以，正如预期的那样，只有具有高 $\delta_i$ 和相对较高 $\rho_i$ 的的点才是 <code>类簇中心</code>。因为点 26、27、28 是孤立的，所以有相对较高的 $\delta_i$ 值和低 $\rho_i$ 值，它们可以被看作是由单个点做成的类簇，也就是 <code>异常点</code>。</p></blockquote><p><img src="/images/illustration/Paper/2018/05/Clustering-by-fast-search-and-find-of-density-peaks_1-1.jpg" alt="图1-1算法在二维空间的展示"></p><center>图 1-1 算法在二维空间的展示</center><p>类簇中心找到后，剩余的每个点被归属到它的有更高密度的最近邻所属类簇。类簇分配只需 <code>一步即可完成</code>，不像其它算法要对目标函数进行 <code>迭代优化</code>。</p><p>在聚类分析中，定量的衡量分配的可信度是很重要的。在该算法中，首先为每个类簇定义一个 <code>边界区域</code> (即分配到该类簇的点集合，且与其它类簇的点的距离小于 $d_c$)，然后为每个类簇的找到其边界区域中密度最高的点 $\rho_b$，并以来表示该点的密度。若类簇中局部密度值比 $\rho_b$ 大的点被看作是类簇的核心部分 (即分配到该类簇的可靠性较高)，其他点 (类簇中局部密度值比 $\rho_b$ 小的点) 被看作是类簇的 <code>光晕部分</code> (亦可被看作是噪声)。</p><p><img src="/images/illustration/Paper/2018/05/Clustering-by-fast-search-and-find-of-density-peaks_1-2.jpg" alt="图1-2合成点分布的结果"></p><center>图 1-2 合成点分布的结果</center><p>(A) 为绘制点分布的概率分布。(B和C) 分分别为4000和1000样本点的点分布。且每个点以其颜色表示所属类簇，黑色点属于光晕类簇 (噪声点)。(D和E) 为 (B和C) 相应的决策图，其中心由相应簇来着色。(F) 作为样本维度的函数，分配给不正确聚类的点的分数。误差线表示平均值的标准误差。</p><p>从图 1-2.(F) 中可以看到，错分点的比例即使在只有 1000 个点的小样本中仍保持在 1% 以下，说明算法有很好的鲁棒性。</p><p>从图 1-3 中可以看到，该算法对于各种数据级都能达到很好的聚类效果 (图中为引用文献中的测试用例结果)。</p><p><img src="/images/illustration/Paper/2018/05/Clustering-by-fast-search-and-find-of-density-peaks_1-3.jpg" alt="图1-3引用文献中的测试用例结果"></p><center>图 1-3 引用文献中的测试用例结果</center><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] Huang Z. Clustering large data sets with mixed numeric and categorical values [C]. 1997: 21-34.<br>[2] Huang Z. Extensions to the k-means algorithm for clustering large data sets with categorical values [J]. Data mining and knowledge discovery, 1998, 2(3): 283-304.<br>[3] San O M, Huynh V N, Nakamori Y. A clustering algorithm for mixed numeric and categorical data [J]. Journal of Systems Science and Complexity, 2003, 16(4): 562-571.  </p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;原文：Clustering by fast search and find of density peaks&lt;br&gt;作者：Alex Rodriguez and Alessandro Laio&lt;br&gt;来源：Science 344.6191(2014), 1492-1496.&lt;/p&gt;&lt;/div&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;聚类分析的目的在于根据元素的相似性将元素分类。而该论文基于这样一种观点的提出新的方法，即聚类中心的密度高于其邻居，而密度高的点相对较远。这个想法构成了聚类过程的基础，其中簇的数量直观地产生，异常值被自动地发现并从分析中排除，并且聚类被识别，而不管它们的形状和嵌入它们的空间的维度如何。&lt;/p&gt;
    
    </summary>
    
      <category term="Paper" scheme="http://www.kofes.cn/categories/Paper/"/>
    
    
      <category term="数据挖掘" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="聚类" scheme="http://www.kofes.cn/tags/%E8%81%9A%E7%B1%BB/"/>
    
      <category term="密度" scheme="http://www.kofes.cn/tags/%E5%AF%86%E5%BA%A6/"/>
    
      <category term="监督学习" scheme="http://www.kofes.cn/tags/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>笔记 - 高级软件工程 &amp; 导论</title>
    <link href="http://www.kofes.cn/2018/05/Sofeware-Engineering.html"/>
    <id>http://www.kofes.cn/2018/05/Sofeware-Engineering.html</id>
    <published>2018-05-02T11:45:02.000Z</published>
    <updated>2018-05-19T12:31:23.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在软工系列课程上，老师常提及的一条等式  <code>软件 = 程序 + 软件工程</code> ( 或 <code>软件 = 程序 + 文档</code>)，即一般情况讨论，一款软件产品的诞生之际总是伴随着一系列的软件过程。</p><p>那么如何充分理解软件工程 (过程)？从本书作者理念出发，我所理解的即应该时刻对软件产品持有 <code>生命周期</code> 的思维模式，将 <code>需求、建模、设计、实现、测试、维护</code> 等工程阶段联系起来，以自身代入案例环境中，去模拟开展软件过程的一系列活动，而非割裂。而这样的动态过程中，不仅仅是枯燥地学习理论、方法，则更像是问题所需、问题导向的理论应用过程。</p><p>当然，软件工程作为一门工程学科，学习过程的最大收获可以说是对 <code>项目思维模式</code> 的掌握。譬如，我们可以抛开软件产品的范畴，谈谈现实生活的实例：假若你需要在一定时限内掌握一门新知识、任务，则我们的做法可以从调研、计划、布局、实施，直至验收，即类似的过程可复用软件工程的方法。</p><p>最后，也是想声明的一点：学习软件工程的过程中，无可避免地将反映本人的一些观点、倾向，当然这也反映该学科需要 <code>多沟通</code> 的特点，若有不恰当、错误之处，欢迎大伙出建议、斧正。</p><a id="more"></a><ul><li><p>参考书目：</p><ul><li>《 软件工程 》. Ian Sommerville 著：计算机科学丛书，且是著名软件工程学家 Ian Sommerille 系统介绍软件工程理论的经典教材。</li><li>《 构建之法(第二版) 》: 待整理。贴上本书豆瓣的书评，供朋友评判，做出抉择。<a href="https://book.douban.com/subject/26577755/" target="_blank" rel="noopener">构建之法(第二版)</a> </li></ul></li><li><p>更新进程</p><ul><li>2018.05.02 - 完成初稿；</li><li>2018.05.04 - 更新正文：导论部分  (第 4 / 8 章)；</li></ul></li></ul><h2 id="零-总览"><a href="#零-总览" class="headerlink" title="零 总览"></a>零 总览</h2><ul><li>软件工程导论<ul><li><a href="#壹-软件过程">壹 软件过程</a></li><li><a href="#贰-敏捷软件开发">贰 敏捷软件开发</a></li><li><a href="#叁-需求工程">叁 需求工程</a></li><li><a href="#肆-系统建模">肆 系统建模</a></li><li><a href="#">伍 体系结构设计</a></li><li><a href="#">陆 设计与实现</a></li><li><a href="#">柒 软件测试</a></li><li><a href="#">捌 软件进化 / 软件维护</a></li></ul></li><li>高级软件工程<ul><li><a href="#">玖 软件复用</a></li><li><a href="#">拾 基于组件的软件工程</a></li></ul></li><li>软件管理<ul><li><a href="#">拾壹 项目管理</a></li><li><a href="#">拾贰 项目规划</a></li></ul></li></ul><h2 id="壹-软件过程"><a href="#壹-软件过程" class="headerlink" title="壹 软件过程"></a>壹 软件过程</h2><ul><li>学习目标<ul><li>3个一般的 <code>软件过程模型</code>；</li><li>了解软件需求工程、开发、测试和进化中所涉及的 <code>基本过程活动</code>；</li><li>理解为什么软件过程要有效地组织以应对软件需求和设计上的变更；</li><li>Rational 统一过程 (RUP).</li></ul></li><li>软件过程必须具有的基本活动<ul><li>软件描述</li><li>软件设计和实现</li><li>软件有效性验证</li><li>软件进化</li></ul></li><li>没有“理想”的软件过程 — 寻找平衡点<ul><li>计划驱动过程：提前计划好所有的过程活动，再按计划去考核过程的执行。</li><li>敏捷过程：计划是增量式的，且容易根据不断变化的客户需求变更过程。更多详细内容见 <code>第叁章</code>。</li></ul></li></ul><h3 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h3><ul><li>软件过程：产生一个软件系统的一系列活动。</li><li>软件过程的简化表示 (抽象表示)。</li><li><p>每个过程模型都是从一个特定的侧面表现软件过程，所以只提供过程的部分信息。</p><blockquote><p>如过程活动模型表现了这些活动和他们的顺序，但可能表现不出人们在这些活动中的角色。</p></blockquote></li></ul><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-1.png" alt="图1-1瀑布模型"></p><center>图 1-1 瀑布模型</center><ul><li>计划驱动模型；</li><li>该模型将基本的过程活动、描述、开发、有效性验证和进化，看成是一些界限分明的独立的过程阶段。<ul><li>需求分析和定义：通过咨询系统用户建立系统的服务、约束和目标，并对其详细定义形成系统描述。</li><li>系统和软件设计<ul><li>系统设计 — 建立系统的总体体系结构，将需求区分为硬件需求和软件需求。</li><li>软件设计 — 识别和描述一些基本的软件系统抽象及其之间的关系。</li></ul></li><li>实现和单元测试<ul><li>软件设计实现 — 实现为一组程序或程序单元。</li><li>单元测试 — 验证每个单元是否符合其描述。</li></ul></li><li>集成和系统测试<ul><li>集成 — 集成单个的程序单元或一组程序。</li><li>系统测试 — 评估系统的可靠性；是否满足软件需求。</li></ul></li><li>运行和维护</li></ul></li></ul><h4 id="增量式开发"><a href="#增量式开发" class="headerlink" title="增量式开发"></a>增量式开发</h4><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-2.png" alt="图1-2增量式开发"></p><center>图 1-2 增量式开发</center><ul><li>即可是计划驱动的，也可是敏捷方法的。<ul><li>系统增量是提前定义好的，即为 <code>计划驱动方法</code>。</li><li>最初的增量是定义好的，但往后的增量的开发取决于项目的进展情况及客户的优先选择，即为 <code>敏捷方法</code>。</li></ul></li><li>系统的开发是建立一系列的版本 (增量) 每个版本添加部分功能到先前版本中。</li><li>增量式开发的特性<ul><li>降低了适应用户需求变更的成本。</li><li>开发过程中及时得到用户已做的开发工作的反馈意见。</li><li>更快地交付和部署有用的软件到客户方。</li></ul></li></ul><h4 id="面向复用的软件工程"><a href="#面向复用的软件工程" class="headerlink" title="面向复用的软件工程"></a>面向复用的软件工程</h4><p>基于复用开发的一般过程模型如图 1-3 所示。初始需求描述阶段、有效性验证阶段与其他过程差不多，面向复用过程的中间阶段是不同的。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-3.png" alt="图1-3面向复用的软件工程"></p><center>图 1-3 面向复用的软件工程</center><ul><li>中间阶段：即组件分析、需求修改、使用复用的系统设计、开发和集成阶段。<ul><li>组件分析：需求描述 -&gt; 搜组件 (往往只提供所需的部分功能)。</li><li>需求修改：根据得到组件信息分析需求，再修改需求以反映可得到的组件。</li><li>使用复用的系统设计：设计系统的框架或者重复使用一个已存在的框架。</li><li>开发和集成</li></ul></li></ul><h3 id="过程活动"><a href="#过程活动" class="headerlink" title="过程活动"></a>过程活动</h3><h4 id="软件描述"><a href="#软件描述" class="headerlink" title="软件描述"></a>软件描述</h4><ul><li>软件描述或需求工程是理解和定义系统需要提供什么样的服务，以及找出开发和运行中受到哪些约束。</li><li>需求工程过程的主要阶段，如图 1-4 所示。<ul><li>可行性研究</li><li>需求导出和分析</li><li>需求描述</li><li>需求有效性验证</li></ul></li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-4.png" alt="图1-4需求工程过程"></p><center>图 1-4 需求工程过程</center><h4 id="软件设计和实现"><a href="#软件设计和实现" class="headerlink" title="软件设计和实现"></a>软件设计和实现</h4><ul><li>软件设计和实现阶段是把系统描述转换成一个可运行的系统的过程。</li><li>软件设计是对实现软件的结构、系统的数据、系统组件间的接口以及所用的算法的描述。这是一反复、迭代的过程。</li></ul><h4 id="软件有效性验证"><a href="#软件有效性验证" class="headerlink" title="软件有效性验证"></a>软件有效性验证</h4><ul><li>程序测试：用模拟测试数据运行系统。</li><li>测试过程各阶段<ul><li>组件 (单元) 测试：每个组件单独测试；组件可是简单实体，如函数、对象类或这些实体的集合。</li><li>系统测试：集成组件形成完整系统，对组件组成的子系统测试。</li><li>接收测试：客户提供真实数据测试系统。</li></ul></li></ul><h4 id="软件进化-软件维护"><a href="#软件进化-软件维护" class="headerlink" title="软件进化/软件维护"></a>软件进化/软件维护</h4><p>软件工程不再是开发和维护两个独立的过程，而是一个进化过程。即软件在其生命内不断随着需求的变更而变更的进化式过程。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-5.png" alt="图1-5系统进化"></p><center>图 1-5 系统进化</center><h3 id="应对变更"><a href="#应对变更" class="headerlink" title="应对变更"></a>应对变更</h3><ul><li>有效降低变更成本<ul><li>变更避免：预测变更，如 <code>原型系统</code> 的开发，客户试用原型，在花费高额的软件生产成本之前重新定义需求。</li><li>变更容忍：<code>增量开发</code>，即使单个增量(系统一小部分)的修改来适应变更，以较低成本处理变更。</li></ul></li><li>应对变更系统需求的方法<ul><li>系统原型：快速开发一个系统版本或系统一部分，以检验客户需求和某些设计决定的可行性，即它支持 <code>变更避免</code>。</li><li>增量交付：系统增量地交付给用户，给用户评审和试用。即它支持 <code>变更避免</code> 和 <code>变更容忍</code>。</li></ul></li></ul><h4 id="原型构造"><a href="#原型构造" class="headerlink" title="原型构造"></a>原型构造</h4><ul><li>原型是一个软件系统的最初版本，用于验证概念、试用设计选项、发现更多的问题和可能的解决方法。</li><li><p>原型开发的过程模型如图 1-6 所示。</p><p>  <img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-6.png" alt="图1-6原型开发的过程"></p>  <center>图 1-6 原型开发的过程</center><blockquote><p>最后一阶段：原型评估，则必须安排用户培训，应根据原型的目标制定一个评估计划。即用户需习惯并适用新系统，一旦他们自然地使用了系统，将可能发现错误和被遗漏的需求。</p></blockquote></li><li><p>不强求原型是可执行的。</p><blockquote><p>基于纸质的模型系统的用户界面，用户和这个界面交互，但他们的请求被传递给一个人，该人员解释此请求并输出相应的响应。</p></blockquote></li></ul><h4 id="增量式交付"><a href="#增量式交付" class="headerlink" title="增量式交付"></a>增量式交付</h4><ul><li><p>增量式开发是软件开发的一种方法，如图 1-7 所示。</p><p>  <img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-7.png" alt="图1-7增量式交付"></p>  <center>图 1-7 增量式交付</center></li><li><p>增量式开发过程的好处</p><ul><li>早期的增量作为原型，从中获得对后面系统增量的需求经验。</li><li>每一增量会满足他们大多数需求，即软件马上就能使用。</li><li>具有高优先权的服务被首先交付，而后继有增量不断被集成进来，使得最重要的系统服务接受了多次测试。</li></ul></li><li>增量式交付存在的问题<ul><li>软件描述和软件本身一起开发是迭代过程的本质。在增量方法中，直到最后的增量描述完成，才会有完整的系统描述。而许多机构 (如政府) 的采购模型是，系统开发合同中附带完整的系统描述，即相互冲突。</li><li>旧系统的所有功能与新系统的部分功能，多数用户宁可选前者，即获取反馈较困难。</li></ul></li></ul><h4 id="Boehm-的螺旋模型"><a href="#Boehm-的螺旋模型" class="headerlink" title="Boehm 的螺旋模型"></a>Boehm 的螺旋模型</h4><ul><li>风险驱动的软件过程框架 (螺旋模型)<ul><li>在螺旋线中每个回路表示软件过程的一个阶段，如最里的回路可能与系统可行性研究有关，下一回路与系统需求定义有关等。</li><li>螺旋线中每个回路被分成4部分：<br>1) 目标设置<br>2) 风险评估和规避<br>3) 开发和有效性验证<br>4) 规划  </li></ul></li></ul><h3 id="Rational-统一过程"><a href="#Rational-统一过程" class="headerlink" title="Rational 统一过程"></a>Rational 统一过程</h3><ul><li>RUP 一般从3个视角描述过程<ul><li>动态视角：给出模型中随时间所经历的各个阶段。</li><li>静态视角：给出所进行的过程活动。</li><li>实践视角：提出在过程中可采用的良好实践建议。</li></ul></li><li><p>RUP 是一阶段化模型，如图 1-8 所示。</p><ul><li>开端  <ul><li>目标是建立系统的一个业务案例。  </li><li>识别所有与系统交互的外部实体 (人和系统) 并定义这些交互。</li><li>适用这些信息评估系统对业务的贡献，若贡献微小，那么项目在此阶段结束。</li></ul></li><li>细化<ul><li>目标是增进对问题域的理解，建立系统的体系框架，给出项目计划并识别关键项目风险。</li><li>输出系统的需求模型 (描述的用例、体系结构描述及开发计划)。</li></ul></li><li>构造：系统设计、编程和测试。</li><li><p>转换：将系统从开发单位转移到用户单位，并使之在真实环境中工作。</p><blockquote><p>1) RUP 中的阶段是紧密与业务关联，而不是与技术层面关联。<br>2) RUP 把 <code>阶段</code> (开端、细化、构造、转换) 和 <code>工作流</code> (需求、分析、设计…) 分离，即各种 RUP 工作流在整个过程的所有阶段都是可能存放的。  </p></blockquote><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-8.png" alt="图1-8Rational统一过程的各阶段"></p><center>图 1-8 Rational 统一过程的各阶段</center></li></ul></li><li><p>实践视角</p><ul><li>迭代地开发软件；</li><li>对需求的管理：记录并跟踪客户的需求；</li><li>使用基于组件的体系结构，将系统体系结构组织成组件形态；</li><li>可视化地建模软件：UML 模型表现软件的静态、动态视图；</li><li>检验软件质量；</li><li>控制对软件的变更：变更管理系统、配置管理程序和工具来管理软件的变更。</li></ul></li><li><p>静态视角</p><ul><li>聚焦在开发过程中所发生的活动上，这些在 RUP 描述中被称为工作流。</li><li><p>此过程中包含6个核心过程工作流，3个核心支持工作流，见图 1-9 所示。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-9.png" alt="图1-9RUP中的静态工作流"></p><center>图 1-9 RUP 中的静态工作流</center></li></ul></li></ul><h2 id="贰-敏捷软件开发"><a href="#贰-敏捷软件开发" class="headerlink" title="贰 敏捷软件开发"></a>贰 敏捷软件开发</h2><div class="note success"><p> 开始敏捷开发篇章前，引入一有趣的例子。Jazz Band 模式，跟 “敏捷的开发模式” 类似，同样也可以产生优秀的作品。( 演奏中，Miles Davis 先用小号吹出主题 ( 类比为架构师 )，然之后到一旁抽烟。曲目交由其他人员即兴发挥。最后， Miles Davis 加入演奏，回应主题 )。</p><p>感兴趣的可以观看视频：<a href="http://v-wb.youku.com/v_show/id_XMTUzNzUxOTEwNA==.html" target="_blank" rel="noopener">Miles Davis So What</a> </p></div><ul><li>学习目标<ul><li>理解敏捷软件开发方法的基本原理、核心内涵，以及它与计划驱动软件开发方法的差别；</li><li>极限编程；</li><li>理解敏捷项目管理的 <code>Scrum</code> 方法；</li><li>应用伸缩的敏捷方法时的事项和问题 -&gt; 大型软件系统开发过程.</li></ul></li></ul><h3 id="敏捷方法"><a href="#敏捷方法" class="headerlink" title="敏捷方法"></a>敏捷方法</h3><ul><li>敏捷方法是一种专注于快速开发的 <code>增量式开发</code>，<code>频繁地发布软件</code>、<code>降低过程开销</code>、生产高质量代码。他们使用户直接参与到开发过程中。</li><li><p>敏捷方法的基本原理体现在 <code>敏捷宣言</code> 中：</p><ul><li>个体和交互胜过工具和过程；</li><li>编写软件胜过书写详尽文档；</li><li>用户合作胜过合同谈判；</li><li><p>响应变更更胜过遵循计划.</p><blockquote><p>即我们更重视左边的项的价值，虽左右两边的项都有价值。</p></blockquote></li></ul></li><li><p>大量的软件工程努力维护和进化现有的软件系统，而由敏捷方法的特性可知，敏捷方法维护的问题有：</p><ul><li>软件交付后的主要困难可能是继续让用户参与到过程中。</li><li>保持开发团队的持续性，因没有参考文档可循，若一个敏捷开发团队解散了，则 <code>依赖于团队成员理解系统</code> 的 <code>隐式知识</code> 旧丢失了。</li></ul></li><li>混成方法：敏捷方法嵌入来自计划计划驱动式开发的某些技术。</li></ul><h3 id="计划驱动开发和敏捷开发"><a href="#计划驱动开发和敏捷开发" class="headerlink" title="计划驱动开发和敏捷开发"></a>计划驱动开发和敏捷开发</h3><p>计划驱动和敏捷描述如图 2-1 所示。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_2-1.png" alt="图2-1计划驱动和敏捷描述"></p><center>图 2-1 计划驱动和敏捷描述</center><ul><li>敏捷方法：<ul><li>迭代发生在所有活动间。</li></ul></li><li><p>计划驱动方法：</p><ul><li><p>迭代发生在各个活动中，用 <code>正式文件</code> 在软件过程中各阶段间沟通。</p><blockquote><p><code>正式文件</code>：可视化作为各阶段的输出产物。</p></blockquote></li></ul></li><li>在计划驱动和敏捷方法之间得到平衡，必须回答以下一些技术的、人员的和机构方面的问题。<ul><li>详尽的描述和设计 -&gt; <code>计划驱动开发</code></li><li>交互用户并快速取得反馈 -&gt; <code>敏捷开发</code></li><li>开发系统的规模；</li><li>开发的系统类型，如有复杂时序需求的实时系统，通常需要相当详细的设计来实现分析 -&gt; <code>计划驱动开发</code></li><li>预想的系统寿命有多长；</li><li>什么样的技术支持系统开发 (敏捷方法通常依赖于工具，以跟踪设计进化)；</li><li>开发团队的组织情况；</li><li>影响系统开发的文化问题 (传统的工程机构有计划驱动的文化)；</li><li>开发团队的成员专业水平；</li><li>系统是否受制于外部法规 (如联邦的航空管理局 FAA 核准一个安全性要求极高的航空操作软件)；</li></ul></li></ul><h3 id="极限编程-XP"><a href="#极限编程-XP" class="headerlink" title="极限编程 (XP)"></a>极限编程 (XP)</h3><ul><li>极限编程所属敏捷方法，它集成了一系列好的编程经验。例如，频繁地软件发布、连续软件改善和客户参与到软件开发团队。</li><li>XP 中，所有的需求都表示为脚本 (称为用户故事情节)，它将直接实现为一系列任务。</li><li>一个 XP 过程，产生了正在开发的系统的一个增量，具体如图 2-2 所示。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_2-2.png" alt="图2-2极限编程的版本循环"></p><center>图 2-2 极限编程的版本循环</center><ul><li>脚本卡是 XP 规划过程的主要输入。<ul><li>开发团队把每个 <code>脚本</code> 拆分成 <code>任务</code>，并估计实现所需人力资源。</li><li>与客户交谈，定义需求，对脚本进行优先权排序。</li></ul></li></ul><h4 id="极限编程中的测试"><a href="#极限编程中的测试" class="headerlink" title="极限编程中的测试"></a>极限编程中的测试</h4><ul><li>很多增量开发方法的测试过程是很不规范的。</li><li>为避免一些测试和系统验证方面的问题，XP 方法更加强调测试过程。</li><li>XP 当中测试的关键特性：<ul><li>测试优先的开发 (先写测试程序再写代码)；</li><li>来自脚本的增量式测试开发；</li><li>用户参与测试开发和有效性验证；</li><li>自动测试系统的使用。将测试写成了可执行的组件，该测试组件是独立的。自动测试框架即是这样的一个系统。譬如 Eclipse 的 JUnit，JUnit 用于单元测试。</li></ul></li></ul><h4 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h4><p>结对编程是有一些质量效益，但却不足以抵消它的开销。但信息共享在结对编程是很重要的，因为当有团队成员离开时，它降低了项目风险。</p><h3 id="敏捷项目管理"><a href="#敏捷项目管理" class="headerlink" title="敏捷项目管理"></a>敏捷项目管理</h3><ul><li>项目管理的标准：计划驱动。</li><li><p>适合增量开发 (敏捷方法) 的管理方法 (框架)：<code>Scrum</code>。</p><ul><li><p>Scrum 的管理过程如图 2-3 所示。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_2-3.png" alt="图2-3Scrum的管理过程"></p><center>图 2-3 Scrum 的管理过程</center></li><li><p>Scrum 的 3 个阶段</p><ul><li>规划纲要阶段：建立大致的项目目标和设计软件体系结构。</li><li>冲刺循环阶段：<ul><li>每个循环开发出一个系统增量；</li><li>每个循环为一个计划单元，其中的工作有评估、特征选择和开发、软件实现；</li></ul></li><li>项目结束阶段：完善文档，如系统帮助和用户手册。</li><li><p>冲刺循环阶段的特征：</p><ul><li>冲刺有固定长度，一般是 2-4 周，在 XP 过程中对对应与一个系统版本的开发。</li><li>规划的起点，即积压的任务 (Backlog)，也是项目中要完成的工作清单。</li><li>评估阶段：Backlog 需经过审查，并对它们进行优先级排序和风险指派。</li><li>选择阶段：项目所有成员都要参加，和用户一起选择冲刺循环中要开发的特性和功能。</li><li>开发阶段：达成共识将组织进行软件开发，每一天团队开发成员参与段时间会议，回顾开发过程，若有必要重新安排工作。且在此阶段开发团队是隔离于客户和机构的。</li><li><p>冲刺循环阶段结束，对已做工作复查并交付给用户。</p><blockquote><p>所有交流都是通过 <code>Scrum Master</code> 进行，SM 可理解为调解人。体现了 Scrum 的思想，即整个团队被赋予决定的权利。</p></blockquote></li></ul></li></ul></li><li><p>Scrum 适合分布式的开发环境。</p></li></ul></li></ul><h3 id="可扩展的敏捷方法"><a href="#可扩展的敏捷方法" class="headerlink" title="可扩展的敏捷方法"></a>可扩展的敏捷方法</h3><ul><li>敏捷方法的开发是为同一房间办公与交流的小团队开发使用，因此常被用于小型系统开发。</li><li>可伸缩的敏捷方法也可适用于开发大型系统。</li><li>大型、小型系统开发的区别 (可理解为可扩展的敏捷方法应用于大型系统的挑战)。<ul><li>大型系统经常由独立的、交互的子系统组成。不同团队独立开发不同子系统，且团队可能在不同地点或不同时区工作。</li><li>大型系统包含了一系列的已存在的系统并与它们进行交互，许多系统需求关注这种交互。</li><li>当一个系统由多个系统集成产生时，开发工作中重要部分是系统配置而不是原始代码开发。这不一定与增量式开发和频繁的系统集成兼容。</li><li>大型系统通常具有不同的信息持有者，将不同的信息持有者加入开发流程中是必要的。</li></ul></li><li>伸缩的敏捷方法的两个观点<ul><li>照搬放大，即关注如何将这些方法应用到哪些 <code>小团队</code> 无法开发的 <code>大型项目</code> 中。</li><li>渗透，即关注如何将敏捷方法介绍 <code>推广</code> 到拥有多年开发经验的 <code>大机构</code> 中。</li></ul></li></ul><h2 id="叁-需求工程"><a href="#叁-需求工程" class="headerlink" title="叁 需求工程"></a>叁 需求工程</h2><ul><li><p>学习目标</p><ul><li>了解用户需求、系统需求；</li><li>了解功能需求、非功能需求；</li><li>如何在软件需求文档中 <code>机构需求</code>；</li><li>了解需求工程活动的内容及他们之间的关系；</li><li>了解需求管理.</li></ul></li><li><p>一些概念</p><ul><li><p>用户需求：用自然语言加图的形式给出的关于系统 <code>需要提供</code> 哪些服务及系统操作受到哪些 <code>声明的约束</code>。</p><blockquote><p>高层 (抽象) 的概要需求。</p></blockquote></li><li><p>系统需求：详细给出系统 <code>将要提供</code> 的服务及系统所受到的约束。系统的需求文档也称功能描述。</p><blockquote><p>系统应提供哪些服务的详细描述。</p></blockquote></li></ul></li></ul><h3 id="功能需求与非功能需求"><a href="#功能需求与非功能需求" class="headerlink" title="功能需求与非功能需求"></a>功能需求与非功能需求</h3><ul><li>功能需求<ul><li>描述系统所提供的功能或服务。</li><li>若是用户需求，就要用可以被系统用户理解的一种抽象方法描述功能需求。</li><li>更具体的功能性系统需求则需要详细地描述系统功能、异常、输入和输出。</li></ul></li><li><p>非功能需求</p><ul><li>指那些不直接关系到系统向用户提供的具体服务的一类需求。简言之，他们对 <code>系统实现</code> 定义了 <code>约束</code>，如 I/O 设备的能力、与其他系统接口的数据的表示。</li><li><p>非功能性系统需求：通常会从总体上规范或约束系统的特性。</p><blockquote><p>若一个非功能系统需求没有满足则可能使整个系统无法使用。</p></blockquote></li><li><p>非功能需求分类：表明非功能需求或是来源于所要求的软件特性 (产品需求)，或是来源于开发软件的机构 (机构需求)，或是来源于外部来源。如图 3-1 所示。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_3-1.png" alt="图3-1非功能需求的类型"></p><center>图 3-1 非功能需求的类型</center></li></ul></li></ul><h3 id="软件需求文档"><a href="#软件需求文档" class="headerlink" title="软件需求文档"></a>软件需求文档</h3><ul><li>如表 3-1 所示，是基于 IEEE 标准的需求文档的结构。<ul><li>需求文档中内容的详细程序，取决于所要开发的系统的类型及所使用的开发过程。</li></ul></li></ul><center>表 3-1 需求文档结构</center><div class="table-container"><table><thead><tr><th style="text-align:left">章节</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">绪言</td><td style="text-align:left">定义文档的读者对象，说明版本的修正历史，包括新版本为什么要创建，每个版本间的变更内容的概要</td></tr><tr><td style="text-align:left">引言</td><td style="text-align:left">描述为什么需要该系统，简要描述系统的功能，解释系统是如何与其他系统协同工作的。描述该系统在机构总体业务目标和战略目标中的位置和作用</td></tr><tr><td style="text-align:left">术语</td><td style="text-align:left">定义文档中的技术术语和词汇。假设文档读者是不具有专业知识和经验的人</td></tr><tr><td style="text-align:left">用户需求定义</td><td style="text-align:left">这一部分要描述系统应该提供的服务以及非功能系统需求，该描述可以使用自然语言、图表或者其他各种客户能理解的标记系统。产品和过程必须遵循的标准也要在此定义</td></tr><tr><td style="text-align:left">系统体系结构</td><td style="text-align:left">这一部分要对待建系统给出体系结构框架，该体系结构要给出功能在各个模块中的分布。能被复用的结构中组件要用醒目方式示意出来</td></tr><tr><td style="text-align:left">系统需求描述</td><td style="text-align:left">这一部分要对功能和非功能需求进行详细描述。如有必要，对非功能需求要再进一步描述，例如定义与其他系统间的接口</td></tr><tr><td style="text-align:left">系统模型</td><td style="text-align:left">这一部分要提出一个或多个系统模型，以表达系统组件、系统以及系统环境之间的关系。这些模型可以是对象模型、数据流模型和语义数据模型</td></tr><tr><td style="text-align:left">系统进化</td><td style="text-align:left">这一部分要描述系统基于的基本设想和定位以及硬件和用户需求改变时所要做的改变。这部分对系统设计人员来说是有用的，因为这有助于他们避免一些设计决策，这些决策可能会限制未来系统的变更</td></tr><tr><td style="text-align:left">附录</td><td style="text-align:left">这一部分要提供与开发的应用有关的详细、专门的信息。该附录的例子是硬件和数据库的描述，硬件需求定义了系统最小和最优配置，数据库需求定义了系统所用的数据的逻辑结构和数据之间的关系</td></tr><tr><td style="text-align:left">索引</td><td style="text-align:left">可以包括文档的几个索引。除了标准的字母顺序索引外，还可以有图标索引、功能索引等</td></tr></tbody></table></div><h3 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h3><ul><li>即在需求文档中写下用户需求和系统需求。<ul><li>用户需求：从用户角度来描述系统功能需求和非功能需求，一般用自然语言、图形叙述。</li><li>系统需求：<ul><li>用户需求的扩展；</li><li>软件工程师开始系统设计的起点；</li><li>解释如何能让系统提供用户需求.</li></ul></li></ul></li><li><p>原则上系统需求应 <code>反描述</code> 系统的 <code>外部行为</code> 和对它的 <code>操作限制</code>，而不是描述系统如何设计、实现。</p><blockquote><p>当然，并不是不提及任何设计信息，这也是不可能的，例如系统初始的体系结构设计。</p></blockquote></li></ul><h4 id="自然语言描述"><a href="#自然语言描述" class="headerlink" title="自然语言描述"></a>自然语言描述</h4><ul><li>在使用自然语言书写需求时，为了尽力 <code>减少误解</code>，应有一些简单的指导原则：<ul><li>设计一个 <code>标准格式</code>，并保证所用的需求定义都遵循此格式书写。</li><li>使用一致性的语言来区分强制性需求和可选性需求。<ul><li>强制性需求：必须支持的，定义时使用 <code>必须</code>。</li><li>可选性需求：不是必要的，定义时使用 <code>应该</code>。</li></ul></li><li>对文本加亮 (粗体、斜体、颜色) 来突出显示关键性需求。</li><li>避免使用专业术语和缩写语 (无法避免时应该在有标注说明)。</li><li>任何情况下，都应尝试把需求原理和每一个用户需求联系起来。</li></ul></li></ul><h4 id="结构化描述"><a href="#结构化描述" class="headerlink" title="结构化描述"></a>结构化描述</h4><ul><li>使用结构化方法来描述系统需求，则先为需求定义一个或多个的 <code>标准模板</code>，并将模板表示成结构化的表格形式。如表 3-2 所示，是胰岛素泵需求的结构化描述。</li></ul><center>表 3-2 胰岛素泵需求的结构化描述</center><div class="table-container"><table><thead><tr><th style="text-align:left">项目名称</th><th style="text-align:left">胰岛素泵/控制软件/SRS/3.3.2</th></tr></thead><tbody><tr><td style="text-align:left">功能</td><td style="text-align:left">计算胰岛素剂量；安全的胰岛素水平</td></tr><tr><td style="text-align:left">描述</td><td style="text-align:left">计算所要传输的胰岛素剂量，这是在当前度量的血糖水平处于 3-7 个单位之间这样正常范围之内时的胰岛素计算</td></tr><tr><td style="text-align:left">输入</td><td style="text-align:left">当前血糖读数 (r2)，先前的两个读数 (r0, r1)</td></tr><tr><td style="text-align:left">来源</td><td style="text-align:left">来自传感器的当前血糖读数。其他读数来自内存</td></tr><tr><td style="text-align:left">输出</td><td style="text-align:left">CompDose：所要传输的胰岛素剂量</td></tr><tr><td style="text-align:left">目的地</td><td style="text-align:left">主控制循环</td></tr><tr><td style="text-align:left">行动</td><td style="text-align:left">如果血糖水平是稳定的或往下掉或是上升但速率下降，则 CompDose 为 0。若血糖的水平是在上升且上升速率也上升，那么 CompDose 的计算方法是求当前血糖水平和先前血糖水平，再除以 4 并取整。若取整的结果为 0，那么 CompDose 就被设置成可以传输的最小剂量</td></tr><tr><td style="text-align:left">需求</td><td style="text-align:left">两个先前的读数，这样血糖变化速率就可以计算出来了</td></tr><tr><td style="text-align:left">前置条件</td><td style="text-align:left">胰岛素池容纳至少是单个传输剂量的最大值</td></tr><tr><td style="text-align:left">后置条件</td><td style="text-align:left">r0 被 r1 替换，然后 r1 被 r2 替换</td></tr><tr><td style="text-align:left">副作用</td><td style="text-align:left">无</td></tr></tbody></table></div><ul><li>标准格式描述功能需求时，应包括下列信息：<ul><li>关于所定义的功能或实体的描述；</li><li>关于输入及输入来源的描述；</li><li>关于输出及输出去向的描述；</li><li>关于计算所需要的信息及系统中所使用的其他实体信息；</li><li>关于所采取的行动的描述；</li><li>如果使用一个功能方法，前置条件、后置条件的设定描述；</li><li>关于操作的副作用，没有则填写无.</li></ul></li></ul><h3 id="需求工程过程"><a href="#需求工程过程" class="headerlink" title="需求工程过程"></a>需求工程过程</h3><ul><li>需求工程过程包括4个高层活动：<ul><li>系统可行性研究：评估系统是否对业务有用。</li><li>需求导出和分析：需求发现。</li><li>需求描述：将需求转变为某种标准格式描述。</li><li>需求有效性验证：检验需求是否正确地定义了客户所希望的系统。</li></ul></li><li>在实际需求工程是一个活动相互交错的迭代过程，如图 3-2 体现了这种交错性。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_3-2.png" alt="图3-2需求工程过程的螺旋模型"></p><center>图 3-2 需求工程过程的螺旋模型</center><h3 id="需求导出和分析过程"><a href="#需求导出和分析过程" class="headerlink" title="需求导出和分析过程"></a>需求导出和分析过程</h3><ul><li>反复的过程，也可看做是一种 <code>螺旋式活动</code>。</li><li>需求发现 (需求导出)<ul><li>对准备建立的系统和正使用的系统进行信收集，并从中提取用户需求和系统需求的过程。</li><li>与 <code>信息持有者</code> 通过交谈和观察进行交互，即可使用 <code>用例</code> 和 <code>原型</code> 来帮助对方理解系统。</li></ul></li><li>采访<ul><li>封闭式采访：即信息持有者回答一组 <code>锁定的问题</code>。</li><li>开放式采访：需求工程团队 <code>即兴访问</code>，更深层次了解对方需求是什么。</li></ul></li><li>脚本<ul><li>脚本是对 <code>交互实例片段</code> 的描述。</li><li>脚本开始于一个 <code>交互框架</code>，在导出过程中细节增加，直至产生一完整的交互描述。</li><li>脚本的内容<ul><li>开始部分有一系统和用户期望的描述；</li><li>标准事件流的描述；</li><li>处理错误的描述；</li><li>完成后系统状态的描述.    </li></ul></li></ul></li><li>用例<ul><li>统一建模语言 (UML) 的基本特征。</li><li>用例的集合代表所有将会在系统需求中出现的交互。过程中的角色可为人、其他系统等。</li><li>UML 对于面向对象模型来说，是一约定俗成的标准，因此基于用例的导出被广泛应用于需求导出中。</li></ul></li><li>深入实际：如图 3-3 所示的需求分析的深入实际方法和原型法。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_3-3.png" alt="图3-3需求分析的深入实际方法和原型法"></p><center>图 3-3 需求分析的深入实际方法和原型法</center><h3 id="需求有效性验证"><a href="#需求有效性验证" class="headerlink" title="需求有效性验证"></a>需求有效性验证</h3><ul><li>有效性检查：任何一组需求都不可避免地要在不同用户之间协商。</li><li>一致性检查：需求不应该彼此冲突。</li><li>完备性检查：需求文档应包括所有系统用户想要的功能和约束。</li><li>真实性检查：检查需求以保证需求能真正实现。</li><li>可检验性检查：检查方法 -&gt; 验证需交付的系统 -&gt; 满足定义的需求。<ul><li>需求评审：主要是错误检查和不一致检查。</li><li>原型建立：提供一可执行的系统模型，客户和最终用户在此基础检查系统。</li><li>测试用例生成。</li></ul></li></ul><h3 id="需求管理"><a href="#需求管理" class="headerlink" title="需求管理"></a>需求管理</h3><ul><li>大型软件系统的需求总是在变化的，即开发这些系统需满足某些棘手问题，则这些问题不可能被完全定义。如图 3-4 所示为需求进化的过程。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_3-4.png" alt="图3-4需求进化过程"></p><center>图 3-4 需求进化过程</center><h4 id="需求管理规划"><a href="#需求管理规划" class="headerlink" title="需求管理规划"></a>需求管理规划</h4><ul><li>需求识别：每一需求有 <code>唯一标识码</code>。</li><li>变更管理过程：变更带来的影响和成本的评估活动。</li><li>可追溯策略：<code>策略</code> 定义了需求间和需求与系统设计间的 <code>关系</code>；关系是要记录的，并附有记录的 <code>维护方法</code>。</li><li><p>工具支持</p><ul><li>需求存储</li><li>变更管理：如图 3-5 所示，即变更过程由有效工具来支持。</li><li><p><code>可追溯性</code> 管理：需求间的 <code>关联</code> &lt;- 自然语言处理技术 (NLP)</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_3-5.png" alt="图3-5需求变更管理"></p><center>图 3-5 需求变更管理</center></li></ul></li></ul><h4 id="需求变更管理"><a href="#需求变更管理" class="headerlink" title="需求变更管理"></a>需求变更管理</h4><ul><li>问题分析和变更描述：问题或变更 -&gt; 检验有效性 -&gt; 反馈变更请求者 -&gt; 导致两种结果：<ul><li>更加详尽的需求变更、提议；</li><li>取消本次变更.</li></ul></li><li>变更分析和成本计算：需求文档修改、系统设计和实现的成本估算。</li><li>变更实现：与编写程序类似，文档的 <code>可追溯性</code> 即 <code>关联性</code> 是通过最小化外部引用和尽量使之模块化来实现的。</li></ul><h2 id="肆-系统建模"><a href="#肆-系统建模" class="headerlink" title="肆 系统建模"></a>肆 系统建模</h2><ul><li>学习目标<ul><li>如何用图形模型表示软件系统；</li><li>基本的建模角度 (如上下文、交互、结构、行为等)；</li><li>统一建模语言 (UML)；</li><li>模型驱动工程.</li></ul></li><li>系统建模：建立系统抽象模型的过程<ul><li>图形建模；</li><li>形式化建模 (数学模型). </li></ul></li><li>不同角度表述系统 <code>与 第陆章 中的「4+1」视图相仿</code><ul><li><code>外部</code> — 上下文模型：系统上下文；系统环境；</li><li><code>交互</code> — 交互模型：系统与环境之间；系统各组成部分之间；</li><li><code>结构</code> — 结构模型：系统的体系结构；</li><li><code>行为</code> — 行为模型：系统的动态行为和它对事件响应方式.</li></ul></li></ul><h3 id="上下文模型"><a href="#上下文模型" class="headerlink" title="上下文模型"></a>上下文模型</h3><ul><li>定义系统边界：定义系统上下文和系统与环境之间的依赖关系。</li><li>上下文模型表示某一环境包括几个其他的自动系统 (忽略子系统之间及待描述的系统与它们之间的关联关系的类型)。</li><li><p>结合业务过程模型 </p><ul><li><p>活动图：如图 4-1 所示。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-1.png" alt="图4-1活动图"></p><center>图 4-1 活动图</center></li></ul></li></ul><h3 id="交互模型"><a href="#交互模型" class="headerlink" title="交互模型"></a>交互模型</h3><ul><li>为用户交互建模 -&gt; 识别用户需求。</li><li>为系统各部分之间的交互建模 -&gt; 系统结构能否实现系统所需的功能及其可靠性。</li></ul><h4 id="用例建模"><a href="#用例建模" class="headerlink" title="用例建模"></a>用例建模</h4><ul><li>用例图：如图 4-2 所示。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-2.png" alt="图4-2用例图"><br>    <center>图 4-2 用例图</center></p><ul><li>时序图：表示在特定用例中的交互发生顺序。如图 4-3 所示。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-3.png" alt="图4-3时序图"><br>    <center>图 4-3 时序图</center></p><h3 id="结构模型"><a href="#结构模型" class="headerlink" title="结构模型"></a>结构模型</h3><blockquote><p>课本第 6、18、19 章讲述软件体系结构的不同方面和软件体系结构建模。</p></blockquote><ul><li>静态模型：表示系统设计的结构。</li><li>动态模型：表示系统执行时的构成。</li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><ul><li><p>类图可表示系统中的类和这些类之间的关联。</p><blockquote><p>类与类之间的链接，表示类与类之间具有某种关系。</p></blockquote><ul><li><p>简单类图：如图 4-4 所示。其中一对多关系的类图，类似于语义数据模型，即数据实体、与他们相关的属性。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-4.png" alt="图4-4简单类图"></p><center>图 4-4 简单类图</center></li><li><p>扩展类图：如图 4-5 所示。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-5.png" alt="图4-5扩展类图"></p><center>图 4-5 扩展类图</center></li></ul></li></ul><h4 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h4><ul><li>推断一些类的成员具有的某些共同特征，针对类的所有成员给出一般性的描述。如图 4-6 所示。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-6.png" alt="图4-6泛化关系"></p><center>图 4-6 泛化关系</center><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><ul><li>一个对象 (全体) 可有由其他对象 (部分) 组成。如表示一条病人记录由 Patient 和一个不确定的 Consulation 组成。如图 4-7 所示，表示了一条病人记录由 Patient 和一个不确定的 Consulation 组成。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-7.png" alt="图4-7聚合关系"></p><center>图 4-7 聚合关系</center><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>如图 4-8 所示，展示了依赖关系。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-8.png" alt="图4-8依赖关系"></p><center>图 4-8 依赖关系</center><h3 id="行为模型"><a href="#行为模型" class="headerlink" title="行为模型"></a>行为模型</h3><ul><li>描述系统运行时的动态行为的模型，表示系统响应于所处环境的刺激所发生或可能发生的事情。</li><li>刺激：<code>数据</code>、<code>事件</code><ul><li>数据：一些数据到达必须由系统处理。</li><li>事件：某些触发系统处理的事件的发生。</li></ul></li></ul><h4 id="数据驱动的建模"><a href="#数据驱动的建模" class="headerlink" title="数据驱动的建模"></a>数据驱动的建模</h4><ul><li><p>数据驱动模型描述一个 <code>动作序列</code>，该动作序列涉及输入数据的处理和相关 <code>输出的产生</code>。</p><blockquote><p><code>输出的产生</code>：指系统的响应。</p></blockquote></li><li><p>处理序列的方法：</p><ul><li><code>时序图</code>：强调系统中的对象。</li><li><code>数据流图</code> (DFD)：关注于功能。</li></ul></li></ul><h4 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h4><ul><li>事件驱动模型表示系统对内、外部事件的响应方式。</li><li>基于事件的模型表示方法：状态图，表示系统状态和引起状态和引起状态改变的事件。其中状态图的表示如图 4-9 所示。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-9.png" alt="图4-9状态图"></p><center>图 4-9 状态图</center><h3 id="模型驱动工程"><a href="#模型驱动工程" class="headerlink" title="模型驱动工程"></a>模型驱动工程</h3><ul><li>模型驱动工程 (MDE) 起源于模型驱动体系结构 (MDA)，该体系由对象管理组织 (OMG) 提出。</li><li>支持者与反对方：<ul><li><code>支持者</code>：更高的抽象水平上考虑系统，不用关心实现细节，减少出错可能性，加速设计和实现过程，且可复用。</li><li><code>反对方</code>：并不是模型所支持的抽象都是正确的、可实现的。</li></ul></li></ul><h4 id="模型驱动体系结构"><a href="#模型驱动体系结构" class="headerlink" title="模型驱动体系结构"></a>模型驱动体系结构</h4><ul><li>计算独立模型 (CIM) — <code>领域建模</code> — 不同的 CIM 反映系统的不同方面。</li><li>平台独立模型 (PIM) — 表示静态系统结构和系统对内外事件的响应。</li><li>平台特定模型 (PSM) — PIM -&gt; PSM。如图 4-10 所示，为一个复合平台特定模型实例。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-10.png" alt="图4-10复合平台特定模型"></p><center>图 4-10 复合平台特定模型</center><h4 id="可执行-UML：xUML"><a href="#可执行-UML：xUML" class="headerlink" title="可执行 UML：xUML"></a>可执行 UML：xUML</h4><ul><li>为建立一 UML 可执行子集，模型类型可分为：<ul><li>领域模型：识别出系统的主要关注点，由 UML 的类图定义，包括对象、属性和关联。</li><li>类模型：定义类及它们的属性和操作。</li><li>状态模型：每一状态与一个类相关联，并且用来描述类的生命周期。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;在软工系列课程上，老师常提及的一条等式  &lt;code&gt;软件 = 程序 + 软件工程&lt;/code&gt; ( 或 &lt;code&gt;软件 = 程序 + 文档&lt;/code&gt;)，即一般情况讨论，一款软件产品的诞生之际总是伴随着一系列的软件过程。&lt;/p&gt;
&lt;p&gt;那么如何充分理解软件工程 (过程)？从本书作者理念出发，我所理解的即应该时刻对软件产品持有 &lt;code&gt;生命周期&lt;/code&gt; 的思维模式，将 &lt;code&gt;需求、建模、设计、实现、测试、维护&lt;/code&gt; 等工程阶段联系起来，以自身代入案例环境中，去模拟开展软件过程的一系列活动，而非割裂。而这样的动态过程中，不仅仅是枯燥地学习理论、方法，则更像是问题所需、问题导向的理论应用过程。&lt;/p&gt;
&lt;p&gt;当然，软件工程作为一门工程学科，学习过程的最大收获可以说是对 &lt;code&gt;项目思维模式&lt;/code&gt; 的掌握。譬如，我们可以抛开软件产品的范畴，谈谈现实生活的实例：假若你需要在一定时限内掌握一门新知识、任务，则我们的做法可以从调研、计划、布局、实施，直至验收，即类似的过程可复用软件工程的方法。&lt;/p&gt;
&lt;p&gt;最后，也是想声明的一点：学习软件工程的过程中，无可避免地将反映本人的一些观点、倾向，当然这也反映该学科需要 &lt;code&gt;多沟通&lt;/code&gt; 的特点，若有不恰当、错误之处，欢迎大伙出建议、斧正。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://www.kofes.cn/categories/Reading/"/>
    
    
      <category term="软件工程" scheme="http://www.kofes.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="需求工程" scheme="http://www.kofes.cn/tags/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="系统建模" scheme="http://www.kofes.cn/tags/%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="UML" scheme="http://www.kofes.cn/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>笔记 - 一个 APP 的诞生 ( 方法论 )</title>
    <link href="http://www.kofes.cn/2018/03/Producting-An-Application.html"/>
    <id>http://www.kofes.cn/2018/03/Producting-An-Application.html</id>
    <published>2018-03-20T03:13:54.000Z</published>
    <updated>2018-05-18T11:23:27.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p><a href="https://book.douban.com/subject/26865230/" target="_blank" rel="noopener">《 一个 APP 的诞生 》</a>被定义是一本教科书、工具书，适合想通过 APP 实现自己的产品梦的受众通读，即通过本书可让你快速了解 APP 产品的整个流程，从零到一，创造 APP 产品。</p><p>而通读本书籍后，或许你、我有同样的感受，即大部分内容是以设计师的角度看待问题的。这样，若你就是设计师，或许这将助你更加透彻理解 APP 的产出过程；若你是软件工程师，也可看待成是从另一角度理解软件过程。当然，这些知识只停留在书本层面，而对实际项目而言，有出入是无法避免的，但不失它的参考价值。简言之，这样一本图文并茂、实例贴近现实且含有众多跨界元素 (设计、开发、交互、产品等) 的工具书，特别是产品这一类别的书目 (下述还有同类型的书籍推荐)，不仅让你有机会感同身受业界优秀企业的工作流程，也是自身寻求产品方法论的不二选择。</p><a id="more"></a><ul><li><p>推荐书目</p><ul><li><p>《 U一点·料 》：由阿里巴巴集团 1688.UED 团队历经多年实践之后的佳作，内容重实战、讲方法、求专业、论文化，且以 “道─术─器” 的思路为编排脉络，从设计观、思考体系、方法论上层层剖析，将零散的行业技术诀窍串成体系，对 “UED如何发展突破” 提出了自己的真知灼见。<br>贴上本书的 <a href="https://book.douban.com/subject/26594029/" target="_blank" rel="noopener">豆瓣书评</a>，供朋友评判，做出抉择。</p></li><li><p>《 设计之下 》：由搜狐新闻客户端 UED 团队共同出品的佳作，分别以交互设计、视觉设计、设计师视觉，全面讲解了用户体验设计的流程和方法。<br>贴上本书的 <a href="https://book.douban.com/subject/25817190/" target="_blank" rel="noopener">豆瓣书评</a>，供朋友评判，做出抉择。</p></li></ul></li><li>更新进程<ul><li>2018.03.25 - 完成序言；</li><li>2018.03.26 - 更新内容 ( 共 6 章 )；</li><li>2018.04.02 - 更新完毕.</li></ul></li></ul><h2 id="零-思维导图"><a href="#零-思维导图" class="headerlink" title="零 思维导图"></a>零 思维导图</h2><blockquote><p>学习思路：根据思维导图的架构，掌握知识；以及参考部分项目经验，文档归纳。</p></blockquote><ul><li>前景探索<ul><li>竞品分析<ul><li>熟悉竞品分析的流程；</li><li>明确竞品分析的每个部分包含的内容；</li><li>分析报告的输出.</li></ul></li><li>用户研究<ul><li>了解用户研究的方法及它们的定义；</li><li>用户画像<br>1) 掌握建立的流程；<br>2) 用户画像的分类，每种分类的使用方法及优缺点；<br>3) 用户画像的构成、价值.  </li></ul></li></ul></li><li>设计规范及流程<ul><li>建立设计规范的特定情况；</li><li>iOS 和 Android 规范的差别；</li><li>主要元素及作用.</li></ul></li><li>交互设计<ul><li>用户体验<ul><li>交互设计师的工作内容、状况分析及处理；</li><li>紧密联系生活.</li></ul></li><li>交互设计的基本流程<ul><li>交互设计五要素：<code>人</code>、<code>目的</code>、<code>环境</code>、<code>媒介</code>、<code>行为</code>；</li><li>基本流程.</li></ul></li></ul></li><li>视觉设计<ul><li>Ui 设计<ul><li>Ui 设计制作流程；</li><li>对未来设计趋势的了解与把握.</li></ul></li><li>图标品质的提升</li><li>界面细节设计<ul><li>栅格系统提升界面易读性与可用性；</li><li>切图标注的知识与技能；</li><li>设计资源命名及文件分类整理.</li></ul></li></ul></li><li>开发实现<ul><li>如何与产品、运营、开发配合工作<ul><li>互联网企业中产品开发实现过程；</li><li>主要工作岗位职责和工作性质，以及岗位配合的注意事项.</li></ul></li><li>发布制作完成的 APP<ul><li>发布方式</li><li>常见市场</li></ul></li></ul></li><li>线上运营<ul><li>运营的定义<ul><li>什么是运营及运营的目标；</li><li>运营手段及运营岗位.</li></ul></li><li>线上运营活动：策划线上活动流程</li><li>H5 页面和 Banner 设计</li></ul></li><li><p>服务设计</p><blockquote><p>推荐阅读 <em>This is service design thinking</em> \(^{[1]}\)</p></blockquote><ul><li>服务设计的概念</li><li>服务设计的流程</li><li>工具箱：熟悉常见服务设计工具</li></ul></li><li>跨界设计</li></ul><h2 id="壹-前景探索"><a href="#壹-前景探索" class="headerlink" title="壹 前景探索"></a>壹 前景探索</h2><h3 id="竞品分析"><a href="#竞品分析" class="headerlink" title="竞品分析"></a>竞品分析</h3><p>竞品分析，能带来的价值：</p><ul><li>企业：优势 (Strength，S) 和 劣势 (Weakness，W)</li><li>设计：User Interface</li></ul><h4 id="为什么要竞品分析"><a href="#为什么要竞品分析" class="headerlink" title="为什么要竞品分析"></a>为什么要竞品分析</h4><ul><li>知己知彼<ul><li>市场：红海 (已知的市场空间)；蓝海 (还不存在的产品)</li><li>动向：目标人群、运营策略、用户体验、用户反馈</li></ul></li><li>设计灯塔：权衡利益与设计成本的关系</li></ul><h4 id="如何做竞品分析"><a href="#如何做竞品分析" class="headerlink" title="如何做竞品分析"></a>如何做竞品分析</h4><ul><li><code>确立</code> 竞争对手<ul><li>市场目标一致；</li><li>目标用户相同；</li><li>产品功能相同、相似；</li><li>用户需求相同.</li></ul></li></ul><blockquote><p>选择优质和合适的竞品，再进行分析。如表 1-1 所示，定位于即时通信类 APP ，即所要考虑的竟品类型及竞争关系。</p></blockquote><center>表 1-1 即时通信类 APP 的竟品类型及竞争关系</center><div class="table-container"><table><thead><tr><th style="text-align:left">考虑因素</th><th style="text-align:left">主要分析对象</th><th style="text-align:left">参考分析对象</th></tr></thead><tbody><tr><td style="text-align:left">市场目标方向一致、目标用户群体大致相同、功能用户需求相似</td><td style="text-align:left">QQ、微信</td><td style="text-align:left">陌陌、JUJU</td></tr><tr><td style="text-align:left">市场目标方向不一致、功能需求互补</td><td style="text-align:left">YY、斗鱼</td><td style="text-align:left">—</td></tr></tbody></table></div><ul><li><p><code>挖掘</code> 对手信息</p><ul><li>搜集资料<ul><li>数据资料，例如：APP 下载量，市场方面数据等。</li><li>其他信息，例如：APP 新闻动态，研究报告，APP 评价等。</li></ul></li><li>搜集渠道<ul><li>公司内部资源</li><li>运营部门</li><li>搜索引擎</li></ul></li></ul></li><li><p><code>分析</code> 数据信息</p><ul><li><a href="#分析数据信息">分析数据模型</a></li><li>整合收集的信息 (企业战略、目标人群、交互设计、视觉设计、运营策略等)</li></ul></li><li><p><code>输出</code> 分析报告 — <a href="#输出分析报告">可视化输出</a></p></li></ul><h4 id="分析数据信息"><a href="#分析数据信息" class="headerlink" title="分析数据信息"></a>分析数据信息</h4><ul><li><p>分析数据模型</p><ul><li><p><code>SWOT</code> 模型，即道斯矩阵、态势分析法，经常用于企业战略制定、竞争对手分析。</p><p>详细解释见：<a href="http://wiki.mbalib.com/wiki/%E9%81%93%E6%96%AF%E7%9F%A9%E9%98%B5" target="_blank" rel="noopener">MBAlib.智库百科.SWOT分析模型</a></p><blockquote><p><code>SWOT</code> 分别代表企业的优势 (Stength)、劣势 (Weakness)、机会 (Opportunity) 和威胁 (Threats)。</p></blockquote></li><li><p>波士顿矩阵 \(^{[2,3]}\)，四象限分析法。详细解释见：<a href="http://wiki.mbalib.com/wiki/%E6%B3%A2%E5%A3%AB%E9%A1%BF%E7%9F%A9%E9%98%B5" target="_blank" rel="noopener">MBAlib.智库百科.波士顿矩阵</a></p></li><li><p>KANO 模型 \(^{[4]}\)，一种典型的定性分析模型，经常用于绩效指标分类。其定义了顾客需求的三个层次：基本型需求、期望型需求和兴奋型需求。详细解释见：<a href="http://wiki.mbalib.com/wiki/KANO%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">MBAlib.智库百科.KANO 模型</a></p></li></ul></li><li><p>关于 SWOT 分析模型</p><ul><li>SW：竞争优势指一企业超越其竞争对手的能力，这种能力有助于实现企业的主要目标 — 盈利。  </li><li>OT：不利发展趋势所形成的挑战。</li></ul></li></ul><center>表 1-2 SWOT 分析模型</center><div class="table-container"><table><thead><tr><th style="text-align:center">发展趋势 (负)</th><th style="text-align:center">条件</th><th style="text-align:center">发展趋势 (正)</th></tr></thead><tbody><tr><td style="text-align:center">劣势 (Weakness，W)</td><td style="text-align:center">企业自身自身实力与竞争对手比较</td><td style="text-align:center">优势 (Strength，S)</td></tr><tr><td style="text-align:center">威胁 (Threats，T)</td><td style="text-align:center">外部环境变化对企业可能的影响</td><td style="text-align:center">机遇 (Opportunity，O)</td></tr></tbody></table></div><blockquote><p>举例：对蚂蜂窝 APP 实行 SWOT 分析法    </p></blockquote><ul><li><code>S</code>：旅游攻略是蚂蜂窝进军移动端的拳头产品，手持海量 UGC 数据和攻略引擎技术。</li><li><code>W</code>：盈利模式单一，知识与传统 OTA 合作的佣金 + 广告模式)。</li><li><code>O</code>：OTA &amp; O2O。</li><li><p><code>T</code>：行业壁垒；变现能力还能支持技术和运营走多远？</p></li><li><p>关于波士顿矩阵：波士顿矩阵区分出4种业务组合，如表 1-3 所示。</p></li></ul><center>表 1-3 波士顿矩阵业务组合</center><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">销售增长率</th><th style="text-align:left">市场占有率</th></tr></thead><tbody><tr><td style="text-align:left">明星类产品</td><td style="text-align:left">高</td><td style="text-align:left">高</td></tr><tr><td style="text-align:left">瘦狗类产品</td><td style="text-align:left">低</td><td style="text-align:left">低</td></tr><tr><td style="text-align:left">问题类产品</td><td style="text-align:left">高</td><td style="text-align:left">低</td></tr><tr><td style="text-align:left">现金牛类产品</td><td style="text-align:left">低</td><td style="text-align:left">高</td></tr></tbody></table></div><h4 id="输出分析报告"><a href="#输出分析报告" class="headerlink" title="输出分析报告"></a>输出分析报告</h4><ul><li>竞品分析包括内容：<ul><li>市场趋势、行业现状； — <code>SWOT 分析法</code></li><li>竞品的企业愿景、APP 定位、发展策略；</li><li>目标用户，用户画像；</li><li>核心功能；</li><li>交互设计；</li><li>APP 优缺点；</li><li>运营及推广策略；</li><li>总结并建议.</li></ul></li></ul><h3 id="用户研究"><a href="#用户研究" class="headerlink" title="用户研究"></a>用户研究</h3><p>用户研究最终的输出产物之一就是用户画像，即用户研究 =&gt; 用户画像。</p><h4 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h4><ul><li>场景观察：正常的工作环境或其他产品合适的 <code>物理场景</code> 中观察用户并与其交流。</li><li>可用性测试：用户在一定场景下使用产品。由可用性工程师对 <code>用户操作过程、习惯</code> 等进行 <code>观察、记录和测量</code>，以评估产品的可用性问题。</li><li>问卷调查：用 <code>统一、严格设计的问卷</code> 收集研究对象有关的 <code>心理特征</code> 和 <code>行为数据</code> 资料。</li><li><p>访谈研究：在访问用户过程中，提示被访者对某一问题的 <code>潜在冬季、新年、态度和感情</code>。</p><blockquote><p>潜在冬季、新年、态度和感情？</p></blockquote></li><li><p>焦点小组：定性研究方法。一定的组织结构，让用户一起进行 <code>互动</code>，用以激发新的思考和想法。</p></li><li>桌面研究：对已收集信息进行调研活动，即对二手资料进行搜集、筛选，并判断问题是否已经 <code>局部解决</code> 或 <code>全部解决</code>。</li><li>专家评估：组织各领域专家运用专业方面知识和经验，通过直观归纳，对产品过去、现在及发展过程进行综合分析、研究，再作判断。</li></ul><h4 id="用户画像"><a href="#用户画像" class="headerlink" title="用户画像"></a>用户画像</h4><ul><li><p>输出用户画像的流程</p><ul><li>获取研究用户信息</li><li>细分用户群</li><li>建立并丰富用户画像</li></ul></li><li><p>建立用户画像的方法</p><ul><li><code>定性</code> 用户画像</li><li>经 <code>定量验证</code> 的 <code>定性</code> 用户画像</li><li><p><code>定量</code> 用户画像</p><blockquote><p>定性 (性质) 研究：创立理论的过程。即 <code>具体向抽象转化</code>，形成理论。通常以 <code>访谈、观察</code> 等方法收集第一手描述性资料 (归纳法)。 </p><p>定量 (度量) 研究：<code>提出理论假设</code>，使用 <code>问卷</code> 等工具收集具有数量关系的资料，对资料进行 <code>量化</code>，以 <code>数据形式</code> 验证假设。</p></blockquote></li></ul></li><li><p>定性用户画像 — <code>直接分用户群</code></p><ul><li>步骤<br>1) 定性研究访谈；<br>2) 细分用户群；<br>3) 建立细分群体的用户画像。 </li><li>定性用户画像优缺点<ul><li>优点 - 省时省力、简单、需要专业人员少。</li><li>缺点 - 缺少数据支持和验证。</li></ul></li></ul></li><li><p>经定量验证的定性用户画像 — <code>分了用户群再验证</code></p><ul><li>步骤<br>1) 定性研究访谈；<br>2) 细分用户群；<br>3) 定量验证细分群体；<br>4) 建立细分群体的用户画像。  </li><li>经定量验证的定性用户画像优缺点<ul><li>优点 - 有一定的定量验证工作，需要少量的专业人员。</li><li>缺点 - 工作量较大，成本较高。</li></ul></li></ul></li><li><p>定量用户画像 — <code>验证了再分用户群</code></p><ul><li>步骤<br>1) 定性研究；<br>2) 多个细分假设；<br>3) 通过定量收集细分数据；<br>4) 聚类分析细分用户；<br>5) 建立细分群体的用户画像。  </li><li>定量用户画像的优缺点<ul><li>优点 - 有充分的佐证、更加科学、需要大量的专业人员。</li><li>缺点 - 工作量较大，成本高。</li></ul></li></ul></li><li><p>用户画像包含以下元素：</p><ul><li>基本信息 (姓名、照片、年龄、家庭状况、收入、工作)；</li><li>典型场景；</li><li>目标和动机；</li><li>需求和痛点；</li><li><p>对 APP 的态度；</p><p>如图 1-1 以音乐沉侵爱好者为例，建立用户画像。</p></li></ul></li></ul><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_1-1.png" alt="音乐沉侵爱好者的用户画像"></p><center>图 1-1 音乐沉侵爱好者的用户画像</center><h4 id="调查问卷设计"><a href="#调查问卷设计" class="headerlink" title="调查问卷设计"></a>调查问卷设计</h4><p>设计问卷的目的是为了更好地搜集信息或者定量去验证定性研究的结果。故在问卷设计的过程中，要把握调查的目的和需求，具体可分为以下几个步骤：</p><ul><li><p>问卷设计流程</p><ul><li>确定所需要的信息<ul><li>调研目的</li><li>竞品分析文档</li><li>用户画像</li></ul></li><li>确定问题顺序：<code>先易后难</code></li><li>问卷的测试和修改<ul><li>投放预测试</li><li>问题修改</li></ul></li></ul></li><li><p>设计问卷题目</p><ul><li>用户基本信息 (年龄、爱好、APP 相关生活行为)</li><li>用户使用 APP 典型场景 (碎片化时间使用，使用频次)</li><li><p>用户的痛点与需求</p><blockquote><p>可参考书本 P27-30 的实例，全民 K 歌用户体验调研问卷。</p></blockquote></li></ul></li></ul><h2 id="贰-交互设计"><a href="#贰-交互设计" class="headerlink" title="贰 交互设计"></a>贰 交互设计</h2><h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h3><ul><li>用户体验，即站在用户角度考虑问题。</li><li>交互设计师<ul><li>核心价值：沟通</li><li>工作流程：<ul><li>对重要或者紧急设计任务进行准备、分工、安排；</li><li>写解决方案，画稿；</li><li>评审待确认的设计；</li><li>总结方案，输出结果，同步给部门；</li><li>输出设计稿，与产品、研发及时沟通；</li><li>与项目接口人沟通.</li></ul></li></ul></li></ul><h3 id="交互设计基本流程"><a href="#交互设计基本流程" class="headerlink" title="交互设计基本流程"></a>交互设计基本流程</h3><h4 id="交互五要素"><a href="#交互五要素" class="headerlink" title="交互五要素"></a>交互五要素</h4><ul><li>人 (Amber)：有记录灵感的设计师，有需求的人称之为用户。</li><li>媒介 (Tools)：用户使用的设备。</li><li>行为 (Behavior)：用户的具体操作。</li><li>目的 (Purpose)：要达到某种的效果。</li><li>环境 (Enviroment)：用户使用的设备，这里指手机。</li></ul><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_2-1.png" alt="交互设计五元素"></p><center>图 2-1 交互设计五元素</center><h4 id="如何参与一个项目"><a href="#如何参与一个项目" class="headerlink" title="如何参与一个项目"></a>如何参与一个项目</h4><p>交互设计师接到一个项目或者需求后，他们的工作流程基本按照以下流程执行，即需求分析、信息架构设计、流程图设计、原型设计、最终进入产品的可用性测试，当然需求分析阶段完成后，也可以进行可用性测试，以验证方案的可行性。图 2-2 描述了交互设计师如何参与一个项目。</p><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_2-2.png" alt="交互设计师如何参与一个项目"> </p><center>图 2-2 交互设计师如何参与一个项目</center><blockquote><p>提示：实例中，我们以便签 APP 为主题展开讨论的。</p></blockquote><ul><li><p>1) 需求分析</p><ul><li>了解需求</li><li>用户调研</li><li>需求定位：竟品分析、头脑风暴、绘制故事板、人物建模 (用户画像)、产品数据</li><li><code>实例</code>：在需求分析阶段，我们从诸多研究方法和数据中简明得出便签 APP 的产品定位：  <ul><li>产品定义<ul><li>使用人群 — <code>设计师、学设计的学生</code>  </li><li>主要功能 — <code>记录想法、分享想法</code>  </li></ul></li><li>用户需求<ul><li>使用目标 — <code>随时随地记录想法、把想法分享给同事和朋友</code>  </li><li>使用场景 — <code>商场、会议、课堂、工作、训练、作图</code>  </li><li>用户目标 — <code>操作方便快捷、耗流量少、学习成本低</code></li></ul></li></ul></li></ul></li><li><p>2) 信息架构</p><ul><li>需求收集</li><li>需求删减</li><li>定义优先级</li><li>用户任务</li><li><p><code>实例</code>：根据需求分析得到的信息，接下来便梳理架构，开始架构草图设计。如图 2-2 所示。</p><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_2-3.png" alt="信息架构图"> </p><center>图 2-3 信息架构图</center></li></ul></li><li><p>3) 流程图</p><ul><li>操作流程</li><li>页面流</li><li>布局设计</li></ul></li><li><p>4) 原型设计</p><ul><li>交互原型</li><li>交互说明</li><li>设计规范</li><li>项目跟进</li></ul></li><li><p>5) 测试</p><ul><li>可用性测试</li><li>A/B 测试</li><li>用户反馈</li><li>产品数据</li></ul></li></ul><h4 id="需求分析的考虑因素"><a href="#需求分析的考虑因素" class="headerlink" title="需求分析的考虑因素"></a>需求分析的考虑因素</h4><p>在产品设计的整个过程中，要充分考虑商业需求和用户体验的平衡。如图 2-4 所示，展示了需求收集需要考虑的因素。</p><p>需求的删减是需求分析中很有必要的步骤，他是设计师们综合考虑各种因素，取舍得到的结果。</p><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_2-4.png" alt="信息架构图"></p><center>图 2-4 需求收集需要考虑的因素</center><h4 id="如何组织需求"><a href="#如何组织需求" class="headerlink" title="如何组织需求"></a>如何组织需求</h4><ul><li>1) 定义信息优先级<ul><li>产品定位：核心功能，意味着这些功能的优先级最高。</li><li>真实需求：区分次要需求。它们是围绕核心功能进行拓展的。</li><li>需求删减：权衡删减需求。</li></ul></li><li>2) 信息架构：深度和广度要均衡。</li></ul><h4 id="流程图设计"><a href="#流程图设计" class="headerlink" title="流程图设计"></a>流程图设计</h4><ul><li>确定信息架构</li><li>确定用户任务</li><li><p>如何完成操作</p><p>  完成任务方法即我们所说的流程，任务流程是根据用户实际操作的心理和行为来确定的。  </p><p>  [实例] 人在使用纸质版的便签的流程：  </p><ul><li>首先拿出纸和笔；</li><li>纸上记录想法；</li><li><p>粘贴醒目的地方便于查看。</p><p>在现实中使用便签的过程和在手机上使用便签的实际操作步骤基本吻合，如图 2-5 所示，展示了添加便签的流程图。</p><blockquote><p>这里的流程图设计，可以使用 C 语言程序设计中的程序流程图。</p></blockquote></li></ul></li></ul><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_2-5.png" alt="添加便签的流程图"></p><center>图 2-5 添加便签的流程图素</center><h4 id="原型设计及设计原则"><a href="#原型设计及设计原则" class="headerlink" title="原型设计及设计原则"></a>原型设计及设计原则</h4><ul><li>确立功能和逻辑后</li><li>设计草图</li><li>低保真线框图</li><li><p>高保真原型图</p><p>  图 2-6 是本人早期设计的沙漏记事 APP 的低保真线稿，强制插入了一段广告哈。而对应的高保真原型图，可参考对应的专题介绍。<a href="http://www.zcool.com.cn/work/ZMTU3NjcxMTI=.html" target="_blank" rel="noopener">「沙漏记事」APP</a></p><p>  <img src="/images/illustration/Reading/2018/03/Producting_An_Application_2-6.jpg" alt="沙漏记事APP低保真线稿"></p>  <center>图 2-6 沙漏记事 APP 低保真线稿</center></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>交互设计基本流程<ul><li>需求收集和分析</li><li>定义优先级</li><li>信息架构设计</li><li>流程设计</li><li>原型设计</li></ul></li><li>需求分析过程，要综合考虑 <code>商业</code>、<code>项目</code>、<code>用户</code> 三要素。</li></ul><h2 id="叁-视觉设计"><a href="#叁-视觉设计" class="headerlink" title="叁 视觉设计"></a>叁 视觉设计</h2><h3 id="UI-设计"><a href="#UI-设计" class="headerlink" title="UI 设计"></a>UI 设计</h3><h4 id="UI-的定义"><a href="#UI-的定义" class="headerlink" title="UI 的定义"></a>UI 的定义</h4><p>用户界面 (User Interface，UI)，系统和用户之间进行交互和信息交换的媒介，它实现信息的内部形式与人类可接受形式之间的转换。</p><h4 id="UI-设计流程"><a href="#UI-设计流程" class="headerlink" title="UI 设计流程"></a>UI 设计流程</h4><ul><li><p>具体把 UI 设计流程分为前期准备和情绪板两个阶段。</p><ul><li>1) 定义：做好定义 / 用户细分。</li><li>2) 找寻：找到同类竞品的 APP 安装并进行沉侵式体验。</li><li>3) 分析：分析竞品并学习。</li><li>4) 关键字：确定情感关键字。</li><li>5) 收集：图片素材收集，建立情绪板。</li><li>6) 分析：对情绪板进行色彩和质感分析。</li><li>7) 访谈：用户验证确定设计风格。</li><li><p>8) 完善：完善整个 APP 视觉设计。</p><blockquote><p>Step 1 ~ 4 为前期准备阶段，Step 5 ~ 8 为情绪板阶段。</p></blockquote></li></ul></li><li>做用户定义：如何定义用户在这不再重复阐述，详细见 <a href="#壹-前景探索">第一章 前景探索</a>。</li><li>找寻同类竞品 APP 使用并体验：站得高，看得远。即选择的竞品也要有足够的市场表现力。</li><li>确定情感关键字：该 APP 的视觉所要表达的情感感受。</li><li>情绪板：把每个人对情感的抽象理解成实际可定义的元素。<ul><li>关键字提炼；</li><li>建立具象图库 (具体的事实物、场景) 和抽象；</li><li>图库 (色彩质感等元素).</li></ul></li><li>对情绪板进行色彩和质感分析，即把握图片上的颜色、元素的感觉，再抽象成颜色方案。</li></ul><h3 id="图标品质提升"><a href="#图标品质提升" class="headerlink" title="图标品质提升"></a>图标品质提升</h3><h4 id="素描色彩的基础"><a href="#素描色彩的基础" class="headerlink" title="素描色彩的基础"></a>素描色彩的基础</h4><ul><li><p>素描的三大面五大调</p><ul><li>三大面：亮面，灰面，暗面。</li><li><p>五大调：亮面，灰面，明暗交界线，反光部和投影。</p><blockquote><p>在构图中，我们都是通过假设光源的方法来进行创作。</p></blockquote></li></ul></li><li><p>构图注意事项</p><ul><li>构图不能太小 (让人觉得画面不够饱满，显得小气)；</li><li>构图应注重重心平衡；</li><li>构图应注意透视的变化及比例关系.</li></ul></li><li><p>色彩的魅力</p><ul><li>色彩的冷暖：物体通过表面色彩给人温暖或凉爽的观感。</li><li>色彩的轻重：质感与色感的复合感觉。</li><li>色彩的前进性与后腿性：一般而言，暖色比冷色更富有前进的特性。</li></ul></li></ul><h4 id="一个像素也是事儿"><a href="#一个像素也是事儿" class="headerlink" title="一个像素也是事儿"></a>一个像素也是事儿</h4><ul><li><code>边缘像素</code> 的完美方案：图标变虚问题 =&gt; 没有边缘对齐，故在矢量绘图当中，需要对齐边缘，对齐像素。</li><li><code>旋转像素</code> 的完美方案：<ul><li>旋转中心点挪到任意定点，再旋转。</li><li>若是旋转并缩放，建议先旋转再缩放。</li></ul></li><li>Ai 到 Ps 的完美粘贴<ul><li>1) Ai 里选 <code>对齐像素网格</code>；</li><li>2) Ps 里建一个图标大小相同的 <code>选区</code>，再粘贴进来，粘贴时最好选择 <code>形状图层</code>，这样便于后期编辑。</li></ul></li></ul><h4 id="国际化的图标设计"><a href="#国际化的图标设计" class="headerlink" title="国际化的图标设计"></a>国际化的图标设计</h4><ul><li><p>表现形式上符合全球化潮流的设计趋势。</p><blockquote><p>这里非常容易理解，例如地铁、高铁、机场的指示标志，还有厕所指示标志等。</p></blockquote></li><li><p>动感：动效与交互的相交融。</p></li><li>质感：拟物、扁平和微质感，这里视具体情况而决定，如公司文化、应用受众、市场趋势等因素，总得来说，调研、分析工作是少不了环节。</li></ul><h3 id="界面细节提升"><a href="#界面细节提升" class="headerlink" title="界面细节提升"></a>界面细节提升</h3><h4 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h4><p>栅格系统，又称网格系统。主要以规则的网格阵列来指导和规范页面中的版面布局以及信息布局。当然，栅格系统也只是一种布局辅助工具，在实际项目中应灵活地根据需求在整体或布局合理应用，即综合 iOS 或 Android 的规范准则，总体把控每个元素与界面的协调感。</p><h4 id="资源规范"><a href="#资源规范" class="headerlink" title="资源规范"></a>资源规范</h4><ul><li><p>切图</p><ul><li>iOS：选择一这种的分辨率，即 @2x，750 x 1334 px，再输出 @3x，@4x。当然，你的设计稿是基于 <code>矢量工具</code> 绘制的。</li><li><p>Android：MDPI (160 DPI)，HDPI (240 DPI)，XHDPI (320 DPI), XXHDPI (480DPI)，或更多。</p><blockquote><p>1) 关于切图适配的问题，除了上述的原始办法外，现有很多插件、工具可帮你完成此项工作了。<br>2) 一套切图尽可能适配 iOS 与 Android，即找准 @ 与 DPI 的大小关系即可。</p></blockquote></li><li><p>在标注文档中，可采用 <code>物理像素单位</code> 描述元素的大小、布局的位置和间距留白的大小。<br>这样做的好处是，<strong>开发人员直接设置参数，设计人员按照切图的倍率输出切图</strong> (@2x、@3x、@4x)。</p></li><li><p>特别地，切图是以偶数倍放大的，便于缩放，设计元素的大小注意使用偶数单位即可。  </p><p>例如，标注的基准信息是 <code>14.0 DP / @1x</code>，适配对应尺寸的参数即有：<br><code>XHDPI / @2x &lt;=&gt; 28px</code>，<code>XXHDPI / @3x &lt;=&gt; 42px</code>，<code>@4x &lt;=&gt; 56px</code>。</p></li></ul></li><li><p>.9.PNG</p><ul><li>最外围的一圈像素，必须限定是 <code>1px</code> 大小，必须是纯黑色 <code>#000000</code>，任何参杂都不行。</li><li><p>文件名后缀必须是 <code>*.9.PNG</code>。</p><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_3-1.png" alt=".9.PNG使用演示图"></p><center>图 3-1 .9.PNG使用演示图</center></li></ul></li><li><p>压缩切图：在 Photoshop 中，输出方式为 <code>存储为 web 所用格式</code>；在 Sketch 中使用 <code>导出功能</code> 导出图片；其他工具可自行查阅资料，这里就不一一列举了。</p></li><li><p>标注</p><ul><li>常用的标注软件：<code>Markman</code>、PxCook、Assistor PS。</li><li>若公司、团队有规范的设计、开发手册，则请按照规范标准进行设计。</li><li><p>拥有自己的一套标注文档 (迎合大众的，容易理解的)。</p><p>对于一界面来说，图片、图标、框架、文字等元素，是必不可少的。若是为了更高程度的还原，那么详细的标注描述、文字说明、交互说明是必要的。在一般情况下，很多朋友为了便捷 (偷懒) 会在同一界面一次性把上述工作都堆积在一起完成，而这样带来的问题就是 <code>糟糕的阅读体验</code>。</p><p>这里推崇一种做法 <code>分页描述法</code>。即：<br>1) 第一页，描述界面布局的信息，如间距大小、背景颜色；<br>2) 第二页，描述文字属性信息，如文字的字体、字号、颜色、布局；<br>3) 第三页，描述组件属性信息，如按钮、小图标等；<br>4) 第四页，描述界面的交互信息，按照需求，你还可以细分为每个组件的交互信息；<br>5) 以此类推…</p></li></ul></li><li><p>资源命名</p><ul><li><p><code>组件类型_模块_子功能_状态</code> 或者 <code>模块_组件类型_子功能_状态</code>；</p><blockquote><p>例如：btn_setting_logout_n.png / setting_btn_logout_n.png</p></blockquote></li><li><p>下划线相连命名，如 <code>ico_appicon_normal.png</code></p></li></ul></li><li>PSD 源文件<ul><li>以模块为单位，归类于不同文件夹中；</li><li>PSD 源文件中，有 <code>分组分层</code> 的习惯.</li></ul></li></ul><h2 id="肆-开发实现"><a href="#肆-开发实现" class="headerlink" title="肆 开发实现"></a>肆 开发实现</h2><h3 id="如何与产品、运营、开发配合"><a href="#如何与产品、运营、开发配合" class="headerlink" title="如何与产品、运营、开发配合"></a>如何与产品、运营、开发配合</h3><h4 id="互联网产品的研发流程"><a href="#互联网产品的研发流程" class="headerlink" title="互联网产品的研发流程"></a>互联网产品的研发流程</h4><ul><li>需求来了：产品经理，负责需求的策划和整理，输出产品需求文档 (Product Requirement Document，PRD)。那么产品经理的需求来自哪：<ul><li>版本规划：从无到有策划一款产品，这些功能不是一次性开发的，而是分布在若干版本中。</li><li>动态演变的产品：根据市场的反馈，调整后续的增量版本。</li><li>细节的优化：注重用户体验的优化。</li><li>适应丰富的使用场景。</li></ul></li><li>需求要评审：方案需要和开发、设计、测试、运维人员一起评审。</li><li>开始设计</li><li>开始开发</li><li>测试把关</li></ul><h4 id="与各种角色融洽相处"><a href="#与各种角色融洽相处" class="headerlink" title="与各种角色融洽相处"></a>与各种角色融洽相处</h4><p>可借助一些 <code>协作平台</code> 来规范研发流程，如需求的追加、任务分派、提交 BUG 等。相关人员通过日志、文档开展工作。</p><p><code>协作平台</code>：<a href="https://worktile.com/" target="_blank" rel="noopener">Worktile</a> 、 <a href="https://www.teambition.com/" target="_blank" rel="noopener">Teambition</a> 、<a href="http://co.youdao.com/" target="_blank" rel="noopener">有道云协作</a> 、 <a href="https://processon.com/" target="_blank" rel="noopener">ProcessOn (在线绘图)</a>  </p><p>当然，软件过程中，一款合适的团队协作工具能使事情事半功倍。特别是敏捷方法，它是非常依赖工具的。至于哪款工具更适合于你们团队，建议参考知乎的文章再作判断：<a href="https://www.zhihu.com/question/24920474" target="_blank" rel="noopener">Worktile 与 Teambition 的优劣对比？</a></p><h4 id="发布应用程序"><a href="#发布应用程序" class="headerlink" title="发布应用程序"></a>发布应用程序</h4><ul><li>灰度发布：在发布新版本时，仅针对少部分用户样本发布。灰度发布是一种常用的产品测试及质量管理工具。对于用户量大的产品，贸然发布一个新版本取代用户当前使用的版本，风险太大。因此互联网公司摸索出了一种工具，即灰度发布。</li></ul><h4 id="快速制作原型"><a href="#快速制作原型" class="headerlink" title="快速制作原型"></a>快速制作原型</h4><p>快速原型的工具有很多，推荐几款制作工具：<a href="https://modao.cc/" target="_blank" rel="noopener">墨刀</a> 、 <a href="https://www.axure.com/download" target="_blank" rel="noopener">Axure PR</a> 、 <a href="https://proto.io/" target="_blank" rel="noopener">Proto.io</a></p><h2 id="伍-线上运营"><a href="#伍-线上运营" class="headerlink" title="伍 线上运营"></a>伍 线上运营</h2><h3 id="运营的概述"><a href="#运营的概述" class="headerlink" title="运营的概述"></a>运营的概述</h3><h4 id="运营的定义"><a href="#运营的定义" class="headerlink" title="运营的定义"></a>运营的定义</h4><p>在互联网中，针对不同群体推广产品，进行内容建议，并通过数据指标优化运营手段、产品功能与体验等行为。</p><ul><li>运营三要素：产品、用户和渠道，如图 5-1 所示。</li></ul><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_5-1.png" alt="运营三要素"></p><center>图 5-1 运营三要素</center><ul><li>运营的目标：运营是以目标为导向，数据为基础的工作。一切工作都围绕着运营三要素来进行，即产品、用户和渠道。运营的目标如图 5-2 所示。</li></ul><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_5-2.png" alt="运营的目标"></p><center>图 5-2 运营的目标</center><ul><li><p>产品、运营、设计工作的关系：为了达到运营目标，运营经理需要与产品经理、设计师等配合工作，如图 5-3 所示，简单地描述了产品经理、运营经理和设计师的工作关系。</p><p>  <img src="/images/illustration/Reading/2018/03/Producting_An_Application_5-3.png" alt="产品、运营、设计工作关系图"></p>  <center>图 5-3 产品、运营、设计工作关系图</center></li></ul><h4 id="运营工作内容及岗位"><a href="#运营工作内容及岗位" class="headerlink" title="运营工作内容及岗位"></a>运营工作内容及岗位</h4><ul><li><p>典型的产品生命周期：即每个阶段的运营重点都不同。图 5-4 展示了一款产品的生命周期。</p><p>  <img src="/images/illustration/Reading/2018/03/Producting_An_Application_5-4.png" alt="产品的生命周期"></p>  <center>图 5-4 产品的生命周期</center></li><li><p>运营目标：可量化的指标</p><ul><li>拉新：为 APP 带来下载或注册，或微信公众号拉粉。<br>常用手段有：<code>搜索引擎优化</code>，<code>广告投放</code>，<code>渠道合作</code>、<code>社交媒体推广</code>。</li><li>留存：想办法留住用户。运营的方式为：<code>优化产品内容机制</code>；<code>策划活动与用户互动</code>。</li><li>促活：<ul><li>促用户更高频使用产品，增加用户黏性。可用 <code>等级设定</code>、<code>激励体系</code>、<code>积分制度</code> 等增加长期活跃性。</li><li>已流失的用户，通过 <code>站内信</code>、<code>邮件</code>、<code>短信</code> 等手段召回。</li></ul></li><li>营收：增加付费用户和提高付费用户的活跃度。</li></ul></li></ul><h4 id="运营工作方法论"><a href="#运营工作方法论" class="headerlink" title="运营工作方法论"></a>运营工作方法论</h4><ul><li>如何让运营手段更抓住人心，追根溯源就是研究人性，一款好的产品及运营，一定能迎合人性七宗罪中的其中之一。下述为 <code>利用人性</code> 的产品功能举例。<ul><li><code>色欲</code>：美女直播、陌陌、基于 LBS (基于位置的服务) 的陌生人社交。</li><li><code>虚荣</code>：游戏装备。</li><li><code>贪婪</code>：双十一折扣、抽奖、送红包。</li><li><code>懒惰</code>：一键下单、二维码。</li><li><code>窥探</code>：无秘、悄悄关注。</li><li><code>傲慢</code>：吵架营销、粉丝大战。</li></ul></li><li>数据化运营：基于数据的运营决策更可靠。<ul><li>产品数据<ul><li>用户注册：包括下载量、注册用户激活数、APP 打开数、新增注册数等；</li><li>用户留存：留存率、使用留存、购买留存等；</li><li>用户活跃：活跃用户数、注册活跃转化率、APP 启动数、访问频率、浏览时长等；</li><li>营收数据：付费用户数、付费转化率、付费金额、付费频次等；</li><li>功能数据：每日评论数、交互反馈次数 (收藏、分享、喜欢等功能)。</li></ul></li><li>用户数据：用户画像 (性别、职业、学历、年龄、地域、使用设备、操作系统、消费行为)。</li></ul></li></ul><h3 id="活动运营"><a href="#活动运营" class="headerlink" title="活动运营"></a>活动运营</h3><h4 id="什么是活动运营"><a href="#什么是活动运营" class="headerlink" title="什么是活动运营"></a>什么是活动运营</h4><ul><li>传统行业短期的活动促销，带来一定人气增长、销售额增加。</li><li>社交网络的病毒式传播，例如春晚微信摇红包、支付宝集五福等。</li></ul><h4 id="活动使用场景"><a href="#活动使用场景" class="headerlink" title="活动使用场景"></a>活动使用场景</h4><ul><li>常规活动：有针对性提高某一指标，或新功能推广。其活动形式有：签到、邀请好友、新用户福利。</li><li>节日：每个节日都有其自带的属性，利用节假日的情感共鸣。如表 5-1 所示。</li></ul><center>表 5-1 常见节日举例</center><div class="table-container"><table><thead><tr><th style="text-align:left">常见节日</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">常规节日</td><td style="text-align:left">春节、情人节、圣诞节、母亲节、劳动节</td></tr><tr><td style="text-align:left">人为创造</td><td style="text-align:left">双十一、双十二、520告白日</td></tr><tr><td style="text-align:left">店庆活动</td><td style="text-align:left">天猫店庆、周年庆</td></tr><tr><td style="text-align:left">季节变化</td><td style="text-align:left">换季清仓、节气、春夏秋冬交替</td></tr><tr><td style="text-align:left">体育赛事</td><td style="text-align:left">奥运会、欧冠、世界杯、NBA</td></tr><tr><td style="text-align:left">颁奖典礼</td><td style="text-align:left">奥斯卡、电影节</td></tr></tbody></table></div><p>每个节日都有其自带属性，例如春节会想到春运，双十一想到打折促销、中秋节想到团圆等。</p><ul><li>突发热点事件：极具话题性，短期爆发力强，能迅速传播。如表 5-2 列举了一些热点。</li></ul><center>表 5-2 热点举例</center><div class="table-container"><table><thead><tr><th style="text-align:left">热点</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">民生类</td><td style="text-align:left">与我有关的话题，生老病死的话题</td></tr><tr><td style="text-align:left">公益类</td><td style="text-align:left">环保、支教、老人、儿童、宠物</td></tr><tr><td style="text-align:left">娱乐类</td><td style="text-align:left">明星八卦、热门参与、笑话段子</td></tr><tr><td style="text-align:left">敏感话题</td><td style="text-align:left">权利、金钱、色情</td></tr><tr><td style="text-align:left">技术趋势</td><td style="text-align:left">人工智能、区块链、科技公司新品发布</td></tr></tbody></table></div><p>例如，肌萎缩侧索硬化症引发的冰桶挑战，达到的效果有：微博话题阅读超 7 亿，捐款总额达 137 万元。</p><h4 id="如何策划线上活动"><a href="#如何策划线上活动" class="headerlink" title="如何策划线上活动"></a>如何策划线上活动</h4><p>策划线上活动共四阶段，即准备阶段、策划阶段、执行阶段和总结阶段。</p><ul><li><code>准备阶段</code>：活动前的准备<ul><li>活动需求：目的、人群、平台、机会点 (借势发挥，如世界杯)</li><li>活动目的：量化为数据指标，核心目标为推广品牌、拉新用户、促进消费、提升用户活跃度。</li></ul></li><li><p><code>策划阶段</code>：活动方案策划</p><ul><li>明确活动的时间、内容、规范、文案、流程；</li><li><p>确认奖品及协调推广资源；</p><p>[注意] 策划方案时应：<br>1) 流程简单，文案清晰；<br>2) 吸引力，例如奖励等手段；<br>3) 适时反馈，精神激励。例如动态显示参与人数、突出用户收益、获奖用户轮播。</p></li></ul></li><li><code>执行阶段</code>：活动上线后做好三点<ul><li>客服跟进：解决用户疑难，平息用户情绪。</li><li>监控数据：随时调整，保证活动质量和预期。</li><li>分布活动结果和活动善后 (<code>不要让用户感到被欺骗</code>)。</li></ul></li><li><code>总结阶段</code><ul><li>用户参与情况和数据，用以判断是否达到目标。</li><li>总结活动经验，提炼亮点和失误点，为下次活动做准备。</li></ul></li></ul><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><p>以 “新浪微博愚人节刮奖” 活动为例。</p><ul><li>活动类型：游戏</li><li>活动目标：提升用户活跃度</li><li>活动时间：愚人节，七天活动</li><li>目标人群及切入需求：针对老用户 -&gt; <code>逐利心理</code></li><li>平台：手机</li><li>交互方式：模拟真实的刮奖操作</li><li>规则判定<ul><li>每天每个用户可参与 5 次 刮刮卡活动，第一次免费。</li><li>完成某些指定任务可获得更多抽奖活动。</li></ul></li><li>奖品设置<ul><li>根据预算控制奖品数量和中奖概率。</li><li>头奖要吸引眼球，配合普通奖品，<code>增加用户获奖信心</code>。</li></ul></li><li>文案与视觉设计<ul><li>标题醒目，规则明确，页面简洁。</li><li>结合活动主题渲染气氛。</li></ul></li><li>活动指标：参与人数，传播度 (分享数)，任务完成度，活动期间的活跃用户数。</li></ul><h3 id="H5-与-Banner-的设计"><a href="#H5-与-Banner-的设计" class="headerlink" title="H5 与 Banner 的设计"></a>H5 与 Banner 的设计</h3><h4 id="H5-表现形式"><a href="#H5-表现形式" class="headerlink" title="H5 表现形式"></a>H5 表现形式</h4><p>H5，即第五代 HTML，也泛指利用 HTML5 语言制作的页面。在开始设计前，先了解 H5 专题页的类型。</p><ul><li>按功能形式分：如图 5-5 所示。</li></ul><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_5-5.png" alt="按功能形式分的H5"></p><center>图 5-5 按功能形式分的 H5</center><ul><li>按目标分：如图 5-6 所示。</li></ul><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_5-6.png" alt="按目标分的H5"></p><center>图 5-6 按目标分的 H5</center><ul><li><p>在确定了专题页的功能与目标后，接下来的设计阶段尤为关键。即可从用户角度出发，思考用户的分享动机 (共六种情况)。</p><ul><li>利益相关：<code>有奖形式</code> 促进用户分享。</li><li>有所收获：通过传播内容，学习自己感兴趣的知识，或 <code>自我提升</code>。</li><li>身份认同：内容使某一类型人产生身份认同和归属感。</li><li>成就吸引：朋友间竞技，满足用户 <code>炫耀心理需求</code>。</li><li>情感共鸣：<code>情感共鸣</code>，从而产生集体回忆的分享冲动。</li><li>借助热点：借助 <code>当前热点</code>，吸引用户眼球。</li></ul></li><li><p>H5 页面表现形式</p><ul><li>展示型：支付宝十年账单、微信故事。</li><li>互动型：智能招聘的职场神曲 DIY。</li><li>产品型：微信公众号里的微商城，如京东。</li></ul></li></ul><h4 id="Banner"><a href="#Banner" class="headerlink" title="Banner"></a>Banner</h4><p>投放于线上 (PC端、移动端) 的各种尺寸和形状的广告图。</p><ul><li>设计流程<ul><li>了解目的，定义信息优先级；</li><li>确定文案，确定设计方向；</li><li>视觉设计排版，讨论修改.</li></ul></li><li>搭配方式 =&gt; 输出 Banner<ul><li>内容专题：文案 + 主体物或文案 + 背景形式。<code>P238</code></li><li>电商：文案 + 主体物 + 背景形式。<code>P239</code></li><li>活动：文案 + 主体物 + 引导 Button + 背景 + 引导 Button 的形式。<code>P240 ~ 241</code></li></ul></li></ul><h2 id="陆-服务设计"><a href="#陆-服务设计" class="headerlink" title="陆 服务设计"></a>陆 服务设计</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="服务设计的定义"><a href="#服务设计的定义" class="headerlink" title="服务设计的定义"></a>服务设计的定义</h4><p>一种新兴领域，主要关注通过 <code>有形、无形媒介的结合方式</code> 形成细致考量过的 <code>体验设计过程</code>。它已经在实践中为各种传统下行业都带来了更优良的用户体验。</p><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><blockquote><p>本章节将围绕一个虚构的餐馆为例，姑且称他为 <code>美食与爱</code>。</p></blockquote><ul><li><p>服务提供者：除一般含义的服务人员外，还包括电子显示屏、按钮开关等实体。</p><blockquote><p>在 <code>美食与爱</code> 中，就包括侍应、收银员、厨师、后台系统等。</p></blockquote></li><li><p>利益相关者：服务提供者所属的商业实体负责人。</p><blockquote><p>餐馆老板、门店经理、收银系统的服务商。</p></blockquote></li><li><p>服务设计团队：除设计师外，还包括利益相关者、一些顾客等。</p></li><li><p>顾客：指服务提供者面向的用户、消费者等。</p></li><li><p>触点：顾客与服务提供者之间每个有接触点的点。</p><blockquote><p>门口排位服务员、侍应、菜单、桌椅。</p></blockquote></li><li><p>服务周期：前期、中期和后期。</p><p>  以就餐为例：</p><ul><li><code>前期</code> 顾客感到饥饿时，有人推荐或搜 <code>美食与爱</code>，前往餐馆就餐。</li><li><code>中期</code> 到门店后，需排位等待，收号入座，点菜，等就餐，就餐，结账。</li><li><code>后期</code> 离开餐馆，呼叫的士回家 / 公司。 </li></ul></li></ul><h4 id="五个原则"><a href="#五个原则" class="headerlink" title="五个原则"></a>五个原则</h4><ul><li>用户至上：应通过客户的视角出发来设计整套服务。</li><li>合作创新：设计师 (主持人)，利益相关者，服务提供人员，顾客。每种角色必须从自己视角出发提出想法。</li><li>先后顺序：服务是一般以 <code>时间为序</code> 的 <code>动态</code> 的过程，而每一 <code>服务片段</code> 类似电影中的帧一样，把服务结构成一个个 <code>独立触点</code> 和 <code>交互行为</code>。</li><li><p>有理有据：服务是无形的，需要用人工制品的形式“显示”出来，让其容易被感知。</p><blockquote><p>例如，酒店的清洁人员在客人不在时打扫卫生。</p></blockquote></li><li><p>全局视觉：涉及的角色、触点众多，具备全局视觉，以统筹好各个环节。</p></li></ul><h3 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h3><p>以下介绍服务设计的基本流程，即 <code>探索</code> =&gt; <code>创造</code> =&gt; <code>反思</code> =&gt; <code>实施</code>。</p><ul><li><p><code>探索</code></p><ul><li>了解公司对于设计思维的态度，是否接受服务设计这样需要合作创新的设计流程。</li><li>找服务设计要解决的本质问题 (问题往往是公司自身的，或是从公司角度提出的)。</li><li><p>找出问题本质所在。</p><blockquote><p>从 <code>潜在顾客</code> 和 <code>顾客</code> 的角度出发，理解他们当时的处境以及做出对应行为背后的真实动机。</p></blockquote></li><li><p>设计师要把研究后的发现和现有服务流程可视化方法展现出来。</p></li></ul></li><li><p><code>创造</code>：产生解决方案的阶段</p><ul><li>服务设计的最大特点：鼓励各种试错，而不是避免出错。</li><li><p>阶段任务：</p><ul><li>基于探索阶段发现的核心问题；</li><li>基于顾客需求；</li><li>基于服务提供者本身诉求等约束条件；</li><li><p>基于用户旅程图的一系列的触点.</p><blockquote><p>设计新的方案，并不断加以迭代验证、优化方案。</p></blockquote></li></ul></li></ul></li><li><code>反思</code>：创新阶段产生新方案后，这个阶段要进行测试验证。<ul><li>产品原型 (人机交互 Demo / 实体产品小样)，找顾客或者专家进行测试评估，然后不断改进以达到预期目标。</li><li>服务原型：通过 <code>角色扮演</code> 等 <code>互动沉侵</code> 的方式，让顾客与服务之间产生 <code>真实的交互</code> 以及 <code>情感上的沟通</code>。</li></ul></li><li><code>实施</code>：工具 — <code>服务蓝图</code></li></ul><h3 id="工具箱"><a href="#工具箱" class="headerlink" title="工具箱"></a>工具箱</h3><p>在 <em>This is service design thinking</em> \(^{[1]}\) 中，列举了 24 种服务设计的工具，下述选择了其中三款常用工具进行阐述，即 <code>影子跟随法</code>、<code>顾客旅程图</code>、<code>服务蓝图</code>，若对此模块有兴趣可查阅原书学习。</p><h4 id="影子跟随法"><a href="#影子跟随法" class="headerlink" title="影子跟随法"></a>影子跟随法</h4><ul><li><p>概念：研究人员或设计师把自己融入到顾客的，前后台人员的日常生活或工作中去，像 <code>影子</code> 一样跟着他们去观察他们一举一动。</p><blockquote><p>该方法可以真正做到从全局或者 <code>上帝视觉</code> 审视整个服务运作方式。</p></blockquote></li></ul><h4 id="顾客旅程图"><a href="#顾客旅程图" class="headerlink" title="顾客旅程图"></a>顾客旅程图</h4><ul><li>概念：用 <code>顾客</code> 与 <code>服务</code> 之间产生互动的一个个 <code>触点</code> 来构成用户完整旅程的 <code>地图</code>。即这个图是从顾客的视角表达出所有与服务之间互动的行为以及由于互动而产生的情感。</li><li><p>如何绘制顾客旅程图</p><ul><li>1) 需要找到顾客与服务之间所有互动的行为触点。</li><li>2) 当所有行为触点找出后，按时序的方式进行罗列以形成完整的体验流程。</li><li>3) 然后通过访谈或利用顾客自己的描述和记录，以顾客口吻表达出他们每个步骤的心理活动，对应某种情绪，打分以形成情绪曲线图。</li><li><p>4) 分析旅程图中情绪分值较低部分 (尤其是 <code>谷底</code> 时)，找出问题所在，往往当中存在不错创新设计机会点。</p><p>如图 6-1 所示，为餐馆就餐的典型顾客旅程图。</p></li></ul></li></ul><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_6-1.png" alt="餐馆就餐的典型顾客旅程图"></p><center>图 6-1 餐馆就餐的典型顾客旅程图</center><h4 id="服务蓝图"><a href="#服务蓝图" class="headerlink" title="服务蓝图"></a>服务蓝图</h4><blockquote><p>服务蓝图，类似建筑设计的蓝图。</p></blockquote><ul><li>从全局的视觉详细地设计服务体系里包含的所有对象、交互、触点等的图形化语言。</li><li>该图包含多种角色：用户、服务提供者，涉及服务流程相关者，触点及后台流程。</li><li><p>服务蓝图绘制方法： </p><ul><li>首先按时序把 <code>用户新的行为</code> (设计后的行为) 从左到右罗列出来。并从服务的前中后阶段 (如就餐前、就餐时、就餐后) 对其进行分类。</li><li>在行为 <code>上一行</code>，列出用户行为所接触的物理触点或环境。</li><li>在行为 <code>下一行</code>，列出用户交互的服务提供者。</li><li><p>在行为 <code>下两行</code>，是后台服务提供者以及提供的支援流程。</p><p>如图 6-2 所示，针对餐馆优化后的服务蓝图。</p></li></ul></li></ul><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_6-2.png" alt="针对餐馆优化后的服务蓝图"></p><center>图 6-2 针对餐馆优化后的服务蓝图</center><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/5397784/" target="_blank" rel="noopener">[1] Schneider, Jakob. This is service design thinking [M]. Canada: BIS Publishers, 2011</a><br>[2] 赵晋. 波士顿矩阵分析在实际案例中的运用[J]. 中国高新技术企业,2008,(8).<br>[3] 张镜天. 波士顿矩阵在酒类营销中的运用[J]. 中国酒业. 2006,(1).<br>[4] 上海质量科学研究院. 顾客满意的测量、分析与改进[M]. 中国标准出版社,2009.10.  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26865230/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《 一个 APP 的诞生 》&lt;/a&gt;被定义是一本教科书、工具书，适合想通过 APP 实现自己的产品梦的受众通读，即通过本书可让你快速了解 APP 产品的整个流程，从零到一，创造 APP 产品。&lt;/p&gt;
&lt;p&gt;而通读本书籍后，或许你、我有同样的感受，即大部分内容是以设计师的角度看待问题的。这样，若你就是设计师，或许这将助你更加透彻理解 APP 的产出过程；若你是软件工程师，也可看待成是从另一角度理解软件过程。当然，这些知识只停留在书本层面，而对实际项目而言，有出入是无法避免的，但不失它的参考价值。简言之，这样一本图文并茂、实例贴近现实且含有众多跨界元素 (设计、开发、交互、产品等) 的工具书，特别是产品这一类别的书目 (下述还有同类型的书籍推荐)，不仅让你有机会感同身受业界优秀企业的工作流程，也是自身寻求产品方法论的不二选择。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://www.kofes.cn/categories/Reading/"/>
    
    
      <category term="APP" scheme="http://www.kofes.cn/tags/APP/"/>
    
      <category term="产品" scheme="http://www.kofes.cn/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="设计流程" scheme="http://www.kofes.cn/tags/%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B/"/>
    
      <category term="规范" scheme="http://www.kofes.cn/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>笔记 - 设计模式之 Android 实践与案例 ( 速记手册 )</title>
    <link href="http://www.kofes.cn/2018/01/Design-Pattern-Based-on-Android.html"/>
    <id>http://www.kofes.cn/2018/01/Design-Pattern-Based-on-Android.html</id>
    <published>2018-01-30T11:51:18.000Z</published>
    <updated>2018-03-19T12:39:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在你接触过的安卓项目当中，如监听器、适配器、迭代器等并不陌生，然而它们无不体现着设计模式的精髓。设计与模式的结合，往往与设计能力与代码质量息息相关。同理，逆过来思考此类问题，对于一些优秀项目、源码的理解障碍往往是对其设计 (逻辑、性能、解耦等) 的理解，而非源码本身。而作为开发者，知其然知其所以然，这也正是我们深入学习设计模式的理由之一。</p><p>当然，我们还要正视学习设计模式的心态。掌握了各种设计模式，并不代表你的设计能力与代码质量就会突飞猛进，同样在项目中运用设计模式也不是生搬硬套就解决问题了，在《 <a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">Head First 设计模式</a> 》一书中，则把设计模式的使用心智分为：初学者、中级人员和悟道者，虽有“玄学”的味道，但也恰当。即没有最好的模式，而是你综合众多因素，根据经验、方法来筛选合适的设计模式与你的项目结合，运用。</p><p>最后，对于设计模式的学习，不要局限于《 <a href="https://book.douban.com/subject/26644935/" target="_blank" rel="noopener">Android 源码设计模式</a> 》本身，你可以搭配一些经典论文、综述，或者书籍，以至于怀疑一个问题的正误，多比对、多思考，以得到最精确的理解。而本笔记的作用也在于此，即一个设计模式的架构，或是借鉴学习，亦或是复习之需便于查询。</p><a id="more"></a><ul><li><p>推荐书目：</p><ul><li>《 设计模式（可复用面向对象软件的基础）》：待补充</li></ul></li><li><p>更新进程</p><ul><li>2018.01.30 - 完成序言；</li><li>2018.01.31 - 更新第壹章；</li><li>2018.02.05 - 更新第贰章 ( 共 23 种设计模式 )；</li><li>2018.03.19 - 更新完毕.</li></ul></li></ul><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><ul><li><a href="#零-本书架构">零 本书架构</a></li><li><a href="#壹-面向对象编程六大原则">壹 面向对象编程六大原则</a></li><li><a href="#贰-二十三种设计模式解析">贰 二十三种设计模式解析</a></li><li><a href="#叁-MVC-与-MVP-模式">叁 MVC 与 MVP 模式</a></li></ul><h2 id="零-本书架构"><a href="#零-本书架构" class="headerlink" title="零 本书架构"></a>零 本书架构</h2><h3 id="面向对象六大原则"><a href="#面向对象六大原则" class="headerlink" title="面向对象六大原则"></a>面向对象六大原则</h3><ul><li><p>单一职责原则</p><blockquote><p>优化代码第一步。即就一个类而言，应该有且仅有一个引起它变化的原因。</p></blockquote></li><li><p>开闭原则</p><blockquote><p>让程序更稳定，更灵活。即软件中的对象（类、模块、函数等）应该对于扩展是开放的，但对于修改是封闭的。</p></blockquote></li><li><p>里氏替换原则</p><blockquote><p>构建扩展性更好的系统。</p></blockquote></li><li><p>依赖倒置原则  </p><blockquote><p>让项目拥有变化能力，即依赖抽象，不依赖具体实现。</p></blockquote></li><li><p>接口隔离原则</p><blockquote><p>系统拥有更高灵活性。</p></blockquote></li><li><p>迪米特原则</p><blockquote><p>也称为「最少知识原则」。即一个对象应对其他对象有最少的了解。</p></blockquote></li></ul><h3 id="二十三种设计模式"><a href="#二十三种设计模式" class="headerlink" title="二十三种设计模式"></a>二十三种设计模式</h3><div class="table-container"><table><thead><tr><th style="text-align:left">模式名称</th><th style="text-align:left">一句话描述</th></tr></thead><tbody><tr><td style="text-align:left">单例模式</td><td style="text-align:left">一个类只有一个实例</td></tr><tr><td style="text-align:left">Build 模式</td><td style="text-align:left">自由拓展你的项目</td></tr><tr><td style="text-align:left">原型模式</td><td style="text-align:left">使程序运行更高效</td></tr><tr><td style="text-align:left">工厂方法模式</td><td style="text-align:left">生成复杂对象</td></tr><tr><td style="text-align:left">抽象工厂模式</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left">策略模式</td><td style="text-align:left">时势造英雄</td></tr><tr><td style="text-align:left">状态模式</td><td style="text-align:left">随遇则安</td></tr><tr><td style="text-align:left">责任链模式</td><td style="text-align:left">使编程更有灵活性</td></tr><tr><td style="text-align:left">解释器模式</td><td style="text-align:left">化繁为简的翻译机</td></tr><tr><td style="text-align:left">命令模式</td><td style="text-align:left">让程序畅通执行</td></tr><tr><td style="text-align:left">观察者模式</td><td style="text-align:left">解决、解耦的钥匙</td></tr><tr><td style="text-align:left">备忘录模式</td><td style="text-align:left">编程中的后悔药</td></tr><tr><td style="text-align:left">迭代器模式</td><td style="text-align:left">解决问题的第三者</td></tr><tr><td style="text-align:left">模块方法模式</td><td style="text-align:left">抓住问题的核心</td></tr><tr><td style="text-align:left">访问者模式</td><td style="text-align:left">数据结构与操作分离</td></tr><tr><td style="text-align:left">中介者模式</td><td style="text-align:left">调解者模式或调停者模式</td></tr><tr><td style="text-align:left">代理模式</td><td style="text-align:left">委托模式</td></tr><tr><td style="text-align:left">组合模式</td><td style="text-align:left">物以类聚</td></tr><tr><td style="text-align:left">适配器模式</td><td style="text-align:left">得心应手粘合剂</td></tr><tr><td style="text-align:left">装饰模式</td><td style="text-align:left">动态给对象添加额外职责</td></tr><tr><td style="text-align:left">享元模式</td><td style="text-align:left">对象共享，避免创建多对象</td></tr><tr><td style="text-align:left">外观模式</td><td style="text-align:left">统一编程接口</td></tr><tr><td style="text-align:left">桥接模式</td><td style="text-align:left">连接两地的交通枢纽</td></tr></tbody></table></div><h3 id="MVC-与-MVP-模式"><a href="#MVC-与-MVP-模式" class="headerlink" title="MVC 与 MVP 模式"></a>MVC 与 MVP 模式</h3><h2 id="壹-面向对象编程六大原则"><a href="#壹-面向对象编程六大原则" class="headerlink" title="壹 面向对象编程六大原则"></a>壹 面向对象编程六大原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><ul><li>Single Responsibility Principle，SRP.</li><li>即就一个类而言，应该仅有一个引起它变化的原因。</li></ul><blockquote><p>如何划分一个类，一个函数的职责？每个人的经验不同，观点看法也不同，故视具体任务而定。但它也有一些基本的知道原则：  </p><ul><li>两个完全不一样的功能就不应该放到同一个类中。</li><li>一个类中应该是一组相关性很高的函数、数据的封装。</li></ul></blockquote><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><ul><li>Open Close Principle，OCP.</li><li>即软件中的对象（类、模块、函数等）应该对于扩展是开放的，但对于修改是封闭的。</li><li>勃兰特·梅耶. 《面向对象软件构造》中提倡：<ul><li>新的或改变的特性应通过新建不同的类实现，新建的类可通过 <code>继承</code> 的方式来重用原类的代码。</li><li>已存在的实现类对于修改是封闭的，但新的实现类可通过 <code>覆写父类的接口</code> 应对变化。</li></ul></li></ul><blockquote><p>开闭原则知道我们，当软件需变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。</p></blockquote><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><blockquote><p><strong>往往开闭原则与里氏替换原则是生死相依、不离不弃的。</strong></p></blockquote><ul><li>Liskov Substitution Principle，LSP。</li><li>所有引用基类的地方必须能透明地使用其子类的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测量视图的大小</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 绘制按钮</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Windows</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">show</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">child.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述例子中，任何继承自 View 类的子类都可以设置给 show 方法，即里氏替换。这样千变万化的 View 传递给 Window，Window 只管组织 View，并显示在屏幕上。</p></blockquote><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><ul><li>Dependence Inversion Principle，DIP.</li><li>一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节。</li><li><p>依赖倒置原则的几个关键点：    </p><ul><li><p>高层模块不应该依赖低层模块，两者都应以来其抽象（接口或抽象类）</p><blockquote><p>高层模块指调用端，低层模块指实现类。</p></blockquote></li><li><p>抽象不应该依赖细节</p></li><li>细节应依赖抽象</li></ul></li><li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系。一句话概括：<code>面向接口编程，面向抽编程</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设计一款实现图片缓冲功能的接口，具体的缓冲实现方式、细节，根据实际情况编写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageChache</span> </span>&#123;<span class="comment">// ImageCache 缓存抽象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryCache</span> <span class="keyword">implements</span> <span class="title">ImageCache</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据实际需求，再实现具体细节</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</span><br><span class="line"><span class="comment">// 图片缓存类，依赖抽象，不依赖细节</span></span><br><span class="line">ImageCache mCache = <span class="keyword">new</span> MemoryCache();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String url, ImageView imageView)</span> </span>&#123;</span><br><span class="line">Bitmap bmp = mCache.get(url);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == bmp)&#123;</span><br><span class="line">downloadImageAsync(url, imageView);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">imageView.setImageBitmap(bmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageCache</span><span class="params">(ImageCache cache)</span> </span>&#123;</span><br><span class="line">mCache = cache;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><ul><li>Interface Segregation Principles，ISP.</li><li>类间的依赖关系应建立在最小的接口上。ISP 将非常庞大、臃肿的接口拆分成更小的和更具体的接口。IPS的目的是系统解开耦合。</li></ul><blockquote><p>如上例中，ImageLoader 中的 ImageCache，ImageLoader 只需要知道该缓存对象有存、取缓存图片的接口即可，其他一概不管。</p></blockquote><h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3><ul><li><p>一个对象应对其他对象有最少的了解、即类的内部如何实现与调用者、依赖者没关系，调用者或依赖者之需知道它需要的方法即可，其他一概不管。</p></li><li><p>图 1-1 展示了租客、中介与房间相互之间的需求关系。</p><p>  <img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_1-1.png" alt="租客、中介与房间关系"></p>  <center>图 1-1 租客、中介与房间关系</center>   <p>  因为租客只需要房子，即把需求转达中介，对房子具体的租金、维修、签约等交由中介处理，租客不需要再了解细节。改进效果见图 1-2。</p><p>  <img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_1-2.png" alt="租客、中介与房间关系"></p>  <center>图 1-2 改进：租客、中介与房间的关系</center>  </li></ul><h2 id="贰-二十三种设计模式解析"><a href="#贰-二十三种设计模式解析" class="headerlink" title="贰 二十三种设计模式解析"></a>贰 二十三种设计模式解析</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="单例模式的定义"><a href="#单例模式的定义" class="headerlink" title="单例模式的定义"></a>单例模式的定义</h4><ul><li><p>确保某 <code>一个类只有一个实例</code> ，而且自行实例化并向整个系统提供这个实例。</p><blockquote><p><code>一个类只有一个实例</code> ：避免产生多个对象消耗过多资源，如访问 I/O 和数据库等资源。</p></blockquote></li></ul><h4 id="单例模式-UML-类图"><a href="#单例模式-UML-类图" class="headerlink" title="单例模式 UML 类图"></a>单例模式 UML 类图</h4><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-1.png" alt="单例模式示意图"></p><center>图 2-1 单例模式示意图</center> <ul><li><p>实现单例模式主要有如下几个关键点：</p><ul><li><code>构造函数</code> 不对外开放，一般设为 <code>私有</code> ；</li><li>通过一个 <code>静态方法</code> 或者 <code>枚举返回</code> 单例类对象；</li><li>确保单例类的对象有且只有一个，尤其多线程环境下；</li><li><p>确保单例类对象在 <code>反序列化</code> 时不会重新构建对象；</p><blockquote><p>序列化：将对象的状态信息转换为可以存储或传输的形式的过程。一般将一个对象存储至一个储存媒介，例如档案或是记亿体缓冲等。在网络传输过程中，可以是字节或是XML等格式。  </p><p>反序列化：而字节的或XML编码格式可以还原完全相等的对象。这个相反的过程又称为反序列化。</p></blockquote></li></ul></li></ul><h4 id="单例模式的简单示例"><a href="#单例模式的简单示例" class="headerlink" title="单例模式的简单示例"></a>单例模式的简单示例</h4><p>例如一个公司只有一个 CEO，一个应用只有一个 Application 对象等。下面以公司里的 CEO 为例来简单演示，即一个公司可有几个 VP，无数个员工，但 CEO 只有一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 员工的基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Staff</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 忽略执行细节</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 副总裁类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VP</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 覆写执行细节</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉单例模式：声明静态对象时已初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CEO</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123; <span class="comment">// 公司保证只有一个 CEO</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CEO mCeo = <span class="keyword">new</span> CEO();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">CEO</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CEO <span class="title">getCeo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mCeo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 覆写执行细节</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 实际中使用：</span></span><br><span class="line"><span class="comment"> * CEO 类不能通过 new 的形式构造对象，只能通过 CEO.getCeo() 函数获取。</span></span><br><span class="line"><span class="comment"> * CEO 对象是静态对象，并在声明时已初始化，保证 CEO 对象的唯一性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line">Staff ceo1 = CEO.getCeo();</span><br><span class="line">Staff ceo2 = CEO.getCeo();</span><br></pre></td></tr></table></figure><h4 id="单例模式的其他实现方式"><a href="#单例模式的其他实现方式" class="headerlink" title="单例模式的其他实现方式"></a>单例模式的其他实现方式</h4><h5 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h5><ul><li>声明一静态对象；</li><li>调用 getInstance() 方法初始化 ( 用时才初始化，即惰性处理机制 )</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉单例模式：用时才初始化，即惰性处理机制</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instantce;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 synchronized 关键字，即 getInstance() 是一个同步方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">null</span> == instance ) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>懒汉单例模式的优缺点：  <ul><li>优点 - 使用时才实例化，一定程度上节约资源。  </li><li>缺点 - 每次调用 getInstance() 都进行同步，造成不必要同步开销。</li></ul></li></ul><h5 id="Double-CheckLock-DCL"><a href="#Double-CheckLock-DCL" class="headerlink" title="Double CheckLock (DCL)"></a>Double CheckLock (DCL)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">// private static Singleton sInstance = null;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton sInstance = <span class="keyword">null</span>; <span class="comment">// 保证 sInstance 对象每次都是从主内存存、读取。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"do sth."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">null</span> == sInstance ) &#123; <span class="comment">// 避免不必要同步</span></span><br><span class="line"><span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">null</span> == sInstance ) &#123; <span class="comment">// 此处判空操作，是因为 Java 编译器允许处理器乱序执行，具体解析见注解</span></span><br><span class="line">sInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DCL 又称「丑陋的优化」？  </p><p>DCL 虽一定程度解决了资源消耗，多余同步、线程安全等问题，但某种情况下还是会出现失效问题 ( 双重检查锁定(DCL) )，即称「丑陋的优化」。</p><ul><li><p>线程A，执行 <code>sInstance = new Singleton();</code>，编译器会编译成多条汇编指令，具体汇编指令的分工为：  </p><ul><li>Step.01 给 Singleton 实例分配内存；  </li><li>Step.02 调用 Singleton() 的构造函数；  </li><li>Step.03 将 sInstance 对象指向分配的内存空间；  </li></ul></li><li><p>然而 Java 编译器允许处理器乱序执行，即有「1-2-3」或「1-3-2」的执行顺序。</p></li><li>若执行「1-3-2」的顺序，这样会使 DCL 的优化失效，即第三步执行完毕，sInstance 非空，线程B取走 sInstance。再使用时就会报错。</li></ul><h5 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonHolder.sInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123; <span class="comment">// 静态内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton sInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次加载 Singleton 的 getInstance() 方法才会使 sInstance 被初始化。因此，第一次调用 getInstance() 方法会导致虚拟机加载 SingletonHolder 类.</p><blockquote><p>内部类是延时加载的，只会在第一次使用时加载，不使用不加载。这样，即保证了线程安全，又保证单例对象唯一性，同时也延迟单例的实例化。</p></blockquote><h5 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认枚举实例的创建是线程安全的，并且在任何情况下它都是一个单例。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">INSTANCE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"do sth."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>不管以哪种形式实现单例模式，它们的核心原理都是将 <code>构造函数私有化</code> ，并通过 <code>静态方法获取一个唯一的实例</code> 。</p><blockquote><p>获取实例的过程须保证线程安全，防止反序列化导致重新生成实例对象等。</p></blockquote></li><li><p>选择哪种实现形式取决项目本身，如是否是复杂的并发环境、JDK 版本是否过低、单例对象的资源消耗等。</p></li><li>单例模式的优缺点<ul><li>优点<br>1) 只生成一个实例，减少系统的性能开销；<br>2) 当一对象的产生需要较多资源时，如读取配置、产生其他依赖对象时，可通过应用启动时直接产生一个单例对象，永久驻留内存。  </li><li>缺点<br>1) 单例模式一般没有接口，扩展性难；<br>2) 单例对象若持有 Context，那么很容易引发内存泄漏，此时需注意传递给单例对象的 Context 应该是 <code>Application.Context</code> 。</li></ul></li></ul><h3 id="Bulider-模式"><a href="#Bulider-模式" class="headerlink" title="Bulider 模式"></a>Bulider 模式</h3><h4 id="Bulider-模式的定义"><a href="#Bulider-模式的定义" class="headerlink" title="Bulider 模式的定义"></a>Bulider 模式的定义</h4><ul><li>创建型设计模式。</li><li>将一个复杂对象的 <code>构建</code> 与它的 <code>表示</code> 分离，使得同样的构建过程可以创建不同的表示。</li><li>Builder 模式是一步步创建一个复杂对象的，它允许用户在不知内部构建细节的情况下，可以更精细地控制对象的构造流程。</li></ul><h4 id="Builder-模式的使用场景"><a href="#Builder-模式的使用场景" class="headerlink" title="Builder 模式的使用场景"></a>Builder 模式的使用场景</h4><ul><li>产品类非常复杂，或产品类中调用顺序不同产生不同的作用，这时需要使用 Builder 模式。</li><li>初始化一个对象特别复杂，如参数多，且很多参数都具有默认值。</li></ul><h4 id="Builder-模式的UML类图"><a href="#Builder-模式的UML类图" class="headerlink" title="Builder 模式的UML类图"></a>Builder 模式的UML类图</h4><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-2.png" alt="Builder模式示意图"></p><center>图 2-2 Builder 模式示意图</center> <h4 id="Builder-模式的简单实现"><a href="#Builder-模式的简单实现" class="headerlink" title="Builder 模式的简单实现"></a>Builder 模式的简单实现</h4><p>便于理解，本示例的 UML 类图见图 2-3。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-3.png" alt="计算机组装过程"></p><center>图 2-3 计算机组装过程</center> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 下述程序以计算机组装过程简化为：构建主机，设置操作系统，设置显示器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 计算机抽象类，即 Product 角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> String mBoard;</span><br><span class="line"> <span class="keyword">protected</span> String mDisplay;</span><br><span class="line"> <span class="keyword">protected</span> String mOS;</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="title">Computer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBoard</span><span class="params">(String board)</span> </span>&#123; <span class="comment">// 设置 CPU 核心数</span></span><br><span class="line"> mBoard = board;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisplay</span><span class="params">(String display)</span> </span>&#123; <span class="comment">// 设置内存</span></span><br><span class="line"> mDisplay = display;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setOS</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">"Computer[...]"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体的 Computer 类 - MacBook</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Macbook</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="title">Macbook</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> mOS = <span class="string">"MAC OSX 10.10"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 抽象 Builder 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBoard</span><span class="params">(String board)</span></span>; <span class="comment">// 设置主机</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildOS</span><span class="params">()</span></span>; <span class="comment">// 设置操作系统</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildDisplay</span><span class="params">(String display)</span></span>; <span class="comment">// 设置显示器</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">create</span><span class="params">()</span></span>; <span class="comment">// 创建 Computer</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体的 Builder 类 - MacbookBuilder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacbookBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Computer mComputer = <span class="keyword">new</span> Macbook();</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBoard</span><span class="params">(String board)</span></span>&#123;</span><br><span class="line"> mComputer.setBoard(board);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDisplay</span><span class="params">(String display)</span> </span>&#123;</span><br><span class="line"> mComputer.setDisplay(display);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildOS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> mComputer.setOS();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Computer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> mComputer;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Director 类，负责构造 Computer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line"> Builder mBuilder = <span class="keyword">null</span>;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line"> mBuilder = builder;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(String board, String display)</span> </span>&#123;</span><br><span class="line"> mBuilder.buildBoard(board);</span><br><span class="line"> mBuilder.buildDisplay(display);</span><br><span class="line">mBuilder.buildOS();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Builder builder = <span class="keyword">new</span> MacbookBuilder(); <span class="comment">// 构造器</span></span><br><span class="line"> Director pcDirector = <span class="keyword">new</span> Director(builder); <span class="comment">// Director</span></span><br><span class="line"> <span class="comment">// 封装构建过程</span></span><br><span class="line"> pcDirector.construct(<span class="string">"英特尔主板"</span>, <span class="string">"Retina 显示器"</span>);</span><br><span class="line"> System.out.println(<span class="string">"Computer Info: "</span> + builder.create().toString());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Builder-模式实战"><a href="#Builder-模式实战" class="headerlink" title="Builder 模式实战"></a>Builder 模式实战</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 知名图片加载库：Universal-Image-Loader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">ImageLoaderConfiguration config = <span class="keyword">new</span> ImageLoaderConfiguration</span><br><span class="line">.Builder(context) <span class="comment">// 用户只能通过 Builder 对象构建 ImageLoaderConfiguration 对象，这就是构建和表示相分离</span></span><br><span class="line">.threadPriority(Thread_NORM_PRIORITY_2)</span><br><span class="line">.denyCacheImageMultipleSizesInMemory()</span><br><span class="line">.discCacheFileNameGenerator( <span class="keyword">new</span> MD5FileNameGenerator() )</span><br><span class="line">.tasksProcessingOrder(QueueProcessingType.LIFO)</span><br><span class="line">.bulider();</span><br><span class="line"></span><br><span class="line">ImageLoader.getInstance().init(config);</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>Builder 模式，通过作为配置类的构建器将配置的构建和表示分离开来，同时也将配置从目标类中隔离出来，避免过多的 Setter 方法暴露在目标类当中。</li><li>Builder 模式的优缺点<ul><li>优点<br>1) 良好的封装性，不必知道产品内部组成的细节；<br>2) 建造者独立，易于扩展。</li><li>缺点<br>1) 产生多余 Builder 对象及 Director 对象，消耗内存。</li></ul></li></ul><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h4 id="原型模式的定义"><a href="#原型模式的定义" class="headerlink" title="原型模式的定义"></a>原型模式的定义</h4><ul><li>创建型的模式。</li><li>定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。<ul><li>原型拥有样板实例，可克隆内部属性一致的对象。</li><li>原型模式多用于创建复杂的或构建耗时的实例，即复制一个已经存在的实例可使程序运行更高效。</li></ul></li></ul><h4 id="原型模式的使用场景"><a href="#原型模式的使用场景" class="headerlink" title="原型模式的使用场景"></a>原型模式的使用场景</h4><ul><li>类初始化需消耗非常多的资源 ( 数据、硬件资源等 )。</li><li>通过 new 产生一个对象需要非常繁琐的数据准备或访问权限。</li><li>一个对象需提供其他对象访问，且各调用者可能都需修改其值时，可考虑用原型模式或拷贝多个对象以供调用者使用，即 <code>保护性拷贝</code> 。</li></ul><h4 id="原型模式的-UML-类图"><a href="#原型模式的-UML-类图" class="headerlink" title="原型模式的 UML 类图"></a>原型模式的 UML 类图</h4><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-4.png" alt="Builder模式示意图"></p><center>图 2-4 原型模式的 UML 类图</center> <h4 id="原型模式的简单实现"><a href="#原型模式的简单实现" class="headerlink" title="原型模式的简单实现"></a>原型模式的简单实现</h4><p>便于理解，本示例的 UML 类图见图 2-5。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-5.png" alt="WordDocument文档编辑器"></p><center>图 2-5 WordDocument 文档编辑器</center> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * WordDocument 具有文字、图片编辑功能的简单文档处理类。且为保护源文件，其可在克隆对象上作内容修改。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDocument</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"><span class="comment">// WordDocument 扮演 ConcretePrototype 角色</span></span><br><span class="line"><span class="comment">// Cloneable 扮演 Prototype 角色</span></span><br><span class="line"><span class="keyword">private</span> String mText; <span class="comment">// 文本</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;String&gt; mImages = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 图片名列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WordDocument</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 忽略实现细节</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WordDocument <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">WordDocument doc = (WordDocument) <span class="keyword">super</span>.clone();</span><br><span class="line">doc.mText = <span class="keyword">this</span>.mText;</span><br><span class="line">doc.mImages = <span class="keyword">this</span>.mImages;</span><br><span class="line"><span class="keyword">return</span> doc;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mText;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String mText)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mText = mText;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mImages;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addImage</span><span class="params">(String img)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mImages.add(img);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDocument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Text:"</span> + mText);</span><br><span class="line">System.out.println(<span class="string">"Images List:"</span>);</span><br><span class="line"><span class="keyword">for</span>(String imgName:mImages) &#123;</span><br><span class="line">System.out.println(<span class="string">"image name:"</span> + imgName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">WordDocument originDoc = <span class="keyword">new</span> WordDocument();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Partion A start */</span></span><br><span class="line">originDoc.setText(<span class="string">"This is a Aircle"</span>);</span><br><span class="line">originDoc.addImage(<span class="string">"Image A"</span>);</span><br><span class="line"><span class="comment">/* Partion A end */</span></span><br><span class="line">originDoc.showDocument();</span><br><span class="line"></span><br><span class="line">WordDocument secDoc = originDoc.clone();</span><br><span class="line">secDoc.showDocument();</span><br><span class="line">secDoc.setText(<span class="string">"This is a Paper"</span>); <span class="comment">// 只是改变了引用指向</span></span><br><span class="line">secDoc.showDocument();</span><br><span class="line">originDoc.showDocument(); <span class="comment">// 还是输出 Partion A 的结果</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：通过 clone() 拷贝对象时并不会执行构造函数。如果在构造函数中需要一些特殊的初始化操作类型，在使用 Cloneable 实现拷贝时，注意构造函数不会执行的问题。</p></blockquote><h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><ul><li><p>浅拷贝：上述例子实际上只是一个浅拷贝，也称 <code>影子拷贝</code>，即只是副本文档引用原始文档的字段。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-6.png" alt="浅拷贝示意图"></p><center>图 2-6 浅拷贝示意图</center> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">secDoc.setText(<span class="string">"This is a Paper."</span>);</span><br><span class="line">secDoc.addImage(<span class="string">"Image B"</span>);</span><br><span class="line">secDoc.showDocument(); <span class="comment">// Case 1</span></span><br><span class="line">originDoc.showDocument(); <span class="comment">// Case 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Case 1，2 都增加了图片 “Image B”，原因是 secDoc 只是单纯指向了 this.mImages</span></span><br></pre></td></tr></table></figure></li><li><p>深拷贝：为了解决浅拷贝所带来的“问题” ( 视具体问题而定 )，引入深入拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WordDocument <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">WordDocument doc = (WordDocument) <span class="keyword">super</span>.clone();</span><br><span class="line">doc.mText = <span class="keyword">this</span>.mText;</span><br><span class="line"><span class="comment">// doc.mImages 指向 mImages 的一份拷贝，而不是 this.mImages 本身</span></span><br><span class="line">doc.mImages = (ArrayList&lt;String&gt;) <span class="keyword">this</span>.mImages.clone();</span><br><span class="line"><span class="keyword">return</span> doc;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="原型模式实战"><a href="#原型模式实战" class="headerlink" title="原型模式实战"></a>原型模式实战</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在线用户信息修改 (需登录后修改用户信息)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String phoneNum;</span><br><span class="line"><span class="keyword">public</span> Adress,adress;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"User[age=...]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">Login</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> login()</span></span>;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginImpl</span> <span class="keyword">implements</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">User loginedUser = <span class="keyword">new</span> User(); <span class="comment">// 登录服务器，获取用户信息</span></span><br><span class="line">loginedUser.age = <span class="number">12</span>;</span><br><span class="line">loginedUser.name = <span class="string">"Mr.Sample"</span>;</span><br><span class="line">loginedUser.address = <span class="keyword">new</span> Address(<span class="string">"BeiJing"</span>, <span class="string">"HaiDing"</span>, <span class="string">"Garden Rd"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录完成后，将用户信息设置到 Session:</span></span><br><span class="line">LoginSession.getLoginSession()</span><br><span class="line">.setLoginedUser(loginedUser)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录 Session</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginSession</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> LoginSession sLoginSession = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> User longinedUser; <span class="comment">// 已登录用户</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LoginSession</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoginSession <span class="title">getLoginSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == sLoginSession) &#123;</span><br><span class="line"> sLoginSession = <span class="keyword">new</span> LoginSession();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> sLoginSession;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包级私有：即不加任何修饰符，该模式(默认访问模式)下，只允许在同一包中进行访问</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLoginedUser</span><span class="params">(User user)</span> </span>&#123; <span class="comment">// 设置已登录用户信息，不对外开放</span></span><br><span class="line">loginedUser = user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getLoginedUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> loginedUser;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Partion A : 以下是实际执行部分，可能在不同包的某个类下执行 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取已登录的 User 对象</span></span><br><span class="line">User newUser = LoginSession.getLoginSession().getLoginedUser();</span><br><span class="line"><span class="comment">// 更新用户信息</span></span><br><span class="line">newUser.address = <span class="keyword">new</span> Adress(<span class="string">"BeiJing"</span>, <span class="string">"ChaoYang"</span>, <span class="string">"DaWang Rd"</span>);</span><br></pre></td></tr></table></figure><p>用户信息的更新，限定于与 LoginSession 类在同一包下才能执行，即 Partion A 的操作，使这样的限定失效。我们可作以下改进：</p><ul><li>在 User 类中实现 Cloneable 接口。</li><li>在 LoginSession 中将 getLoginedUser() 改为 <code>return loginedUser.clone()</code> ，即在任何地方调用，获得的都是用户拷贝的对象，修改只是作用于拷贝的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 Cloneable 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123; <span class="comment">// 用户实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String phoneNum;</span><br><span class="line"><span class="keyword">public</span> Adress,adress;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">User user = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">user = (User) <span class="keyword">super</span>.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span>(CLoneNotSupportedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"User[age=...]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginSession</span> </span>&#123; </span><br><span class="line"><span class="comment">// 即管在任何地方调用，获得的都是用户拷贝的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getLoginedUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> loginedUser.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul><li>原型模式的优缺点<ul><li>优点 - 原型模式是在内存中二进制的拷贝，比 new 一个对象性能更优。</li><li>缺点 - 内存中拷贝，构造函数是不会执行的。</li></ul></li></ul><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><h4 id="工厂方法模式的定义"><a href="#工厂方法模式的定义" class="headerlink" title="工厂方法模式的定义"></a>工厂方法模式的定义</h4><ul><li>创建型设计模式。</li><li>定义一个用于创建对象的接口，让子类决定实例化哪个类。</li></ul><h4 id="工厂方法模式的使用场景"><a href="#工厂方法模式的使用场景" class="headerlink" title="工厂方法模式的使用场景"></a>工厂方法模式的使用场景</h4><ul><li>复杂对象的创建，而用 New 就可以完成创建的对象则不必使用工厂方法了。</li></ul><h4 id="工厂方法模式的-UML-类图"><a href="#工厂方法模式的-UML-类图" class="headerlink" title="工厂方法模式的 UML 类图"></a>工厂方法模式的 UML 类图</h4><p>工厂方法模式的 UML 如图 2-7 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-7.png" alt="浅拷贝示意图"></p><center>图 2-7 工厂方法模式 UML 类图</center> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123; <span class="comment">// 具体产品 A</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我是具体的产品A."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductB</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123; <span class="comment">// 具体产品 B</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我是具体的产品B."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123; <span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @return 具体的产品对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 返回具体产品 A 或者具体产品 B</span></span><br><span class="line"><span class="comment">// return new ConcreteProductA();</span></span><br><span class="line"><span class="comment">// return new ConcreteProductB();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Factory factory = <span class="keyword">new</span> ConcreteFactory();</span><br><span class="line">Product p = factory.createProduct();</span><br><span class="line">p.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们可以利用反射的方式实现多工厂方法模式，具体见下述代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 具体生产什么由子类去实现</span></span><br><span class="line"><span class="comment"> * @param clz 产品对象类类型</span></span><br><span class="line"><span class="comment"> * @return 具体的产品对象</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span>&lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(class&lt;T&gt; clz)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(class&lt;T&gt; clz)</span> </span>&#123;</span><br><span class="line">Product p = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">p = (Product) <span class="class"><span class="keyword">class</span>.<span class="title">forName</span>(<span class="title">clz</span>.<span class="title">getName</span>()).<span class="title">newInstance</span>()</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端中实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Factory factory = <span class="keyword">new</span> ConcreteFactory();</span><br><span class="line">Product p = factory.createProduct(ConcreteProductA.class);</span><br><span class="line">p.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="工厂方法模式的简单实现"><a href="#工厂方法模式的简单实现" class="headerlink" title="工厂方法模式的简单实现"></a>工厂方法模式的简单实现</h4><p>某汽车厂主要就是组装某款 SUV 车型，比如 Q3、Q5、Q7，对于这类车型来说，内部结构差异并不是很大，因此一条生产线足以应付 3 种车型，对于该类生产线可提供一抽象类定义。</p><p>便于理解，本示例的 UML 类图见图 2-8。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-8.png" alt="某工厂生产某车型的工厂方法"></p><center>图 2-8 某工厂生产某车型的工厂方法</center> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 某工厂生产某种车型的工厂方法</span></span><br><span class="line"><span class="comment"> * @param clz 具体的 SUV 型号类型</span></span><br><span class="line"><span class="comment"> * @return 具体型号的 SUV 车对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span>&lt;T extends AudiCar&gt; <span class="function">T <span class="title">createAudiCar</span><span class="params">(class&lt;T&gt; clz)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiCarFactory</span> <span class="keyword">extends</span> <span class="title">AudiFactory</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends AudiCar&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(class&lt;T&gt; clz)</span> </span>&#123;</span><br><span class="line">Product p = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">p = (AudiCar) <span class="class"><span class="keyword">class</span>.<span class="title">forName</span>(<span class="title">clz</span>.<span class="title">getName</span>())</span></span><br><span class="line"><span class="class">.<span class="title">newInstance</span>()</span>; </span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汽车的抽象产品类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiCar</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">selfNavigation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体车型：Q3</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiQ3</span> <span class="title">exntends</span> <span class="title">AudiCar</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Q3 Launched!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfNavigation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Q3 starts a auto-navigation!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AudiFactory factory = <span class="keyword">new</span> AudiFactory();</span><br><span class="line">AudiQ3 audiQ3 = factory.createProduct(AudiQ3.class);</span><br><span class="line">audiQ3.dirve();</span><br><span class="line">audiQ3.selfNavigation();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="工厂方法模式的实战"><a href="#工厂方法模式的实战" class="headerlink" title="工厂方法模式的实战"></a>工厂方法模式的实战</h4><p>Android 数据持久化有很多方式，如 SharedPreferences (XML)、SQLite (关系数据库)。对数据操作的方法无非就是增、删、改、查，若我们将每种数据储存的方式作为一个产品类，在抽象产品类中定义对数据操作的方法，即我们宏观层面把握操作的逻辑，具体的实现逻辑由储存数据的方式决定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IOHandler</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String id, String name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String id, String name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">query</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> <span class="keyword">extends</span> <span class="title">IOHandler</span> </span>&#123; <span class="comment">// 普通文件存储</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String id, String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String id, String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> </span><br><span class="line"><span class="keyword">return</span> <span class="string">"AigeStudio"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLHandler</span> <span class="keyword">extends</span> <span class="title">IOHandler</span> </span>&#123; <span class="comment">// XML 文存储</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String id, String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String id, String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"SMBrother"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBHandler</span> <span class="keyword">extends</span> <span class="title">IOHandler</span> </span>&#123; <span class="comment">// SQLite 数据库存储</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String id, String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String id, String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"Android"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取 IO 处理者</span></span><br><span class="line"><span class="comment"> * @param clz IOHandler 类型的类类型</span></span><br><span class="line"><span class="comment"> * @return IOHandler 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends IOHandler&gt; <span class="function">T <span class="title">getIOHandler</span><span class="params">(class&lt;T&gt; clz)</span> </span>&#123;</span><br><span class="line">IOHandler handler = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> handler = (IOHandler) <span class="class"><span class="keyword">class</span>.<span class="title">forName</span>(<span class="title">clz</span>.<span class="title">getName</span>())</span></span><br><span class="line"><span class="class"> .<span class="title">newInstance</span>()</span>;</span><br><span class="line"> &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> (T) handler;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle saveInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(saveInstanceState);</span><br><span class="line">setContentView(R.layout.activity_factory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取显示查询内容的 TextView 对象</span></span><br><span class="line"><span class="keyword">final</span> TextView tvContent = (TextView) <span class="keyword">this</span>.findViewById(R.id.factory_content_tv);</span><br><span class="line"><span class="comment">// 获取查询普通文件数据的按钮对象，并设置监听</span></span><br><span class="line">Button btnFile = (Button) <span class="keyword">this</span>.findViewById(R.id.factory_file_btn);</span><br><span class="line">btnFile.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">IOHandler handler = IOFactory.getIOHanHandler(FileHandler.class);</span><br><span class="line">Log.d(<span class="string">"AigeStudio"</span>, handler.query(<span class="string">"4455645646"</span>));</span><br><span class="line">tvContent.setText(handler.query(<span class="string">"4455645646"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><h4 id="抽象工厂模式的定义"><a href="#抽象工厂模式的定义" class="headerlink" title="抽象工厂模式的定义"></a>抽象工厂模式的定义</h4><ul><li>创建型设计模式。</li><li>为创建一组相关或者是相互依赖的对象 提供一个 <code>接口</code> ，而不需要指定它们的具体类。</li></ul><h4 id="抽象工厂模式的使用场景"><a href="#抽象工厂模式的使用场景" class="headerlink" title="抽象工厂模式的使用场景"></a>抽象工厂模式的使用场景</h4><p>一个对象族有相同约束时可以使用抽象工厂模式。如：<br>Android、iOS、Window Phone 下都有短信软件和拨号软件，两者属于软件范畴，但由于操作系统平台不一样，其代码实现细节也是有差异的，则我们可考虑使用抽象工厂方法模式去产生不同平台下的同款软件。</p><h4 id="抽象工厂模式的-UML-类图"><a href="#抽象工厂模式的-UML-类图" class="headerlink" title="抽象工厂模式的 UML 类图"></a>抽象工厂模式的 UML 类图</h4><p>抽象工厂方法模式的 UML 如图 2-9 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-9.png" alt="抽象工厂方法模式UML类图"></p><center>图 2-9 抽象工厂方法模式 UML 类图</center> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span> </span>&#123; <span class="comment">// 抽象产品类 A</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> abstractvoid <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductB</span> </span>&#123; <span class="comment">// 抽象产品类 B</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> abstractvoid <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProducxtA1</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123; <span class="comment">// 具体产品类 A1</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体产品 A1 的方法."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProducxtA2</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123; <span class="comment">// 具体产品类 A2</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体产品 A2 的方法."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProducxtB1</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span> </span>&#123; <span class="comment">// 具体产品类 B1</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"具体产品 B1 的方法."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProducxtB2</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span> </span>&#123; <span class="comment">// 具体产品类 B2</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体产品 B2 的方法."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123; <span class="comment">// 抽象工厂类</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建产品 A 的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 产品 A 的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建产品 B 的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 产品 B的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123; <span class="comment">// 具体工厂类1</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductA <span class="title">createProductA1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA1();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductB <span class="title">createProductB1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB1();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123; <span class="comment">// 具体工厂类2</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductA <span class="title">createProductA2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA2();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductB <span class="title">createProductB2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB2();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象工厂模式的简单实现"><a href="#抽象工厂模式的简单实现" class="headerlink" title="抽象工厂模式的简单实现"></a>抽象工厂模式的简单实现</h4><p>在简单工厂模式的简单实现中，我门以车厂生产汽车为例。虽 Q3、Q5、Q7 同为一车系，但三者之间的零部件产别却很大，如 Q3、Q7 当中，Q3 装配的是国产发动机，普通轮胎和普通制动系统；Q7 则装配的是进口发动机，全尺寸越野轮胎和制动性能极好的制动系统。</p><p>即同为一系列车，大家共有部件有发动机、轮胎和制动系统等，由于具体的部件品质不同，装配的细节又不同。故我们可将抽象工厂模式应用当中，化繁为简。具体的架构如图 2-10 的 UML 类图所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-10.png" alt="车厂生产同系列汽车的抽象工厂模式"></p><center>图 2-10 车厂生产同系列汽车的抽象工厂模式</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产轮胎</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ITire 轮胎</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ITire <span class="title">createTire</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产发动机</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> IEngine 发动机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IEngine <span class="title">createEngine</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产制动系统</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> IBrake 制动系统</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IBrake <span class="title">createBrake</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITire</span> </span>&#123; <span class="comment">// 轮胎</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tire</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalTire</span> <span class="keyword">implements</span> <span class="title">ITire</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"普通轮胎"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SUVTire</span> <span class="keyword">implements</span> <span class="title">ITire</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"越野轮胎"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">IEngine</span><span class="params">()</span> </span>&#123; <span class="comment">// 发动机</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DomesticEngine</span> <span class="keyword">implements</span> <span class="title">IEngine</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"国产发动机"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportEngine</span> <span class="keyword">implements</span> <span class="title">IEngine</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"进口发动机"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBrake</span> </span>&#123; <span class="comment">// 制动系统</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalBrake</span> <span class="keyword">implements</span> <span class="title">IBrake</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"普通制动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeniorBrake</span> <span class="keyword">implements</span> <span class="title">IBrake</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"高级制动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q3Factory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span> </span>&#123; <span class="comment">// Q3工厂类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ITire <span class="title">createTire</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NormalTire();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEngine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="function">Domestic <span class="title">Engine</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IBrake <span class="title">createBrake</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NormalBrake();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q3Factory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span> </span>&#123; <span class="comment">// Q3工厂类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ITire <span class="title">createTire</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NormalTire();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEngine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DomesticEngine();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IBrake <span class="title">createBrake</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NormalBrake();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q7Factory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span> </span>&#123; <span class="comment">// Q7 工厂类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ITire <span class="title">createTire</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SUVTire();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEngine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ImportEngine();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@verride</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IBrake <span class="title">createBrake</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SeniorBrake();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 构造一个生产 Q3 的工厂</span></span><br><span class="line">CarFactory factoryQ3 = <span class="keyword">new</span> Q3Factory();</span><br><span class="line">factoryQ3.createTire().tire();</span><br><span class="line">factoryQ3.createEngine().engine();</span><br><span class="line">factoryQ3.createBrake().brake();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 构造一个生产 Q7 的工厂</span></span><br><span class="line">CarFactory factoryQ7 = <span class="keyword">new</span> Q7Factory();</span><br><span class="line">factoryQ7.createTire().tire();</span><br><span class="line">factoryQ7.createEngine().engine();</span><br><span class="line">factoryQ7.createBrake().brake();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><ul><li>抽象工厂方法模式的优缺点<ul><li>优点 - 分离接口与实现，即客户端使用抽象工厂的创建对象，客户端不知具体实现是谁，客户端只是面向产品的接口编程而已，使其从具体的产品实现中解耦。</li><li>缺点<br>1) 类文件的爆炸性增加。<br>2) 不太容易扩展新的产品类，因为每当增加一个产品类，就需修改抽象工厂，故所有具体工厂类均会被修改。</li></ul></li></ul><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h4 id="策略模式的介绍"><a href="#策略模式的介绍" class="headerlink" title="策略模式的介绍"></a>策略模式的介绍</h4><p>实现某功能，可以有多种算法或策略选择，例如排序算法，有插入排序、归并排序、冒泡排序等。</p><blockquote><p>思考：多种排序算法，可以写在一个类中，一个方法对应一种具体排序。但是缺点也是很明显，即臃肿；维护成本高，且容易引发错误；每增加一种排序需修改封装类的源码。  </p><p>改进：提供一个统一接口，不同的算法或策略有不同的实现类。</p></blockquote><h4 id="策略模式的使用场景"><a href="#策略模式的使用场景" class="headerlink" title="策略模式的使用场景"></a>策略模式的使用场景</h4><ul><li>针对同类问题的多种处理方式，仅仅是 <code>具体行为</code> 有差别。</li><li>需要安全地封装多种 <code>同类型</code> 的操作。</li><li><p>出现同一抽象类，有多个子类，而又需使用 <code>if-else</code> 或 <code>switch-case</code>  来选择具体子类。</p><blockquote><p>但缺点也明显，耦合性高；代码臃肿难维护。</p></blockquote></li></ul><h4 id="策略模式的-UML-类图"><a href="#策略模式的-UML-类图" class="headerlink" title="策略模式的 UML 类图"></a>策略模式的 UML 类图</h4><p>策略模式的 UML 如图 2-11 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-11.png" alt="策略模式UML类图"></p><center>图 2-11 策略模式 UML 类图</center> <h4 id="策略模式的简单实现"><a href="#策略模式的简单实现" class="headerlink" title="策略模式的简单实现"></a>策略模式的简单实现</h4><p>下面以在北京乘坐公共交通工具的费用计算来演示一简单示例。在 2014 年 12 月 20 号之后，北京提高公交价格，不在是单一票价制，而是分段计费。显然，公交车和地铁的价格计算方式是不一样的。但是，我们的示例中是需要计算乘不同出行工具的成本，故我们采用策略模式进行设计、编码。</p><p>便于理解，本示例的 UML 类图如图 2-12 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-12.png" alt="交通方案UML类图"></p><center>图 2-12 交通方案的 UML 类图</center> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CalculateStragety</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按距离来计算价格</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> km 公里</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回价格</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculatePrice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusStragety</span> <span class="keyword">implements</span> <span class="title">CalculateStragety</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculatePrice</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 公交车价格计算策略</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubwayStragety</span> <span class="keyword">implements</span> <span class="title">CalculateStragety</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculatePrice</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 地铁价格计算策略</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现: 出行价格计算器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TranficCalculator</span> </span>&#123;</span><br><span class="line">CalculateStrategy mStrategy = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">TranficCalculator calculator = <span class="keyword">new</span> TranficCalculator();</span><br><span class="line"><span class="comment">// 设置计算策略</span></span><br><span class="line">calculator.setStrategy( <span class="keyword">new</span> BusStrategy() );</span><br><span class="line"><span class="comment">// 计算价格</span></span><br><span class="line">System.out.println(<span class="string">"公交车乘16公里的价格: "</span> + calculator.calculatePrice(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(CalculateStrategy mStrategy)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mStrategy = mStrategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculatePrice</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mStrategy.calculatePrice(km);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="策略模式的实战应用"><a href="#策略模式的实战应用" class="headerlink" title="策略模式的实战应用"></a>策略模式的实战应用</h4><p>对于默认情况下，ImageLoader 会按照先后顺序加载图片，但在实际算法当中，相反顺序加载图片也是有可能的，即反序列加载图片。当然加载方式可看作多种策略，共同的目标是实现加载图片。图 2-13 是 ImageLoader 的 UML 类图。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-13.png" alt="ImageLoader的UML类图"></p><center>图 2-13 ImageLoader 的 UML 类图</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadPolicy</span> </span>&#123; <span class="comment">// 加载策略接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(BitmapRequest request1, BitmapRequest request2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺序加载策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialPolicy</span> <span class="keyword">implements</span> <span class="title">LoadPolicy</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(BitmapRequest request1, BitmapRequest request2)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 按照添加到队列的序列号顺序来执行</span></span><br><span class="line"><span class="keyword">return</span> request1.serialNum - request2.serialNum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆序加载策略，即从最后加入队列的请求进行加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pulbic <span class="class"><span class="keyword">class</span> <span class="title">ReversePolicy</span> <span class="keyword">implements</span> <span class="title">LoadPolicy</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(BitmapRequest request1, BitmapRequest request2)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注意: Bitmap 请求要先执行最晚加入队列的请求，ImageLoader 的策略 </span></span><br><span class="line"><span class="keyword">return</span> request2.serialNum - request1.serialNum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 因每个请求都有一序列号，序列号以递增形式增加，越晚加入队列的请求序列号越大。</span></span><br><span class="line"><span class="comment"> * 而请求队列是优先级队列，因此我们需要在图片加载请求类中实现 Comparable 接口，以实现对这些请求的排序处理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapRequest</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">BitmapRequest</span>&gt; </span>&#123; <span class="comment">// 加载策略</span></span><br><span class="line">LoadPolicy mLoadPolicy = <span class="keyword">new</span> SerialPolicy();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(BitmapRequest another)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 委托给 LoadPolicy 进行处理，实现按照策略模式</span></span><br><span class="line"><span class="keyword">return</span> mLoadPolicy.compare(<span class="keyword">this</span>, another);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户在配置 ImageLoader 时可以设置加载策略，</span></span><br><span class="line"><span class="comment"> * 这个策略会被设置给每个图片加载请求对象，具体如下：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> ImageView imageView, <span class="keyword">final</span> String uri, <span class="keyword">final</span> DisplayConfig config, <span class="keyword">final</span> ImageListener listener)</span> </span>&#123;</span><br><span class="line">BitmapRequest request = <span class="keyword">new</span> BitmapRequest(imageView, uri, config, listener);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 加载的配置对象，如果没有设置则使用 ImageLoader 的配置</span></span><br><span class="line">request.displayConfig = request.displayConfig != <span class="keyword">null</span> ?</span><br><span class="line">request.displayConfig : mConfig.displayConfig;</span><br><span class="line"> <span class="comment">// 设置加载策略</span></span><br><span class="line"> request.setLoadPolicy(mConfig.loadPolicy);</span><br><span class="line"> <span class="comment">// 添加到队列中</span></span><br><span class="line">mImageQueue.addRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><ul><li>策略模式的优缺点<ul><li>优点<br>1) 很好地演示了开闭原则，也就定义了抽象。<br>2) 耦合度相对较低，扩展方法。</li><li>缺点 - 随着策略的增加，子类会变得繁多。</li></ul></li></ul><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><ul><li>状态模式和策略模式和结构几乎一样，但它们的目的本质完全相异。<ul><li>状态模式：行为是平行的，不可替换的。</li><li>策略模式：行为彼此独立，可相互替换。</li></ul></li></ul><h4 id="状态模式的定义"><a href="#状态模式的定义" class="headerlink" title="状态模式的定义"></a>状态模式的定义</h4><p>当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p><h4 id="状态模式的使用场景"><a href="#状态模式的使用场景" class="headerlink" title="状态模式的使用场景"></a>状态模式的使用场景</h4><p>代码中包含大量与对象状态有关的条件语句。如操作中含有庞大的多分支语句 ( <code>if-else</code> 或 <code>switch-case</code> )，且这些分支依赖与该对象的状态。</p><p>若使用状态模式来优化架构，即每一条件分支放于独立的类。</p><h4 id="状态模式的-UML-类图"><a href="#状态模式的-UML-类图" class="headerlink" title="状态模式的 UML 类图"></a>状态模式的 UML 类图</h4><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-14.png" alt="状态模式的UML类图"></p><center>图 2-14 状态模式的 UML 类图</center> <h4 id="状态模式的简单示例"><a href="#状态模式的简单示例" class="headerlink" title="状态模式的简单示例"></a>状态模式的简单示例</h4><p>下面以电视遥控器为例演示状态模式的实现。便于理解，本示例的 UML 类图如图 2-15 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-15.png" alt="电视遥控器UML类图"></p><center>图 2-15 电视遥控器 UML 类图</center> <h4 id="状态模式实战"><a href="#状态模式实战" class="headerlink" title="状态模式实战"></a>状态模式实战</h4><p>在新浪微博中，用户在未登录的情况下点击转发按钮，此时会先让用户登录，然后再执行转发操作；如果已登录的情况下，那么用户输入转发的内容后就可以直接进行操作。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-16.png" alt="新浪微博用户状态管理UML类图"></p><center>图 2-16 新浪微博用户状态管理 UML 类图</center> <h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><ul><li>状态模式的优缺点<ul><li>优点 - 将所有与一个特定的状态相关的行为都放入一个状态对象中，它提供了一个更好的方法来组织与特定状态相关的代码，将繁琐的状态判断转为结构清晰的状态类族。</li><li>缺点 - 必然增加系统类和对象的个数。</li></ul></li></ul><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><h4 id="责任链模式的定义"><a href="#责任链模式的定义" class="headerlink" title="责任链模式的定义"></a>责任链模式的定义</h4><ul><li>行为型设计模式。</li><li>通俗定义：每个节点看作一对象，每一对象拥有不同的处理逻辑，将一请求从链式的首端发出，沿着链的路径一次传递每个节点对象，直至有对象处理这个请求为止。</li><li>标准定义：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成链，并沿着这条链传递该请求，直至有对象处理它为止。</li></ul><h4 id="责任链模式的使用场景"><a href="#责任链模式的使用场景" class="headerlink" title="责任链模式的使用场景"></a>责任链模式的使用场景</h4><ul><li>多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动态决定。</li><li>在请求处理者不明确的情况下向多个对象中的其一提交一个请求。</li><li>需要动态指定一组对象处理请求。</li></ul><h4 id="责任链模式的-UML-类图"><a href="#责任链模式的-UML-类图" class="headerlink" title="责任链模式的 UML 类图"></a>责任链模式的 UML 类图</h4><p>责任链模式的 UML 类图如图 2-17 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-17.png" alt="责任链模式UML类图"></p><center>图 2-17 责任链模式 UML 类图</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象处理者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> Handler successor; <span class="comment">// 下一节点的处理者</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> condition 请求条件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String condition)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的处理者1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String condition)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(condition.equals(<span class="string">"ConcreteHandler1"</span>)) &#123;</span><br><span class="line">System.out.println(<span class="string">"ConcreteHandler1 handled"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">successor.handleRequest(condition);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的处理者2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String condition)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(condition.equals(<span class="string">"ConcreteHandler2"</span>)) &#123;</span><br><span class="line">System.out.println(<span class="string">"ConcreteHandler2 handled"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">successor.handleRequest(condition);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 构造一个 ConcreteHandler1 对象</span></span><br><span class="line">ConcreteHandler1 handler1 = <span class="keyword">new</span> ConcreteHandler1();</span><br><span class="line"><span class="comment">// 构造一个 ConcreteHandler2 对象</span></span><br><span class="line">ConcreteHandler2 handler1 = <span class="keyword">new</span> ConcreteHandler2();</span><br><span class="line"><span class="comment">// 设置 handler1 的下一个节点</span></span><br><span class="line">handler1.successor = handler2;</span><br><span class="line"><span class="comment">// 设置 handler2 的下一个节点</span></span><br><span class="line">handler2.successor = handler1;</span><br><span class="line"><span class="comment">// 处理请求</span></span><br><span class="line">handler1.handleRequest(<span class="string">"ConcreteHandler2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="责任链模式的简单实现"><a href="#责任链模式的简单实现" class="headerlink" title="责任链模式的简单实现"></a>责任链模式的简单实现</h4><p>在公司中报销费用中，审批的流程其实就是一个类似责任链的实例。例如，小明是请求的发起者，而处理者有组长、部门主管、经理和老板，对于不同额度的报销费用需要不同级的处理者审批，准确地说，每一类人代表这条链上的一个节点。</p><p>例如小民是请求的发起者，而老板则是处于链条顶端的类，小民从链的底端开始发出一个申请报账的请求，首先由组长处理该请求，组长比对后发现自己权限不够于是将该请求转发给位于链中下一个节点的主管，主管比对后发现自己权限不足又将该请求转发给经理，经理也基于同样的原因将请求转发给老板，这样层层转达直至请求被处理。即至始至终小民关心的是报账结果，而不用在乎处理者是谁。责任链模式在这里很好地将请求的发起者与处理者解耦。</p><p>便于理解，本示例的 UML 类图如图 2-18 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-18.png" alt="报账审核机制UML类图"></p><center>图 2-18 报账审核机制 UML 类图</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象领导者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> Leader nextHandler; <span class="comment">// 上一级领导处理者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理报账请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> money 能批复的报账额度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>( money &lt; limit() ) &#123;</span><br><span class="line">handle(money);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">null</span> != nextHandlder ) &#123;</span><br><span class="line">nextHandler.handleRequest(money);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自身能批复的额度权限</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 额度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理报账行为</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> money 具体金额</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">pulbic <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> money)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupLeader</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">Ststen.out.println(<span class="string">"组长批复报销"</span> + money + <span class="string">"元"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">5000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">Ststen.out.println(<span class="string">"主管批复报销"</span> + money + <span class="string">"元"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">Ststen.out.println(<span class="string">"经理批复报销"</span> + money + <span class="string">"元"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">Ststen.out.println(<span class="string">"老板批复报销"</span> + money + <span class="string">"元"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小民从组长开始发起请求申请报账</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMin</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 构造各个领导对象</span></span><br><span class="line">GroupLeader groupLeader = <span class="keyword">new</span> GroupLeader();</span><br><span class="line">Director director = <span class="keyword">new</span> Director();</span><br><span class="line">Manager manager = <span class="keyword">new</span> Manager();</span><br><span class="line">Boss boss = <span class="keyword">new</span> Boss();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置上一级领导处理者对象</span></span><br><span class="line">groupLeader.nextHandler = director;</span><br><span class="line">director.nextHandler = manager;</span><br><span class="line">manager.nextHandler = boss;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起报账申请</span></span><br><span class="line">groupLeader.handleRequest(<span class="number">50000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="责任链模式实战"><a href="#责任链模式实战" class="headerlink" title="责任链模式实战"></a>责任链模式实战</h4><p>Android 中我们可以借鉴责任链模式的思想来优化 BroadcastReceiver 使之成为一个全局的责任链处理者。</p><p>我们知道 Broadcast 可以被分为两种:</p><ul><li>Normal Broadcast：普通广播，异步广播，发出时可被所有的接收者收到。</li><li>Ordered Broadcast：有序广播，依优先级依次传播的，直到有接收者将其终止或所有接收者都不终止它。</li></ul><p>有序广播这一特性与我们的责任链模式很相近，通过它可实现一种全局的责任链事件处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体的实现思路是，通过 Intent 的限制值来限定最终的广播权归谁所有</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取 Intent 中附加的限制值</span></span><br><span class="line"><span class="keyword">int</span> limit = intent.getIntExtra(<span class="string">"limit"</span>, -<span class="number">1001</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果限定值等于 1000 则处理，否则继续转发给下一个 Receiver</span></span><br><span class="line"><span class="keyword">if</span>( <span class="number">1000</span> == limit ) &#123;</span><br><span class="line"><span class="comment">// 获取 Intent 中附加的字符串消息并 Toast</span></span><br><span class="line">String msg = intent.getStringExtra(<span class="string">"msg"</span>);</span><br><span class="line">Toast.makeText(context, msg, Toast.LENGTH_SHORT).show();</span><br><span class="line"><span class="comment">// 终止广播</span></span><br><span class="line">abortBroadcast();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 添加信息发送给下一个 Receiver</span></span><br><span class="line">Bundle b = <span class="keyword">new</span> Bundle();</span><br><span class="line">b.putString(<span class="string">"new"</span>, <span class="string">"Message from FirstReceiver"</span>);</span><br><span class="line">setResultExtras(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取 Intent 中附加的限制值</span></span><br><span class="line"><span class="keyword">int</span> limit = intent.getIntExtra(<span class="string">"limit"</span>, -<span class="number">1001</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果限定值等于 100 则处理，否则继续转发给下一个 Receiver</span></span><br><span class="line"><span class="keyword">if</span>( <span class="number">100</span> == limit ) &#123;</span><br><span class="line"><span class="comment">// 获取 Intent 中附加的字符串消息</span></span><br><span class="line">String msg = intent.getStringExtra(<span class="string">"msg"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取上一个 Receiver 增加的消息</span></span><br><span class="line">Bundle b = getResultExtras(<span class="keyword">true</span>);</span><br><span class="line">String str = b.getString(<span class="string">"new"</span>);</span><br><span class="line"></span><br><span class="line">Toast.makeText(context, msg + str, Toast.LENGTH_SHORT).show();</span><br><span class="line"><span class="comment">// 终止广播</span></span><br><span class="line">abortBroadcast();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 添加信息发送给下一个 Receiver</span></span><br><span class="line">Bundle b = <span class="keyword">new</span> Bundle();</span><br><span class="line">b.putString(<span class="string">"new"</span>, <span class="string">"Message from FirstReceiver"</span>);</span><br><span class="line">setResultExtras(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取 Intent 中附加的限制值</span></span><br><span class="line"><span class="keyword">int</span> limit = intent.getIntExtra(<span class="string">"limit"</span>, -<span class="number">1001</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果限定值等于 10 则处理，否则继续转发给下一个 Receiver</span></span><br><span class="line"><span class="keyword">if</span>( <span class="number">10</span> == limit ) &#123;</span><br><span class="line"><span class="comment">// 获取 Intent 中附加的字符串消息</span></span><br><span class="line">String msg = intent.getStringExtra(<span class="string">"msg"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取上一个 Receiver 增加的消息</span></span><br><span class="line">Bundle b = getResultExtras(<span class="keyword">true</span>);</span><br><span class="line">String str = b.getString(<span class="string">"new"</span>);</span><br><span class="line"></span><br><span class="line">Toast.makeText(context, msg + str, Toast.LENGTH_SHORT).show();</span><br><span class="line"><span class="comment">// 终止广播</span></span><br><span class="line">abortBroadcast();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 添加信息发送给下一个 Receiver</span></span><br><span class="line">Bundle b = <span class="keyword">new</span> Bundle();</span><br><span class="line">b.putString(<span class="string">"new"</span>, <span class="string">"Message from FirstReceiver"</span>);</span><br><span class="line">setResultExtras(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_order);</span><br><span class="line"></span><br><span class="line">Button btnSend = (Button) findViewById(R.id.order_send_btn);</span><br><span class="line">btnSend.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">Intent i = <span class="keyword">new</span> Intent();</span><br><span class="line">i.setAction(<span class="string">"com.aigestudio.action.ORDER_BROADCAST"</span>);</span><br><span class="line">i.putExtra(<span class="string">"limit"</span>, <span class="number">100</span>);</span><br><span class="line">i.putExtra(<span class="string">"msg"</span>, <span class="string">"Message from OrderActivity"</span>);</span><br><span class="line">sendOrderedBroadcast(i, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里我们设置 limit = 100，即只有 SecondReceiver 才会处理它。</span></span><br></pre></td></tr></table></figure><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><ul><li>责任链模式的优缺点<ul><li>优点 - 对请求者和处理者关系解耦，提高代码灵活性。</li><li>缺点 - 递归调用。特别是处理者太多，那么遍历定会影响性能。</li></ul></li></ul><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><h4 id="解释器模式的定义"><a href="#解释器模式的定义" class="headerlink" title="解释器模式的定义"></a>解释器模式的定义</h4><ul><li>行为型设计模式。</li><li>概念：给定一个语言，定义它的 <code>文法</code> 的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</li><li>文法：例如我们熟悉的「主谓宾结构」，通过下述短语举例，我们可把短语抽象看作：I am a/an [noun.]</li></ul><div class="table-container"><table><thead><tr><th>主语</th><th>谓语</th><th>宾语</th></tr></thead><tbody><tr><td>I</td><td>am</td><td>a designer</td></tr><tr><td>I</td><td>am</td><td>a teacher</td></tr></tbody></table></div><ul><li><p>再举例：假设有如以 ab 开头 ef 结尾，中间排列 N(N&gt;=0) 个 cd 的字符串。</p><blockquote><p>abcdcd…cdef</p></blockquote><p>在计算机科学中，我们将上述字符串中的 “a”、“b”、“c”、“d”、“e” 和 “f” 这 6 个字符称为一种形式语言的 <code>字符表</code>。</p><p>而这些字符组成的集合，如 “abcdcd…cdef” 这样由字符表构成的字符串则称为 <code>形式语言</code>。注意这里的语言不是文法。</p><p>假设定义一个符号 S，从符号 S 出发推导上述字符串，即可得到如下推导式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S ::= abA*ef  </span><br><span class="line">A ::= cd</span><br></pre></td></tr></table></figure></li></ul><ul><li><code>::==</code> 称为推导；  </li><li><code>*</code> 表示闭包，上述推导式中意思是，符号 A 可以有 0 或 N 个重复；  </li><li>非终结符号：<code>S</code> 和 <code>A</code> 则称非终结符号，即它们能推导出式子右边的表达式；  </li><li>终结符号：”pqmn”，“ab”，“ef”，即无法再推导；</li></ul><h4 id="解释器模式的使用场景"><a href="#解释器模式的使用场景" class="headerlink" title="解释器模式的使用场景"></a>解释器模式的使用场景</h4><ul><li><p>某个 <code>简单语言</code> 需要解释执行且可将该语言中的语句表示为 <code>抽象语法树</code> 时可考虑使用解释器模式。</p><blockquote><p>如：有非终结符号 p+q+m-n，即该数学表示式可表示为一棵抽象语法树。如图 2-19 所示。</p></blockquote></li></ul><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-19.png" alt="p+q+m-n的抽象语法树"></p><center>图 2-19 p+q+m-n 的抽象语法树</center><ul><li><p>某些特定的领域出现不断重复的问题时，可将该领域的问题转化为一种语法规则下的语句，然后构建解释器来解释该语句。</p><blockquote><p>英文字母的大小写转换；阿拉伯数字转为中文的数字…<br>即它们都是一个个终结符，不同的只是具体内容。</p></blockquote></li></ul><h4 id="解释器模式的-UML-类图"><a href="#解释器模式的-UML-类图" class="headerlink" title="解释器模式的 UML 类图"></a>解释器模式的 UML 类图</h4><p>解释器模式的 UML 类图如图 2-20 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-20.png" alt="解释器模式UML类图"></p><center>图 2-20 解释器模式 UML 类图</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象的解析方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctx 上下文环境对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(Context ctx)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终结符表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(Context ctx)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 实现文法中与终结符有关的解释操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非终结符表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonterminalExpression</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(Context ctx)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 实现文法中与非终结符有关的解释操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"><span class="comment">// 包含解释器之外的全局信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据文法对特定句子构建抽象语法树后解释</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><ul><li>解释模式的优缺点<ul><li>优点 - 灵活的扩展性，即我们想对文法规则进行扩展延伸时，只需增加相应的非终结符解释器，并在构建抽象语法树时，使用到新增的解释器对象进行具体的解释即可。</li><li>缺点<br>1) 对于每一条文法对应至少一个解释器，其会生成大量的类，导致后期维护困难；<br>2) 构建其抽象语法树会显得异常繁琐，甚至可能出现需要构建多棵抽象语法树的情况。</li></ul></li></ul><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h4 id="命令模式的定义"><a href="#命令模式的定义" class="headerlink" title="命令模式的定义"></a>命令模式的定义</h4><ul><li>行为型设计模式。</li><li>介绍：将一系列的方法调用封装，用户只需调用一个方法执行，那么所有这些被封装的方法就会被挨个执行调用。</li><li>定义：<ul><li>将一个请求封装成一个对象，从而让用户使用不同的请求把客户端参数化。</li><li>对请求排队或者记录请求日志，以及支持可撤销的操作。</li></ul></li></ul><h4 id="命令模式的使用场景"><a href="#命令模式的使用场景" class="headerlink" title="命令模式的使用场景"></a>命令模式的使用场景</h4><ul><li>需要抽象出待执行的动作，然后以参数的形式提供处理 (类似过程设计中的回调机制)。</li><li>在不同的时刻指定、排列和执行请求。一个命令对象可以有与初始请求无关的生存期。</li><li>需要支持取消操作。</li><li>需要支持事务操作。</li><li>支持修改日志功能，若系统崩溃，这些修改可重做一遍。</li></ul><h4 id="命令模式的-UML-类图"><a href="#命令模式的-UML-类图" class="headerlink" title="命令模式的 UML 类图"></a>命令模式的 UML 类图</h4><p>命令模式的 UML 类图如图 2-21 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-21.png" alt="命令模式UML类图"></p><center>图 2-21 命令模式 UML 类图</center><p><strong>Receiver：接收者角色</strong><br>该类负责具体实施或执行一个请求，通俗地说，执行具体逻辑的角色。</p><p><strong>Command：命令角色</strong><br>定义所有具体命令类的抽象接口。</p><p><strong>ConcreteCommand：具体命令角色</strong><br>该类实现了 Command 接口，在 execute() 方法中调用接收者角色的相关方法，在接收者和命令执行的具体行为之间加以弱耦和。</p><p><strong>Invoker：请求者角色</strong><br>该类的职责就是调用命令对象执行具体的请求，相关的方法我们称为行动方法。</p><p>这里其实大家可以看到，命令模式的应用其实可用一句话概述，就是将行为调用者与实现者解耦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正执行具体命令逻辑的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"执行具体操作"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象命令接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行具体操作的命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Receiver receiver; <span class="comment">// 持有一个对接受者对象的引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用接收者的相关方法来执行具体逻辑</span></span><br><span class="line">receiver.action();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Command command; <span class="comment">// 持有一个对应命令对象的引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.command = command;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用具体命令对象的相关方法，执行具体命令</span></span><br><span class="line">command.execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 构造一个接受者对象</span></span><br><span class="line">Receiver receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line"><span class="comment">// 根据接收者对象构造一个命令对象</span></span><br><span class="line">Command command = <span class="keyword">new</span> ConcreteCommand(receiver);</span><br><span class="line"><span class="comment">// 根据具体的对象构造请求者对象</span></span><br><span class="line">Invoker invoker = <span class="keyword">new</span> Invoker(command);</span><br><span class="line"><span class="comment">// 执行请求方法</span></span><br><span class="line">invoker.action();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命令模式的简单实现"><a href="#命令模式的简单实现" class="headerlink" title="命令模式的简单实现"></a>命令模式的简单实现</h4><p>这里以古老的俄罗斯方块游戏为例，在命令模式下如何操控俄罗斯方块变换。游戏中含有 4 个按钮，即上下左右。设定玩游戏的人相当于我们的客户端，游戏上的 4 个按钮相当于请求者，而执行具体按钮命令的逻辑方法可看作命令角色。</p><p>便于理解，本示例的 UML 类图如图 2-22 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-22.png" alt="命令模式实现俄罗斯方块游戏"></p><center>图 2-22 命令模式实现俄罗斯方块游戏</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收者角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TetrisMachine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toLeft</span><span class="params">()</span> </span>&#123; <span class="comment">// 真正处理 “向左” 操作的逻辑代码</span></span><br><span class="line">System.out.println(“向左”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toRight</span><span class="params">()</span> </span>&#123; <span class="comment">// 真正处理 “向右” 操作的逻辑代码</span></span><br><span class="line">System.out.println(“向右”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fastToBottom</span><span class="params">()</span> </span>&#123; <span class="comment">// 真正处理 “快速落下” 操作的逻辑代码</span></span><br><span class="line">System.out.println(“快速落下”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123; <span class="comment">// 真正处理 “改变形状” 操作的逻辑代码</span></span><br><span class="line">System.out.println(“改变形状”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令者抽象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 命令执行方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令者：向左移的命令类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"><span class="comment">// 持有一个接收者俄罗斯方块游戏对象的引用</span></span><br><span class="line"><span class="keyword">private</span> TetrisMachine machine;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeftCommand</span><span class="params">(TetriMachine machine)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.machine = machine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用游戏机里的具体方法执行操作</span></span><br><span class="line">machine.toLeft();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令者：向右移的命令类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"><span class="comment">// 持有一个接收者俄罗斯方块游戏对象的引用</span></span><br><span class="line"><span class="keyword">private</span> TetrisMachine machine;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RightCommand</span><span class="params">(TetriMachine machine)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.machine = machine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用游戏机里的具体方法执行操作</span></span><br><span class="line">machine.toRight();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令者：快速落下的命令类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FallCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"><span class="comment">// 持有一个接收者俄罗斯方块游戏对象的引用</span></span><br><span class="line"><span class="keyword">private</span> TetrisMachine machine;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FallCommand</span><span class="params">(TetriMachine machine)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.machine = machine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用游戏机里的具体方法执行操作</span></span><br><span class="line">machine.fastToBottom();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令者：改变形状的命令类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"><span class="comment">// 持有一个接收者俄罗斯方块游戏对象的引用</span></span><br><span class="line"><span class="keyword">private</span> TetrisMachine machine;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TransformCommand</span><span class="params">(TetriMachine machine)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.machine = machine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用游戏机里的具体方法执行操作</span></span><br><span class="line">machine.transform();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求者类：命令由按钮发起</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Buttons</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> LeftCommand leftCommand; <span class="comment">// 向左移动的命令对象引用</span></span><br><span class="line"><span class="keyword">private</span> RightCommand rightCommand; <span class="comment">// 向右移动的命令对象引用</span></span><br><span class="line"><span class="keyword">private</span> FallCommand fallCommand; <span class="comment">// 快速落下的命令对象引用</span></span><br><span class="line"><span class="keyword">private</span> TransformCommand transformCommand; <span class="comment">// 变换形状的命令对象引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置向左移动的命令对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> leftCommand 向左移动的命令对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftCommand</span><span class="params">(LeftCommand leftCommand)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.leftCommand = leftCommand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置向右移动的命令对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rightCommand 向右移动的命令对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightCommand</span><span class="params">(RightCommand rightCommand)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.rightCommand = rightCommand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置快速落下的命令对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fallCommand 向左移动的命令对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFallCommand</span><span class="params">(FallCommand fallCommand)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.fallCommand = fallCommand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置变换形状的命令对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> transformCommand 向左移动的命令对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransformCommand</span><span class="params">(TransformCommand transformCommand)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.leftCommand = leftCommand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toLeft</span><span class="params">()</span> </span>&#123; <span class="comment">// 按下按钮向左移动</span></span><br><span class="line">leftCommand.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toRight</span><span class="params">()</span> </span>&#123; <span class="comment">// 按下按钮向右移动</span></span><br><span class="line">rightCommand.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fall</span><span class="params">()</span> </span>&#123; <span class="comment">// 按下按钮快速落下</span></span><br><span class="line">fallCommand.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123; <span class="comment">// 按下按钮改变形状</span></span><br><span class="line">transformCommand.execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 首先要有俄罗斯方块游戏</span></span><br><span class="line">TetrisMachine machine = <span class="keyword">new</span> TetrisMachine();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据游戏我们构造 4 种命令</span></span><br><span class="line">LeftCommand leftCommand = <span class="keyword">new</span> LeftCommand(machine);</span><br><span class="line">RightCommand rightCommand = <span class="keyword">new</span> RightCommand(machine);</span><br><span class="line">FallCommand fallCommand = <span class="keyword">new</span> FallCommand(machine);</span><br><span class="line">TransformCommand transformCommand = <span class="keyword">new</span> TransformCommand(machine);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮可以执行不同的命令</span></span><br><span class="line">Buttons buttons = <span class="keyword">new</span> Buttons();</span><br><span class="line">buttons.setLeftCommand(leftCommand);</span><br><span class="line">buttons.setRightCommand(rightCommand);</span><br><span class="line">buttons.setFallCommand(fallCommand);</span><br><span class="line">buttons.setTransformCommand(transformCommand);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体按下哪个按钮玩家决定</span></span><br><span class="line">buttons.toLeft();</span><br><span class="line">buttons.toRight();</span><br><span class="line">buttons.fall();</span><br><span class="line">buttons.transform();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于大部分开发者来说，更愿意接受的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TetrisMachine machine = <span class="keyword">new</span> TetrisMachine();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现怎样的控制方式，直接调用相关函数</span></span><br><span class="line"><span class="comment">// machine.toLeft();</span></span><br><span class="line"><span class="comment">// machine.toRight();</span></span><br><span class="line"><span class="comment">// machine.fastToBottom();</span></span><br><span class="line"><span class="comment">// machine.transform();</span></span><br><span class="line"></span><br><span class="line">machine.toLeft();</span><br></pre></td></tr></table></figure><p>调用逻辑做得如此复杂，其实是为了开发起来方便，即每次我们增加或修改游戏功能只需修改 TetrisMachine 类即可。<br>当然，其实这样做是有原因的，即设计模式种有一条重要的原则：对修改关闭对扩展开放。具体好处是：</p><ul><li>如修改功能、代码的具体逻辑，以上例为例，即修改 TetrisMachine 类即可。</li><li>此外，命令模式还可以实现命令记录的功能，如在 Buttons 里使用数据结构存储执行过的命令对象，需要时可恢复。</li></ul><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><ul><li>命令模式的优缺点<ul><li>优点 - 更灵活的控制性以及更好的扩展性；更弱的耦合性。</li><li>缺点 - 类的膨胀，大量衍生类的创建。</li></ul></li></ul><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h4 id="观察者模式的定义"><a href="#观察者模式的定义" class="headerlink" title="观察者模式的定义"></a>观察者模式的定义</h4><p>定义对象间一种 <code>一对多</code> 的 <code>依赖关系</code>，使得每当一个对象改变状态，则所有依赖与它的对象都会得到通知并被自动更新。</p><h4 id="观察者模式的使用场景"><a href="#观察者模式的使用场景" class="headerlink" title="观察者模式的使用场景"></a>观察者模式的使用场景</h4><ul><li>关联行为场景，即关联行为是可拆分的，而不是“组合”关系。</li><li>事件多级触发场景。</li><li>跨系统的消息交换场景，如消息队列、事件总线的处理机制。</li></ul><h4 id="观察者模式的-UML-类图"><a href="#观察者模式的-UML-类图" class="headerlink" title="观察者模式的 UML 类图"></a>观察者模式的 UML 类图</h4><p>观察者模式的 UML 类图如图 2-23 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-23.png" alt="观察者模式的UML类图"></p><center>图 2-23 观察者模式的 UML 类图</center><h4 id="观察者模式实战"><a href="#观察者模式实战" class="headerlink" title="观察者模式实战"></a>观察者模式实战</h4><h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><ul><li>观察者模式主要的作用就是对象解耦，将观察者与被观察者完全隔离，只依赖于 Observer 和 Obserable 抽象。</li></ul><blockquote><p>如：ListView 就是运用了 Adapter 和观察者模式，使之它的扩展性、灵活性增强，且耦合度却很低。</p></blockquote><ul><li>观察者模式的优缺点<ul><li>优点<br>1) 增强系统灵活性、可扩展性；<br>2) 将观察者与被观察者之间是抽象耦合，应对业务变换。</li><li>缺点 - 应用观察者模式，需考虑开放效率和运行效率问题 (一般考虑采用异步的方式)</li></ul></li></ul><h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><h4 id="备忘录模式的介绍"><a href="#备忘录模式的介绍" class="headerlink" title="备忘录模式的介绍"></a>备忘录模式的介绍</h4><ul><li>行为型设计模式。</li><li>用于保存对象当前状态，并在之后可再次恢复到此状态。</li><li>保证被保存的对象状态不能被对象从外部访问，目的是为了保护好被保存对象状态的完整性及内部实现不向外暴露。</li></ul><h4 id="备忘录模式的定义"><a href="#备忘录模式的定义" class="headerlink" title="备忘录模式的定义"></a>备忘录模式的定义</h4><p>在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原生保存的状态。</p><h4 id="备忘录模式的-UML-类图"><a href="#备忘录模式的-UML-类图" class="headerlink" title="备忘录模式的 UML 类图"></a>备忘录模式的 UML 类图</h4><p>备忘录模式的 UML 类图如图 2-24 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-24.png" alt="备忘录模式的UML类图"></p><center>图 2-24 备忘录模式的 UML 类图</center><p><strong>Originator</strong><br>负责创建一个备忘录，可以记录、恢复自身的内部状态。同时 Originator 还可以根据需要决定 Memoto 存储自身的哪些内部状态。</p><p><strong>Memoto</strong><br>备忘录角色，用于储存 Originator 的内部状态，并且可以防止 Originator 以外的对象访问 Memoto。</p><p><strong>Caretaker</strong><br>负责储存备忘录，不能对备忘录的内容进行操作和访问，只能够将备忘录传递给其他对象。</p><h4 id="备忘录模式的简单实例"><a href="#备忘录模式的简单实例" class="headerlink" title="备忘录模式的简单实例"></a>备忘录模式的简单实例</h4><p>对于备忘录模式来说，比较贴切的场景应该是游戏中的存档功能，该功能就是将游戏进度存储到本地文件系统或者数据库中，下次再次进入时从本地加载进度，使得玩家能够继续上一次的游戏之旅。下面我们以“使命召唤”这款游戏为例简单演示备忘录模式的实现。</p><p>首先我们建立游戏类 CallOfDuty，备忘录类 Memoto 和负责管理 Memoto 的 CareTaker 类。玩游戏到某个节点对游戏进行存档，然后退出游戏，再重新进入时从存档中读取进度，并且进入存档时的进度。</p><p>便于理解，本示例的 UML 类图如图 2-25 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-25.png" alt="使命召唤的存储功能实现"></p><center>图 2-25 使命召唤的存储功能实现</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ”使命召唤“ 游戏 ( 简化的数据模型，仅供简单演示 )</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallOfDuty</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mCheckPoint = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mLifeValue = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> String mWeapon = <span class="string">"沙漠之鹰"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123; <span class="comment">// 玩游戏</span></span><br><span class="line"><span class="comment">// 忽略实现细节</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123; <span class="comment">// 退出游戏</span></span><br><span class="line"><span class="comment">// 忽略实现细节</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Memoto <span class="title">createMemoto</span><span class="params">()</span> </span>&#123; <span class="comment">// 创建备忘录</span></span><br><span class="line"> Memoto memoto = <span class="keyword">new</span> Memoto();</span><br><span class="line"> memoto.mCheckPoint = mCheckPoint;</span><br><span class="line"> memoto.mLifeValue = mLifeValue;</span><br><span class="line"> memoto.mWeapon = mWeapon;</span><br><span class="line"> <span class="keyword">return</span> memoto;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(Memoto memoto)</span> </span>&#123; <span class="comment">// 恢复游戏</span></span><br><span class="line"> <span class="keyword">this</span>.mCheckPoint = memoto.mCheckPoint;</span><br><span class="line"> <span class="keyword">this</span>.mLifeValue = memoto.mLifeValue;</span><br><span class="line"> <span class="keyword">this</span>.mWeapon = memoto.mWeapon;</span><br><span class="line"> System.out.println(<span class="string">"恢复后的游戏属性: "</span> + <span class="keyword">this</span>.toString());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Overrride</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"CallOfDuty[mCheckPoint=..., mLifeValue=..., mWeapon=...]"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoto</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> mCheckPoint;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> mLifeValue;</span><br><span class="line"><span class="keyword">public</span> String mWeapon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Caretaker，负责管理 Memoto</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">Memoto memoto = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">archive</span><span class="params">(Memoto memoto)</span> </span>&#123; <span class="comment">// 存档</span></span><br><span class="line"><span class="keyword">this</span>.memoto = memoto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Memoto <span class="title">getMemoto</span><span class="params">()</span> </span>&#123; <span class="comment">// 读取存档</span></span><br><span class="line"><span class="keyword">return</span> memoto;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">CallOfDuty game = <span class="keyword">new</span> CallOfDuty();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step.01 游戏开始</span></span><br><span class="line">game.play();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step.02 游戏存档</span></span><br><span class="line">Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line">caretaker.archive( game.createMemoto() );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step.03 退出游戏</span></span><br><span class="line">game.quit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step.04 恢复游戏</span></span><br><span class="line">CallOfDuty newGame = <span class="keyword">new</span> CallOfDuty();</span><br><span class="line">newGame.restore( caretaker.getMemoto() );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h4><ul><li>备忘录模式是在不破坏封装的条件下，通过备忘录对象 (Memoto) 存储另外一个对象内部状态的快照，在需求的时候把对象还原到存储的状态。</li><li>备忘录的优缺点<ul><li>优点 - 恢复状态机制；信息封装</li><li>缺点 - 消耗内存 </li></ul></li></ul><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><h4 id="迭代器模式的介绍"><a href="#迭代器模式的介绍" class="headerlink" title="迭代器模式的介绍"></a>迭代器模式的介绍</h4><ul><li>又称游标 (Cursor) 模式，行为型设计模式。</li><li><p>迭代器模式源于对容器的访问，若我们将遍历的方法封装在容器中，则存在问题：</p><ul><li>不仅维护自身内部数据且要对外提供遍历的接口方法。</li><li>不能对同一个容器同时进行多个遍历操作。</li><li><p>不提供遍历方法，而让使用者自行实现，必暴露内部细节。  </p><p>解决方案：在客户访问类与容器直接插入一个第三者 <code>迭代器</code>。</p></li></ul></li></ul><h4 id="迭代器模式的定义"><a href="#迭代器模式的定义" class="headerlink" title="迭代器模式的定义"></a>迭代器模式的定义</h4><p>提供一种方法顺序访问一个容器对象中的各个元素，而不需暴露该对象内部细节。</p><h4 id="迭代器模式的-UML-类图"><a href="#迭代器模式的-UML-类图" class="headerlink" title="迭代器模式的 UML 类图"></a>迭代器模式的 UML 类图</h4><p>迭代器模式的 UML 类图如图 2-26 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-26.png" alt="迭代器模式的UML类图"></p><center>图 2-26 迭代器模式的 UML 类图</center><p><strong>Iterator：迭代器接口</strong><br>迭代器接口，负责定义、访问和遍历元素的接口。</p><p><strong>ConcreteIterator：具体迭代器类</strong><br>具体迭代器类，实现迭代器接口，并记录遍历的当前位置。  </p><p><strong>Aggregate：容器接口</strong><br>容器接口，负责提供创建具体迭代器角色的接口。</p><p><strong>ConcreteIterator：具体容器类</strong><br>具体容器类，具体迭代器角色与该容器相关联。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代器接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否还有下一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 表示有，false 表示没有</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前位置的元素并将位置移至下一位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回当前位置的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体迭代器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.list = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> cursor != list.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">T obj = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">this</span>.hasNext()) &#123;</span><br><span class="line">obj = <span class="keyword">this</span>.list.get(cursor++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器接口</span></span><br><span class="line">pulbic <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 元素对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T obj)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 元素对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T obj)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取容器的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Iterator&lt;T&gt; <span class="title">Iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体容器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Aggregate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">list.add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">list.remove(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator&lt;T&gt;(list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Aggregate&lt;String&gt; aggregate = <span class="keyword">new</span> ConcreteAggregate&lt;&gt;();</span><br><span class="line"></span><br><span class="line">aggregate.add(<span class="string">"Aige "</span>);</span><br><span class="line">aggregate.add(<span class="string">"Studio\n"</span>);</span><br><span class="line">aggregate.add(<span class="string">"SM "</span>);</span><br><span class="line">aggregate.add(<span class="string">"Brother\n"</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = aggregate.iterator();</span><br><span class="line"><span class="keyword">while</span>( iterator.hasNext() ) &#123;</span><br><span class="line">System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h4><ul><li>迭代器模式的优缺点<ul><li>优点 - 支持以不同的方式遍容器对象，也可以有多个遍历，弱化了容器类与遍历算法之间的关系。</li><li>缺点 - 类文件的增加。  </li></ul></li><li>当然几乎每一种高级语言都有相应的内置迭代器实现，故本章的内容在于了解而非应用。</li></ul><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><h4 id="模板方法模式的介绍"><a href="#模板方法模式的介绍" class="headerlink" title="模板方法模式的介绍"></a>模板方法模式的介绍</h4><p>若我们知道一个算法所需的关键步骤，并确定了这些步骤的执行顺序，但某些步骤的具体实现是未知的，或实现是随着环境变化的。</p><blockquote><p>例如，执行程度的流程大致为：<br>Step.01：检查代码正确性<br>Step.02：链接相关类库<br>Step.03：编译<br>Step.04：执行程序<br>即上述步骤不一样 ( 实现细节 )，但执行流程是固定的。</p></blockquote><h4 id="模板方法模式的定义"><a href="#模板方法模式的定义" class="headerlink" title="模板方法模式的定义"></a>模板方法模式的定义</h4><ul><li>定义一个操作的 <code>算法框架</code>。</li><li>将步骤延迟到子类，使子类不改变算法结构即可重定义该算法的某些特定步骤。</li></ul><h4 id="模板方法模式的使用场景"><a href="#模板方法模式的使用场景" class="headerlink" title="模板方法模式的使用场景"></a>模板方法模式的使用场景</h4><ul><li>多个子类有公有的方法，且逻辑基本相同。</li><li>重要复杂的算法，可把核心算法设计为模板方法，周边细节功能则由各个子类实现。</li><li><p>重构时，使用模板方法，即相同代码抽取到父类中，然后通过 <code>钩子函数</code> 约束其行为。</p><blockquote><p>钩子函数：普通的抽象类多态，即它在模板方法模式中提供了改变原始逻辑的空间。</p></blockquote></li></ul><h4 id="模板方法模式的-UML-类图"><a href="#模板方法模式的-UML-类图" class="headerlink" title="模板方法模式的 UML 类图"></a>模板方法模式的 UML 类图</h4><p>模板方法模式的 UML 类图如图 2-27 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-27.png" alt="模板方法模式的UML类图"></p><center>图 2-27 模板方法模式的 UML 类图</center><h4 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h4><ul><li><p>模板方法模式：流程封装，即把某个固定的流程封装到一个 final 函数中，并让子类能够定制这个流程中的某些或者所有步骤。</p><blockquote><p>要求父类提供共同代码，即提高代码复用性、可扩展性。</p></blockquote></li><li><p>模板方法的优缺点</p><ul><li>优点<br>1) 封装不变部分，扩展可变部分。<br>2) 提取公共部分代码。  </li><li>缺点：代码阅读有难度？</li></ul></li></ul><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><h4 id="访问者模式的介绍"><a href="#访问者模式的介绍" class="headerlink" title="访问者模式的介绍"></a>访问者模式的介绍</h4><ul><li>将 <code>数据操作</code> 与 <code>数据结构</code> 分离的设计模式。</li><li>软件系统拥有由许多对象构成的对象结构，这些对象类拥有一 accept() 方法接受访问者对象访问。</li><li><p>访问者是一接口，拥有一 visit() 方法对访问到的对象结构中不同类型的元素作出不同的处理。</p><blockquote><ul><li>在对象结构的一次访问中，遍历整个对象结构，对每个元素实施 accept() 方法。  </li><li>每一元素的 accept() 方法会调用访问者的 visit() 方法，即访问者可针对对象结构设计不同的访问类来完成不同操作。</li></ul></blockquote></li></ul><h4 id="访问者模式的定义"><a href="#访问者模式的定义" class="headerlink" title="访问者模式的定义"></a>访问者模式的定义</h4><p>封装用于某种数据结构中各元素操作，且在不改数据结构的前提下定义这些元素的新操作。</p><h4 id="访问者模式的使用场景"><a href="#访问者模式的使用场景" class="headerlink" title="访问者模式的使用场景"></a>访问者模式的使用场景</h4><ul><li>对一对象结构中的对象进行不同且不相关的操作。</li><li>需避免操作“污染”对象的类。</li><li>增加新操作是不修改这些类。</li><li>对象结构稳定，但经常需在对象结构上定义新操作。</li></ul><h4 id="访问者模式的-UML-类图"><a href="#访问者模式的-UML-类图" class="headerlink" title="访问者模式的 UML 类图"></a>访问者模式的 UML 类图</h4><p>访问者模式的 UML 类图如图 2-28 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-28.png" alt="访问者模式的UML类图"></p><center>图 2-28 访问者模式的 UML 类图</center><h4 id="访问者模式的简单示例"><a href="#访问者模式的简单示例" class="headerlink" title="访问者模式的简单示例"></a>访问者模式的简单示例</h4><p>公司给员工进行业绩考核，评定由公司高层负责。但不同领域的管理人员对与员工的评定标准不一样。即我们把员工分为工程师和经理，评定员工分为 CTO 和 CEO。</p><p>假定 CTO 关注工程师的代码量，经理的新产品数量；CEO 关注工程师的 KPI，经理的 KPI 及新产品数量。</p><p>便于理解，本示例的 UML 类图如图 2-29 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-29.png" alt="公司员工业绩考核"></p><center>图 2-29 公司员工业绩考核</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 员工基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> kpi; <span class="comment">// 员工 KPI</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Staff</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">kpi = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>); <span class="comment">// 随机生成 10 内的值.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受 Visitor 的访问</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工程师类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> codes; <span class="comment">// 代码量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Engineer</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line">codes = <span class="keyword">new</span> Random().nextInt(<span class="number">100000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCodeLines</span><span class="params">()</span> </span>&#123; <span class="comment">// 工程师一年内写的代码量</span></span><br><span class="line"><span class="keyword">return</span> codes;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经理类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> products; <span class="comment">// 产品数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line">products = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getProducts</span><span class="params">()</span> </span>&#123; <span class="comment">// 经理一年内做的产品数量</span></span><br><span class="line"><span class="keyword">return</span> products;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"><span class="comment">// 访问工程师类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Engineer engineer)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问经理类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Manager leader)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CEO 访问者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CEOVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Engineer engineer)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Name:..., KPI:..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Manager mgr)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Name:..., KPI:..., Products:..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CTO 访问者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CTOVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Engineer engineer)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Name:..., Codes:..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Manager mgr)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Name:..., Products:..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessReport</span> </span>&#123;</span><br><span class="line">List&lt;Staff&gt; mStaffs = <span class="keyword">new</span> LinkedList&lt;Staff&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BusinessReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mStaffs.add(<span class="keyword">new</span> Manager(<span class="string">"Manager Wang."</span>));</span><br><span class="line">mStaffs.add(<span class="keyword">new</span> Manager(<span class="string">"Manager Lin."</span>));</span><br><span class="line">mStaffs.add(<span class="keyword">new</span> Manager(<span class="string">"Engineer Kael."</span>));</span><br><span class="line">mStaffs.add(<span class="keyword">new</span> Manager(<span class="string">"Engineer Chaos."</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为访问者展示报表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> visitor 公司高层，如 CEO、CTO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showReport</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>( Staff staff : mStaffs ) &#123;</span><br><span class="line">staff.accept(visitor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">BusinessReport report = <span class="keyword">new</span> BusinessReport();</span><br><span class="line">report.showReport( <span class="keyword">new</span> CEOVisitor() );</span><br><span class="line">report.showReport( <span class="keyword">new</span> CTOVisitor() );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h4><ul><li>对象结构足够稳定，需在对象结构上经常定义新操作，且需对对象结构中的对象进行很多不同且不相关的操作，考虑访问者模式。</li><li>访问者模式的优缺点<ul><li>优点<br>1) 单一职责原则，即各角色职责分离。<br>2) 数据结构和作用于该结构上的操作解耦。  </li><li>缺点<br>1) 具体元素对访问者公布细节。<br>2) 具体元素变更导致修改成本大。<br>3) 违反依赖倒置原则，即为了“区别对待”而依赖了具体类，没有依赖抽象，如上例中的 Engineer 与 Manager。  </li></ul></li></ul><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><h4 id="中介者模式的介绍"><a href="#中介者模式的介绍" class="headerlink" title="中介者模式的介绍"></a>中介者模式的介绍</h4><ul><li>又称为调节者模式或调停者模式，行为型设计模式。</li></ul><h4 id="中介者模式的定义"><a href="#中介者模式的定义" class="headerlink" title="中介者模式的定义"></a>中介者模式的定义</h4><ul><li>包装一系列对象相互作用的方式，使这些对象不必相互明显作用。</li><li>将多对多的相互作用转化为一对多的相互作用。</li><li>将对象的行为和协作抽象化。</li></ul><h4 id="中介者模式的使用场景"><a href="#中介者模式的使用场景" class="headerlink" title="中介者模式的使用场景"></a>中介者模式的使用场景</h4><ul><li>对象间交互操作较多且每个对象的行为操作都依赖彼此时，为防止修改其中一对象的行为同时涉及修改很多其他对象的行为。</li><li>该模式将对象之间的多对多关系变成一对多关系。</li><li>中介者对象将系统从网状结构变成以调停者为中心的星形结构，以降低系统复杂性，提高可扩展性作用。</li></ul><h4 id="中介者模式的-UML-类图"><a href="#中介者模式的-UML-类图" class="headerlink" title="中介者模式的 UML 类图"></a>中介者模式的 UML 类图</h4><p>中介者模式的 UML 类图如图 2-30 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-30.png" alt="中介者模式的UML类图"></p><center>图 2-30 中介者模式的 UML 类图</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象中介者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> ConcreteColleagueA colleagueA; <span class="comment">// 具体同事类 A</span></span><br><span class="line"><span class="keyword">protected</span> ConcreteColleagueB colleagueB; <span class="comment">// 具体同事类 B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象中介方法、子类实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleagueA</span><span class="params">(ConcreteColleagueA colleagueA)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.colleagueA = colleagueA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleagueB</span><span class="params">(ConcreteColleagueB colleagueB)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.colleagueB = colleagueB;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体中介者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">colleagueA.action();</span><br><span class="line">colleagueB.action();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象同事</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> Mediator mediator; <span class="comment">// 中介者对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同事角色的具体行为，由子类去实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事 A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleagueA</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleagueA</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(mediator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Colleague A 将信息递交给中介者处理."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事 B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleagueB</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleagueB</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(mediator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Colleague B 将信息递交给中介者处理."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中介者模式的简单实现"><a href="#中介者模式的简单实现" class="headerlink" title="中介者模式的简单实现"></a>中介者模式的简单实现</h4><p>便于理解，本示例的 UML 类图如图 2-31 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-31.png" alt="电脑内部硬件的交互"></p><center>图 2-31 电脑内部硬件的交互</center><p>中介者模式就是用来协调多个对象之间的交互，就像上例中的主板，没有主板这个中介者，那么电脑里的每一个零部件都要与其他零部件建立关联。</p><p>比如 CPU 要与内存交互，与显卡交互以及与 IO 设备交互，那么这样一来就会构成一个错综复杂的网状图，而中介者模式即将网状图变成一个结构清晰的星形图。</p><h4 id="中介者模式实战"><a href="#中介者模式实战" class="headerlink" title="中介者模式实战"></a>中介者模式实战</h4><p>协调多个交互的对象，Android 中这么多形形色色控件也算是交互对象。其中社交、网商等应用的用户登录模块，账号框、密码框、登录按钮之间的相互制约、联系，正是中介者模式的表现，具体的实例样式可自行尝试。</p><h4 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h4><ul><li>中介者模式的优缺点<ul><li>优点 - 将网状般的依赖关系转化为以中介者为中心的星形结构，即使用中介者模式可对这种依赖关系进行解耦使逻辑结构清晰。</li><li>缺点 - 若几个类间的依赖关系并不复杂，使用中介者模式反而会使原本不复杂的逻辑结构变得复杂。</li></ul></li></ul><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="代理模式的定义"><a href="#代理模式的定义" class="headerlink" title="代理模式的定义"></a>代理模式的定义</h4><ul><li>结构型设计模式。</li><li>为其他对象提供一种代理以控制对这个对象的访问。</li></ul><h4 id="代理模式的使用场景"><a href="#代理模式的使用场景" class="headerlink" title="代理模式的使用场景"></a>代理模式的使用场景</h4><ul><li>无法或不想直接访问某个对象或访问某对象存在困难。</li><li>为保证客户端使用的透明性，委托对象与代理对象需实现相同的接口。</li></ul><h4 id="代理模式的-UML-类图"><a href="#代理模式的-UML-类图" class="headerlink" title="代理模式的 UML 类图"></a>代理模式的 UML 类图</h4><p>代理模式的 UML 类图如图 2-32 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-32.png" alt="代理模式的UML类图"></p><center>图 2-32 代理模式的 UML 类图</center><p><strong>Subject：抽象主题类</strong><br>该类主要职责是声明真实主题与代理的共同接口方法，其可是抽象类或接口。</p><p><strong>RealSubject：真实主题类</strong><br>该类也被称为被委托类或者被代理类，该类定义了代理所表示的真实对象，由其执行具体的业务逻辑方法，而客户类则通过代理类间接地调用真实主题类中定义的方法。</p><p><strong>ProxySubject：代理类</strong><br>该类也称为委托类或者代理类，该类持有一个对真实主题类的引用，在其所实现的接口方法中调用真实主题类中相应的接口方法执行，以起到代理的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象主题类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"><span class="comment">// 一个普通的业务方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现抽象主题的真实主题类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Real Subjetc!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> RealSubject mSubject; <span class="comment">// 持有真实主题的引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(RealSubject mSubject)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mSubject = mSubject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mSubject.visit();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 构造一个真实主题对象</span></span><br><span class="line">RealSubject real = <span class="keyword">new</span> RealSubject();</span><br><span class="line"><span class="comment">// 通过真实主题对象构造一个代理对象</span></span><br><span class="line">ProxySubject proxy = <span class="keyword">new</span> ProxySubject(real);</span><br><span class="line"><span class="comment">// 调用代理的相关方法</span></span><br><span class="line">proxy.visit(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代理模式的简单实现"><a href="#代理模式的简单实现" class="headerlink" title="代理模式的简单实现"></a>代理模式的简单实现</h4><p>以生活中常有的例子，老板拖欠工资甚至克扣工资的情况，而最恰当的途径就是通过法律诉讼解决问题。一旦选择走法律途径解决该纠纷，那么不可避免地需请一个律师来作为自己的诉讼代理人。</p><p>便于理解，本示例的 UML 类图如图 2-33 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-33.png" alt="律师作为诉讼代理人"></p><center>图 2-33 律师作为诉讼代理人</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 诉讼接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILawsuit</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>; <span class="comment">// 提交申请</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">burden</span><span class="params">()</span></span>; <span class="comment">// 进行举证</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">defend</span><span class="params">()</span></span>; <span class="comment">// 开始辩护</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>; <span class="comment">// 诉讼完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体诉讼人</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMin</span> <span class="keyword">implements</span> <span class="title">ILawsuit</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"老板拖欠工资，特此申请仲裁!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">burden</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这是合同书和过去一年的银行工资流水!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"证据确凿!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"诉讼成功!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理律师</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lawyer</span> <span class="keyword">implements</span> <span class="title">ILawsuit</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ILawsuit mLawsuit; <span class="comment">// 持有一个具体被代理者的引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Lawyer</span><span class="params">(ILawsuit lawsuit)</span> </span>&#123;</span><br><span class="line">mLawsuit = lawsuit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mLawsuit.submit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">burden</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mLawsuit.burden();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mLawsuit.defend();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mLawsuit.finish();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ILawsuit xiaomin = <span class="keyword">new</span> XiaoMin();</span><br><span class="line">ILawsuit lawyer = <span class="keyword">new</span> Lawyer(xiaomin);</span><br><span class="line"></span><br><span class="line">lawyer.submit();</span><br><span class="line">lawyer.burden();</span><br><span class="line">lawyer.defend();</span><br><span class="line">lawyer.finish();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>静态代理<br>  代码由程序员自己或者通过一些自动化工具生成固定的代码再对其进行编译，即说在我们的代码运行前代理类的 Class 编译文件就已经存在。上述例子即为静态代理的实现模式。</p></li><li><p>动态代理<br>  通过反射机制动态地生成代理者的对象，即我们在编译阶段不需要知道代理者是谁，代理谁我们将在执行阶段决定。Java 提供了便捷的动态代理接口 InvocationHandler。<br>  同样，以动态代理方式实现上述例子，本示例的 UML 类图如图 2-34 所示。</p></li></ul><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-34.png" alt="动态代理的实现案例"></p><center>图 2-34 动态代理的实现案例</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">IncocationHandler</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Object obj; <span class="comment">// 被代理的类引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.obj = obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Object result = method.invoke(obj, args);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ILawsuit xiaomin = <span class="keyword">new</span> XiaoMin();</span><br><span class="line">DynamicProxy proxy = <span class="keyword">new</span> DynamicProxy(xiaomin);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取被代理类小民的 ClassLoader</span></span><br><span class="line">ClassLoader loader = xiaomin.getClass().getClassLoader();</span><br><span class="line"><span class="comment">// 动态构造一个代理者律师</span></span><br><span class="line">ILawsuit lawyer =(ILawsuit) Proxy.newProxyInstance(loader,</span><br><span class="line"><span class="keyword">new</span> Class[] &#123;ILawsuit.class&#125;, proxy);</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 律师提交诉讼申请</span></span><br><span class="line">lawyer.submit();</span><br><span class="line"><span class="comment">// 律师进行举证</span></span><br><span class="line">lawyer.burden();</span><br><span class="line"><span class="comment">// 律师代替小民进行辩护</span></span><br><span class="line">lawyer.defend();</span><br><span class="line"><span class="comment">// 完成诉讼</span></span><br><span class="line">lawyer.finish();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h4><ul><li>代理模式的优缺点<ul><li>优点 - 代理模式可看作一种针对性优化。</li><li>缺点 - 暂没有明显的缺点。</li></ul></li></ul><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><h4 id="组合模式的介绍"><a href="#组合模式的介绍" class="headerlink" title="组合模式的介绍"></a>组合模式的介绍</h4><ul><li>又称部分整体模式，结构型设计模式。</li><li><p>它将一组相似的对象看作一个对象处理，并根据一个树状结构来组合对象，然后提供一个统一的方法去访问相应对象。</p><p>  例如公司组织结构的树状图，如图 2-35 所示。</p><p>  <img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-35.png" alt="公司组织结构的树状图"></p><center>图 2-35 公司组织结构的树状图</center><p>  在组合模式中，我们将这样的一个拥有分支的节点称之为枝干构件，位于树状结构顶部的枝干结构比较特殊，我们称为根结构件，因其为整个树状图的始端。同样对于像行政部和研发部这样没有分支的结构，我们称之为叶子结构，这样的一个结构就是组合模式的雏形。如图 2-36 所示。</p><p>  <img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-36.png" alt="组合模式的雏形"></p><center>图 2-36 组合模式的雏形</center></li></ul><h4 id="组合模式的定义"><a href="#组合模式的定义" class="headerlink" title="组合模式的定义"></a>组合模式的定义</h4><p>将对象组合成 <code>树状结构</code> 以表示 “部分-整体” 的 <code>层次结构</code>，使得用户对单个对象和组合对象的使用具有一致性。</p><h4 id="组合模式的使用场景"><a href="#组合模式的使用场景" class="headerlink" title="组合模式的使用场景"></a>组合模式的使用场景</h4><ul><li>表示对象的 <code>部分-整体</code> 层次结构时。</li><li>从一个整体中能够独立出部分模块或功能的场景。</li></ul><h4 id="组合模式的-UML-类图"><a href="#组合模式的-UML-类图" class="headerlink" title="组合模式的 UML 类图"></a>组合模式的 UML 类图</h4><p>组合模式的 UML 类图如图 2-37 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-37.png" alt="组合模式的UML类图"></p><center>图 2-37 组合模式的 UML 类图</center><p>上述所讲与依赖倒置原则相违背，既然是面向接口编程，则我们就该把焦点放在接口设计上，即在 Composite 的一些实现方法定义到 Component 中。</p><p>这样，我们会得到一个不一样的组合模式，也称为安全的组合模式，该安全组合模式的 UML 类图见图 2-38 所示。</p><p>透明组合模式不管是叶子还是枝干节点都有相同的结构，那么意味着不能单一的 getChildren() 方法得到子字节的类型 (已是叶子节点)，则必须在方法实现的内部进行判断。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-38.png" alt="安全的组合模式的UML类图"></p><center>图 2-38 安全的组合模式的 UML 类图</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 透明的组合模式抽象根节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> String name; <span class="comment">// 节点</span></span><br><span class="line"></span><br><span class="line"><span class="function">pulbic <span class="title">Component</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的逻辑方法由子类实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加子节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@child</span> 子节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Component child)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除子节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@child</span> 子节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(Component child)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取子节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 子节点对应下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Component <span class="title">getChildren</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透明的组合模式具体枝干节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储节点的容器</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Component&gt; components = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Composite</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">null</span> != components ) &#123;</span><br><span class="line"><span class="keyword">for</span>(Component c : components) &#123;</span><br><span class="line">c.doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Component child)</span> </span>&#123;</span><br><span class="line">components.add(child);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(Component child)</span> </span>&#123;</span><br><span class="line">components.remove(child);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Component <span class="title">getChildren</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> components.get(index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透明的组合模式叶子节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Component child)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"叶子节点没有子节点"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(Component child)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"叶子节点没有子节点"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Component <span class="title">getChildren</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"叶子节点没有子节点"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 构造一个根节点</span></span><br><span class="line">Component root = <span class="keyword">new</span> Composite(<span class="string">"Root"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造两个枝干节点</span></span><br><span class="line">Component branch1 = <span class="keyword">new</span> Composite(<span class="string">"Branch1"</span>);</span><br><span class="line">Component branch2 = <span class="keyword">new</span> Composite(<span class="string">"Branch2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造两个叶子节点</span></span><br><span class="line">Component leaf1 = <span class="keyword">new</span> Leaf(<span class="string">"Leaf1"</span>);</span><br><span class="line">Component leaf2 = <span class="keyword">new</span> Leaf(<span class="string">"Leaf2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将叶子节点添加至枝干节点中</span></span><br><span class="line">branch1.addChild(leaf1);</span><br><span class="line">branch2.addChild(leaf2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将枝干节点添加到根节点中</span></span><br><span class="line">root.addChild(branch1);</span><br><span class="line">root.addChild(branch2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行方法</span></span><br><span class="line">root.doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合模式的简单实现"><a href="#组合模式的简单实现" class="headerlink" title="组合模式的简单实现"></a>组合模式的简单实现</h4><p>在操作系统中，文件系统其实就是一种典型的组合模式例子。</p><p>具体地，文件系统中文件就是可被具体程序执行的对象，文件夹就是可存放文件和文件夹的对象。文件系统的组合模式表示如图 2-39 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-39.png" alt="文件系统的组合模式表示"></p><center>图 2-39 文件系统的组合模式表示</center><p>便于理解，本实例的 UML 类图如图 2-40 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-40.png" alt="文件系统的组合模式实现"></p><center>图 2-40 文件系统的组合模式实现</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示文件或文件夹的抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Dir</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明一个 List 成员变量存储文件夹下的所有元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;Dir&gt; dirs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> String name; <span class="comment">// 当前文件或文件夹的名称</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dir</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加一个文件或文件夹</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dir 文件或文件夹</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addDir</span><span class="params">(Dir dir)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除一个文件或文件夹</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dir 文件或文件夹</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rmDir</span><span class="params">(Dir dir)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空文件夹下所有元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出文件夹目录结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文件夹下所有的文件或文件夹</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 文件夹下所有的文件或文件夹</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Dir&gt; <span class="title">getFiles</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文件或文件夹的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 文件或文件夹的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示文件夹的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Folder</span> <span class="keyword">extends</span> <span class="title">Dir</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Folder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDir</span><span class="params">(Dir dir)</span> </span>&#123;</span><br><span class="line">dirs.add(dir);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rmDir</span><span class="params">(Dir dir)</span> </span>&#123;</span><br><span class="line">dirs.remove(dir);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">dirs.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println( getName() + <span class="string">"("</span> );</span><br><span class="line">Iterator&lt;Dir&gt; iterator = dirs.iterator();</span><br><span class="line"><span class="keyword">while</span>( iterator.hasNext() ) &#123;</span><br><span class="line">Dir dir = iterator.next();</span><br><span class="line">dir.print();</span><br><span class="line"><span class="keyword">if</span>( iterator.hasNext() ) &#123;</span><br><span class="line">System.out.println(<span class="string">",\t"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Dir&gt; <span class="title">getFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> dirs;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示文件的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Dir</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDir</span><span class="params">(Dir dir)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line"><span class="string">"文件类不能作为文件夹类来使用，即文件不支持添加也不支持删除"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rmDir</span><span class="params">(Dir dir)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line"><span class="string">"文件类不能作为文件夹类来使用，即文件不支持添加也不支持删除"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line"><span class="string">"文件类不能作为文件夹类来使用，即文件不支持添加也不支持删除"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Dir&gt; <span class="title">getFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line"><span class="string">"文件类不能作为文件夹类来使用"</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 构造一个目录对象表示 C 盘根目录</span></span><br><span class="line">Dir diskC = <span class="keyword">new</span> Folder(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// C 盘根目录下有一个文件 FileLog.txt</span></span><br><span class="line">diskC.addDir( <span class="keyword">new</span> File(<span class="string">"Filelog.txt"</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// C 盘根目录下有3个子目录 windows、perflogs 和 Program File</span></span><br><span class="line">Dir dirWin = <span class="keyword">new</span> File(<span class="string">"windows"</span>);</span><br><span class="line">Dir dirPerf = <span class="keyword">new</span> File(<span class="string">"perflogs"</span>);</span><br><span class="line">Dir dirProg = <span class="keyword">new</span> File(<span class="string">"Program File"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// windows 目录下有文件 explorer.exe</span></span><br><span class="line"><span class="comment">// perflogs 目录下有文件 perflogs.txt</span></span><br><span class="line"><span class="comment">// Program File 目录下有文件 syslogs.txt</span></span><br><span class="line">dirWin.addDir( <span class="keyword">new</span> File(<span class="string">"explorer.exe"</span>) );</span><br><span class="line">dirPerf.addDir( <span class="keyword">new</span> File(<span class="string">"perflogs.txt"</span>) );</span><br><span class="line">dirProg.addDir( <span class="keyword">new</span> File(<span class="string">"syslogs.txt"</span>) );</span><br><span class="line"></span><br><span class="line">diskC.add(dirWin);</span><br><span class="line">diskC.add(dirPerf);</span><br><span class="line">diskC.add(dirProg);</span><br><span class="line"></span><br><span class="line">diskC.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h4><ul><li>组合模式与解释器模式有一定的类同，两者在迭代对象时都涉及递归的调用，但组合模式所提供的属性层次结构使我们能 <code>一视同仁</code> 对待单个对象的对象集合。</li><li>组合模式的优缺点<ul><li>优点<br>1) 清楚定义分层次的复杂对象，表示对象的全部或部分层次，让高层模块忽略了层次差异，方便对整个层次结构进行控制。<br>2) 高层模块可一致地使用一个组合结构或其中单个对象。<br>3) 在组合模式中增加新的枝干结构和叶子构件很方便，无须对类库进行修改。<br>4) 通过叶子对象和枝干对象的递归组合，形成复杂的树形结构，但对其控制却非常简单。</li><li>缺点<br>1) 新增构件时，不好对枝干中的构件类型进行限制，不能依赖类型系统来施加这些约束，因为大多数情况下他们来自相同的抽象层。<br>2) 因此必须进行类型检查来实现。</li></ul></li></ul><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><h4 id="适配器模式的介绍"><a href="#适配器模式的介绍" class="headerlink" title="适配器模式的介绍"></a>适配器模式的介绍</h4><ul><li>ListView、GirdView、RecyclerView 都需要使用 Adapter。</li><li>两个没有关系的类型之间交互，一种解决方法是修改各自类接口；另一种情况是使用一个 Adapter，在两种接口间创建一个 “混血儿” 接口，将两接口兼容。</li></ul><h4 id="适配器模式的定义"><a href="#适配器模式的定义" class="headerlink" title="适配器模式的定义"></a>适配器模式的定义</h4><p>把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法一起工作的两个类能一起工作。</p><h4 id="适配器模式的使用场景"><a href="#适配器模式的使用场景" class="headerlink" title="适配器模式的使用场景"></a>适配器模式的使用场景</h4><ul><li>系统需要使用现存类，而此类接口不符系统需求，即接口不兼容。</li><li>需一个统一的输出接口，而输入端的类型不可预知。</li></ul><h4 id="适配器模式的-UML-类图"><a href="#适配器模式的-UML-类图" class="headerlink" title="适配器模式的 UML 类图"></a>适配器模式的 UML 类图</h4><p>适配器模式也分两种，即类适配器模式和对象适配器模式。</p><ul><li>类适配器模式，如图 2-41 所示。</li></ul><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-41.png" alt="类适配器的UML类图"></p><center>图 2-41 类适配器的 UML 类图</center><p>目标接口需要的是 operation2()，而 Adaptee 对象中有一个 operation3()，因此不兼容。故通过 Adapter 实现一个 operation2() 将 Adapter 的 operation3() 转换为 Target() 需要的 operation2()。</p><ul><li>对象适配器模式，如图 2-42 所示。</li></ul><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-42.png" alt="对象适配器的UML类图"></p><center>图 2-42 对象适配器的 UML 类图</center><p>这种实现方式直接将要被适配的对象传递到 Adapter 中，使用组合的形式实现接口兼容的效果。即带来的好处有，在被适配的对象中不暴露方法细节；且相对类适配器，由于继承了被适配对象，在 Adapter 类中出现一些奇怪接口。因此对象适配器模式的实现更加灵活。</p><h4 id="适配器模式的简单示例"><a href="#适配器模式的简单示例" class="headerlink" title="适配器模式的简单示例"></a>适配器模式的简单示例</h4><p>以电源适配器为例，分别以类适配器和对象适配器模式阐述具体情况。</p><ul><li>5V 电压是 Target 接口。</li><li>220V 电压是 Adaptee 类。</li><li>将电压 220V 转换到 5V 是 Adapter 类。 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以类适配器模式实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Target 角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FiveVolt</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getvolt5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adaptee 角色，需被转换的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volt220</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">220</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adapter 角色，将 220V 的电压转换为 5V 电压</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltAdapter</span> <span class="keyword">extends</span> <span class="title">Volt220</span> <span class="keyword">implements</span> <span class="title">FiveVolt</span> </span>&#123;</span><br><span class="line"><span class="meta">@OVerride</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt5</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">VoltAdapter adpter = <span class="keyword">new</span> VoltAdapter();</span><br><span class="line">System.out.println(输出电压：adapter.getVolt5);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以对象适配器模式实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Target 角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FiveVolt</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getvolt5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adaptee 角色，需被转换的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volt220</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">220</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adapter 角色，将 220V 的电压转换为 5V 电压</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltAdapter</span> <span class="keyword">implements</span> <span class="title">FiveVolt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Volt220 mVolt220;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VoltAdapter</span><span class="params">(Volt220 adaptee)</span> </span>&#123;</span><br><span class="line">mVolt220 = adaptee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt220</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mVolt220.getVolt220();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OVerride</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt5</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">VoltAdapter adpter = <span class="keyword">new</span> VoltAdapter( <span class="keyword">new</span> Volt220() );</span><br><span class="line">System.out.println(输出电压：adapter.getVolt5);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h4><ul><li>适配器模式的优缺点<ul><li>优点<br>1) 更好的复用性：系统需使用现有的类，而此类的接口不符系统需求，则通过适配器模式可让这些功能得到更好的复用。<br>2) 更好的扩展性。  </li><li>缺点 - 若可对系统重构，尽可能不使用适配器，过多使用适配器，容易让系统凌乱，不易整体把握。</li></ul></li></ul><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><h4 id="装饰模式的介绍"><a href="#装饰模式的介绍" class="headerlink" title="装饰模式的介绍"></a>装饰模式的介绍</h4><ul><li>又称为包装模式，结构性设计模式。</li><li>使用一种对客户端透明的方式来动态地扩展对象的功能，同时它也是继承关系的一种替代方案。</li></ul><h4 id="装饰模式的定义"><a href="#装饰模式的定义" class="headerlink" title="装饰模式的定义"></a>装饰模式的定义</h4><p>动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式相比生成子类更为灵活。</p><h4 id="装饰模式的使用场景"><a href="#装饰模式的使用场景" class="headerlink" title="装饰模式的使用场景"></a>装饰模式的使用场景</h4><p>需要透明地、动态地扩展类的功能时，装饰模式不失一种理想方案。</p><h4 id="装饰模式的-UML-类图"><a href="#装饰模式的-UML-类图" class="headerlink" title="装饰模式的 UML 类图"></a>装饰模式的 UML 类图</h4><p>装饰模式的 UML 类图如图 2-43 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-43.png" alt="装饰模式的UML类图"></p><center>图 2-43 装饰模式的 UML 类图</center><p><strong>Component：抽象组件</strong><br>可以是一个接口或者抽象类，充当被装饰的原始对象。</p><p><strong>ConcreteComponent：组件具体实现类</strong><br>该类是 Component 类的基本实现，也是我们装饰的具体对象。</p><p><strong>Decorator：抽象装饰者</strong><br>其承担的职责是为了装饰我们的组件对象，其内部一定要有一个指向组件对象的引用。</p><p><strong>ConcreteDecorator：抽象装饰者</strong><br>对抽象装饰者做出具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象组件类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象的方法：自由增加你需要的抽象方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 忽略实现细节</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象装饰者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Component component; <span class="comment">// 持有一个 Component 对象的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必要的构造方法，需要一个 Component 类型的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> component Component 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.component = component;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">component.operate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰者具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ConcreteDecoratorA</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(component);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">operateA();</span><br><span class="line"><span class="keyword">super</span>.operate();</span><br><span class="line">operateB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operateA</span><span class="params">()</span> </span>&#123; <span class="comment">// 自定义的装饰方法 A</span></span><br><span class="line"><span class="comment">// 装饰方法逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operateB</span><span class="params">()</span> </span>&#123; <span class="comment">// 自定义的装饰方法 B</span></span><br><span class="line"><span class="comment">// 装饰方法逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造被装饰的组件对象</span></span><br><span class="line">Component component = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据组件对象构造装饰者对象并调用，即给组件对象增加装饰者的功能方法</span></span><br><span class="line">Decorator.decoratorA = <span class="keyword">new</span> ConcreteDecoratorA(component);</span><br><span class="line">decoratorA.operate();</span><br><span class="line"></span><br><span class="line">Decorator.decoratorB = <span class="keyword">new</span> ConcreteDecoratorB(component);</span><br><span class="line">decoratorB.operate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="装饰模式实战"><a href="#装饰模式实战" class="headerlink" title="装饰模式实战"></a>装饰模式实战</h4><p>其实装饰模式并不复杂，也不陌生，它就是一种 <code>类间的封装</code>，例如我们常在 Activity 的 onCreate() 方法中做一些相关的初始化操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle saveInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(saveInstanceState);</span><br><span class="line"></span><br><span class="line">initViews();</span><br><span class="line">findViews();</span><br><span class="line">setListeners();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 匹配组件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置组件的监听器</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h4><ul><li><p>装饰模式与代理模式的区别 (容易混淆)</p><ul><li>装饰模式：以对客户端透明的方式 <code>扩展对象的功能</code>，即继承关系的一个替代方案。</li><li><p>代理模式：给一个对象提供一个代理对象，并由 <code>代理对象</code> 来控制对原有对象引用。 </p><blockquote><p>代理模式，即对代理的对象施加控制。</p></blockquote></li></ul></li></ul><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><h4 id="享元模式的介绍"><a href="#享元模式的介绍" class="headerlink" title="享元模式的介绍"></a>享元模式的介绍</h4><ul><li>又称 FlyWeight，代表轻量级的意思，结构型设计模式。</li><li><code>对象池</code> 的一种实现。</li><li><p>享元模式用来是尽可能减少内存使用量，它适用于可能存在大量重复对象的场景。  </p><blockquote><p>目的：缓存可共享的对象，达到对象共享，避免过多创建对象，即提升性能、避免内存移除。</p></blockquote></li><li>享元对象<ul><li>内存状态：可共享，不随环境变化</li><li>外部状态：不可共享，随环境变化</li><li>对象容器：在经典的享元模式中，对象容器为一 Map，它的 <code>键</code> 是享元对象的<code>内部状态</code>，它的 <code>值</code> 是 <code>享元对象本身</code>。</li></ul></li><li>客户端通过这个内部状态从享元工厂中获取享元对象，若有缓存则使用缓存对象，否则创建一个享元对象并存入容器中。</li></ul><h4 id="享元模式的定义"><a href="#享元模式的定义" class="headerlink" title="享元模式的定义"></a>享元模式的定义</h4><p>使用共享对象可有效地支持大量的细粒度的对象。</p><h4 id="享元模式的使用场景"><a href="#享元模式的使用场景" class="headerlink" title="享元模式的使用场景"></a>享元模式的使用场景</h4><ul><li>系统中存在大量的 <code>相似对象</code>。</li><li>细粒度的对象都具备较接近的外部状态，且内部状态与环境无关，即对象没有特定身份。</li><li>需要 <code>缓冲池</code> 的场景。</li></ul><h4 id="享元模式的-UML-类图"><a href="#享元模式的-UML-类图" class="headerlink" title="享元模式的 UML 类图"></a>享元模式的 UML 类图</h4><p>享元模式的 UML 类图如图 2-44 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-44.png" alt="享元模式的UML类图"></p><center>图 2-44 享元模式的 UML 类图</center><h4 id="享元模式的简单示例"><a href="#享元模式的简单示例" class="headerlink" title="享元模式的简单示例"></a>享元模式的简单示例</h4><p>例1. 过年回家买火车票，无数人在客户端上订票 (有多次购票、刷票的情况)，即不断向服务端发送请求。</p><p>而每次查询，服务器必须做出回应，具体地，用户查询输入出发地和目的地，查询结构返回值只有一趟列车的车票。而数以万计的人有同样需求，即不间断请求数据，每次重新创建一个查询的车票结果，即造成大量重复对象创建、销毁，使得服务器压力加重。</p><p>享元模式正好适合解决该情形的问题，例如 A 到 B 地的车辆是有限的，车上铺位分硬卧、软卧和坐票三种，将这些可公用的对象缓存起来。用户查询时优先使用缓存，反之则重新创建。</p><p>便于理解，本示例的 UML 类图如图 2-45 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-45.png" alt="网上订票系统的UML类图"></p><center>图 2-45 网上订票系统的 UML 类图</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showTicketInfo</span><span class="params">(String bunk)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 火车票</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainTicket</span> <span class="keyword">implements</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String from; <span class="comment">// 始发地</span></span><br><span class="line"><span class="keyword">public</span> String to; <span class="comment">// 目的地</span></span><br><span class="line"><span class="keyword">public</span> String bunk; <span class="comment">// 铺位</span></span><br><span class="line"></span><br><span class="line">TrainTicket(String from, String to) &#123;</span><br><span class="line"><span class="keyword">this</span>.from = from;</span><br><span class="line"><span class="keyword">this</span>.to = to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showTicketInfo</span><span class="params">(String bunk)</span> </span>&#123;</span><br><span class="line">price = <span class="keyword">new</span> Random().nextInt(<span class="number">300</span>);</span><br><span class="line">System.out.println(<span class="string">"From:"</span> + from</span><br><span class="line">+ <span class="string">"To:"</span> + to</span><br><span class="line">+ <span class="string">"Bunk:"</span> + bunk</span><br><span class="line">+ <span class="string">"Price:"</span> + price);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketFactory</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> Map&lt;String, Ticket&gt; sTicketMap = </span><br><span class="line"><span class="keyword">new</span> ConcurrentHashMap&lt;String, Ticket&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Ticket <span class="title">getTicket</span><span class="params">(String from, String to)</span> </span>&#123;</span><br><span class="line">String key = from + <span class="string">"-"</span> + to;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( sTicketMap.containsKey(key) ) &#123; <span class="comment">// 使用缓存</span></span><br><span class="line"><span class="keyword">return</span> sTicketMap.get(key);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 创建对象</span></span><br><span class="line">Ticket ticket = <span class="keyword">new</span> TrainTicket(from, to);</span><br><span class="line">sTicketMap.put(key, ticket);</span><br><span class="line"><span class="keyword">return</span> ticket;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2. 我们知道 Java 中 String 是存在于常量池中，即一个 String 被定义之后它就被缓存到了常量池中，当其他地方使用同样的字符串，则直接使用缓存，而非创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String str1 = <span class="string">"Hello World"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"Hello World"</span>);</span><br><span class="line">String str3 = <span class="string">"Hello "</span> + <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println( <span class="string">"\nStr1 - Str3: "</span> + str1.equals(str3)</span><br><span class="line">+  <span class="string">"\nStr2 - Str3: "</span> + str2.equals(str3)</span><br><span class="line">+  <span class="string">"\nStr1 - Str2: "</span> + str1.equals(str1));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出的结果分别是：true，false，false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h4><ul><li>享元模式的优缺点<ul><li>优点 - 大幅度地降低内存中对象的数量。</li><li>缺点<br>1) 为了使对象可共享，需将一些状态外部化，使程序的逻辑复杂化。<br>2) 将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。  </li></ul></li></ul><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><h4 id="外观模式的介绍"><a href="#外观模式的介绍" class="headerlink" title="外观模式的介绍"></a>外观模式的介绍</h4><ul><li>又称门面模式 (Facade模式)，结构型设计模式。</li><li>通过一个外观类使得整个系统中接口只有一个 <code>统一的高层接口</code>，即这样降低用户使用成本，也对用户屏蔽了很多实现细节。</li><li>外观模式是 <code>封装API</code> 的常用手段。</li></ul><h4 id="外观模式的定义"><a href="#外观模式的定义" class="headerlink" title="外观模式的定义"></a>外观模式的定义</h4><ul><li>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。</li><li>外观模式提供一个高层次接口，使得子系统更易于使用。</li></ul><h4 id="外观模式的使用场景"><a href="#外观模式的使用场景" class="headerlink" title="外观模式的使用场景"></a>外观模式的使用场景</h4><ul><li><p>为一个复杂的子系统提供一个简单接口。</p><blockquote><p>对于系统进行定制、修改，这种易变性，使得隐藏子系统的具体实现变得尤为重要，对外隐藏子系统的具体实现，隔离变化。</p></blockquote></li><li>构建一层次结构的子系统，子系统间相互依赖，则通过 Facade 接口进行通信，从而简化他们的依赖关系。</li></ul><h4 id="外观模式的-UML-类图"><a href="#外观模式的-UML-类图" class="headerlink" title="外观模式的 UML 类图"></a>外观模式的 UML 类图</h4><p>外观模式的 UML 类图如图 2-46 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-46.png" alt="外观模式的UML类图"></p><center>图 2-46 外观模式的 UML 类图</center><h4 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h4><ul><li>外观模式的精髓在于 <code>封装</code>。通过一高层次结构为用户提供统一的 API 入口，使得用户通过一个类就基本能够操作整个系统。</li><li>外观模式的优缺点<ul><li>优点<br>1) 对客户端隐藏子系统细节，因而减少客户对于子系统的耦合。<br>2) 外观类对子系统的接口封装，使得系统更易于使用。  </li><li>缺点<br>1) 外观类没有遵循开闭原则，当业务出现变更时，可能需要直接修改外观类。</li></ul></li></ul><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><h4 id="桥接模式的介绍"><a href="#桥接模式的介绍" class="headerlink" title="桥接模式的介绍"></a>桥接模式的介绍</h4><ul><li>又称桥梁模式，结构型设计模式。</li><li>承接者连接 <code>两边</code> 的作用，两边指抽象部分和实现部分。</li></ul><h4 id="桥接模式的定义"><a href="#桥接模式的定义" class="headerlink" title="桥接模式的定义"></a>桥接模式的定义</h4><p>将 <code>抽象部分</code> 和 <code>实现部分</code> 分离，使它们都可以独立地进行变化。</p><h4 id="桥接模式的使用场景"><a href="#桥接模式的使用场景" class="headerlink" title="桥接模式的使用场景"></a>桥接模式的使用场景</h4><ul><li>对于不希望使用继承或因多层次继承导致系统类的个数急剧增加的系统，考虑使用桥接模式。</li><li>需要在构件的抽象化角色和具体角色之间增加更多灵活性，避免两层次间建立静态的继承关系，可通过桥接模式使它们在抽象层建立一个关联关系。</li><li>一个类存在两个独立变化的维度，且这两个维度都需进行扩展。</li><li>任何多维度变化类或多个树状类之间的耦合可通过桥接模式解耦。</li></ul><h4 id="桥接模式的-UML-类图"><a href="#桥接模式的-UML-类图" class="headerlink" title="桥接模式的 UML 类图"></a>桥接模式的 UML 类图</h4><p>桥接模式的 UML 类图如图 2-47 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-47.png" alt="桥接模式的UML类图"></p><center>图 2-47 桥接模式的 UML 类图</center><p><strong>Abstraction：抽象部分</strong><br>该类保持一个对实现部分对象的引用，抽象部分中的方法需要调用实现部分的对象来实现。该类一般为抽象类。</p><p><strong>RefinedAbstraction：优化的抽象部分</strong><br>抽象部分的具体实现，该类一般是对抽象部分的方法进行完善和扩展。</p><p><strong>Implementor：实现部分</strong><br>可以为接口或抽象类，其方法不一定要与抽象部分中的一致，一般情况下是由实现部分提供基本的操作，而抽象部分定义的则是基于实现部分这些基本操作的业务方法。</p><p><strong>ConcreteImplementorA/B：实现部分的具体实现</strong><br>完成实现部分中定义的具体逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现部分的抽象接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现抽象部分的具体方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现部分具体的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 忽略实现逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象部分</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line"><span class="comment">// 声明一私有成员变量引用实现部分的对象</span></span><br><span class="line"><span class="keyword">private</span> Implementor mImplementor; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过实现部分对象的引用构造抽象部分的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> implementor 实现部分对象的引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Abstraction</span><span class="params">(Implementor implementor)</span> </span>&#123;</span><br><span class="line">mImplementor = implementor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过调用实现部分具体的方法实现具体的功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mImplementor.operationImpl();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化的抽象部分</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor implementor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(implementor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对 Abstraction 中的方法进行扩展</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refinedOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 忽略实现逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">RefinedAbstraction abstration = </span><br><span class="line"><span class="keyword">new</span> RefinedAbstraction( <span class="keyword">new</span> ConcreteImplementorA );</span><br><span class="line"></span><br><span class="line">abstraction.operation();</span><br><span class="line">abstraction.refinedOperation();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="桥接模式实战"><a href="#桥接模式实战" class="headerlink" title="桥接模式实战"></a>桥接模式实战</h4><p>View 的视图层级与执行真正的硬件绘制相关类之间的关系可看作是一种桥接模式。即模仿这种行为，我们可自定义控件以桥接的方式提供多种不同的实现机制。</p><p>以进度条为例，我们可继承 View 类来实现进度条控件，自定义水平、垂直和圆形等不同形式的进度条。</p><p>便于理解，本示例的 UML 类图如图 2-48 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-48.png" alt="进度条框架的UML类图"></p><center>图 2-48 进度条框架的 UML 类图</center><h4 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h4><p>桥接模式，分离抽象与实现，其优点毋庸置疑，即灵活的扩展以及对客户来说透明的是实现。但不足之处在于运用桥接模式进行设计，是有一定难度的，需多加推敲与研究。</p><h2 id="叁-MVC-与-MVP-模式"><a href="#叁-MVC-与-MVP-模式" class="headerlink" title="叁 MVC 与 MVP 模式"></a>叁 MVC 与 MVP 模式</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ul><li><p>模型 - 视图 - 控制器 (Model - View - Controller，MVC)，是一种 <code>框架模式</code> ，而非设计模式。</p><blockquote><p>GOF 把 MVC 看作3种设计模式，即观察者模式、策略模式与组合模式的合体，也就是一个基于 <code>发布/订阅者模型</code> 的框架。</p></blockquote></li><li><p>软件开发领域的3种级别重用：</p><ul><li>内部重用：同一应用中能公共使用的抽象块。</li><li>代码重用：将通用模块组合成库或工具集，以便在多个应用和领域都能使用。</li><li><p>应用框架重用：为专用领域提供通用的或者现成的基础结构，以获得最高级别的重用性。</p><blockquote><p>平时开发过程中，常见的框架模式除了 MVC 外，还有 MVVC、MTV、CBD、ORM 和 MVP。</p></blockquote></li></ul></li><li>MVC 模式的优缺点<ul><li>优点 - 表现层与业务层分离实现，各司其职。若在实际项目中，即前端工程师专注界面的研发，后端工程师致力于业务逻辑。</li><li>缺点：<br>1) Model 和 View 严格分离，在调试应用程序时较困难。<br>2) 小规模项目，采用 MVC 模式反而显得工序更加繁琐。  </li></ul></li></ul><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><ul><li><p>数据的存取 - 用户界面 - 交互中间人 (Model - View - Presenter，MVP)，分离显示层和逻辑层，它们之间通过接口进行通信，降低耦合。</p></li><li><p>MVP 模式的三个角色</p><ul><li><p><strong>Presenter：交互中间人</strong><br>View 和 Model 沟通的桥梁。它从 Model 层检索数据后，返回给 View 层，使得 View 和 Model 之间没有耦合，也将业务逻辑从 View 角色上抽离。</p></li><li><p><strong>View：用户界面</strong><br>在 Android 中，通常指 Activity、Fragment 或某个 View 控件，它含有一个 Presenter 成员变量，且 View 需实现以逻辑接口。将 View 上操作通过转交给 Presenter 实现，最后 Presenter 调用 View 逻辑接口将结果返回给 View。 </p></li><li><p><strong>Model：数据的存取</strong><br>主要提供数据的存取功能。Presenter 需通过 Model 层存储、获取数据。</p></li></ul></li></ul><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_3-1.png" alt="MVP模式的三个角色"></p><center>图 3-1 MVP模式的三个角色</center><ul><li><p>与 MVC 模式的区别</p><ul><li><p>MVC 特点<br>1) 用户可向 View 发送指令，再由 View 直接要求 Model 改变状态。<br>2) 用户可向 Controller 发送指令，再由 Controller 发送给 View。<br>3) Controller 起到时间路由的作用，同时业务逻辑都部署在 Controller 中。  </p><blockquote><p>View 可直接访问 Model，即 MVC 模式的耦合性还是相对较高的。</p></blockquote></li></ul></li></ul><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_3-2.png" alt="MVC模式的三个角色"></p><center>图 3-2 MVC模式的三个角色</center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;在你接触过的安卓项目当中，如监听器、适配器、迭代器等并不陌生，然而它们无不体现着设计模式的精髓。设计与模式的结合，往往与设计能力与代码质量息息相关。同理，逆过来思考此类问题，对于一些优秀项目、源码的理解障碍往往是对其设计 (逻辑、性能、解耦等) 的理解，而非源码本身。而作为开发者，知其然知其所以然，这也正是我们深入学习设计模式的理由之一。&lt;/p&gt;
&lt;p&gt;当然，我们还要正视学习设计模式的心态。掌握了各种设计模式，并不代表你的设计能力与代码质量就会突飞猛进，同样在项目中运用设计模式也不是生搬硬套就解决问题了，在《 &lt;a href=&quot;https://book.douban.com/subject/2243615/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Head First 设计模式&lt;/a&gt; 》一书中，则把设计模式的使用心智分为：初学者、中级人员和悟道者，虽有“玄学”的味道，但也恰当。即没有最好的模式，而是你综合众多因素，根据经验、方法来筛选合适的设计模式与你的项目结合，运用。&lt;/p&gt;
&lt;p&gt;最后，对于设计模式的学习，不要局限于《 &lt;a href=&quot;https://book.douban.com/subject/26644935/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 源码设计模式&lt;/a&gt; 》本身，你可以搭配一些经典论文、综述，或者书籍，以至于怀疑一个问题的正误，多比对、多思考，以得到最精确的理解。而本笔记的作用也在于此，即一个设计模式的架构，或是借鉴学习，亦或是复习之需便于查询。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://www.kofes.cn/categories/Reading/"/>
    
    
      <category term="UML" scheme="http://www.kofes.cn/tags/UML/"/>
    
      <category term="Android" scheme="http://www.kofes.cn/tags/Android/"/>
    
      <category term="设计模式" scheme="http://www.kofes.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>项目 - 基于 Hexo 框架在 Github 上搭建博客</title>
    <link href="http://www.kofes.cn/2018/01/Hexo-Installation-Guide.html"/>
    <id>http://www.kofes.cn/2018/01/Hexo-Installation-Guide.html</id>
    <published>2018-01-19T10:46:03.000Z</published>
    <updated>2018-01-22T03:17:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>Hexo\(^{[1]}\)，一个快速、简洁且高效的博客框架，若以个人博文为主导需求，它的强大毋庸置疑。    </p><p>Hexo 支持 GitHub Flavored Markdown 的所有功能；且基于 Node.Js 所带来的超快生成速度，百页博文秒级渲染；开放性 API 以及丰富的插件等，即功能来得纯粹，不失个性化定制，上手容易且操作便捷。更重要的一点，它是开源的、免费的博客框架，数据保存在本地以及 Github 上，相信在众多博客产品中选择、博弈，相信 Hexo 的表现不会令你失望。</p><p>对于 Hexo 的安装、使用教程尽量遵照官方使用文档的流程操作，而本文则将侧重于 Hexo 的优化体验、实用插件等方面的内容分享。</p><p>若想了解详情可访问「<a href="https://hexo.io/" target="_blank" rel="noopener">hexo.io</a>」。</p><a id="more"></a><h2 id="壹-搭建环境"><a href="#壹-搭建环境" class="headerlink" title="壹 搭建环境"></a>壹 搭建环境</h2><ul><li>Mac OS、Windows 环境下的配置流程和步骤大同小异，而搭建环境的大致流程为：  <ul><li>Git 环境配置 ( Windows )</li><li>Node.Js 环境配置</li><li>Github 账号注册和配置</li><li>Hexo 的安装和配置</li></ul></li><li>考虑到是流程操作类的文章，为简单起见，则我们以 MacOS 和 Windows 版本分别说明情况：<ul><li><a href="#MacOS-版本">MacOS 版本</a></li><li><a href="#Windows-版本">Windows 版本</a></li></ul></li></ul><h3 id="MacOS-版本"><a href="#MacOS-版本" class="headerlink" title="MacOS 版本"></a>MacOS 版本</h3><h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><ul><li>Xcode: Hexo的编译依赖于 Xcode<ul><li>Xcode 可自行到 Apple App Store 下载</li></ul></li><li><p>Node.Js: Hexo 是基于 Node.Js 开发的</p><ul><li><a href="https://nodejs.org/" target="_blank" rel="noopener">官方下载</a></li><li>本地安装，文件包为「Node-Vx.x.x.pkg」</li><li><p>检测是否安装成功，当然返回版本信息即成功安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端下输入命令:  </span></span><br><span class="line">node -v  </span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>Github Account ( <strong>已有账号、项目可忽略</strong> )</p><ul><li>注册账号「<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>」</li><li><p>创建代码库 </p><blockquote><p>具体操作步骤:  </p><ol><li>Add ( 右上角「+」图标 ) &gt; New Repository；  </li><li>Repository Name，填写<code>yourname.github.io</code>；        </li><li>Repository Description，填写<code>简单描述</code>；</li></ol></blockquote></li><li><p>配置代码库</p><blockquote><p>具体操作步骤:  </p><ol><li>进入项目「yourname.github.io」；  </li><li>Settings &gt; GitHub Pages，开启<code>GH-Pages</code>功能；  </li><li>点击「Launch Automatic Page Generator」；</li></ol><p>第三步说明:<br>Github 将会自动替你创建出一个 GH-Pages 的页面。若配置没有问题，约15分钟后，yourname.github.io 就可以正常访问了，配置结束。</p></blockquote></li></ul></li></ul><h4 id="安装-HEXO"><a href="#安装-HEXO" class="headerlink" title="安装 HEXO"></a>安装 HEXO</h4><h5 id="安装-HEXO-1"><a href="#安装-HEXO-1" class="headerlink" title="安装 HEXO"></a>安装 HEXO</h5><ul><li><p>本地选择安装目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> your-hexo-site</span><br></pre></td></tr></table></figure></li><li><p>在线安装 HEXO ( <a href="http://npm.taobao.org/" target="_blank" rel="noopener">NPM淘宝源</a> )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g  </span><br><span class="line">hexo init  </span><br><span class="line">hexo install</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>检测是否安装成功，当然返回版本信息即成功安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure></li></ul><h5 id="运作-HEXO"><a href="#运作-HEXO" class="headerlink" title="运作 HEXO"></a>运作 HEXO</h5><ul><li><p>本地运作 HEXO</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server<span class="comment"># 或简写 hexo s</span></span><br></pre></td></tr></table></figure></li><li><p>当终端提示以下信息，则本地配置工作基本完成。</p><blockquote><p>Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>. Press Ctrl+C to stop.</p></blockquote></li></ul><h5 id="使用-HEXO"><a href="#使用-HEXO" class="headerlink" title="使用 HEXO"></a>使用 HEXO</h5><blockquote><p>[注意] 此项操作，需要确保在 Hexo 安装目录下执行。</p></blockquote><ul><li><p>新建一篇博文 ( 当然，更新过往的文章只需修改「Hexo &gt; Source &gt; _Posts」目录下相应的 MarkDown 文件 )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">"Article Title"</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>生成博文 ( 生成静态网页 )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure></li></ul><h5 id="部署至-GitHub"><a href="#部署至-GitHub" class="headerlink" title="部署至 GitHub"></a>部署至 GitHub</h5><ul><li><p>部署至 Git 的准备工作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在部署前，还需要安装「Git部署插件」:  </span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若没有安装该插件，会出现情况：</span></span><br><span class="line"><span class="comment"># deloyer not found:git</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>再者，与 Github 连接前需要获得授权，不然会出现以下情况 ( 本机没有配置 Public Key ):</p><blockquote><p>Permission denied (publickey).<br>fatal: Could not read from remote repository.<br>Please make sure you have the correct access rights and the repository exists.</p></blockquote></li><li><p>配置「SSH KEY / Public KEY」</p><blockquote><p>[注意] 若之前机器上配置了 Git 的信息，请跳过该步骤。</p></blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 配置 Git 的 UserName 和 Email </span></span><br><span class="line"><span class="comment"># “YourAnonymousName"，可以替换成自己的用户名   </span></span><br><span class="line">git config --global user.name <span class="string">"YourAnonymousName"</span>  </span><br><span class="line"><span class="comment"># "UserName@xxx.com"，替换成自己的邮箱  </span></span><br><span class="line">git config --global user.email <span class="string">"UserName@xxx.com"</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 检查是否已经有 SSH KEY </span></span><br><span class="line"><span class="comment"># Step01. 列出该目录下的文件；</span></span><br><span class="line"><span class="comment"># Step02. 看是否存在「id_isa」和「id_isa.pub」文件；</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">ls</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Step03. 若存在则跳过，没有则执行此步骤「生成密钥」.</span></span><br><span class="line"><span class="comment"># 邮箱「UserName@xxx.com」替换成自己的邮箱</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"UserName@xxx.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 登陆 Github, 添加 SSH KEY</span></span><br><span class="line"><span class="comment"># Step01. Avatar(头像) &gt; Settings &gt; Personal Settings &gt; SSH and GPG keys； </span></span><br><span class="line"><span class="comment"># Step02. New SSH KEY，把「id_isa.pub」的密钥粘贴过去即可.  </span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 4. 测试是否配置成功</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"><span class="comment"># 提示「Hi YourName! You've successfully authenticated, but GitHub does not provide shell. access.」即成功配置。</span></span><br></pre></td></tr></table></figure></li><li><p>配置「_config.yml」文件  </p><ul><li><p>在 Hexo 安装目录下找到 _config.yml 文件，如「~/你的安装目录/Hexo/_config.yml」。找到「deploy」字段，修改配置。</p><blockquote><p>deploy:<br>type: git<br>repo: <a href="https://github.com/yourname/yourname.github.io.git" target="_blank" rel="noopener">https://github.com/yourname/yourname.github.io.git</a><br>branch: master  </p></blockquote></li><li><p>注意: 冒号后面含一个空格；使用 Github 不用 branch 字段；若使用多个 deployer，则有：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- <span class="built_in">type</span>: git</span><br><span class="line">repo:</span><br><span class="line">- <span class="built_in">type</span>: heroku </span><br><span class="line">repo:</span><br></pre></td></tr></table></figure></li></ul></li><li><p>部署至 Git</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy  </span><br><span class="line">hexo d -g<span class="comment"># 即在部署之前先生成</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Windows-版本"><a href="#Windows-版本" class="headerlink" title="Windows 版本"></a>Windows 版本</h3><h4 id="配置环境-1"><a href="#配置环境-1" class="headerlink" title="配置环境"></a>配置环境</h4><blockquote><p>Github 账号注册和配置和 Hexo 的安装和配置，在 Windows 与 MacOS 上是通用的。因此，在 Windows 版本中，主要阐述 Node.Js和 Git 的安装和配置即可。</p></blockquote><ul><li><p>Node.Js 的安装和准备</p><ul><li>下载并安装「<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.Js for Windows x86/x64 bit</a>」</li><li><p>检测是否安装成功，当然返回版本信息即成功安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v  </span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>Git 的安装和准备</p><ul><li>下载并安装「<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git for Windows x86/x64 bit</a>」</li><li><p>检测是否安装成功，当然返回版本信息即成功安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="贰-优化拓展"><a href="#贰-优化拓展" class="headerlink" title="贰 优化拓展"></a>贰 优化拓展</h2><p>至此，Hexo 的安装以及 GitHub 的配置工作暂告一段落。能正常运行使用 Hexo 是没问题的，而下面的章节则是对 Hexo 的扩展和个性化定制，根据自己的需求挑选阅读、实践。</p><h3 id="套用一款主题"><a href="#套用一款主题" class="headerlink" title="套用一款主题"></a>套用一款主题</h3><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。</p><p>在 Hexo 中有两份主要的配置文件，其名称都是「_config.yml」。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p><p>为了描述方便，在以下说明中，将前者称为「<code>站点配置文件</code>」， 后者称为「<code>主题配置文件</code>」。</p><p>具体以 NexT\(^{[2]}\) 为例说明，安装步骤如下。</p><h4 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h4><p>如果你熟悉 Git， 建议你使用<code>克隆最新版本</code>的方式，之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆最新版本</span></span><br><span class="line"><span class="built_in">cd</span> your-hexo-site  </span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next. themes/next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速更新</span></span><br><span class="line"><span class="built_in">cd</span> themes/next</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h4 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h4><ul><li><p>与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到<code>theme</code>字段，并将其值更改为<code>next</code>。</p><blockquote><p>theme: next</p></blockquote></li><li><p>到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></li></ul><h4 id="主题设定"><a href="#主题设定" class="headerlink" title="主题设定"></a>主题设定</h4><ul><li><p>选择 Scheme</p><p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：</p><ul><li>Muse - 默认 Scheme，黑白主调，大量留白  </li><li>Mist - Muse 的紧凑版本，整洁有序的单栏外观  </li><li><p>Pisces - 双栏 Scheme，小家碧玉似的清新  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line">scheme: Pisces</span><br></pre></td></tr></table></figure><blockquote><p>Scheme 的切换通过更改<code>主题配置文件</code>，搜索「scheme」关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。</p></blockquote></li></ul></li><li><p>设置语言</p><p>  编辑<code>站点配置文件</code>， 将<code>language</code>设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下 ( 更多请语言配置请参考下述表格 )：</p><blockquote><p>language: zh-Hans  </p></blockquote></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">语言</th><th style="text-align:left">代码</th><th style="text-align:left">设定示例</th></tr></thead><tbody><tr><td style="text-align:left">English</td><td style="text-align:left">en</td><td style="text-align:left">language: en</td></tr><tr><td style="text-align:left">简体中文</td><td style="text-align:left">zh-Hans</td><td style="text-align:left">language: zh-Hans</td></tr><tr><td style="text-align:left">Français</td><td style="text-align:left">fr-FR</td><td style="text-align:left">language: fr-FR</td></tr><tr><td style="text-align:left">Português</td><td style="text-align:left">pt</td><td style="text-align:left">language: pt or pt-BR</td></tr><tr><td style="text-align:left">繁體中文</td><td style="text-align:left">zh-hk</td><td style="text-align:left">language: zh-hk</td></tr><tr><td style="text-align:left">Русский</td><td style="text-align:left">язык    ru</td><td style="text-align:left">language: ru</td></tr><tr><td style="text-align:left">Deutsch</td><td style="text-align:left">de</td><td style="text-align:left">language: de</td></tr><tr><td style="text-align:left">日本語</td><td style="text-align:left">ja</td><td style="text-align:left">language: ja</td></tr><tr><td style="text-align:left">Indonesian</td><td style="text-align:left">id</td><td style="text-align:left">language: id</td></tr><tr><td style="text-align:left">Korean</td><td style="text-align:left">ko</td><td style="text-align:left">language: ko</td></tr></tbody></table></div><ul><li><p>设置菜单</p><p>  菜单配置包括三个部分，第一是菜单项 ( 名称和链接 )，第二是菜单项的显示文本，第三是菜单项对应的图标。</p><p>  NexT 使用的是 <a href="http://fontawesome.io/" target="_blank" rel="noopener">Font Awesome</a>\(^{[3]}\) 提供的图标，600+ 的图标可满足大部分需求，且适配 Retina 屏幕。</p><p>  编辑<code>主题配置文件</code>，修改以下内容：</p>   <div class="note warning"><p>请注意键值（如 home）的大小写要严格匹配。 </p></div><ul><li><p>设定菜单内容，对应的字段是<code>menu</code>，菜单内容的设置格式是：<code>item name: link</code>。其中<code>item name</code>是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: /</span><br><span class="line">archives: /archives</span><br><span class="line"><span class="comment">#about: /about</span></span><br><span class="line"><span class="comment">#categories: /categories</span></span><br><span class="line">tags: /tags</span><br><span class="line"><span class="comment">#commonweal: /404.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若你的站点运行在子目录中，请将链接前缀的/去掉</span></span><br></pre></td></tr></table></figure><p> NexT 默认的菜单项有( 标注 <code>*</code> 的项表示需要手动创建这个页面 )：</p></li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">键值</th><th style="text-align:left">设定值</th><th style="text-align:left">显示文本(简体中文)</th></tr></thead><tbody><tr><td style="text-align:left">home</td><td style="text-align:left">home: /</td><td style="text-align:left">主页</td></tr><tr><td style="text-align:left">archives</td><td style="text-align:left">archives: /archives</td><td style="text-align:left">归档页</td></tr><tr><td style="text-align:left">categories</td><td style="text-align:left">categories: /categories</td><td style="text-align:left">分类页 <code>*</code></td></tr><tr><td style="text-align:left">tags</td><td style="text-align:left">tags: /tags</td><td style="text-align:left">标签页 <code>*</code></td></tr><tr><td style="text-align:left">about</td><td style="text-align:left">about: /about</td><td style="text-align:left">关于页面 <code>*</code></td></tr><tr><td style="text-align:left">commonweal</td><td style="text-align:left">commonweal: /404.html</td><td style="text-align:left">公益 404 <code>*</code></td></tr></tbody></table></div><ul><li><p>设置菜单项的显示文本，在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用这个名称查找对应的语言翻译，并提取显示文本。</p><p>  这些翻译文本放置在 NexT 主题目录下的<code>languages/{language}.yml</code> （ {language} 为你所使用的语言 )。</p><p>  以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件<code>languages/zh-Hans.yml</code>，在<code>menu</code>字段下添加一项：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: 首页</span><br><span class="line">archives: 归档</span><br><span class="line">categories: 分类</span><br><span class="line">tags: 标签</span><br><span class="line">about: 关于</span><br><span class="line">search: 搜索</span><br><span class="line">commonweal: 404</span><br><span class="line">something: 有料</span><br></pre></td></tr></table></figure></li><li><p>设定菜单项的图标，对应的字段是<code>menu_icons</code>。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">menu_icons:</span><br><span class="line"><span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line"><span class="comment"># Icon Mapping.</span></span><br><span class="line">home: home</span><br><span class="line">about: user</span><br><span class="line">categories: th</span><br><span class="line">tags: tags</span><br><span class="line">archives: archive</span><br><span class="line">commonweal: heartbeat</span><br><span class="line"></span><br><span class="line"><span class="comment">#  此设定格式是「item name: icon name」</span></span><br><span class="line"><span class="comment"># 「item name」与上一步所配置的菜单名字对应</span></span><br><span class="line"><span class="comment"># 「icon name」是 Font Awesome 图标的名字</span></span><br><span class="line"><span class="comment"># 「enable」用于控制是否显示图标，你可以设置成「false」来去掉图标</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>设置侧栏 </p><p>  可以通过修改<code>主题配置文件</code>中的<code>sidebar</code>字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。</p><ul><li><p>设置侧栏的位置，修改 sidebar.position 的值，支持的选项有：</p><blockquote><p>left - 靠左放置<br>right - 靠右放置  </p></blockquote><p> 目前仅 Pisces Scheme 支持 position 配置。影响版本5.0.0及更低版本。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sidebar:  </span><br><span class="line">position: left</span><br></pre></td></tr></table></figure></li><li><p>设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有：</p><blockquote><p>post - 默认行为，在文章页面（ 拥有目录列表 ）时显示<br>always - 在所有页面中都显示<br>hide - 在所有页面中都隐藏（ 可以手动展开 ）<br>remove - 完全移除  </p></blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">display: post</span><br></pre></td></tr></table></figure><p> 已知侧栏在 use motion: false 的情况下不会展示。影响版本5.0.0及更低版本。</p></li></ul></li><li><p>设置头像</p><p>  编辑<code>主题配置文件</code>， 修改字段<code>avatar</code>，值设置成头像的链接地址。其中，头像的链接地址可以是：</p><ul><li><p>站外链接</p><blockquote><p>avatar: <a href="http://example.com/avatar.png" target="_blank" rel="noopener">http://example.com/avatar.png</a></p></blockquote></li><li><p>站内资源 </p><blockquote><p>放置在「source/images/」目录下，images 为自建目录<br>avatar: avatar: /images/avatar.png</p></blockquote></li></ul></li></ul><h3 id="揽收实用插件"><a href="#揽收实用插件" class="headerlink" title="揽收实用插件"></a>揽收实用插件</h3><h2 id="叁-参考资料"><a href="#叁-参考资料" class="headerlink" title="叁 参考资料"></a>叁 参考资料</h2><p><a href="https://hexo.io/docs/" target="_blank" rel="noopener">[1] HexoJs. 使用文档. 2018</a><br><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">[2] NexT. 使用文档. 2018</a><br><a href="http://fontawesome.io/accessibility/" target="_blank" rel="noopener">[3] Dave Gandy. Font Awesome Accessibility</a><br><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53576018" target="_blank" rel="noopener">[4] 徐俊. 手把手教你搭建属于自己的博客. CSDN. 2017</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;Hexo\(^{[1]}\)，一个快速、简洁且高效的博客框架，若以个人博文为主导需求，它的强大毋庸置疑。    &lt;/p&gt;
&lt;p&gt;Hexo 支持 GitHub Flavored Markdown 的所有功能；且基于 Node.Js 所带来的超快生成速度，百页博文秒级渲染；开放性 API 以及丰富的插件等，即功能来得纯粹，不失个性化定制，上手容易且操作便捷。更重要的一点，它是开源的、免费的博客框架，数据保存在本地以及 Github 上，相信在众多博客产品中选择、博弈，相信 Hexo 的表现不会令你失望。&lt;/p&gt;
&lt;p&gt;对于 Hexo 的安装、使用教程尽量遵照官方使用文档的流程操作，而本文则将侧重于 Hexo 的优化体验、实用插件等方面的内容分享。&lt;/p&gt;
&lt;p&gt;若想了解详情可访问「&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo.io&lt;/a&gt;」。&lt;/p&gt;
    
    </summary>
    
      <category term="Project" scheme="http://www.kofes.cn/categories/Project/"/>
    
    
      <category term="hexo" scheme="http://www.kofes.cn/tags/hexo/"/>
    
  </entry>
  
</feed>
