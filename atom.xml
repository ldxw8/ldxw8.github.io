<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kofe</title>
  
  <subtitle>Reading / Project / Paper</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kofes.cn/"/>
  <updated>2019-08-04T17:43:28.837Z</updated>
  <id>http://www.kofes.cn/</id>
  
  <author>
    <name>Kofe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>论文 | 基于根因分析的报警聚类算法</title>
    <link href="http://www.kofes.cn/2019/08/root-cause-analysis-alarm-clustering.html"/>
    <id>http://www.kofes.cn/2019/08/root-cause-analysis-alarm-clustering.html</id>
    <published>2019-08-04T12:27:58.000Z</published>
    <updated>2019-08-04T17:43:28.837Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p>原文：Clustering intrusion detection alarms to support root cause analysis<br>作者：Klaus Julisch<br>来源：ACM Transactions on Information and System Security, 2003, 6(4):443-471.</p></div><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>系统出现故障时，运维人员一般先查看错误日志定位故障原因。</li><li>业务流量小、逻辑复杂度低时，应用出现故障时错误日志一般较少，运维人员根据错误日志迅速定位到问题。但随着业务逻辑的迭代，系统接入的依赖服务不断增多、引入的组件不断增多，当系统出现故障时，<code>错误日志的量级急剧增加</code>。极端情况下更甚出现 “疯狂报错” 的现象，这时错误日志的内容会存在 <code>相互掩埋</code>、<code>相互影响</code> 的问题，运维人员面对报错一时难以理清逻辑， 失去焦点，没能第一时间解决最核心问题。</li><li>若在报警流出现时，通过处理程序将报警进行聚类，整理出一段时间内的报警摘要。运维人员就可以在摘要信息的帮助下，先对当前的故障有一个大致的轮廓，再结合技术知识与业务知识定位故障的根本原因。</li><li>围绕上面描述的问题，以及对于报警聚类处理的分析假设，本文主要做了以下事情：  <ul><li><code>选定算法</code>：选定聚类算法，简单描述算法基本原理，并给出针对报警日志聚类的一种具体实现方案。  </li><li><code>验证算法</code>：在分布式业务服务的系统下构造了三种不同实验场景，验证了算法的效果，并且对算法的不足进行分析阐述。</li></ul></li></ul><a id="more"></a><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>我们希望这些泛化报警既要具有很强的概括性，同时尽可能地保留细节。这样运维人员在收到报警时，便能快速定位故障的大致方向，从而提高故障排查的效率。</li><li><p>对一段时间内的报警进行聚类处理，将具有相同根因的报警归纳为能够涵盖报警内容的泛化报警，最终形成仅有几条泛化报警的报警摘要，如图 1-1 所示。</p><p>  <img src="/images/illustration/Paper/2019/alarm-clustering_1-1.jpg" alt=""></p>  <center>图 1-1 通过聚类算法泛化报警日志</center></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>如图 1-2 所示，文章主要分三个部分阐述：提取报警特征、算法实现以及展示报警摘要。</li><li><p>首先，是根据根因分析提取报警关键特征，并生成报警信息的泛化层次结构。其次，则是从泛化层次结构中计算得不同报警对象之间的不相似度度量，以确定最具象化的泛化表示、最大程度涵盖原始报警集合的泛化层次结构。最后，经由聚类算法获得泛化报警簇群，以簇群代表某一类报警信息。</p><blockquote><p>聚类算法还涉及 <code>min_size</code> 与 <code>聚类停止条件</code> 的调参问题，详情见下文描述。</p></blockquote><p>  <img src="/images/illustration/Paper/2019/alarm-clustering_1-2.png" alt=""></p>  <center>图 1-2 文章的章节布局</center></li></ul><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="泛化初探"><a href="#泛化初探" class="headerlink" title="泛化初探"></a>泛化初探</h3><ul><li><p>将报警信息抽象表达、逐层分解，形成类似于 <code>树结构</code> 或者 <code>有向无环图</code> 的泛化层次结构。</p><p>  如图 1-3 所示，可将服务器的报警抽象为 “全部服务器 网络调用 故障”，也可以抽象为 “server_room_a 服务器 网络调用 产品信息获取失败” 和 “server_room_b 服务器 RPC 获取产品类型信息失败”。</p><blockquote><p>前者泛化范围较广、抽象层次较高，细节越少；后者包含的范围较小、抽象层次低，则包含的无用信息可能越多。当然不局限于一种层次关系，你也可以用其他层次的抽象来表达这个报警集群。</p></blockquote><p>  <img src="/images/illustration/Paper/2019/alarm-clustering_1-3.jpg" alt=""></p>  <center>图 1-3 服务器的报警泛化初探</center></li></ul><h3 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h3><ul><li>为了确定报警聚类泛化的程度，我们需要先了解一些定义：<ul><li><code>属性</code> ( Attribute )：构成报警日志的基本信息，如机器、环境、时间等，记作 $A_i$。</li><li><code>值域</code> ( Domain )：属性 $A_i$  的值域 ( 取值范围 )，记作 $Dom(A_i)$。</li><li><code>泛化层次结构</code> ( Generalization Hierarchy )：对于每个属性 $A_i$，都有一个对应的泛化层次结构，记作 $G_i$。</li><li><code>不相似度</code> ( Dissimilarity )：定义为 $d(\mathcal{a_1}, \mathcal{a_2})$。它接受两个报警 $\mathcal{a_1}$、$\mathcal{a_2}$ 作为输入，并返回一个数值量，表示这两个报警不相似的程度。当 $d(\mathcal{a_1}, \mathcal{a_2})$ 较小时，表示报警 $\mathcal{a_1}$ 和报警 $\mathcal{a_2}$ 越相似，相反越大则越不相似。为了计算不相似度，则需要用户预先定义好报警信息的 <code>泛化层次结构</code>。</li></ul></li><li><p>计算 $d(\mathcal{a_1}, \mathcal{a_2})$，我们先定义两个属性值的不相似度：令 $x_1$、$x_2$ 为 $\mathcal{a_1}$、$\mathcal{a_2}$ 某个属性 $A_i$ 的两个不同的值，$x_1、x_2 \in Dom(A_i)$。</p><ul><li><p>在属性 $A_i$ 的泛化层次结构 $G_i$ 中，通过一个公共点父节点 $p$ 连接 $x_1$、$x_2$ 的最短路径长度。$\delta(·,·)$ 表示两节点的最短路径长度，把它们累加起来以表示两个属性的不相似度。</p><script type="math/tex; mode=display">d(x_1, x_2) := \min \left\{ \delta(x_1, p) + \delta(x_2, p) \mid  p \in G_i, x1 \trianglelefteq p, x2 \trianglelefteq p\right\}\tag{1}</script><blockquote><p>举例：在图 1-3 的泛化层次结构中：<br>d(“Thrift”, “Pigeon”) = d(“RPC”, “Thrift”) + d(“RPC”, “Pigeon”) =  1 + 1 = 2  </p></blockquote></li><li><p>接下来把警报的所有属性都加入计算，累加报警的所有属性的不相似度，即可表示报警的不相似度。对于两个报警 $\mathcal{a_1}$、$\mathcal{a_2}$，其不相似度的计算公式为：</p><script type="math/tex; mode=display">d(\mathcal{a_1}, \mathcal{a_2}) :=   \sum_{i=1}^n d(\mathcal{a_1}[A_i], \mathcal{a_2}[A_i])\tag{2}</script><blockquote><p>举例：参考图 1-3 的泛化层次结构：<br>$\mathcal{a_1}$ = (“server_room_b-biz_tag-offline02”, “Thrift”)<br>$\mathcal{a_2}$ = (“server_room_a-biz_tag-online01”, “Pigeon”)  </p><p>$d(\mathcal{a_1}, \mathcal{a_2})$ =<br>d(“server_room_b-biz_tag-offline02”, “server_room_a-biz_tag-online01”) +<br>d(“Thrift”, “Pigeon”)  </p><p>$d(\mathcal{a_1}, \mathcal{a_2})$ =<br>d(“server_room_b-biz_tag-offline02”, “服务器”) +<br>d(“server_room_a-biz_tag-online01”, “服务器”) +<br>d(“RPC”, “Thrift”) +<br>d(“RPC”,  “Pigeon”)<br>= 2 + 2 + 1 + 1 = 6</p></blockquote></li></ul></li><li><p>对于某个报警聚类来说，我们如何获得既能够涵盖它的集合又有最具象化的泛化表示？回答问题前，我们预先完成一些定义：</p><ul><li>一个警报对象是 n 维属性空间 $dom(A_1) \times dom(A_2) … \times dom(A_n)$ 上的元组，记作 $\mathcal{X}_{i = 1}^{n} Dom(A_i)$。</li><li><p>我们用 $C$ 表示报警集合，$\mathbf{g}$ 是 $C$ 的一个泛化表示，满足 $\forall \mathcal{a} \in C, \mathcal{a} \trianglelefteq \mathcal{g}$。</p><blockquote><p>以报警集合 {“dx-trip-package-api02 Thrift get deal list error”, “dx-trip-package-api01 Thrift get deal list error”} 为例，<code>dx服务器 thrift调用 获取产品信息失败</code> 是一个泛化表示，<code>服务器 网络调用 获取产品信息失败</code> 也是一个泛化表示。</p></blockquote></li><li><p>定义 $d_i := d(\mathcal{g}, a_i), i = 1, 2$，$d_i$ 表示在警报 $a_i$ 中需要多少个属性即可让 $\mathcal{g}$ 泛化表示 $\mathcal{a_i}$。当 $d_1 + d_2$ 越小，$\mathcal{g}$ 从警报 $\mathcal{a_1}、\mathcal{a_2}$ 中获得泛化表示的步数越少，说明 $\mathcal{g}$ 对 $\mathcal{a_1}、\mathcal{a_2}$ 覆盖越充分。相反，当 $d_1 + d_2$ 越大，由于过于抽象或者未能有效捕获警报 $\mathcal{a_1}、\mathcal {a_2}$ 的详细信息，说明当前 $\mathcal{g}$ 的覆盖效果不好。</p></li><li><p>因此，明确我们的目标是计算得 <code>最小化的报警不相似度</code> 以获得 <code>最具象化的泛化表示</code>。为了解决这个问题，定义以下两个指标：</p><script type="math/tex; mode=display">\overline{d} (\mathcal{g}, \mathcal{C}) :=   1 / | \mathcal{C} |   \times \sum _{\mathcal{a} \in C} d (\mathcal{g}, \mathcal{a})\tag{3}</script><script type="math/tex; mode=display">H(C) := \min \left\{  \overline {d}(\mathcal{g} , C) \mid  \mathcal {g} \in \mathcal{X}_{i = 1}^{n} Dom(A_i),  \forall \mathcal {a} \in C : \mathcal{a} \trianglelefteq \mathcal{g}\right\} \tag{4}</script><blockquote><p>$H(C)$ 代表一个报警簇群 $C$ 的相异性度量，$\overline{d} (\mathcal{g}, \mathcal{C})$ 代表一个报警簇群的平均相异性度量。$H(C)$ 值最小时对应的 $\mathcal{g}$ 就是我们要找的最适合的泛化表示，我们称 $\mathcal{g}$ 为 $C$ 的覆盖。</p></blockquote></li></ul></li><li><p>基于以上的概念，将报警日志聚类问题定义为：</p><ul><li>定义 $L$ 为一个日志集合，$G_i(i = 1, 2, 3……n)$ 为属性 $A_i$ 的泛化层次结构，$\mathcal{min_size} \in \mathbb{N}$ 为一个预设的常量。</li><li><p>目标是找到一个 $L$ 的子集 $C$，簇群中元素数量满足 $|C| \geq \mathcal{min_size}$，且 $H(C)$ 值最小。</p><blockquote><p>$\mathcal{min_size}$ 是用来控制抽象程度的，即一个簇群至少包含的元素个数。若 $\mathcal{min_size}$ 与 $L$ 集合的大小一样，那么我们只能使用终极抽象了；若 $\mathcal{min_size} = 1$ ，则每个报警日志是它自己的抽象。</p></blockquote></li><li><p>找到一个聚类之后，我们可以去除这些元素，然后在 $L$ 剩下的集合里找其他的聚类。</p></li></ul></li><li><p>不幸的是，这是个 NP 完全问题 ( <a href="https://en.wikipedia.org/wiki/Clique_problem" target="_blank" rel="noopener">分团问题</a> )。因此论文 $^{[2]}$ 提出了一种启发式算法，该算法满足 $|C| \geq \mathcal{min_size}$，使 $H(C)$ 值尽量小 ( 并不一定要最小化的 $H(C)$  )。</p></li></ul><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li><p>启发式 Alarm-Clustering 算法：面向属性归纳的改进算法 (Attribute-oriented induction, AOI) $^{[3]}$。</p><blockquote><p><code>面向属性归纳的改进算法</code>：1) 对比经典的 AOI 算法更保守地概括属性；2) 使用了类似基于密度聚类的聚类终止条件。  </p></blockquote><ul><li><code>Step.01</code>: 算法假设所有的泛化层次结构 $G_i$ 都是树，这样每个报警集群都有一个唯一的、最顶层的泛化结果。</li><li><code>Step.02</code>: 将 $L$ 定义为一个原始的报警日志集合，算法选择一个属性 $A_i$，将 $L$ 中所有报警的 $A_i$ 值替换为 $G_i$ 中 $A_i$ 的父值，通过这一操作不断对报警进行泛化。</li><li><code>Step.03</code>: 持续步骤 2 的操作，直到找到至少可以将原始报警泛化为报警簇群的最小值  $\mathcal{min_size}$。</li><li><code>Step.04</code>: 输出步骤 3 中找到的报警。</li></ul></li><li><p>算法的伪代码描述： </p><ul><li><code>Input</code>：(报警日志集合 $L$，$\mathcal{min_size}$，每个属性的泛化层次结构 $G_1、…、G_n$)</li><li><p><code>Output</code>：(泛化报警日志集合 $L$，$\mathcal{min_size}$，每个属性的泛化层次结构 $G_1、…、G_n$)</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* 将报警日志集合 L 保存至表 <span class="literal">T</span>，且表中每一列代表报警的一项属性 Ai */</span><br><span class="line"><span class="literal">T</span> := L</span><br><span class="line"></span><br><span class="line">/* count 是统计当前报警记录数量的变量 (可理解为报警簇群的大小)</span><br><span class="line"> * count 初始化为 <span class="number">1</span> 可理解为当前报警为一个仅且包含它本身的簇群 */</span><br><span class="line"><span class="keyword">for</span> all alarms a <span class="keyword">in</span> <span class="literal">T</span> do a[count] = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">/* 开始对报警进行泛化操作 */</span><br><span class="line"><span class="keyword">while</span> ∀a∈<span class="literal">T</span>:a[count] &lt; min_size do &#123;</span><br><span class="line"></span><br><span class="line">// Step.1 使用启发算法选择一个属性 Ai</span><br><span class="line"></span><br><span class="line">// Step.2 对 L 中所有报警进行泛化：</span><br><span class="line">// 即把报警的属性 Ai 替换为泛化层次结构 Gi 中 Ai 的父值</span><br><span class="line"><span class="keyword">for</span> all alarms a <span class="keyword">in</span> <span class="literal">T</span> do &#123;</span><br><span class="line">a[Ai] := parent of a[Ai] <span class="keyword">in</span> Gi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Step.3 如果 a[Ai] == a’[Ai], i = <span class="number">1</span>, <span class="number">2</span>, <span class="keyword">...</span>, n</span><br><span class="line">// 即报警的所有属性 Ai 都相同</span><br><span class="line"><span class="keyword">while</span> identical alarms a, a<span class="string">' exist do &#123;</span></span><br><span class="line"><span class="string">// 合并相同警报于同一个泛化报警 a 中并更新泛化警报的计数</span></span><br><span class="line"><span class="string">Set a[count] := a[count] + a'</span>[count];</span><br><span class="line">// 完成统计后移除报警记录 a<span class="string">'</span></span><br><span class="line"><span class="string">Delete a'</span> from <span class="literal">T</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="启发式选择属性泛化报警"><a href="#启发式选择属性泛化报警" class="headerlink" title="启发式选择属性泛化报警"></a>启发式选择属性泛化报警</h4><blockquote><p>其中第 11 行的启发算法为:</p></blockquote><ul><li><p>统计在 $A_i$ 属性上值为 $v$ 的报警的数量，记作 $f_i(v)$：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fi(v) := <span class="keyword">SELECT</span> <span class="keyword">sum</span>(<span class="keyword">count</span>) <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> Ai = v</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>让 $F_i$ 记作每个属性 $A_i$ 的最大值函数 ：</p><script type="math/tex; mode=display">  F_i := \max \left\{      f_i(v) | v \in Dom(A_i)  \right\} \tag{5}</script></li><li><p>这里的逻辑是：</p><ul><li>若有一个报警 $\mathcal{a}$ 满足 $\mathcal{a}[count] \geq \mathcal{min_size}$，那么对于所有属性 $A_i$ 均能满足 $F_i \geq f_i(\mathcal{a}[A_i]) \geq \mathcal{min_size}$。</li><li><p>相反，如果有一个属性 $A_i$ 的 $F_i &lt; \mathcal{min_size}$，那么 $\mathcal{a}[count]$ 就不可能大于 $\mathcal{min_size}$。所以选择 $F_i$ 值最小的属性 $A_i$ 进行泛化。</p><blockquote><p>类似于木桶定律，装水量由最短的木板决定。</p></blockquote></li></ul></li></ul><h4 id="DAG-形式的泛化层次结构"><a href="#DAG-形式的泛化层次结构" class="headerlink" title="DAG 形式的泛化层次结构"></a>DAG 形式的泛化层次结构</h4><ul><li><p>当泛化层次结构是一个有向无环图 (Directed Acyclic Graph, DAG)，而不是一颗树时，结构上的任何一个节点都有可能包含多个父节点，那么一个属性值存在多个父节点将其泛化。</p><p>  针对此问题，基于经典的 AOI 提出两种解决策略：</p></li><li><p><code>选择其一法</code>：基于用户定义的规则解决歧义问题。例如，考虑运行在同一 IP 下的 HTTP 服务器和 FTP 服务器，我们通过附加端口值进行准确泛化。</p>  <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a[Destination-port] = <span class="number">80</span></span><br><span class="line">then generalize ip to HTTP-server </span><br><span class="line"><span class="keyword">else</span> generalize ip to FTP-server;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>探索所有法</code>：并行地探索所有可能的泛化结果 (穷举法)。改写上述代码 16 行即可实现：</p>  <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Step.2 对 L 中所有报警进行泛化</span><br><span class="line"><span class="keyword">for</span> all alarms a <span class="keyword">in</span> <span class="literal">T</span> do &#123;</span><br><span class="line"><span class="literal">T</span> := <span class="literal">T</span> \ &#123;a&#125;;</span><br><span class="line">// 由属性 Ai 泛化报警的所有可能性都加入 <span class="literal">T</span> 中</span><br><span class="line"><span class="keyword">for</span> all parents p that a[Ai] has <span class="keyword">in</span> Gi do &#123;</span><br><span class="line">a<span class="string">' := a; </span></span><br><span class="line"><span class="string">a'</span>[Ai] := p; </span><br><span class="line"><span class="literal">T</span> := <span class="literal">T</span> ∪ &#123;a<span class="string">'&#125;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="MINSIZE-参数自适应算法"><a href="#MINSIZE-参数自适应算法" class="headerlink" title="MINSIZE 参数自适应算法"></a>MINSIZE 参数自适应算法</h4><ul><li>此外，关于 $\mathcal{min_size}$ 的选择，如果选择了一个过大的 $\mathcal{min_size}$，那么会迫使算法合并具有不同根源的报警。另一方面，如果过小，那么聚类可能会提前结束，具有相同根源的报警可能会出现在不同的聚类中。</li><li>因此，设置一个初始值，可以记作 $ms_0$。定义一个较小的值 $\varepsilon (0 &lt; \varepsilon &lt; 1)$，当 $\mathcal{min_size}$ 取值为 $ms_0$、$ms_0 \times (1 - \varepsilon )$、$ms_0 \times (1 + \varepsilon )$ 时的聚类结果相同时，我们就说此时聚类是 $ \varepsilon$-鲁棒的。</li><li><p>如果不相同，则使 $ms_1 = ms_0 * (1 - \varepsilon)$，重复这个测试，直到找到一个鲁棒的最小值。</p><blockquote><p>需要注意的是，$ \varepsilon$-鲁棒性与特定的报警日志相关。因此，给定的最小值，可能相对于一个报警日志来说是鲁棒的，而对于另一个报警日志来说是不鲁棒的。</p></blockquote></li></ul><h2 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h2><h3 id="提取报警特征"><a href="#提取报警特征" class="headerlink" title="提取报警特征"></a>提取报警特征</h3><ul><li>根据线上问题排查的经验，运维人员通常关注的指标包括时间、机器 ( 机房、环境 )、异常来源、报警日志文本提示、故障所在位置 ( 代码行数、接口、类 )、Case 相关的特殊 ID ( 订单号、产品编号、用户ID ) 等。</li><li>在本案例中，实际应用场景都是线上准实时场景，时间间隔短，因此我们不需要关注时间指标；同时，Case 相关的特殊 ID 不符合抽象描述的要求，因此也无需关注此项指标。</li><li>综上所述，我们选择的特征包括：<code>机房</code>、<code>环境</code>、<code>异常来源</code>、<code>报警日志文本摘要</code>、<code>故障所在位置</code> ( 接口、类 )。</li></ul><h3 id="提取关键特征"><a href="#提取关键特征" class="headerlink" title="提取关键特征"></a>提取关键特征</h3><blockquote><p>我们的数据来源是日志中心已经格式化过的报警日志信息，这些信息主要包含：报警日志产生的时间、服务标记、在代码中的位置、日志内容等。在定义泛化层次结构前夕，我们需要从已知的数据源中梳理出关键特征。</p></blockquote><ul><li><code>机房和环境</code>：提取这两个指标比较简单，在此不做详细赘述。</li><li><code>异常来源</code>：获得故障所在位置后，优先使用此信息确定异常报警的来源；若不能获取，则在日志内容中根据关键字匹配。需要说明的是，两者都需要预先定义词典支持。</li><li><code>报警日志文本摘要</code>：优先查找日志内容中是否有异常堆栈，若存在，则查找最后一个异常 ( 通常为真正的故障原因 )；若不能获取，则在日志中查找是否存在 “code=……, message=……” 这样形式的错误提示；若不能获取，则取日志内容的第一行内容 ( 以换行符为界 )，并去除其中可能存在的 Case 相关的提示信息。</li><li><code>故障所在位置</code>：优先查找是否有异常堆栈，如存在则查找第一个本地代码的位置； 若不存在，则取日志打印位置。</li></ul><h3 id="泛化层次结构"><a href="#泛化层次结构" class="headerlink" title="泛化层次结构"></a>泛化层次结构</h3><ul><li>泛化层次结构，用于记录属性的泛化关系，是泛化时向上抽象的依据，需要预先定义。</li><li><p>根据实验所用项目的实际使用环境，根据 <code>关键特性</code> 定义的 <code>泛化层次结构</code> 如下：</p><p>  <img src="/images/illustration/Paper/2019/alarm-clustering_1-4.png" alt=""></p>  <center>图 1-4 机房泛化层次结构</center><p>  <img src="/images/illustration/Paper/2019/alarm-clustering_1-5.png" alt=""></p>  <center>图 1-5 环境泛化层次结构</center><p>  <img src="/images/illustration/Paper/2019/alarm-clustering_1-6.png" alt=""></p>  <center>图 1-6 异常来源的泛化层次结构</center><p>  <img src="/images/illustration/Paper/2019/alarm-clustering_1-7.png" alt=""></p>  <center>图 1-7 报警日志文本摘要的泛化层次结构</center></li><li><p><code>故障所在位置</code> 此属性无需泛化层次结构，每次泛化时直接按照包路径向上层截断，直到系统包名。</p></li></ul><h3 id="报警聚类算法"><a href="#报警聚类算法" class="headerlink" title="报警聚类算法"></a>报警聚类算法</h3><ul><li><p>算法的执行流程，我们以图 1-8 来表述：</p><p>  <img src="/images/illustration/Paper/2019/alarm-clustering_1-8.png" alt=""></p>  <center>图 1-8 报警日志聚类流程图</center></li><li><p><code>min_size</code> 参数设定：考虑到日志数据中可能包含种类极多，且根据小规模数据实验表明，$\mathcal{min_size} = \frac15 \times$ 报警日志数量时，算法已经有较好的表现，再高会增加过度聚合的风险，因此我们取 $\mathcal{min_size} = \frac15 \times$ 报警日志数量，$\varepsilon$ 参考论文中的实验取 0.05。</p></li><li><p><code>聚类停止条件</code>：考虑到部分场景下，报警日志可能较少，因此 min_size 的值也较少，此时聚类已无太大意义，因此设定聚类停止条件为：聚类结果的报警摘要数量小于等于 20 或已经存在某个类别的 count 值达到 min_size 的阈值，即停止聚类。</p></li></ul><h2 id="延伸探究"><a href="#延伸探究" class="headerlink" title="延伸探究"></a>延伸探究</h2><ul><li><p>在论文中，警报 $\mathcal{a_x}$、$\mathcal{a_y}$ 的不相似度量定义为 $d(\mathcal{a_x}, \mathcal{a_y}) := \sum_{i=1}^n d(\mathcal{a_x}[A_i], \mathcal{a_y}[A_i])$，$d(·,·)$ 即把警报 a 中每个属性的不相似度量累加起来。</p><blockquote><p>在现实条件下，警报对象包含的属性值理应是有主次、重要性之分。我们计算警报的不相似度，具体计算不同的属性的不相似度时，是否考虑加入权重计算系统。</p></blockquote></li><li><p>关于泛化层次结构的表现形式包括 <code>有向无环图</code> 和 <code>树</code>。针对有向无环图形式的泛化层次结构，一个结构节点可能存在多个父节点，即一个属性值存在多个父节点将其泛化，故论文基于经典的 AOI 提出两种解决策略，以准确地选择唯一父节点去泛化报警。</p><p>  首先，是结合领域知识的 <code>选择其一法</code>，满足基本要求但需要人为因素干预。而现在问题是，若采取 <code>探索所有法</code> 将所有的泛化报警都加入集合 T 中，然而存在重复加入泛化报警的可能性，那么由原始方法构建簇群将是不正确的 (上述伪代码 23 行)。</p><blockquote><p>原论文描述解决办法：重新扫描原始警报日志，并确定与之匹配的原始警报的数量？细节和意图不明确，是否有替代方案？</p></blockquote></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://tech.meituan.com/2019/02/28/root-clause-analysis.html" target="_blank" rel="noopener">美团技术团队. 根因分析初探：一种报警聚类算法在业务系统的落地实施. 2019. tech.meituan.com</a></li><li>[2] Julisch K . Clustering intrusion detection alarms to support root cause analysis[J]. ACM Transactions on Information and System Security, 2003, 6(4):443-471.</li><li>[3] Jiawei Han 等著; 范明等译. 数据挖掘:概念与技术 (原书第3版) [M]. 机械工业出版社., 2012. 111-116.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;原文：Clustering intrusion detection alarms to support root cause analysis&lt;br&gt;作者：Klaus Julisch&lt;br&gt;来源：ACM Transactions on Information and System Security, 2003, 6(4):443-471.&lt;/p&gt;&lt;/div&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;系统出现故障时，运维人员一般先查看错误日志定位故障原因。&lt;/li&gt;
&lt;li&gt;业务流量小、逻辑复杂度低时，应用出现故障时错误日志一般较少，运维人员根据错误日志迅速定位到问题。但随着业务逻辑的迭代，系统接入的依赖服务不断增多、引入的组件不断增多，当系统出现故障时，&lt;code&gt;错误日志的量级急剧增加&lt;/code&gt;。极端情况下更甚出现 “疯狂报错” 的现象，这时错误日志的内容会存在 &lt;code&gt;相互掩埋&lt;/code&gt;、&lt;code&gt;相互影响&lt;/code&gt; 的问题，运维人员面对报错一时难以理清逻辑， 失去焦点，没能第一时间解决最核心问题。&lt;/li&gt;
&lt;li&gt;若在报警流出现时，通过处理程序将报警进行聚类，整理出一段时间内的报警摘要。运维人员就可以在摘要信息的帮助下，先对当前的故障有一个大致的轮廓，再结合技术知识与业务知识定位故障的根本原因。&lt;/li&gt;
&lt;li&gt;围绕上面描述的问题，以及对于报警聚类处理的分析假设，本文主要做了以下事情：  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;选定算法&lt;/code&gt;：选定聚类算法，简单描述算法基本原理，并给出针对报警日志聚类的一种具体实现方案。  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;验证算法&lt;/code&gt;：在分布式业务服务的系统下构造了三种不同实验场景，验证了算法的效果，并且对算法的不足进行分析阐述。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Paper" scheme="http://www.kofes.cn/categories/Paper/"/>
    
    
      <category term="数据挖掘" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="聚类" scheme="http://www.kofes.cn/tags/%E8%81%9A%E7%B1%BB/"/>
    
      <category term="根因分析" scheme="http://www.kofes.cn/tags/%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>框架 | Django 框架入门到应用</title>
    <link href="http://www.kofes.cn/2019/02/Django.html"/>
    <id>http://www.kofes.cn/2019/02/Django.html</id>
    <published>2019-02-17T14:44:07.000Z</published>
    <updated>2019-02-21T13:29:36.026Z</updated>
    
    <content type="html"><![CDATA[<p>Django 是基于 MVC 模式，由 Python 写成的开源 Web 应用框架。在 Django 中，控制器接受用户输入的部分由框架自行处理，而 Django 里更关注的是模型 ( Model )、模板 ( Template ) 和视图 ( Views )，为此也称其为 MTV 模式的 Web 框架。</p><p>当然，基于 Python 的 Web 框架不仅这一家，如  flask、tornado、web2py 等。而任何一款框架的产生都有自身的亮点和缺陷 $^{[2, 3]}$，综合自我诉求、性能要求等诸多因素考量，选择适合的框架即可。在本次开发中，我们只需要一款数据库驱动的内容发布与管理系统，而 Django 的中间件 <a href="https://baike.baidu.com/item/对象关系映射" target="_blank" rel="noopener">ORM</a> 设计，使得我们在具体操作业务对象时，不需要和复杂的 SQL 语句打交道，只要像平时操作对象一样操作即可。为此，本着轻量开发的原则选择了 Django。</p><a id="more"></a><h2 id="教学资源"><a href="#教学资源" class="headerlink" title="教学资源"></a>教学资源</h2><ul><li>📺 | 视频 | <a href="https://www.bilibili.com/video/av22606568/?p=3" target="_blank" rel="noopener">老男孩.Python 全栈: Django 框架入门到应用. 2018. bilibili.com</a></li><li>📄 | 文章 | <a href="https://docs.djangoproject.com/zh-hans/2.1/" target="_blank" rel="noopener">Django.Django 快速入门&amp;中文使用文档. djangoproject.com</a></li></ul><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><ul><li><p>安装：命令行模式安装 ( Mac / Linux 用户注意管理员权限 )</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install django</span><br><span class="line">pip install django == x.xx.xx</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>配置：配置 Django 项目并初次启动它。</p><ul><li><p>创建项目：可通过命令模式启动项目 ( 多用于部署环境 )，也可通过 PyCharm 启动、运行项目。</p><ul><li>命令模式：<code>django-admin startproject mysite</code></li><li><p>PyCharm：通过 PyCharm 一步到位，即 <code>新建工程 &gt; Django &gt; ( 建立单独的 Venv ) &gt; mysite</code>。</p><blockquote><p>Virtualenv：为一个应用创建一套“隔离”的 Python 运行环境，具体配置方法可参考 [1]。</p></blockquote></li></ul></li><li><p>项目目录结构说明</p><ul><li><code>mysite</code>：同名目录，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名，比如 mysite.urls。</li><li><code>__init__.py</code>：空文件，标识这个目录应识别为 Python 包。</li><li><code>settings.py</code>：Django 的项目配置文件。</li><li><code>urls.py</code>：Django 项目的 URL 声明。</li><li><code>wsgi.py</code>：Web 服务网关接口 ( Socket )。</li><li><p><code>manage.py</code>：对网络所有管理是通过其来实现的。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysite</span><br><span class="line">  ├─── mysite</span><br><span class="line">  │ ├── init__.py</span><br><span class="line">  │ ├── settings.py</span><br><span class="line">  │ ├── urls.py</span><br><span class="line">  │ ├── wsgi.gy</span><br><span class="line">  └─── manage.py</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>使用：以命令模式启动本地服务器为例，当然可以使用 Pycharm 一键运行。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver 127.0.0.1:8000</span><br></pre></td></tr></table></figure></li></ul><h3 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h3><h4 id="返回内容至页面"><a href="#返回内容至页面" class="headerlink" title="返回内容至页面"></a>返回内容至页面</h4><p>返回内容 ( Html 元素或对象 ) 至页面，代码应包含在 <code>urls.py</code> 文件中。</p><ul><li><p>下述是返回字符串或 Html 元素的示例代码：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">arguments:</span></span><br><span class="line"><span class="string">@param request 放置用户请求相关的所有信息</span></span><br><span class="line"><span class="string">@return 响应与返回处理结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="comment"># 1. 可返回字符串</span></span><br><span class="line"><span class="keyword">return</span> HttpResponse(<span class="string">"Hello World!"</span>)</span><br><span class="line"><span class="comment"># 2. 可返回 Html 元素 (对象)</span></span><br><span class="line"><span class="comment"># return HttpResponse("&lt;input type='text' /&gt;")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 Site 根目录</span></span><br><span class="line">urlpatterns = [ url(<span class="string">''</span>, info), ]</span><br></pre></td></tr></table></figure></li></ul><h4 id="返回独立-Html-页面"><a href="#返回独立-Html-页面" class="headerlink" title="返回独立 Html 页面"></a>返回独立 Html 页面</h4><p>返回独立 Html 页面，且尝试把数据返回到页面中。</p><ul><li>Html 页面放置 <code>tempates</code> 目录下；</li><li><p><code>settings.py</code> 中配置模板的路径 ( 告诉程序网页模板在哪个目录下 )；</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line"><span class="string">'DIRS'</span>: [os.path.join(BASE_DIR, <span class="string">'templates'</span>)]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>urs.py</code> 中加入调用代码，绑定请求地址与处理函数；</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># render 能抓取页面全部信息 ( 它也调用了 HttpResponse )</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'info.html'</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>若要引用资源目录，如存放 images、css 等，则需要在 <code>settings.py</code> 中加入声明语句。</p><p>  引用资源时，需要加入 <code>static</code>。例如 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;static/style.css&quot;&gt;</code>。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STATIC_URL = <span class="string">'/static/'</span></span><br><span class="line">STATICFILES_DIRS = (</span><br><span class="line">    <span class="comment"># '文件名' 是自由命名的，这里取 'static' 是为了统一命名</span></span><br><span class="line">    os.path.join(BASE_DIR, <span class="string">'static'</span>), </span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h3 id="简单登录功能"><a href="#简单登录功能" class="headerlink" title="简单登录功能"></a>简单登录功能</h3><blockquote><p>本实例主要展示的是，在 Django 框架下 Web 前后端的交互过程。</p></blockquote><ul><li><p>首先，我们在 <code>urls.py</code> 中配置路由关系，并绑定路由触发的函数以实现功能。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse, render, redirect</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首次加载页面调用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="comment"># GET 可通过请求的链接地址传参，如 url?page=1</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'GET'</span> == request.method):</span><br><span class="line"><span class="comment">## render() 是抓取页面全部信息 ( 它也调用了 HttpResponse )</span></span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">'login.html'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录成功后把数据回传到目标页面</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">user = request.POST</span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">'index.html'</span>, &#123;</span><br><span class="line"><span class="string">'username'</span>: str(user.get(<span class="string">'username'</span>)),</span><br><span class="line"><span class="string">'password'</span>: &#123;</span><br><span class="line"><span class="string">'origin'</span>: user.get(<span class="string">'password'</span>),</span><br><span class="line"><span class="string">'encode'</span>: base64.b64encode( (user.get(<span class="string">'password'</span>) + user.get(<span class="string">'password'</span>)).encode(<span class="string">'utf-8'</span>) )</span><br><span class="line">&#125;&#125;</span><br><span class="line">)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># path(相对地址, 调用函数)，如请求地址为根目录，故这里填写 '' </span></span><br><span class="line">urlpatterns = [ </span><br><span class="line">    path(<span class="string">''</span>, login), </span><br><span class="line">    path(<span class="string">'index'</span>, index), </span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>最后附上相关联的 <code>login.html</code> 和 <code>index.html</code>。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- login.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Information Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"static/css/style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Welcome to use the exhibation page.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">"login"</span> <span class="attr">type</span>=<span class="string">"submit"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Home Index<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"static/css/style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1. 模板中接受函数体返回的属性 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &#123;&#123;&#125;&#125; 特殊占位符: Django render() 会自动解析它 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>username<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> &#123;&#123; username &#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>password<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> &#123;&#123; password.origin &#125;&#125; =&gt; &#123;&#123; password.encode &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="comment">&lt;!-- 换行 --&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2. 模板中调用对象的方法和属性，例如循环体 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">&#123;% for key, value in password.items %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Password:&#123;&#123; key &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="增删改查系统"><a href="#增删改查系统" class="headerlink" title="增删改查系统"></a>增删改查系统</h3><blockquote><p>本实例主要展示的是 Python 与数据库的交互过程。</p></blockquote><h4 id="建立数据表"><a href="#建立数据表" class="headerlink" title="建立数据表"></a>建立数据表</h4><p>数据关系：这里以学生 ( Student )、任教老师 ( Teacher ) 和课程 ( Course ) 三个实体为例，构建数据表。</p><ul><li>ER 图，如图 4-1 所示：<ul><li>学生可以选修多门课程，一门课程可以多个学生参与，即多对多关系。</li><li>老师只能任教一门课程，但是一门课程有多个老师开课，即一对多关系。</li></ul></li></ul><p><img src="/images/illustration/Programme/2019/02/django_1-1.jpg" alt="django_1-1"></p><center>图 1-1 演示数据库的数据关系</center><ul><li>关系模式：<ul><li>学生实体(学生序号, 学生姓名) == t_student(_sid_, name)</li><li>课程实体(课程序号, 课堂名称) == t_course(_cid_, name)</li><li>老师实体(老师序号, 老师姓名) == t_teacher(_tid_, name, cid)</li><li>选课关系(学生序号, 课程序号, 成绩) == Student2Course(_sid_, _cid_, score)</li></ul></li></ul><h4 id="前-后端交互原理"><a href="#前-后端交互原理" class="headerlink" title="前 / 后端交互原理"></a>前 / 后端交互原理</h4><ul><li>Web 程序的前后端交互原理如图 4-2 所示。</li></ul><p><img src="/images/illustration/Programme/2019/02/django_1-2.jpg" alt="django_1-2"></p><center>图 1-2 Web 程序的前后端交互原理</center><h4 id="原生代码操作数据"><a href="#原生代码操作数据" class="headerlink" title="原生代码操作数据"></a>原生代码操作数据</h4><ul><li>Python 的 MySQL 驱动有 <code>MySQLdb</code>、<code>PyMySQL</code> 以及 <code>MySQLClient</code>。</li><li><p>在 Python 2.7 版本，主要是用 MySQLdb，而 Python 3.x 版本多数使用 PyMySQL 以及 MySQLClient。两者操作风格类似，本文则以 PyMySQL 展开探讨。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 封装连接数据库的信息</span></span><br><span class="line">db_infos = &#123;</span><br><span class="line"><span class="string">'host'</span>: <span class="string">"IP 地址"</span>,</span><br><span class="line"><span class="string">'port'</span>: <span class="number">3306</span>,</span><br><span class="line"><span class="string">'user'</span>: <span class="string">"数据库账户"</span>,</span><br><span class="line"><span class="string">'password'</span>: <span class="string">"数据库密码"</span>,</span><br><span class="line"><span class="string">'db'</span>: <span class="string">"数据库名称"</span>,</span><br><span class="line"><span class="string">'charset'</span>: <span class="string">"utf8"</span>,</span><br><span class="line"><span class="string">'cursorclass'</span>: pymysql.cursors.DictCursor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">db = pymysql.connect(db_infos)</span><br><span class="line"></span><br><span class="line">SQL = <span class="string">"SELECT * FROM t_student"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">with</span> db.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">cursor.excute(SQL) <span class="comment"># 执行 SQL 语句</span></span><br><span class="line">db.commit() <span class="comment"># 提交修改数据请求</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">db.rollback() <span class="comment"># 回滚</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">db.close() <span class="comment"># 关闭数据库连接</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Ajax-方式交互数据"><a href="#Ajax-方式交互数据" class="headerlink" title="Ajax 方式交互数据"></a>Ajax 方式交互数据</h4><ul><li><p>借助 Ajax，实现数据的本地刷新，而不需要重新加载、渲染网页。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'提交地址'</span>,</span><br><span class="line">    type: <span class="string">'POST'</span> <span class="comment">// POST / GET</span></span><br><span class="line">    data: &#123;<span class="string">'key_1'</span>: <span class="string">'value_1'</span>, ..., <span class="string">'key_n'</span>: <span class="string">'value_n'</span> &#125;</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 当前服务端处理数据，自动执行回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="框架正文"><a href="#框架正文" class="headerlink" title="框架正文"></a>框架正文</h2><p>本章节的内容参考 <a href="https://docs.djangoproject.com/zh-hans/2.1/" target="_blank" rel="noopener">Django 官方文档 v2.1</a> 整理所得，即把模型、模板和视图的概念更加细化，通过一个投票应用的实例以讲述如何搭建一个 <code>MTV模式</code> 的 Web 框架，如图 3-1 所示。</p><p><img src="/images/illustration/Programme/2019/02/django_2-1.jpg" alt="django_2-1"></p><center>图 2-1 MTV 模式的 Web 框架</center><h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><ul><li><p>编辑 <code>mysite/settings.py</code> 文件前，先设置 <a href="https://docs.djangoproject.com/zh-hans/2.1/ref/settings/#std:setting-TIME_ZONE" target="_blank" rel="noopener">TIME_ZONE</a> 为你自己时区，可参考 Wikipedia 的 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="noopener">List of time zones</a>。</p><blockquote><p>新建立的项目，默认时区为 <code>UTC</code>。</p></blockquote></li><li><p>打开 <code>mysite/settings.py</code>，通常这个配置文件使用 SQLite 作为默认数据库。</p><ul><li><code>ENGINE</code>：选值 <code>django.db.backends.sqlite3</code>。</li><li><p><code>NAME</code>：数据库的名称。若使用 <a href="https://baike.baidu.com/item/SQLite/375020?fr=aladdin" target="_blank" rel="noopener">SQLite</a>，数据库将是你电脑上的一个文件，NAME 应该是此文件的绝对路径 + 文件名，默认值 <code>os.path.join(BASE_DIR, &#39;db.sqlite3&#39;)</code> 将会把数据库文件储存在项目的根目录。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.sqlite3'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: os.path.join(BASE_DIR, <span class="string">'db.sqlite3'</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若使用了 SQLite 以外的数据库，请确认在使用前已经 <code>创建了数据库</code>。连接到其他数据库时 ( MySQL，Oracle 或 PostgreSQL )，参考 <a href="https://docs.djangoproject.com/zh-hans/2.1/ref/settings/#std:setting-DATABASE-ENGINE" target="_blank" rel="noopener">ENGINE</a> 的设置来连接其他数据库。例如连接 MySQL 的配置如下所示：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'mydatabase'</span>,</span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'mydatabaseuser'</span>,</span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'mypassword'</span>,</span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        <span class="string">'PORT'</span>: <span class="string">'3306'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>此外，关注一下文件头部的 <code>INSTALLED_APPS</code> 设置项。这里包括了项目中启用的所有 Django 应用。应用能在多个项目中使用，也可以打包并且发布应用，让别人使用它们。通常 INSTALLED_APPS 默认包括了以下 Django 的自带应用：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="comment"># 因为 ApplicationConfig 类写在文件 polls/apps.py 中，</span></span><br><span class="line">    <span class="comment"># 所以它的点式路径是 'polls.apps.ApplicationConfig'</span></span><br><span class="line">    <span class="string">'polls.apps.ApplicationConfig'</span>,<span class="comment"># 激活模型</span></span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,<span class="comment"># 管理员站点</span></span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,<span class="comment"># 认证授权系统</span></span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,<span class="comment"># 内容类型框架</span></span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,<span class="comment"># 会话框架</span></span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,<span class="comment"># 消息框架</span></span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,<span class="comment"># 管理静态文件的框架</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>默认开启的某些应用需要至少一个数据表，故在使用他们前需要在数据库中创建一些表。请执行命令：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> MacOS / Linux</span></span><br><span class="line">python manage.py migrate</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Windows ( 下述代码同理，基本上 <span class="string">"py"</span> 对应于 <span class="string">"python"</span> )</span></span><br><span class="line">py manage.py migrate</span><br></pre></td></tr></table></figure></li></ul><h3 id="模型和站点管理"><a href="#模型和站点管理" class="headerlink" title="模型和站点管理"></a>模型和站点管理</h3><h4 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h4><ul><li><p>定义模型 ( Model )，即数据库结构设计和附加的其它元数据。在 Django 中，你只需要定义数据模型，其中的实现代码不用理会，它们会自动从模型生成。</p><blockquote><p>模型是真实数据的简单明确的描述，它包含了储存的数据所必要的字段和行为。</p></blockquote></li><li><p>例如，在本案例中 ( 投票应用 )，需要创建两个模型：问题 Question 和选项 Choice。</p><ul><li>Question 模型：包括问题描述和发布时间。</li><li>Choice 模型：包括选项描述和当前得票数。每个选项属于一个问题 ( 一对一关系 )。</li></ul></li><li><p>这些概念可通过 Python 类来描述。按照下面的例子来编辑 <code>polls/models.py</code> 文件：</p><ul><li>每个模型被表示为 <code>django.db.models.Model</code> 类的子类。每个模型有一些类变量，它们都表示模型里的一个数据库字段。</li><li>每个字段都是 <code>Field</code> 类的实例，这将告诉 Django 每个字段要处理的数据类型。比如，字符字段被表示为 <code>CharField</code>，日期时间字段被表示为 <code>DateTimeField</code>。</li><li><p>定义某些 Field 类实例需要参数，例如 CharField 需要一个 max_length 参数。</p><blockquote><p>这个参数的用处不止于用来定义数据库结构，也用于验证数据。</p></blockquote></li><li><p>Django 支持所有常用的数据库关系：一对一、一对多和多对多，我们使用外键 <code>ForeignKey</code> 定义了一个关系。例如，每个 Choice 对象都关联到一个 Question 对象。</p></li><li><p>数据表最重要的 <code>主键</code> 会被自动创建，当然也可以自定义。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Question</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    question_text = models.CharField(max_ length=<span class="number">200</span>)</span><br><span class="line">    pub_date = models.DateTimeField(<span class="string">'date published'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Question.objects.all() 返回信息对我们用处不大，如下所示：</span></span><br><span class="line">    <span class="comment"># &lt;QuerySet [&lt;Question: Question object (1)&gt;]&gt;</span></span><br><span class="line">    <span class="comment"># 可尝试通过 __str__() 方法返回一些字段信息</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.question_text</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Choice</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    question = models.ForeignKey(Question, on_delete=models.CASCADE)</span><br><span class="line">    choice_text = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    votes = models.IntegerField(default=<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.choice_text</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="激活模型"><a href="#激活模型" class="headerlink" title="激活模型"></a>激活模型</h4><ul><li><p>从上述用于创建模型的代码可知，Django 可实现：</p><ul><li>为这个应用创建数据库 <code>schema</code> ( 生成 CREATE TABLE 语句 )。</li><li>创建与 Question 和 Choice 对象与数据库进行交互的 <code>API</code> ( Python 版本 )。</li></ul></li><li><p>但是首先得把 polls 应用安装到我们的项目里。具体地， 在文件 <code>mysite/settings.py</code> 中 <code>INSTALLED_APPS</code> 子项添加点式路径：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="comment"># 因为 ApplicationConfig 类写在文件 polls/apps.py 中，</span></span><br><span class="line">    <span class="comment"># 所以它的点式路径是 'polls.apps.ApplicationConfig'</span></span><br><span class="line">    <span class="string">'polls.apps.ApplicationConfig'</span>,<span class="comment"># 激活模型</span></span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,<span class="comment"># 管理员站点</span></span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,<span class="comment"># 认证授权系统</span></span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,<span class="comment"># 内容类型框架</span></span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,<span class="comment"># 会话框架</span></span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,<span class="comment"># 消息框架</span></span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,<span class="comment"># 管理静态文件的框架</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>现在你的 Django 项目会包含 polls 应用。接着通过运行 <code>makemigrations</code> 命令，Django 会检测你对模型文件的修改 ( 在这种情况下刚创建的可理解为最新修改的  )，并且把修改的部分储存为一次 <code>迁移</code>。</p><blockquote><p>迁移：Django 对于模型定义，也就是你的数据库结构的变化的储存形式。它们其实也只是一些你磁盘上的文件。</p></blockquote>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations polls</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Django 有一个自动执行 <code>数据库迁移</code> 并同步管理你的数据库结构的命令：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>当然，你是否会好奇，迁移是怎样的过程，迁移命令会执行哪些 SQL 语句？那么，<code>sqlmigrate</code> 命令接收一个迁移的名称，然后返回对应的 SQL。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sqlmigrate 命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 并没有真正在数据库中的执行迁移，它只是把命令输出到屏幕上</span></span><br><span class="line">python manage.py sqlmigrate polls 0001</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>输入以上命令，你将看到如下结果 ( 格式化输出 SQL )：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 输出示例使用的是 PostgreSQL / MySQL --</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- Create model Choice</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">"polls_choice"</span> (</span><br><span class="line">    <span class="string">"id"</span> <span class="built_in">serial</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="string">"choice_text"</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">"votes"</span> <span class="built_in">integer</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- Create model Question</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">"polls_question"</span> (</span><br><span class="line">    <span class="string">"id"</span> <span class="built_in">serial</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="string">"question_text"</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">"pub_date"</span> <span class="keyword">timestamp</span> <span class="keyword">with</span> <span class="keyword">time</span> zone <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 省略剩余语句，具体可自行测试 --</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li><li><p>从格式化的 SQL 语句可注意到：</p><ul><li><p>数据库的表名是由应用名 ( polls ) 和模型名的小写形式 ( question 和 choice ) 连接而来。</p></li><li><p>主键 ( id ) 会被自动创建，当然你也可以自定义。</p></li><li><p>默认 Django 会在外键字段名后追加字符串 “_id” ，同样也可以自定义。</p></li><li><p>生成的 SQL 语句是为你所用的数据库定制的，所以那些和数据库有关的字段类型，比如 auto_increment ( MySQL )、 serial ( PostgreSQL ) 和 integer primary key autoincrement ( SQLite )，Django 会帮你自动处理。那些和引号相关的事情，比如使用单引号还是双引号，也一样会被自动处理。</p></li></ul></li><li><p>总结：迁移是非常强大的功能，它能让你在开发过程中持续的改变数据库结构而不需要重新删除和创建表，即它专注于使数据库平滑升级而不会丢失数据。<strong>现在改变模型只需要记住这三步</strong>：</p><ul><li><p>编辑 <code>models.py</code> 文件，改变模型。</p></li><li><p>运行 <code>python manage.py makemigrations</code> 为模型的改变 <code>生成</code> 迁移文件。</p></li><li><p>运行 <code>python manage.py migrate</code> 来 <code>应用</code> 数据库迁移。</p></li></ul></li></ul><h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><ul><li>当完成 <code>创建模型</code> ( 定义数据实体和数据关系 ) 与 <code>激活模型</code> ( 模型驱动自动生成 SQL 代码 ) 的工作，即表明数据表已建立起来，紧接着便可操作数据库了。</li><li>关于操作数据库的 Python API 所有细节可在 <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/" target="_blank" rel="noopener">Database API For Python</a> 参考文档中找到。</li></ul><h5 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h5><ul><li><p>假设模型存在于文件中 mysite/polls/models.py：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> polls.models <span class="keyword">import</span> Choice, Question</span><br><span class="line"><span class="comment"># 使用模型类的关键字参数对其实例化，再调用 save() 以将其保存到数据库中</span></span><br><span class="line">q = Question(question_text=<span class="string">"What's new?"</span>, pub_date=timezone.now())</span><br><span class="line"><span class="comment"># 创建和保存对象则使用 create() 方法</span></span><br><span class="line">q.save()</span><br></pre></td></tr></table></figure></li></ul><h5 id="更新对象"><a href="#更新对象" class="headerlink" title="更新对象"></a>更新对象</h5><ul><li><p>UPDATE 在幕后执行 SQL 语句：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存对象的更改</span></span><br><span class="line">q.question = <span class="string">"What do you think about?"</span></span><br><span class="line">q.save()</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>保存 ForeignKey 字段：更新 ForeignKey 字段的工作方式与保存普通字段的方式完全相同，只需将正确类型的对象分配给相关字段即可。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般情况 pk ( Primary Key ) 和 id 是一样的，只有 id 不是主键时才不一样</span></span><br><span class="line">choice = Choice.objects.get(pk=<span class="number">1</span>)</span><br><span class="line">question = Question.objects.get(<span class="string">'What do you think about?'</span>)</span><br><span class="line">choice.question = question</span><br><span class="line">choice.save()</span><br></pre></td></tr></table></figure></li></ul><ul><li>更新ManyToManyField 工作的方式略有不同 ：使用 add() 字段上的方法向关系添加记录。</li></ul><h5 id="检索对象"><a href="#检索对象" class="headerlink" title="检索对象"></a>检索对象</h5><ul><li><p>使用 all() 返回所有对象：例如，返回 Question 数据库中所有对象。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_question = Question.objects.all()</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>使用过滤器检索特定对象</code>：若我们仅需要选择整个对象集的子集，则需要向 QuerySet 添加过滤条件。两种最常见的改进方法：</p><ul><li><code>filter(**kwargs)</code>：返回 QuerySet 包含与给定查找参数匹配的新对象。</li><li><p><code>exclude(**kwargs)</code>：返回 QuerySet 包含与给定查找参数不匹配的新对象。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如：获取 2018 年间所有问题记录</span></span><br><span class="line">Question.objects.filter(pub_date__year=<span class="number">2017</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>链接过滤器</code>：QuerySet 检索结果本身也是 QuerySet 对象，故可使用多个过滤器。作用与 <code>多条件查询</code> 类似效果。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如：获取以“What”开头，在 2018 年 1 月 1 日至当天前的所有记录</span></span><br><span class="line">Question.objects.filter(</span><br><span class="line">headline__startswith=<span class="string">'What'</span></span><br><span class="line">).exclude(</span><br><span class="line">pub_date__gte=datetime.date.today()</span><br><span class="line">).filter(</span><br><span class="line">pub_date__gte=datetime.date(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用 get() 检索单个对象：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one_question = Question.objects.get(pk=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># Question 没有主键为 1 的对象，Django 将引发异常 Entry.DoesNotExist。</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>限制 QuerySet 返回集合的大小：使用 Python 的数组切片语法将限制 QuerySet 为一定数量的结果。这相当于 SQL 中 <code>LIMIT</code> 和 <code>OFFSET</code> 子句。</p><ul><li>注意 1：<code>Entry.objects.all()[-1]</code> 不支持负索引。</li><li><p>注意 2：<code>Entry.objects.all()[:10:2]</code> 不支持使用步进 ( Step ) 取值。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如：返回前5个对象（）：LIMIT 5</span></span><br><span class="line">Question.objects.all()[:<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 例如：返回第6到第10个对象：OFFSET 5 LIMIT 5</span></span><br><span class="line">Question.objects.all()[<span class="number">5</span>:<span class="number">10</span>]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="站点管理"><a href="#站点管理" class="headerlink" title="站点管理"></a>站点管理</h4><h5 id="开篇引言"><a href="#开篇引言" class="headerlink" title="开篇引言"></a>开篇引言</h5><ul><li>相信你也有过同样的经历，例如为你的员工或客户生成一个用户添加、修改和删除内容的管理后台，即简单的增删改查操作 ( CRUD ) ，但它却是一项缺乏创造性和乏味的工作。因此，Django 全自动地根据模型创建界面化的管理后台。</li><li>管理界面不是为了网站的访问者，而是为管理者准备的。需要客制化的后台管理界面还需自行实现。</li></ul><h5 id="创建管理员账号"><a href="#创建管理员账号" class="headerlink" title="创建管理员账号"></a>创建管理员账号</h5><ul><li><p>首先，我们得创建一个能登录管理页面的用户。请运行下面的命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br><span class="line"><span class="comment"># Username: kofe</span></span><br><span class="line"><span class="comment"># Email address: kofe@example.com</span></span><br><span class="line"><span class="comment"># Password: **********</span></span><br><span class="line"><span class="comment"># Password (again): *********</span></span><br><span class="line"><span class="comment"># Superuser created successfully.</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="启动开发服务器"><a href="#启动开发服务器" class="headerlink" title="启动开发服务器"></a>启动开发服务器</h5><ul><li><p>Django 的管理界面默认就是启用的。让我们启动开发服务器。当然，你可以通过 PyCharm 启动服务器，也可以通过命令启动：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure></li><li><p>打开浏览器即可访问：<code>http://127.0.0.1:8000/admin/</code></p></li></ul><h5 id="管理页添加应用"><a href="#管理页添加应用" class="headerlink" title="管理页添加应用"></a>管理页添加应用</h5><ul><li><p>在索引页面中，我们并没有看到应用，如本例中的投票应用 <code>polls</code>。所以我们得告诉管理页面，问题 <code>Question</code> 对象需要被管理。打开 <code>polls/admin.py</code> 文件，把它编辑成下面这样：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line">admin.site.register(Question)</span><br></pre></td></tr></table></figure></li></ul><h3 id="模板和视图"><a href="#模板和视图" class="headerlink" title="模板和视图"></a>模板和视图</h3><h4 id="开篇引言-1"><a href="#开篇引言-1" class="headerlink" title="开篇引言"></a>开篇引言</h4><ul><li><p>每个视图必须要做的只有两件事：返回一个包含被请求页面内容的 <code>HttpResponse</code> 对象或者抛出一个 <code>异常</code>，比如 HTTP 404。</p><blockquote><p>Django 只要求返回的是一个 HttpResponse ，或抛出一个异常。</p></blockquote></li><li><p>视图可以从数据库里读取记录，可使用一个模板引擎 ( Django 自带或者其他第三方的 )，生成一个 PDF 文件、输出一个 XML、创建一个 ZIP 文件等，你可以使用任何你想用的 Python 库，实现你想做的事。</p></li><li><p>Django 自带的 <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/" target="_blank" rel="noopener">Database API</a> 很方便，与试图结合使用即可实现数据的基本交互操作。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 index() 函数里插入了一些新内容</span></span><br><span class="line"><span class="comment"># 让它能展示数据库里以发布日期排序的最近5个投票问题</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">latest_question_list = Question.objects.order_by(<span class="string">'-pub_date'</span>)[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">output = <span class="string">', '</span>.join([q.question_text <span class="keyword">for</span> q <span class="keyword">in</span> latest_question_list])</span><br><span class="line"><span class="keyword">return</span> HttpResponse(output)</span><br></pre></td></tr></table></figure></li></ul><h4 id="模板系统"><a href="#模板系统" class="headerlink" title="模板系统"></a>模板系统</h4><ul><li><p>这里有个问题：页面的设计写死在视图函数的代码里的。如果你想改变页面的样子，你需要编辑 Python 代码。我们是否能将此过程相互分离，即 <code>视图负责处理、组装数据</code>；<code>模板则负责样式</code>。</p><ul><li>首先，在你的项目根目录里创建一个 <code>templates</code> 目录。Django 将会在这个目录里查找模板文件。</li><li>在 <code>templates</code> 目录里，再创建一个目录 <code>polls</code>，然后在其中新建一个文件 <code>index.html</code>。</li><li><p>换句话说，你的模板文件的路径应该是 <code>mysite/templates/polls/index.html</code>。因为 Django 会寻找到对应的 <code>app_directories</code>，所以你只需要使用 <code>polls/index.html</code> 就可引用到这一模板了。</p><blockquote><p><code>模板命名空间</code>：虽然可将模板文件直接放在 mysite/templates 目录下，但若有一个模板文件正好和另一个应用中的某个模板文件重名，则 Django 没有办法区分它们，从而选择第一个匹配的模板文件，造成不能准确匹配的状况。</p><p>帮助 Django 正确选择模板，最简单的方法是把他们放入各自的 <code>命名空间</code> 中，即把这些模板放入一个和 <code>自身应用重名</code> 的子文件夹里，如本例中的 <code>polls</code>。</p></blockquote></li></ul></li></ul><h4 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h4><ul><li><p>我们将下面的代码输入到刚刚创建的模板文件中：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mysite/templates/polls/index.html --&gt;</span></span><br><span class="line">&#123;% if latest_question_list %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% for question in latest_question_list %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/polls/&#123;&#123; question.id &#125;&#125;/"</span>&gt;</span></span><br><span class="line">&#123;&#123; question.question_text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% else %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>No polls are available.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>然后，让我们更新一下 polls/views.py 里的 index 视图来使用模板：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.template <span class="keyword">import</span> loader</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">latest_question_list = Question.objects.order_by(<span class="string">'-pub_date'</span>)[:<span class="number">5</span>]</span><br><span class="line">template = loader.get_template(<span class="string">'polls/index.html'</span>)</span><br><span class="line">context = &#123;</span><br><span class="line"><span class="string">'latest_question_list'</span>: latest_question_list,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> HttpResponse(template.render(context, request))</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>载入模板，填充上下文，再返回由它生成的 HttpResponse 对象，这里引入一个便捷函数 render() 函数。它已经把此过程封装一起，调用即可使用。</p><p>  render() 函数的第一个参数是 request 对象，第二个参数是模板名，第三个参数是字典。它返回给定上下文呈现的给定模板的 HttpResponse 对象。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">latest_question_list = Question.objects.order_by(<span class="string">'-pub_date'</span>)[:<span class="number">5</span>]</span><br><span class="line">context = &#123;<span class="string">'latest_question_list'</span>: latest_question_list&#125;</span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">'polls/index.html'</span>, context)</span><br></pre></td></tr></table></figure></li></ul><ul><li>用你的浏览器访问 <code>http://127.0.0.1:8000/polls/</code>，你将会看见一个无序列表。</li></ul><h4 id="使用模板系统"><a href="#使用模板系统" class="headerlink" title="使用模板系统"></a>使用模板系统</h4><blockquote><p>使用模板系统的过程，更像是前端与后端信息交互的过程，即前端访问请求地址获取数据的过程。</p></blockquote><ul><li>模板系统统一使用 <code>点符号</code> 来访问变量的属性。在示例 {{ question.question_text }} 中，首先 Django 尝试对 question 对象使用字典查找 ( 也就是使用 obj.get(str) 操作 )，如果失败了就尝试属性查找 ( 也就是 obj.str 操作 )，结果是成功了。如果这一操作也失败的话，将会尝试列表查找 ( 也就是 obj[int] 操作 )。</li><li>在{% for %}循环中发生的函数调用：question.choice_set.all 被解释为 Python 代码 question.choice_set.all()，将会返回一个可迭代的 Choice 对象，这一对象可以在 {% for %} 标签内部使用。</li><li>查看 <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/templates/" target="_blank" rel="noopener">模板指南</a> 可以了解关于模板的更多信息。</li></ul><h4 id="去除模板中的硬编码-URL"><a href="#去除模板中的硬编码-URL" class="headerlink" title="去除模板中的硬编码 URL"></a>去除模板中的硬编码 URL</h4><ul><li><p>硬编码：硬编码和强耦合的链接，对于一个包含很多应用的项目来说，修改起来是十分困难的。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/polls/&#123;&#123; question.id &#125;&#125;/"</span>&gt;</span></span><br><span class="line">&#123;&#123; question.question_text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>软编码：然而，因为你在 polls.urls 的 url() 函数中通过 name 参数为 URL 定义了名字，你可以使用 {% url %} 标签代替它。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> | 具有名字 'detail' 的 URL 在 polls/url.py 中定义为：</span></span><br><span class="line"><span class="comment"> | path('&lt;int:question_id&gt;/', views.detail, name='detail')</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'detail' question.id %&#125;"</span>&gt;</span></span><br><span class="line">&#123;&#123; question.question_text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> | 若你想改变投票详情视图的 URL，比如 polls/specifics/12/</span></span><br><span class="line"><span class="comment"> | 不用在模板里修改任何东西 (包括模板)，只在 polls/urls.py 稍微修改就行</span></span><br><span class="line"><span class="comment"> | path('specifics/&lt;int:question_id&gt;/', views.detail, name='detail')</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="为-URL-名称添加命名空间"><a href="#为-URL-名称添加命名空间" class="headerlink" title="为 URL 名称添加命名空间"></a>为 URL 名称添加命名空间</h4><ul><li>在一个真实的 Django 项目中，可能会有多个应用，Django 如何分辨重名的 URL 呢？具体情况则是，{% url %} 标签到底对应哪一个应用的 URL 呢？</li><li><p>在根 <code>URLconf</code> 中添加命名空间。在 polls/urls.py 文件中稍作修改，加上 <code>app_name</code> 设置命名空间：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line">app_name = <span class="string">'polls'</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">path(<span class="string">''</span>, views.index, name=<span class="string">'index'</span>),</span><br><span class="line">path(<span class="string">'&lt;int:question_id&gt;/'</span>, views.detail, name=<span class="string">'detail'</span>),</span><br><span class="line">path(<span class="string">'&lt;int:question_id&gt;/results/'</span>, views.results, name=<span class="string">'results'</span>),</span><br><span class="line">path(<span class="string">'&lt;int:question_id&gt;/vote/'</span>, views.vote, name=<span class="string">'vote'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>修改为指向具有命名空间的详细视图：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'polls:detail' question.id %&#125;"</span>&gt;</span></span><br><span class="line">&#123;&#123; question.question_text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="表单和通用视图"><a href="#表单和通用视图" class="headerlink" title="表单和通用视图"></a>表单和通用视图</h3><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><blockquote><p>在此小节中，通过表单接收数据，再通过 Django 视图来处理提交的数据。此过程，更像是前端打包数据通过 GET/POST 请求，把数据传送到后端，交由后端视图处理数据。</p></blockquote><ul><li><p>编写一个简单的表单：让我们更新一下在上一个教程中编写的投票详细页面的模板  <code>polls/detail.html</code>，让它包含一个 HTML <code>&lt;form&gt;</code> 元素：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mystie/templates/polls/detail.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;% if error_message %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123; error_message &#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"&#123;% url 'polls:vote' question.id %&#125;"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> | 跨站点请求伪造保护：</span></span><br><span class="line"><span class="comment"> | 在 Django 中，所有针对内部 URL 的 POST 表单，</span></span><br><span class="line"><span class="comment"> | 都应该使用  &#123;% csrf_token %&#125; 模板标签。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">&#123;% csrf_token %&#125;</span><br><span class="line">&#123;% for choice in question.choice_set.all %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"choice"</span> <span class="attr">id</span>=<span class="string">"choice&#123;&#123; forloop.counter &#125;&#125;"</span> <span class="attr">value</span>=<span class="string">"&#123;&#123; choice.id &#125;&#125;"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指示 for 标签已经循环多少次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"choice&#123;&#123; forloop.counter &#125;&#125;"</span>&gt;</span>&#123;&#123; choice.choice_text &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Vote"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://docs.djangoproject.com/zh-hans/2.1/ref/csrf/" target="_blank" rel="noopener">跨站点请求伪造保护</a>：当恶意网站包含链接，表单按钮或某些旨在在您的网站上执行某些操作的JavaScript时，会发生此类攻击，使用登录用户访问其浏览器中的恶意网站的凭据。一种相关类型的攻击，“登录CSRF”，攻击网站欺骗用户的浏览器以其他人的凭据登录网站也受到保护。</p></blockquote></li><li><p>我们为投票应用创建了一个 URLconf ，即新增一行 <code>path()</code>：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># polls/urls.py</span></span><br><span class="line">path(<span class="string">'&lt;int:question_id&gt;/vote/'</span>, views.vote, name=<span class="string">'vote'</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>创建一个 <code>vote()</code> 函数，来处理相关的数据请求：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># polls/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse, HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404, render</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Choice, Question</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vote</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">question = get_object_or_404(Question, pk=question_id)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">selected_choice = question.choice_set.get(pk=request.POST[<span class="string">'choice'</span>])</span><br><span class="line"><span class="keyword">except</span> (KeyError, Choice.DoesNotExist):</span><br><span class="line"><span class="comment"># Redisplay the question voting form.</span></span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">'polls/detail.html'</span>, &#123;</span><br><span class="line"><span class="string">'question'</span>: question,</span><br><span class="line"><span class="string">'error_message'</span>: <span class="string">"You didn't select a choice."</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">selected_choice.votes += <span class="number">1</span></span><br><span class="line">selected_choice.save()</span><br><span class="line"><span class="comment"># Always return an HttpResponseRedirect after successfully dealing</span></span><br><span class="line"><span class="comment"># with POST data. This prevents data from being posted twice if a</span></span><br><span class="line"><span class="comment"># user hits the Back button.</span></span><br><span class="line"><span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">'polls:results'</span>, args=(question.id,)))</span><br></pre></td></tr></table></figure><ul><li>代码返回一个 HttpResponseRedirect 而不是常用的 HttpResponse；</li><li>HttpResponseRedirect 只接收一个参数：用户将要被重定向的 URL；</li><li><p>在 HttpResponseRedirect 的构造函数中使用 reverse() 函数。这个函数避免了我们在视图函数中硬编码 URL。</p><blockquote><p>reverse() 调用将返回一个这样的字符串 <code>/polls/3/results/</code>。<br>其中 3 是 question.id 的值。重定向的 URL 将调用 ‘results’ 视图来显示最终的页面。</p></blockquote></li></ul></li><li><p>当对 Question 进行投票后，vote() 视图将请求重定向到 Question 的结果界面。让我们来编写这个视图 ( 这和上一章节中的 detail() 视图几乎一模一样，唯一的不同是模板的名字。 我们将在稍后解决这个冗余问题 )：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># polls/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404, render</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">results</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">question = get_object_or_404(Question, pk=question_id)</span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">'polls/results.html'</span>, &#123;<span class="string">'question'</span>: question&#125;)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>再创建一个 <code>polls/results.html</code> 模板：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- polls/templates/polls/results.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% for choice in question.choice_set.all %&#125;<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;&#123; choice.choice_text &#125;&#125; -- &#123;&#123; choice.votes &#125;&#125; vote&#123;&#123; choice.votes|pluralize &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span>&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'polls:detail' question.id %&#125;"</span>&gt;</span>Vote again?<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="通用视图"><a href="#通用视图" class="headerlink" title="通用视图"></a>通用视图</h4><blockquote><p>猜想：通用视图是否是通用模板的思想，即使用统一的界面展示数据？</p></blockquote><ul><li>detail() 和 results() 视图都很简单。并且，像上面提到的那样，存在冗余问题。</li><li>这些视图反映基本的 Web 开发中的一个常见情况：根据 URL 中的参数从数据库中获取数据、载入模板文件然后返回渲染后的模板。 由于这种情况特别常见，Django 提供一种快捷方式，叫做“通用视图”系统。</li><li><p>通用视图将常见的模式抽象化，可以使你在编写应用时甚至不需要编写 Python 代码。</p><blockquote><p>一般来说，当编写一个 Django 应用时，你应该先评估一下通用视图是否可以解决你的问题，你应该在一开始使用它，而不是进行到一半时重构代码。</p></blockquote></li><li><p>让我们将我们的投票应用转换成使用通用视图系统，这样我们可以删除许多我们的代码。我们仅仅需要做以下几步来完成转换，我们将：</p><ul><li>转换 URLconf。</li><li>删除一些旧的、不再需要的视图。</li><li>基于 Django 的通用视图引入新的视图。</li></ul></li></ul><h5 id="改良-URLconf"><a href="#改良-URLconf" class="headerlink" title="改良 URLconf"></a>改良 URLconf</h5><ul><li><p>首先，打开 polls/urls.py 这个 URLconf 并将它修改成：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">app_name = <span class="string">'polls'</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">path(<span class="string">''</span>, views.IndexView.as_view(), name=<span class="string">'index'</span>),</span><br><span class="line"><span class="comment"># 路径字符串中匹配模式的名称已经由 &lt;question_id&gt; 改为 &lt;pk&gt;</span></span><br><span class="line">path(<span class="string">'&lt;int:pk&gt;/'</span>, views.DetailView.as_view(), name=<span class="string">'detail'</span>),</span><br><span class="line">path(<span class="string">'&lt;int:pk&gt;/results/'</span>, views.ResultsView.as_view(), name=<span class="string">'results'</span>),</span><br><span class="line">path(<span class="string">'&lt;int:question_id&gt;/vote/'</span>, views.vote, name=<span class="string">'vote'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h5 id="改良视图"><a href="#改良视图" class="headerlink" title="改良视图"></a>改良视图</h5><ul><li><p>下一步，我们将删除旧的 index, detail, 和 results 视图，并用 Django 的通用视图代替。打开 polls/views.py 文件，并将它修改成：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404, render</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> generic</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Choice, Question</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexView</span><span class="params">(generic.ListView)</span>:</span></span><br><span class="line">template_name = <span class="string">'polls/index.html'</span></span><br><span class="line">context_object_name = <span class="string">'latest_question_list'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">       <span class="comment"># Return the last five published questions.</span></span><br><span class="line">       <span class="keyword">return</span> Question.objects.order_by(<span class="string">'-pub_date'</span>)[:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailView</span><span class="params">(generic.DetailView)</span>:</span></span><br><span class="line">model = Question</span><br><span class="line">template_name = <span class="string">'polls/detail.html'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultsView</span><span class="params">(generic.DetailView)</span>:</span></span><br><span class="line">model = Question</span><br><span class="line">template_name = <span class="string">'polls/results.html'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vote</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line"><span class="comment"># Same as above, no changes needed.</span></span><br></pre></td></tr></table></figure></li><li><p>上述代码详细解释：        </p><ul><li>默认情况下，通用视图 DetailView 使用一个叫做 <code>&lt;app name&gt;/&lt;model name&gt;_detail.html</code> 的模板。在我们的例子中，它将使用 <code>polls/question_detail.html</code> 模板。</li><li><code>template_name</code> 属性是用来告诉 Django 使用一个指定的模板名字，而不是自动生成的默认名字。 </li><li>我们也为 results 列表视图和 detail 视图指定了 template_name。即使它们在后台都是同一个 DetailView，results 视图和 detail 视图在渲染时具有不同的访问名称。</li><li>类似地，ListView 使用一个叫做 <code>&lt;app name&gt;/&lt;model name&gt;_list.html</code> 的默认模板；我们使用 template_name 来告诉 ListView 使用我们创建的已经存在的 <code>polls/index.html</code> 模板。</li><li>在之前的教程中，提供模板文件时都带有一个包含 question 和 latest_question_list 变量的 context。<ul><li>对于 DetailView ， question 变量会自动提供—— 因为我们使用 Django 的模型 (Question)， Django 能够为 context 变量决定一个合适的名字。</li><li>对于 ListView， 自动生成的 context 变量是 question_list。为了覆盖这个行为，我们提供 <code>context_object_name</code> 属性，表示我们想使用 <code>latest_question_list</code>。</li></ul></li></ul></li></ul><h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><h4 id="为什么你需要写测试"><a href="#为什么你需要写测试" class="headerlink" title="为什么你需要写测试"></a>为什么你需要写测试</h4><ul><li><code>测试将节约你的时间</code>：在复杂的应用程序中，组件之间可能会有数十个复杂的交互。改变其中某一组件的行为，也有可能会造成意想不到的结果。判断「代码是否正常工作」意味着你需要用大量的数据来完整的测试全部代码的功能，以确保你的小修改没有对应用整体造成破坏，可想而知其中的工作量。</li><li><code>测试不仅能发现错误且能预防错误</code>：测试是开发的对立面，这种思想是不对的，开发其实更像是一个不断试错的过程。</li></ul><h4 id="开始写一个测试程序"><a href="#开始写一个测试程序" class="headerlink" title="开始写一个测试程序"></a>开始写一个测试程序</h4><ul><li>约定俗称，Django 应用的测试应该写在应用的 <code>tests.py</code> 文件里，测试系统会自动的在所有以 tests 开头的文件里寻找并执行测试代码。</li><li><p>制造一个 BUG：继续上述提及的应用 Polls，要求 Question 是在一天之内发布， 则 Question.was_published_recently() 方法将会返回 True 。然而现在这个方法在 Question 的 pub_date 字段比当前时间还晚 ( 未来的时间 ) 时也会返回 True。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"><span class="keyword">from</span> polls.models <span class="keyword">import</span> Question</span><br><span class="line"><span class="comment"># create a Question instance with pub_date 30 days in the future</span></span><br><span class="line">time = timezone.now() + datetime.timedelta(days=<span class="number">30</span>)</span><br><span class="line">future_question = Question(pub_date=time)</span><br><span class="line"><span class="comment"># was it published recently? ==&gt; True</span></span><br><span class="line">future_question.was_published_recently()</span><br></pre></td></tr></table></figure></li><li><p>创造一个测试用例：创建一个 <code>django.test.TestCase</code> 的子类。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"><span class="keyword">from</span> django.test <span class="keyword">import</span> TestCase</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuestionModelTests</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_was_published_recently_with_future_question</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        was_published_recently() returns False </span></span><br><span class="line"><span class="string">        for questions whose pub_date is in the future.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        time = timezone.now() + datetime.timedelta(days=<span class="number">30</span>)</span><br><span class="line">        future_question = Question(pub_date=time)</span><br><span class="line">        self.assertIs(future_question.was_published_recently(), <span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></li><li><p>最后，我们可通过 PyCharm 单独运行测试用例，也可以通过终端命令运行自动化测试。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py <span class="built_in">test</span> polls</span><br></pre></td></tr></table></figure></li><li><p>发生了什么呢？以下是自动化测试的运行过程：</p><ul><li><code>python manage.py test polls</code> 将会寻找 Polls 应用里的测试代码，它找到了 django.test.TestCase 的一个子类，并创建一个特殊的数据库供测试使用；</li><li>在类中寻找测试方法 ( 以 test 开头的 )，在 <code>test_was_published_recently_with_future_question</code> 方法中，它创建了一个 pub_date 值为 30 天后的 Question 实例。</li><li>接着使用 <code>assertls()</code> 方法，发现 <code>was_published_recently()</code> 返回了 True，而我们期望它返回 False。</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432712108300322c61f256c74803b43bfd65c6f8d0d0000" target="_blank" rel="noopener">廖雪峰. Python 教程之 virtualenv. 2017. liaoxuefeng.com</a></li><li>[2] <a href="https://zhuanlan.zhihu.com/p/31447222" target="_blank" rel="noopener">地球的外星人君. Python Web 框架大乱斗：哪个框架适合你. 2017. zhihu.com</a></li><li>[3] <a href="https://www.zhihu.com/question/20706333" target="_blank" rel="noopener">知乎问答. Python 有哪些好的 Web 框架. zhihu.com</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Django 是基于 MVC 模式，由 Python 写成的开源 Web 应用框架。在 Django 中，控制器接受用户输入的部分由框架自行处理，而 Django 里更关注的是模型 ( Model )、模板 ( Template ) 和视图 ( Views )，为此也称其为 MTV 模式的 Web 框架。&lt;/p&gt;
&lt;p&gt;当然，基于 Python 的 Web 框架不仅这一家，如  flask、tornado、web2py 等。而任何一款框架的产生都有自身的亮点和缺陷 $^{[2, 3]}$，综合自我诉求、性能要求等诸多因素考量，选择适合的框架即可。在本次开发中，我们只需要一款数据库驱动的内容发布与管理系统，而 Django 的中间件 &lt;a href=&quot;https://baike.baidu.com/item/对象关系映射&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ORM&lt;/a&gt; 设计，使得我们在具体操作业务对象时，不需要和复杂的 SQL 语句打交道，只要像平时操作对象一样操作即可。为此，本着轻量开发的原则选择了 Django。&lt;/p&gt;
    
    </summary>
    
      <category term="Project" scheme="http://www.kofes.cn/categories/Project/"/>
    
    
      <category term="python" scheme="http://www.kofes.cn/tags/python/"/>
    
      <category term="web" scheme="http://www.kofes.cn/tags/web/"/>
    
      <category term="django" scheme="http://www.kofes.cn/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>框架 | FastDFS 入门到应用</title>
    <link href="http://www.kofes.cn/2019/02/FastDFS.html"/>
    <id>http://www.kofes.cn/2019/02/FastDFS.html</id>
    <published>2019-02-05T06:37:37.000Z</published>
    <updated>2019-02-05T06:43:22.082Z</updated>
    
    <content type="html"><![CDATA[<p>余庆老师在他的 Github 上介绍关于 <a href="https://github.com/happyfish100/fastdfs" target="_blank" rel="noopener">FastDFS</a> 开源项目的描述：FastDFS 是一个开源的高性能分布式文件系统 ( DFS )。 它的主要功能包括文件存储，文件同步和文件访问，以及高容量和负载平衡。</p><a id="more"></a><h2 id="FastDFS-简单介绍"><a href="#FastDFS-简单介绍" class="headerlink" title="FastDFS 简单介绍"></a>FastDFS 简单介绍</h2><h3 id="FastDFS-核心组件"><a href="#FastDFS-核心组件" class="headerlink" title="FastDFS 核心组件"></a>FastDFS 核心组件</h3><ul><li><code>Tracker Server</code>：跟踪服务器，负责维持集群的信息；负责管理所有的 Storage Server 和 Group，每个 Storage 在启动后会连接 Tracker，告知自己所属 group 等信息，并保持周期性心跳。</li><li><code>Storage server</code>：存储服务器，以 Group 为单位进行组织，任何一个 Storage Server 都应该属于某个 Group；一个 Group 可含多个 Storage server；在同一个 Group 内部，各 Storage Server 的数据自行同步、备份。</li><li><p><code>Client</code>：客户端，上传、下载数据的服务器，也就是我们自己的项目所部署在的服务器。</p><blockquote><p>核心组件的介绍参考了 [1]、[2] 的概念叙述。</p></blockquote></li></ul><h3 id="FastDFS-组织架构"><a href="#FastDFS-组织架构" class="headerlink" title="FastDFS 组织架构"></a>FastDFS 组织架构</h3><ul><li><p>结合组件的功能描述可知，FastDFS 的组织架构 $^{[2]}$ 如图 1-1 所示。</p><p>  <img src="/images/illustration/Project/2019/02/fastdfs_1-1.jpg" alt="fastdfs_1-1"></p>  <center>图 1-1 FastDFS 的组织架构</center></li></ul><h3 id="FastDFS-文件传输"><a href="#FastDFS-文件传输" class="headerlink" title="FastDFS 文件传输"></a>FastDFS 文件传输</h3><ul><li><p>通过时序图，分析 FastDFS 文件上传、文件下载等操作的流程，如图 1-2 所示。</p><p>  <img src="/images/illustration/Project/2019/02/fastdfs_1-2.jpg" alt="fastdfs_1-2"></p>  <center>图 1-2 FastDFS 文件上传、下载的时序图</center></li><li><p>文件上传流程：</p><ul><li>1) Client 询问 Tracker，发送上传文件的请求；</li><li>2) Tracker 返回可调用的 <code>Storage ID: Port</code>；</li><li>3) Client 直接与目标 Storage 通讯，完成文件上传；</li><li>4) Storage 返回 <code>文件ID</code>，文件ID 为 <code>Group ID + FileName</code>。</li></ul></li><li>文件下载流程：<ul><li>1) Client 询问 Tracker  下载文件所在的 Storage ( 参数为 <code>文件ID</code> )；</li><li>2) Tracker 返回可调用的 <code>Storage ID: Port</code>；</li><li>3) Client 直接与目标 Storage 通讯，完成文件下载；</li><li>4) Storage 返回 <code>文件内容</code>。</li></ul></li></ul><h2 id="FastDFS-客户端"><a href="#FastDFS-客户端" class="headerlink" title="FastDFS 客户端"></a>FastDFS 客户端</h2><h3 id="Java-客户端"><a href="#Java-客户端" class="headerlink" title="Java 客户端"></a>Java 客户端</h3><ul><li>调用余庆老师封装的 <a href="https://github.com/happyfish100/fastdfs-client-java" target="_blank" rel="noopener">FastDFS Client Java SDK</a>，即可实现客户端访问 FastDFS。</li></ul><h3 id="Python-客户端"><a href="#Python-客户端" class="headerlink" title="Python 客户端"></a>Python 客户端</h3><ul><li><p><code>安装环境</code>：网上教程一般都是指 Python 2.7，在 Python 3.x 版本下跑不了，即使是通过 <code>pip3 install fdfs-client-py</code> 安装也跑不通，这里建议通过源码方式安装 $^{[3, 4]}$。</p><blockquote><p>源码地址：<a href="https://github.com/jefforeilly/fdfs_client-py.git" target="_blank" rel="noopener">Hay86. fdfs_client-py. Last Updated on Sept.9, 2018</a></p></blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Case.01.通过 pip 安装</span></span><br><span class="line">pip install fdfs_client-py-master.zip</span><br><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">Case.02.通过 python 安装</span></span><br><span class="line"><span class="string">解压 fdfs_client-py-master.zip，进入目录 /fdfs_client-py-master</span></span><br><span class="line"><span class="string">python steup.py install</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line"><span class="comment"># 安装完成后，若导入时提示缺少 mutagen、requests，请继续安装依赖包</span></span><br><span class="line">pip install mutagen</span><br><span class="line">pip install requests</span><br></pre></td></tr></table></figure></li><li><p><code>安装指南</code>：当然，安装指南和 <a href="https://github.com/hay86/fdfs_client-py#api-reference" target="_blank" rel="noopener">API Reference</a> 请参考源码的官方文档。</p></li><li><p><code>生成配置</code>：在测试代码前夕，我们还需要创建一配置文件 <code>client.conf</code>。注意配置文件名称就是 <strong>client.conf</strong>，更改为其他名称好像行不通。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># connect timeout in seconds</span></span><br><span class="line"><span class="comment"># default value is 30s</span></span><br><span class="line">connect_timeout=<span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># network timeout in seconds</span></span><br><span class="line"><span class="comment"># default value is 30s</span></span><br><span class="line">network_timeout=<span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the base path to store log files</span></span><br><span class="line">base_path=log</span><br><span class="line"></span><br><span class="line"><span class="comment"># tracker_server can ocur more than once, and tracker_server format is</span></span><br><span class="line"><span class="comment"># "host:port", host can be hostname or ip address</span></span><br><span class="line">tracker_server=<span class="number">192.168</span><span class="number">.200</span><span class="number">.221</span>:<span class="number">22122</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># standard log level as syslog, case insensitive, value list:</span></span><br><span class="line"><span class="comment">### emerge for emergency</span></span><br><span class="line"><span class="comment">### alert</span></span><br><span class="line"><span class="comment">### crit for critical</span></span><br><span class="line"><span class="comment">### error</span></span><br><span class="line"><span class="comment">### warn for warning</span></span><br><span class="line"><span class="comment">### notice</span></span><br><span class="line"><span class="comment">### info</span></span><br><span class="line"><span class="comment">### debug</span></span><br><span class="line">log_level=info</span><br><span class="line"></span><br><span class="line"><span class="comment"># if use connection pool</span></span><br><span class="line"><span class="comment"># default value is false</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">use_connection_pool = false</span><br><span class="line"></span><br><span class="line"><span class="comment"># connections whose the idle time exceeds this time will be closed</span></span><br><span class="line"><span class="comment"># unit: second</span></span><br><span class="line"><span class="comment"># default value is 3600</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">connection_pool_max_idle_time = <span class="number">3600</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if load FastDFS parameters from tracker server</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line"><span class="comment"># default value is false</span></span><br><span class="line">load_fdfs_parameters_from_tracker=false</span><br><span class="line"></span><br><span class="line"><span class="comment"># if use storage ID instead of IP address</span></span><br><span class="line"><span class="comment"># same as tracker.conf</span></span><br><span class="line"><span class="comment"># valid only when load_fdfs_parameters_from_tracker is false</span></span><br><span class="line"><span class="comment"># default value is false</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">use_storage_id = false</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify storage ids filename, can use relative or absolute path</span></span><br><span class="line"><span class="comment"># same as tracker.conf</span></span><br><span class="line"><span class="comment"># valid only when load_fdfs_parameters_from_tracker is false</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">storage_ids_filename = storage_ids.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTP settings</span></span><br><span class="line">http.tracker_server_port=<span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># use "#include" directive to include HTTP other settings</span></span><br><span class="line"><span class="comment">## include http.conf</span></span><br></pre></td></tr></table></figure></li><li><p><code>测试代码</code>：这里假设你已成功安装了 <code>fdfs-client-py</code>，那么以一段测试代码正式开始使用。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Step.01. import fdfs_client.client module</span></span><br><span class="line"><span class="comment"># Step.02. instantiate class Fdfs_client</span></span><br><span class="line"><span class="comment"># Step.03. call memeber functions</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fdfs_client.client <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># client.conf 配置文件放在 .py 文件同目录下</span></span><br><span class="line">client = Fdfs_client(<span class="string">'client.conf'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传文件</span></span><br><span class="line">ret = client.upload_by_filename(<span class="string">'upload.txt'</span>)</span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment">## 等待 3 秒，否则下载时会报错文件不存在</span></span><br><span class="line">time.sleep(<span class="number">3</span>)  </span><br><span class="line"><span class="comment">## 新版本文件存放 Remote file_id 格式变化</span></span><br><span class="line">file_id = ret[<span class="string">'Remote file_id'</span>].replace(<span class="string">'\\'</span>, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line">ret_download = client.download_to_file(<span class="string">'download.txt'</span>, file_id)</span><br><span class="line">print(ret_download)</span><br></pre></td></tr></table></figure></li><li><p><code>说明文档</code>：关于 <code>Fdfs_client</code> 类的成员函数详细说明请参考 <a href="https://github.com/hay86/fdfs_client-py#api-reference" target="_blank" rel="noopener">API Reference</a>：</p><ul><li>upload_by_filename(self, filename, meta_dict = None)</li><li>upload_by_buffer(self, filebuffer, file_ext_name = None, meta_dict = None)</li><li>upload_slave_by_filename(self, filename, remote_file_id, prefix_name, meta_dict = None)</li><li>upload_slave_by_buffer(self, filebuffer, remote_file_id, meta_dict = None, file_ext_name = None)</li><li>upload_appender_by_filename(self, local_filename, meta_dict = None)</li><li>upload_appender_by_buffer(self, filebuffer, file_ext_name = None, meta_dict = None)</li><li>delete_file(self, remote_file_id)</li><li>download_to_file(self, local_filename, remote_file_id, offset = 0, down_bytes = 0)</li><li>download_to_buffer(self, remote_file_id, offset = 0, down_bytes = 0)</li><li>list_one_group(self, group_name)</li><li>list_all_groups(self)</li><li>list_servers(self, group_name, storage_ip = None)</li><li>get_meta_data(self, remote_file_id)</li><li>append_by_filename(self, local_filename, remote_fileid)</li><li>append_by_buffer(self, file_buffer, remote_fileid)</li><li>truncate_file(self, truncated_filesize, appender_fileid)</li><li>modify_by_filename(self, filename, appender_fileid, offset = 0)</li><li>modify_by_buffer(self, filebuffer, appender_fileid, offset = 0)</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://www.cnblogs.com/mafly/p/fastdfs.html" target="_blank" rel="noopener">Mafly. 分布式文件系统 FastDFS 简单了解. 2016. cnblogs.com</a></li><li>[2] <a href="https://www.cnblogs.com/shenxm/p/8459292.html" target="_blank" rel="noopener">shenxm. FastDFS 的介绍. 2018. cnblogs.com</a></li><li>[3] <a href="http://zifuchuan.com/me/index.php/python/725-1.html" target="_blank" rel="noopener">小草. FastDFS 的 Python 客户端. 2017. zifuchuan.com</a></li><li>[4] <a href="https://blog.csdn.net/weixin_42149982/article/details/82391218" target="_blank" rel="noopener">ZbyFt. Django-FDFS 配置. 2018. csdn.net</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;余庆老师在他的 Github 上介绍关于 &lt;a href=&quot;https://github.com/happyfish100/fastdfs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FastDFS&lt;/a&gt; 开源项目的描述：FastDFS 是一个开源的高性能分布式文件系统 ( DFS )。 它的主要功能包括文件存储，文件同步和文件访问，以及高容量和负载平衡。&lt;/p&gt;
    
    </summary>
    
      <category term="Project" scheme="http://www.kofes.cn/categories/Project/"/>
    
    
      <category term="分布式" scheme="http://www.kofes.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="文件系统" scheme="http://www.kofes.cn/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="DFS" scheme="http://www.kofes.cn/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>极客 | 树莓派能做什么？</title>
    <link href="http://www.kofes.cn/2019/01/Raspbian-Guideline.html"/>
    <id>http://www.kofes.cn/2019/01/Raspbian-Guideline.html</id>
    <published>2019-01-21T01:20:22.000Z</published>
    <updated>2019-02-28T06:57:20.082Z</updated>
    
    <content type="html"><![CDATA[<p>树莓派能做什么？关于此命题，最直观感受就是看看树莓派实验室整理的一些<a href="http://shumeipai.nxez.com/what-raspi-used-for" target="_blank" rel="noopener">案例</a>，相信你心目中会有答案的。例如，打造一个家庭媒体中心 ( KODI )、配置无线路由器、搭建 BT 下载服务器、搭建代码托管服务器 ( SVN、GIt )、搭建网站服务器、搭建 Shadowsocks、用 HomeKit + Siri 声控家里电器等，即可把树莓派想象成嵌入式、微小型的服务器，这一过程就好比操作系统 ( Linux ) 赋予硬件生命，编程 ( Python、Java )、程序灌入灵魂，借助树莓派低能耗、移动便携性、GPIO 等特性，很多想法不是不可能，相信树莓派会给你创造更多的惊喜！</p><a id="more"></a><p>需要说明的是，本文将围绕两大方面去探索树莓派，即基础应用和解决方案两大部分，也可理解为基础到进阶的过程。</p><ul><li><a href="#基础应用">基础应用</a>：介绍使用树莓派必须的应用或组件，这些应用和组件主要作用是：一方面是增强系统功能，另一方面则是为解决方案建立软件基础。</li><li><a href="#解决方案">解决方案</a>：诸如引言中谈及的，搭建服务器、智能家居控制中心等，即针对某部分需求集成为服务，学术说法称其为某某即服务 ( XaaS )。</li></ul><h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><ul><li>树莓派型号：树莓派 3B+</li><li>树莓派系统：<a href="https://www.raspberrypi.org/downloads/noobs/" target="_blank" rel="noopener">Raspbian v.3.0.0</a></li></ul><h2 id="更新进度"><a href="#更新进度" class="headerlink" title="更新进度"></a>更新进度</h2><ul><li>2019.01.21：完成初稿，形成笔记的整体框架；</li><li>2019.02.25：更新「Jupyter 服务器」 章节内容；</li><li>2019.02.26：更新「Conda 服务器」 章节内容；</li></ul><h2 id="教学资源"><a href="#教学资源" class="headerlink" title="教学资源"></a>教学资源</h2><ul><li>🚩 | 社区 | <a href="http://shumeipai.nxez.com/" target="_blank" rel="noopener">树莓派实验室</a> | 教程、创意、作品、资讯、硬件五位一体的爱好者交流社区。</li><li>🚩 | 社区 | <a href="https://www.quwj.com/" target="_blank" rel="noopener">趣无尽</a> | 树莓派高端、创意的玩法探索博客站。</li><li>📄 | 资料 | <a href="https://www.yahboom.com/study/raspberry" target="_blank" rel="noopener">亚博智能官方资料. 树莓派3代B型开发板</a> | <a href="https://pan.baidu.com/s/1OUa0KszF7sxim5FcUdqccQ" target="_blank" rel="noopener">资料打包下载 ( bwnr )</a></li></ul><h2 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h2><h3 id="TeamViewer-远程控制"><a href="#TeamViewer-远程控制" class="headerlink" title="TeamViewer 远程控制"></a>TeamViewer 远程控制</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>访问树莓派有多种方式，如直连显示器交互使用、通过 SSH 远程登录访问、通过软件实现控制使用等。其中，TeamViewer 是通过软件方式实现对树莓派的远程控制，其拥有有以下几种特性：</p><ul><li>可穿透局域网，支持外网连接；</li><li>实时 GUI 界面显示；</li><li>支持文件双向传输。</li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在本节，则单独介绍 TeamViewer 的配置与使用，当然教程是参考文章 <a href="http://www.52pi.net/archives/549" target="_blank" rel="noopener">[5]</a>、<a href="https://blog.csdn.net/realDonaldTrump/article/details/79694196" target="_blank" rel="noopener">[6]</a> 整理而得。</p><h5 id="删除-TeamViewer"><a href="#删除-TeamViewer" class="headerlink" title="删除 TeamViewer"></a>删除 TeamViewer</h5><p>删除 TeamViewer，用于安装出错时，清理残留软件包，方便从头再来。😂</p><blockquote><p>此步骤是非必要执行的步骤。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove teamviewer-host</span><br><span class="line"><span class="comment"># 清除所有已删除包的残余配置文件</span></span><br><span class="line"><span class="comment"># 若报错误 dpkg: –purge needs at least one package name argument</span></span><br><span class="line"><span class="comment"># 证明你的系统中没有残留配置文件了</span></span><br><span class="line">dpkg -l |grep ^rc|awk <span class="string">'&#123;print $2&#125;'</span> |sudo xargs dpkg -P</span><br></pre></td></tr></table></figure><h5 id="安装-TeamViewer"><a href="#安装-TeamViewer" class="headerlink" title="安装 TeamViewer"></a>安装 TeamViewer</h5><p>Step.01：进入 <a href="https://www.teamviewer.com/en-us/download/linux/" target="_blank" rel="noopener">官方下载</a>，在「TeamViewer Host for Raspberry Pi」模块，复制安装包地址，接着正式开始安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 wget 在线下载安装包</span></span><br><span class="line">wget https://download.teamviewer.com/download/linux/teamviewer-host_armhf.deb</span><br><span class="line"><span class="comment"># 安装本地软件包，但不解决依赖关系</span></span><br><span class="line">sudo dpkg -i teamviewer-host_armhf.deb</span><br><span class="line"><span class="comment"># 修复损坏的软件包，尝试卸载出错的包，重新安装正确版本的</span></span><br><span class="line">sudo apt-get -f install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若提示未找到依赖包，可安装 Gdebi，通过 Gdebi 安装解决依赖问题</span></span><br><span class="line"><span class="comment"># 使用 Gdebi 可代替软件中心接管 deb 软件包的安装</span></span><br><span class="line"><span class="comment"># 它会根据软件仓库这一实用的特性来解算依赖关系</span></span><br><span class="line">sudo apt-get install gdebi</span><br><span class="line">sudo gdebi teamviewer-host_armhf.deb</span><br></pre></td></tr></table></figure><h5 id="配置-TeamViewer"><a href="#配置-TeamViewer" class="headerlink" title="配置 TeamViewer"></a>配置 TeamViewer</h5><p>Step.02：因为我们烧写的系统有图形界面，默认 TeamViewer 要在图形界面进行配置，如远程控制的账号、密码设置等。若有条件支持，可移步图形化界面操作，即可忽略此步骤。</p><ul><li><p>没有图形界面，则我们需要在命令行下配置。使用 <code>raspi-config</code> 配置 Raspbian 仅命令行模式运行。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令模式的操作界面</span></span><br><span class="line"><span class="comment"># 依次选择操作 ( 同理，还原桌面模式也是类似操作 )</span></span><br><span class="line"><span class="comment"># Boot Options -&gt; Desktop / CLI -&gt; Console AutoLogin -&gt;</span></span><br><span class="line"><span class="comment"># Finished</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>配置保存后，树莓派会自动重启，那么重新远程登录继续操作。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo teamviewer setup</span><br><span class="line"><span class="comment"># 1. Accept License Agreement? (y/n) y</span></span><br><span class="line"><span class="comment"># 2. 输入用户名和密码的步骤无法跳过，没有账号请移步「官网完成注册」</span></span><br><span class="line"><span class="comment">#  注册地址：https://login.teamviewer.com/LogOn</span></span><br><span class="line"><span class="comment">#  Please enter your e-mail / username: kofe</span></span><br><span class="line"><span class="comment">#  Please enter your password: ******</span></span><br><span class="line"><span class="comment"># 3. 然后 TeamViewer 会发一份设备授权邮件，请移步「邮箱处理」</span></span><br><span class="line"><span class="comment"># 4. 重新输入用户名和密码登录，提示分组信息，点击 y：</span></span><br><span class="line"><span class="comment">#  Adding this machine as 'raspberrypi' to ... </span></span><br><span class="line"><span class="comment"># Do you want to continue? (y/n) [n]  y</span></span><br><span class="line"><span class="comment"># 5. 提示 "Successfully...." 即表示已经完成配置工作了</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>完成初始化配置后，只需设置远程控制密码即可使用了。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本机 ID</span></span><br><span class="line">teamviewer info</span><br><span class="line"><span class="comment"># 设置本机密码</span></span><br><span class="line">teamviewer passwd [你的密码]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>当然，我们还需要把 Raspbian 还原为图形化操作界面。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br><span class="line"><span class="comment"># Boot Options -&gt; Desktop / CLI -&gt; Desktop AutoLogin -&gt;</span></span><br><span class="line"><span class="comment"># Finished</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li><p>一般情况下，我们主要是通过命令模式访问树莓派、配置 TeamViewer。当然也可以通过图形界面完成配置操作，按照文字提示操作即可，这里就不详细阐述了。附上 TeamViewer 常用的命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看帮助信息</span></span><br><span class="line">teamviewer <span class="built_in">help</span></span><br><span class="line"><span class="comment"># 查看本机 ID</span></span><br><span class="line">teamviewer info</span><br><span class="line"><span class="comment"># 设置本机密码</span></span><br><span class="line">sudo teamviewer passwd [你的密码]</span><br><span class="line"><span class="comment"># 启动 TeamViewer 服务</span></span><br><span class="line">sudo teamviewer --daemon start</span><br><span class="line"><span class="comment"># 开启 TeamViewer 服务随机启动</span></span><br><span class="line">sudo teamviewer --daemon <span class="built_in">enable</span></span><br></pre></td></tr></table></figure></li><li><p>最后，关于图形化界面显示方面，可能还有分辨率调整与存在黑边的问题，详细可参考以下文章解决问题：</p><ul><li><a href="https://www.raspberrypi.org/documentation/configuration/config-txt/README.md" target="_blank" rel="noopener">树莓派. 官方使用文档之 CONFIG-TXT. raspberrypi.org</a></li><li><a href="https://blog.csdn.net/fishchina/article/details/54564395" target="_blank" rel="noopener">FishChina. 树莓派有黑边不能全屏解决方法. 2017. csdn.net</a></li></ul></li></ul><h3 id="MySQL-数据库"><a href="#MySQL-数据库" class="headerlink" title="MySQL 数据库"></a>MySQL 数据库</h3><h4 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h4><p>数据库的用途毋庸置疑，若在树莓派上跑脚本、程序、网站系统等，少不了数据的交互，为此我们需要一款数据库作为数据储存的媒介。MySQL，是一款开源免费的数据库，也是关系型数据库管理系统，支持多种存储引擎 $^{[1, 2]}$，对于个人开发和日常使用足矣。</p><p>以下将介绍，在树莓派 Raspbian 上安装 Mysql  服务，并开启远程访问。</p><h4 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h4><ul><li><p>删除 MySQL：安装前，确保系统没有旧版的 MySQL。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoremove --purge mysql-server</span><br><span class="line">sudo apt-get remove mysql-common</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除所有已删除包的残馀配置文件</span></span><br><span class="line"><span class="comment"># 若报错误 dpkg: –purge needs at least one package name argument</span></span><br><span class="line"><span class="comment"># 证明你的系统中没有残留配置文件了</span></span><br><span class="line">dpkg -l |grep ^rc|awk <span class="string">'&#123;print $2&#125;'</span> |sudo xargs dpkg -P</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>安装 MySQL：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt-get install mysql-client</span><br><span class="line">sudo apt-get install python-mysqldb <span class="comment"># 安装 Python 接口的 MySQL</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="配置-MySQL"><a href="#配置-MySQL" class="headerlink" title="配置 MySQL"></a>配置 MySQL</h4><ul><li><p>命令行安装，默认是不用配置用户和密码信息，故我们首先配置登录信息 $^{[3]}$：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql -u root # 无密码登录 MySQL</span><br><span class="line"><span class="keyword">use</span> mysql;</span><br><span class="line"></span><br><span class="line"># 加密方式选择，系统默认是 'unix_socket'，这里暂为空</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> <span class="keyword">plugin</span>=<span class="string">''</span> <span class="keyword">WHERE</span> <span class="keyword">user</span>=<span class="string">'root'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> <span class="keyword">password</span>=<span class="keyword">PASSWORD</span>(<span class="string">'你自己的密码'</span>) <span class="keyword">WHERE</span> <span class="keyword">user</span>=<span class="string">'root'</span>;</span><br><span class="line"></span><br><span class="line">flush privileges; # 清空缓存</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure></li><li><p>操作数据库 ( 配置完信息，重启 MySQL 以让设置生效 )</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudo /etc/init.d/mysql status/start/stop/restart</span></span><br><span class="line">sudo /etc/init.d/mysql restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然可通过 systemctl 命令管理系统服务</span></span><br><span class="line"><span class="comment"># sudo systemctl restart mysql # 重启系统服务</span></span><br><span class="line"><span class="comment"># sudo systemctl status mysql # 查看系统状态</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="开启远程访问"><a href="#开启远程访问" class="headerlink" title="开启远程访问"></a>开启远程访问</h4><p>以上配置工作完成后，即可本地使用 MySQL 数据库了。若需要开启远程访问服务，我们还需要实现以下工作：防火墙与访问规则配置和远程登录的账号配置。</p><h5 id="外网访问"><a href="#外网访问" class="headerlink" title="外网访问"></a>外网访问</h5><p>若在树莓派下测试，让数据库允许外网访问，注意得关闭防火墙或添加规则允许某端口的访问权限 $^{[4]}$。</p><ul><li>Case.01：本机和服务器端 ( 树莓派 ) 互相 Ping 对方 IP，以检验网络是否畅通、是否拒绝访问。</li><li><p>Case.02：若网络畅通、没有拒绝访问，还要留意对应端口是否有权限访问，通过 nc -vz IP 端口检验，返回 Succeeded 即成功。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MacOS：nc -vz IP地址 端口号</span></span><br><span class="line">nc -vz 192.168.x.x 3306</span><br><span class="line"><span class="comment"># Windows：telnet IP地址 端口号</span></span><br><span class="line">telnet 192.168.x.x 22 <span class="comment"># SSH 远程访问</span></span><br><span class="line">telnet 192.168.x.x 3306 <span class="comment"># MySQL 数据库</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="防火墙与访问规则"><a href="#防火墙与访问规则" class="headerlink" title="防火墙与访问规则"></a>防火墙与访问规则</h5><p>针对上述两种情况，则可通过关闭防火墙或者添加端口的访问规则，以授权 IP 和相关端口接受访问。</p><ul><li><p>配置防火墙：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 ufw ( 已安装忽略 )</span></span><br><span class="line">sudo apt-get install ufw</span><br><span class="line"><span class="comment"># 设置默认规则为 allow，除指明打开的端口，所有端口默认关闭</span></span><br><span class="line">ufw default deny</span><br><span class="line"><span class="comment"># 启用 /关闭 ufw</span></span><br><span class="line">ufw <span class="built_in">enable</span>/<span class="built_in">disable</span></span><br><span class="line"><span class="comment"># 查看防火墙状态</span></span><br><span class="line">ufw status</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>配置访问规则：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如：打开 SSH 远程登录</span></span><br><span class="line">sudo ufw allow 22</span><br><span class="line"><span class="comment"># 删除添加过的规则</span></span><br><span class="line">sudo ufw delete allow 22</span><br></pre></td></tr></table></figure></li></ul><h5 id="远程登录的账号"><a href="#远程登录的账号" class="headerlink" title="远程登录的账号"></a>远程登录的账号</h5><p>最后，我们还需要设置可远程登录的账号。</p><ul><li><p>修改 MySQL 配置：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/mysql/mariadb.conf.d/50-server.cnf</span><br><span class="line"><span class="comment"># 找到 bind-address 这行注释掉，然后重启</span></span><br><span class="line">sudo systemctl restart mysql</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>修改 MySQL 账号信息：在配置 <code>登录信息</code> 时已授权，此项可日后用作远程登录账号的配置。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line"><span class="keyword">use</span> mysql;</span><br><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'root账号密码'</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Jupyter-服务器"><a href="#Jupyter-服务器" class="headerlink" title="Jupyter 服务器"></a>Jupyter 服务器</h3><h4 id="引言-2"><a href="#引言-2" class="headerlink" title="引言"></a>引言</h4><p>Jupyter Notebooks 是什么？相信做数据科学项目的同学都清楚，Jupyter 其提供了一个集成环境，无需更多附加操作就可在其中编写你的代码、运行代码、查看输出、可视化数据并查看结果。</p><p>作为一款可执行端到端的数据科学工作流程的便捷工具，它不仅支持数据清理、统计建模、构建和训练机器学习模型、可视化数据等数据科学工作，而且其强大的交互性，使得它可以更具教学性的方式展示代码。</p><blockquote><p>当然 Jupyter 也能运行其他 Python 程序，这里只是为了代入特定场景介绍它。</p></blockquote><h4 id="安装-Jupyter-Notebook"><a href="#安装-Jupyter-Notebook" class="headerlink" title="安装 Jupyter Notebook"></a>安装 Jupyter Notebook</h4><ul><li><p>在此之前，需要确保你安装了 <code>Python</code> 以及 <code>pip</code> 模块。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 树莓派 Raspbian 原生内置了 Python 2.7</span></span><br><span class="line"><span class="comment"># 我们需要基于 Python 3.x 基础上运作 Jupyter，则需要先安装 Python 3.x</span></span><br><span class="line">sudo apt-get install python3.5 python3-pip</span><br></pre></td></tr></table></figure></li><li><p>安装 Jupyter Notebook：</p><blockquote><p>若你已经有使用 virtualenv 的经验，强烈建议在虚拟环境中安装所需版本的 jupyter notebook。</p></blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于 Python 2.7</span></span><br><span class="line">pip install --upgrade jupyter</span><br><span class="line"><span class="comment"># 基于 Python 3.x</span></span><br><span class="line">pip3 install --upgrade jupyter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否安装成功，成功返回版本号</span></span><br><span class="line">jupyter --version</span><br></pre></td></tr></table></figure></li></ul><h4 id="配置-Jupyter-Notebook"><a href="#配置-Jupyter-Notebook" class="headerlink" title="配置 Jupyter Notebook"></a>配置 Jupyter Notebook</h4><p>配置 Jupyter Notebook，参考了文档 <a href="https://www.jianshu.com/p/639c8d939643" target="_blank" rel="noopener">[7]</a>：</p><ul><li><p>生成配置文件：注意不同用户组，生成的配置文件是存放在不同位置的。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件存放于 /root/.jupyter/jupyter_notebook_config.py </span></span><br><span class="line">sudo jupyter notebook --generate-config</span><br><span class="line"><span class="comment"># 配置文件存放于 /home/pi/.jupyter/jupyter_notebook_config.py ( 推荐 )</span></span><br><span class="line"><span class="comment"># /home/pi/ 为当前登录用户的工作目录</span></span><br><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure></li><li><p>设置密码：终端进入 iPython / Python 环境，借助 Python 生成 SHA 密钥：</p><blockquote><p>若不开启远程服务，则可跳过此步骤。</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd <span class="comment"># 导入授权模块设置密码</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>passwd() <span class="comment"># 提示键入密码</span></span><br><span class="line">Enter password: your password</span><br><span class="line">Verify password: your password again</span><br><span class="line"><span class="comment"># 密码的哈希值，用于配置文件中设置密码</span></span><br><span class="line"><span class="string">'sha1:67c9e601de......7d111089e11aed'</span></span><br></pre></td></tr></table></figure></li><li><p>进入配置文件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /home/pi/.jupyter/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>修改配置内容：配置选项非常丰富，关于其他配置的选项用途详细可参考 <code>jupyter_notebook_config.py</code> 内的注释。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意开启配置选项，记得去掉 #，才能使配置生效！</span></span><br><span class="line"><span class="comment"># 允许所有 IP 访问</span></span><br><span class="line">c.NotebookApp.ip=<span class="string">'*'</span></span><br><span class="line"><span class="comment"># 远程访问密钥</span></span><br><span class="line">c.NotebookApp.password = u<span class="string">'sha:67c9e......11aed'</span></span><br><span class="line"><span class="comment"># 不在本机自动打开浏览器</span></span><br><span class="line">c.NotebookApp.open_browser = False</span><br><span class="line"><span class="comment"># 指定监听端口</span></span><br><span class="line">c.NotebookApp.port =8888</span><br><span class="line"><span class="comment"># Jupyter 的默认工作目录</span></span><br><span class="line">c.NotebookApp.notebook_dir = <span class="string">'/home/pi/ipynb/'</span></span><br><span class="line"><span class="comment"># 允许使用 root 用户启动 jupyter</span></span><br><span class="line"><span class="comment"># c.NotebookApp.allow_root = True</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>启动 Jupyter Notebook：<code>jupyter notebook</code></li></ul><h4 id="拓展-Jupyter-Notebook"><a href="#拓展-Jupyter-Notebook" class="headerlink" title="拓展 Jupyter Notebook"></a>拓展 Jupyter Notebook</h4><h5 id="开启远程访问-1"><a href="#开启远程访问-1" class="headerlink" title="开启远程访问"></a>开启远程访问</h5><p>Jupyter Notebook 开启远程访问 ( 远程访问这里指同一局域网，其他终端访问树莓派，若是要外网访问请参阅内网穿透相关内容 )，但端口被拒绝访问。</p><ul><li><p>在配置文件中，我们只设置了 <code>0.0.0.0</code> 或 <code>*</code> 的 IP 地址，在局域网环境运行能正常访问。但对于远程访问，归根结底，我们还需要知道树莓派的 IP 才能访问到服务端的 Jupyter，故我们是这样解决访问问题的 $^{[7]}$。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nohup: 一直执行命令，即使关闭了 SSH。</span></span><br><span class="line"><span class="comment"># --ip: 指定在 192.168.10.200 ( 树莓派的IP ) 上监听活动。</span></span><br><span class="line"><span class="comment"># &amp;: 在后台运行这条命令。</span></span><br><span class="line">nohup jupyter notebook --ip 192.168.10.200 &amp;</span><br></pre></td></tr></table></figure></li><li><p>最后，我们需要确保该端口是否在安全策略下已经开启，详细可参考 MySQL 数据库的 <a href="#防火墙与访问规则">防火墙与访问规则</a> 章节内容。</p></li></ul><h5 id="开启自启服务"><a href="#开启自启服务" class="headerlink" title="开启自启服务"></a>开启自启服务</h5><p>搭建 Jupyter 服务器，Jupyter 挂靠后台服务，且开通断电自动重启功能，参考了文档 <a href="https://blog.csdn.net/q361949240/article/details/83179560" target="_blank" rel="noopener">[8]</a>。</p><ul><li><p>在 <code>/etc/systemd/system</code> 下创建 <code>jupyter.service</code> 输入如下内容：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/sytemd/system/jupyter.service</span><br></pre></td></tr></table></figure></li><li><p><code>jupyter.service</code> 内容填写如下：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Jupyter Notebook</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line"><span class="comment"># 这里在 /run 目录下没有 jupyter.pid</span></span><br><span class="line"><span class="comment"># 这个是进程产生之后出现的，虽然在启动前没有，但是可以使用</span></span><br><span class="line">PIDFile=/run/jupyter.pid</span><br><span class="line"><span class="comment"># ExecStart 是执行文件 jupyter-notebook</span></span><br><span class="line"><span class="comment"># config 是配置文件 jupyter_notebook_config.py</span></span><br><span class="line"><span class="comment"># ip 是树莓派的地址</span></span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/jupyter-notebook --config=/home/pi/.jupyter/jupyter_notebook_config.py --ip=192.168.10.200</span><br><span class="line">User=pi</span><br><span class="line"><span class="comment"># 查看用户组 groups pi，发现属于 pi 组</span></span><br><span class="line">Group=pi</span><br><span class="line"><span class="comment"># 自己设置的工作目录</span></span><br><span class="line"><span class="comment"># 需同时在 jupyter_notebook_config.py 中设置</span></span><br><span class="line"><span class="comment"># c.NotebookApp.notebook_dir = '/home/pi/ipynb/'</span></span><br><span class="line">WorkingDirectory=/home/pi/ipynb/</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li><li><p>使服务自启动：<code>systemctl enable jupyter</code></p></li><li>启动服务：<code>service jupyter start</code></li></ul><h5 id="加载虚拟环境"><a href="#加载虚拟环境" class="headerlink" title="加载虚拟环境"></a>加载虚拟环境</h5><ul><li><p>首先，我们为 Jupyter Notebook 创建隔绝的虚拟环境，从而便捷、更针对地管理软件包。</p><blockquote><p>比如，某个 Python 程序需要 Python 2.7 特定环境运行，而我们编译的环境是 Python 3.x ，即为了运行该程序需要把原来的 Python 3.x 给替换成 Python 2.7。同理，对于程序的依赖包，即使是同一个软件包也存在不同版本的要求。那么问题就出现在这，在同一台电脑上，为让更多程序兼容运行，这正是虚拟环境的作用之一。  </p></blockquote></li><li><p>再者，引入 <a href="#Conda-管理器">Conda 管理器</a> 的概念，简单来说 Conda 是一款包管理系统。conda 与 pip 类似，它会根据你的键入需求，且自行交代清楚相互依赖的包，并实现自动化地下载、安装它们。</p></li><li><p>基于以上两点的理解，我们正式进入正题，开始配置一个虚拟环境，并让 Jupyter Notebook 使用起来：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 参考 Conda 管理器的 BerryConda 小节，完成 BerryConda 的安装</span></span><br><span class="line"><span class="comment"># 2. 建立一个虚拟环境运作 Conda 以方便管理各种包</span></span><br><span class="line">conda create -n your_venv_name python=3.6</span><br><span class="line"><span class="comment"># 3. 激活环境</span></span><br><span class="line"><span class="built_in">source</span> activate your_venv_name</span><br><span class="line"><span class="comment"># 4. 安装 Jupyter 包：上述内容中，Jupyter 是安装在原生环境下的</span></span><br><span class="line"><span class="comment"># 考虑到兼容性的情况 (例如第5点的情况)，在该虚拟环境中重新安装一个 Jupyter</span></span><br><span class="line">conda install jupyter</span><br><span class="line"><span class="comment"># 给该环境下载其他软件包也是类似操作</span></span><br><span class="line"><span class="comment"># conda install scipy numpy scikit-learn...</span></span><br><span class="line"><span class="comment"># 5. 指定版本安装 tornado，不然 Jupyter 会报错</span></span><br><span class="line">conda install tornado=4.5</span><br><span class="line"><span class="comment"># 6. 安装 nb_conda 包，让 Jupyter 支持使用虚拟环境</span></span><br><span class="line">conda install nb_conda</span><br></pre></td></tr></table></figure></li><li><p>若使用虚拟环境中的 Jupyter ( 自启服务的 ExecStart 设置同理 )，此时启动 Jupyter 的程序应该改为：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /home/pi/ 为当前登录用户的工作目录</span></span><br><span class="line">/home/pi/berryconda3/envs/your_venv_name/bin/jupyter-notebook</span><br></pre></td></tr></table></figure></li></ul><h5 id="打造科学环境"><a href="#打造科学环境" class="headerlink" title="打造科学环境"></a>打造科学环境</h5><h6 id="Tensorflow"><a href="#Tensorflow" class="headerlink" title="Tensorflow"></a>Tensorflow</h6><p>值得庆贺的是，<a href="https://medium.com/tensorflow/tensorflow-1-9-officially-supports-the-raspberry-pi-b91669b0aa0" target="_blank" rel="noopener">Tensorflow 1.9</a> 官方版本开始支持树莓派 RaspBerry Pi 了，没有繁琐的步骤即可体验 Tensorflow！具体的安装方法大概参考 <a href="https://tensorflow.google.cn/install/pip" target="_blank" rel="noopener">Tensorflow 官方说明文档</a>。</p><ul><li><p>但在实操过程中还是碰到了不可预计的情况：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装 libatlas-base-dev (Required for Numpy)</span></span><br><span class="line">sudo apt install libatlas-base-dev</span><br><span class="line"><span class="comment"># 2. 同样，在虚拟环境内安装 tensorflow，虚拟环境的 Python 版本为 3.6</span></span><br><span class="line"><span class="built_in">source</span> activate your_venv_name</span><br><span class="line"><span class="comment"># 3. 安装 h5py、hdf5，不然 tf 安装过程中会报错 ( 缺少 hdf5.h 文件 )：</span></span><br><span class="line"><span class="comment"># /tmp/pip-install-ve4RnJ/h5py/h5py/api_compat.h:27:18: </span></span><br><span class="line"><span class="comment"># fatal error: hdf5.h: No such file or directory</span></span><br><span class="line"><span class="comment"># 4. 通过 conda 安装 h5py ( 好像 pip (Python3.x) 安装 h5py 会遇到缺少文件的问题？)</span></span><br><span class="line">conda install h5py </span><br><span class="line"><span class="comment"># 5. 正式安装 tensorflow</span></span><br><span class="line"><span class="comment"># pip --version 查看是否是虚拟环境的 pip，不然未能安装在当前环境</span></span><br><span class="line">pip install --upgrade --user tensorflow</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>若中途不出错、不提示错误，等待安装成功即可。然后输入代码测试验证：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python <span class="comment"># 命令进入 ipython / python 模式</span></span><br><span class="line">&gt;&gt;&gt; import tensorflow as tf</span><br><span class="line">&gt;&gt;&gt; tf.enable_eager_execution()</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>( tf.reduce_sum(tf.random_normal([1000, 1000])) )</span><br></pre></td></tr></table></figure></li><li><p>当然，还可能遇到 tensorflow 部分模块的 Python 版本跟编译环境的 Python 版本对不上，则可通过针对 ( 编译环境的 ) Python 版本的 pip 升级 tensorflow 解决此问题：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 异常的情况大概如下：</span></span><br><span class="line"><span class="comment"># /usr/lib/python3.6/importlib/_bootstrap.py:219: </span></span><br><span class="line"><span class="comment"># RuntimeWarning: compiletime version 3.5 of module 'tensorflow.python.framework.fast_tensor_util' </span></span><br><span class="line"><span class="comment"># does not match runtime version 3.6</span></span><br><span class="line">python3.6 -m pip install --upgrade --user tensorflow</span><br></pre></td></tr></table></figure></li></ul><h6 id="Keras"><a href="#Keras" class="headerlink" title="Keras"></a>Keras</h6><ul><li><p>安装过程演示：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 同样，在虚拟环境内安装 keras，虚拟环境的 Python 版本为 3.6</span></span><br><span class="line"><span class="built_in">source</span> activate your_venv_name</span><br><span class="line"><span class="comment"># 2. 正式安装 keras</span></span><br><span class="line"><span class="comment"># pip --version 查看是否是虚拟环境的 pip，不然未能安装在当前环境</span></span><br><span class="line">pip install --upgrade --user keras</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>当然，还可能遇到版本对不上的异常，参考 上述解决方案：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3.6 -m pip install --upgrade --user keras</span><br></pre></td></tr></table></figure></li></ul><h5 id="常见问题整理"><a href="#常见问题整理" class="headerlink" title="常见问题整理"></a>常见问题整理</h5><ul><li><p>当新建或修改 ipynb 文档时，出现 <code>Permission denied: Untitled.ipynb</code> 权限异常，检查工作目录是否具有操作权限、当前用户是否有操作权限。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保 Jupyter 工作目录属于当前登录用户 pi</span></span><br><span class="line">sudo chown -R pi:pi /home/pi/ipynb</span><br><span class="line"><span class="comment"># 确保 Jupyter 工作目录有可读、可写和可执行的权限</span></span><br><span class="line"><span class="comment"># 更新后的权限情况：drwxrwxr--</span></span><br><span class="line">chmod ug=rwx /home/pi/ipynb</span><br></pre></td></tr></table></figure></li></ul><h3 id="Conda-管理器"><a href="#Conda-管理器" class="headerlink" title="Conda 管理器"></a>Conda 管理器</h3><h4 id="引言-3"><a href="#引言-3" class="headerlink" title="引言"></a>引言</h4><p>无论是使用 Jupyter Notebook，亦或是原生 Python 环境做 <code>数据科学</code> 相关工作，难免需要 <code>安装各种科学计算包</code>，而且还涉及众多依赖包的安装。那么如何管理包变成了一门 “手艺活” 了，此时推荐你使用 Conda 包管理系统，繁琐的包安装工作交由 Conda 处理，你只管专心地开展数据科学工作。</p><p>参考 <a href="https://www.zhihu.com/question/65430209" target="_blank" rel="noopener">树莓派 Raspbian 系统可安装 Anaconda 吗？</a>，得知树莓派安装 Conda 共有两种选择：</p><ul><li><a href="https://conda.io/en/latest/miniconda.html" target="_blank" rel="noopener">MiniConda</a>：年久未更，目前 Python 只停留在 Python 3.4 版本。</li><li><a href="https://github.com/jjhelmus/berryconda" target="_blank" rel="noopener">BerryConda</a>：是一款为树莓派定制基于 Conda Python 发行版的开源软件。Berryconda 提供了 Python 2.7 的 Berryconda 2 和 Python 3.6 的 Berryconda 3，同时还支持树莓派 0、1、2、3 各个系列，我们可根据树莓派的版本选择适合的软件版本安装即可。</li></ul><h4 id="Miniconda"><a href="#Miniconda" class="headerlink" title="Miniconda"></a>Miniconda</h4><p>Miniconda 与 Anaconda 同为发行版本的 Conda 包管理系统，Miniconda 则是最小的 Conda 安装环境。以下直接安装操作演示，安装过程参考了 <a href="https://blog.csdn.net/tju_cc/article/details/80024721" target="_blank" rel="noopener">[9]</a>、<a href="https://www.jianshu.com/p/edaa744ea47d" target="_blank" rel="noopener">[10]</a>。</p><h5 id="安装-MiniConda"><a href="#安装-MiniConda" class="headerlink" title="安装 MiniConda"></a>安装 MiniConda</h5><ul><li><p>首先，确保安装了 <code>wget</code> 和 <code>bzip2</code>：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看是否有反馈，有则表示已安装</span></span><br><span class="line">wget --<span class="built_in">help</span></span><br><span class="line">bzip2 --<span class="built_in">help</span></span><br><span class="line">sudo apt-get install -y wget bzip2</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>下载安装脚本：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wget 不添加参数，默认是保存到当前路径</span></span><br><span class="line"><span class="comment"># wget -O /path/name 指定路径及文件名</span></span><br><span class="line">wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-armv7l.sh</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>运行安装脚本：</p><blockquote><p>安装过程中不需要使用 sudo，程序默认会安装到 /home/pi/miniconda3 中。当然，也是为了确保 miniconda3 工作目录属于当前登录用户 pi。</p></blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bash Miniconda3-latest-Linux-armv7l.sh</span><br><span class="line"><span class="comment"># 安装过程中，需要阅读一份声明，后面需要输入两次 Yes 确认</span></span><br><span class="line"><span class="comment"># 第一个 Yes 是是否同意声明，若回车跳过则是默认输入了 No</span></span><br><span class="line"><span class="comment"># 第二个 Yes 是添加到环境变量，否则需要自己手动添加到环境变量</span></span><br><span class="line"><span class="comment"># --------- 若选择了 No 则需进行以下步骤的操作 --------- #</span></span><br><span class="line"><span class="comment"># 1. 编辑 /bashrc 文件</span></span><br><span class="line">vim /home/pi/.bashrc</span><br><span class="line"><span class="comment"># 2. 添加以下内容 (根据自己的安装路径修改)：</span></span><br><span class="line"><span class="comment"># export PATH="/home/pi/miniconda3/bin:$PATH"</span></span><br><span class="line"><span class="comment"># 3. 添加完成后记得让其生效 ( 启动时才执行原则 )</span></span><br><span class="line"><span class="comment"># export 生成的环境变量是临时的，关闭终端即结束 ( 可改永久性环境变量 )</span></span><br><span class="line"><span class="built_in">source</span> /home/pi/.bashrc</span><br></pre></td></tr></table></figure></li></ul><h5 id="使用-MiniConda"><a href="#使用-MiniConda" class="headerlink" title="使用 MiniConda"></a>使用 MiniConda</h5><ul><li><p>检查 conda 是否安装成功，返回版本信息：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查 conda 是否安装成功，返回版本信息</span></span><br><span class="line">conda --version</span><br><span class="line"><span class="comment"># 显示当前已经安装好的包</span></span><br><span class="line">conda list</span><br></pre></td></tr></table></figure></li><li><p><code>创建虚拟环境</code>，以避免 “污染” 环境，便于管理各种 Python 包：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立一个虚拟环境运作 Conda 以方便管理各种包</span></span><br><span class="line">conda create -n your_venv_name python=3.4</span><br><span class="line"><span class="comment"># 删除一个虚拟环境：</span></span><br><span class="line"><span class="comment"># conda env remove -n your_venv_name</span></span><br><span class="line"><span class="comment"># 激活环境 &lt;---&gt; 关闭环境：source deactivate</span></span><br><span class="line"><span class="built_in">source</span> activate your_venv_name</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>更改国内源，优化安装包下载速度：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加国内下载源 ( 例如: 清华源 )</span></span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line"><span class="comment"># 替换源后记得更新 Conda 以促使配置生效</span></span><br><span class="line">conda update conda</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用 Conda 安装包:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事先查找指定软件是否存在</span></span><br><span class="line">conda search numpy</span><br><span class="line"><span class="comment"># 安装指定软件</span></span><br><span class="line">conda install numpy</span><br><span class="line"><span class="comment"># 安装特定版本的软件，Conda 会先卸载已安装版本，然后重新安装指定版本</span></span><br><span class="line">conda install 软件名=版本号</span><br><span class="line"><span class="comment"># 更新指定软件</span></span><br><span class="line">conda update numpy</span><br><span class="line"><span class="comment"># 卸载指定软件</span></span><br><span class="line">conda remove numpy</span><br></pre></td></tr></table></figure></li></ul><h5 id="卸载-MiniConda"><a href="#卸载-MiniConda" class="headerlink" title="卸载 MiniConda"></a>卸载 MiniConda</h5><ul><li><p>卸载 MiniConda 的方法：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 在 /home/pi/.bashrc 移除环境变量 ( 注释掉 )</span></span><br><span class="line"><span class="comment"># export PATH="/home/pi/miniconda3/bin:$PATH"</span></span><br><span class="line"><span class="comment"># 2. 删除 miniconda 整个文件</span></span><br><span class="line">rm -rf miniconda3/</span><br><span class="line"><span class="comment"># 3. 重新激活 .bashrc</span></span><br><span class="line"><span class="built_in">source</span> /home/pi/.bashrc</span><br></pre></td></tr></table></figure></li></ul><h4 id="BerryConda"><a href="#BerryConda" class="headerlink" title="BerryConda"></a>BerryConda</h4><p>BerryConda 是一款为树莓派定制基于 conda python 发行版的开源软件。安装过程参考了 <a href="https://www.jianshu.com/p/ccad38dbb897" target="_blank" rel="noopener">[11]</a>。</p><h5 id="安装-BerryConda"><a href="#安装-BerryConda" class="headerlink" title="安装 BerryConda"></a>安装 BerryConda</h5><ul><li><p>参考 <a href="https://github.com/jjhelmus/berryconda" target="_blank" rel="noopener">BerryConda</a> 文档，根据自己的机器版本 ( 树莓派 3B+ / Armv7l 架构 )，并确定 Python 版本号 ( Python 3.x )，为此选择了 Berryconda 3 版本安装，安装方法与 Miniconda 类似。</p></li><li><p>下载安装脚本：</p><blockquote><p>安装过程中不需要使用 sudo，程序默认会安装到 /home/pi/berryconda3 中。当然，也是为了确保 berryconda3 工作目录属于当前登录用户 pi。</p></blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/jjhelmus/berryconda/releases/download/v2.0.0/Berryconda3-2.0.0-Linux-armv7l.sh</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>执行安装脚本：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bash Berryconda3-2.0.0-Linux-armv7l.sh</span><br><span class="line"><span class="comment"># 安装过程中，需要阅读一份声明，后面需要输入两次 Yes 确认</span></span><br><span class="line"><span class="comment"># 第一个 Yes 是是否同意声明，若回车跳过则是默认输入了 No</span></span><br><span class="line"><span class="comment"># 第二个 Yes 是添加到环境变量，否则需要自己手动添加到环境变量</span></span><br><span class="line"><span class="comment"># --------- 若选择了 No 则需进行以下步骤的操作 --------- #</span></span><br><span class="line"><span class="comment"># 1. 编辑 /bashrc 文件</span></span><br><span class="line">vim /home/pi/.bashrc</span><br><span class="line"><span class="comment"># 2. 添加以下内容 (根据自己的安装路径修改)：</span></span><br><span class="line"><span class="comment"># export PATH="/home/pi/miniconda3/bin:$PATH"</span></span><br><span class="line"><span class="comment"># 3. 添加完成后记得让其生效</span></span><br><span class="line"><span class="comment"># export 生成的环境变量是临时的，关闭终端即结束 ( 可改永久性环境变量 )</span></span><br><span class="line"><span class="built_in">source</span> /home/pi/.bashrc</span><br></pre></td></tr></table></figure></li></ul><h5 id="使用-BerryConda"><a href="#使用-BerryConda" class="headerlink" title="使用 BerryConda"></a>使用 BerryConda</h5><ul><li><p>至此，BerryConda 已经安装完成，查看版本信息检验是否安装成功，剩余的 Conda 操作参考 <a href="#使用-MiniConda">使用 MiniConda</a> 章节即可。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查 conda 是否安装成功，返回版本信息</span></span><br><span class="line">conda --version</span><br><span class="line"><span class="comment"># 显示当前已经安装好的包</span></span><br><span class="line">conda list</span><br></pre></td></tr></table></figure></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://baike.baidu.com/item/存储引擎" target="_blank" rel="noopener">百度百科. 存储引擎. baike.baidu.com</a></li><li>[2] <a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md" target="_blank" rel="noopener">jaywcjlove. mysql-tutorial. 2017. github.com</a></li><li>[3] <a href="https://www.cnblogs.com/apanly/p/9061803.html" target="_blank" rel="noopener">编程浪子. 树莓派3之安装Mysql服务. 2018. cnblogs.com</a></li><li>[4] <a href="https://blog.csdn.net/faryang/article/details/50788795" target="_blank" rel="noopener">farYang. 树莓派安装mysql并开启远程访问. 2016. csdn.net</a></li><li>[5] <a href="http://www.52pi.net/archives/549" target="_blank" rel="noopener">Li, TaterLi. 十步配置TeamViewer远程控制Pi. 2017. 52pi.net</a></li><li>[6] <a href="https://blog.csdn.net/realDonaldTrump/article/details/79694196" target="_blank" rel="noopener">萝是carrot夢是Dream. 树莓派安装配置TeamViewer实现外网远程控制. 2018. csdn.net</a></li><li>[7] <a href="https://www.jianshu.com/p/639c8d939643" target="_blank" rel="noopener">终可见. 树莓派 3B 搭建 Jupyter notebook. 2018. jianshu.com</a></li><li>[8] <a href="https://blog.csdn.net/q361949240/article/details/83179560" target="_blank" rel="noopener">齐志刚. 树莓派 3B Jupyter notebook 设置为后台服务. 2018. csdn.net</a></li><li>[9] <a href="https://blog.csdn.net/tju_cc/article/details/80024721" target="_blank" rel="noopener">Holy_C. 树莓派 miniconda3+opencv3.3+tensorflow1.7 踩坑总结. 2018. csdn.net</a></li><li>[10] <a href="https://www.jianshu.com/p/edaa744ea47d" target="_blank" rel="noopener">卖萌哥. Conda 的安装与使用. 2018. jiansu.com</a></li><li>[11] <a href="https://www.jianshu.com/p/ccad38dbb897" target="_blank" rel="noopener">Speculatecat. 解决 Raspbian Miniconda 无法安装最新 Python3.6. 2018. jianshu.com</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树莓派能做什么？关于此命题，最直观感受就是看看树莓派实验室整理的一些&lt;a href=&quot;http://shumeipai.nxez.com/what-raspi-used-for&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;案例&lt;/a&gt;，相信你心目中会有答案的。例如，打造一个家庭媒体中心 ( KODI )、配置无线路由器、搭建 BT 下载服务器、搭建代码托管服务器 ( SVN、GIt )、搭建网站服务器、搭建 Shadowsocks、用 HomeKit + Siri 声控家里电器等，即可把树莓派想象成嵌入式、微小型的服务器，这一过程就好比操作系统 ( Linux ) 赋予硬件生命，编程 ( Python、Java )、程序灌入灵魂，借助树莓派低能耗、移动便携性、GPIO 等特性，很多想法不是不可能，相信树莓派会给你创造更多的惊喜！&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://www.kofes.cn/categories/Technique/"/>
    
    
      <category term="树莓派" scheme="http://www.kofes.cn/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="Raspbian" scheme="http://www.kofes.cn/tags/Raspbian/"/>
    
      <category term="博客搭建" scheme="http://www.kofes.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
      <category term="服务器" scheme="http://www.kofes.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="数据科学" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>讲座 | 利用 t-SNE 降维并可视化数据</title>
    <link href="http://www.kofes.cn/2018/11/The-Best-Way-to-Visualize-a-Dataset-Easily.html"/>
    <id>http://www.kofes.cn/2018/11/The-Best-Way-to-Visualize-a-Dataset-Easily.html</id>
    <published>2018-11-21T07:43:57.000Z</published>
    <updated>2019-07-27T14:44:02.957Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p>作者：Siraj Raval<br>课堂：The Best Way to Visualize a Dataset Easily | <a href="https://www.bilibili.com/video/av35768109" target="_blank" rel="noopener">Bilibili</a> | <a href="https://www.youtube.com/watch?v=yQsOFWqpjkE" target="_blank" rel="noopener">Youtube</a><br>源码：llSourcell.Visualize_dataset_demo | <a href="https://github.com/llSourcell/visualize_dataset_demo" target="_blank" rel="noopener">Github</a>  </p></div><ul><li><p><code>目标</code>：在本次课堂中，将对人类活动识别 ( Human Activity Recognition，HAR ) 数据集进行数据可视化呈现，并进行探索性分析以发现知识。而本课堂具体目标则是人类活动状态识别，活动状态包括：Sitting-down，Standing-up，Standing，Walking，Sitting。</p><p>  具体地，通过降维方法 <code>t-SNE</code> 实现不同活动状态的数据自动 “分类” ( 更准确地说应该是聚类 )，从而在低维度 ( 二维 ) 下复现数据 ( 的特征 )，以便我们理解数据、统计分析数据。</p></li><li><p><code>问题</code>：若我们要将要描述如此复杂的数据，即它们拥有的特征 ( 维度 ) 过多了，相对于人类大脑只能理解二维或三维的层面，如此复杂数据我们是难以从中发现知识的。</p></li><li><p><code>解决</code>：通过可视化数据来描述它们的特征，具体措施是使用机器学习中的降维方法 <code>T-SNE</code> ( Distributed Stochastic Neighbor Embedding )，把高维空间中的数据以二维或三维的形式表示。</p></li></ul><a id="more"></a><ul><li><p>HAR 数据集的数据来源：参与者绑上健身追踪设备，当它们运动起来时，追踪设备会记录这些身体指标数据。</p><blockquote><p>关于HAR 数据集更详细的描述请参考：<a href="http://groupware.les.inf.puc-rio.br/har#ixzz4Mt0Teae2" target="_blank" rel="noopener">HAR Set 介绍</a> | <a href="https://d396qusza40orc.cloudfront.net/predmachlearn/pml-training.csv" target="_blank" rel="noopener">HAR Set 下载</a></p></blockquote></li></ul><h2 id="观察数据"><a href="#观察数据" class="headerlink" title="观察数据"></a>观察数据</h2><ul><li>每一行数据代表不同的人。</li><li>每一列代表某人的身体指标测量数据，如手臂或者前臂的空间位置 ( x，y，z 坐标 )。</li><li>在人类活动识别数据集中，每一行 ( 实体 ) 都有类标签标记。且共有 5 种标签：Sitting-down，Standing-up，Standing，Walking，Sitting。</li></ul><h2 id="预处理数据"><a href="#预处理数据" class="headerlink" title="预处理数据"></a>预处理数据</h2><blockquote><p>关于 <code>预处理数据</code> 的详细解释，可参考另外一篇文章：<a href="https://www.kofes.cn/2018/11/the-best-way-to-prepare-a-dataset-easily.html">Kofe. 如何轻松有效地预处理数据</a></p></blockquote><ul><li><p><code>数据清洗</code>：缺失值处理、光滑噪声数据、识别和删除离群点。</p><blockquote><p>关于数据清洗，也推荐阅读具有实操意义的一篇博文：<a href="https://towardsdatascience.com/how-to-handle-missing-data-8646b18db0d4" target="_blank" rel="noopener">TowardsDataScience. How to Handle Missing Data</a></p></blockquote></li><li><p><code>数据集成</code>：多个数据源的数据合并，存放于同一个数据仓库中。</p><ul><li><code>实体识别问题</code>：来自多个信息源，各数据源中的实体之间如何匹配，这涉及实体识别问题。如不同数据来源于不同数据库中，现实意义上它们是同一实体，但它们属性的元数据表达却不同 ( 如主键 )。</li><li><code>冗余和相关分析</code>：集成多个数据源，数据中可能有多组属性重复存在。而冗余可被相关分析检测到，如分类 ( 标称 ) 属性的卡方检验、数值属性的相关系数、数值属性的方差和协方差。</li><li><code>元组重复</code>：元组级检测重复。</li></ul></li><li><p><code>数据归约</code>：在海量数据上进行复杂的数据分析和挖掘，需要时间很长且不显示。在尽可能保持数据原貌前提下，最大限度精简数据量。策略包括：</p><ul><li><code>维归约</code>：也称为特征归约，减少所考虑的属性的个数。方法包括：小波变换、主成分分析、属性子集选择等。当然利用冗余和相关分析也是可行的。</li><li><p><code>数量归约</code>：用替代的、较小的数据表示形式替换原数据 ( 是否可理解为合并多组特征成为新的特征 )。方法包括：参数的方法，回归和对数线性模型；非参数的方法，聚类、降维、直方图、抽样和数据立方体聚集。</p><blockquote><p>在本课堂中则使用了降维方法进行属性数量的归约，其中降维方法有：PCA、t-SNE $^{[4]}$、LargeVis $^{[5, 6]}$ 等。</p></blockquote></li></ul></li><li><p><code>数据变换</code>：主要思想是将数据变换或统一成适合数据挖掘的形式。方法可以是数据归一化、数据离散化、概念分层等。</p><ul><li><code>特征构造</code>：由给定的属性构造新的属性并添加至属性集中。</li><li><code>聚集分解</code>：对数据进行 <code>汇总</code> 或者 <code>聚集</code>。如聚集季度销售数据。与之相对的是 <code>分解</code>，如常见的 “日期” 属性，不同的需求，我们要解构的粒度是不同的。如预测当日的气温变化，则我们可把年和月份剔除。</li><li><code>归一化</code>：针对每一个特征 ( 维度 )，去均值和方差归一化。即把属性数据按比例缩放，让所有特征在统一数量级上运作，如此一来数据指标之间就有了可比性。</li><li><p><code>离散化</code>：数值属性的原始值用区间标签或者概念标签替换，即这些标签可递归地组织成更高层概念，导致数值属性的 <code>概念分层</code>。</p><blockquote><p>例如，我们    对年龄进行分层：1 to 17 为 Adolescent；18 to 45 为 Adult；46 以上为 Senior。</p></blockquote></li></ul></li></ul><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><h3 id="降维方法"><a href="#降维方法" class="headerlink" title="降维方法"></a>降维方法</h3><h4 id="降维目的"><a href="#降维目的" class="headerlink" title="降维目的"></a>降维目的</h4><ul><li>通过降维算法来寻找 <code>数据内部的本质结构特征</code>，如特征选择或特征提取。<ul><li><code>特征选择</code>：假定数据中包含大量冗余或无关变量 ( 或称特征、属性、指标等 )，旨在从原有变量中找出主要变量。其代表方法为 <a href="https://zh.wikipedia.org/wiki/Lasso%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">LASSO</a>。</li><li><code>特征提取</code>：是将高维数据转化为低维数据的过程。在此过程中可能舍弃原有数据、创造新的变量。其代表方法为 <a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90" target="_blank" rel="noopener">PCA</a>。</li></ul></li><li>在原始的高维空间中，包含有冗余信息、噪音信息。通过降维方法，<code>减少冗余信息</code> 所造成的误差，以提高模型的精度。</li></ul><h4 id="降维本质"><a href="#降维本质" class="headerlink" title="降维本质"></a>降维本质</h4><ul><li>机器学习领域中，降维指采用某种映射方法将原高维空间中的数据点映射到低维度的空间中。</li><li>降维的本质是学习一个映射函数 $ f : x \to y$，其中 $x$ 是原始数据点的表达，$y$ 是数据点映射后的低维向量表达 ( 通常 $y$ 的维度小于 $x$ 的维度 )。$f$ 可能是显式的或隐式的、线性的或非线性的映射函数 ( 例如本例提及的 PCA 或者 t-SNE )。</li><li>当我们意识到需要降维时，一般是发现了特征间的高度线性相关。若我们发现了线性相关，则适合使用 PCA 处理 $^{[1]}$，而 t-SNE 主打的是非线性降维。</li></ul><h4 id="降维算法"><a href="#降维算法" class="headerlink" title="降维算法"></a>降维算法</h4><h5 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h5><ul><li><p><code>PCA</code>：主成分分析算法 ( Principal Component Analysis，PCA )，是最常用的 <code>线性降维方法</code>。它通过某种线性投影，将高维的数据映射到低维的空间中表示。具体工作原理是，从原始的空间中顺序地找一组相互正交的坐标轴，而且新的坐标轴选择与数据本身是密切相关的。其中，第一个新坐标轴选择是原始数据中方差最大的方向，第二个新坐标轴选取是与第一个坐标轴正交的平面中使得方差最大的方向，若继续添加第三个坐标轴，第三个轴与第一、二个轴正交的平面中方差最大的。依次类推，可以得到 $n$ 个这样的坐标轴。</p><p>  而实际情况，大部分方差都包含在前面 $k$ 个坐标轴中，后面的坐标轴所含的方差几乎为 0。事实上实现对数据特征的降维处理，相当于只保留包含绝大部分方差的维度，而忽略包含方差几乎为 0 的维度。</p></li></ul><h5 id="SNE"><a href="#SNE" class="headerlink" title="SNE"></a>SNE</h5><ul><li><p><code>t-SNE</code> 可理解为 <code>SNE</code> 的特殊形式，我们先了解 SNE 的基本原理，再延伸学习 t-SNE ( 本小节可参考多篇博文比对学习，如参考资料中的 [2] - [3] )。</p></li><li><p>SNE 是通过 <a href="https://www.zhihu.com/question/20666664" target="_blank" rel="noopener">仿射变换</a> 将数据点映射到概率分布上，主要包括两个步骤：</p><ul><li><p>SNE 构建一个高维对象之间的概率分布，使得相似的对象有更高的概率被选择，而不相似的对象有较低的概率被选择。</p></li><li><p>SNE在低维空间里在构建这些点的概率分布，使之与高维度的概率分布之间尽可能相似。</p></li></ul></li><li><p>SNE 的实现原理：</p><ul><li><p>原始 SNE 先将 <code>欧几里得距离</code> 转换为 <code>条件概率</code> 来表达点与点之间的相似度。具体地，给定一个 $N$ 个高维的数据 $x_1, x_2, …, x_N$，$x_i$ 和 $x_j$ 之间的相似度可表示为 ( $x_i$ 为中心点 )： </p><script type="math/tex; mode=display">  p_{j|i} = \frac{      exp({-||x^{(i)} - x^{(j)}||}^2 / {      2\sigma_i^2})  }{       \sum_{k \neq i} exp({-||x^{(i)} - x^{(k)}||}^2 / {      2\sigma_i^2})  }  \tag{1}</script><p>  这里的有一个参数是 $\sigma_i$，其表示以 $x_i$ 为中心点的高斯分布的方差。且对于不同的点 $x_i$ 取值不一样 $^{[2]}$ ( 具体参详 SNE 的困惑度 ( Perplexity ) )。再者，由于我们只关心不同点两两之间的相似度，所以设定 $p_{i|i} = 0$。</p></li><li><p>在把数据映射到低维空间后，高维数据点之间的相似性也应该在低维空间的数据点上体现出来。这里同样用条件概率的形式描述，对于低维度下的 $y_i$，我们可以指定高斯分布为方差为 $\frac{1}{\sqrt2}$。因此它们之间的相似度为:</p><script type="math/tex; mode=display">q_{j|i} = \frac{  exp( {-||y^{(i)} - y^{(j)}||}^2 )}{   \sum_{k \neq i} exp( {-||y^{(i)} - y^{(k)}||}^2 )}\tag{2}</script></li><li><p>同理，设定 $q_{i|i} = 0$。这样一来，若 $y_i$ 和 $y_j$ 真实反映了高维数据点 $x_i$ 和 $x_j$ 之间的关系，那么条件概率 $p_{j|i}$ 与 $q_{j|i}$ 应该完全相等。</p><p>  这里我们只考虑 $x_i$ 与 $x_j$ 之间的条件概率，则它们可构成一个条件概率分布函数 $P$。同理，只考虑 $y_i$ 与 $y_j$ 之间的条件概率，在低维空间存在一个条件概率分布 $Q$，且应该与 $P$ 是一致的。</p><p>  如何衡量两个分布之间的相似性？则我们可通过优化两分布的距离，即 <code>K-L 散度</code> ( Kullback-Leibler Divergence )。SNE 最终目标就是对所有数据点最小化这个 K-L 散度，具体地，我们可使用 <code>梯度下降算法</code> 最小化以下代价函数：</p><script type="math/tex; mode=display">  C = D_{KL}(P || Q) = \sum_{i} \sum_{j} p_{j|i} log \frac{p_{j|i}}{q_{j|i}}  \tag{3}</script><p>  SNE 代价函数对 $y_i$ 求梯度后的形式如下：</p><script type="math/tex; mode=display">  \frac{\delta C}{\delta y_i} =   2 \sum_j ( p_{j|i} - q_{j|i} + p_{i|j} - q_{i|j} )( y_i - y_j )  \tag{4}</script></li><li><p>似乎到这里问题就解决了，得到代价函数，利用梯度下降算法进行训练了。但事情远没有那么简单，因为 K-L 散度是一个非对称的度量，最小化代价函数的目的是让 $pj|i$ 和 $qj|i$ 的值尽可能的接近，即低维空间中点的相似性应当与高维空间中点的相似性一致。</p><ul><li>但从代价函数的形式就可以看出，考虑到离群点的情况，当 $p_{j|i}$ 较大，$q_{j|i}$ 较小时，即高维空间中两个数据点距离较近，而映射到低维空间后距离较远，那么将得到一个很高的惩罚，这没什么问题；</li><li>而$p_{j|i}$ 较小，$q_{j|i}$ 较大时，即高维空间中两个数据点距离较远，而映射到低维空间距离较近，将得到一个很低的惩罚值。然而这就是问题所在，理应得到一个较高的惩罚才对。换句话说，SNE 的代价函数更关注局部结构，而忽视了全局结构。</li></ul></li></ul></li></ul><h5 id="t-SNE"><a href="#t-SNE" class="headerlink" title="t-SNE"></a>t-SNE</h5><div class="note success"><p>论文中对 t-SNE 原理描述是基于数学形式化的，更多细节或难以理解的，比如距离度量如何转化为概率度量、如何确定 $\sigma$、如何求梯度下降值等，建议阅读 t-SNE 的代码实现。</p><p>推荐 <a href="https://github.com/karpathy/tsnejs" target="_blank" rel="noopener">karpathy.tsnejs</a> 和 <a href="https://gist.github.com/bindog/0ac283fc4dbdeb4c954990ea5c3dcd87" target="_blank" rel="noopener">bindog.t-sne.js</a> (请科学上网)，需要说明的是，bindog 的版本是基于 karpathy 的，具体工作是添加了注释和 <a href="https://upload-images.jianshu.io/upload_images/415974-ab098a421189c1d0.png" target="_blank" rel="noopener">算法流程图</a> $^{[8]}$。</p></div><ul><li><p>在原始 SNE 中，$p_{i|j}$ 与 $p_{j|i}$ 是不相等的，低维空间中 $q_{i|j}$ 与 $q_{j|i}$ 也是不相等的。若我们分别在高维和低维空间构造更加通用的联合概率分布 $P$ 和 $Q$，使得对任意 i, j，均有 $p_{i|j} = p_{j|i}, \, q_{i|j} = q_{j|i}$。而这种 SNE 称之为对称 SNE ( Symmetric SNE )，因此它们的概率分布可改写为 ( 同理，我们只关注不同点两两之间的相似性，故设定 $p_{i||i} = 0, q_{i||i} = 0$ ):</p><script type="math/tex; mode=display">  p_{i, j} = \frac{          exp({-||x^{(i)} - x^{(j)}||}^2 / {          2\sigma_i^2})      }{           \sum_{k \neq l} exp({-||x^{(k)} - x^{(l)}||}^2 / {          2\sigma_i^2})      } \\  q_{i, j} = \frac{      exp( {-||y^{(i)} - y^{(j)}||}^2 )  }{       \sum_{k \neq l} exp( {-||y^{(k)} - y^{(l)}||}^2 )  }  \tag{5}</script></li><li><p>这样表达方式使得整体简洁了很多。但是会引入异常值的问题。比如，$x_i$ 是异常值，那么 $||x^{(i)} - x^{(j)}||^2$ 会很大，对应的所有的 $j$, $p_{i, j}$ 都会很小，导致低维映射下的 $y_i$ 无论处在什么位置，对代价函数影响很小。</p><p>  为了解决这个问题，我们将联合概率分布改写为：</p><script type="math/tex; mode=display">  p_{i,j} = \frac{      p_{j|i} + p_{i|j}   }{2N} \\  ( p_{j|i} = \frac{p_{i,j}}{p_i}, \,  p_{i|j} = \frac{p_{i,j}}{p_j}, \,  p_i = p_j = \frac1N )  \tag{6}</script></li><li><p>其中 N 为数据点的总数，这样定义即满足了对称性，又保证了 $x_i$ 的惩罚值不会过小。此时可以利用 KL 距离写出如下代价函数：</p><script type="math/tex; mode=display">  C = D_{KL}(P || Q) = \sum_{i} \sum_{j} p_{i, j} log \frac{p_{i, j}}{q_{i, j}}  \tag{7}</script></li><li><p>对称 SNE 的最大优点，即梯度计算变得简单了：</p><script type="math/tex; mode=display">  \frac{\delta C}{\delta y_i} =   4 \sum_j ( p_{i, j} - q_{i, j})( y_i - y_j )  \tag{8}</script><p>  但是Maaten 还指出 $^{[4]}$，对称 SNE 的效果只是略微优于原始 SNE 的效果，依然没有从根本上解决问题。我们还需要解决 <code>拥挤问题</code>。</p></li><li><p><code>拥挤问题</code>：就是说各个簇聚集在一起，无法区分。这是由于高维空间距离分布和低维空间距离分布的差异造成的。比如，有一高维度数据在降维到 10 维下可以有很好的表达，但是降维到两维后无法得到 “可信” 映射。</p><p>  进一步说明，假设一个以数据点 $x_i$ 为中心，半径为 $r$ 的 $m$ 维球 ( 三维空间就是球 )，其体积是按 $r^m$ 增长的，假设数据点是在 m 维球中均匀分布的，我们来看看其他数据点与 $x_i$ 的距离随维度增大而产生的变化。具体，我们可参考代码 $^{[3]}$：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> norm</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">npoints = <span class="number">1000</span><span class="comment"># 抽取 1000 个 m 维球内均匀分布的点</span></span><br><span class="line">plt.figure( figsize=(<span class="number">20</span>, <span class="number">4</span>) )</span><br><span class="line"><span class="keyword">for</span> i, m <span class="keyword">in</span> enumerate((<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>)):</span><br><span class="line">    <span class="comment"># 这里模拟 m 维球中的均匀分布用到了拒绝采样</span></span><br><span class="line">    <span class="comment"># 即先生成 m 维立方中的均匀分布，再剔除 m 维球外部的点</span></span><br><span class="line">    accepts = []</span><br><span class="line">    <span class="keyword">while</span> len(accepts) &lt; <span class="number">1000</span>:</span><br><span class="line">        points = np.random.rand(<span class="number">500</span>, m)</span><br><span class="line">        accepts.extend(</span><br><span class="line">            [d <span class="keyword">for</span> d <span class="keyword">in</span> norm(points, axis=<span class="number">1</span>) <span class="keyword">if</span> d &lt;= <span class="number">1.0</span>]</span><br><span class="line">        ) <span class="comment"># 拒绝采样</span></span><br><span class="line">    accepts = accepts[:npoints]</span><br><span class="line">    ax = plt.subplot(<span class="number">1</span>, <span class="number">4</span>, i+<span class="number">1</span>)</span><br><span class="line">    ax.set_xlabel(<span class="string">'distance'</span>) <span class="comment"># x 轴表示点到圆心的距离</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        ax.set_ylabel(<span class="string">'count'</span>) <span class="comment"># y 轴表示点的数量</span></span><br><span class="line">    ax.hist(accepts, bins=np.linspace(<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">50</span>), color=<span class="string">'green'</span>)</span><br><span class="line">    ax.set_title(<span class="string">'m=&#123;0&#125;'</span>.format(str(m)), loc=<span class="string">'left'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li><li><p>运行结果如图 2-1 所示。据图示反映，随着维度的增大，大部分数据点都聚集在 m 维球的表面附近，与点 $x_i$ 的距离分布极不均衡。若直接将这种距离关系保留到低维，肯定会出现拥挤问题。如何解决呢？这个时候就需要请出 $\tau$ 分布了。</p><p>  <img src="/images/illustration/Project/2018/11/The-Best-Way-to-Visualize-a-Dataset-Easily_2-1.jpg" alt="图2-1半径为 r 的 m 维球上的数据分布"></p>  <center>图 2-1 半径为 r 的 m 维球上的数据分布</center></li><li><p>减轻 <code>拥挤问题</code> 的方法：在高维空间下我们使用 <code>高斯分布</code> 将距离转换为概率分布；在低维空间下，我们使用更加 <code>偏重长尾分布</code> 的方式来将距离转换为概率分布，使得高维度下中低等的距离在映射后能够有一个较大的距离。使用了自由度为 1 的 $\tau$ 分布之后的 $q$ 变化，如下:</p><script type="math/tex; mode=display">  q_{i,j} = \frac{      (1 + ||y^{(i)} - y^{(j)}||^2)^{-1}  }{       \sum_{k \neq l} (1 + ||y^{(k)} - y^{(l)}||^2)^{-1}  }  \tag{9}</script><p>  依然用 K-L 距离衡量两个分布之间的相似性，此时梯度变为：</p><script type="math/tex; mode=display">  \frac{\delta C}{\delta y_i} =   4 \sum_j ( p_{i, j} - q_{i, j})( y_i - y_j )(1 + ||y^{(i)} - y^{(j)}||^2)^{-1}  \tag{10}</script></li><li><p><code>总结</code>：综上所述，从不对称的 SNE 算法到 t-SNE 算法，所做的改进工作：</p><ul><li>把 SNE 变为对称 SNE；</li><li>在低维空间中采用了 $\tau$ 分布代替原来的高斯分布，高维空间不变。</li><li><p>具体算法步骤可参考了文章 [7] 的 <a href="https://zhuanlan.zhihu.com/p/33722444" target="_blank" rel="noopener">t-SNE</a> 图文解释，如图 2-2 所示。</p><p><img src="/images/illustration/Project/2018/11/The-Best-Way-to-Visualize-a-Dataset-Easily_2-2.jpg" alt="图2-2t-SNE的算法步骤"></p><center>图 2-2 t-SNE 的算法步骤</center></li></ul></li></ul><h3 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://www.zhihu.com/question/52022955/answer/387753267" target="_blank" rel="noopener">微调. t-SNE 数据可视化算法的作用是为了降维还是认识数据. zhihu.com</a></li><li>[2] <a href="http://www.datakit.cn/blog/2017/02/05/t_sne_full.html#12-sne原理推导" target="_blank" rel="noopener">Chrispher. t-SNE 完整笔记 [OL]. datakit.cn. 2017</a></li><li>[3] <a href="http://bindog.github.io/blog/2016/06/04/from-sne-to-tsne-to-largevis/" target="_blank" rel="noopener">Bindog. 从 SNE 到 t-SNE 再到 LargeVis. bindog.github.io. 2016</a></li><li>[4] Maaten L, Hinton G. Visualizing data using t-SNE [J]. Journal of machine learning r/esearch, 2008, 9(Nov): 2579-2605.</li><li>[5] Tang J, Liu J, Zhang M, et al. Visualizing large-scale and high-dimensional data[C]. International World Wide Web Conferences Steering Committee, 2016: 287-297.</li><li>[6] Tang J, Qu M, Wang M, et al. Line: Large-scale information network embedding[C]. International World Wide Web Conferences Steering Committee, 2015: 1067-1077.</li><li>[7] <a href="https://zhuanlan.zhihu.com/p/33722444" target="_blank" rel="noopener">徐小贱民. 降维技术解析：PCA, t-SNE and Auto Encoders. zhihu.com</a></li><li>[8] <a href="https://www.jianshu.com/p/631d6529e0df" target="_blank" rel="noopener">Bindog. t-SNE使用过程中的一些坑. jianshu.com. 2018</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;作者：Siraj Raval&lt;br&gt;课堂：The Best Way to Visualize a Dataset Easily | &lt;a href=&quot;https://www.bilibili.com/video/av35768109&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bilibili&lt;/a&gt; | &lt;a href=&quot;https://www.youtube.com/watch?v=yQsOFWqpjkE&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Youtube&lt;/a&gt;&lt;br&gt;源码：llSourcell.Visualize_dataset_demo | &lt;a href=&quot;https://github.com/llSourcell/visualize_dataset_demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;  &lt;/p&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;目标&lt;/code&gt;：在本次课堂中，将对人类活动识别 ( Human Activity Recognition，HAR ) 数据集进行数据可视化呈现，并进行探索性分析以发现知识。而本课堂具体目标则是人类活动状态识别，活动状态包括：Sitting-down，Standing-up，Standing，Walking，Sitting。&lt;/p&gt;
&lt;p&gt;  具体地，通过降维方法 &lt;code&gt;t-SNE&lt;/code&gt; 实现不同活动状态的数据自动 “分类” ( 更准确地说应该是聚类 )，从而在低维度 ( 二维 ) 下复现数据 ( 的特征 )，以便我们理解数据、统计分析数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;问题&lt;/code&gt;：若我们要将要描述如此复杂的数据，即它们拥有的特征 ( 维度 ) 过多了，相对于人类大脑只能理解二维或三维的层面，如此复杂数据我们是难以从中发现知识的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;解决&lt;/code&gt;：通过可视化数据来描述它们的特征，具体措施是使用机器学习中的降维方法 &lt;code&gt;T-SNE&lt;/code&gt; ( Distributed Stochastic Neighbor Embedding )，把高维空间中的数据以二维或三维的形式表示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Project" scheme="http://www.kofes.cn/categories/Project/"/>
    
    
      <category term="数据挖掘" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="数据可视化" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="Kaggle" scheme="http://www.kofes.cn/tags/Kaggle/"/>
    
      <category term="t-SNE" scheme="http://www.kofes.cn/tags/t-SNE/"/>
    
  </entry>
  
</feed>
