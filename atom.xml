<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KOFE&#39;S BLOG</title>
  
  <subtitle>Reading / Project / Research</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kofes.cn/"/>
  <updated>2018-03-06T16:44:18.000Z</updated>
  <id>http://www.kofes.cn/</id>
  
  <author>
    <name>Kofe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读书笔记 - Android 源码设计模式</title>
    <link href="http://www.kofes.cn/2018/01/Design-Pattern-Based-on-Android.html"/>
    <id>http://www.kofes.cn/2018/01/Design-Pattern-Based-on-Android.html</id>
    <published>2018-01-30T11:51:18.000Z</published>
    <updated>2018-03-06T16:44:18.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>更新进度<ul><li>2018.01.30 - 完成序言；</li><li>2018.01.31 - 更新第壹章；</li><li>2018.02.05 - 更新第贰章，共 10 / 23 种设计模式；</li></ul></li></ul><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在你接触过的安卓项目当中，你所接触过的，如监听器、适配器、迭代器等并不陌生，然而它们无不体现着设计模式的精髓。</p><a id="more"></a><ul><li>推荐书目：<ul><li>《 设计模式之禅 》</li><li>《 设计模式（可复用面向对象软件的基础）》</li></ul></li></ul><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><ul><li><a href="#零-本书架构">零 本书架构</a></li><li><a href="#壹-面向对象编程六大原则">壹 面向对象编程六大原则</a></li><li><a href="#贰-二十三种设计模式解析">贰 二十三种设计模式解析</a></li><li><a href="#叁-MVC与MVP模式">叁 MVC 与 MVP 模式</a></li></ul><h2 id="零-本书架构"><a href="#零-本书架构" class="headerlink" title="零 本书架构"></a>零 本书架构</h2><h3 id="面向对象六大原则"><a href="#面向对象六大原则" class="headerlink" title="面向对象六大原则"></a>面向对象六大原则</h3><ul><li><p>单一职责原则</p><blockquote><p>优化代码第一步。既就一个类而言，应该有且仅有一个引起它变化的原因。</p></blockquote></li><li><p>开闭原则</p><blockquote><p>让程序更稳定，更灵活。既软件中的对象（类、模块、函数等）应该对于扩展是开放的，但对于修改是封闭的。</p></blockquote></li><li><p>里氏替换原则</p><blockquote><p>构建扩展性更好的系统。</p></blockquote></li><li><p>依赖倒置原则  </p><blockquote><p>让项目拥有变化能力，既依赖抽象，不依赖具体实现。</p></blockquote></li><li><p>接口隔离原则</p><blockquote><p>系统拥有更高灵活性。</p></blockquote></li><li><p>迪米特原则</p><blockquote><p>也称为「最少知识原则」。既一个对象应对其他对象有最少的了解。</p></blockquote></li></ul><h3 id="二十三种设计模式"><a href="#二十三种设计模式" class="headerlink" title="二十三种设计模式"></a>二十三种设计模式</h3><table><thead><tr><th style="text-align:left">模式名称</th><th style="text-align:left">一句话描述</th></tr></thead><tbody><tr><td style="text-align:left">单例模式</td><td style="text-align:left">一个类只有一个实例</td></tr><tr><td style="text-align:left">Build 模式</td><td style="text-align:left">自由拓展你的项目</td></tr><tr><td style="text-align:left">原型模式</td><td style="text-align:left">使程序运行更高效</td></tr><tr><td style="text-align:left">工厂方法模式</td><td style="text-align:left">生成复杂对象</td></tr><tr><td style="text-align:left">抽象工厂模式</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left">策略模式</td><td style="text-align:left">时势造英雄</td></tr><tr><td style="text-align:left">状态模式</td><td style="text-align:left">随遇则安</td></tr><tr><td style="text-align:left">责任链模式</td><td style="text-align:left">使编程更有灵活性</td></tr><tr><td style="text-align:left">解释器模式</td><td style="text-align:left">化繁为简的翻译机</td></tr><tr><td style="text-align:left">命令模式</td><td style="text-align:left">让程序畅通执行</td></tr><tr><td style="text-align:left">观察者模式</td><td style="text-align:left">解决、解耦的钥匙</td></tr><tr><td style="text-align:left">备忘录模式</td><td style="text-align:left">编程中的后悔药</td></tr><tr><td style="text-align:left">迭代器模式</td><td style="text-align:left">解决问题的第三者</td></tr><tr><td style="text-align:left">模块方法模式</td><td style="text-align:left">抓住问题的核心</td></tr><tr><td style="text-align:left">访问者模式</td><td style="text-align:left">数据结构与操作分离</td></tr><tr><td style="text-align:left">中介者模式</td><td style="text-align:left">调解者模式或调停者模式</td></tr><tr><td style="text-align:left">代理模式</td><td style="text-align:left">委托模式</td></tr><tr><td style="text-align:left">组合模式</td><td style="text-align:left">物以类聚</td></tr><tr><td style="text-align:left">适配器模式</td><td style="text-align:left">得心应手粘合剂</td></tr><tr><td style="text-align:left">装饰模式</td><td style="text-align:left">动态给对象添加额外职责</td></tr><tr><td style="text-align:left">享元模式</td><td style="text-align:left">对象共享，避免创建多对象</td></tr><tr><td style="text-align:left">外观模式</td><td style="text-align:left">统一编程接口</td></tr><tr><td style="text-align:left">桥接模式</td><td style="text-align:left">连接两地的交通枢纽</td></tr></tbody></table><h3 id="MVC-与-MVP-模式"><a href="#MVC-与-MVP-模式" class="headerlink" title="MVC 与 MVP 模式"></a>MVC 与 MVP 模式</h3><h2 id="壹-面向对象编程六大原则"><a href="#壹-面向对象编程六大原则" class="headerlink" title="壹 面向对象编程六大原则"></a>壹 面向对象编程六大原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><ul><li>Single Responsibility Principle，SRP.</li><li>既就一个类而言，应该仅有一个引起它变化的原因。</li></ul><blockquote><p>如何划分一个类，一个函数的职责？每个人的经验不同，观点看法也不同，故视具体任务而定。但它也有一些基本的知道原则：  </p><ul><li>两个完全不一样的功能就不应该放到同一个类中。</li><li>一个类中应该是一组相关性很高的函数、数据的封装。</li></ul></blockquote><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><ul><li>Open Close Principle，OCP.</li><li>既软件中的对象（类、模块、函数等）应该对于扩展是开放的，但对于修改是封闭的。</li><li>勃兰特·梅耶. 《面向对象软件构造》中提倡：<ul><li>新的或改变的特性应通过新建不同的类实现，新建的类可通过 <code>继承</code> 的方式来重用原类的代码。</li><li>已存在的实现类对于修改是封闭的，但新的实现类可通过 <code>覆写父类的接口</code> 应对变化。</li></ul></li></ul><blockquote><p>开闭原则知道我们，当软件需变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。</p></blockquote><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><blockquote><p><strong>往往开闭原则与里氏替换原则是生死相依、不离不弃的。</strong></p></blockquote><ul><li>Liskov Substitution Principle，LSP。</li><li>所有引用基类的地方必须能透明地使用其子类的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测量视图的大小</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 绘制按钮</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Windows</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">show</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">child.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述例子中，任何继承自 View 类的子类都可以设置给 show 方法，既里氏替换。这样千变万化的 View 传递给 Window，Window 只管组织 View，并显示在屏幕上。</p></blockquote><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><ul><li>Dependence Inversion Principle，DIP.</li><li>一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节。</li><li><p>依赖倒置原则的几个关键点：    </p><ul><li><p>高层模块不应该依赖低层模块，两者都应以来其抽象（接口或抽象类）</p><blockquote><p>高层模块指调用端，低层模块指实现类。</p></blockquote></li><li><p>抽象不应该依赖细节</p></li><li>细节应依赖抽象</li></ul></li><li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系。一句话概括：<code>面向接口编程，面向抽编程</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设计一款实现图片缓冲功能的接口，具体的缓冲实现方式、细节，根据实际情况编写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageChache</span> </span>&#123;<span class="comment">// ImageCache 缓存抽象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryCache</span> <span class="keyword">implements</span> <span class="title">ImageCache</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据实际需求，再实现具体细节</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</span><br><span class="line"><span class="comment">// 图片缓存类，依赖抽象，不依赖细节</span></span><br><span class="line">ImageCache mCache = <span class="keyword">new</span> MemoryCache();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String url, ImageView imageView)</span> </span>&#123;</span><br><span class="line">Bitmap bmp = mCache.get(url);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == bmp)&#123;</span><br><span class="line">downloadImageAsync(url, imageView);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">imageView.setImageBitmap(bmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageCache</span><span class="params">(ImageCache cache)</span> </span>&#123;</span><br><span class="line">mCache = cache;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><ul><li>Interface Segregation Principles，ISP.</li><li>类间的依赖关系应建立在最小的接口上。ISP 将非常庞大、臃肿的接口拆分成更小的和更具体的接口。IPS的目的是系统解开耦合。</li></ul><blockquote><p>如上例中，ImageLoader 中的 ImageCache，ImageLoader 只需要知道该缓存对象有存、取缓存图片的接口即可，其他一概不管。</p></blockquote><h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3><ul><li><p>一个对象应对其他对象有最少的了解、即类的内部如何实现与调用者、依赖者没关系，调用者或依赖者之需知道它需要的方法即可，其他一概不管。</p></li><li><p>图 1-1 展示了租客、中介与房间相互之间的需求关系。</p><p>  <img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_1-1.png" alt="租客、中介与房间关系"></p>  <center>图 1-1 租客、中介与房间关系</center>   <p>  因为租客只需要房子，既把需求转达中介，对房子具体的租金、维修、签约等交由中介处理，租客不需要再了解细节。改进效果见图 1-2。</p><p>  <img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_1-2.png" alt="租客、中介与房间关系"></p>  <center>图 1-2 改进：租客、中介与房间的关系</center>  </li></ul><h2 id="贰-二十三种设计模式解析"><a href="#贰-二十三种设计模式解析" class="headerlink" title="贰 二十三种设计模式解析"></a>贰 二十三种设计模式解析</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="单例模式的定义"><a href="#单例模式的定义" class="headerlink" title="单例模式的定义"></a>单例模式的定义</h4><ul><li><p>确保某 <code>一个类只有一个实例</code> ，而且自行实例化并向整个系统提供这个实例。</p><blockquote><p><code>一个类只有一个实例</code> ：避免产生多个对象消耗过多资源，如访问 I/O 和数据库等资源。</p></blockquote></li></ul><h4 id="单例模式-UML-类图"><a href="#单例模式-UML-类图" class="headerlink" title="单例模式 UML 类图"></a>单例模式 UML 类图</h4><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-1.png" alt="单例模式示意图"></p><center>图 2-1 单例模式示意图</center> <ul><li>实现单例模式主要有如下几个关键点：<ul><li><code>构造函数</code> 不对外开放，一般设为 <code>私有</code> ；</li><li>通过一个 <code>静态方法</code> 或者 <code>枚举返回</code> 单例类对象；</li><li>确保单例类的对象有且只有一个，尤其多线程环境下；</li><li>确保单例类对象在 <code>反序列化</code> 时不会重新构建对象；</li></ul></li></ul><h4 id="单例模式的简单示例"><a href="#单例模式的简单示例" class="headerlink" title="单例模式的简单示例"></a>单例模式的简单示例</h4><p>例如一个公司只有一个 CEO，一个应用只有一个 Application 对象等。下面以公司里的 CEO 为例来简单演示，既一个公司可有几个 VP，无数个员工，但 CEO 只有一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 员工的基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Staff</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 忽略执行细节</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 副总裁类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VP</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 覆写执行细节</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉单例模式：声明静态对象时已初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CEO</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123; <span class="comment">// 公司保证只有一个 CEO</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CEO mCeo = <span class="keyword">new</span> CEO();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">CEO</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CEO <span class="title">getCeo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mCeo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 覆写执行细节</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 实际中使用：</span></span><br><span class="line"><span class="comment"> * CEO 类不能通过 new 的形式构造对象，只能通过 CEO.getCeo() 函数获取。</span></span><br><span class="line"><span class="comment"> * CEO 对象是静态对象，并在声明时已初始化，保证 CEO 对象的唯一性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line">Staff ceo1 = CEO.getCeo();</span><br><span class="line">Staff ceo2 = CEO.getCeo();</span><br></pre></td></tr></table></figure><h4 id="单例模式的其他实现方式"><a href="#单例模式的其他实现方式" class="headerlink" title="单例模式的其他实现方式"></a>单例模式的其他实现方式</h4><h5 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h5><ul><li>声明一静态对象；</li><li>调用 getInstance() 方法初始化 ( 用时才初始化，既惰性处理机制 )</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉单例模式：用时才初始化，既惰性处理机制</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instantce;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 synchronized 关键字，即 getInstance() 是一个同步方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">null</span> == instance ) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>懒汉单例模式的优缺点：  <ul><li>优点 - 使用时才实例化，一定程度上节约资源。  </li><li>缺点 - 每次调用 getInstance() 都进行同步，造成不必要同步开销。</li></ul></li></ul><h5 id="Double-CheckLock-DCL"><a href="#Double-CheckLock-DCL" class="headerlink" title="Double CheckLock (DCL)"></a>Double CheckLock (DCL)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">// private static Singleton sInstance = null;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton sInstance = <span class="keyword">null</span>; <span class="comment">// 保证 sInstance 对象每次都是从主内存存、读取。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"do sth."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">null</span> == sInstance ) &#123; <span class="comment">// 避免不必要同步</span></span><br><span class="line"><span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">null</span> == sInstance ) &#123; <span class="comment">// 此处判空操作，是因为 Java 编译器允许处理器乱序执行，具体解析见注解</span></span><br><span class="line">sInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DCL 又称「丑陋的优化」？  </p><p>DCL 虽一定程度解决了资源消耗，多余同步、线程安全等问题，但某种情况下还是会出现失效问题 ( 双重检查锁定(DCL) )，既称「丑陋的优化」。</p><ul><li><p>线程A，执行 <code>sInstance = new Singleton();</code>，编译器会编译成多条汇编指令，具体汇编指令的分工为：  </p><ul><li>Step.01 给 Singleton 实例分配内存；  </li><li>Step.02 调用 Singleton() 的构造函数；  </li><li>Step.03 将 sInstance 对象指向分配的内存空间；  </li></ul></li><li><p>然而 Java 编译器允许处理器乱序执行，既有「1-2-3」或「1-3-2」的执行顺序。</p></li><li>若执行「1-3-2」的顺序，这样会使 DCL 的优化失效，既第三步执行完毕，sInstance 非空，线程B取走 sInstance。再使用时就会报错。</li></ul><h5 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonHolder.sInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123; <span class="comment">// 静态内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton sInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次加载 Singleton 的 getInstance() 方法才会使 sInstance 被初始化。因此，第一次调用 getInstance() 方法会导致虚拟机加载 SingletonHolder 类.</p><blockquote><p>内部类是延时加载的，只会在第一次使用时加载，不使用不加载。这样，既保证了线程安全，又保证单例对象唯一性，同时也延迟单例的实例化。</p></blockquote><h5 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认枚举实例的创建是线程安全的，并且在任何情况下它都是一个单例。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">INSTANCE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"do sth."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>不管以哪种形式实现单例模式，它们的核心原理都是将 <code>构造函数私有化</code> ，并通过 <code>静态方法获取一个唯一的实例</code> 。</p><blockquote><p>获取实例的过程须保证线程安全，防止反序列化导致重新生成实例对象等。</p></blockquote></li><li><p>选择哪种实现形式取决项目本身，如是否是复杂的并发环境、JDK 版本是否过低、单例对象的资源消耗等。</p></li><li>单例模式的优缺点<ul><li>优点<br>1) 只生成一个实例，减少系统的性能开销；<br>2) 当一对象的产生需要较多资源时，如读取配置、产生其他依赖对象时，可通过应用启动时直接产生一个单例对象，永久驻留内存。  </li><li>缺点<br>1) 单例模式一般没有接口，扩展性难；<br>2) 单例对象若持有 Context，那么很容易引发内存泄漏，此时需注意传递给单例对象的 Context 应该是 <code>Application.Context</code> 。</li></ul></li></ul><h3 id="Bulider-模式"><a href="#Bulider-模式" class="headerlink" title="Bulider 模式"></a>Bulider 模式</h3><h4 id="Bulider-模式的定义"><a href="#Bulider-模式的定义" class="headerlink" title="Bulider 模式的定义"></a>Bulider 模式的定义</h4><ul><li>创建型设计模式。</li><li>将一个复杂对象的 <code>构建</code> 与它的 <code>表示</code> 分离，使得同样的构建过程可以创建不同的表示。</li><li>Builder 模式是一步步创建一个复杂对象的，它允许用户在不知内部构建细节的情况下，可以更精细地控制对象的构造流程。</li></ul><h4 id="Builder-模式的使用场景"><a href="#Builder-模式的使用场景" class="headerlink" title="Builder 模式的使用场景"></a>Builder 模式的使用场景</h4><ul><li>产品类非常复杂，或产品类中调用顺序不同产生不同的作用，这时需要使用 Builder 模式。</li><li>初始化一个对象特别复杂，如参数多，且很多参数都具有默认值。</li></ul><h4 id="Builder-模式的UML类图"><a href="#Builder-模式的UML类图" class="headerlink" title="Builder 模式的UML类图"></a>Builder 模式的UML类图</h4><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-2.png" alt="Builder模式示意图"></p><center>图 2-2 Builder 模式示意图</center> <h4 id="Builder-模式的简单实现"><a href="#Builder-模式的简单实现" class="headerlink" title="Builder 模式的简单实现"></a>Builder 模式的简单实现</h4><p>便于理解，本示例的 UML 类图见图 2-3。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-3.png" alt="计算机组装过程"></p><center>图 2-3 计算机组装过程</center> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 下述程序以计算机组装过程简化为：构建主机，设置操作系统，设置显示器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 计算机抽象类，既 Product 角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> String mBoard;</span><br><span class="line"> <span class="keyword">protected</span> String mDisplay;</span><br><span class="line"> <span class="keyword">protected</span> String mOS;</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="title">Computer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBoard</span><span class="params">(String board)</span> </span>&#123; <span class="comment">// 设置 CPU 核心数</span></span><br><span class="line"> mBoard = board;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisplay</span><span class="params">(String display)</span> </span>&#123; <span class="comment">// 设置内存</span></span><br><span class="line"> mDisplay = display;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setOS</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">"Computer[...]"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体的 Computer 类 - MacBook</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Macbook</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="title">Macbook</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> mOS = <span class="string">"MAC OSX 10.10"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 抽象 Builder 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBoard</span><span class="params">(String board)</span></span>; <span class="comment">// 设置主机</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildOS</span><span class="params">()</span></span>; <span class="comment">// 设置操作系统</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildDisplay</span><span class="params">(String display)</span></span>; <span class="comment">// 设置显示器</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">create</span><span class="params">()</span></span>; <span class="comment">// 创建 Computer</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体的 Builder 类 - MacbookBuilder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacbookBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Computer mComputer = <span class="keyword">new</span> Macbook();</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBoard</span><span class="params">(String board)</span></span>&#123;</span><br><span class="line"> mComputer.setBoard(board);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDisplay</span><span class="params">(String display)</span> </span>&#123;</span><br><span class="line"> mComputer.setDisplay(display);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildOS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> mComputer.setOS();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Computer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> mComputer;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Director 类，负责构造 Computer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line"> Builder mBuilder = <span class="keyword">null</span>;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line"> mBuilder = builder;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(String board, String display)</span> </span>&#123;</span><br><span class="line"> mBuilder.buildBoard(board);</span><br><span class="line"> mBuilder.buildDisplay(display);</span><br><span class="line">mBuilder.buildOS();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Builder builder = <span class="keyword">new</span> MacbookBuilder(); <span class="comment">// 构造器</span></span><br><span class="line"> Director pcDirector = <span class="keyword">new</span> Director(builder); <span class="comment">// Director</span></span><br><span class="line"> <span class="comment">// 封装构建过程</span></span><br><span class="line"> pcDirector.construct(<span class="string">"英特尔主板"</span>, <span class="string">"Retina 显示器"</span>);</span><br><span class="line"> System.out.println(<span class="string">"Computer Info: "</span> + builder.create().toString());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Builder-模式实战"><a href="#Builder-模式实战" class="headerlink" title="Builder 模式实战"></a>Builder 模式实战</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 知名图片加载库：Universal-Image-Loader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">ImageLoaderConfiguration config = <span class="keyword">new</span> ImageLoaderConfiguration</span><br><span class="line">.Builder(context) <span class="comment">// 用户只能通过 Builder 对象构建 ImageLoaderConfiguration 对象，这就是构建和表示相分离</span></span><br><span class="line">.threadPriority(Thread_NORM_PRIORITY_2)</span><br><span class="line">.denyCacheImageMultipleSizesInMemory()</span><br><span class="line">.discCacheFileNameGenerator( <span class="keyword">new</span> MD5FileNameGenerator() )</span><br><span class="line">.tasksProcessingOrder(QueueProcessingType.LIFO)</span><br><span class="line">.bulider();</span><br><span class="line"></span><br><span class="line">ImageLoader.getInstance().init(config);</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>Builder 模式，通过作为配置类的构建器将配置的构建和表示分离开来，同时也将配置从目标类中隔离出来，避免过多的 Setter 方法暴露在目标类当中。</li><li>Builder 模式的优缺点<ul><li>优点<br>1) 良好的封装性，不必知道产品内部组成的细节；<br>2) 建造者独立，易于扩展。</li><li>缺点<br>1) 产生多余 Builder 对象及 Director 对象，消耗内存。</li></ul></li></ul><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h4 id="原型模式的定义"><a href="#原型模式的定义" class="headerlink" title="原型模式的定义"></a>原型模式的定义</h4><ul><li>创建性的模式。</li><li>定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。<ul><li>原型拥有样板实例，可克隆内部属性一致的对象。</li><li>原型模式多用于创建复杂的或构建耗时的实例，既复制一个已经存在的实例可使程序运行更高效。</li></ul></li></ul><h4 id="原型模式的使用场景"><a href="#原型模式的使用场景" class="headerlink" title="原型模式的使用场景"></a>原型模式的使用场景</h4><ul><li>类初始化需消耗非常多的资源 ( 数据、硬件资源等 )。</li><li>通过 new 产生一个对象需要非常繁琐的数据准备或访问权限。</li><li>一个对象需提供其他对象访问，且各调用者可能都需修改其值时，可考虑用原型模式或拷贝多个对象以供调用者使用，既 <code>保护性拷贝</code> 。</li></ul><h4 id="原型模式的-UML-类图"><a href="#原型模式的-UML-类图" class="headerlink" title="原型模式的 UML 类图"></a>原型模式的 UML 类图</h4><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-4.png" alt="Builder模式示意图"></p><center>图 2-4 原型模式的 UML 类图</center> <h4 id="原型模式的简单实现"><a href="#原型模式的简单实现" class="headerlink" title="原型模式的简单实现"></a>原型模式的简单实现</h4><p>便于理解，本示例的 UML 类图见图 2-5。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-5.png" alt="WordDocument文档编辑器"></p><center>图 2-5 WordDocument 文档编辑器</center> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * WordDocument 具有文字、图片编辑功能的简单文档处理类。且为保护源文件，其可在克隆对象上作内容修改。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDocument</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"><span class="comment">// WordDocument 扮演 ConcretePrototype 角色</span></span><br><span class="line"><span class="comment">// Cloneable 扮演 Prototype 角色</span></span><br><span class="line"><span class="keyword">private</span> String mText; <span class="comment">// 文本</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;String&gt; mImages = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 图片名列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WordDocument</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 忽略实现细节</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WordDocument <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">WordDocument doc = (WordDocument) <span class="keyword">super</span>.clone();</span><br><span class="line">doc.mText = <span class="keyword">this</span>.mText;</span><br><span class="line">doc.mImages = <span class="keyword">this</span>.mImages;</span><br><span class="line"><span class="keyword">return</span> doc;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mText;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String mText)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mText = mText;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mImages;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addImage</span><span class="params">(String img)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mImages.add(img);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDocument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Text:"</span> + mText);</span><br><span class="line">System.out.println(<span class="string">"Images List:"</span>);</span><br><span class="line"><span class="keyword">for</span>(String imgName:mImages) &#123;</span><br><span class="line">System.out.println(<span class="string">"image name:"</span> + imgName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">WordDocument originDoc = <span class="keyword">new</span> WordDocument();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Partion A start */</span></span><br><span class="line">originDoc.setText(<span class="string">"This is a Aircle"</span>);</span><br><span class="line">originDoc.addImage(<span class="string">"Image A"</span>);</span><br><span class="line"><span class="comment">/* Partion A end */</span></span><br><span class="line">originDoc.showDocument();</span><br><span class="line"></span><br><span class="line">WordDocument secDoc = originDoc.clone();</span><br><span class="line">secDoc.showDocument();</span><br><span class="line">secDoc.setText(<span class="string">"This is a Paper"</span>); <span class="comment">// 只是改变了引用指向</span></span><br><span class="line">secDoc.showDocument();</span><br><span class="line">originDoc.showDocument(); <span class="comment">// 还是输出 Partion A 的结果</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：通过 clone() 拷贝对象时并不会执行构造函数。如果在构造函数中需要一些特殊的初始化操作类型，在使用 Cloneable 实现拷贝时，注意构造函数不会执行的问题。</p></blockquote><h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><ul><li><p>浅拷贝：上述例子实际上只是一个浅拷贝，也称 <code>影子拷贝</code>，既只是副本文档引用原始文档的字段。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-6.png" alt="浅拷贝示意图"></p><center>图 2-6 浅拷贝示意图</center> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">secDoc.setText(<span class="string">"This is a Paper."</span>);</span><br><span class="line">secDoc.addImage(<span class="string">"Image B"</span>);</span><br><span class="line">secDoc.showDocument(); <span class="comment">// Case 1</span></span><br><span class="line">originDoc.showDocument(); <span class="comment">// Case 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Case 1，2 都增加了图片 “Image B”，原因是 secDoc 只是单纯指向了 this.mImages</span></span><br></pre></td></tr></table></figure></li><li><p>深拷贝：为了解决浅拷贝所带来的“问题” ( 视具体问题而定 )，引入深入拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WordDocument <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">WordDocument doc = (WordDocument) <span class="keyword">super</span>.clone();</span><br><span class="line">doc.mText = <span class="keyword">this</span>.mText;</span><br><span class="line"><span class="comment">// doc.mImages 指向 mImages 的一份拷贝，而不是 this.mImages 本身</span></span><br><span class="line">doc.mImages = (ArrayList&lt;String&gt;) <span class="keyword">this</span>.mImages.clone();</span><br><span class="line"><span class="keyword">return</span> doc;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="原型模式实战"><a href="#原型模式实战" class="headerlink" title="原型模式实战"></a>原型模式实战</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在线用户信息修改 (需登录后修改用户信息)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String phoneNum;</span><br><span class="line"><span class="keyword">public</span> Adress,adress;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"User[age=...]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">Login</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> login()</span></span>;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginImpl</span> <span class="keyword">implements</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">User loginedUser = <span class="keyword">new</span> User(); <span class="comment">// 登录服务器，获取用户信息</span></span><br><span class="line">loginedUser.age = <span class="number">12</span>;</span><br><span class="line">loginedUser.name = <span class="string">"Mr.Sample"</span>;</span><br><span class="line">loginedUser.address = <span class="keyword">new</span> Address(<span class="string">"BeiJing"</span>, <span class="string">"HaiDing"</span>, <span class="string">"Garden Rd"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录完成后，将用户信息设置到 Session:</span></span><br><span class="line">LoginSession.getLoginSession()</span><br><span class="line">.setLoginedUser(loginedUser)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录 Session</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginSession</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> LoginSession sLoginSession = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> User longinedUser; <span class="comment">// 已登录用户</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LoginSession</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoginSession <span class="title">getLoginSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == sLoginSession) &#123;</span><br><span class="line"> sLoginSession = <span class="keyword">new</span> LoginSession();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> sLoginSession;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包级私有：既不加任何修饰符，该模式(默认访问模式)下，只允许在同一包中进行访问</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLoginedUser</span><span class="params">(User user)</span> </span>&#123; <span class="comment">// 设置已登录用户信息，不对外开放</span></span><br><span class="line">loginedUser = user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getLoginedUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> loginedUser;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Partion A : 以下是实际执行部分，可能在不同包的某个类下执行 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取已登录的 User 对象</span></span><br><span class="line">User newUser = LoginSession.getLoginSession().getLoginedUser();</span><br><span class="line"><span class="comment">// 更新用户信息</span></span><br><span class="line">newUser.address = <span class="keyword">new</span> Adress(<span class="string">"BeiJing"</span>, <span class="string">"ChaoYang"</span>, <span class="string">"DaWang Rd"</span>);</span><br></pre></td></tr></table></figure><p>用户信息的更新，限定于与 LoginSession 类在同一包下才能执行，既 Partion A 的操作，使这样的限定失效。我们可作以下改进：</p><ul><li>在 User 类中实现 Cloneable 接口。</li><li>在 LoginSession 中将 getLoginedUser() 改为 <code>return loginedUser.clone()</code> ，既在任何地方调用，获得的都是用户拷贝的对象，修改只是作用于拷贝的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 Cloneable 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123; <span class="comment">// 用户实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String phoneNum;</span><br><span class="line"><span class="keyword">public</span> Adress,adress;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">User user = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">user = (User) <span class="keyword">super</span>.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span>(CLoneNotSupportedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"User[age=...]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginSession</span> </span>&#123; </span><br><span class="line"><span class="comment">// 既管在任何地方调用，获得的都是用户拷贝的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getLoginedUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> loginedUser.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul><li>原型模式的优缺点<ul><li>优点 - 原型模式是在内存中二进制的拷贝，比 new 一个对象性能更优。</li><li>缺点 - 内存中拷贝，构造函数是不会执行的。</li></ul></li></ul><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><h4 id="工厂方法模式的定义"><a href="#工厂方法模式的定义" class="headerlink" title="工厂方法模式的定义"></a>工厂方法模式的定义</h4><ul><li>创建型设计模式。</li><li>定义一个用于创建对象的接口，让子类决定实例化哪个类。</li></ul><h4 id="工厂方法模式的使用场景"><a href="#工厂方法模式的使用场景" class="headerlink" title="工厂方法模式的使用场景"></a>工厂方法模式的使用场景</h4><ul><li>复杂对象的创建，而用 New 就可以完成创建的对象则不必使用工厂方法了。</li></ul><h4 id="工厂方法模式的-UML-类图"><a href="#工厂方法模式的-UML-类图" class="headerlink" title="工厂方法模式的 UML 类图"></a>工厂方法模式的 UML 类图</h4><p>工厂方法模式的 UML 如图 2-7 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-7.png" alt="浅拷贝示意图"></p><center>图 2-7 工厂方法模式 UML 类图</center> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123; <span class="comment">// 具体产品 A</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我是具体的产品A."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductB</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123; <span class="comment">// 具体产品 B</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我是具体的产品B."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123; <span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @return 具体的产品对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 返回具体产品 A 或者具体产品 B</span></span><br><span class="line"><span class="comment">// return new ConcreteProductA();</span></span><br><span class="line"><span class="comment">// return new ConcreteProductB();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Factory factory = <span class="keyword">new</span> ConcreteFactory();</span><br><span class="line">Product p = factory.createProduct();</span><br><span class="line">p.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们可以利用反射的方式实现多工厂方法模式，具体见下述代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 具体生产什么由子类去实现</span></span><br><span class="line"><span class="comment"> * @param clz 产品对象类类型</span></span><br><span class="line"><span class="comment"> * @return 具体的产品对象</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span>&lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(class&lt;T&gt; clz)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(class&lt;T&gt; clz)</span> </span>&#123;</span><br><span class="line">Product p = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">p = (Product) <span class="class"><span class="keyword">class</span>.<span class="title">forName</span>(<span class="title">clz</span>.<span class="title">getName</span>()).<span class="title">newInstance</span>()</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端中实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Factory factory = <span class="keyword">new</span> ConcreteFactory();</span><br><span class="line">Product p = factory.createProduct(ConcreteProductA.class);</span><br><span class="line">p.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="工厂方法模式的简单实现"><a href="#工厂方法模式的简单实现" class="headerlink" title="工厂方法模式的简单实现"></a>工厂方法模式的简单实现</h4><p>某汽车厂主要就是组装某款 SUV 车型，比如 Q3、Q5、Q7，对于这类车型来说，内部结构差异并不是很大，因此一条生产线足以应付 3 种车型，对于该类生产线可提供一抽象类定义。</p><p>便于理解，本示例的 UML 类图见图 2-8。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-8.png" alt="某工厂生产某车型的工厂方法"></p><center>图 2-8 某工厂生产某车型的工厂方法</center> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 某工厂生产某种车型的工厂方法</span></span><br><span class="line"><span class="comment"> * @param clz 具体的 SUV 型号类型</span></span><br><span class="line"><span class="comment"> * @return 具体型号的 SUV 车对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span>&lt;T extends AudiCar&gt; <span class="function">T <span class="title">createAudiCar</span><span class="params">(class&lt;T&gt; clz)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiCarFactory</span> <span class="keyword">extends</span> <span class="title">AudiFactory</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends AudiCar&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(class&lt;T&gt; clz)</span> </span>&#123;</span><br><span class="line">Product p = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">p = (AudiCar) <span class="class"><span class="keyword">class</span>.<span class="title">forName</span>(<span class="title">clz</span>.<span class="title">getName</span>())</span></span><br><span class="line"><span class="class">.<span class="title">newInstance</span>()</span>; </span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汽车的抽象产品类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiCar</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">selfNavigation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体车型：Q3</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiQ3</span> <span class="title">exntends</span> <span class="title">AudiCar</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Q3 Launched!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfNavigation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Q3 starts a auto-navigation!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AudiFactory factory = <span class="keyword">new</span> AudiFactory();</span><br><span class="line">AudiQ3 audiQ3 = factory.createProduct(AudiQ3.class);</span><br><span class="line">audiQ3.dirve();</span><br><span class="line">audiQ3.selfNavigation();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="工厂方法模式的实战"><a href="#工厂方法模式的实战" class="headerlink" title="工厂方法模式的实战"></a>工厂方法模式的实战</h4><p>Android 数据持久化有很多方式，如 SharedPreferences (XML)、SQLite (关系数据库)。对数据操作的方法无非就是增、删、改、查，若我们将每种数据储存的方式作为一个产品类，在抽象产品类中定义对数据操作的方法，既我们宏观层面把握操作的逻辑，具体的实现逻辑由储存数据的方式决定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IOHandler</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String id, String name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String id, String name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">query</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> <span class="keyword">extends</span> <span class="title">IOHandler</span> </span>&#123; <span class="comment">// 普通文件存储</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String id, String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String id, String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> </span><br><span class="line"><span class="keyword">return</span> <span class="string">"AigeStudio"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLHandler</span> <span class="keyword">extends</span> <span class="title">IOHandler</span> </span>&#123; <span class="comment">// XML 文存储</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String id, String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String id, String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"SMBrother"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBHandler</span> <span class="keyword">extends</span> <span class="title">IOHandler</span> </span>&#123; <span class="comment">// SQLite 数据库存储</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String id, String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String id, String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 业务逻辑 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"Android"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取 IO 处理者</span></span><br><span class="line"><span class="comment"> * @param clz IOHandler 类型的类类型</span></span><br><span class="line"><span class="comment"> * @return IOHandler 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends IOHandler&gt; <span class="function">T <span class="title">getIOHandler</span><span class="params">(class&lt;T&gt; clz)</span> </span>&#123;</span><br><span class="line">IOHandler handler = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> handler = (IOHandler) <span class="class"><span class="keyword">class</span>.<span class="title">forName</span>(<span class="title">clz</span>.<span class="title">getName</span>())</span></span><br><span class="line"><span class="class"> .<span class="title">newInstance</span>()</span>;</span><br><span class="line"> &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> (T) handler;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle saveInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(saveInstanceState);</span><br><span class="line">setContentView(R.layout.activity_factory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取显示查询内容的 TextView 对象</span></span><br><span class="line"><span class="keyword">final</span> TextView tvContent = (TextView) <span class="keyword">this</span>.findViewById(R.id.factory_content_tv);</span><br><span class="line"><span class="comment">// 获取查询普通文件数据的按钮对象，并设置监听</span></span><br><span class="line">Button btnFile = (Button) <span class="keyword">this</span>.findViewById(R.id.factory_file_btn);</span><br><span class="line">btnFile.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">IOHandler handler = IOFactory.getIOHanHandler(FileHandler.class);</span><br><span class="line">Log.d(<span class="string">"AigeStudio"</span>, handler.query(<span class="string">"4455645646"</span>));</span><br><span class="line">tvContent.setText(handler.query(<span class="string">"4455645646"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><h4 id="抽象工厂模式的定义"><a href="#抽象工厂模式的定义" class="headerlink" title="抽象工厂模式的定义"></a>抽象工厂模式的定义</h4><ul><li>创建型设计模式。</li><li>为创建一组相关或者是相互依赖的对象 提供一个 <code>接口</code> ，而不需要指定它们的具体类。</li></ul><h4 id="抽象工厂模式的使用场景"><a href="#抽象工厂模式的使用场景" class="headerlink" title="抽象工厂模式的使用场景"></a>抽象工厂模式的使用场景</h4><p>一个对象族有相同约束时可以使用抽象工厂模式。如：<br>Android、iOS、Window Phone 下都有短信软件和拨号软件，两者属于软件范畴，但由于操作系统平台不一样，其代码实现细节也是有差异的，则我们可考虑使用抽象工厂方法模式去产生不同平台下的同款软件。</p><h4 id="抽象工厂模式的-UML-类图"><a href="#抽象工厂模式的-UML-类图" class="headerlink" title="抽象工厂模式的 UML 类图"></a>抽象工厂模式的 UML 类图</h4><p>抽象工厂方法模式的 UML 如图 2-9 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-9.png" alt="抽象工厂方法模式UML类图"></p><center>图 2-9 抽象工厂方法模式 UML 类图</center> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span> </span>&#123; <span class="comment">// 抽象产品类 A</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> abstractvoid <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductB</span> </span>&#123; <span class="comment">// 抽象产品类 B</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> abstractvoid <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProducxtA1</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123; <span class="comment">// 具体产品类 A1</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体产品 A1 的方法."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProducxtA2</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123; <span class="comment">// 具体产品类 A2</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体产品 A2 的方法."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProducxtB1</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span> </span>&#123; <span class="comment">// 具体产品类 B1</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"具体产品 B1 的方法."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProducxtB2</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span> </span>&#123; <span class="comment">// 具体产品类 B2</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体产品 B2 的方法."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123; <span class="comment">// 抽象工厂类</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建产品 A 的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 产品 A 的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建产品 B 的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 产品 B的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123; <span class="comment">// 具体工厂类1</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductA <span class="title">createProductA1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA1();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductB <span class="title">createProductB1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB1();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123; <span class="comment">// 具体工厂类2</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductA <span class="title">createProductA2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA2();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductB <span class="title">createProductB2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB2();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象工厂模式的简单实现"><a href="#抽象工厂模式的简单实现" class="headerlink" title="抽象工厂模式的简单实现"></a>抽象工厂模式的简单实现</h4><p>在简单工厂模式的简单实现中，我门以车厂生产汽车为例。虽 Q3、Q5、Q7 同为一车系，但三者之间的零部件产别却很大，如 Q3、Q7 当中，Q3 装配的是国产发动机，普通轮胎和普通制动系统；Q7 则装配的是进口发动机，全尺寸越野轮胎和制动性能极好的制动系统。</p><p>既同为一系列车，大家共有部件有发动机、轮胎和制动系统等，由于具体的部件品质不同，装配的细节又不同。故我们可将抽象工厂模式应用当中，化繁为简。具体的架构如图 2-10 的 UML 类图所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-10.png" alt="车厂生产同系列汽车的抽象工厂模式"></p><center>图 2-10 车厂生产同系列汽车的抽象工厂模式</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产轮胎</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ITire 轮胎</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ITire <span class="title">createTire</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产发动机</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> IEngine 发动机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IEngine <span class="title">createEngine</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产制动系统</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> IBrake 制动系统</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IBrake <span class="title">createBrake</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITire</span> </span>&#123; <span class="comment">// 轮胎</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tire</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalTire</span> <span class="keyword">implements</span> <span class="title">ITire</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"普通轮胎"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SUVTire</span> <span class="keyword">implements</span> <span class="title">ITire</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"越野轮胎"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">IEngine</span><span class="params">()</span> </span>&#123; <span class="comment">// 发动机</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DomesticEngine</span> <span class="keyword">implements</span> <span class="title">IEngine</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"国产发动机"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportEngine</span> <span class="keyword">implements</span> <span class="title">IEngine</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"进口发动机"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBrake</span> </span>&#123; <span class="comment">// 制动系统</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalBrake</span> <span class="keyword">implements</span> <span class="title">IBrake</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"普通制动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeniorBrake</span> <span class="keyword">implements</span> <span class="title">IBrake</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"高级制动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q3Factory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span> </span>&#123; <span class="comment">// Q3工厂类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ITire <span class="title">createTire</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NormalTire();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEngine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="function">Domestic <span class="title">Engine</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IBrake <span class="title">createBrake</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NormalBrake();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q3Factory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span> </span>&#123; <span class="comment">// Q3工厂类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ITire <span class="title">createTire</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NormalTire();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEngine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DomesticEngine();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IBrake <span class="title">createBrake</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NormalBrake();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q7Factory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span> </span>&#123; <span class="comment">// Q7 工厂类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ITire <span class="title">createTire</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SUVTire();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEngine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ImportEngine();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@verride</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IBrake <span class="title">createBrake</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SeniorBrake();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 构造一个生产 Q3 的工厂</span></span><br><span class="line">CarFactory factoryQ3 = <span class="keyword">new</span> Q3Factory();</span><br><span class="line">factoryQ3.createTire().tire();</span><br><span class="line">factoryQ3.createEngine().engine();</span><br><span class="line">factoryQ3.createBrake().brake();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 构造一个生产 Q7 的工厂</span></span><br><span class="line">CarFactory factoryQ7 = <span class="keyword">new</span> Q7Factory();</span><br><span class="line">factoryQ7.createTire().tire();</span><br><span class="line">factoryQ7.createEngine().engine();</span><br><span class="line">factoryQ7.createBrake().brake();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><ul><li>抽象工厂方法模式的优缺点<ul><li>优点 - 分离接口与实现，既客户端使用抽象工厂的创建对象，客户端不知具体实现是谁，客户端只是面向产品的接口编程而已，使其从具体的产品实现中解耦。</li><li>缺点<br>1) 类文件的爆炸性增加。<br>2) 不太容易扩展新的产品类，因为每当增加一个产品类，就需修改抽象工厂，故所有具体工厂类均会被修改。</li></ul></li></ul><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h4 id="策略模式介绍"><a href="#策略模式介绍" class="headerlink" title="策略模式介绍"></a>策略模式介绍</h4><p>实现某功能，可以有多种算法或策略选择，例如排序算法，有插入排序、归并排序、冒泡排序等。</p><blockquote><p>思考：多种排序算法，可以写在一个类中，一个方法对应一种具体排序。但是缺点也是很明显，既臃肿；维护成本高，且容易引发错误；每增加一种排序需修改封装类的源码。  </p><p>改进：提供一个统一接口，不同的算法或策略有不同的实现类。</p></blockquote><h4 id="策略模式的使用场景"><a href="#策略模式的使用场景" class="headerlink" title="策略模式的使用场景"></a>策略模式的使用场景</h4><ul><li>针对同类问题的多种处理方式，仅仅是 <code>具体行为</code> 有差别。</li><li>需要安全地封装多种 <code>同类型</code> 的操作。</li><li><p>出现同一抽象类，有多个子类，而又需使用 <code>if-else</code> 或 <code>switch-case</code>  来选择具体子类。</p><blockquote><p>但缺点也明显，耦合性高；代码臃肿难维护。</p></blockquote></li></ul><h4 id="策略模式的-UML-类图"><a href="#策略模式的-UML-类图" class="headerlink" title="策略模式的 UML 类图"></a>策略模式的 UML 类图</h4><p>策略模式的 UML 如图 2-11 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-11.png" alt="策略模式UML类图"></p><center>图 2-11 策略模式 UML 类图</center> <h4 id="策略模式的简单实现"><a href="#策略模式的简单实现" class="headerlink" title="策略模式的简单实现"></a>策略模式的简单实现</h4><p>下面以在北京乘坐公共交通工具的费用计算来演示一简单示例。在 2014 年 12 月 20 号之后，北京提高公交价格，不在是单一票价制，而是分段计费。显然，公交车和地铁的价格计算方式是不一样的。但是，我们的示例中是需要计算乘不同出行工具的成本，故我们采用策略模式进行设计、编码。</p><p>便于理解，本示例的 UML 类图如图 2-12 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-12.png" alt="交通方案UML类图"></p><center>图 2-12 交通方案的 UML 类图</center> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CalculateStragety</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按距离来计算价格</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> km 公里</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回价格</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculatePrice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusStragety</span> <span class="keyword">implements</span> <span class="title">CalculateStragety</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculatePrice</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 公交车价格计算策略</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubwayStragety</span> <span class="keyword">implements</span> <span class="title">CalculateStragety</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculatePrice</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 地铁价格计算策略</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现: 出行价格计算器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TranficCalculator</span> </span>&#123;</span><br><span class="line">CalculateStrategy mStrategy = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">TranficCalculator calculator = <span class="keyword">new</span> TranficCalculator();</span><br><span class="line"><span class="comment">// 设置计算策略</span></span><br><span class="line">calculator.setStrategy( <span class="keyword">new</span> BusStrategy() );</span><br><span class="line"><span class="comment">// 计算价格</span></span><br><span class="line">System.out.println(<span class="string">"公交车乘16公里的价格: "</span> + calculator.calculatePrice(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(CalculateStrategy mStrategy)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mStrategy = mStrategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculatePrice</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mStrategy.calculatePrice(km);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="策略模式的实战应用"><a href="#策略模式的实战应用" class="headerlink" title="策略模式的实战应用"></a>策略模式的实战应用</h4><p>对于默认情况下，ImageLoader 会按照先后顺序加载图片，但在实际算法当中，相反顺序加载图片也是有可能的，既反序列加载图片。当然加载方式可看作多种策略，共同的目标是实现加载图片。图 2-13 是 ImageLoader 的 UML 类图。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-13.png" alt="ImageLoader的UML类图"></p><center>图 2-13 ImageLoader 的 UML 类图</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadPolicy</span> </span>&#123; <span class="comment">// 加载策略接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(BitmapRequest request1, BitmapRequest request2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺序加载策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialPolicy</span> <span class="keyword">implements</span> <span class="title">LoadPolicy</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(BitmapRequest request1, BitmapRequest request2)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 按照添加到队列的序列号顺序来执行</span></span><br><span class="line"><span class="keyword">return</span> request1.serialNum - request2.serialNum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆序加载策略，即从最后加入队列的请求进行加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pulbic <span class="class"><span class="keyword">class</span> <span class="title">ReversePolicy</span> <span class="keyword">implements</span> <span class="title">LoadPolicy</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(BitmapRequest request1, BitmapRequest request2)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注意: Bitmap 请求要先执行最晚加入队列的请求，ImageLoader 的策略 </span></span><br><span class="line"><span class="keyword">return</span> request2.serialNum - request1.serialNum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 因每个请求都有一序列号，序列号以递增形式增加，越晚加入队列的请求序列号越大。</span></span><br><span class="line"><span class="comment"> * 而请求队列是优先级队列，因此我们需要在图片加载请求类中实现 Comparable 接口，以实现对这些请求的排序处理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapRequest</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">BitmapRequest</span>&gt; </span>&#123; <span class="comment">// 加载策略</span></span><br><span class="line">LoadPolicy mLoadPolicy = <span class="keyword">new</span> SerialPolicy();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(BitmapRequest another)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 委托给 LoadPolicy 进行处理，实现按照策略模式</span></span><br><span class="line"><span class="keyword">return</span> mLoadPolicy.compare(<span class="keyword">this</span>, another);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户在配置 ImageLoader 时可以设置加载策略，</span></span><br><span class="line"><span class="comment"> * 这个策略会被设置给每个图片加载请求对象，具体如下：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> ImageView imageView, <span class="keyword">final</span> String uri, <span class="keyword">final</span> DisplayConfig config, <span class="keyword">final</span> ImageListener listener)</span> </span>&#123;</span><br><span class="line">BitmapRequest request = <span class="keyword">new</span> BitmapRequest(imageView, uri, config, listener);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 加载的配置对象，如果没有设置则使用 ImageLoader 的配置</span></span><br><span class="line">request.displayConfig = request.displayConfig != <span class="keyword">null</span> ?</span><br><span class="line">request.displayConfig : mConfig.displayConfig;</span><br><span class="line"> <span class="comment">// 设置加载策略</span></span><br><span class="line"> request.setLoadPolicy(mConfig.loadPolicy);</span><br><span class="line"> <span class="comment">// 添加到队列中</span></span><br><span class="line">mImageQueue.addRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><ul><li>策略模式的优缺点<ul><li>优点<br>1) 很好地演示了开闭原则，也就定义了抽象。<br>2) 耦合度相对较低，扩展方法。</li><li>缺点 - 随着策略的增加，子类会变得繁多。</li></ul></li></ul><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><ul><li>状态模式和策略模式和结构几乎一样，但它们的目的本质完全相异。<ul><li>状态模式：行为是平行的，不可替换的。</li><li>策略模式：行为彼此独立，可相互替换。</li></ul></li></ul><h4 id="状态模式的定义"><a href="#状态模式的定义" class="headerlink" title="状态模式的定义"></a>状态模式的定义</h4><p>当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p><h4 id="状态模式的使用场景"><a href="#状态模式的使用场景" class="headerlink" title="状态模式的使用场景"></a>状态模式的使用场景</h4><p>代码中包含大量与对象状态有关的条件语句。如操作中含有庞大的多分支语句 ( <code>if-else</code> 或 <code>switch-case</code> )，且这些分支依赖与该对象的状态。</p><p>若使用状态模式来优化架构，既每一条件分支放于独立的类。</p><h4 id="状态模式的-UML-类图"><a href="#状态模式的-UML-类图" class="headerlink" title="状态模式的 UML 类图"></a>状态模式的 UML 类图</h4><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-14.png" alt="状态模式的UML类图"></p><center>图 2-14 状态模式的 UML 类图</center> <h4 id="状态模式的简单示例"><a href="#状态模式的简单示例" class="headerlink" title="状态模式的简单示例"></a>状态模式的简单示例</h4><p>下面以电视遥控器为例演示状态模式的实现。便于理解，本示例的 UML 类图如图 2-15 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-15.png" alt="电视遥控器UML类图"></p><center>图 2-15 电视遥控器 UML 类图</center> <h4 id="状态模式实战"><a href="#状态模式实战" class="headerlink" title="状态模式实战"></a>状态模式实战</h4><p>在新浪微博中，用户在未登录的情况下点击转发按钮，此时会先让用户登录，然后再执行转发操作；如果已登录的情况下，那么用户输入转发的内容后就可以直接进行操作。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-16.png" alt="新浪微博用户状态管理UML类图"></p><center>图 2-16 新浪微博用户状态管理 UML 类图</center> <h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><ul><li>状态模式的优缺点<ul><li>优点 - 将所有与一个特定的状态相关的行为都放入一个状态对象中，它提供了一个更好的方法来组织与特定状态相关的代码，将繁琐的状态判断转为结构清晰的状态类族。</li><li>缺点 - 必然增加系统类和对象的个数。</li></ul></li></ul><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><h4 id="责任链模式的定义"><a href="#责任链模式的定义" class="headerlink" title="责任链模式的定义"></a>责任链模式的定义</h4><ul><li>行为型设计模式。</li><li>通俗定义：每个节点看作一对象，每一对象拥有不同的处理逻辑，将一请求从链式的首端发出，沿着链的路径一次传递每个节点对象，直至有对象处理这个请求为止。</li><li>标准定义：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成链，并沿着这条链传递该请求，直至有对象处理它为止。</li></ul><h4 id="责任链模式的使用场景"><a href="#责任链模式的使用场景" class="headerlink" title="责任链模式的使用场景"></a>责任链模式的使用场景</h4><ul><li>多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动态决定。</li><li>在请求处理者不明确的情况下向多个对象中的其一提交一个请求。</li><li>需要动态指定一组对象处理请求。</li></ul><h4 id="责任链模式的-UML-类图"><a href="#责任链模式的-UML-类图" class="headerlink" title="责任链模式的 UML 类图"></a>责任链模式的 UML 类图</h4><p>责任链模式的 UML 类图如图 2-17 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-17.png" alt="责任链模式UML类图"></p><center>图 2-17 责任链模式 UML 类图</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象处理者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> Handler successor; <span class="comment">// 下一节点的处理者</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> condition 请求条件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String condition)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的处理者1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String condition)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(condition.equals(<span class="string">"ConcreteHandler1"</span>)) &#123;</span><br><span class="line">System.out.println(<span class="string">"ConcreteHandler1 handled"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">successor.handleRequest(condition);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的处理者2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String condition)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(condition.equals(<span class="string">"ConcreteHandler2"</span>)) &#123;</span><br><span class="line">System.out.println(<span class="string">"ConcreteHandler2 handled"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">successor.handleRequest(condition);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 构造一个 ConcreteHandler1 对象</span></span><br><span class="line">ConcreteHandler1 handler1 = <span class="keyword">new</span> ConcreteHandler1();</span><br><span class="line"><span class="comment">// 构造一个 ConcreteHandler2 对象</span></span><br><span class="line">ConcreteHandler2 handler1 = <span class="keyword">new</span> ConcreteHandler2();</span><br><span class="line"><span class="comment">// 设置 handler1 的下一个节点</span></span><br><span class="line">handler1.successor = handler2;</span><br><span class="line"><span class="comment">// 设置 handler2 的下一个节点</span></span><br><span class="line">handler2.successor = handler1;</span><br><span class="line"><span class="comment">// 处理请求</span></span><br><span class="line">handler1.handleRequest(<span class="string">"ConcreteHandler2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="责任链模式的简单实现"><a href="#责任链模式的简单实现" class="headerlink" title="责任链模式的简单实现"></a>责任链模式的简单实现</h4><p>在公司中报销费用中，审批的流程其实就是一个类似责任链的实例。例如，小明是请求的发起者，而处理者有组长、部门主管、经理和老板，对于不同额度的报销费用需要不同级的处理者审批，准确地说，每一类人代表这条链上的一个节点。</p><p>例如小民是请求的发起者，而老板则是处于链条顶端的类，小民从链的底端开始发出一个申请报账的请求，首先由组长处理该请求，组长比对后发现自己权限不够于是将该请求转发给位于链中下一个节点的主管，主管比对后发现自己权限不足又将该请求转发给经理，经理也基于同样的原因将请求转发给老板，这样层层转达直至请求被处理。既至始至终小民关心的是报账结果，而不用在乎处理者是谁。责任链模式在这里很好地将请求的发起者与处理者解耦。</p><p>便于理解，本示例的 UML 类图如图 2-18 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-18.png" alt="报账审核机制UML类图"></p><center>图 2-18 报账审核机制 UML 类图</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象领导者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> Leader nextHandler; <span class="comment">// 上一级领导处理者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理报账请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> money 能批复的报账额度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>( money &lt; limit() ) &#123;</span><br><span class="line">handle(money);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">null</span> != nextHandlder ) &#123;</span><br><span class="line">nextHandler.handleRequest(money);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自身能批复的额度权限</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 额度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理报账行为</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> money 具体金额</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">pulbic <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> money)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupLeader</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">Ststen.out.println(<span class="string">"组长批复报销"</span> + money + <span class="string">"元"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">5000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">Ststen.out.println(<span class="string">"主管批复报销"</span> + money + <span class="string">"元"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">Ststen.out.println(<span class="string">"经理批复报销"</span> + money + <span class="string">"元"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">Ststen.out.println(<span class="string">"老板批复报销"</span> + money + <span class="string">"元"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小民从组长开始发起请求申请报账</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMin</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 构造各个领导对象</span></span><br><span class="line">GroupLeader groupLeader = <span class="keyword">new</span> GroupLeader();</span><br><span class="line">Director director = <span class="keyword">new</span> Director();</span><br><span class="line">Manager manager = <span class="keyword">new</span> Manager();</span><br><span class="line">Boss boss = <span class="keyword">new</span> Boss();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置上一级领导处理者对象</span></span><br><span class="line">groupLeader.nextHandler = director;</span><br><span class="line">director.nextHandler = manager;</span><br><span class="line">manager.nextHandler = boss;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起报账申请</span></span><br><span class="line">groupLeader.handleRequest(<span class="number">50000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="责任链模式实战"><a href="#责任链模式实战" class="headerlink" title="责任链模式实战"></a>责任链模式实战</h4><p>Android 中我们可以借鉴责任链模式的思想来优化 BroadcastReceiver 使之成为一个全局的责任链处理者。</p><p>我们知道 Broadcast 可以被分为两种:</p><ul><li>Normal Broadcast：普通广播，异步广播，发出时可被所有的接收者收到。</li><li>Ordered Broadcast：有序广播，依优先级依次传播的，直到有接收者将其终止或所有接收者都不终止它。</li></ul><p>有序广播这一特性与我们的责任链模式很相近，通过它可实现一种全局的责任链事件处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体的实现思路是，通过 Intent 的限制值来限定最终的广播权归谁所有</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取 Intent 中附加的限制值</span></span><br><span class="line"><span class="keyword">int</span> limit = intent.getIntExtra(<span class="string">"limit"</span>, -<span class="number">1001</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果限定值等于 1000 则处理，否则继续转发给下一个 Receiver</span></span><br><span class="line"><span class="keyword">if</span>( <span class="number">1000</span> == limit ) &#123;</span><br><span class="line"><span class="comment">// 获取 Intent 中附加的字符串消息并 Toast</span></span><br><span class="line">String msg = intent.getStringExtra(<span class="string">"msg"</span>);</span><br><span class="line">Toast.makeText(context, msg, Toast.LENGTH_SHORT).show();</span><br><span class="line"><span class="comment">// 终止广播</span></span><br><span class="line">abortBroadcast();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 添加信息发送给下一个 Receiver</span></span><br><span class="line">Bundle b = <span class="keyword">new</span> Bundle();</span><br><span class="line">b.putString(<span class="string">"new"</span>, <span class="string">"Message from FirstReceiver"</span>);</span><br><span class="line">setResultExtras(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取 Intent 中附加的限制值</span></span><br><span class="line"><span class="keyword">int</span> limit = intent.getIntExtra(<span class="string">"limit"</span>, -<span class="number">1001</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果限定值等于 100 则处理，否则继续转发给下一个 Receiver</span></span><br><span class="line"><span class="keyword">if</span>( <span class="number">100</span> == limit ) &#123;</span><br><span class="line"><span class="comment">// 获取 Intent 中附加的字符串消息</span></span><br><span class="line">String msg = intent.getStringExtra(<span class="string">"msg"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取上一个 Receiver 增加的消息</span></span><br><span class="line">Bundle b = getResultExtras(<span class="keyword">true</span>);</span><br><span class="line">String str = b.getString(<span class="string">"new"</span>);</span><br><span class="line"></span><br><span class="line">Toast.makeText(context, msg + str, Toast.LENGTH_SHORT).show();</span><br><span class="line"><span class="comment">// 终止广播</span></span><br><span class="line">abortBroadcast();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 添加信息发送给下一个 Receiver</span></span><br><span class="line">Bundle b = <span class="keyword">new</span> Bundle();</span><br><span class="line">b.putString(<span class="string">"new"</span>, <span class="string">"Message from FirstReceiver"</span>);</span><br><span class="line">setResultExtras(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取 Intent 中附加的限制值</span></span><br><span class="line"><span class="keyword">int</span> limit = intent.getIntExtra(<span class="string">"limit"</span>, -<span class="number">1001</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果限定值等于 10 则处理，否则继续转发给下一个 Receiver</span></span><br><span class="line"><span class="keyword">if</span>( <span class="number">10</span> == limit ) &#123;</span><br><span class="line"><span class="comment">// 获取 Intent 中附加的字符串消息</span></span><br><span class="line">String msg = intent.getStringExtra(<span class="string">"msg"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取上一个 Receiver 增加的消息</span></span><br><span class="line">Bundle b = getResultExtras(<span class="keyword">true</span>);</span><br><span class="line">String str = b.getString(<span class="string">"new"</span>);</span><br><span class="line"></span><br><span class="line">Toast.makeText(context, msg + str, Toast.LENGTH_SHORT).show();</span><br><span class="line"><span class="comment">// 终止广播</span></span><br><span class="line">abortBroadcast();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 添加信息发送给下一个 Receiver</span></span><br><span class="line">Bundle b = <span class="keyword">new</span> Bundle();</span><br><span class="line">b.putString(<span class="string">"new"</span>, <span class="string">"Message from FirstReceiver"</span>);</span><br><span class="line">setResultExtras(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_order);</span><br><span class="line"></span><br><span class="line">Button btnSend = (Button) findViewById(R.id.order_send_btn);</span><br><span class="line">btnSend.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">Intent i = <span class="keyword">new</span> Intent();</span><br><span class="line">i.setAction(<span class="string">"com.aigestudio.action.ORDER_BROADCAST"</span>);</span><br><span class="line">i.putExtra(<span class="string">"limit"</span>, <span class="number">100</span>);</span><br><span class="line">i.putExtra(<span class="string">"msg"</span>, <span class="string">"Message from OrderActivity"</span>);</span><br><span class="line">sendOrderedBroadcast(i, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里我们设置 limit = 100，既只有 SecondReceiver 才会处理它。</span></span><br></pre></td></tr></table></figure><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><ul><li>责任链模式的优缺点<ul><li>优点 - 对请求者和处理者关系解耦，提高代码灵活性。</li><li>缺点 - 递归调用。特别是处理者太多，那么遍历定会影响性能。</li></ul></li></ul><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><h4 id="解释器模式的定义"><a href="#解释器模式的定义" class="headerlink" title="解释器模式的定义"></a>解释器模式的定义</h4><ul><li>行为型设计模式。</li><li>概念：给定一个语言，定义它的 <code>文法</code> 的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</li><li>文法：例如我们熟悉的「主谓宾结构」，通过下述短语举例，我们可把短语抽象看作：I am a/an [noun.]</li></ul><table><thead><tr><th>主语</th><th>谓语</th><th>宾语</th></tr></thead><tbody><tr><td>I</td><td>am</td><td>a designer</td></tr><tr><td>I</td><td>am</td><td>a teacher</td></tr></tbody></table><ul><li><p>再举例：假设有如以 ab 开头 ef 结尾，中间排列 N(N&gt;=0) 个 cd 的字符串。</p><blockquote><p>abcdcd…cdef</p></blockquote><p>在计算机科学中，我们将上述字符串中的 “a”、“b”、“c”、“d”、“e” 和 “f” 这 6 个字符称为一种形式语言的 <code>字符表</code>。</p><p>而这些字符组成的集合，如 “abcdcd…cdef” 这样由字符表构成的字符串则称为 <code>形式语言</code>。注意这里的语言不是文法。</p><p>假设定义一个符号 S，从符号 S 出发推导上述字符串，既可得到如下推导式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S ::= abA*ef  </span><br><span class="line">A ::= cd</span><br></pre></td></tr></table></figure></li></ul><ul><li><code>::==</code> 称为推导；  </li><li><code>*</code> 表示闭包，上述推导式中意思是，符号 A 可以有 0 或 N 个重复；  </li><li>非终结符号：<code>S</code> 和 <code>A</code> 则称非终结符号，既它们能推导出式子右边的表达式；  </li><li>终结符号：”pqmn”，“ab”，“ef”，既无法再推导；</li></ul><h4 id="解释器模式的使用场景"><a href="#解释器模式的使用场景" class="headerlink" title="解释器模式的使用场景"></a>解释器模式的使用场景</h4><ul><li><p>某个 <code>简单语言</code> 需要解释执行且可将该语言中的语句表示为 <code>抽象语法树</code> 时可考虑使用解释器模式。</p><blockquote><p>如：有非终结符号 p+q+m-n，既该数学表示式可表示为一棵抽象语法树。如图 2-19 所示。</p></blockquote></li></ul><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-19.png" alt="p+q+m-n的抽象语法树"></p><center>图 2-19 p+q+m-n 的抽象语法树</center><ul><li><p>某些特定的领域出现不断重复的问题时，可将该领域的问题转化为一种语法规则下的语句，然后构建解释器来解释该语句。</p><blockquote><p>英文字母的大小写转换；阿拉伯数字转为中文的数字…<br>既它们都是一个个终结符，不同的只是具体内容。</p></blockquote></li></ul><h4 id="解释器模式的-UML-类图"><a href="#解释器模式的-UML-类图" class="headerlink" title="解释器模式的 UML 类图"></a>解释器模式的 UML 类图</h4><p>解释器模式的 UML 类图如图 2-20 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-20.png" alt="解释器模式UML类图"></p><center>图 2-20 解释器模式 UML 类图</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象的解析方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctx 上下文环境对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(Context ctx)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终结符表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(Context ctx)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 实现文法中与终结符有关的解释操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非终结符表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonterminalExpression</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(Context ctx)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 实现文法中与非终结符有关的解释操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"><span class="comment">// 包含解释器之外的全局信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据文法对特定句子构建抽象语法树后解释</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><ul><li>解释模式的优缺点<ul><li>优点 - 灵活的扩展性，既我们想对文法规则进行扩展延伸时，只需增加相应的非终结符解释器，并在构建抽象语法树时，使用到新增的解释器对象进行具体的解释即可。</li><li>缺点<br>1) 对于每一条文法对应至少一个解释器，其会生成大量的类，导致后期维护困难；<br>2) 构建其抽象语法树会显得异常繁琐，甚至可能出现需要构建多棵抽象语法树的情况。</li></ul></li></ul><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h4 id="命令模式的定义"><a href="#命令模式的定义" class="headerlink" title="命令模式的定义"></a>命令模式的定义</h4><ul><li>行为型设计模式。</li><li>介绍：将一系列的方法调用封装，用户只需调用一个方法执行，那么所有这些被封装的方法就会被挨个执行调用。</li><li>定义：<ul><li>将一个请求封装成一个对象，从而让用户使用不同的请求把客户端参数化。</li><li>对请求排队或者记录请求日志，以及支持可撤销的操作。</li></ul></li></ul><h4 id="命令模式的使用场景"><a href="#命令模式的使用场景" class="headerlink" title="命令模式的使用场景"></a>命令模式的使用场景</h4><ul><li>需要抽象出待执行的动作，然后以参数的形式提供处理 (类似过程设计中的回调机制)。</li><li>在不同的时刻指定、排列和执行请求。一个命令对象可以有与初始请求无关的生存期。</li><li>需要支持取消操作。</li><li>需要支持事务操作。</li><li>支持修改日志功能，若系统崩溃，这些修改可重做一遍。</li></ul><h4 id="命令模式的-UML-类图"><a href="#命令模式的-UML-类图" class="headerlink" title="命令模式的 UML 类图"></a>命令模式的 UML 类图</h4><p>命令模式的 UML 类图如图 2-21 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-21.png" alt="命令模式UML类图"></p><center>图 2-21 命令模式 UML 类图</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正执行具体命令逻辑的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"执行具体操作"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象命令接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行具体操作的命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Receiver receiver; <span class="comment">// 持有一个对接受者对象的引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用接收者的相关方法来执行具体逻辑</span></span><br><span class="line">receiver.action();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Command command; <span class="comment">// 持有一个对应命令对象的引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.command = command;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用具体命令对象的相关方法，执行具体命令</span></span><br><span class="line">command.execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 构造一个接受者对象</span></span><br><span class="line">Receiver receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line"><span class="comment">// 根据接收者对象构造一个命令对象</span></span><br><span class="line">Command command = <span class="keyword">new</span> ConcreteCommand(receiver);</span><br><span class="line"><span class="comment">// 根据具体的对象构造请求者对象</span></span><br><span class="line">Invoker invoker = <span class="keyword">new</span> Invoker(command);</span><br><span class="line"><span class="comment">// 执行请求方法</span></span><br><span class="line">invoker.action();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Receiver：接收者角色</strong><br>该类负责具体实施或执行一个请求，通俗地说，执行具体逻辑的角色。</p><p><strong>Command：命令角色</strong><br>定义所有具体命令类的抽象接口。</p><p><strong>ConcreteCommand：具体命令角色</strong><br>该类实现了 Command 接口，在 execute() 方法中调用接收者角色的相关方法，在接收者和命令执行的具体行为之间加以弱耦和。</p><p><strong>Invoker：请求者角色</strong><br>该类的职责就是调用命令对象执行具体的请求，相关的方法我们称为行动方法。</p><p>这里其实大家可以看到，命令模式的应用其实可用一句话概述，就是将行为调用者与实现者解耦。</p><h4 id="命令模式的简单实现"><a href="#命令模式的简单实现" class="headerlink" title="命令模式的简单实现"></a>命令模式的简单实现</h4><p>这里以古老的俄罗斯方块游戏为例，在命令模式下如何操控俄罗斯方块变换。游戏中含有 4 个按钮，既上下左右。设定玩游戏的人相当于我们的客户端，游戏上的 4 个按钮相当于请求者，而执行具体按钮命令的逻辑方法可看作命令角色。</p><p>便于理解，本示例的 UML 类图如图 2-22 所示。</p><p><img src="/images/illustration/Reading/2018/01/Design-Pattern-Based-on-Android_2-22.png" alt="命令模式实现俄罗斯方块游戏"></p><center>图 2-22 命令模式实现俄罗斯方块游戏</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收者角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TetrisMachine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toLeft</span><span class="params">()</span> </span>&#123; <span class="comment">// 真正处理 “向左” 操作的逻辑代码</span></span><br><span class="line">System.out.println(“向左”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toRight</span><span class="params">()</span> </span>&#123; <span class="comment">// 真正处理 “向右” 操作的逻辑代码</span></span><br><span class="line">System.out.println(“向右”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fastToBottom</span><span class="params">()</span> </span>&#123; <span class="comment">// 真正处理 “快速落下” 操作的逻辑代码</span></span><br><span class="line">System.out.println(“快速落下”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123; <span class="comment">// 真正处理 “改变形状” 操作的逻辑代码</span></span><br><span class="line">System.out.println(“改变形状”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令者抽象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 命令执行方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令者：向左移的命令类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"><span class="comment">// 持有一个接收者俄罗斯方块游戏对象的引用</span></span><br><span class="line"><span class="keyword">private</span> TetrisMachine machine;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeftCommand</span><span class="params">(TetriMachine machine)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.machine = machine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用游戏机里的具体方法执行操作</span></span><br><span class="line">machine.toLeft();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令者：向右移的命令类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"><span class="comment">// 持有一个接收者俄罗斯方块游戏对象的引用</span></span><br><span class="line"><span class="keyword">private</span> TetrisMachine machine;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RightCommand</span><span class="params">(TetriMachine machine)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.machine = machine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用游戏机里的具体方法执行操作</span></span><br><span class="line">machine.toRight();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令者：快速落下的命令类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FallCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"><span class="comment">// 持有一个接收者俄罗斯方块游戏对象的引用</span></span><br><span class="line"><span class="keyword">private</span> TetrisMachine machine;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FallCommand</span><span class="params">(TetriMachine machine)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.machine = machine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用游戏机里的具体方法执行操作</span></span><br><span class="line">machine.fastToBottom();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令者：改变形状的命令类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"><span class="comment">// 持有一个接收者俄罗斯方块游戏对象的引用</span></span><br><span class="line"><span class="keyword">private</span> TetrisMachine machine;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TransformCommand</span><span class="params">(TetriMachine machine)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.machine = machine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用游戏机里的具体方法执行操作</span></span><br><span class="line">machine.transform();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求者类：命令由按钮发起</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Buttons</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> LeftCommand leftCommand; <span class="comment">// 向左移动的命令对象引用</span></span><br><span class="line"><span class="keyword">private</span> RightCommand rightCommand; <span class="comment">// 向右移动的命令对象引用</span></span><br><span class="line"><span class="keyword">private</span> FallCommand fallCommand; <span class="comment">// 快速落下的命令对象引用</span></span><br><span class="line"><span class="keyword">private</span> TransformCommand transformCommand; <span class="comment">// 变换形状的命令对象引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置向左移动的命令对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> leftCommand 向左移动的命令对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftCommand</span><span class="params">(LeftCommand leftCommand)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.leftCommand = leftCommand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置向右移动的命令对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rightCommand 向右移动的命令对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightCommand</span><span class="params">(RightCommand rightCommand)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.rightCommand = rightCommand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置快速落下的命令对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fallCommand 向左移动的命令对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFallCommand</span><span class="params">(FallCommand fallCommand)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.fallCommand = fallCommand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置变换形状的命令对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> transformCommand 向左移动的命令对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransformCommand</span><span class="params">(TransformCommand transformCommand)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.leftCommand = leftCommand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toLeft</span><span class="params">()</span> </span>&#123; <span class="comment">// 按下按钮向左移动</span></span><br><span class="line">leftCommand.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toRight</span><span class="params">()</span> </span>&#123; <span class="comment">// 按下按钮向右移动</span></span><br><span class="line">rightCommand.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fall</span><span class="params">()</span> </span>&#123; <span class="comment">// 按下按钮快速落下</span></span><br><span class="line">fallCommand.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123; <span class="comment">// 按下按钮改变形状</span></span><br><span class="line">transformCommand.execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 首先要有俄罗斯方块游戏</span></span><br><span class="line">TetrisMachine machine = <span class="keyword">new</span> TetrisMachine();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据游戏我们构造 4 种命令</span></span><br><span class="line">LeftCommand leftCommand = <span class="keyword">new</span> LeftCommand(machine);</span><br><span class="line">RightCommand rightCommand = <span class="keyword">new</span> RightCommand(machine);</span><br><span class="line">FallCommand fallCommand = <span class="keyword">new</span> FallCommand(machine);</span><br><span class="line">TransformCommand transformCommand = <span class="keyword">new</span> TransformCommand(machine);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮可以执行不同的命令</span></span><br><span class="line">Buttons buttons = <span class="keyword">new</span> Buttons();</span><br><span class="line">buttons.setLeftCommand(leftCommand);</span><br><span class="line">buttons.setRightCommand(rightCommand);</span><br><span class="line">buttons.setFallCommand(fallCommand);</span><br><span class="line">buttons.setTransformCommand(transformCommand);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体按下哪个按钮玩家决定</span></span><br><span class="line">buttons.toLeft();</span><br><span class="line">buttons.toRight();</span><br><span class="line">buttons.fall();</span><br><span class="line">buttons.transform();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于大部分开发者来说，更愿意接受的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TetrisMachine machine = <span class="keyword">new</span> TetrisMachine();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现怎样的控制方式，直接调用相关函数</span></span><br><span class="line"><span class="comment">// machine.toLeft();</span></span><br><span class="line"><span class="comment">// machine.toRight();</span></span><br><span class="line"><span class="comment">// machine.fastToBottom();</span></span><br><span class="line"><span class="comment">// machine.transform();</span></span><br><span class="line"></span><br><span class="line">machine.toLeft();</span><br></pre></td></tr></table></figure><p>调用逻辑做得如此复杂，其实是为了开发起来方便，既每次我们增加或修改游戏功能只需修改 TetrisMachine 类即可。<br>当然，其实这样做是有原因的，既设计模式种有一条重要的原则：对修改关闭对扩展开放。具体好处是：</p><ul><li>如修改功能、代码的具体逻辑，以上例为例，即修改 TetrisMachine 类即可。</li><li>此外，命令模式还可以实现命令记录的功能，如在 Buttons 里使用数据结构存储执行过的命令对象，需要时可恢复。</li></ul><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><ul><li>命令模式的优缺点<ul><li>优点 - 更灵活的控制性以及更好的扩展性；更弱的耦合性。</li><li>缺点 - 类的膨胀，大量衍生类的创建。</li></ul></li></ul><h2 id="叁-MVC与MVP模式"><a href="#叁-MVC与MVP模式" class="headerlink" title="叁 MVC与MVP模式"></a>叁 MVC与MVP模式</h2><p>待补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;更新进度&lt;ul&gt;
&lt;li&gt;2018.01.30 - 完成序言；&lt;/li&gt;
&lt;li&gt;2018.01.31 - 更新第壹章；&lt;/li&gt;
&lt;li&gt;2018.02.05 - 更新第贰章，共 10 / 23 种设计模式；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;在你接触过的安卓项目当中，你所接触过的，如监听器、适配器、迭代器等并不陌生，然而它们无不体现着设计模式的精髓。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://www.kofes.cn/categories/Reading/"/>
    
    
      <category term="Android" scheme="http://www.kofes.cn/tags/Android/"/>
    
      <category term="设计模式" scheme="http://www.kofes.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>基于 Hexo 框架在 Github 上搭建博客</title>
    <link href="http://www.kofes.cn/2018/01/Hexo-Installation-Guide.html"/>
    <id>http://www.kofes.cn/2018/01/Hexo-Installation-Guide.html</id>
    <published>2018-01-19T10:46:03.000Z</published>
    <updated>2018-01-22T03:17:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>Hexo\(^{[1]}\)，一个快速、简洁且高效的博客框架，若以个人博文为主导需求，它的强大毋庸置疑。    </p><p>Hexo 支持 GitHub Flavored Markdown 的所有功能；且基于 Node.Js 所带来的超快生成速度，百页博文秒级渲染；开放性 API 以及丰富的插件等，即功能来得纯粹，不失个性化定制，上手容易且操作便捷。更重要的一点，它是开源的、免费的博客框架，数据保存在本地以及 Github 上，相信在众多博客产品中选择、博弈，相信 Hexo 的表现不会令你失望。</p><p>对于 Hexo 的安装、使用教程尽量遵照官方使用文档的流程操作，而本文则将侧重于 Hexo 的优化体验、实用插件等方面的内容分享。</p><p>若想了解详情可访问「<a href="https://hexo.io/" target="_blank" rel="noopener">hexo.io</a>」。</p><a id="more"></a><h2 id="壹-搭建环境"><a href="#壹-搭建环境" class="headerlink" title="壹 搭建环境"></a>壹 搭建环境</h2><ul><li>Mac OS、Windows 环境下的配置流程和步骤大同小异，而搭建环境的大致流程为：  <ul><li>Git 环境配置 ( Windows )</li><li>Node.Js 环境配置</li><li>Github 账号注册和配置</li><li>Hexo 的安装和配置</li></ul></li><li>考虑到是流程操作类的文章，为简单起见，则我们以 MacOS 和 Windows 版本分别说明情况：<ul><li><a href="#MacOS-版本">MacOS 版本</a></li><li><a href="#Windows-版本">Windows 版本</a></li></ul></li></ul><h3 id="MacOS-版本"><a href="#MacOS-版本" class="headerlink" title="MacOS 版本"></a>MacOS 版本</h3><h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><ul><li>Xcode: Hexo的编译依赖于 Xcode<ul><li>Xcode 可自行到 Apple App Store 下载</li></ul></li><li><p>Node.Js: Hexo 是基于 Node.Js 开发的</p><ul><li><a href="https://nodejs.org/" target="_blank" rel="noopener">官方下载</a></li><li>本地安装，文件包为「Node-Vx.x.x.pkg」</li><li><p>检测是否安装成功，当然返回版本信息即成功安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端下输入命令:  </span></span><br><span class="line">node -v  </span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>Github Account ( <strong>已有账号、项目可忽略</strong> )</p><ul><li>注册账号「<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>」</li><li><p>创建代码库 </p><blockquote><p>具体操作步骤:  </p><ol><li>Add ( 右上角「+」图标 ) &gt; New Repository；  </li><li>Repository Name，填写<code>yourname.github.io</code>；        </li><li>Repository Description，填写<code>简单描述</code>；</li></ol></blockquote></li><li><p>配置代码库</p><blockquote><p>具体操作步骤:  </p><ol><li>进入项目「yourname.github.io」；  </li><li>Settings &gt; GitHub Pages，开启<code>GH-Pages</code>功能；  </li><li>点击「Launch Automatic Page Generator」；</li></ol><p>第三步说明:<br>Github 将会自动替你创建出一个 GH-Pages 的页面。若配置没有问题，约15分钟后，yourname.github.io 就可以正常访问了，配置结束。</p></blockquote></li></ul></li></ul><h4 id="安装-HEXO"><a href="#安装-HEXO" class="headerlink" title="安装 HEXO"></a>安装 HEXO</h4><h5 id="安装-HEXO-1"><a href="#安装-HEXO-1" class="headerlink" title="安装 HEXO"></a>安装 HEXO</h5><ul><li><p>本地选择安装目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> your-hexo-site</span><br></pre></td></tr></table></figure></li><li><p>在线安装 HEXO ( <a href="http://npm.taobao.org/" target="_blank" rel="noopener">NPM淘宝源</a> )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g  </span><br><span class="line">hexo init  </span><br><span class="line">hexo install</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>检测是否安装成功，当然返回版本信息即成功安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure></li></ul><h5 id="运作-HEXO"><a href="#运作-HEXO" class="headerlink" title="运作 HEXO"></a>运作 HEXO</h5><ul><li><p>本地运作 HEXO</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server<span class="comment"># 或简写 hexo s</span></span><br></pre></td></tr></table></figure></li><li><p>当终端提示以下信息，则本地配置工作基本完成。</p><blockquote><p>Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>. Press Ctrl+C to stop.</p></blockquote></li></ul><h5 id="使用-HEXO"><a href="#使用-HEXO" class="headerlink" title="使用 HEXO"></a>使用 HEXO</h5><blockquote><p>[注意] 此项操作，需要确保在 Hexo 安装目录下执行。</p></blockquote><ul><li><p>新建一篇博文 ( 当然，更新过往的文章只需修改「Hexo &gt; Source &gt; _Posts」目录下相应的 MarkDown 文件 )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">"Article Title"</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>生成博文 ( 生成静态网页 )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure></li></ul><h5 id="部署至-GitHub"><a href="#部署至-GitHub" class="headerlink" title="部署至 GitHub"></a>部署至 GitHub</h5><ul><li><p>部署至 Git 的准备工作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在部署前，还需要安装「Git部署插件」:  </span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若没有安装该插件，会出现情况：</span></span><br><span class="line"><span class="comment"># deloyer not found:git</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>再者，与 Github 连接前需要获得授权，不然会出现以下情况 ( 本机没有配置 Public Key ):</p><blockquote><p>Permission denied (publickey).<br>fatal: Could not read from remote repository.<br>Please make sure you have the correct access rights and the repository exists.</p></blockquote></li><li><p>配置「SSH KEY / Public KEY」</p><blockquote><p>[注意] 若之前机器上配置了 Git 的信息，请跳过该步骤。</p></blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 配置 Git 的 UserName 和 Email </span></span><br><span class="line"><span class="comment"># “YourAnonymousName"，可以替换成自己的用户名   </span></span><br><span class="line">git config --global user.name <span class="string">"YourAnonymousName"</span>  </span><br><span class="line"><span class="comment"># "UserName@xxx.com"，替换成自己的邮箱  </span></span><br><span class="line">git config --global user.email <span class="string">"UserName@xxx.com"</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 检查是否已经有 SSH KEY </span></span><br><span class="line"><span class="comment"># Step01. 列出该目录下的文件；</span></span><br><span class="line"><span class="comment"># Step02. 看是否存在「id_isa」和「id_isa.pub」文件；</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">ls</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Step03. 若存在则跳过，没有则执行此步骤「生成密钥」.</span></span><br><span class="line"><span class="comment"># 邮箱「UserName@xxx.com」替换成自己的邮箱</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"UserName@xxx.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 登陆 Github, 添加 SSH KEY</span></span><br><span class="line"><span class="comment"># Step01. Avatar(头像) &gt; Settings &gt; Personal Settings &gt; SSH and GPG keys； </span></span><br><span class="line"><span class="comment"># Step02. New SSH KEY，把「id_isa.pub」的密钥粘贴过去即可.  </span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 4. 测试是否配置成功</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"><span class="comment"># 提示「Hi YourName! You've successfully authenticated, but GitHub does not provide shell. access.」即成功配置。</span></span><br></pre></td></tr></table></figure></li><li><p>配置「_config.yml」文件  </p><ul><li><p>在 Hexo 安装目录下找到 _config.yml 文件，如「~/你的安装目录/Hexo/_config.yml」。找到「deploy」字段，修改配置。</p><blockquote><p>deploy:<br>type: git<br>repo: <a href="https://github.com/yourname/yourname.github.io.git" target="_blank" rel="noopener">https://github.com/yourname/yourname.github.io.git</a><br>branch: master  </p></blockquote></li><li><p>注意: 冒号后面含一个空格；使用 Github 不用 branch 字段；若使用多个 deployer，则有：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- <span class="built_in">type</span>: git</span><br><span class="line">repo:</span><br><span class="line">- <span class="built_in">type</span>: heroku </span><br><span class="line">repo:</span><br></pre></td></tr></table></figure></li></ul></li><li><p>部署至 Git</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy  </span><br><span class="line">hexo d -g<span class="comment"># 即在部署之前先生成</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Windows-版本"><a href="#Windows-版本" class="headerlink" title="Windows 版本"></a>Windows 版本</h3><h4 id="配置环境-1"><a href="#配置环境-1" class="headerlink" title="配置环境"></a>配置环境</h4><blockquote><p>Github 账号注册和配置和 Hexo 的安装和配置，在 Windows 与 MacOS 上是通用的。因此，在 Windows 版本中，主要阐述 Node.Js和 Git 的安装和配置即可。</p></blockquote><ul><li><p>Node.Js 的安装和准备</p><ul><li>下载并安装「<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.Js for Windows x86/x64 bit</a>」</li><li><p>检测是否安装成功，当然返回版本信息即成功安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v  </span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>Git 的安装和准备</p><ul><li>下载并安装「<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git for Windows x86/x64 bit</a>」</li><li><p>检测是否安装成功，当然返回版本信息即成功安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="贰-优化拓展"><a href="#贰-优化拓展" class="headerlink" title="贰 优化拓展"></a>贰 优化拓展</h2><p>至此，Hexo 的安装以及 GitHub 的配置工作暂告一段落。能正常运行使用 Hexo 是没问题的，而下面的章节则是对 Hexo 的扩展和个性化定制，根据自己的需求挑选阅读、实践。</p><h3 id="套用一款主题"><a href="#套用一款主题" class="headerlink" title="套用一款主题"></a>套用一款主题</h3><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。</p><p>在 Hexo 中有两份主要的配置文件，其名称都是「_config.yml」。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p><p>为了描述方便，在以下说明中，将前者称为「<code>站点配置文件</code>」， 后者称为「<code>主题配置文件</code>」。</p><p>具体以 NexT\(^{[2]}\) 为例说明，安装步骤如下。</p><h4 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h4><p>如果你熟悉 Git， 建议你使用<code>克隆最新版本</code>的方式，之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆最新版本</span></span><br><span class="line"><span class="built_in">cd</span> your-hexo-site  </span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next. themes/next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速更新</span></span><br><span class="line"><span class="built_in">cd</span> themes/next</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h4 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h4><ul><li><p>与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到<code>theme</code>字段，并将其值更改为<code>next</code>。</p><blockquote><p>theme: next</p></blockquote></li><li><p>到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></li></ul><h4 id="主题设定"><a href="#主题设定" class="headerlink" title="主题设定"></a>主题设定</h4><ul><li><p>选择 Scheme</p><p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：</p><ul><li>Muse - 默认 Scheme，黑白主调，大量留白  </li><li>Mist - Muse 的紧凑版本，整洁有序的单栏外观  </li><li><p>Pisces - 双栏 Scheme，小家碧玉似的清新  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line">scheme: Pisces</span><br></pre></td></tr></table></figure><blockquote><p>Scheme 的切换通过更改<code>主题配置文件</code>，搜索「scheme」关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。</p></blockquote></li></ul></li><li><p>设置语言</p><p>  编辑<code>站点配置文件</code>， 将<code>language</code>设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下 ( 更多请语言配置请参考下述表格 )：</p><blockquote><p>language: zh-Hans  </p></blockquote></li></ul><table><thead><tr><th style="text-align:left">语言</th><th style="text-align:left">代码</th><th style="text-align:left">设定示例</th></tr></thead><tbody><tr><td style="text-align:left">English</td><td style="text-align:left">en</td><td style="text-align:left">language: en</td></tr><tr><td style="text-align:left">简体中文</td><td style="text-align:left">zh-Hans</td><td style="text-align:left">language: zh-Hans</td></tr><tr><td style="text-align:left">Français</td><td style="text-align:left">fr-FR</td><td style="text-align:left">language: fr-FR</td></tr><tr><td style="text-align:left">Português</td><td style="text-align:left">pt</td><td style="text-align:left">language: pt or pt-BR</td></tr><tr><td style="text-align:left">繁體中文</td><td style="text-align:left">zh-hk</td><td style="text-align:left">language: zh-hk</td></tr><tr><td style="text-align:left">Русский</td><td style="text-align:left">язык    ru</td><td style="text-align:left">language: ru</td></tr><tr><td style="text-align:left">Deutsch</td><td style="text-align:left">de</td><td style="text-align:left">language: de</td></tr><tr><td style="text-align:left">日本語</td><td style="text-align:left">ja</td><td style="text-align:left">language: ja</td></tr><tr><td style="text-align:left">Indonesian</td><td style="text-align:left">id</td><td style="text-align:left">language: id</td></tr><tr><td style="text-align:left">Korean</td><td style="text-align:left">ko</td><td style="text-align:left">language: ko</td></tr></tbody></table><ul><li><p>设置菜单</p><p>  菜单配置包括三个部分，第一是菜单项 ( 名称和链接 )，第二是菜单项的显示文本，第三是菜单项对应的图标。</p><p>  NexT 使用的是 <a href="http://fontawesome.io/" target="_blank" rel="noopener">Font Awesome</a>\(^{[3]}\) 提供的图标，600+ 的图标可满足大部分需求，且适配 Retina 屏幕。</p><p>  编辑<code>主题配置文件</code>，修改以下内容：</p>   <div class="note warning"><p>请注意键值（如 home）的大小写要严格匹配。 </p></div><ul><li><p>设定菜单内容，对应的字段是<code>menu</code>，菜单内容的设置格式是：<code>item name: link</code>。其中<code>item name</code>是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: /</span><br><span class="line">archives: /archives</span><br><span class="line"><span class="comment">#about: /about</span></span><br><span class="line"><span class="comment">#categories: /categories</span></span><br><span class="line">tags: /tags</span><br><span class="line"><span class="comment">#commonweal: /404.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若你的站点运行在子目录中，请将链接前缀的/去掉</span></span><br></pre></td></tr></table></figure><p> NexT 默认的菜单项有( 标注 <code>*</code> 的项表示需要手动创建这个页面 )：</p></li></ul></li></ul><table><thead><tr><th style="text-align:left">键值</th><th style="text-align:left">设定值</th><th style="text-align:left">显示文本(简体中文)</th></tr></thead><tbody><tr><td style="text-align:left">home</td><td style="text-align:left">home: /</td><td style="text-align:left">主页</td></tr><tr><td style="text-align:left">archives</td><td style="text-align:left">archives: /archives</td><td style="text-align:left">归档页</td></tr><tr><td style="text-align:left">categories</td><td style="text-align:left">categories: /categories</td><td style="text-align:left">分类页 <code>*</code></td></tr><tr><td style="text-align:left">tags</td><td style="text-align:left">tags: /tags</td><td style="text-align:left">标签页 <code>*</code></td></tr><tr><td style="text-align:left">about</td><td style="text-align:left">about: /about</td><td style="text-align:left">关于页面 <code>*</code></td></tr><tr><td style="text-align:left">commonweal</td><td style="text-align:left">commonweal: /404.html</td><td style="text-align:left">公益 404 <code>*</code></td></tr></tbody></table><ul><li><p>设置菜单项的显示文本，在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用这个名称查找对应的语言翻译，并提取显示文本。</p><p>  这些翻译文本放置在 NexT 主题目录下的<code>languages/{language}.yml</code> （ {language} 为你所使用的语言 )。</p><p>  以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件<code>languages/zh-Hans.yml</code>，在<code>menu</code>字段下添加一项：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: 首页</span><br><span class="line">archives: 归档</span><br><span class="line">categories: 分类</span><br><span class="line">tags: 标签</span><br><span class="line">about: 关于</span><br><span class="line">search: 搜索</span><br><span class="line">commonweal: 404</span><br><span class="line">something: 有料</span><br></pre></td></tr></table></figure></li><li><p>设定菜单项的图标，对应的字段是<code>menu_icons</code>。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">menu_icons:</span><br><span class="line"><span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line"><span class="comment"># Icon Mapping.</span></span><br><span class="line">home: home</span><br><span class="line">about: user</span><br><span class="line">categories: th</span><br><span class="line">tags: tags</span><br><span class="line">archives: archive</span><br><span class="line">commonweal: heartbeat</span><br><span class="line"></span><br><span class="line"><span class="comment">#  此设定格式是「item name: icon name」</span></span><br><span class="line"><span class="comment"># 「item name」与上一步所配置的菜单名字对应</span></span><br><span class="line"><span class="comment"># 「icon name」是 Font Awesome 图标的名字</span></span><br><span class="line"><span class="comment"># 「enable」用于控制是否显示图标，你可以设置成「false」来去掉图标</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>设置侧栏 </p><p>  可以通过修改<code>主题配置文件</code>中的<code>sidebar</code>字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。</p><ul><li><p>设置侧栏的位置，修改 sidebar.position 的值，支持的选项有：</p><blockquote><p>left - 靠左放置<br>right - 靠右放置  </p></blockquote><p> 目前仅 Pisces Scheme 支持 position 配置。影响版本5.0.0及更低版本。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sidebar:  </span><br><span class="line">position: left</span><br></pre></td></tr></table></figure></li><li><p>设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有：</p><blockquote><p>post - 默认行为，在文章页面（ 拥有目录列表 ）时显示<br>always - 在所有页面中都显示<br>hide - 在所有页面中都隐藏（ 可以手动展开 ）<br>remove - 完全移除  </p></blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">display: post</span><br></pre></td></tr></table></figure><p> 已知侧栏在 use motion: false 的情况下不会展示。影响版本5.0.0及更低版本。</p></li></ul></li><li><p>设置头像</p><p>  编辑<code>主题配置文件</code>， 修改字段<code>avatar</code>，值设置成头像的链接地址。其中，头像的链接地址可以是：</p><ul><li><p>站外链接</p><blockquote><p>avatar: <a href="http://example.com/avatar.png" target="_blank" rel="noopener">http://example.com/avatar.png</a></p></blockquote></li><li><p>站内资源 </p><blockquote><p>放置在「source/images/」目录下，images 为自建目录<br>avatar: avatar: /images/avatar.png</p></blockquote></li></ul></li></ul><h3 id="揽收实用插件"><a href="#揽收实用插件" class="headerlink" title="揽收实用插件"></a>揽收实用插件</h3><h2 id="叁-参考资料"><a href="#叁-参考资料" class="headerlink" title="叁 参考资料"></a>叁 参考资料</h2><p><a href="https://hexo.io/docs/" target="_blank" rel="noopener">[1] HexoJs.使用文档.2018</a><br><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">[2] NexT.使用文档.2018</a><br><a href="http://fontawesome.io/accessibility/" target="_blank" rel="noopener">[3] Dave Gandy.Font Awesome Accessibility</a><br><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53576018" target="_blank" rel="noopener">[4] 徐俊.手把手教你搭建属于自己的博客.CSDN.2017</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;Hexo\(^{[1]}\)，一个快速、简洁且高效的博客框架，若以个人博文为主导需求，它的强大毋庸置疑。    &lt;/p&gt;
&lt;p&gt;Hexo 支持 GitHub Flavored Markdown 的所有功能；且基于 Node.Js 所带来的超快生成速度，百页博文秒级渲染；开放性 API 以及丰富的插件等，即功能来得纯粹，不失个性化定制，上手容易且操作便捷。更重要的一点，它是开源的、免费的博客框架，数据保存在本地以及 Github 上，相信在众多博客产品中选择、博弈，相信 Hexo 的表现不会令你失望。&lt;/p&gt;
&lt;p&gt;对于 Hexo 的安装、使用教程尽量遵照官方使用文档的流程操作，而本文则将侧重于 Hexo 的优化体验、实用插件等方面的内容分享。&lt;/p&gt;
&lt;p&gt;若想了解详情可访问「&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo.io&lt;/a&gt;」。&lt;/p&gt;
    
    </summary>
    
      <category term="Project" scheme="http://www.kofes.cn/categories/Project/"/>
    
    
      <category term="hexo" scheme="http://www.kofes.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 - Java 技术手册</title>
    <link href="http://www.kofes.cn/2017/09/Java-in-a-Nutshell.html"/>
    <id>http://www.kofes.cn/2017/09/Java-in-a-Nutshell.html</id>
    <published>2017-09-01T08:01:47.000Z</published>
    <updated>2018-01-30T09:40:28.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>更新进度</p><ul><li>2017.09.01 - 整理 Notes 草稿；</li><li>2017.09.14 - 输出 Markdown 文档；  </li><li>2018.01.30 - 完成序言；</li></ul></li></ul><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>由于对图灵出品的 O’Reilly 动物书情有独钟，至此本篇文章以动物书系列之 Java 技术手册为主要框架，开启我的 Java 语言学习旅程。</p><p>当然，通读一遍本书之后，你会发现本书对 Java 基础知识部分的讲述一定是有所欠缺的，所以课后补充工作很有必要。如通过参考其他 Java 书籍（下文中有参考书目推荐）、优秀博文的补充，核心需求就是要输出一份便于常翻阅、可复用的读书笔记、学习笔记。</p><p>需要说明的是，笔记当中会包含实际项目当中深入了解、研究的知识点，如 Class 类文件结构、Regex 正则表达式、Java 范型等。既经由分析、解决、随之文档化的过程，这不仅仅可作为自己的案例库，也可用于分享、交流。毕竟自身的知识面是非常有限的，有不恰当之处、不正确的地方，欢迎广大朋友的帮忙、斧正，互为补足。</p><a id="more"></a><ul><li><p>参考书目</p><blockquote><p>基础篇</p></blockquote><ul><li>《 Java 技术手册 》:  O’Reilly 动物书系列 (听说集齐一套可以召唤神龙？)，因本书籍不会刻意去阐述面向对象编程（Object Oriented Programming，OOP）的相关概念、内容，适合对 OOP、Java 编程语言有一定了解后，所使用的学习材料。</li></ul><blockquote><p>进阶篇</p></blockquote><ul><li>《 Java编程思想 / Thinking in Java 》：待阅读。贴上本书豆瓣的书评，供朋友评判，做出抉择。<a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">TIJ(中文第四版)</a> | <a href="https://book.douban.com/subject/2061172/" target="_blank" rel="noopener">TIJ(英文第四版)</a></li></ul></li><li><p>优秀博文 (主要的采集源：Guihub、CSDN)</p><ul><li><a href="http://wdxtub.com/2012/09/11/awesome-java/" target="_blank" rel="noopener"> 索引 - 小土刀. Java 资源索引. 2012. wdxtub.com.</a> </li><li><a href="https://github.com/akullpp/awesome-java" target="_blank" rel="noopener"> 索引 - Akullpp. Awsome Java. github.com</a></li><li><a href="http://blog.csdn.net/jdsjlzx/article/details/41545403" target="_blank" rel="noopener"> 规范 - 一叶飘舟. Java / Android 编码规范. 2014. csdn.net</a></li></ul></li><li><p>开源项目</p></li></ul><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><ul><li>壹 Java 环境介绍  </li><li>贰 Java 基本句法  </li><li>叁 Java 面向对象编程  </li><li>肆 Java 类型系统  </li><li>伍 Java 的面向对象设计  </li><li>陆 Java 实现内存管理和并发编程的方式  </li><li>柒 编程和文档约定  </li><li>捌 使用 Java 集合  </li><li>玖 处理常见的数据格式  </li><li>拾 处理文件和I/O  </li><li>拾壹 类加载、反射和方法句柄  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;更新进度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2017.09.01 - 整理 Notes 草稿；&lt;/li&gt;
&lt;li&gt;2017.09.14 - 输出 Markdown 文档；  &lt;/li&gt;
&lt;li&gt;2018.01.30 - 完成序言；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;由于对图灵出品的 O’Reilly 动物书情有独钟，至此本篇文章以动物书系列之 Java 技术手册为主要框架，开启我的 Java 语言学习旅程。&lt;/p&gt;
&lt;p&gt;当然，通读一遍本书之后，你会发现本书对 Java 基础知识部分的讲述一定是有所欠缺的，所以课后补充工作很有必要。如通过参考其他 Java 书籍（下文中有参考书目推荐）、优秀博文的补充，核心需求就是要输出一份便于常翻阅、可复用的读书笔记、学习笔记。&lt;/p&gt;
&lt;p&gt;需要说明的是，笔记当中会包含实际项目当中深入了解、研究的知识点，如 Class 类文件结构、Regex 正则表达式、Java 范型等。既经由分析、解决、随之文档化的过程，这不仅仅可作为自己的案例库，也可用于分享、交流。毕竟自身的知识面是非常有限的，有不恰当之处、不正确的地方，欢迎广大朋友的帮忙、斧正，互为补足。&lt;/p&gt;
    
    </summary>
    
      <category term="Programme" scheme="http://www.kofes.cn/categories/Programme/"/>
    
    
      <category term="java" scheme="http://www.kofes.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>C语言程序设计 ( 应试篇 )</title>
    <link href="http://www.kofes.cn/2017/04/C-Programming-Design-Learning.html"/>
    <id>http://www.kofes.cn/2017/04/C-Programming-Design-Learning.html</id>
    <published>2017-04-08T17:36:28.000Z</published>
    <updated>2017-04-08T17:36:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从标题中透漏的信息可知，本系列文章是围绕 “C语言程序设计” 展开学习的笔记总结，且目的很明确，笔记内容偏应试，适用于计算机等级考试、考研专业课(C语言)等的复习使用。文章推崇总结性、比对性的学习方法，对于模糊的知识模块需自行查阅参考书目，深化理解或可达到理想的效果。</p><a id="more"></a><p>针对C语言程序，推荐几本辅导复习的书目：</p><blockquote><ul><li>基础篇 :<ul><li>《谭浩强:C语言程序设计》: 必不可少的经典教程，权威性的标准答案源。( 因讨论条件而异，如编译系统不同，部分题目的答案就具有了争议性 )</li><li>《明解C语言》: 入门基础教学。值得称赞的是，每个知识模块都符有实例，且实例的源码结构清晰，代码规范及注释到位，非常适合入门使用。</li></ul></li><li>进阶篇 :<ul><li>《征服C指针》: C语言的学习过程中，指针的运用是最大的难关。无论是在实际应用、应试中都是不可忽视的。对于作者前桥和弥，其一针见血的文风，在掌握一定基础之后，是深入了解C语言的一位不可多得 “良师益友” ( 书中有不少作者交谈式的独白，别有一番阅读风味 )。</li></ul></li></ul></blockquote><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><ul><li><a href="#1-壹-程序设计和C语言">壹 程序设计和C语言</a></li><li><a href="#2-贰-程序之魂：算法">贰 程序之魂：算法</a></li><li><a href="#3-叁-简单的C语言程序设计">叁 简单的C语言程序设计</a></li><li><a href="#4-肆-选择结构程序设计">肆 选择结构程序设计</a></li><li><a href="#5-伍-循环结构程序设计">伍 循环结构程序设计</a></li><li><a href="#6-陆-数组">陆 数组</a></li><li><a href="#7-柒-函数">柒 函数</a></li><li><a href="#8-捌-指针">捌 指针</a></li><li><a href="#9-玖-构造类型：用户自己建立数据结构">玖 构造类型：用户自己建立数据结构</a></li><li><a href="#10-拾-文件处理">拾 文件处理</a></li></ul><h2 id="1-壹-程序设计和C语言"><a href="#1-壹-程序设计和C语言" class="headerlink" title="1 壹 程序设计和C语言"></a>1 壹 程序设计和C语言</h2><h3 id="1-1-计算机程序与语言"><a href="#1-1-计算机程序与语言" class="headerlink" title="1.1 计算机程序与语言"></a>1.1 计算机程序与语言</h3><p> 程序：计算机能识别和执行的指令。<br> 语言：人和计算机交流、人和计算机能识别的语言。<br> 计算机语言发展阶段：   </p><table><thead><tr><th style="text-align:center">机器语言</th><th style="text-align:center">符号语言</th><th style="text-align:center">高级语言 ( 面向过程、面向对象 )</th></tr></thead><tbody><tr><td style="text-align:center">0和1指针</td><td style="text-align:center">英文、数字表示指令</td><td style="text-align:center">人类自然语言和数字语言</td></tr></tbody></table><h3 id="1-2-C语言"><a href="#1-2-C语言" class="headerlink" title="1.2 C语言"></a>1.2 C语言</h3><ul><li><p>特点</p><ul><li>语言简洁、紧凑，使用方便、灵活</li><li>运算符丰富 ( 单目、双目、三目运算符 )</li><li>数据类型丰富 ( 整型、浮点型、字符型、数组类型、指针类型、结构体类型、共用体类型、枚举型 )</li><li>结构体控制语句</li><li>直接访问物理地址 ( 对硬件直接操作 )</li><li>可移植性好</li></ul></li><li><p>结构</p><ul><li>以程序由一个或着多个 <strong>源文件</strong> 组成。  <blockquote><p>源文件中包括：<br>预处理命令 ( #include、#define、#typedef等 )<br>全局声明 ( 全局变量、局部变量 )<br>函数定义 ( 参考函数原型 )</p></blockquote></li><li>函数是C程序的主要组成部分。</li><li>一函数包括函数首部和 <strong>函数体</strong>。  <blockquote><p>函数体包括：<br>声明部分和执行部分。 </p></blockquote></li><li>程序总是从main函数开始执行的。  <blockquote><p>main函数有且仅有一个。</p></blockquote></li><li>C程序对计算机的操作有C语言完成。</li><li>数据声明和语句必须有分号 ( 作为结束 )。</li><li>C本身不提供输入输出语句。</li></ul></li></ul><h3 id="1-3-程序设计的任务"><a href="#1-3-程序设计的任务" class="headerlink" title="1.3 程序设计的任务"></a>1.3 程序设计的任务</h3><ol><li>问题分析  </li><li>设计算法  </li><li>编写程序  </li><li>对源文件编辑、编译 ( *.obj ) 和连接 ( *.exe )  </li><li>运行程序并分析结果  </li><li>编写程序文档 </li></ol><blockquote><p>[注] 对于编译，预编译和连接的概念及比对： </p><ul><li>编译：检索语言错误；把源程序转为二进制形式的目标程序。</li><li>预编译：通过预处理得到的信息与程序其他部分一起，组成完整的、可以正式编译的源程序。</li><li>连接：与函数库相连接。</li></ul></blockquote><h2 id="2-贰-程序之魂：算法"><a href="#2-贰-程序之魂：算法" class="headerlink" title="2 贰 程序之魂：算法"></a>2 贰 程序之魂：算法</h2><h3 id="2-1-引入"><a href="#2-1-引入" class="headerlink" title="2.1 引入"></a>2.1 引入</h3><ul><li><p>对数据的描述：所用数据的类型和数据的 <strong>组织形式</strong>。  </p><blockquote><p>组织形式：数据结构 – 特定关系的数据元素的集合</p></blockquote></li><li><p>对操作的描述：计算机进行操作的步骤 – 算法</p></li><li><p>从简理解：<strong>数据结构 + 算法 = 程序</strong></p></li></ul><h3 id="2-2-算法"><a href="#2-2-算法" class="headerlink" title="2.2 算法"></a>2.2 算法</h3><ul><li><p>概念：对特定问题求解的方法和描述。</p></li><li><p>特征  </p><ul><li>有穷性：有穷时间执行结束；</li><li>确定性：算法唯一执行路径，既相同输入执行相同路径；</li><li>可行性：有限次；</li><li>零或一个以上的输入；</li><li>一个或以上的输出；</li></ul></li><li><p>要求  </p><ul><li>正确性；</li><li>可读性；</li><li>健壮性；</li><li><p>效率与低存储量需求 ( 时间复杂度和空间复杂度 )  </p><blockquote><ul><li>时间复杂度 &lt;– 渐进时间复杂度 &lt;– 算法执行时间的增长率和f(n)的增长率相同。  </li></ul><blockquote><p>[说明]  </p><ol><li>渐进时间复杂度：<strong>T(n) = Big O(f(n))</strong>  </li><li>f(n)为问题规模n的某个函数。  </li><li>算法中的基本运算( 最深层循环内的语句 )的频度与T(n)同数量级。  </li></ol></blockquote><ul><li>空间复杂度 &lt;– 算法所需存储空间的量度。  </li></ul><blockquote><p>[说明]  </p><ol><li>渐进空间复杂度：<strong>S(n) = Big O(f(n))</strong>  </li><li>原地工作：额外空间相对输入的数据量来说是常数。</li></ol></blockquote></blockquote></li></ul></li></ul><h3 id="2-3-三种基本结构和改进流程图"><a href="#2-3-三种基本结构和改进流程图" class="headerlink" title="2.3 三种基本结构和改进流程图"></a>2.3 三种基本结构和改进流程图</h3><ul><li>三种基本结构<ul><li>顺序结构；</li><li>选择结构；</li><li>循环结构：当型循环结构 / 直到型循环结构；</li></ul></li><li>改进的流程图：N-S流程图</li></ul><h3 id="2-4-结构化程序设计方法"><a href="#2-4-结构化程序设计方法" class="headerlink" title="2.4 结构化程序设计方法"></a>2.4 结构化程序设计方法</h3><ul><li>自顶向下；</li><li>逐步细化；</li><li>模块化设计：<strong>分而治之</strong>；    <code>注意模块独立性</code></li><li>结构化编码；</li></ul><h2 id="3-叁-简单的C语言程序设计"><a href="#3-叁-简单的C语言程序设计" class="headerlink" title="3 叁 简单的C语言程序设计"></a>3 叁 简单的C语言程序设计</h2><h3 id="3-1-数据的表现形式及运算"><a href="#3-1-数据的表现形式及运算" class="headerlink" title="3.1 数据的表现形式及运算"></a>3.1 数据的表现形式及运算</h3><h4 id="3-1-1-常量"><a href="#3-1-1-常量" class="headerlink" title="3.1.1 常量"></a>3.1.1 常量</h4><ul><li>概念：程序运行期间，其值不能改变。</li><li>类型    <ul><li>整型常量  </li><li>字符常量 ( 与常变量作比对 <strong>[注释1]</strong> )<ul><li>普通字符  </li><li>转移字符：\n, \t, \012 (8进制), \x41 (16进制)</li><li>符号常量：<code>#define PI 3.14159</code></li></ul></li><li>实型常量<ul><li>10进制小数形式：3.14L</li><li>指数形式(科学计数法):<br>8.7e-25(正确);<br>8.7e-2.5(错误)；<br>87e+25(正确);  </li></ul></li></ul></li></ul><h4 id="3-1-2-变量"><a href="#3-1-2-变量" class="headerlink" title="3.1.2 变量"></a>3.1.2 变量</h4><p><code>先定义，后使用</code> </p><ul><li>包含属性<ul><li>数据类型 ( 整型、浮点型、字符型 )  </li><li>存储类别 ( 自动变量，静态变量 )  </li></ul></li><li>概念：程序运行期间，其值可以改变。</li><li><p>类型</p><ul><li>常变量：变量存在期间其值不能改变。 <code>const int a = 10</code>  </li><li>自动变量与静态变量  </li><li>全局变量与局部变量  <blockquote><p>从存储位置、生存周期、作用区域讨论差异性。<strong>[注释2]</strong></p></blockquote></li></ul></li><li><p>标识符<br>一个对象的名称。除关键字外，字符、数字和下划线组成。且要求只能是字母或下划线开头。    </p></li></ul><blockquote><p>[注释1] 符号常量与常变量的比较。</p></blockquote><table><thead><tr><th style="text-align:left">符号常量</th><th style="text-align:left">常变量</th></tr></thead><tbody><tr><td style="text-align:left">不占内存单元，预编译后符号不复存在</td><td style="text-align:left">占存储单元</td></tr><tr><td style="text-align:left">不能重新赋值</td><td style="text-align:left">不能改变其值</td></tr></tbody></table><blockquote><p>[注释2] 局部变量与全局变量，自动变量与静态变量，内部函数与外部函数的比较。</p></blockquote><table><thead><tr><th style="text-align:left">局部变量</th><th style="text-align:left">全局变量</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">存放于动态存储区</td><td style="text-align:left">存放于静态存储区</td><td style="text-align:left">位置</td></tr><tr><td style="text-align:left">在定义函数内起作用</td><td style="text-align:left">自定义位置开始，本文件起作用</td><td style="text-align:left">作用域</td></tr><tr><td style="text-align:left">函数调用完释放内存</td><td style="text-align:left">程序结束时释放内存</td><td style="text-align:left">生存期</td></tr></tbody></table><blockquote><ul><li>静态的局部变量，存放于静态存储区，程序结束时释放内存。</li><li>静态的全局变量，不是因声明static，而误解全局变量才存放于静态存储区。</li><li>局部变量，声明存储类型指变量存储区以及产生的生存期问题。<br>  全局变量，声明存储类型指变量作用域的扩展问题。</li></ul></blockquote><table><thead><tr><th style="text-align:left">自动变量</th><th style="text-align:left">静态变量</th></tr></thead><tbody><tr><td style="text-align:left">1. 声明该变量的语句块被执行结束释放内存(<strong>栈</strong>)</td><td style="text-align:left">1. 程序结束时才释放内存</td></tr><tr><td style="text-align:left">2. 每次函数调用时赋值</td><td style="text-align:left">2. 保留上一步的赋值</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">3. 在编时赋予初值0或’\0’</td></tr></tbody></table><blockquote><p>[注] 对比malloc()函数分配的内存，需调用free()函数释放内存。(<strong>堆</strong>)</p></blockquote><table><thead><tr><th style="text-align:left">内部函数</th><th style="text-align:left">外部函数 (default)</th></tr></thead><tbody><tr><td style="text-align:left">本文件内使用(不限位置)</td><td style="text-align:left">可供其他文件使用(不限位置)</td></tr><tr><td style="text-align:left">定义：static 函数类型 函数名</td><td style="text-align:left">定义：(extern) 函数类型 函数名</td></tr></tbody></table><h4 id="3-1-3-数据类型"><a href="#3-1-3-数据类型" class="headerlink" title="3.1.3 数据类型"></a>3.1.3 数据类型</h4><ul><li>基本类型</li></ul><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">关键字</th><th style="text-align:left">字节</th><th style="text-align:left">取值范围</th></tr></thead><tbody><tr><td style="text-align:left">整型</td><td style="text-align:left">int</td><td style="text-align:left">2/4</td><td style="text-align:left">$-2^{15}$ ~ $-2^{15}-1$ / $-2^{31}$ ~ $2^{31}-1$</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">unsigned int</td><td style="text-align:left">2/4</td><td style="text-align:left">0 ~ $-2^{16}-1$ / 0 ~ $-2^{32}-1$</td></tr><tr><td style="text-align:left">字符型</td><td style="text-align:left">char</td><td style="text-align:left">1</td><td style="text-align:left">$-2^7$ ~ $2^7-1$</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">unsigned char</td><td style="text-align:left">1</td><td style="text-align:left">0 ~ $2^8-1$</td></tr><tr><td style="text-align:left">单浮点</td><td style="text-align:left">float (有效小数：6)</td><td style="text-align:left">4</td><td style="text-align:left">–</td></tr><tr><td style="text-align:left">双浮点</td><td style="text-align:left">double (有效小数：15)</td><td style="text-align:left">8</td><td style="text-align:left">–</td></tr></tbody></table><blockquote><p>[注] 关于基本类型的特别说明  </p><ul><li>字符是按其ASCII形式存储的。</li><li>单浮点定义：float a = 3.14f</li><li>双浮点定义：double a = 3.14</li><li>长浮点定义：long double a = 3.14L</li></ul></blockquote><ul><li><p>派生类型</p><ul><li>指针类型：指向函数的指针、多重指针</li><li>数组类型：指针数组</li></ul></li><li><p>构造类型</p><ul><li>结构体类型</li><li>共同体类型</li><li>枚举类型  <blockquote><p>详情见第玖章：构造类型</p></blockquote></li></ul></li><li><p>类型转换：  </p><ul><li>低精度向高精度转换；  </li><li>强制转换括号加类型；   <code>int a = (int)3.14</code>  </li><li>多类型变量混合运算，取最高精度的类型；</li></ul></li></ul><h2 id="4-肆-选择结构程序设计"><a href="#4-肆-选择结构程序设计" class="headerlink" title="4 肆 选择结构程序设计"></a>4 肆 选择结构程序设计</h2><h3 id="4-1-关系运算符及其优先次序"><a href="#4-1-关系运算符及其优先次序" class="headerlink" title="4.1 关系运算符及其优先次序"></a>4.1 关系运算符及其优先次序</h3><ul><li><p>各类运算符的优先级：</p><ul><li><p>单目运算符 &gt; 双目运算符 (算术、关系、逻辑) &gt; 三目运算符</p></li><li><p>优先级由高到低排序：<br>初等运算符：<code>()，[]，-&gt;，.</code><br>单目运算符：<code>!，++，--，~</code><br>算术运算符：<code>*，/，%</code>，<code>+，-</code><br>关系运算符：<code>&gt;，&lt;，&gt;=，&lt;=</code>，<code>!=，==</code><br>逻辑运算符：<code>&amp;&amp;，||</code><br>条件运算符：<code>a &gt; b : a : b</code><br>赋值运算符：<code>a += 1</code><br>逗号运算符：<code>(a,b)</code>      </p></li><li><p>结合方式<br>自左向右：<code>初等、单目、关系、逻辑、逗号运算符</code><br>自右向左：<code>条件、赋值运算符</code>  </p><blockquote><p>同一级的运算符，由结合方式决定优先级。</p></blockquote></li></ul></li></ul><h3 id="4-2-表达式"><a href="#4-2-表达式" class="headerlink" title="4.2 表达式"></a>4.2 表达式</h3><ul><li><p>算术表达式：先乘除模，后加减，再由“自左向右”原则运算。</p></li><li><p>混合运算</p><ul><li>优先级：遵循各运算符的优先次序。</li><li>结合性：算术运算符 (自左向右)；赋值运算符 (自右向左)。</li><li>不同类型的混合运算：结果的类型为<strong>最高精度</strong>的数据类型。</li></ul></li></ul><h3 id="4-3-运算符与表达式"><a href="#4-3-运算符与表达式" class="headerlink" title="4.3 运算符与表达式"></a>4.3 运算符与表达式</h3><ul><li><p>关系运算符和关系表达式 ( a+b&gt;c ) -&gt; True or False?  </p><blockquote><p>0表示假，!0表示真。</p></blockquote></li><li><p>逻辑运算符和逻辑表达式</p><ul><li>逻辑运算：5 &amp;&amp; 4 =&gt; 1；5 &amp;&amp; 0 =&gt; 0；  </li><li><p>按位逻辑：5 &amp; 4 =&gt; 4；  </p><blockquote><p>[注] 关于逻辑运算与按位逻辑的比较  </p><ul><li>优先级：按位逻辑运算 &gt; 逻辑运算  </li><li>max = a &amp; b；min = a | b    </li></ul></blockquote></li></ul></li><li><p>条件运算符和条件表达式：a &gt; b ? a : b</p></li></ul><h3 id="4-4-选择结构的嵌套"><a href="#4-4-选择结构的嵌套" class="headerlink" title="4.4 选择结构的嵌套"></a>4.4 选择结构的嵌套</h3><ul><li><p>if语句只有两个分支可供选择，else总是与它上面最近的未配对的if()配对。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(express1)&#123;</span><br><span class="line"><span class="keyword">if</span>(express2)&#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(express3)&#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>switch语句实现多分支选择结构</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(express1)&#123; <span class="comment">// 整型、字符型</span></span><br><span class="line"><span class="keyword">case</span> 常量/常量表达式:语句<span class="number">1</span>；<span class="keyword">break</span>; <span class="comment">// break为拦截作用</span></span><br><span class="line"><span class="keyword">case</span> 常量/常量表达式:语句<span class="number">2</span>；<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: 语句<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-伍-循环结构程序设计"><a href="#5-伍-循环结构程序设计" class="headerlink" title="5 伍 循环结构程序设计"></a>5 伍 循环结构程序设计</h2><h3 id="5-1-while-语句实现"><a href="#5-1-while-语句实现" class="headerlink" title="5.1 while 语句实现"></a>5.1 while 语句实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">express1;</span><br><span class="line"><span class="keyword">while</span>(express2)&#123;</span><br><span class="line">express3;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-for-语句实现循环"><a href="#5-2-for-语句实现循环" class="headerlink" title="5.2 for 语句实现循环"></a>5.2 for 语句实现循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(express1; express2; express3)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-do…while-语句实现循环"><a href="#5-3-do…while-语句实现循环" class="headerlink" title="5.3 do…while() 语句实现循环"></a>5.3 do…while() 语句实现循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">express1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">express3;</span><br><span class="line">&#125; <span class="keyword">while</span>(express2);</span><br></pre></td></tr></table></figure><h3 id="5-4-break、continue与goto语句"><a href="#5-4-break、continue与goto语句" class="headerlink" title="5.4 break、continue与goto语句"></a>5.4 break、continue与goto语句</h3><ul><li>break：从循环体内跳出循环体。多层嵌套循环，跳出相邻一层循环。</li><li>continue：提前结束本次循环。</li><li>goto：跳出多层循环。</li></ul><h2 id="6-陆-数组"><a href="#6-陆-数组" class="headerlink" title="6 陆 数组"></a>6 陆 数组</h2><h3 id="6-1-概念"><a href="#6-1-概念" class="headerlink" title="6.1 概念"></a>6.1 概念</h3><ul><li>一组有序数据的集合。</li><li>数组中每一元素同属一个数据类型。</li><li>sname[0] &lt;=&gt; *(p+0) &lt;=&gt; 第一个数组元素。  </li></ul><h3 id="6-2-定义"><a href="#6-2-定义" class="headerlink" title="6.2 定义"></a>6.2 定义</h3><h4 id="6-2-1-一维数组"><a href="#6-2-1-一维数组" class="headerlink" title="6.2.1 一维数组"></a>6.2.1 一维数组</h4><ul><li><p>定义<br>类型符 数组名[常量表达式]     –&gt; 正确<br>类型符 数组名[变量] –&gt; 错误，不能为变量</p></li><li><p>初始化  </p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  </span><br><span class="line">in <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 5个元素都为0。</span></span><br></pre></td></tr></table></figure></li><li><p>引用  </p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;<span class="built_in">array</span>[<span class="number">0</span>];<span class="comment">// 等同于 int *p = array;</span></span><br><span class="line">p++;<span class="comment">// 指针运算</span></span><br><span class="line">*(p+i);<span class="comment">// 取第i位元素</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="6-2-2-二维数组"><a href="#6-2-2-二维数组" class="headerlink" title="6.2.2 二维数组"></a>6.2.2 二维数组</h4><ul><li><p>定义：类型符 数组名[常量表达式][常量表达式]</p></li><li><p>初始化</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">2</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">2</span>][<span class="number">2</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125; &#125;;<span class="comment">// 既只允许最外层元素个数定义时为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125; &#125;;<span class="comment">// 正确 </span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[][<span class="number">2</span>] = &#123; &#123;&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125; &#125;;<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>引用</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="built_in">array</span>[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> *p = <span class="built_in">array</span>;</span><br><span class="line">*(*(p+j)+j); <span class="comment">// 等同于array[i][j];</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="6-2-3-字符数组"><a href="#6-2-3-字符数组" class="headerlink" title="6.2.3 字符数组"></a>6.2.3 字符数组</h4><ul><li><p>定义：char array[10]; &lt;=&gt; int array[10];</p><blockquote><p>字符型数组是以整型形式存放的 (ASCII)。</p></blockquote></li><li><p>初始化  </p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">0</span>] = <span class="string">'A'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> <span class="built_in">array</span>[] = &#123;<span class="string">"Hello"</span>&#125;;</span><br><span class="line"><span class="comment">// 字符数组的存储情况：| H | e | l | l | o | \0 |</span></span><br><span class="line"><span class="comment">// sizeof() -- 6</span></span><br><span class="line"><span class="comment">// strlen() -- 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> <span class="built_in">array</span>[] = &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>&#125;;</span><br><span class="line"><span class="comment">// sizeof() -- 5</span></span><br><span class="line"><span class="comment">// strlen() -- 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="string">"Hello"</span>&#125;;</span><br><span class="line"><span class="comment">// sizeof() -- 4</span></span><br><span class="line"><span class="comment">// strlen() -- 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>&#125;;</span><br><span class="line"><span class="comment">// sizeof() -- 20</span></span><br><span class="line"><span class="comment">// strlen() -- 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">array</span> = <span class="string">"Hello"</span>; <span class="comment">// 字符串常量</span></span><br></pre></td></tr></table></figure><blockquote><p>[注]</p><ul><li>字符串常量不可以数组形式取具体位置进行元素修改。</li><li>( array == “Hello” ) =&gt; True or False ?<br>False，array与字符串常量比较的是内存地址。</li></ul></blockquote></li><li><p>引用 </p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, <span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, <span class="built_in">array</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="built_in">array</span>);</span><br></pre></td></tr></table></figure><blockquote><p>[注]</p><ul><li>若字符数组中，存在’\0’两个或以上，系统则以第一次出现的位置提前终止字符输出。</li><li>stdin 也 gets() 搭配，可获得换行符、空格等字符。 (需结束标记符来终止输入)</li></ul></blockquote></li><li><p>应用  </p><blockquote><ul><li>字符串处理函数：<code>#include &lt;string.h&gt;</code></li><li>需掌握字符串函数自定义方法实现。</li><li>大部份字符串处理函数多数以标记量’\0’为临界点，若字符数组中含两个或或以上，需注意实际的结果。</li></ul></blockquote><ul><li>gets(字符数组) – 输入一字符串到字符数组中</li><li>puts(字符数组) – 输出一字符串到终端</li><li>strlen(字符数组) – 测一字符串的实际长度</li><li><p>strcat(char *src1, const char *src2);</p><blockquote><p>数组src2后接于src1，src1中的’\0’被覆盖。且数组src1必须足够大，以容纳数组src2。</p></blockquote></li><li><p>strcpy(char *src1, const char *src2);</p><blockquote><p>数组src1必须足够大，以容纳数组src2。</p></blockquote></li><li><p>strcmp(const char *src1, const char *src2);</p><blockquote><p>实际为ASCII的比较，其返回值为 <0、==0，>0 的情况。</0、==0，></p></blockquote></li><li><p>strlwr(字符串) – 将字符串中大写字母转为小写字母</p></li><li>strupr(字符串) – 将字符串中小写字母转为大写字母</li><li>atoi(字符串) – 字符串转int型</li><li>atol(字符串) – 字符串转long型</li><li>atof(字符串) – 字符串转double型  <blockquote><p>引用atoi()、atol()、atof()函数需引用<code>#include &lt;stdlib.h&gt;</code>  </p></blockquote></li></ul></li></ul><h2 id="7-柒-函数"><a href="#7-柒-函数" class="headerlink" title="7 柒 函数"></a>7 柒 函数</h2><h3 id="7-1-为什么要用函数"><a href="#7-1-为什么要用函数" class="headerlink" title="7.1 为什么要用函数"></a>7.1 为什么要用函数</h3><ul><li>模块化程序设计：每一函数实现一特定的功能，函数的名称既反映功能。</li><li><p>更好地代码复用：使用库函数；使用自己编写的函数。 </p><blockquote><p>代码复用：减少重复编码程序段的工作量。 </p><p>[说明]  </p><p>对于所有完成相同功能的组件，应抽象出一个接口，它们都实现该接口。<br>具体在Java中，所有完成相同功能的组件都<strong>实现该接口</strong>或<strong>从该抽象类中的继承</strong>。</p></blockquote></li></ul><h3 id="7-2-定义函数"><a href="#7-2-定义函数" class="headerlink" title="7.2 定义函数"></a>7.2 定义函数</h3><p><code>建立存储空间的声明</code>  </p><p>函数返回类型 函数名 函数参数 函数体 (变量定义、声明，执行语句)</p><blockquote><p>函数返回类型：基本数据类型 / void型<br>函数名：驼峰式命名法<br>函数参数：实参、形参  </p></blockquote><h3 id="7-3-函数声明"><a href="#7-3-函数声明" class="headerlink" title="7.3 函数声明"></a>7.3 函数声明</h3><p><code>不需要建立存储空间的声明</code></p><ul><li><p>函数原型 (Prototype)：函数返回类型、函数名、参数类型、参数个数、参数顺序</p></li><li><p>函数声明的方法</p><ul><li>使用函数原型；</li><li>同一源文件，在调用该函数的前面定义 (可打包到自定义头文件中)；</li></ul></li></ul><h3 id="7-4-函数调用"><a href="#7-4-函数调用" class="headerlink" title="7.4 函数调用"></a>7.4 函数调用</h3><ul><li>嵌套调用、递归调用 (直接或间接调用该函数本身)</li><li>实参和形参<ul><li>概念<br>实参：常量、变量或表达式、函数 (返回值)<br>形参：函数调用期间临时分配内存，值从实参中获得，调用结束后释放内存空间。</li><li>实质：值传递、地址传递</li></ul></li></ul><h2 id="8-捌-指针"><a href="#8-捌-指针" class="headerlink" title="8 捌 指针"></a>8 捌 指针</h2><h3 id="8-1-指针是什么"><a href="#8-1-指针是什么" class="headerlink" title="8.1 指针是什么"></a>8.1 指针是什么</h3><ul><li>指针变量：保存变量地址的变量。</li><li>指针类型<ul><li>指针类型的变量：存放地址</li><li>指针类型的值：对应内存地址存放的值  <blockquote><p>在 swap(int *a, int *b); 的案例中可以形象说明两者的区别。</p></blockquote></li></ul></li></ul><h3 id="8-2-指针移动-运算：加、减"><a href="#8-2-指针移动-运算：加、减" class="headerlink" title="8.2 指针移动 (运算：加、减)"></a>8.2 指针移动 (运算：加、减)</h3><p>对指针加一、减一运算，即地址会增加或减少一单位长度。单位长度具体具体指当前指针所指向数据类型的所占空间大小。</p><h3 id="8-3-指针类型"><a href="#8-3-指针类型" class="headerlink" title="8.3 指针类型"></a>8.3 指针类型</h3><h4 id="8-3-1-空指针"><a href="#8-3-1-空指针" class="headerlink" title="8.3.1 空指针"></a>8.3.1 空指针</h4><p>确保没有指向任何一个对象的指针。通常以宏定义NULL(0)表示空指针的常量值。</p><blockquote><p>关于NULL、0和’\0’，大部分情况都为零。特别地，  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="number">0</span>;<span class="comment">// 正确，编译器将指针指向内存地址为0处。 </span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="number">3</span>;<span class="comment">// 错误，赋值的数据类型不相符。</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="8-3-2-指针类型的派生"><a href="#8-3-2-指针类型的派生" class="headerlink" title="8.3.2 指针类型的派生"></a>8.3.2 指针类型的派生</h4><ul><li><p>指向函数的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*func(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure></li><li><p>指向数组的指针(多重指针)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)[<span class="number">5</span>];</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-3-3-数组类型的派生"><a href="#8-3-3-数组类型的派生" class="headerlink" title="8.3.3 数组类型的派生"></a>8.3.3 数组类型的派生</h4><ul><li>指针数组<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p[<span class="number">5</span>]; <span class="comment">// 存放5个指向int类型的指针。</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>[附] 用英语解读各种各样的C语言声明</p><table><thead><tr><th style="text-align:left">C语言</th><th style="text-align:left">英语表示</th><th style="text-align:left">中文表示</th></tr></thead><tbody><tr><td style="text-align:left">int huge;</td><td style="text-align:left">huge is int</td><td style="text-align:left">hoge是int型</td></tr><tr><td style="text-align:left">int huge[10];</td><td style="text-align:left">huge is array[10] of int</td><td style="text-align:left">hoge是int型的数组</td></tr><tr><td style="text-align:left">int huge[2][4];</td><td style="text-align:left">huge is array[2] of array[4] of int</td><td style="text-align:left">hoge是int型的数组的数组</td></tr><tr><td style="text-align:left">int *huge[10];</td><td style="text-align:left">huge is array[10] of point to int</td><td style="text-align:left">hoge是指向int型的指针的数组(存放指针变量)</td></tr><tr><td style="text-align:left">int (*huge)[10];</td><td style="text-align:left">hoge is pointer to array[10] of int</td><td style="text-align:left">hoge是指向int型的数组的指针</td></tr><tr><td style="text-align:left">int func(int a);</td><td style="text-align:left">func is function(int a) returning int</td><td style="text-align:left">func是返回int型的函数</td></tr><tr><td style="text-align:left">int (*func)(int a);</td><td style="text-align:left">func is pointer to function(int a) returning int</td><td style="text-align:left">func是指向返回int型值的函数的指针</td></tr></tbody></table></blockquote><h3 id="8-4-指针的应用"><a href="#8-4-指针的应用" class="headerlink" title="8.4 指针的应用"></a>8.4 指针的应用</h3><h4 id="8-4-1-指针与数组"><a href="#8-4-1-指针与数组" class="headerlink" title="8.4.1 指针与数组"></a>8.4.1 指针与数组</h4><ul><li><p>一维  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p[i]<span class="comment">// 等同于 *(p+i)</span></span><br><span class="line">i[p]<span class="comment">// 等同于 *(i+p)</span></span><br><span class="line">&amp;p[i]<span class="comment">// 等同于 (p+i)，即第i个元素的地址</span></span><br></pre></td></tr></table></figure></li><li><p>二维  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">huge[i]<span class="comment">// 等同于 *(huge+i)，即第i行的首地址</span></span><br><span class="line">*(huge+i)[j]<span class="comment">// 等同于 *(*(p+j)+j)，即 huge[i][j]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="8-4-2-指针与字符串"><a href="#8-4-2-指针与字符串" class="headerlink" title="8.4.2 指针与字符串"></a>8.4.2 指针与字符串</h4><h5 id="8-4-2-1-字符指针变量"><a href="#8-4-2-1-字符指针变量" class="headerlink" title="8.4.2.1 字符指针变量"></a>8.4.2.1 字符指针变量</h5><ul><li><p>定义</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *<span class="built_in">array</span> = <span class="string">"World"</span>;</span><br><span class="line"><span class="built_in">array</span> = <span class="string">"hello"</span>;<span class="comment">// 改变指向</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> <span class="built_in">array</span>[] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="built_in">array</span> = <span class="string">"World"</span>;<span class="comment">// 错误的做法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">array</span> = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="built_in">array</span> += <span class="number">6</span>;<span class="comment">// 改变指向 (首地址改变)</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="8-4-2-2-字符数组"><a href="#8-4-2-2-字符数组" class="headerlink" title="8.4.2.2 字符数组"></a>8.4.2.2 字符数组</h5><ul><li><p>定义: int array[] = “Hello”;</p></li><li><p>使用：printf(“%c”, array[0]);</p><blockquote><p>字符指针变量的值是不能改变的，既已是字符串常量。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *<span class="built_in">array</span> = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>] = <span class="string">'W'</span>;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h4 id="8-4-3-指针与函数"><a href="#8-4-3-指针与函数" class="headerlink" title="8.4.3 指针与函数"></a>8.4.3 指针与函数</h4><h5 id="8-4-3-1-作为参数"><a href="#8-4-3-1-作为参数" class="headerlink" title="8.4.3.1 作为参数"></a>8.4.3.1 作为参数</h5><p>即传递的是指向初始元素的指针。</p><ul><li>数组名作函数参数<ul><li>int func( int array[] ); </li><li>int func( int *array );</li></ul></li><li>多维数组作函数参数<ul><li>int func( int (*huge)[10] );</li><li>int func( int huge[2][4] );</li></ul></li><li>指向函数的指针作函数参数<ul><li>int func( int (*p)(int) ); </li></ul></li><li>指针数组作main函数形参<ul><li>int func( int argc, char *argv[] );   <blockquote><p>argv: 文件名 + 其他参数</p></blockquote></li></ul></li><li>字符指针作函数参数</li></ul><h5 id="8-4-3-2-作为返回值"><a href="#8-4-3-2-作为返回值" class="headerlink" title="8.4.3.2 作为返回值"></a>8.4.3.2 作为返回值</h5><p>返回指针值的函数，即返回的是地址。</p><blockquote><p>[如] 返回的指针指向结构体变量、字符变量等。</p></blockquote><h2 id="9-玖-构造类型：用户自己建立数据结构"><a href="#9-玖-构造类型：用户自己建立数据结构" class="headerlink" title="9 玖 构造类型：用户自己建立数据结构"></a>9 玖 构造类型：用户自己建立数据结构</h2><h3 id="9-1-结构体类型"><a href="#9-1-结构体类型" class="headerlink" title="9.1 结构体类型"></a>9.1 结构体类型</h3><ul><li><p>定义</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Name</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">char</span> word[<span class="number">59</span>];</span><br><span class="line">&#125; *p, name[<span class="number">5</span>];</span><br></pre></td></tr></table></figure></li><li><p>初始化：所有成员一起赋值。</p></li><li><p>使用</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name[i].num;</span><br><span class="line">p-&gt;word[i];</span><br><span class="line">(*p).num;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Name</span> *<span class="title">tmp</span>;</span></span><br><span class="line">tmp = name;</span><br><span class="line">(tmp++)-&gt;num;<span class="comment">// 先'++'操作，后'-&gt;'操作</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>大小：成员变量所占内存长度总和。</li></ul><h3 id="9-2-共用体类型"><a href="#9-2-共用体类型" class="headerlink" title="9.2 共用体类型"></a>9.2 共用体类型</h3><ul><li><p>定义</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> Name &#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">double</span> digital;</span><br><span class="line"><span class="keyword">char</span> word;</span><br><span class="line">&#125; *p, name[<span class="number">5</span>];</span><br></pre></td></tr></table></figure></li><li><p>初始化：只允许给一个成员变量赋值。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> Name tmp = &#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">union</span> Name tmp = &#123;.word = <span class="string">'Y'</span>&#125;;</span><br><span class="line">t.digital = <span class="number">2.0</span>;</span><br><span class="line">t.word = <span class="string">'N'</span>;<span class="comment">// 最终的赋值</span></span><br></pre></td></tr></table></figure></li><li><p>使用</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name[i].num;</span><br><span class="line">p-&gt;word[i];</span><br><span class="line">(*p).num;</span><br></pre></td></tr></table></figure></li></ul><ul><li>大小：成员变量所占内存长度最大者。</li></ul><blockquote><p>[注] 关于结构体、共用体类型的内存长度问题，遵循4字节倍数的原则进行内存布局对齐。<br>[如]<br>sizeof(struct Name) = 64 (63)<br>sizeof(union Name) = 4 (4)</p></blockquote><h3 id="9-3-枚举类型"><a href="#9-3-枚举类型" class="headerlink" title="9.3 枚举类型"></a>9.3 枚举类型</h3><ul><li><p>定义</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week &#123;</span><br><span class="line">sun, mon, tue, wed, thu, fir, sat <span class="comment">// 默认参数从0开始</span></span><br><span class="line">&#125; week;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>初始化</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week &#123;</span><br><span class="line">mon = <span class="number">1</span>, tue = <span class="number">2</span>, wed = <span class="number">3</span>, thu = <span class="number">4</span>, fir = <span class="number">5</span>, sat = <span class="number">6</span>，sun = <span class="number">7</span> <span class="comment">// 默认参数从0开始</span></span><br><span class="line">&#125; week;</span><br></pre></td></tr></table></figure></li><li><p>使用：week.mon;</p></li></ul><h3 id="9-4-Typedef-声明新类型名"><a href="#9-4-Typedef-声明新类型名" class="headerlink" title="9.4 Typedef 声明新类型名"></a>9.4 Typedef 声明新类型名</h3><ul><li>含义：引入变量别名，而不是另外地给变量分配空间。</li><li><p>使用</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Integer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> Integer;<span class="comment">// 若编译器中，int为2字节，满足移值需求可以long型替换。</span></span><br><span class="line">Interger num = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>与 #define 宏定义的区别<br>#typedef：编译阶段处理<br>#define：预编译阶段处理，实质是字符串替换 </p></blockquote><h2 id="10-拾-文件处理"><a href="#10-拾-文件处理" class="headerlink" title="10 拾 文件处理"></a>10 拾 文件处理</h2><h3 id="10-1-文件与流"><a href="#10-1-文件与流" class="headerlink" title="10.1 文件与流"></a>10.1 文件与流</h3><ul><li><p>stdin – 标准输入流 – 用于读取普通输入的流，在大多数环境中为键盘输入。scanf()与getchar()等函数会从这个流中读取字符。</p></li><li><p>stdout - 标准输入流 – 用于写入普通输入的流，在大多数环境中为输出至显示器界面。printf()、puts()与putchar()等函数会向这个流写入字符。</p></li><li><p>stderr – 标准错误流 – 用于写出错误的流，在大多数环境中为输出至显示器界面。</p></li></ul><h3 id="10-2-文件分类"><a href="#10-2-文件分类" class="headerlink" title="10.2 文件分类"></a>10.2 文件分类</h3><ul><li>ASCII文件 (文本文件)：每一字节存放一字符的ASCII代码。</li><li><p>二进制文件</p><ul><li>优：节约存储空间</li><li><p>劣：精度有限</p><blockquote><p>[如] 整数10000<br>ASCII形式存储空间为5字节<br>二进制形式存储空间为4字节  </p></blockquote></li></ul></li></ul><h3 id="10-3-文件类型指针：FILE型"><a href="#10-3-文件类型指针：FILE型" class="headerlink" title="10.3 文件类型指针：FILE型"></a>10.3 文件类型指针：FILE型</h3><ul><li>需引用 <code>#include &lt;stdio.h&gt;</code><blockquote><p>[注] 指向文件的指针变量并不是指向外部介质上的数据文件开头，而是指向内存中的文件信息区的开头。</p></blockquote></li></ul><h3 id="10-4-打开文件"><a href="#10-4-打开文件" class="headerlink" title="10.4 打开文件"></a>10.4 打开文件</h3><ul><li>原型：FILE *fopen(const char *filename, const char *mode);</li><li>定义：FILE *fp = fopen(“example.txt”, “r”);</li></ul><table><thead><tr><th style="text-align:center">文件类型</th><th style="text-align:center">文本文件</th><th style="text-align:center">二进制文件</th></tr></thead><tbody><tr><td style="text-align:center">模式</td><td style="text-align:center">r   w   a</td><td style="text-align:center">rb   wb   ab</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">只读；只写(文件存在，则长度清零)；追加</td><td style="text-align:center">只读；只写(文件存在，则长度清零)；追加</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">r+   w+   a+</td><td style="text-align:center">rb+   wb+   ab+</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">读和写(打开文件)；读和写(建立文件；文件存在，则长度清零)；读和写(打开文件)</td><td style="text-align:center">读和写(打开文件；文件存在，则长度清零)；读和写(建立文件)；读和写(打开文件)</td></tr></tbody></table><h3 id="10-5-关闭文件"><a href="#10-5-关闭文件" class="headerlink" title="10.5 关闭文件"></a>10.5 关闭文件</h3><ul><li><p>原型：int fclose(FILE *stream);</p><blockquote><ul><li>返回值 ( True：0；False：EOF(-1) )  </li><li>[注]<br>若不关闭文件，将会造成数据丢失。<br>数据存储的过程：数据 –&gt; 缓存区 (充满) –&gt; 文件<br>若突然关闭文件，缓存区传输到文件的过程给中断，造成数据丢失。</li></ul></blockquote></li></ul><h3 id="10-6-顺序读写数据文件"><a href="#10-6-顺序读写数据文件" class="headerlink" title="10.6 顺序读写数据文件"></a>10.6 顺序读写数据文件</h3><ul><li><p>格式化读取文件</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// Ture - 返回成功赋值的输入项数</span></span><br><span class="line"><span class="comment">// False - 返回文件结束标记EOF(-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用实例</span></span><br><span class="line"><span class="built_in">fscanf</span>(fp, <span class="string">"%s%lf%lf"</span>, name, &amp;height, &amp;weight);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>格式化写入文件</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// Ture - 返回发送的字符数</span></span><br><span class="line"><span class="comment">// False - 返回文件结束标记EOF(-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用实例：获得当前运行时间，并存入文本中</span></span><br><span class="line"><span class="keyword">time_t</span> current = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">timer</span> = <span class="title">Localtime</span>(&amp;<span class="title">current</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将日历时间time_t型的值转换为分解时间tm结构体类型的值</span></span><br><span class="line"><span class="comment">// 其中，tm结构体为：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> tm_sec;<span class="comment">// 秒(0 - 61)</span></span><br><span class="line"><span class="keyword">int</span> tm_min;<span class="comment">// 分 (0 - 59)</span></span><br><span class="line"><span class="keyword">int</span> tm_hour;<span class="comment">// 时 (0 - 24)</span></span><br><span class="line"><span class="keyword">int</span> tm_mday;<span class="comment">// 日 (1 - 31)</span></span><br><span class="line"><span class="keyword">int</span> tm_mon;<span class="comment">// 月 (0 - 11)</span></span><br><span class="line"><span class="keyword">int</span> tm_year;<span class="comment">// 从1900至今，经历了多少年</span></span><br><span class="line"><span class="keyword">int</span> tm_wday;<span class="comment">// 星期 (0 - 6)</span></span><br><span class="line"><span class="keyword">int</span> tm_yday;<span class="comment">// 经历天数 (从1月1日计起)</span></span><br><span class="line"><span class="keyword">int</span> tm_tm_isdst;<span class="comment">// 夏时令 (夏季时间将提前1小时)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">"%d %d %d %d %d"</span>, </span><br><span class="line">timer-&gt;tm_year + <span class="number">1900</span>, timer-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">timer-&gt;tm_day, timer-&gt;tm_hour, </span><br><span class="line">timer-&gt;tm_min, timer-&gt;tm_sec);</span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure></li><li><p>读入／写入一个字符</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>;<span class="comment">// 读入一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(FILE *stream)</span></span>;<span class="comment">// 写入一个字符</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// Ture - 返回所读的字符数</span></span><br><span class="line"><span class="comment">// False - 返回文件结束标记EOF(-1)</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>用二进制方式向文件读写一组数据</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line"><span class="comment">// 从ptr指向的数组中将最多nmemb个长度为size的元素写入stream指向的流中。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">szie_t</span> nmemb, FILE *stream);</span><br><span class="line"><span class="comment">// 从stream流中读取nmemb个长度为size的元素写入到ptr数组。</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="10-7-随机读写数据文件"><a href="#10-7-随机读写数据文件" class="headerlink" title="10.7 随机读写数据文件"></a>10.7 随机读写数据文件</h3><h4 id="10-7-1-文件位置标记及其定位"><a href="#10-7-1-文件位置标记及其定位" class="headerlink" title="10.7.1 文件位置标记及其定位"></a>10.7.1 文件位置标记及其定位</h4><ul><li><p>文件位置标记：文件头、读写当前位置、文件尾</p></li><li><p>文件位置标记的定位：fseek(文件类型指针, 位移量, 起始点);</p><blockquote><p>文件开始位置 -&gt; SEEK_SET -&gt; 0<br>文件当前位置 -&gt; SEEK_CUR -&gt; 1<br>文件末尾位置 -&gt; SEEK_END -&gt; 2  </p></blockquote></li></ul><h4 id="10-7-2-随机读写"><a href="#10-7-2-随机读写" class="headerlink" title="10.7.2 随机读写"></a>10.7.2 随机读写</h4><p>结合fseek()与fread()函数实现。</p><blockquote><p>[如] 读取第1，3，5，7，9个学生数据并输出。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i+=<span class="number">2</span>)&#123;</span><br><span class="line">fseek(fp, i*<span class="keyword">sizeof</span>(struct Student), <span class="number">0</span>);</span><br><span class="line">fread(&amp;student[i], <span class="keyword">sizeof</span>(struct Student), <span class="number">1</span>, fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;从标题中透漏的信息可知，本系列文章是围绕 “C语言程序设计” 展开学习的笔记总结，且目的很明确，笔记内容偏应试，适用于计算机等级考试、考研专业课(C语言)等的复习使用。文章推崇总结性、比对性的学习方法，对于模糊的知识模块需自行查阅参考书目，深化理解或可达到理想的效果。&lt;/p&gt;
    
    </summary>
    
      <category term="Programme" scheme="http://www.kofes.cn/categories/Programme/"/>
    
    
      <category term="C" scheme="http://www.kofes.cn/tags/C/"/>
    
      <category term="考试" scheme="http://www.kofes.cn/tags/%E8%80%83%E8%AF%95/"/>
    
  </entry>
  
</feed>
