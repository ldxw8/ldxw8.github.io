<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KOFE&#39;S BLOG</title>
  
  <subtitle>Reading / Project / Research</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kofes.cn/"/>
  <updated>2018-06-11T16:17:48.944Z</updated>
  <id>http://www.kofes.cn/</id>
  
  <author>
    <name>Kofe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>论文 - 通过非线性随机邻近嵌入自动分类细胞表达</title>
    <link href="http://www.kofes.cn/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding.html"/>
    <id>http://www.kofes.cn/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding.html</id>
    <published>2018-06-06T13:14:53.000Z</published>
    <updated>2018-06-11T16:17:48.944Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p>原文：Automatic classification of cellular expression by nonlinear stochastic embedding (ACCENSE)<br>作者：Karthik Shekhar, Petter Brodin, Mark M.Davis and Arup K.Chakraborty.<br>来源：Proceedings of the National Academy of Sciences (PNAS), 2014, 111(1): 202-207.  </p></div><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>质谱流式细胞技术 (Mass cytometry) 能够在单细胞水平上测试近 40 种不同的蛋白质，即提供前所未有的多维信息水平。由于各式各样的细胞种群数据集的复杂性，要收集有用的生物学知识对计算工具也有新的要求。回顾之前的聚类方法，即对于不同功能的细胞识别是基于细胞表征相似性来实现区分的。当然，经典方法存在一定局限性，例如单细胞分辨率的损失；经典方法需要预知簇中的对象数量 (本文中指细胞亚群的规模数量)。</p><a id="more"></a><p>则该论文引入 <code>ACCENSE</code> (Automatic classification of cellular expression by nonlinear stochastic embedding) 高维单细胞数据分析工具：</p><ul><li>基于密度划分的非线性降维方法，降维步骤采用 <code>t-Distributed Stochastic Neighbor Embedding (t-SNE)</code> 算法 $^{[1]}$。</li><li>探索性数据分析，同时避免任何手动 <code>阀门(阈值)</code> 的需要，即有别于基于距离的方法 (离群点判定)、基于密度的方法 (密度阈值)。</li><li>化繁为简，在二维或三维图上展示多元细胞的表型。</li></ul><p>再有，本论文将 ACCENSE 应用于 35 参数的质谱流式细胞技术，检测 CD8+ T 细胞的数量 (数据来自于特定的无病原和无菌小鼠)，并将细胞分层到表型亚群中。即对于具体的聚类算法、降维算法中，特定的符号名称会以具体的对象名称替代。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><ul><li><p>免疫系统包含了许多类型的细胞，它们在免疫应答过程中表现出多样化的功能和复杂方式的相互作用，即通过不同蛋白质的表达水平所定义，故个体细胞的功能与其细胞表型密切相关。这里启示我们，对于不同功能的细胞可通过细胞表型相似性进行聚类区分。</p></li><li><p>传统流式细胞技术和质谱流式细胞技术</p><ul><li><p>传统流式细胞技术 (Flow Cytometry) $^{[2]}$ 中，用 <code>荧光基因</code> 标记的抗体染色，其蛋白质靶标通过单细胞分辨率的光发射信号进行量化。</p><blockquote><p>由于有限的光谱和重叠的发射信号，每个细胞限制为 12-16 个参数。</p></blockquote></li><li><p>质谱流式细胞技术 (Mass Cytometry) $^{[3]}$ ，使用 <code>金属螯合探针</code> 可以对多达 42 个参数的单个细胞进行量化。</p></li><li><p>传统流式细胞技术和质谱流式细胞技术相比，主要有两点不同：  </p><ul><li>标签系统的不同，前者主要使用各种荧光基团作为抗体的标签，后者则使用各种金属元素作为标签；  </li><li>检测系统的不同，前者使用激光器和光电倍增管，而后者使用 ICP 质谱技术。 </li></ul></li></ul></li></ul><h3 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h3><p>由 <code>质谱流式细胞技术产生的高维数据</code>，以具有生物学意义的方式解释是具有挑战性的。然而，很多聚类工具是基于细胞的蛋白表达相似性进行细胞分类的，例如：</p><ul><li><code>SPADE 算法</code> $^{[4,5]}$：SPADE 使用多元信息定义细胞簇，并在树状结构中显示潜在的表型层次结构。但尚有不足之处：<ul><li>一是单细胞分辨率的损失；</li><li>二是对目标集群数量的需要预知。</li></ul></li></ul><h3 id="降维算法"><a href="#降维算法" class="headerlink" title="降维算法"></a>降维算法</h3><p>同样，降维算法以蛋白质表达相似性，把空间组织的细胞群在低维空间聚集成不同的细胞亚群。    </p><ul><li><code>PCA 算法</code>：PCA降维的大致思想就是，挑选特征明显的、显得比较重要的信息保留下来。在本论文中，Newell 等人将主成分分析 (Principal component analysis，PCA) 应用于 25 参数的质谱流式细胞技术，检测人的 CD8+ T 细胞的数量，且使用前三种主成分 (3D-PCA) 分离细胞亚群。3D-PCA 以三个汇总变量表示数据，每个汇总变量都是原始维度的线性组合，并去捕获投影后数据的方差，直至其取值为最大值。然而，PCA 能在数据中所有的可能线性组合中找到最优表达，但也存在限制条件：线性投影可能太严格而不能产生精确的表示 $^{[6]}$ ( 引入 t-SNE 算法 )。</li><li><p><code>t-SNE 算法</code> $^{[7]}$：t-Distributed Stochastic Neighbor Embedding，数据降维与可视化的方法，具体的算法细节如下：</p><ul><li>让 $\{x^{(i)}\}$ 表示归一化 n 维蛋白质表达向量编码的细胞 i 表型 (i=1, 2, …, M)。</li><li>若在 2D 平面图下，$\{y^{(i)}\}$ 向量表示高维 $\{x^{(i)}\}$ 对应于低维的映射，它使得具有相似表型的 T 细胞彼此靠近嵌入，表型不相似的则嵌入相对较远的距离。</li><li>采用细胞 i 和 j 之间的成对概率 $\{p_{i,j}\}$ 表示 $\{x^{(i)}\}$ 与 $\{x^{(j)}\}$ 之间的相似性。</li><li>若在 2D 平面图下，成对概率 $\{q_{i,j}\}$ 表示 $\{y^{(i)}\}$ 与 $\{y^{(j)}\}$ 之间的相似性。</li><li><p>通过最小化 $\{p_{i,j}\}$ 与 $\{q_{i,j}\}$ 的 KL 散度 (可理解为代价函数)，然后找出嵌入向量 $\{y^{(i)}\}$，即它让高维转低维的表示信息能最大程度被保存下来。</p><blockquote><p>KL 散度 (<a href="#1-t-SNE-中的概率">详细见附录 1</a>)，Kullback-Leibler Divergence，又称相对熵，即描述两概率分布 P 和 Q 的差异。KL 散度公式 (1) 如下：</p></blockquote><script type="math/tex; mode=display">D_{KL}(\{p_{i,j}\}|\{q_{i,j}\}) = \sum_{i,j} p_{i,j} log \frac{p_{i,j}}{q_{i,j}} \tag{1}</script></li><li><p>$\{y^{(i)}\}$ 可以编码非线性关系，不像 PCA 中被约束为 $\{x^{(i)}\}$ 的线性组合。</p></li><li><code>最佳嵌入</code> 是通过数值梯度下降法来确定的，即所有数据点的 KL 散度总和减小到最小 (<a href="#2-数值梯度下降法">详细见附录 2</a>)。</li></ul></li></ul><h3 id="识别细胞亚群"><a href="#识别细胞亚群" class="headerlink" title="识别细胞亚群"></a>识别细胞亚群</h3><ul><li><p>使用一个内核密度变换，从 t-SNE 的细胞散布图计算出一个复合图像 $K_\gamma(y)$：</p><script type="math/tex; mode=display">K_\gamma(y) = exp(  -\frac{||y - y'||^{2}}{2\gamma^2}  )\tag{2}</script></li><li><p>在本论文中，$K_\gamma(y)$ 的 <code>局部最大值</code> 表示具有共同表型的 CD8+ T 细胞亚群，且使用了 matlab 的峰值检测算法识别这些局部最大值。</p><blockquote><p>当然，也可以在嵌入点上使用 K-Means 聚类算法来识别 T 细胞子集，但其要求事先指定簇的数量。</p></blockquote></li><li><p>如何求得 <code>局部最大值</code>，关键是对于公式 (2) 中 $\gamma$ 的参数设定多少有关。即通过比较不同的核-宽带 $\gamma$ 产生的结果，则存在一个 $\gamma$ 值为表型空间中存在的局部和全局特征提供了准确的粗粒度表示。从图 1-2 中可得，即启示我们可以以数据驱动的方式，近似地识别 CD8+ T 细胞的亚群。</p></li></ul><h3 id="相关图表"><a href="#相关图表" class="headerlink" title="相关图表"></a>相关图表</h3><ul><li>如图 1-1 所示，ACCENSE 应用于质谱高维数据。</li></ul><p><img src="/images/illustration/Paper/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding_1-1.jpg" alt="图1-1ACCENSE ACCENSE 应用于质谱高维数据"></p><center>图 1-1 ACCENSE 应用于质谱高维数据</center><p>(A) 质谱细胞计数数据集样本的图示。行对应于不同的细胞，而列对应于测量其表达 (细胞表面抗原和细胞内蛋白) 的不同标记的金属螯合抗体。每一元组对应于指示每个标记的表达水平的质荷比变换值 (反双曲函数)。(C) 来自SPF B6 小鼠的 CD8+ T 细胞的 2D t-SNE 图谱。每个点代表来自训练集的一个细胞 (M = 18304)，且数据点是通过对原始数据集进行下采样得到。(D) 通过使用基于内核密度变换 ($K_{\gamma}(y)\,{,}\,\gamma = 7$)，将细胞的局部概率密度嵌入 (C) 的复合图像。并使用标准的峰值检测算法进行识别局部最大值，在二维密度图表示表型亚群的中心。</p><ul><li>如图 1-2 所示，展示了峰值随着 $\gamma$ 的增加而变化。</li></ul><p><img src="/images/illustration/Paper/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding_1-2.png" alt="图1-1ACCENSE ACCENSE 应用于质谱高维数据"></p><center>图 1-2 展示了峰值随着 $\gamma$ 的增加而变化</center><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="1-t-SNE-中的概率"><a href="#1-t-SNE-中的概率" class="headerlink" title="1 t-SNE 中的概率"></a>1 t-SNE 中的概率</h3><h4 id="p-i-j-概率"><a href="#p-i-j-概率" class="headerlink" title="$p_{i,j}$ 概率"></a>$p_{i,j}$ 概率</h4><p>基于蛋白质相似性，设 $p_{j|i}$ (i,j = 1, 2, …, M) 表示细胞 i 将选择细胞 j 作为其最近邻的概率 ( $p_{j|i}$ 越大，$x^{(i)} 和 x^{(j)}$ 越近 )：</p><script type="math/tex; mode=display">p_{j|i} = \frac{    exp({-d_{i,j}^2} / {    2\sigma_i^2})}{     \sum_{k \neq i} exp({-d_{i,k}^2} / {    2\sigma_i^2})}, d_{i,j} = ||x^{(i)} - x^{(j)}||_2\tag{3}</script><p>对于概率 $p_{j|i}$ 的几点说明：</p><ul><li>$d_{i,j}$ 可以使用其他距离范式替代欧式距离范式；</li><li><p>原始的 SNE 算法是不对称的，为简化梯度公式，t-SNE 中让公式 (3) 的条件概率是对称的。即初始化 $p_{i|i} = 0$，对于任意的 $p_{i|j} = p_{j|i}$，可得：    </p><script type="math/tex; mode=display">p_{i,j} = \frac{  p_{j|i} + p_{i|j} }{2M} = \frac{  exp({-d_{i,j}^2} / {  2\sigma_i^2})}{   \sum_{k \neq i} exp({-d_{i,k}^2} / {  2\sigma_i^2})}\tag{4}</script></li><li><p>不同的点 $x_i$，带宽 $\sigma_i$ 的取值也是不同的。</p><ul><li>公式 (3) 中的带宽 $\sigma_i$ 是确保对于每一个细胞都有相同的复杂度 (Complexity)。复杂度可理解为一个点附近的 <code>有效近邻点个数</code>。</li><li>定义复杂度为 $P_i = 2^{H_{j|i}}$，其近似地解释为细胞 i 的最近邻点的数量。</li><li><p>定义 $p_{j|i}$ 的香农熵 (信息熵) 为 $H_{j|i} = - \sum_j p_{j|i} \log_2 p_{j|i}$，且 $H_{j|i}$ 随着 $\sigma_i$ 的增加而增加。</p><blockquote><p>在本论文中，t-SNE 图谱的复杂度被设定为 30，即 10-50 范围内的复杂度对最终结果的影响不大 (较好的鲁棒性)。</p></blockquote></li></ul></li></ul><h4 id="q-i-j-概率"><a href="#q-i-j-概率" class="headerlink" title="$q_{i,j}$ 概率"></a>$q_{i,j}$ 概率</h4><p>对于低维度下的 $\{y_i\}$，在原始的 SNE 算法 $^{[7]}$ 中 Hinton 和 Rowers 引用高斯核函数 (Gaussian Kernels) 定义 $q_{i,j}$，但在低维表达中发现了 <code>拥挤问题</code>。</p><blockquote><p><code>拥挤问题</code>：就是说各个簇聚集在一起，无法区分。譬如，有一高维度数据在降维到 10 维下可以有很好的表达，但是降维到两维后无法得到可信映射。具体情况是，10 维中有数个点之间两两等距离的，在二维下就无法得到可信的映射结果。<br>进一步说明，假设一个以数据点 $x^i$ 为中心，半径为 r 的 m 维球(三维空间就是球)，其体积是按 $r^m$ 增长的，假设数据点是在 m 维球中均匀分布的，我们来看看其他数据点与 $x^i$ 的距离随维度增大而产生的变化。</p></blockquote><p>t-SNE 减轻了拥挤问题，即使用更加偏重长尾分布的方式来将距离转换为概率分布 $^{[8]}$，故有 $q_{i,j}$：</p><script type="math/tex; mode=display">q_{i,j} = \frac{    (1 + \Delta_{i,j}^2)^{-1}}{     \sum_{k \neq i} (1 + \Delta_{i,k}^2)^{-1}}, \Delta_{i,j} = ||y^{(i)} - y^{(j)}||_2\tag{5}</script><p>同样地，对于概率 $q_{i,j}$ 的几点说明：</p><ul><li>$\Delta_{i,j}$ 可以使用其他距离范式替代欧式距离范式；</li><li>原始的 SNE 算法是不对称的，为简化梯度公式，t-SNE 中让公式 (5) 的条件概率是对称的。即初始化 $q_{i|i}=0$，对于任意的 $q_{i|j} = q_{j|i}$。</li></ul><h3 id="2-数值梯度下降法"><a href="#2-数值梯度下降法" class="headerlink" title="2 数值梯度下降法"></a>2 数值梯度下降法</h3><ul><li>在 [7] 中的概述过程，获得优化的梯度公式，如下所示:</li></ul><script type="math/tex; mode=display">\frac{    \partial D_{KL}(\{p_{i,j}\} | \{q_{i,j}\})}{    \partial_{y_t}^{(i)}} = 4 \sum_j \frac{        (p_{i,j} - q_{i,j})    }{        (1 + ||y_t^{(i)} - y_t^{(j)}||^2)    }    (y_t^{(i)} - y_t^{(j)})    \tag{6}</script><ul><li><p>通过梯度下降法迭代计算局部最大值：</p><script type="math/tex; mode=display">  y_{t+1}^{(i)} = y_{t}^{(i)} + \eta(t) \frac{      \partial D_{KL}(\{p_{i,j}\} | \{q_{i,j}\})  }{      \partial_{y_t}^{(i)}  }  + \alpha(t)(y_{t}^{(i)} - y_{t-1}^{(i)})  \tag{7}</script><ul><li>$y_t^{(i)}$ 表示迭代 t 次的解，$\eta(t)$ 表示学习速率，$\alpha(t)$ 表示迭代 t 次的动量。</li><li><p>学习速率初始值为 $\eta(t) = 100\,^{[9]}$，且动能量 $\alpha(t)$ 设定为：</p><script type="math/tex; mode=display">\alpha(t) = \begin{cases} 0.8, & t < 300 \\0.5, & t \geq 300 \end{cases}</script></li></ul></li></ul><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul><li>t-SNE 主要用于可视化，很难用于其他目的。譬如测试集合降维，因为他没有显式的预估部分，不能在测试集合直接降维。</li><li>关于核-带宽 $\gamma$ 参数设定问题：文中展示了 $\gamma$ 参数的大小与识别细胞亚群能力的数量关系。然而，数据驱动方式虽能实现自动聚类，但缺乏对于 $\gamma$ 参数设定范围该如何控制的说明。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] Maaten L, Hinton G. Visualizing data using t-SNE [J]. Journal of machine learning research, 2008, 9(Nov): 2579-2605.<br>[2] Cantor H, Simpson E, Sato V L, et al. And functional studies of peripheral t-cells binding different amounts of fluorescent anti-thy 1.2 (theta) Antibody using a fluorescence—activated cell sorter (FACS) [J]. 1975.<br>[3] Bendall S C, Nolan G P, Roederer M, et al. A deep profiler’s guide to cytometry [J]. Trends in immunology, 2012, 33(7): 323-332.<br>[4] Qiu P, Simonds E F, Bendall S C, et al. Extracting a cellular hierarchy from high-dimensional cytometry data with SPADE [J]. Nature biotechnology, 2011, 29(10): 886.<br>[5] Bendall S C, Simonds E F, Qiu P, et al. Single-cell mass cytometry of differential immune and drug responses across a human hematopoietic continuum [J]. Science, 2011, 332(6030): 687-696.<br>[6] Van Der Maaten L, Postma E, Van den Herik J. Dimensionality reduction: a comparative [J]. J Mach Learn Res, 2009, 10: 66-71.<br>[7] Maaten L, Hinton G. Visualizing data using t-SNE [J]. Journal of machine learning research, 2008, 9(Nov): 2579-2605.<br><a href="http://www.datakit.cn/blog/2017/02/05/t_sne_full.html" target="_blank" rel="noopener">[8] Chrispher. t-SNE 完整笔记 [OL]. www.datakit.cn. 2017.</a><br>[9] Jacobs R A. Increased rates of convergence through learning rate adaptation[J]. Neural networks, 1988, 1(4): 295-307.</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;原文：Automatic classification of cellular expression by nonlinear stochastic embedding (ACCENSE)&lt;br&gt;作者：Karthik Shekhar, Petter Brodin, Mark M.Davis and Arup K.Chakraborty.&lt;br&gt;来源：Proceedings of the National Academy of Sciences (PNAS), 2014, 111(1): 202-207.  &lt;/p&gt;&lt;/div&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;质谱流式细胞技术 (Mass cytometry) 能够在单细胞水平上测试近 40 种不同的蛋白质，即提供前所未有的多维信息水平。由于各式各样的细胞种群数据集的复杂性，要收集有用的生物学知识对计算工具也有新的要求。回顾之前的聚类方法，即对于不同功能的细胞识别是基于细胞表征相似性来实现区分的。当然，经典方法存在一定局限性，例如单细胞分辨率的损失；经典方法需要预知簇中的对象数量 (本文中指细胞亚群的规模数量)。&lt;/p&gt;
    
    </summary>
    
      <category term="Paper" scheme="http://www.kofes.cn/categories/Paper/"/>
    
    
      <category term="数据挖掘" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="聚类" scheme="http://www.kofes.cn/tags/%E8%81%9A%E7%B1%BB/"/>
    
      <category term="降维" scheme="http://www.kofes.cn/tags/%E9%99%8D%E7%BB%B4/"/>
    
      <category term="免疫表型" scheme="http://www.kofes.cn/tags/%E5%85%8D%E7%96%AB%E8%A1%A8%E5%9E%8B/"/>
    
      <category term="机器学习" scheme="http://www.kofes.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>论文 - 扩展 K-Means 算法：混合数据类型的聚类方法</title>
    <link href="http://www.kofes.cn/2018/06/Extensions-to-the-k-Means-algorithm-for-custering-large-datasets-with-categorical-values.html"/>
    <id>http://www.kofes.cn/2018/06/Extensions-to-the-k-Means-algorithm-for-custering-large-datasets-with-categorical-values.html</id>
    <published>2018-06-03T12:47:42.000Z</published>
    <updated>2018-06-08T17:06:26.009Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p>原文：Extensions to the k-means algorithm for clustering large datasets with categorical values<br>作者：ZHEXUE HUANG.<br>来源：Data mining and knowledge discovery, 1998, 2(3): 283-304.  </p></div><ul><li>更新进度：<ul><li>2018.06.04: 整理原文，完成初稿；</li><li>2018.06.05: 更新第 2 / 6 章；</li></ul></li></ul><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在早期，大多数聚类工作主要集中在数值数据上，且它们主要是利用数值数据的固有几何特性，即数据点之间的 <code>距离函数</code> (<a href="#1-距离函数">见附录1</a>)。但是，数据挖掘应用程序通常涉及许多数据集，这些数据集是由混合数值属性和标称属性组成的，仅拥有数值数据的测量方法已无法满足混合数据类型的聚类工作。</p><p>本论文基于经典的 K-Means 算法上，提出了两种聚类算法，分别应对 <code>标称域</code> 和 <code>混合数值与标称域</code> 属性值的聚类操作。首先介绍的是<code>K-Modes (K-众数)</code> 聚类算法，他运作的方式与 K-Means 相仿，只是它利用的是相异性度量处理标称对象，聚类中心以众数替代均值，且众数以基于频率的方法去迭代更新，直至 <code>聚类代价函数</code> 的结果最小化停止迭代。其次，是 <code>K-Prototype</code> 聚类算法，它定义了一组合的相异性度量值，进一步整合 <code>K-Means</code> 和 <code>K-Modes</code> 算法，以实现对混合数值与标称属性的对象进行聚类操作。</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>将数据库中的一组对象划分为同构组或集群是数据挖掘中最基本的操作。而讨论划分操作，自然离不开聚类。聚类是把每一组对象划分为一个簇，且同一簇中对象之间相似，而不同簇之间的对象相异。</p><p>数据挖掘最显著的特征是处理复杂的大型数据集。特别地，数据集包含数以百万计由不同类型属性或变量描述的对象，由此数据挖掘操作和算法应充分考虑可扩展性，以应付处理不同类型的属性。</p><p>在本论文中，提出的两个新聚类算法，即利用 <code>K-Means 范式</code> 对拥有标称属性的数据进行聚类。<code>K-Modes (K-众数)</code> 聚类算法，他运作的方式与 K-Means 相仿，只是它利用的是相异性度量处理标称对象，聚类中心以众数替代均值，且众数以基于频率的方法去迭代更新，直至 <code>聚类代价函数</code> 的结果最小化停止迭代。其次，是 <code>K-Prototype</code> 聚类算法，它定义了一组合的相异性度量值 $s^r + \gamma s^c$，以实现对混合数值与标称属性的对象进行聚类操作。其中，$s^r$ 是由 <code>平方欧式距离</code> 定义的 <code>数值属性</code> 的相异性度量值，$s^c$ 是由 <code>两个对象间类别不匹配的数量</code> 定义的 <code>标称属性</code> 的相异性度量值，$\gamma$ 是平衡数值属性和标称属性两部分的的权值，以避免偏向于某一属性。若聚类的效果更青睐于数值属性，则可以设定一个较小的 $\gamma$ 值；反之，设定一较大的 $\gamma$ 值。</p><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><ul><li>假设需要聚类的对象数据集储存在数据集 D 中。<ul><li>集合的属性 $A_1, A_2, … , A_m$ 分别是值域 $D_1, D_2, … , D_m$ 的描述。</li><li>在 D 中的每个对象由元组 t 表示，$t \in D_1 \times D_2 \times … \times D_m$。</li></ul></li><li>针对本文讨论的聚类问题，仅考虑两种常见数据类型：数值类型和标称类型。<ul><li>数值域的取值范围是实数域。</li><li>在多维的密度空间中，每一个数值型的数据点都采用诸如欧式或马氏的距离度量方法。</li><li>若值域 $D_i$ 被定义为有限、无序的标称域，则对象的比较操作只允许在 $D_i$ 中执行，即有 $a, b \in D_i$，either a = b or $a \neq b$。</li></ul></li><li><p>对于数据集中的每一数据对象 $X$，也可由 <code>属性-属性值</code> 的键值对表示，</p><script type="math/tex; mode=display">[A_1=x_1] \bigwedge [A_2=x_2] \bigwedge ... \bigwedge [A_m=x_m]</script></li><li><p>即当 $x_i \in D_i$，for i = 1, 2, …, m。为简单起见，这里以 $X$ 表示元组：</p><script type="math/tex; mode=display">[x_1^r, x_2^r, ...,x_p^r, x_{p+1}^c, ..., x_m^c] \in D_1 \times D_2 \times ... \times D_m</script><blockquote><p>第一个元素 p 为数值对象，其余的都是标称对象。当然，若元组中仅有一种数据类型，可表示为 $[x_1, x_2, …, x_m]$。</p></blockquote></li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="1-距离函数"><a href="#1-距离函数" class="headerlink" title="1 距离函数"></a>1 距离函数</h3><p><code>距离函数</code>：关于数据点之间的距离函数，即数值属性刻画的对象相异性的距离度量。度量方法 $^{[1]}$ 包括闵可夫斯基距离 (闵氏距离)、欧几里得距离 (欧式距离) 和曼哈顿距离。</p><p>令 $i=(x_{i1},x_{i2},…,x_{ih})$ 和 $j=(x_{j1},x_{j2},…,x_{jh})$ 是两个被 h 个属性描述的对象。 </p><p>闵氏距离是欧式距离和曼哈顿距离的推广，定义如下：</p><script type="math/tex; mode=display">d(i, j) = \sqrt[h](    \sum_{f=1}^h |x_{if}-x_{jf}|^{h}),h \geq 1\tag{1}</script><ul><li>当 h = 1 时，它表示 <code>曼哈顿距离</code>，也称 <code>城市块</code> 距离 (城市两点之间的街区距离，如向南 2 个街区，横过 3 个街区，共计五个街区)，其定义如下：</li></ul><script type="math/tex; mode=display">d(i, j) = \sum_{f=1}^h |x_{if}-x_{jf}|,h \geq 1\tag{2}</script><ul><li>当 h = 2 时，它表示 <code>欧式距离</code>，也称 <code>直线或乌鸦飞行</code> 距离，其定义如下：</li></ul><script type="math/tex; mode=display">d(i, j) = \sqrt(\sum_{f=1}^h (x_{if}-x_{jf})^2),h \geq 1\tag{3}</script><ul><li>当 h = $\infty$ 时，它表示 <code>上确界距离</code>，又称 <code>切比雪夫距离</code>，其定义如下L：</li></ul><script type="math/tex; mode=display">d(i, j) = \lim_{h \to \infty} (    \sum_{f=1}^h |x_{if}-x_{jf}|^h)^\frac{1}{h} = max_{f}^h |x_{if}-x_{jf}|\tag{4}</script><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] Jiewei Han, Micheline Kamber and Jian Pei. 数据挖掘 (第三版) [M]. 机械工业出版社, 2018, 48-49.</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;原文：Extensions to the k-means algorithm for clustering large datasets with categorical values&lt;br&gt;作者：ZHEXUE HUANG.&lt;br&gt;来源：Data mining and knowledge discovery, 1998, 2(3): 283-304.  &lt;/p&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;更新进度：&lt;ul&gt;
&lt;li&gt;2018.06.04: 整理原文，完成初稿；&lt;/li&gt;
&lt;li&gt;2018.06.05: 更新第 2 / 6 章；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;在早期，大多数聚类工作主要集中在数值数据上，且它们主要是利用数值数据的固有几何特性，即数据点之间的 &lt;code&gt;距离函数&lt;/code&gt; (&lt;a href=&quot;#1-距离函数&quot;&gt;见附录1&lt;/a&gt;)。但是，数据挖掘应用程序通常涉及许多数据集，这些数据集是由混合数值属性和标称属性组成的，仅拥有数值数据的测量方法已无法满足混合数据类型的聚类工作。&lt;/p&gt;
&lt;p&gt;本论文基于经典的 K-Means 算法上，提出了两种聚类算法，分别应对 &lt;code&gt;标称域&lt;/code&gt; 和 &lt;code&gt;混合数值与标称域&lt;/code&gt; 属性值的聚类操作。首先介绍的是&lt;code&gt;K-Modes (K-众数)&lt;/code&gt; 聚类算法，他运作的方式与 K-Means 相仿，只是它利用的是相异性度量处理标称对象，聚类中心以众数替代均值，且众数以基于频率的方法去迭代更新，直至 &lt;code&gt;聚类代价函数&lt;/code&gt; 的结果最小化停止迭代。其次，是 &lt;code&gt;K-Prototype&lt;/code&gt; 聚类算法，它定义了一组合的相异性度量值，进一步整合 &lt;code&gt;K-Means&lt;/code&gt; 和 &lt;code&gt;K-Modes&lt;/code&gt; 算法，以实现对混合数值与标称属性的对象进行聚类操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Paper" scheme="http://www.kofes.cn/categories/Paper/"/>
    
    
      <category term="数据挖掘" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="聚类" scheme="http://www.kofes.cn/tags/%E8%81%9A%E7%B1%BB/"/>
    
      <category term="机器学习" scheme="http://www.kofes.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="混合类型" scheme="http://www.kofes.cn/tags/%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="K-Means" scheme="http://www.kofes.cn/tags/K-Means/"/>
    
  </entry>
  
  <entry>
    <title>论文 - 通过快速查找和发现密度峰值进行聚类</title>
    <link href="http://www.kofes.cn/2018/05/Clustering-by-fast-search-and-find-of-density-peaks.html"/>
    <id>http://www.kofes.cn/2018/05/Clustering-by-fast-search-and-find-of-density-peaks.html</id>
    <published>2018-05-27T01:43:41.000Z</published>
    <updated>2018-06-08T17:06:36.668Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p>原文：Clustering by fast search and find of density peaks<br>作者：Alex Rodriguez and Alessandro Laio<br>来源：Science 344.6191(2014), 1492-1496.</p></div><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>聚类分析的目的在于根据元素的相似性将元素分类。而该论文基于这样一种观点的提出新的方法，即聚类中心的密度高于其邻居，而密度高的点相对较远。这个想法构成了聚类过程的基础，其中簇的数量直观地产生，异常值被自动地发现并从分析中排除，并且聚类被识别，而不管它们的形状和嵌入它们的空间的维度如何。</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="不同的聚类策略"><a href="#不同的聚类策略" class="headerlink" title="不同的聚类策略"></a>不同的聚类策略</h3><h4 id="基于距离的方法"><a href="#基于距离的方法" class="headerlink" title="基于距离的方法"></a>基于距离的方法</h4><p>在 <code>K-means</code> 和 <code>K-medoids</code>，聚类是以距离聚类中心很小的距离为特征的数据集合。</p><p>然而，因为数据点总是被分配到最近的中心，所以该类算法只能发现球形的簇，而在发现任意形状的簇时会遇到困难。</p><blockquote><p>提示：<code>K-均值 (K-Means)</code> 的方法仅当簇中均值有定义时才有意义，而当涉及具有标称属性的数据时，K-均值的方法失效。而这里可采用 <code>K-众数 (K-Modes)</code> 的变体，即采用 <code>基于频率</code> 的方法来更新簇的众数，对具有标称属性的数据进行聚类。当然，还有 <code>K-Prototype</code> $^{[1,2]}$、<code>K-Means++</code> $^{[3]}$ 等优化版本的算法。</p></blockquote><h4 id="基于密度的方法"><a href="#基于密度的方法" class="headerlink" title="基于密度的方法"></a>基于密度的方法</h4><p>通过基于数据点局部密度的方法很容易检测具有任意形状的簇。其主要思想是：在某领域 (对象或数据点的数目) 内，给定密度阈值，将密度低于该阈值的数据点视为噪声丢弃，并将其分配给不连续的高密度领域的其他簇。这样的方法可用来过滤噪声或离群点，发现任意形状的簇。</p><p><code>DBSCAN</code> (Density-Based Spatial Clustering of Applications with Noise) 是一个基于密度的聚类算法，它将簇定义为密度相连的点的最大集合，能够把具有足够高密度的领域划分为簇。在噪声的空间数据库中可发现任意形状的聚类。</p><p>然而，从上述当中可知，除了要选择合适的阈值，且它缺少均值漂移的聚类方法。虽然这种方法允许发现非球形簇，但仅适用于由一组坐标定义的数据。</p><h4 id="本文改进的方法"><a href="#本文改进的方法" class="headerlink" title="本文改进的方法"></a>本文改进的方法</h4><p>首先，该算法提出假设：类簇中心被具有较低局部密度的 <code>邻居点</code> 包围，且与具有较高密度的 <code>任何点</code> 有相对较大的距离。对于每一个数据点 i，要计算 <code>两个量</code>：点的局部密度 $\rho_i$ 和该点到具有更高局部密度的点的距离 $\delta_i$。而这两个值都取决于数据点间的距离 ${d}_{ij}$ (欧几里得距离，也称 <code>欧式距离</code>)。数据点的局部密度定义为：</p><script type="math/tex; mode=display">\rho_i = \sum_j \chi(d_{ij} - d_c)</script><p>其中 $\chi(x)$ 为 0-1 函数，如果 x &lt; 0，那么 $\chi(x) = 1$；否则 $\chi(x) = 0$，$d_{c}$ 是一个 <code>截断距离</code>。基本上，$\rho_i$ 等于与点 i 的距离小于 $d_{c}$ 的点的个数。算法只对不同点 $\rho_i$ 的相对大小敏感，这意味着对于大数据集，分析结果在 $d_{c}$ 的选择方面具有很好 <code>鲁棒性</code>。</p><ul><li><p>$\delta_i$ 是通过计算点之间的 <code>最小距离</code> 来测量的，即数据点 i 与距离它最近的、密度更高的点 j 的距离最小值式：</p><blockquote><p>提示：在图 1-1.(A) 中可知，数据点是按照密度降序排列。</p></blockquote></li></ul><script type="math/tex; mode=display">\delta_i = min_{j:\rho_j>\rho_i}(d_{ij})</script><ul><li>若数据点 i 是密度最大的点，$\delta_i$ 为所有节点中到数据点 i 的最大距离：</li></ul><script type="math/tex; mode=display">\delta_i = max_j(d_{ij})</script><p>如图 1-1 所示，其展示了算法的核心思想。图 1-1.(A) 展示了二维空间中的 28 个点，<code>且 A 中数据点是按照密度降序排列</code>。图 1-1.(B) 中以 $\rho_i$ 作为横坐标，$\delta_i$ 作为纵坐标，画二维图，并称其为决策图。可以发现点 1 和点 10 的  $\rho_i$ 和 $\delta_i$ 最大，故将其作为类簇中心。</p><blockquote><p>点 9 和点 10 的 $\rho_i$ 相似，但 $\delta_i$ 值却有很大差别：点 9 属于点 1 的类簇，且有其它几个更高 $\rho_i$ 的点距其很近，然而点 10 拥有更高密度的最近邻属于其它的类簇。  </p><p>所以，正如预期的那样，只有具有高 $\delta_i$ 和相对较高 $\rho_i$ 的的点才是 <code>类簇中心</code>。因为点 26、27、28 是孤立的，所以有相对较高的 $\delta_i$ 值和低 $\rho_i$ 值，它们可以被看作是由单个点做成的类簇，也就是 <code>异常点</code>。</p></blockquote><p><img src="/images/illustration/Paper/2018/05/Clustering-by-fast-search-and-find-of-density-peaks_1-1.jpg" alt="图1-1算法在二维空间的展示"></p><center>图 1-1 算法在二维空间的展示</center><p>类簇中心找到后，剩余的每个点被归属到它的有更高密度的最近邻所属类簇。类簇分配只需 <code>一步即可完成</code>，不像其它算法要对目标函数进行 <code>迭代优化</code>。</p><p>在聚类分析中，定量的衡量分配的可信度是很重要的。在该算法中，首先为每个类簇定义一个 <code>边界区域</code> (即分配到该类簇的点集合，且与其它类簇的点的距离小于 $d_c$)，然后为每个类簇的找到其边界区域中密度最高的点 $\rho_b$，并以来表示该点的密度。若类簇中局部密度值比 $\rho_b$ 大的点被看作是类簇的核心部分 (即分配到该类簇的可靠性较高)，其他点 (类簇中局部密度值比 $\rho_b$ 小的点) 被看作是类簇的 <code>光晕部分</code> (亦可被看作是噪声)。</p><p><img src="/images/illustration/Paper/2018/05/Clustering-by-fast-search-and-find-of-density-peaks_1-2.jpg" alt="图1-2合成点分布的结果"></p><center>图 1-2 合成点分布的结果</center><p>(A) 为绘制点分布的概率分布。(B和C) 分分别为 4000 和 1000 样本点的点分布。且每个点以其颜色表示所属类簇，黑色点属于光晕类簇 (噪声点)。(D和E) 为 (B和C) 相应的决策图，其中心由相应簇来着色。(F) 作为样本维度的函数，分配给不正确聚类的点的分数。误差线表示平均值的标准误差。</p><p>从图 1-2.(F) 中可以看到，错分点的比例即使在只有 1000 个点的小样本中仍保持在 1% 以下，说明算法有很好的鲁棒性。</p><p>从图 1-3 中可以看到，该算法对于各种数据级都能达到很好的聚类效果 (图中为引用文献中的测试用例结果)。</p><p><img src="/images/illustration/Paper/2018/05/Clustering-by-fast-search-and-find-of-density-peaks_1-3.jpg" alt="图1-3引用文献中的测试用例结果"></p><center>图 1-3 引用文献中的测试用例结果</center><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>摘要部分提到的，异常点能 <code>自动地</code> 被分析出来，但从它的 Matlab 源码可知，还是需要人为判断异常点 (与问题三结合思考)？</li><li>文中提到的截断距离 $d_c$，该设定多少才算较合理？</li><li>文中判断簇中心的两个参数量 $\delta_i$ 和 $\rho_i$，即同时具有相对较高的距离和局部密度可选为簇中心，那么如何定义相对较高的具体值？</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] Huang Z. Clustering large data sets with mixed numeric and categorical values [C]. 1997: 21-34.<br>[2] Huang Z. Extensions to the k-means algorithm for clustering large data sets with categorical values [J]. Data mining and knowledge discovery, 1998, 2(3): 283-304.<br>[3] San O M, Huynh V N, Nakamori Y. A clustering algorithm for mixed numeric and categorical data [J]. Journal of Systems Science and Complexity, 2003, 16(4): 562-571.  </p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;原文：Clustering by fast search and find of density peaks&lt;br&gt;作者：Alex Rodriguez and Alessandro Laio&lt;br&gt;来源：Science 344.6191(2014), 1492-1496.&lt;/p&gt;&lt;/div&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;聚类分析的目的在于根据元素的相似性将元素分类。而该论文基于这样一种观点的提出新的方法，即聚类中心的密度高于其邻居，而密度高的点相对较远。这个想法构成了聚类过程的基础，其中簇的数量直观地产生，异常值被自动地发现并从分析中排除，并且聚类被识别，而不管它们的形状和嵌入它们的空间的维度如何。&lt;/p&gt;
    
    </summary>
    
      <category term="Paper" scheme="http://www.kofes.cn/categories/Paper/"/>
    
    
      <category term="数据挖掘" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="聚类" scheme="http://www.kofes.cn/tags/%E8%81%9A%E7%B1%BB/"/>
    
      <category term="机器学习" scheme="http://www.kofes.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>笔记 - 高级软件工程 &amp; 导论</title>
    <link href="http://www.kofes.cn/2018/05/Sofeware-Engineering.html"/>
    <id>http://www.kofes.cn/2018/05/Sofeware-Engineering.html</id>
    <published>2018-05-02T11:45:02.000Z</published>
    <updated>2018-05-19T12:31:23.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在软工系列课程上，老师常提及的一条等式  <code>软件 = 程序 + 软件工程</code> ( 或 <code>软件 = 程序 + 文档</code>)，即一般情况讨论，一款软件产品的诞生之际总是伴随着一系列的软件过程。</p><p>那么如何充分理解软件工程 (过程)？从本书作者理念出发，我所理解的即应该时刻对软件产品持有 <code>生命周期</code> 的思维模式，将 <code>需求、建模、设计、实现、测试、维护</code> 等工程阶段联系起来，以自身代入案例环境中，去模拟开展软件过程的一系列活动，而非割裂。而这样的动态过程中，不仅仅是枯燥地学习理论、方法，则更像是问题所需、问题导向的理论应用过程。</p><p>当然，软件工程作为一门工程学科，学习过程的最大收获可以说是对 <code>项目思维模式</code> 的掌握。譬如，我们可以抛开软件产品的范畴，谈谈现实生活的实例：假若你需要在一定时限内掌握一门新知识、任务，则我们的做法可以从调研、计划、布局、实施，直至验收，即类似的过程可复用软件工程的方法。</p><p>最后，也是想声明的一点：学习软件工程的过程中，无可避免地将反映本人的一些观点、倾向，当然这也反映该学科需要 <code>多沟通</code> 的特点，若有不恰当、错误之处，欢迎大伙出建议、斧正。</p><a id="more"></a><ul><li><p>参考书目：</p><ul><li>《 软件工程 》. Ian Sommerville 著：计算机科学丛书，且是著名软件工程学家 Ian Sommerille 系统介绍软件工程理论的经典教材。</li><li>《 构建之法(第二版) 》: 待整理。贴上本书豆瓣的书评，供朋友评判，做出抉择。<a href="https://book.douban.com/subject/26577755/" target="_blank" rel="noopener">构建之法(第二版)</a> </li></ul></li><li><p>更新进程</p><ul><li>2018.05.02 - 完成初稿；</li><li>2018.05.04 - 更新正文：导论部分  (第 4 / 8 章)；</li></ul></li></ul><h2 id="零-总览"><a href="#零-总览" class="headerlink" title="零 总览"></a>零 总览</h2><ul><li>软件工程导论<ul><li><a href="#壹-软件过程">壹 软件过程</a></li><li><a href="#贰-敏捷软件开发">贰 敏捷软件开发</a></li><li><a href="#叁-需求工程">叁 需求工程</a></li><li><a href="#肆-系统建模">肆 系统建模</a></li><li><a href="#">伍 体系结构设计</a></li><li><a href="#">陆 设计与实现</a></li><li><a href="#">柒 软件测试</a></li><li><a href="#">捌 软件进化 / 软件维护</a></li></ul></li><li>高级软件工程<ul><li><a href="#">玖 软件复用</a></li><li><a href="#">拾 基于组件的软件工程</a></li></ul></li><li>软件管理<ul><li><a href="#">拾壹 项目管理</a></li><li><a href="#">拾贰 项目规划</a></li></ul></li></ul><h2 id="壹-软件过程"><a href="#壹-软件过程" class="headerlink" title="壹 软件过程"></a>壹 软件过程</h2><ul><li>学习目标<ul><li>3个一般的 <code>软件过程模型</code>；</li><li>了解软件需求工程、开发、测试和进化中所涉及的 <code>基本过程活动</code>；</li><li>理解为什么软件过程要有效地组织以应对软件需求和设计上的变更；</li><li>Rational 统一过程 (RUP).</li></ul></li><li>软件过程必须具有的基本活动<ul><li>软件描述</li><li>软件设计和实现</li><li>软件有效性验证</li><li>软件进化</li></ul></li><li>没有“理想”的软件过程 — 寻找平衡点<ul><li>计划驱动过程：提前计划好所有的过程活动，再按计划去考核过程的执行。</li><li>敏捷过程：计划是增量式的，且容易根据不断变化的客户需求变更过程。更多详细内容见 <code>第叁章</code>。</li></ul></li></ul><h3 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h3><ul><li>软件过程：产生一个软件系统的一系列活动。</li><li>软件过程的简化表示 (抽象表示)。</li><li><p>每个过程模型都是从一个特定的侧面表现软件过程，所以只提供过程的部分信息。</p><blockquote><p>如过程活动模型表现了这些活动和他们的顺序，但可能表现不出人们在这些活动中的角色。</p></blockquote></li></ul><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-1.png" alt="图1-1瀑布模型"></p><center>图 1-1 瀑布模型</center><ul><li>计划驱动模型；</li><li>该模型将基本的过程活动、描述、开发、有效性验证和进化，看成是一些界限分明的独立的过程阶段。<ul><li>需求分析和定义：通过咨询系统用户建立系统的服务、约束和目标，并对其详细定义形成系统描述。</li><li>系统和软件设计<ul><li>系统设计 — 建立系统的总体体系结构，将需求区分为硬件需求和软件需求。</li><li>软件设计 — 识别和描述一些基本的软件系统抽象及其之间的关系。</li></ul></li><li>实现和单元测试<ul><li>软件设计实现 — 实现为一组程序或程序单元。</li><li>单元测试 — 验证每个单元是否符合其描述。</li></ul></li><li>集成和系统测试<ul><li>集成 — 集成单个的程序单元或一组程序。</li><li>系统测试 — 评估系统的可靠性；是否满足软件需求。</li></ul></li><li>运行和维护</li></ul></li></ul><h4 id="增量式开发"><a href="#增量式开发" class="headerlink" title="增量式开发"></a>增量式开发</h4><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-2.png" alt="图1-2增量式开发"></p><center>图 1-2 增量式开发</center><ul><li>即可是计划驱动的，也可是敏捷方法的。<ul><li>系统增量是提前定义好的，即为 <code>计划驱动方法</code>。</li><li>最初的增量是定义好的，但往后的增量的开发取决于项目的进展情况及客户的优先选择，即为 <code>敏捷方法</code>。</li></ul></li><li>系统的开发是建立一系列的版本 (增量) 每个版本添加部分功能到先前版本中。</li><li>增量式开发的特性<ul><li>降低了适应用户需求变更的成本。</li><li>开发过程中及时得到用户已做的开发工作的反馈意见。</li><li>更快地交付和部署有用的软件到客户方。</li></ul></li></ul><h4 id="面向复用的软件工程"><a href="#面向复用的软件工程" class="headerlink" title="面向复用的软件工程"></a>面向复用的软件工程</h4><p>基于复用开发的一般过程模型如图 1-3 所示。初始需求描述阶段、有效性验证阶段与其他过程差不多，面向复用过程的中间阶段是不同的。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-3.png" alt="图1-3面向复用的软件工程"></p><center>图 1-3 面向复用的软件工程</center><ul><li>中间阶段：即组件分析、需求修改、使用复用的系统设计、开发和集成阶段。<ul><li>组件分析：需求描述 -&gt; 搜组件 (往往只提供所需的部分功能)。</li><li>需求修改：根据得到组件信息分析需求，再修改需求以反映可得到的组件。</li><li>使用复用的系统设计：设计系统的框架或者重复使用一个已存在的框架。</li><li>开发和集成</li></ul></li></ul><h3 id="过程活动"><a href="#过程活动" class="headerlink" title="过程活动"></a>过程活动</h3><h4 id="软件描述"><a href="#软件描述" class="headerlink" title="软件描述"></a>软件描述</h4><ul><li>软件描述或需求工程是理解和定义系统需要提供什么样的服务，以及找出开发和运行中受到哪些约束。</li><li>需求工程过程的主要阶段，如图 1-4 所示。<ul><li>可行性研究</li><li>需求导出和分析</li><li>需求描述</li><li>需求有效性验证</li></ul></li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-4.png" alt="图1-4需求工程过程"></p><center>图 1-4 需求工程过程</center><h4 id="软件设计和实现"><a href="#软件设计和实现" class="headerlink" title="软件设计和实现"></a>软件设计和实现</h4><ul><li>软件设计和实现阶段是把系统描述转换成一个可运行的系统的过程。</li><li>软件设计是对实现软件的结构、系统的数据、系统组件间的接口以及所用的算法的描述。这是一反复、迭代的过程。</li></ul><h4 id="软件有效性验证"><a href="#软件有效性验证" class="headerlink" title="软件有效性验证"></a>软件有效性验证</h4><ul><li>程序测试：用模拟测试数据运行系统。</li><li>测试过程各阶段<ul><li>组件 (单元) 测试：每个组件单独测试；组件可是简单实体，如函数、对象类或这些实体的集合。</li><li>系统测试：集成组件形成完整系统，对组件组成的子系统测试。</li><li>接收测试：客户提供真实数据测试系统。</li></ul></li></ul><h4 id="软件进化-软件维护"><a href="#软件进化-软件维护" class="headerlink" title="软件进化/软件维护"></a>软件进化/软件维护</h4><p>软件工程不再是开发和维护两个独立的过程，而是一个进化过程。即软件在其生命内不断随着需求的变更而变更的进化式过程。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-5.png" alt="图1-5系统进化"></p><center>图 1-5 系统进化</center><h3 id="应对变更"><a href="#应对变更" class="headerlink" title="应对变更"></a>应对变更</h3><ul><li>有效降低变更成本<ul><li>变更避免：预测变更，如 <code>原型系统</code> 的开发，客户试用原型，在花费高额的软件生产成本之前重新定义需求。</li><li>变更容忍：<code>增量开发</code>，即使单个增量(系统一小部分)的修改来适应变更，以较低成本处理变更。</li></ul></li><li>应对变更系统需求的方法<ul><li>系统原型：快速开发一个系统版本或系统一部分，以检验客户需求和某些设计决定的可行性，即它支持 <code>变更避免</code>。</li><li>增量交付：系统增量地交付给用户，给用户评审和试用。即它支持 <code>变更避免</code> 和 <code>变更容忍</code>。</li></ul></li></ul><h4 id="原型构造"><a href="#原型构造" class="headerlink" title="原型构造"></a>原型构造</h4><ul><li>原型是一个软件系统的最初版本，用于验证概念、试用设计选项、发现更多的问题和可能的解决方法。</li><li><p>原型开发的过程模型如图 1-6 所示。</p><p>  <img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-6.png" alt="图1-6原型开发的过程"></p>  <center>图 1-6 原型开发的过程</center><blockquote><p>最后一阶段：原型评估，则必须安排用户培训，应根据原型的目标制定一个评估计划。即用户需习惯并适用新系统，一旦他们自然地使用了系统，将可能发现错误和被遗漏的需求。</p></blockquote></li><li><p>不强求原型是可执行的。</p><blockquote><p>基于纸质的模型系统的用户界面，用户和这个界面交互，但他们的请求被传递给一个人，该人员解释此请求并输出相应的响应。</p></blockquote></li></ul><h4 id="增量式交付"><a href="#增量式交付" class="headerlink" title="增量式交付"></a>增量式交付</h4><ul><li><p>增量式开发是软件开发的一种方法，如图 1-7 所示。</p><p>  <img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-7.png" alt="图1-7增量式交付"></p>  <center>图 1-7 增量式交付</center></li><li><p>增量式开发过程的好处</p><ul><li>早期的增量作为原型，从中获得对后面系统增量的需求经验。</li><li>每一增量会满足他们大多数需求，即软件马上就能使用。</li><li>具有高优先权的服务被首先交付，而后继有增量不断被集成进来，使得最重要的系统服务接受了多次测试。</li></ul></li><li>增量式交付存在的问题<ul><li>软件描述和软件本身一起开发是迭代过程的本质。在增量方法中，直到最后的增量描述完成，才会有完整的系统描述。而许多机构 (如政府) 的采购模型是，系统开发合同中附带完整的系统描述，即相互冲突。</li><li>旧系统的所有功能与新系统的部分功能，多数用户宁可选前者，即获取反馈较困难。</li></ul></li></ul><h4 id="Boehm-的螺旋模型"><a href="#Boehm-的螺旋模型" class="headerlink" title="Boehm 的螺旋模型"></a>Boehm 的螺旋模型</h4><ul><li>风险驱动的软件过程框架 (螺旋模型)<ul><li>在螺旋线中每个回路表示软件过程的一个阶段，如最里的回路可能与系统可行性研究有关，下一回路与系统需求定义有关等。</li><li>螺旋线中每个回路被分成4部分：<br>1) 目标设置<br>2) 风险评估和规避<br>3) 开发和有效性验证<br>4) 规划  </li></ul></li></ul><h3 id="Rational-统一过程"><a href="#Rational-统一过程" class="headerlink" title="Rational 统一过程"></a>Rational 统一过程</h3><ul><li>RUP 一般从3个视角描述过程<ul><li>动态视角：给出模型中随时间所经历的各个阶段。</li><li>静态视角：给出所进行的过程活动。</li><li>实践视角：提出在过程中可采用的良好实践建议。</li></ul></li><li><p>RUP 是一阶段化模型，如图 1-8 所示。</p><ul><li>开端  <ul><li>目标是建立系统的一个业务案例。  </li><li>识别所有与系统交互的外部实体 (人和系统) 并定义这些交互。</li><li>适用这些信息评估系统对业务的贡献，若贡献微小，那么项目在此阶段结束。</li></ul></li><li>细化<ul><li>目标是增进对问题域的理解，建立系统的体系框架，给出项目计划并识别关键项目风险。</li><li>输出系统的需求模型 (描述的用例、体系结构描述及开发计划)。</li></ul></li><li>构造：系统设计、编程和测试。</li><li><p>转换：将系统从开发单位转移到用户单位，并使之在真实环境中工作。</p><blockquote><p>1) RUP 中的阶段是紧密与业务关联，而不是与技术层面关联。<br>2) RUP 把 <code>阶段</code> (开端、细化、构造、转换) 和 <code>工作流</code> (需求、分析、设计…) 分离，即各种 RUP 工作流在整个过程的所有阶段都是可能存放的。  </p></blockquote><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-8.png" alt="图1-8Rational统一过程的各阶段"></p><center>图 1-8 Rational 统一过程的各阶段</center></li></ul></li><li><p>实践视角</p><ul><li>迭代地开发软件；</li><li>对需求的管理：记录并跟踪客户的需求；</li><li>使用基于组件的体系结构，将系统体系结构组织成组件形态；</li><li>可视化地建模软件：UML 模型表现软件的静态、动态视图；</li><li>检验软件质量；</li><li>控制对软件的变更：变更管理系统、配置管理程序和工具来管理软件的变更。</li></ul></li><li><p>静态视角</p><ul><li>聚焦在开发过程中所发生的活动上，这些在 RUP 描述中被称为工作流。</li><li><p>此过程中包含6个核心过程工作流，3个核心支持工作流，见图 1-9 所示。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_1-9.png" alt="图1-9RUP中的静态工作流"></p><center>图 1-9 RUP 中的静态工作流</center></li></ul></li></ul><h2 id="贰-敏捷软件开发"><a href="#贰-敏捷软件开发" class="headerlink" title="贰 敏捷软件开发"></a>贰 敏捷软件开发</h2><div class="note success"><p> 开始敏捷开发篇章前，引入一有趣的例子。Jazz Band 模式，跟 “敏捷的开发模式” 类似，同样也可以产生优秀的作品。( 演奏中，Miles Davis 先用小号吹出主题 ( 类比为架构师 )，然之后到一旁抽烟。曲目交由其他人员即兴发挥。最后， Miles Davis 加入演奏，回应主题 )。</p><p>感兴趣的可以观看视频：<a href="http://v-wb.youku.com/v_show/id_XMTUzNzUxOTEwNA==.html" target="_blank" rel="noopener">Miles Davis So What</a> </p></div><ul><li>学习目标<ul><li>理解敏捷软件开发方法的基本原理、核心内涵，以及它与计划驱动软件开发方法的差别；</li><li>极限编程；</li><li>理解敏捷项目管理的 <code>Scrum</code> 方法；</li><li>应用伸缩的敏捷方法时的事项和问题 -&gt; 大型软件系统开发过程.</li></ul></li></ul><h3 id="敏捷方法"><a href="#敏捷方法" class="headerlink" title="敏捷方法"></a>敏捷方法</h3><ul><li>敏捷方法是一种专注于快速开发的 <code>增量式开发</code>，<code>频繁地发布软件</code>、<code>降低过程开销</code>、生产高质量代码。他们使用户直接参与到开发过程中。</li><li><p>敏捷方法的基本原理体现在 <code>敏捷宣言</code> 中：</p><ul><li>个体和交互胜过工具和过程；</li><li>编写软件胜过书写详尽文档；</li><li>用户合作胜过合同谈判；</li><li><p>响应变更更胜过遵循计划.</p><blockquote><p>即我们更重视左边的项的价值，虽左右两边的项都有价值。</p></blockquote></li></ul></li><li><p>大量的软件工程努力维护和进化现有的软件系统，而由敏捷方法的特性可知，敏捷方法维护的问题有：</p><ul><li>软件交付后的主要困难可能是继续让用户参与到过程中。</li><li>保持开发团队的持续性，因没有参考文档可循，若一个敏捷开发团队解散了，则 <code>依赖于团队成员理解系统</code> 的 <code>隐式知识</code> 旧丢失了。</li></ul></li><li>混成方法：敏捷方法嵌入来自计划计划驱动式开发的某些技术。</li></ul><h3 id="计划驱动开发和敏捷开发"><a href="#计划驱动开发和敏捷开发" class="headerlink" title="计划驱动开发和敏捷开发"></a>计划驱动开发和敏捷开发</h3><p>计划驱动和敏捷描述如图 2-1 所示。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_2-1.png" alt="图2-1计划驱动和敏捷描述"></p><center>图 2-1 计划驱动和敏捷描述</center><ul><li>敏捷方法：<ul><li>迭代发生在所有活动间。</li></ul></li><li><p>计划驱动方法：</p><ul><li><p>迭代发生在各个活动中，用 <code>正式文件</code> 在软件过程中各阶段间沟通。</p><blockquote><p><code>正式文件</code>：可视化作为各阶段的输出产物。</p></blockquote></li></ul></li><li>在计划驱动和敏捷方法之间得到平衡，必须回答以下一些技术的、人员的和机构方面的问题。<ul><li>详尽的描述和设计 -&gt; <code>计划驱动开发</code></li><li>交互用户并快速取得反馈 -&gt; <code>敏捷开发</code></li><li>开发系统的规模；</li><li>开发的系统类型，如有复杂时序需求的实时系统，通常需要相当详细的设计来实现分析 -&gt; <code>计划驱动开发</code></li><li>预想的系统寿命有多长；</li><li>什么样的技术支持系统开发 (敏捷方法通常依赖于工具，以跟踪设计进化)；</li><li>开发团队的组织情况；</li><li>影响系统开发的文化问题 (传统的工程机构有计划驱动的文化)；</li><li>开发团队的成员专业水平；</li><li>系统是否受制于外部法规 (如联邦的航空管理局 FAA 核准一个安全性要求极高的航空操作软件)；</li></ul></li></ul><h3 id="极限编程-XP"><a href="#极限编程-XP" class="headerlink" title="极限编程 (XP)"></a>极限编程 (XP)</h3><ul><li>极限编程所属敏捷方法，它集成了一系列好的编程经验。例如，频繁地软件发布、连续软件改善和客户参与到软件开发团队。</li><li>XP 中，所有的需求都表示为脚本 (称为用户故事情节)，它将直接实现为一系列任务。</li><li>一个 XP 过程，产生了正在开发的系统的一个增量，具体如图 2-2 所示。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_2-2.png" alt="图2-2极限编程的版本循环"></p><center>图 2-2 极限编程的版本循环</center><ul><li>脚本卡是 XP 规划过程的主要输入。<ul><li>开发团队把每个 <code>脚本</code> 拆分成 <code>任务</code>，并估计实现所需人力资源。</li><li>与客户交谈，定义需求，对脚本进行优先权排序。</li></ul></li></ul><h4 id="极限编程中的测试"><a href="#极限编程中的测试" class="headerlink" title="极限编程中的测试"></a>极限编程中的测试</h4><ul><li>很多增量开发方法的测试过程是很不规范的。</li><li>为避免一些测试和系统验证方面的问题，XP 方法更加强调测试过程。</li><li>XP 当中测试的关键特性：<ul><li>测试优先的开发 (先写测试程序再写代码)；</li><li>来自脚本的增量式测试开发；</li><li>用户参与测试开发和有效性验证；</li><li>自动测试系统的使用。将测试写成了可执行的组件，该测试组件是独立的。自动测试框架即是这样的一个系统。譬如 Eclipse 的 JUnit，JUnit 用于单元测试。</li></ul></li></ul><h4 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h4><p>结对编程是有一些质量效益，但却不足以抵消它的开销。但信息共享在结对编程是很重要的，因为当有团队成员离开时，它降低了项目风险。</p><h3 id="敏捷项目管理"><a href="#敏捷项目管理" class="headerlink" title="敏捷项目管理"></a>敏捷项目管理</h3><ul><li>项目管理的标准：计划驱动。</li><li><p>适合增量开发 (敏捷方法) 的管理方法 (框架)：<code>Scrum</code>。</p><ul><li><p>Scrum 的管理过程如图 2-3 所示。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_2-3.png" alt="图2-3Scrum的管理过程"></p><center>图 2-3 Scrum 的管理过程</center></li><li><p>Scrum 的 3 个阶段</p><ul><li>规划纲要阶段：建立大致的项目目标和设计软件体系结构。</li><li>冲刺循环阶段：<ul><li>每个循环开发出一个系统增量；</li><li>每个循环为一个计划单元，其中的工作有评估、特征选择和开发、软件实现；</li></ul></li><li>项目结束阶段：完善文档，如系统帮助和用户手册。</li><li><p>冲刺循环阶段的特征：</p><ul><li>冲刺有固定长度，一般是 2-4 周，在 XP 过程中对对应与一个系统版本的开发。</li><li>规划的起点，即积压的任务 (Backlog)，也是项目中要完成的工作清单。</li><li>评估阶段：Backlog 需经过审查，并对它们进行优先级排序和风险指派。</li><li>选择阶段：项目所有成员都要参加，和用户一起选择冲刺循环中要开发的特性和功能。</li><li>开发阶段：达成共识将组织进行软件开发，每一天团队开发成员参与段时间会议，回顾开发过程，若有必要重新安排工作。且在此阶段开发团队是隔离于客户和机构的。</li><li><p>冲刺循环阶段结束，对已做工作复查并交付给用户。</p><blockquote><p>所有交流都是通过 <code>Scrum Master</code> 进行，SM 可理解为调解人。体现了 Scrum 的思想，即整个团队被赋予决定的权利。</p></blockquote></li></ul></li></ul></li><li><p>Scrum 适合分布式的开发环境。</p></li></ul></li></ul><h3 id="可扩展的敏捷方法"><a href="#可扩展的敏捷方法" class="headerlink" title="可扩展的敏捷方法"></a>可扩展的敏捷方法</h3><ul><li>敏捷方法的开发是为同一房间办公与交流的小团队开发使用，因此常被用于小型系统开发。</li><li>可伸缩的敏捷方法也可适用于开发大型系统。</li><li>大型、小型系统开发的区别 (可理解为可扩展的敏捷方法应用于大型系统的挑战)。<ul><li>大型系统经常由独立的、交互的子系统组成。不同团队独立开发不同子系统，且团队可能在不同地点或不同时区工作。</li><li>大型系统包含了一系列的已存在的系统并与它们进行交互，许多系统需求关注这种交互。</li><li>当一个系统由多个系统集成产生时，开发工作中重要部分是系统配置而不是原始代码开发。这不一定与增量式开发和频繁的系统集成兼容。</li><li>大型系统通常具有不同的信息持有者，将不同的信息持有者加入开发流程中是必要的。</li></ul></li><li>伸缩的敏捷方法的两个观点<ul><li>照搬放大，即关注如何将这些方法应用到哪些 <code>小团队</code> 无法开发的 <code>大型项目</code> 中。</li><li>渗透，即关注如何将敏捷方法介绍 <code>推广</code> 到拥有多年开发经验的 <code>大机构</code> 中。</li></ul></li></ul><h2 id="叁-需求工程"><a href="#叁-需求工程" class="headerlink" title="叁 需求工程"></a>叁 需求工程</h2><ul><li><p>学习目标</p><ul><li>了解用户需求、系统需求；</li><li>了解功能需求、非功能需求；</li><li>如何在软件需求文档中 <code>机构需求</code>；</li><li>了解需求工程活动的内容及他们之间的关系；</li><li>了解需求管理.</li></ul></li><li><p>一些概念</p><ul><li><p>用户需求：用自然语言加图的形式给出的关于系统 <code>需要提供</code> 哪些服务及系统操作受到哪些 <code>声明的约束</code>。</p><blockquote><p>高层 (抽象) 的概要需求。</p></blockquote></li><li><p>系统需求：详细给出系统 <code>将要提供</code> 的服务及系统所受到的约束。系统的需求文档也称功能描述。</p><blockquote><p>系统应提供哪些服务的详细描述。</p></blockquote></li></ul></li></ul><h3 id="功能需求与非功能需求"><a href="#功能需求与非功能需求" class="headerlink" title="功能需求与非功能需求"></a>功能需求与非功能需求</h3><ul><li>功能需求<ul><li>描述系统所提供的功能或服务。</li><li>若是用户需求，就要用可以被系统用户理解的一种抽象方法描述功能需求。</li><li>更具体的功能性系统需求则需要详细地描述系统功能、异常、输入和输出。</li></ul></li><li><p>非功能需求</p><ul><li>指那些不直接关系到系统向用户提供的具体服务的一类需求。简言之，他们对 <code>系统实现</code> 定义了 <code>约束</code>，如 I/O 设备的能力、与其他系统接口的数据的表示。</li><li><p>非功能性系统需求：通常会从总体上规范或约束系统的特性。</p><blockquote><p>若一个非功能系统需求没有满足则可能使整个系统无法使用。</p></blockquote></li><li><p>非功能需求分类：表明非功能需求或是来源于所要求的软件特性 (产品需求)，或是来源于开发软件的机构 (机构需求)，或是来源于外部来源。如图 3-1 所示。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_3-1.png" alt="图3-1非功能需求的类型"></p><center>图 3-1 非功能需求的类型</center></li></ul></li></ul><h3 id="软件需求文档"><a href="#软件需求文档" class="headerlink" title="软件需求文档"></a>软件需求文档</h3><ul><li>如表 3-1 所示，是基于 IEEE 标准的需求文档的结构。<ul><li>需求文档中内容的详细程序，取决于所要开发的系统的类型及所使用的开发过程。</li></ul></li></ul><center>表 3-1 需求文档结构</center><div class="table-container"><table><thead><tr><th style="text-align:left">章节</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">绪言</td><td style="text-align:left">定义文档的读者对象，说明版本的修正历史，包括新版本为什么要创建，每个版本间的变更内容的概要</td></tr><tr><td style="text-align:left">引言</td><td style="text-align:left">描述为什么需要该系统，简要描述系统的功能，解释系统是如何与其他系统协同工作的。描述该系统在机构总体业务目标和战略目标中的位置和作用</td></tr><tr><td style="text-align:left">术语</td><td style="text-align:left">定义文档中的技术术语和词汇。假设文档读者是不具有专业知识和经验的人</td></tr><tr><td style="text-align:left">用户需求定义</td><td style="text-align:left">这一部分要描述系统应该提供的服务以及非功能系统需求，该描述可以使用自然语言、图表或者其他各种客户能理解的标记系统。产品和过程必须遵循的标准也要在此定义</td></tr><tr><td style="text-align:left">系统体系结构</td><td style="text-align:left">这一部分要对待建系统给出体系结构框架，该体系结构要给出功能在各个模块中的分布。能被复用的结构中组件要用醒目方式示意出来</td></tr><tr><td style="text-align:left">系统需求描述</td><td style="text-align:left">这一部分要对功能和非功能需求进行详细描述。如有必要，对非功能需求要再进一步描述，例如定义与其他系统间的接口</td></tr><tr><td style="text-align:left">系统模型</td><td style="text-align:left">这一部分要提出一个或多个系统模型，以表达系统组件、系统以及系统环境之间的关系。这些模型可以是对象模型、数据流模型和语义数据模型</td></tr><tr><td style="text-align:left">系统进化</td><td style="text-align:left">这一部分要描述系统基于的基本设想和定位以及硬件和用户需求改变时所要做的改变。这部分对系统设计人员来说是有用的，因为这有助于他们避免一些设计决策，这些决策可能会限制未来系统的变更</td></tr><tr><td style="text-align:left">附录</td><td style="text-align:left">这一部分要提供与开发的应用有关的详细、专门的信息。该附录的例子是硬件和数据库的描述，硬件需求定义了系统最小和最优配置，数据库需求定义了系统所用的数据的逻辑结构和数据之间的关系</td></tr><tr><td style="text-align:left">索引</td><td style="text-align:left">可以包括文档的几个索引。除了标准的字母顺序索引外，还可以有图标索引、功能索引等</td></tr></tbody></table></div><h3 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h3><ul><li>即在需求文档中写下用户需求和系统需求。<ul><li>用户需求：从用户角度来描述系统功能需求和非功能需求，一般用自然语言、图形叙述。</li><li>系统需求：<ul><li>用户需求的扩展；</li><li>软件工程师开始系统设计的起点；</li><li>解释如何能让系统提供用户需求.</li></ul></li></ul></li><li><p>原则上系统需求应 <code>反描述</code> 系统的 <code>外部行为</code> 和对它的 <code>操作限制</code>，而不是描述系统如何设计、实现。</p><blockquote><p>当然，并不是不提及任何设计信息，这也是不可能的，例如系统初始的体系结构设计。</p></blockquote></li></ul><h4 id="自然语言描述"><a href="#自然语言描述" class="headerlink" title="自然语言描述"></a>自然语言描述</h4><ul><li>在使用自然语言书写需求时，为了尽力 <code>减少误解</code>，应有一些简单的指导原则：<ul><li>设计一个 <code>标准格式</code>，并保证所用的需求定义都遵循此格式书写。</li><li>使用一致性的语言来区分强制性需求和可选性需求。<ul><li>强制性需求：必须支持的，定义时使用 <code>必须</code>。</li><li>可选性需求：不是必要的，定义时使用 <code>应该</code>。</li></ul></li><li>对文本加亮 (粗体、斜体、颜色) 来突出显示关键性需求。</li><li>避免使用专业术语和缩写语 (无法避免时应该在有标注说明)。</li><li>任何情况下，都应尝试把需求原理和每一个用户需求联系起来。</li></ul></li></ul><h4 id="结构化描述"><a href="#结构化描述" class="headerlink" title="结构化描述"></a>结构化描述</h4><ul><li>使用结构化方法来描述系统需求，则先为需求定义一个或多个的 <code>标准模板</code>，并将模板表示成结构化的表格形式。如表 3-2 所示，是胰岛素泵需求的结构化描述。</li></ul><center>表 3-2 胰岛素泵需求的结构化描述</center><div class="table-container"><table><thead><tr><th style="text-align:left">项目名称</th><th style="text-align:left">胰岛素泵/控制软件/SRS/3.3.2</th></tr></thead><tbody><tr><td style="text-align:left">功能</td><td style="text-align:left">计算胰岛素剂量；安全的胰岛素水平</td></tr><tr><td style="text-align:left">描述</td><td style="text-align:left">计算所要传输的胰岛素剂量，这是在当前度量的血糖水平处于 3-7 个单位之间这样正常范围之内时的胰岛素计算</td></tr><tr><td style="text-align:left">输入</td><td style="text-align:left">当前血糖读数 (r2)，先前的两个读数 (r0, r1)</td></tr><tr><td style="text-align:left">来源</td><td style="text-align:left">来自传感器的当前血糖读数。其他读数来自内存</td></tr><tr><td style="text-align:left">输出</td><td style="text-align:left">CompDose：所要传输的胰岛素剂量</td></tr><tr><td style="text-align:left">目的地</td><td style="text-align:left">主控制循环</td></tr><tr><td style="text-align:left">行动</td><td style="text-align:left">如果血糖水平是稳定的或往下掉或是上升但速率下降，则 CompDose 为 0。若血糖的水平是在上升且上升速率也上升，那么 CompDose 的计算方法是求当前血糖水平和先前血糖水平，再除以 4 并取整。若取整的结果为 0，那么 CompDose 就被设置成可以传输的最小剂量</td></tr><tr><td style="text-align:left">需求</td><td style="text-align:left">两个先前的读数，这样血糖变化速率就可以计算出来了</td></tr><tr><td style="text-align:left">前置条件</td><td style="text-align:left">胰岛素池容纳至少是单个传输剂量的最大值</td></tr><tr><td style="text-align:left">后置条件</td><td style="text-align:left">r0 被 r1 替换，然后 r1 被 r2 替换</td></tr><tr><td style="text-align:left">副作用</td><td style="text-align:left">无</td></tr></tbody></table></div><ul><li>标准格式描述功能需求时，应包括下列信息：<ul><li>关于所定义的功能或实体的描述；</li><li>关于输入及输入来源的描述；</li><li>关于输出及输出去向的描述；</li><li>关于计算所需要的信息及系统中所使用的其他实体信息；</li><li>关于所采取的行动的描述；</li><li>如果使用一个功能方法，前置条件、后置条件的设定描述；</li><li>关于操作的副作用，没有则填写无.</li></ul></li></ul><h3 id="需求工程过程"><a href="#需求工程过程" class="headerlink" title="需求工程过程"></a>需求工程过程</h3><ul><li>需求工程过程包括4个高层活动：<ul><li>系统可行性研究：评估系统是否对业务有用。</li><li>需求导出和分析：需求发现。</li><li>需求描述：将需求转变为某种标准格式描述。</li><li>需求有效性验证：检验需求是否正确地定义了客户所希望的系统。</li></ul></li><li>在实际需求工程是一个活动相互交错的迭代过程，如图 3-2 体现了这种交错性。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_3-2.png" alt="图3-2需求工程过程的螺旋模型"></p><center>图 3-2 需求工程过程的螺旋模型</center><h3 id="需求导出和分析过程"><a href="#需求导出和分析过程" class="headerlink" title="需求导出和分析过程"></a>需求导出和分析过程</h3><ul><li>反复的过程，也可看做是一种 <code>螺旋式活动</code>。</li><li>需求发现 (需求导出)<ul><li>对准备建立的系统和正使用的系统进行信收集，并从中提取用户需求和系统需求的过程。</li><li>与 <code>信息持有者</code> 通过交谈和观察进行交互，即可使用 <code>用例</code> 和 <code>原型</code> 来帮助对方理解系统。</li></ul></li><li>采访<ul><li>封闭式采访：即信息持有者回答一组 <code>锁定的问题</code>。</li><li>开放式采访：需求工程团队 <code>即兴访问</code>，更深层次了解对方需求是什么。</li></ul></li><li>脚本<ul><li>脚本是对 <code>交互实例片段</code> 的描述。</li><li>脚本开始于一个 <code>交互框架</code>，在导出过程中细节增加，直至产生一完整的交互描述。</li><li>脚本的内容<ul><li>开始部分有一系统和用户期望的描述；</li><li>标准事件流的描述；</li><li>处理错误的描述；</li><li>完成后系统状态的描述.    </li></ul></li></ul></li><li>用例<ul><li>统一建模语言 (UML) 的基本特征。</li><li>用例的集合代表所有将会在系统需求中出现的交互。过程中的角色可为人、其他系统等。</li><li>UML 对于面向对象模型来说，是一约定俗成的标准，因此基于用例的导出被广泛应用于需求导出中。</li></ul></li><li>深入实际：如图 3-3 所示的需求分析的深入实际方法和原型法。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_3-3.png" alt="图3-3需求分析的深入实际方法和原型法"></p><center>图 3-3 需求分析的深入实际方法和原型法</center><h3 id="需求有效性验证"><a href="#需求有效性验证" class="headerlink" title="需求有效性验证"></a>需求有效性验证</h3><ul><li>有效性检查：任何一组需求都不可避免地要在不同用户之间协商。</li><li>一致性检查：需求不应该彼此冲突。</li><li>完备性检查：需求文档应包括所有系统用户想要的功能和约束。</li><li>真实性检查：检查需求以保证需求能真正实现。</li><li>可检验性检查：检查方法 -&gt; 验证需交付的系统 -&gt; 满足定义的需求。<ul><li>需求评审：主要是错误检查和不一致检查。</li><li>原型建立：提供一可执行的系统模型，客户和最终用户在此基础检查系统。</li><li>测试用例生成。</li></ul></li></ul><h3 id="需求管理"><a href="#需求管理" class="headerlink" title="需求管理"></a>需求管理</h3><ul><li>大型软件系统的需求总是在变化的，即开发这些系统需满足某些棘手问题，则这些问题不可能被完全定义。如图 3-4 所示为需求进化的过程。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_3-4.png" alt="图3-4需求进化过程"></p><center>图 3-4 需求进化过程</center><h4 id="需求管理规划"><a href="#需求管理规划" class="headerlink" title="需求管理规划"></a>需求管理规划</h4><ul><li>需求识别：每一需求有 <code>唯一标识码</code>。</li><li>变更管理过程：变更带来的影响和成本的评估活动。</li><li>可追溯策略：<code>策略</code> 定义了需求间和需求与系统设计间的 <code>关系</code>；关系是要记录的，并附有记录的 <code>维护方法</code>。</li><li><p>工具支持</p><ul><li>需求存储</li><li>变更管理：如图 3-5 所示，即变更过程由有效工具来支持。</li><li><p><code>可追溯性</code> 管理：需求间的 <code>关联</code> &lt;- 自然语言处理技术 (NLP)</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_3-5.png" alt="图3-5需求变更管理"></p><center>图 3-5 需求变更管理</center></li></ul></li></ul><h4 id="需求变更管理"><a href="#需求变更管理" class="headerlink" title="需求变更管理"></a>需求变更管理</h4><ul><li>问题分析和变更描述：问题或变更 -&gt; 检验有效性 -&gt; 反馈变更请求者 -&gt; 导致两种结果：<ul><li>更加详尽的需求变更、提议；</li><li>取消本次变更.</li></ul></li><li>变更分析和成本计算：需求文档修改、系统设计和实现的成本估算。</li><li>变更实现：与编写程序类似，文档的 <code>可追溯性</code> 即 <code>关联性</code> 是通过最小化外部引用和尽量使之模块化来实现的。</li></ul><h2 id="肆-系统建模"><a href="#肆-系统建模" class="headerlink" title="肆 系统建模"></a>肆 系统建模</h2><ul><li>学习目标<ul><li>如何用图形模型表示软件系统；</li><li>基本的建模角度 (如上下文、交互、结构、行为等)；</li><li>统一建模语言 (UML)；</li><li>模型驱动工程.</li></ul></li><li>系统建模：建立系统抽象模型的过程<ul><li>图形建模；</li><li>形式化建模 (数学模型). </li></ul></li><li>不同角度表述系统 <code>与 第陆章 中的「4+1」视图相仿</code><ul><li><code>外部</code> — 上下文模型：系统上下文；系统环境；</li><li><code>交互</code> — 交互模型：系统与环境之间；系统各组成部分之间；</li><li><code>结构</code> — 结构模型：系统的体系结构；</li><li><code>行为</code> — 行为模型：系统的动态行为和它对事件响应方式.</li></ul></li></ul><h3 id="上下文模型"><a href="#上下文模型" class="headerlink" title="上下文模型"></a>上下文模型</h3><ul><li>定义系统边界：定义系统上下文和系统与环境之间的依赖关系。</li><li>上下文模型表示某一环境包括几个其他的自动系统 (忽略子系统之间及待描述的系统与它们之间的关联关系的类型)。</li><li><p>结合业务过程模型 </p><ul><li><p>活动图：如图 4-1 所示。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-1.png" alt="图4-1活动图"></p><center>图 4-1 活动图</center></li></ul></li></ul><h3 id="交互模型"><a href="#交互模型" class="headerlink" title="交互模型"></a>交互模型</h3><ul><li>为用户交互建模 -&gt; 识别用户需求。</li><li>为系统各部分之间的交互建模 -&gt; 系统结构能否实现系统所需的功能及其可靠性。</li></ul><h4 id="用例建模"><a href="#用例建模" class="headerlink" title="用例建模"></a>用例建模</h4><ul><li>用例图：如图 4-2 所示。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-2.png" alt="图4-2用例图"><br>    <center>图 4-2 用例图</center></p><ul><li>时序图：表示在特定用例中的交互发生顺序。如图 4-3 所示。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-3.png" alt="图4-3时序图"><br>    <center>图 4-3 时序图</center></p><h3 id="结构模型"><a href="#结构模型" class="headerlink" title="结构模型"></a>结构模型</h3><blockquote><p>课本第 6、18、19 章讲述软件体系结构的不同方面和软件体系结构建模。</p></blockquote><ul><li>静态模型：表示系统设计的结构。</li><li>动态模型：表示系统执行时的构成。</li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><ul><li><p>类图可表示系统中的类和这些类之间的关联。</p><blockquote><p>类与类之间的链接，表示类与类之间具有某种关系。</p></blockquote><ul><li><p>简单类图：如图 4-4 所示。其中一对多关系的类图，类似于语义数据模型，即数据实体、与他们相关的属性。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-4.png" alt="图4-4简单类图"></p><center>图 4-4 简单类图</center></li><li><p>扩展类图：如图 4-5 所示。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-5.png" alt="图4-5扩展类图"></p><center>图 4-5 扩展类图</center></li></ul></li></ul><h4 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h4><ul><li>推断一些类的成员具有的某些共同特征，针对类的所有成员给出一般性的描述。如图 4-6 所示。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-6.png" alt="图4-6泛化关系"></p><center>图 4-6 泛化关系</center><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><ul><li>一个对象 (全体) 可有由其他对象 (部分) 组成。如表示一条病人记录由 Patient 和一个不确定的 Consulation 组成。如图 4-7 所示，表示了一条病人记录由 Patient 和一个不确定的 Consulation 组成。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-7.png" alt="图4-7聚合关系"></p><center>图 4-7 聚合关系</center><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>如图 4-8 所示，展示了依赖关系。</p><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-8.png" alt="图4-8依赖关系"></p><center>图 4-8 依赖关系</center><h3 id="行为模型"><a href="#行为模型" class="headerlink" title="行为模型"></a>行为模型</h3><ul><li>描述系统运行时的动态行为的模型，表示系统响应于所处环境的刺激所发生或可能发生的事情。</li><li>刺激：<code>数据</code>、<code>事件</code><ul><li>数据：一些数据到达必须由系统处理。</li><li>事件：某些触发系统处理的事件的发生。</li></ul></li></ul><h4 id="数据驱动的建模"><a href="#数据驱动的建模" class="headerlink" title="数据驱动的建模"></a>数据驱动的建模</h4><ul><li><p>数据驱动模型描述一个 <code>动作序列</code>，该动作序列涉及输入数据的处理和相关 <code>输出的产生</code>。</p><blockquote><p><code>输出的产生</code>：指系统的响应。</p></blockquote></li><li><p>处理序列的方法：</p><ul><li><code>时序图</code>：强调系统中的对象。</li><li><code>数据流图</code> (DFD)：关注于功能。</li></ul></li></ul><h4 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h4><ul><li>事件驱动模型表示系统对内、外部事件的响应方式。</li><li>基于事件的模型表示方法：状态图，表示系统状态和引起状态和引起状态改变的事件。其中状态图的表示如图 4-9 所示。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-9.png" alt="图4-9状态图"></p><center>图 4-9 状态图</center><h3 id="模型驱动工程"><a href="#模型驱动工程" class="headerlink" title="模型驱动工程"></a>模型驱动工程</h3><ul><li>模型驱动工程 (MDE) 起源于模型驱动体系结构 (MDA)，该体系由对象管理组织 (OMG) 提出。</li><li>支持者与反对方：<ul><li><code>支持者</code>：更高的抽象水平上考虑系统，不用关心实现细节，减少出错可能性，加速设计和实现过程，且可复用。</li><li><code>反对方</code>：并不是模型所支持的抽象都是正确的、可实现的。</li></ul></li></ul><h4 id="模型驱动体系结构"><a href="#模型驱动体系结构" class="headerlink" title="模型驱动体系结构"></a>模型驱动体系结构</h4><ul><li>计算独立模型 (CIM) — <code>领域建模</code> — 不同的 CIM 反映系统的不同方面。</li><li>平台独立模型 (PIM) — 表示静态系统结构和系统对内外事件的响应。</li><li>平台特定模型 (PSM) — PIM -&gt; PSM。如图 4-10 所示，为一个复合平台特定模型实例。</li></ul><p><img src="/images/illustration/Reading/2018/05/Sofeware-Engineering_4-10.png" alt="图4-10复合平台特定模型"></p><center>图 4-10 复合平台特定模型</center><h4 id="可执行-UML：xUML"><a href="#可执行-UML：xUML" class="headerlink" title="可执行 UML：xUML"></a>可执行 UML：xUML</h4><ul><li>为建立一 UML 可执行子集，模型类型可分为：<ul><li>领域模型：识别出系统的主要关注点，由 UML 的类图定义，包括对象、属性和关联。</li><li>类模型：定义类及它们的属性和操作。</li><li>状态模型：每一状态与一个类相关联，并且用来描述类的生命周期。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;在软工系列课程上，老师常提及的一条等式  &lt;code&gt;软件 = 程序 + 软件工程&lt;/code&gt; ( 或 &lt;code&gt;软件 = 程序 + 文档&lt;/code&gt;)，即一般情况讨论，一款软件产品的诞生之际总是伴随着一系列的软件过程。&lt;/p&gt;
&lt;p&gt;那么如何充分理解软件工程 (过程)？从本书作者理念出发，我所理解的即应该时刻对软件产品持有 &lt;code&gt;生命周期&lt;/code&gt; 的思维模式，将 &lt;code&gt;需求、建模、设计、实现、测试、维护&lt;/code&gt; 等工程阶段联系起来，以自身代入案例环境中，去模拟开展软件过程的一系列活动，而非割裂。而这样的动态过程中，不仅仅是枯燥地学习理论、方法，则更像是问题所需、问题导向的理论应用过程。&lt;/p&gt;
&lt;p&gt;当然，软件工程作为一门工程学科，学习过程的最大收获可以说是对 &lt;code&gt;项目思维模式&lt;/code&gt; 的掌握。譬如，我们可以抛开软件产品的范畴，谈谈现实生活的实例：假若你需要在一定时限内掌握一门新知识、任务，则我们的做法可以从调研、计划、布局、实施，直至验收，即类似的过程可复用软件工程的方法。&lt;/p&gt;
&lt;p&gt;最后，也是想声明的一点：学习软件工程的过程中，无可避免地将反映本人的一些观点、倾向，当然这也反映该学科需要 &lt;code&gt;多沟通&lt;/code&gt; 的特点，若有不恰当、错误之处，欢迎大伙出建议、斧正。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://www.kofes.cn/categories/Reading/"/>
    
    
      <category term="软件工程" scheme="http://www.kofes.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="需求工程" scheme="http://www.kofes.cn/tags/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="系统建模" scheme="http://www.kofes.cn/tags/%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="UML" scheme="http://www.kofes.cn/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>笔记 - 一个 APP 的诞生 ( 方法论 )</title>
    <link href="http://www.kofes.cn/2018/03/Producting-An-Application.html"/>
    <id>http://www.kofes.cn/2018/03/Producting-An-Application.html</id>
    <published>2018-03-20T03:13:54.000Z</published>
    <updated>2018-05-18T11:23:27.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p><a href="https://book.douban.com/subject/26865230/" target="_blank" rel="noopener">《 一个 APP 的诞生 》</a>被定义是一本教科书、工具书，适合想通过 APP 实现自己的产品梦的受众通读，即通过本书可让你快速了解 APP 产品的整个流程，从零到一，创造 APP 产品。</p><p>而通读本书籍后，或许你、我有同样的感受，即大部分内容是以设计师的角度看待问题的。这样，若你就是设计师，或许这将助你更加透彻理解 APP 的产出过程；若你是软件工程师，也可看待成是从另一角度理解软件过程。当然，这些知识只停留在书本层面，而对实际项目而言，有出入是无法避免的，但不失它的参考价值。简言之，这样一本图文并茂、实例贴近现实且含有众多跨界元素 (设计、开发、交互、产品等) 的工具书，特别是产品这一类别的书目 (下述还有同类型的书籍推荐)，不仅让你有机会感同身受业界优秀企业的工作流程，也是自身寻求产品方法论的不二选择。</p><a id="more"></a><ul><li><p>推荐书目</p><ul><li><p>《 U一点·料 》：由阿里巴巴集团 1688.UED 团队历经多年实践之后的佳作，内容重实战、讲方法、求专业、论文化，且以 “道─术─器” 的思路为编排脉络，从设计观、思考体系、方法论上层层剖析，将零散的行业技术诀窍串成体系，对 “UED如何发展突破” 提出了自己的真知灼见。<br>贴上本书的 <a href="https://book.douban.com/subject/26594029/" target="_blank" rel="noopener">豆瓣书评</a>，供朋友评判，做出抉择。</p></li><li><p>《 设计之下 》：由搜狐新闻客户端 UED 团队共同出品的佳作，分别以交互设计、视觉设计、设计师视觉，全面讲解了用户体验设计的流程和方法。<br>贴上本书的 <a href="https://book.douban.com/subject/25817190/" target="_blank" rel="noopener">豆瓣书评</a>，供朋友评判，做出抉择。</p></li></ul></li><li>更新进程<ul><li>2018.03.25 - 完成序言；</li><li>2018.03.26 - 更新内容 ( 共 6 章 )；</li><li>2018.04.02 - 更新完毕.</li></ul></li></ul><h2 id="零-思维导图"><a href="#零-思维导图" class="headerlink" title="零 思维导图"></a>零 思维导图</h2><blockquote><p>学习思路：根据思维导图的架构，掌握知识；以及参考部分项目经验，文档归纳。</p></blockquote><ul><li>前景探索<ul><li>竞品分析<ul><li>熟悉竞品分析的流程；</li><li>明确竞品分析的每个部分包含的内容；</li><li>分析报告的输出.</li></ul></li><li>用户研究<ul><li>了解用户研究的方法及它们的定义；</li><li>用户画像<br>1) 掌握建立的流程；<br>2) 用户画像的分类，每种分类的使用方法及优缺点；<br>3) 用户画像的构成、价值.  </li></ul></li></ul></li><li>设计规范及流程<ul><li>建立设计规范的特定情况；</li><li>iOS 和 Android 规范的差别；</li><li>主要元素及作用.</li></ul></li><li>交互设计<ul><li>用户体验<ul><li>交互设计师的工作内容、状况分析及处理；</li><li>紧密联系生活.</li></ul></li><li>交互设计的基本流程<ul><li>交互设计五要素：<code>人</code>、<code>目的</code>、<code>环境</code>、<code>媒介</code>、<code>行为</code>；</li><li>基本流程.</li></ul></li></ul></li><li>视觉设计<ul><li>Ui 设计<ul><li>Ui 设计制作流程；</li><li>对未来设计趋势的了解与把握.</li></ul></li><li>图标品质的提升</li><li>界面细节设计<ul><li>栅格系统提升界面易读性与可用性；</li><li>切图标注的知识与技能；</li><li>设计资源命名及文件分类整理.</li></ul></li></ul></li><li>开发实现<ul><li>如何与产品、运营、开发配合工作<ul><li>互联网企业中产品开发实现过程；</li><li>主要工作岗位职责和工作性质，以及岗位配合的注意事项.</li></ul></li><li>发布制作完成的 APP<ul><li>发布方式</li><li>常见市场</li></ul></li></ul></li><li>线上运营<ul><li>运营的定义<ul><li>什么是运营及运营的目标；</li><li>运营手段及运营岗位.</li></ul></li><li>线上运营活动：策划线上活动流程</li><li>H5 页面和 Banner 设计</li></ul></li><li><p>服务设计</p><blockquote><p>推荐阅读 <em>This is service design thinking</em> \(^{[1]}\)</p></blockquote><ul><li>服务设计的概念</li><li>服务设计的流程</li><li>工具箱：熟悉常见服务设计工具</li></ul></li><li>跨界设计</li></ul><h2 id="壹-前景探索"><a href="#壹-前景探索" class="headerlink" title="壹 前景探索"></a>壹 前景探索</h2><h3 id="竞品分析"><a href="#竞品分析" class="headerlink" title="竞品分析"></a>竞品分析</h3><p>竞品分析，能带来的价值：</p><ul><li>企业：优势 (Strength，S) 和 劣势 (Weakness，W)</li><li>设计：User Interface</li></ul><h4 id="为什么要竞品分析"><a href="#为什么要竞品分析" class="headerlink" title="为什么要竞品分析"></a>为什么要竞品分析</h4><ul><li>知己知彼<ul><li>市场：红海 (已知的市场空间)；蓝海 (还不存在的产品)</li><li>动向：目标人群、运营策略、用户体验、用户反馈</li></ul></li><li>设计灯塔：权衡利益与设计成本的关系</li></ul><h4 id="如何做竞品分析"><a href="#如何做竞品分析" class="headerlink" title="如何做竞品分析"></a>如何做竞品分析</h4><ul><li><code>确立</code> 竞争对手<ul><li>市场目标一致；</li><li>目标用户相同；</li><li>产品功能相同、相似；</li><li>用户需求相同.</li></ul></li></ul><blockquote><p>选择优质和合适的竞品，再进行分析。如表 1-1 所示，定位于即时通信类 APP ，即所要考虑的竟品类型及竞争关系。</p></blockquote><center>表 1-1 即时通信类 APP 的竟品类型及竞争关系</center><div class="table-container"><table><thead><tr><th style="text-align:left">考虑因素</th><th style="text-align:left">主要分析对象</th><th style="text-align:left">参考分析对象</th></tr></thead><tbody><tr><td style="text-align:left">市场目标方向一致、目标用户群体大致相同、功能用户需求相似</td><td style="text-align:left">QQ、微信</td><td style="text-align:left">陌陌、JUJU</td></tr><tr><td style="text-align:left">市场目标方向不一致、功能需求互补</td><td style="text-align:left">YY、斗鱼</td><td style="text-align:left">—</td></tr></tbody></table></div><ul><li><p><code>挖掘</code> 对手信息</p><ul><li>搜集资料<ul><li>数据资料，例如：APP 下载量，市场方面数据等。</li><li>其他信息，例如：APP 新闻动态，研究报告，APP 评价等。</li></ul></li><li>搜集渠道<ul><li>公司内部资源</li><li>运营部门</li><li>搜索引擎</li></ul></li></ul></li><li><p><code>分析</code> 数据信息</p><ul><li><a href="#分析数据信息">分析数据模型</a></li><li>整合收集的信息 (企业战略、目标人群、交互设计、视觉设计、运营策略等)</li></ul></li><li><p><code>输出</code> 分析报告 — <a href="#输出分析报告">可视化输出</a></p></li></ul><h4 id="分析数据信息"><a href="#分析数据信息" class="headerlink" title="分析数据信息"></a>分析数据信息</h4><ul><li><p>分析数据模型</p><ul><li><p><code>SWOT</code> 模型，即道斯矩阵、态势分析法，经常用于企业战略制定、竞争对手分析。</p><p>详细解释见：<a href="http://wiki.mbalib.com/wiki/%E9%81%93%E6%96%AF%E7%9F%A9%E9%98%B5" target="_blank" rel="noopener">MBAlib.智库百科.SWOT分析模型</a></p><blockquote><p><code>SWOT</code> 分别代表企业的优势 (Stength)、劣势 (Weakness)、机会 (Opportunity) 和威胁 (Threats)。</p></blockquote></li><li><p>波士顿矩阵 \(^{[2,3]}\)，四象限分析法。详细解释见：<a href="http://wiki.mbalib.com/wiki/%E6%B3%A2%E5%A3%AB%E9%A1%BF%E7%9F%A9%E9%98%B5" target="_blank" rel="noopener">MBAlib.智库百科.波士顿矩阵</a></p></li><li><p>KANO 模型 \(^{[4]}\)，一种典型的定性分析模型，经常用于绩效指标分类。其定义了顾客需求的三个层次：基本型需求、期望型需求和兴奋型需求。详细解释见：<a href="http://wiki.mbalib.com/wiki/KANO%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">MBAlib.智库百科.KANO 模型</a></p></li></ul></li><li><p>关于 SWOT 分析模型</p><ul><li>SW：竞争优势指一企业超越其竞争对手的能力，这种能力有助于实现企业的主要目标 — 盈利。  </li><li>OT：不利发展趋势所形成的挑战。</li></ul></li></ul><center>表 1-2 SWOT 分析模型</center><div class="table-container"><table><thead><tr><th style="text-align:center">发展趋势 (负)</th><th style="text-align:center">条件</th><th style="text-align:center">发展趋势 (正)</th></tr></thead><tbody><tr><td style="text-align:center">劣势 (Weakness，W)</td><td style="text-align:center">企业自身自身实力与竞争对手比较</td><td style="text-align:center">优势 (Strength，S)</td></tr><tr><td style="text-align:center">威胁 (Threats，T)</td><td style="text-align:center">外部环境变化对企业可能的影响</td><td style="text-align:center">机遇 (Opportunity，O)</td></tr></tbody></table></div><blockquote><p>举例：对蚂蜂窝 APP 实行 SWOT 分析法    </p></blockquote><ul><li><code>S</code>：旅游攻略是蚂蜂窝进军移动端的拳头产品，手持海量 UGC 数据和攻略引擎技术。</li><li><code>W</code>：盈利模式单一，知识与传统 OTA 合作的佣金 + 广告模式)。</li><li><code>O</code>：OTA &amp; O2O。</li><li><p><code>T</code>：行业壁垒；变现能力还能支持技术和运营走多远？</p></li><li><p>关于波士顿矩阵：波士顿矩阵区分出4种业务组合，如表 1-3 所示。</p></li></ul><center>表 1-3 波士顿矩阵业务组合</center><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">销售增长率</th><th style="text-align:left">市场占有率</th></tr></thead><tbody><tr><td style="text-align:left">明星类产品</td><td style="text-align:left">高</td><td style="text-align:left">高</td></tr><tr><td style="text-align:left">瘦狗类产品</td><td style="text-align:left">低</td><td style="text-align:left">低</td></tr><tr><td style="text-align:left">问题类产品</td><td style="text-align:left">高</td><td style="text-align:left">低</td></tr><tr><td style="text-align:left">现金牛类产品</td><td style="text-align:left">低</td><td style="text-align:left">高</td></tr></tbody></table></div><h4 id="输出分析报告"><a href="#输出分析报告" class="headerlink" title="输出分析报告"></a>输出分析报告</h4><ul><li>竞品分析包括内容：<ul><li>市场趋势、行业现状； — <code>SWOT 分析法</code></li><li>竞品的企业愿景、APP 定位、发展策略；</li><li>目标用户，用户画像；</li><li>核心功能；</li><li>交互设计；</li><li>APP 优缺点；</li><li>运营及推广策略；</li><li>总结并建议.</li></ul></li></ul><h3 id="用户研究"><a href="#用户研究" class="headerlink" title="用户研究"></a>用户研究</h3><p>用户研究最终的输出产物之一就是用户画像，即用户研究 =&gt; 用户画像。</p><h4 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h4><ul><li>场景观察：正常的工作环境或其他产品合适的 <code>物理场景</code> 中观察用户并与其交流。</li><li>可用性测试：用户在一定场景下使用产品。由可用性工程师对 <code>用户操作过程、习惯</code> 等进行 <code>观察、记录和测量</code>，以评估产品的可用性问题。</li><li>问卷调查：用 <code>统一、严格设计的问卷</code> 收集研究对象有关的 <code>心理特征</code> 和 <code>行为数据</code> 资料。</li><li><p>访谈研究：在访问用户过程中，提示被访者对某一问题的 <code>潜在冬季、新年、态度和感情</code>。</p><blockquote><p>潜在冬季、新年、态度和感情？</p></blockquote></li><li><p>焦点小组：定性研究方法。一定的组织结构，让用户一起进行 <code>互动</code>，用以激发新的思考和想法。</p></li><li>桌面研究：对已收集信息进行调研活动，即对二手资料进行搜集、筛选，并判断问题是否已经 <code>局部解决</code> 或 <code>全部解决</code>。</li><li>专家评估：组织各领域专家运用专业方面知识和经验，通过直观归纳，对产品过去、现在及发展过程进行综合分析、研究，再作判断。</li></ul><h4 id="用户画像"><a href="#用户画像" class="headerlink" title="用户画像"></a>用户画像</h4><ul><li><p>输出用户画像的流程</p><ul><li>获取研究用户信息</li><li>细分用户群</li><li>建立并丰富用户画像</li></ul></li><li><p>建立用户画像的方法</p><ul><li><code>定性</code> 用户画像</li><li>经 <code>定量验证</code> 的 <code>定性</code> 用户画像</li><li><p><code>定量</code> 用户画像</p><blockquote><p>定性 (性质) 研究：创立理论的过程。即 <code>具体向抽象转化</code>，形成理论。通常以 <code>访谈、观察</code> 等方法收集第一手描述性资料 (归纳法)。 </p><p>定量 (度量) 研究：<code>提出理论假设</code>，使用 <code>问卷</code> 等工具收集具有数量关系的资料，对资料进行 <code>量化</code>，以 <code>数据形式</code> 验证假设。</p></blockquote></li></ul></li><li><p>定性用户画像 — <code>直接分用户群</code></p><ul><li>步骤<br>1) 定性研究访谈；<br>2) 细分用户群；<br>3) 建立细分群体的用户画像。 </li><li>定性用户画像优缺点<ul><li>优点 - 省时省力、简单、需要专业人员少。</li><li>缺点 - 缺少数据支持和验证。</li></ul></li></ul></li><li><p>经定量验证的定性用户画像 — <code>分了用户群再验证</code></p><ul><li>步骤<br>1) 定性研究访谈；<br>2) 细分用户群；<br>3) 定量验证细分群体；<br>4) 建立细分群体的用户画像。  </li><li>经定量验证的定性用户画像优缺点<ul><li>优点 - 有一定的定量验证工作，需要少量的专业人员。</li><li>缺点 - 工作量较大，成本较高。</li></ul></li></ul></li><li><p>定量用户画像 — <code>验证了再分用户群</code></p><ul><li>步骤<br>1) 定性研究；<br>2) 多个细分假设；<br>3) 通过定量收集细分数据；<br>4) 聚类分析细分用户；<br>5) 建立细分群体的用户画像。  </li><li>定量用户画像的优缺点<ul><li>优点 - 有充分的佐证、更加科学、需要大量的专业人员。</li><li>缺点 - 工作量较大，成本高。</li></ul></li></ul></li><li><p>用户画像包含以下元素：</p><ul><li>基本信息 (姓名、照片、年龄、家庭状况、收入、工作)；</li><li>典型场景；</li><li>目标和动机；</li><li>需求和痛点；</li><li><p>对 APP 的态度；</p><p>如图 1-1 以音乐沉侵爱好者为例，建立用户画像。</p></li></ul></li></ul><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_1-1.png" alt="音乐沉侵爱好者的用户画像"></p><center>图 1-1 音乐沉侵爱好者的用户画像</center><h4 id="调查问卷设计"><a href="#调查问卷设计" class="headerlink" title="调查问卷设计"></a>调查问卷设计</h4><p>设计问卷的目的是为了更好地搜集信息或者定量去验证定性研究的结果。故在问卷设计的过程中，要把握调查的目的和需求，具体可分为以下几个步骤：</p><ul><li><p>问卷设计流程</p><ul><li>确定所需要的信息<ul><li>调研目的</li><li>竞品分析文档</li><li>用户画像</li></ul></li><li>确定问题顺序：<code>先易后难</code></li><li>问卷的测试和修改<ul><li>投放预测试</li><li>问题修改</li></ul></li></ul></li><li><p>设计问卷题目</p><ul><li>用户基本信息 (年龄、爱好、APP 相关生活行为)</li><li>用户使用 APP 典型场景 (碎片化时间使用，使用频次)</li><li><p>用户的痛点与需求</p><blockquote><p>可参考书本 P27-30 的实例，全民 K 歌用户体验调研问卷。</p></blockquote></li></ul></li></ul><h2 id="贰-交互设计"><a href="#贰-交互设计" class="headerlink" title="贰 交互设计"></a>贰 交互设计</h2><h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h3><ul><li>用户体验，即站在用户角度考虑问题。</li><li>交互设计师<ul><li>核心价值：沟通</li><li>工作流程：<ul><li>对重要或者紧急设计任务进行准备、分工、安排；</li><li>写解决方案，画稿；</li><li>评审待确认的设计；</li><li>总结方案，输出结果，同步给部门；</li><li>输出设计稿，与产品、研发及时沟通；</li><li>与项目接口人沟通.</li></ul></li></ul></li></ul><h3 id="交互设计基本流程"><a href="#交互设计基本流程" class="headerlink" title="交互设计基本流程"></a>交互设计基本流程</h3><h4 id="交互五要素"><a href="#交互五要素" class="headerlink" title="交互五要素"></a>交互五要素</h4><ul><li>人 (Amber)：有记录灵感的设计师，有需求的人称之为用户。</li><li>媒介 (Tools)：用户使用的设备。</li><li>行为 (Behavior)：用户的具体操作。</li><li>目的 (Purpose)：要达到某种的效果。</li><li>环境 (Enviroment)：用户使用的设备，这里指手机。</li></ul><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_2-1.png" alt="交互设计五元素"></p><center>图 2-1 交互设计五元素</center><h4 id="如何参与一个项目"><a href="#如何参与一个项目" class="headerlink" title="如何参与一个项目"></a>如何参与一个项目</h4><p>交互设计师接到一个项目或者需求后，他们的工作流程基本按照以下流程执行，即需求分析、信息架构设计、流程图设计、原型设计、最终进入产品的可用性测试，当然需求分析阶段完成后，也可以进行可用性测试，以验证方案的可行性。图 2-2 描述了交互设计师如何参与一个项目。</p><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_2-2.png" alt="交互设计师如何参与一个项目"> </p><center>图 2-2 交互设计师如何参与一个项目</center><blockquote><p>提示：实例中，我们以便签 APP 为主题展开讨论的。</p></blockquote><ul><li><p>1) 需求分析</p><ul><li>了解需求</li><li>用户调研</li><li>需求定位：竟品分析、头脑风暴、绘制故事板、人物建模 (用户画像)、产品数据</li><li><code>实例</code>：在需求分析阶段，我们从诸多研究方法和数据中简明得出便签 APP 的产品定位：  <ul><li>产品定义<ul><li>使用人群 — <code>设计师、学设计的学生</code>  </li><li>主要功能 — <code>记录想法、分享想法</code>  </li></ul></li><li>用户需求<ul><li>使用目标 — <code>随时随地记录想法、把想法分享给同事和朋友</code>  </li><li>使用场景 — <code>商场、会议、课堂、工作、训练、作图</code>  </li><li>用户目标 — <code>操作方便快捷、耗流量少、学习成本低</code></li></ul></li></ul></li></ul></li><li><p>2) 信息架构</p><ul><li>需求收集</li><li>需求删减</li><li>定义优先级</li><li>用户任务</li><li><p><code>实例</code>：根据需求分析得到的信息，接下来便梳理架构，开始架构草图设计。如图 2-2 所示。</p><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_2-3.png" alt="信息架构图"> </p><center>图 2-3 信息架构图</center></li></ul></li><li><p>3) 流程图</p><ul><li>操作流程</li><li>页面流</li><li>布局设计</li></ul></li><li><p>4) 原型设计</p><ul><li>交互原型</li><li>交互说明</li><li>设计规范</li><li>项目跟进</li></ul></li><li><p>5) 测试</p><ul><li>可用性测试</li><li>A/B 测试</li><li>用户反馈</li><li>产品数据</li></ul></li></ul><h4 id="需求分析的考虑因素"><a href="#需求分析的考虑因素" class="headerlink" title="需求分析的考虑因素"></a>需求分析的考虑因素</h4><p>在产品设计的整个过程中，要充分考虑商业需求和用户体验的平衡。如图 2-4 所示，展示了需求收集需要考虑的因素。</p><p>需求的删减是需求分析中很有必要的步骤，他是设计师们综合考虑各种因素，取舍得到的结果。</p><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_2-4.png" alt="信息架构图"></p><center>图 2-4 需求收集需要考虑的因素</center><h4 id="如何组织需求"><a href="#如何组织需求" class="headerlink" title="如何组织需求"></a>如何组织需求</h4><ul><li>1) 定义信息优先级<ul><li>产品定位：核心功能，意味着这些功能的优先级最高。</li><li>真实需求：区分次要需求。它们是围绕核心功能进行拓展的。</li><li>需求删减：权衡删减需求。</li></ul></li><li>2) 信息架构：深度和广度要均衡。</li></ul><h4 id="流程图设计"><a href="#流程图设计" class="headerlink" title="流程图设计"></a>流程图设计</h4><ul><li>确定信息架构</li><li>确定用户任务</li><li><p>如何完成操作</p><p>  完成任务方法即我们所说的流程，任务流程是根据用户实际操作的心理和行为来确定的。  </p><p>  [实例] 人在使用纸质版的便签的流程：  </p><ul><li>首先拿出纸和笔；</li><li>纸上记录想法；</li><li><p>粘贴醒目的地方便于查看。</p><p>在现实中使用便签的过程和在手机上使用便签的实际操作步骤基本吻合，如图 2-5 所示，展示了添加便签的流程图。</p><blockquote><p>这里的流程图设计，可以使用 C 语言程序设计中的程序流程图。</p></blockquote></li></ul></li></ul><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_2-5.png" alt="添加便签的流程图"></p><center>图 2-5 添加便签的流程图素</center><h4 id="原型设计及设计原则"><a href="#原型设计及设计原则" class="headerlink" title="原型设计及设计原则"></a>原型设计及设计原则</h4><ul><li>确立功能和逻辑后</li><li>设计草图</li><li>低保真线框图</li><li><p>高保真原型图</p><p>  图 2-6 是本人早期设计的沙漏记事 APP 的低保真线稿，强制插入了一段广告哈。而对应的高保真原型图，可参考对应的专题介绍。<a href="http://www.zcool.com.cn/work/ZMTU3NjcxMTI=.html" target="_blank" rel="noopener">「沙漏记事」APP</a></p><p>  <img src="/images/illustration/Reading/2018/03/Producting_An_Application_2-6.jpg" alt="沙漏记事APP低保真线稿"></p>  <center>图 2-6 沙漏记事 APP 低保真线稿</center></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>交互设计基本流程<ul><li>需求收集和分析</li><li>定义优先级</li><li>信息架构设计</li><li>流程设计</li><li>原型设计</li></ul></li><li>需求分析过程，要综合考虑 <code>商业</code>、<code>项目</code>、<code>用户</code> 三要素。</li></ul><h2 id="叁-视觉设计"><a href="#叁-视觉设计" class="headerlink" title="叁 视觉设计"></a>叁 视觉设计</h2><h3 id="UI-设计"><a href="#UI-设计" class="headerlink" title="UI 设计"></a>UI 设计</h3><h4 id="UI-的定义"><a href="#UI-的定义" class="headerlink" title="UI 的定义"></a>UI 的定义</h4><p>用户界面 (User Interface，UI)，系统和用户之间进行交互和信息交换的媒介，它实现信息的内部形式与人类可接受形式之间的转换。</p><h4 id="UI-设计流程"><a href="#UI-设计流程" class="headerlink" title="UI 设计流程"></a>UI 设计流程</h4><ul><li><p>具体把 UI 设计流程分为前期准备和情绪板两个阶段。</p><ul><li>1) 定义：做好定义 / 用户细分。</li><li>2) 找寻：找到同类竞品的 APP 安装并进行沉侵式体验。</li><li>3) 分析：分析竞品并学习。</li><li>4) 关键字：确定情感关键字。</li><li>5) 收集：图片素材收集，建立情绪板。</li><li>6) 分析：对情绪板进行色彩和质感分析。</li><li>7) 访谈：用户验证确定设计风格。</li><li><p>8) 完善：完善整个 APP 视觉设计。</p><blockquote><p>Step 1 ~ 4 为前期准备阶段，Step 5 ~ 8 为情绪板阶段。</p></blockquote></li></ul></li><li>做用户定义：如何定义用户在这不再重复阐述，详细见 <a href="#壹-前景探索">第一章 前景探索</a>。</li><li>找寻同类竞品 APP 使用并体验：站得高，看得远。即选择的竞品也要有足够的市场表现力。</li><li>确定情感关键字：该 APP 的视觉所要表达的情感感受。</li><li>情绪板：把每个人对情感的抽象理解成实际可定义的元素。<ul><li>关键字提炼；</li><li>建立具象图库 (具体的事实物、场景) 和抽象；</li><li>图库 (色彩质感等元素).</li></ul></li><li>对情绪板进行色彩和质感分析，即把握图片上的颜色、元素的感觉，再抽象成颜色方案。</li></ul><h3 id="图标品质提升"><a href="#图标品质提升" class="headerlink" title="图标品质提升"></a>图标品质提升</h3><h4 id="素描色彩的基础"><a href="#素描色彩的基础" class="headerlink" title="素描色彩的基础"></a>素描色彩的基础</h4><ul><li><p>素描的三大面五大调</p><ul><li>三大面：亮面，灰面，暗面。</li><li><p>五大调：亮面，灰面，明暗交界线，反光部和投影。</p><blockquote><p>在构图中，我们都是通过假设光源的方法来进行创作。</p></blockquote></li></ul></li><li><p>构图注意事项</p><ul><li>构图不能太小 (让人觉得画面不够饱满，显得小气)；</li><li>构图应注重重心平衡；</li><li>构图应注意透视的变化及比例关系.</li></ul></li><li><p>色彩的魅力</p><ul><li>色彩的冷暖：物体通过表面色彩给人温暖或凉爽的观感。</li><li>色彩的轻重：质感与色感的复合感觉。</li><li>色彩的前进性与后腿性：一般而言，暖色比冷色更富有前进的特性。</li></ul></li></ul><h4 id="一个像素也是事儿"><a href="#一个像素也是事儿" class="headerlink" title="一个像素也是事儿"></a>一个像素也是事儿</h4><ul><li><code>边缘像素</code> 的完美方案：图标变虚问题 =&gt; 没有边缘对齐，故在矢量绘图当中，需要对齐边缘，对齐像素。</li><li><code>旋转像素</code> 的完美方案：<ul><li>旋转中心点挪到任意定点，再旋转。</li><li>若是旋转并缩放，建议先旋转再缩放。</li></ul></li><li>Ai 到 Ps 的完美粘贴<ul><li>1) Ai 里选 <code>对齐像素网格</code>；</li><li>2) Ps 里建一个图标大小相同的 <code>选区</code>，再粘贴进来，粘贴时最好选择 <code>形状图层</code>，这样便于后期编辑。</li></ul></li></ul><h4 id="国际化的图标设计"><a href="#国际化的图标设计" class="headerlink" title="国际化的图标设计"></a>国际化的图标设计</h4><ul><li><p>表现形式上符合全球化潮流的设计趋势。</p><blockquote><p>这里非常容易理解，例如地铁、高铁、机场的指示标志，还有厕所指示标志等。</p></blockquote></li><li><p>动感：动效与交互的相交融。</p></li><li>质感：拟物、扁平和微质感，这里视具体情况而决定，如公司文化、应用受众、市场趋势等因素，总得来说，调研、分析工作是少不了环节。</li></ul><h3 id="界面细节提升"><a href="#界面细节提升" class="headerlink" title="界面细节提升"></a>界面细节提升</h3><h4 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h4><p>栅格系统，又称网格系统。主要以规则的网格阵列来指导和规范页面中的版面布局以及信息布局。当然，栅格系统也只是一种布局辅助工具，在实际项目中应灵活地根据需求在整体或布局合理应用，即综合 iOS 或 Android 的规范准则，总体把控每个元素与界面的协调感。</p><h4 id="资源规范"><a href="#资源规范" class="headerlink" title="资源规范"></a>资源规范</h4><ul><li><p>切图</p><ul><li>iOS：选择一这种的分辨率，即 @2x，750 x 1334 px，再输出 @3x，@4x。当然，你的设计稿是基于 <code>矢量工具</code> 绘制的。</li><li><p>Android：MDPI (160 DPI)，HDPI (240 DPI)，XHDPI (320 DPI), XXHDPI (480DPI)，或更多。</p><blockquote><p>1) 关于切图适配的问题，除了上述的原始办法外，现有很多插件、工具可帮你完成此项工作了。<br>2) 一套切图尽可能适配 iOS 与 Android，即找准 @ 与 DPI 的大小关系即可。</p></blockquote></li><li><p>在标注文档中，可采用 <code>物理像素单位</code> 描述元素的大小、布局的位置和间距留白的大小。<br>这样做的好处是，<strong>开发人员直接设置参数，设计人员按照切图的倍率输出切图</strong> (@2x、@3x、@4x)。</p></li><li><p>特别地，切图是以偶数倍放大的，便于缩放，设计元素的大小注意使用偶数单位即可。  </p><p>例如，标注的基准信息是 <code>14.0 DP / @1x</code>，适配对应尺寸的参数即有：<br><code>XHDPI / @2x &lt;=&gt; 28px</code>，<code>XXHDPI / @3x &lt;=&gt; 42px</code>，<code>@4x &lt;=&gt; 56px</code>。</p></li></ul></li><li><p>.9.PNG</p><ul><li>最外围的一圈像素，必须限定是 <code>1px</code> 大小，必须是纯黑色 <code>#000000</code>，任何参杂都不行。</li><li><p>文件名后缀必须是 <code>*.9.PNG</code>。</p><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_3-1.png" alt=".9.PNG使用演示图"></p><center>图 3-1 .9.PNG使用演示图</center></li></ul></li><li><p>压缩切图：在 Photoshop 中，输出方式为 <code>存储为 web 所用格式</code>；在 Sketch 中使用 <code>导出功能</code> 导出图片；其他工具可自行查阅资料，这里就不一一列举了。</p></li><li><p>标注</p><ul><li>常用的标注软件：<code>Markman</code>、PxCook、Assistor PS。</li><li>若公司、团队有规范的设计、开发手册，则请按照规范标准进行设计。</li><li><p>拥有自己的一套标注文档 (迎合大众的，容易理解的)。</p><p>对于一界面来说，图片、图标、框架、文字等元素，是必不可少的。若是为了更高程度的还原，那么详细的标注描述、文字说明、交互说明是必要的。在一般情况下，很多朋友为了便捷 (偷懒) 会在同一界面一次性把上述工作都堆积在一起完成，而这样带来的问题就是 <code>糟糕的阅读体验</code>。</p><p>这里推崇一种做法 <code>分页描述法</code>。即：<br>1) 第一页，描述界面布局的信息，如间距大小、背景颜色；<br>2) 第二页，描述文字属性信息，如文字的字体、字号、颜色、布局；<br>3) 第三页，描述组件属性信息，如按钮、小图标等；<br>4) 第四页，描述界面的交互信息，按照需求，你还可以细分为每个组件的交互信息；<br>5) 以此类推…</p></li></ul></li><li><p>资源命名</p><ul><li><p><code>组件类型_模块_子功能_状态</code> 或者 <code>模块_组件类型_子功能_状态</code>；</p><blockquote><p>例如：btn_setting_logout_n.png / setting_btn_logout_n.png</p></blockquote></li><li><p>下划线相连命名，如 <code>ico_appicon_normal.png</code></p></li></ul></li><li>PSD 源文件<ul><li>以模块为单位，归类于不同文件夹中；</li><li>PSD 源文件中，有 <code>分组分层</code> 的习惯.</li></ul></li></ul><h2 id="肆-开发实现"><a href="#肆-开发实现" class="headerlink" title="肆 开发实现"></a>肆 开发实现</h2><h3 id="如何与产品、运营、开发配合"><a href="#如何与产品、运营、开发配合" class="headerlink" title="如何与产品、运营、开发配合"></a>如何与产品、运营、开发配合</h3><h4 id="互联网产品的研发流程"><a href="#互联网产品的研发流程" class="headerlink" title="互联网产品的研发流程"></a>互联网产品的研发流程</h4><ul><li>需求来了：产品经理，负责需求的策划和整理，输出产品需求文档 (Product Requirement Document，PRD)。那么产品经理的需求来自哪：<ul><li>版本规划：从无到有策划一款产品，这些功能不是一次性开发的，而是分布在若干版本中。</li><li>动态演变的产品：根据市场的反馈，调整后续的增量版本。</li><li>细节的优化：注重用户体验的优化。</li><li>适应丰富的使用场景。</li></ul></li><li>需求要评审：方案需要和开发、设计、测试、运维人员一起评审。</li><li>开始设计</li><li>开始开发</li><li>测试把关</li></ul><h4 id="与各种角色融洽相处"><a href="#与各种角色融洽相处" class="headerlink" title="与各种角色融洽相处"></a>与各种角色融洽相处</h4><p>可借助一些 <code>协作平台</code> 来规范研发流程，如需求的追加、任务分派、提交 BUG 等。相关人员通过日志、文档开展工作。</p><p><code>协作平台</code>：<a href="https://worktile.com/" target="_blank" rel="noopener">Worktile</a> 、 <a href="https://www.teambition.com/" target="_blank" rel="noopener">Teambition</a> 、<a href="http://co.youdao.com/" target="_blank" rel="noopener">有道云协作</a> 、 <a href="https://processon.com/" target="_blank" rel="noopener">ProcessOn (在线绘图)</a>  </p><p>当然，软件过程中，一款合适的团队协作工具能使事情事半功倍。特别是敏捷方法，它是非常依赖工具的。至于哪款工具更适合于你们团队，建议参考知乎的文章再作判断：<a href="https://www.zhihu.com/question/24920474" target="_blank" rel="noopener">Worktile 与 Teambition 的优劣对比？</a></p><h4 id="发布应用程序"><a href="#发布应用程序" class="headerlink" title="发布应用程序"></a>发布应用程序</h4><ul><li>灰度发布：在发布新版本时，仅针对少部分用户样本发布。灰度发布是一种常用的产品测试及质量管理工具。对于用户量大的产品，贸然发布一个新版本取代用户当前使用的版本，风险太大。因此互联网公司摸索出了一种工具，即灰度发布。</li></ul><h4 id="快速制作原型"><a href="#快速制作原型" class="headerlink" title="快速制作原型"></a>快速制作原型</h4><p>快速原型的工具有很多，推荐几款制作工具：<a href="https://modao.cc/" target="_blank" rel="noopener">墨刀</a> 、 <a href="https://www.axure.com/download" target="_blank" rel="noopener">Axure PR</a> 、 <a href="https://proto.io/" target="_blank" rel="noopener">Proto.io</a></p><h2 id="伍-线上运营"><a href="#伍-线上运营" class="headerlink" title="伍 线上运营"></a>伍 线上运营</h2><h3 id="运营的概述"><a href="#运营的概述" class="headerlink" title="运营的概述"></a>运营的概述</h3><h4 id="运营的定义"><a href="#运营的定义" class="headerlink" title="运营的定义"></a>运营的定义</h4><p>在互联网中，针对不同群体推广产品，进行内容建议，并通过数据指标优化运营手段、产品功能与体验等行为。</p><ul><li>运营三要素：产品、用户和渠道，如图 5-1 所示。</li></ul><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_5-1.png" alt="运营三要素"></p><center>图 5-1 运营三要素</center><ul><li>运营的目标：运营是以目标为导向，数据为基础的工作。一切工作都围绕着运营三要素来进行，即产品、用户和渠道。运营的目标如图 5-2 所示。</li></ul><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_5-2.png" alt="运营的目标"></p><center>图 5-2 运营的目标</center><ul><li><p>产品、运营、设计工作的关系：为了达到运营目标，运营经理需要与产品经理、设计师等配合工作，如图 5-3 所示，简单地描述了产品经理、运营经理和设计师的工作关系。</p><p>  <img src="/images/illustration/Reading/2018/03/Producting_An_Application_5-3.png" alt="产品、运营、设计工作关系图"></p>  <center>图 5-3 产品、运营、设计工作关系图</center></li></ul><h4 id="运营工作内容及岗位"><a href="#运营工作内容及岗位" class="headerlink" title="运营工作内容及岗位"></a>运营工作内容及岗位</h4><ul><li><p>典型的产品生命周期：即每个阶段的运营重点都不同。图 5-4 展示了一款产品的生命周期。</p><p>  <img src="/images/illustration/Reading/2018/03/Producting_An_Application_5-4.png" alt="产品的生命周期"></p>  <center>图 5-4 产品的生命周期</center></li><li><p>运营目标：可量化的指标</p><ul><li>拉新：为 APP 带来下载或注册，或微信公众号拉粉。<br>常用手段有：<code>搜索引擎优化</code>，<code>广告投放</code>，<code>渠道合作</code>、<code>社交媒体推广</code>。</li><li>留存：想办法留住用户。运营的方式为：<code>优化产品内容机制</code>；<code>策划活动与用户互动</code>。</li><li>促活：<ul><li>促用户更高频使用产品，增加用户黏性。可用 <code>等级设定</code>、<code>激励体系</code>、<code>积分制度</code> 等增加长期活跃性。</li><li>已流失的用户，通过 <code>站内信</code>、<code>邮件</code>、<code>短信</code> 等手段召回。</li></ul></li><li>营收：增加付费用户和提高付费用户的活跃度。</li></ul></li></ul><h4 id="运营工作方法论"><a href="#运营工作方法论" class="headerlink" title="运营工作方法论"></a>运营工作方法论</h4><ul><li>如何让运营手段更抓住人心，追根溯源就是研究人性，一款好的产品及运营，一定能迎合人性七宗罪中的其中之一。下述为 <code>利用人性</code> 的产品功能举例。<ul><li><code>色欲</code>：美女直播、陌陌、基于 LBS (基于位置的服务) 的陌生人社交。</li><li><code>虚荣</code>：游戏装备。</li><li><code>贪婪</code>：双十一折扣、抽奖、送红包。</li><li><code>懒惰</code>：一键下单、二维码。</li><li><code>窥探</code>：无秘、悄悄关注。</li><li><code>傲慢</code>：吵架营销、粉丝大战。</li></ul></li><li>数据化运营：基于数据的运营决策更可靠。<ul><li>产品数据<ul><li>用户注册：包括下载量、注册用户激活数、APP 打开数、新增注册数等；</li><li>用户留存：留存率、使用留存、购买留存等；</li><li>用户活跃：活跃用户数、注册活跃转化率、APP 启动数、访问频率、浏览时长等；</li><li>营收数据：付费用户数、付费转化率、付费金额、付费频次等；</li><li>功能数据：每日评论数、交互反馈次数 (收藏、分享、喜欢等功能)。</li></ul></li><li>用户数据：用户画像 (性别、职业、学历、年龄、地域、使用设备、操作系统、消费行为)。</li></ul></li></ul><h3 id="活动运营"><a href="#活动运营" class="headerlink" title="活动运营"></a>活动运营</h3><h4 id="什么是活动运营"><a href="#什么是活动运营" class="headerlink" title="什么是活动运营"></a>什么是活动运营</h4><ul><li>传统行业短期的活动促销，带来一定人气增长、销售额增加。</li><li>社交网络的病毒式传播，例如春晚微信摇红包、支付宝集五福等。</li></ul><h4 id="活动使用场景"><a href="#活动使用场景" class="headerlink" title="活动使用场景"></a>活动使用场景</h4><ul><li>常规活动：有针对性提高某一指标，或新功能推广。其活动形式有：签到、邀请好友、新用户福利。</li><li>节日：每个节日都有其自带的属性，利用节假日的情感共鸣。如表 5-1 所示。</li></ul><center>表 5-1 常见节日举例</center><div class="table-container"><table><thead><tr><th style="text-align:left">常见节日</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">常规节日</td><td style="text-align:left">春节、情人节、圣诞节、母亲节、劳动节</td></tr><tr><td style="text-align:left">人为创造</td><td style="text-align:left">双十一、双十二、520告白日</td></tr><tr><td style="text-align:left">店庆活动</td><td style="text-align:left">天猫店庆、周年庆</td></tr><tr><td style="text-align:left">季节变化</td><td style="text-align:left">换季清仓、节气、春夏秋冬交替</td></tr><tr><td style="text-align:left">体育赛事</td><td style="text-align:left">奥运会、欧冠、世界杯、NBA</td></tr><tr><td style="text-align:left">颁奖典礼</td><td style="text-align:left">奥斯卡、电影节</td></tr></tbody></table></div><p>每个节日都有其自带属性，例如春节会想到春运，双十一想到打折促销、中秋节想到团圆等。</p><ul><li>突发热点事件：极具话题性，短期爆发力强，能迅速传播。如表 5-2 列举了一些热点。</li></ul><center>表 5-2 热点举例</center><div class="table-container"><table><thead><tr><th style="text-align:left">热点</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">民生类</td><td style="text-align:left">与我有关的话题，生老病死的话题</td></tr><tr><td style="text-align:left">公益类</td><td style="text-align:left">环保、支教、老人、儿童、宠物</td></tr><tr><td style="text-align:left">娱乐类</td><td style="text-align:left">明星八卦、热门参与、笑话段子</td></tr><tr><td style="text-align:left">敏感话题</td><td style="text-align:left">权利、金钱、色情</td></tr><tr><td style="text-align:left">技术趋势</td><td style="text-align:left">人工智能、区块链、科技公司新品发布</td></tr></tbody></table></div><p>例如，肌萎缩侧索硬化症引发的冰桶挑战，达到的效果有：微博话题阅读超 7 亿，捐款总额达 137 万元。</p><h4 id="如何策划线上活动"><a href="#如何策划线上活动" class="headerlink" title="如何策划线上活动"></a>如何策划线上活动</h4><p>策划线上活动共四阶段，即准备阶段、策划阶段、执行阶段和总结阶段。</p><ul><li><code>准备阶段</code>：活动前的准备<ul><li>活动需求：目的、人群、平台、机会点 (借势发挥，如世界杯)</li><li>活动目的：量化为数据指标，核心目标为推广品牌、拉新用户、促进消费、提升用户活跃度。</li></ul></li><li><p><code>策划阶段</code>：活动方案策划</p><ul><li>明确活动的时间、内容、规范、文案、流程；</li><li><p>确认奖品及协调推广资源；</p><p>[注意] 策划方案时应：<br>1) 流程简单，文案清晰；<br>2) 吸引力，例如奖励等手段；<br>3) 适时反馈，精神激励。例如动态显示参与人数、突出用户收益、获奖用户轮播。</p></li></ul></li><li><code>执行阶段</code>：活动上线后做好三点<ul><li>客服跟进：解决用户疑难，平息用户情绪。</li><li>监控数据：随时调整，保证活动质量和预期。</li><li>分布活动结果和活动善后 (<code>不要让用户感到被欺骗</code>)。</li></ul></li><li><code>总结阶段</code><ul><li>用户参与情况和数据，用以判断是否达到目标。</li><li>总结活动经验，提炼亮点和失误点，为下次活动做准备。</li></ul></li></ul><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><p>以 “新浪微博愚人节刮奖” 活动为例。</p><ul><li>活动类型：游戏</li><li>活动目标：提升用户活跃度</li><li>活动时间：愚人节，七天活动</li><li>目标人群及切入需求：针对老用户 -&gt; <code>逐利心理</code></li><li>平台：手机</li><li>交互方式：模拟真实的刮奖操作</li><li>规则判定<ul><li>每天每个用户可参与 5 次 刮刮卡活动，第一次免费。</li><li>完成某些指定任务可获得更多抽奖活动。</li></ul></li><li>奖品设置<ul><li>根据预算控制奖品数量和中奖概率。</li><li>头奖要吸引眼球，配合普通奖品，<code>增加用户获奖信心</code>。</li></ul></li><li>文案与视觉设计<ul><li>标题醒目，规则明确，页面简洁。</li><li>结合活动主题渲染气氛。</li></ul></li><li>活动指标：参与人数，传播度 (分享数)，任务完成度，活动期间的活跃用户数。</li></ul><h3 id="H5-与-Banner-的设计"><a href="#H5-与-Banner-的设计" class="headerlink" title="H5 与 Banner 的设计"></a>H5 与 Banner 的设计</h3><h4 id="H5-表现形式"><a href="#H5-表现形式" class="headerlink" title="H5 表现形式"></a>H5 表现形式</h4><p>H5，即第五代 HTML，也泛指利用 HTML5 语言制作的页面。在开始设计前，先了解 H5 专题页的类型。</p><ul><li>按功能形式分：如图 5-5 所示。</li></ul><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_5-5.png" alt="按功能形式分的H5"></p><center>图 5-5 按功能形式分的 H5</center><ul><li>按目标分：如图 5-6 所示。</li></ul><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_5-6.png" alt="按目标分的H5"></p><center>图 5-6 按目标分的 H5</center><ul><li><p>在确定了专题页的功能与目标后，接下来的设计阶段尤为关键。即可从用户角度出发，思考用户的分享动机 (共六种情况)。</p><ul><li>利益相关：<code>有奖形式</code> 促进用户分享。</li><li>有所收获：通过传播内容，学习自己感兴趣的知识，或 <code>自我提升</code>。</li><li>身份认同：内容使某一类型人产生身份认同和归属感。</li><li>成就吸引：朋友间竞技，满足用户 <code>炫耀心理需求</code>。</li><li>情感共鸣：<code>情感共鸣</code>，从而产生集体回忆的分享冲动。</li><li>借助热点：借助 <code>当前热点</code>，吸引用户眼球。</li></ul></li><li><p>H5 页面表现形式</p><ul><li>展示型：支付宝十年账单、微信故事。</li><li>互动型：智能招聘的职场神曲 DIY。</li><li>产品型：微信公众号里的微商城，如京东。</li></ul></li></ul><h4 id="Banner"><a href="#Banner" class="headerlink" title="Banner"></a>Banner</h4><p>投放于线上 (PC端、移动端) 的各种尺寸和形状的广告图。</p><ul><li>设计流程<ul><li>了解目的，定义信息优先级；</li><li>确定文案，确定设计方向；</li><li>视觉设计排版，讨论修改.</li></ul></li><li>搭配方式 =&gt; 输出 Banner<ul><li>内容专题：文案 + 主体物或文案 + 背景形式。<code>P238</code></li><li>电商：文案 + 主体物 + 背景形式。<code>P239</code></li><li>活动：文案 + 主体物 + 引导 Button + 背景 + 引导 Button 的形式。<code>P240 ~ 241</code></li></ul></li></ul><h2 id="陆-服务设计"><a href="#陆-服务设计" class="headerlink" title="陆 服务设计"></a>陆 服务设计</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="服务设计的定义"><a href="#服务设计的定义" class="headerlink" title="服务设计的定义"></a>服务设计的定义</h4><p>一种新兴领域，主要关注通过 <code>有形、无形媒介的结合方式</code> 形成细致考量过的 <code>体验设计过程</code>。它已经在实践中为各种传统下行业都带来了更优良的用户体验。</p><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><blockquote><p>本章节将围绕一个虚构的餐馆为例，姑且称他为 <code>美食与爱</code>。</p></blockquote><ul><li><p>服务提供者：除一般含义的服务人员外，还包括电子显示屏、按钮开关等实体。</p><blockquote><p>在 <code>美食与爱</code> 中，就包括侍应、收银员、厨师、后台系统等。</p></blockquote></li><li><p>利益相关者：服务提供者所属的商业实体负责人。</p><blockquote><p>餐馆老板、门店经理、收银系统的服务商。</p></blockquote></li><li><p>服务设计团队：除设计师外，还包括利益相关者、一些顾客等。</p></li><li><p>顾客：指服务提供者面向的用户、消费者等。</p></li><li><p>触点：顾客与服务提供者之间每个有接触点的点。</p><blockquote><p>门口排位服务员、侍应、菜单、桌椅。</p></blockquote></li><li><p>服务周期：前期、中期和后期。</p><p>  以就餐为例：</p><ul><li><code>前期</code> 顾客感到饥饿时，有人推荐或搜 <code>美食与爱</code>，前往餐馆就餐。</li><li><code>中期</code> 到门店后，需排位等待，收号入座，点菜，等就餐，就餐，结账。</li><li><code>后期</code> 离开餐馆，呼叫的士回家 / 公司。 </li></ul></li></ul><h4 id="五个原则"><a href="#五个原则" class="headerlink" title="五个原则"></a>五个原则</h4><ul><li>用户至上：应通过客户的视角出发来设计整套服务。</li><li>合作创新：设计师 (主持人)，利益相关者，服务提供人员，顾客。每种角色必须从自己视角出发提出想法。</li><li>先后顺序：服务是一般以 <code>时间为序</code> 的 <code>动态</code> 的过程，而每一 <code>服务片段</code> 类似电影中的帧一样，把服务结构成一个个 <code>独立触点</code> 和 <code>交互行为</code>。</li><li><p>有理有据：服务是无形的，需要用人工制品的形式“显示”出来，让其容易被感知。</p><blockquote><p>例如，酒店的清洁人员在客人不在时打扫卫生。</p></blockquote></li><li><p>全局视觉：涉及的角色、触点众多，具备全局视觉，以统筹好各个环节。</p></li></ul><h3 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h3><p>以下介绍服务设计的基本流程，即 <code>探索</code> =&gt; <code>创造</code> =&gt; <code>反思</code> =&gt; <code>实施</code>。</p><ul><li><p><code>探索</code></p><ul><li>了解公司对于设计思维的态度，是否接受服务设计这样需要合作创新的设计流程。</li><li>找服务设计要解决的本质问题 (问题往往是公司自身的，或是从公司角度提出的)。</li><li><p>找出问题本质所在。</p><blockquote><p>从 <code>潜在顾客</code> 和 <code>顾客</code> 的角度出发，理解他们当时的处境以及做出对应行为背后的真实动机。</p></blockquote></li><li><p>设计师要把研究后的发现和现有服务流程可视化方法展现出来。</p></li></ul></li><li><p><code>创造</code>：产生解决方案的阶段</p><ul><li>服务设计的最大特点：鼓励各种试错，而不是避免出错。</li><li><p>阶段任务：</p><ul><li>基于探索阶段发现的核心问题；</li><li>基于顾客需求；</li><li>基于服务提供者本身诉求等约束条件；</li><li><p>基于用户旅程图的一系列的触点.</p><blockquote><p>设计新的方案，并不断加以迭代验证、优化方案。</p></blockquote></li></ul></li></ul></li><li><code>反思</code>：创新阶段产生新方案后，这个阶段要进行测试验证。<ul><li>产品原型 (人机交互 Demo / 实体产品小样)，找顾客或者专家进行测试评估，然后不断改进以达到预期目标。</li><li>服务原型：通过 <code>角色扮演</code> 等 <code>互动沉侵</code> 的方式，让顾客与服务之间产生 <code>真实的交互</code> 以及 <code>情感上的沟通</code>。</li></ul></li><li><code>实施</code>：工具 — <code>服务蓝图</code></li></ul><h3 id="工具箱"><a href="#工具箱" class="headerlink" title="工具箱"></a>工具箱</h3><p>在 <em>This is service design thinking</em> \(^{[1]}\) 中，列举了 24 种服务设计的工具，下述选择了其中三款常用工具进行阐述，即 <code>影子跟随法</code>、<code>顾客旅程图</code>、<code>服务蓝图</code>，若对此模块有兴趣可查阅原书学习。</p><h4 id="影子跟随法"><a href="#影子跟随法" class="headerlink" title="影子跟随法"></a>影子跟随法</h4><ul><li><p>概念：研究人员或设计师把自己融入到顾客的，前后台人员的日常生活或工作中去，像 <code>影子</code> 一样跟着他们去观察他们一举一动。</p><blockquote><p>该方法可以真正做到从全局或者 <code>上帝视觉</code> 审视整个服务运作方式。</p></blockquote></li></ul><h4 id="顾客旅程图"><a href="#顾客旅程图" class="headerlink" title="顾客旅程图"></a>顾客旅程图</h4><ul><li>概念：用 <code>顾客</code> 与 <code>服务</code> 之间产生互动的一个个 <code>触点</code> 来构成用户完整旅程的 <code>地图</code>。即这个图是从顾客的视角表达出所有与服务之间互动的行为以及由于互动而产生的情感。</li><li><p>如何绘制顾客旅程图</p><ul><li>1) 需要找到顾客与服务之间所有互动的行为触点。</li><li>2) 当所有行为触点找出后，按时序的方式进行罗列以形成完整的体验流程。</li><li>3) 然后通过访谈或利用顾客自己的描述和记录，以顾客口吻表达出他们每个步骤的心理活动，对应某种情绪，打分以形成情绪曲线图。</li><li><p>4) 分析旅程图中情绪分值较低部分 (尤其是 <code>谷底</code> 时)，找出问题所在，往往当中存在不错创新设计机会点。</p><p>如图 6-1 所示，为餐馆就餐的典型顾客旅程图。</p></li></ul></li></ul><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_6-1.png" alt="餐馆就餐的典型顾客旅程图"></p><center>图 6-1 餐馆就餐的典型顾客旅程图</center><h4 id="服务蓝图"><a href="#服务蓝图" class="headerlink" title="服务蓝图"></a>服务蓝图</h4><blockquote><p>服务蓝图，类似建筑设计的蓝图。</p></blockquote><ul><li>从全局的视觉详细地设计服务体系里包含的所有对象、交互、触点等的图形化语言。</li><li>该图包含多种角色：用户、服务提供者，涉及服务流程相关者，触点及后台流程。</li><li><p>服务蓝图绘制方法： </p><ul><li>首先按时序把 <code>用户新的行为</code> (设计后的行为) 从左到右罗列出来。并从服务的前中后阶段 (如就餐前、就餐时、就餐后) 对其进行分类。</li><li>在行为 <code>上一行</code>，列出用户行为所接触的物理触点或环境。</li><li>在行为 <code>下一行</code>，列出用户交互的服务提供者。</li><li><p>在行为 <code>下两行</code>，是后台服务提供者以及提供的支援流程。</p><p>如图 6-2 所示，针对餐馆优化后的服务蓝图。</p></li></ul></li></ul><p><img src="/images/illustration/Reading/2018/03/Producting_An_Application_6-2.png" alt="针对餐馆优化后的服务蓝图"></p><center>图 6-2 针对餐馆优化后的服务蓝图</center><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/5397784/" target="_blank" rel="noopener">[1] Schneider, Jakob. This is service design thinking [M]. Canada: BIS Publishers, 2011</a><br>[2] 赵晋. 波士顿矩阵分析在实际案例中的运用[J]. 中国高新技术企业,2008,(8).<br>[3] 张镜天. 波士顿矩阵在酒类营销中的运用[J]. 中国酒业. 2006,(1).<br>[4] 上海质量科学研究院. 顾客满意的测量、分析与改进[M]. 中国标准出版社,2009.10.  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26865230/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《 一个 APP 的诞生 》&lt;/a&gt;被定义是一本教科书、工具书，适合想通过 APP 实现自己的产品梦的受众通读，即通过本书可让你快速了解 APP 产品的整个流程，从零到一，创造 APP 产品。&lt;/p&gt;
&lt;p&gt;而通读本书籍后，或许你、我有同样的感受，即大部分内容是以设计师的角度看待问题的。这样，若你就是设计师，或许这将助你更加透彻理解 APP 的产出过程；若你是软件工程师，也可看待成是从另一角度理解软件过程。当然，这些知识只停留在书本层面，而对实际项目而言，有出入是无法避免的，但不失它的参考价值。简言之，这样一本图文并茂、实例贴近现实且含有众多跨界元素 (设计、开发、交互、产品等) 的工具书，特别是产品这一类别的书目 (下述还有同类型的书籍推荐)，不仅让你有机会感同身受业界优秀企业的工作流程，也是自身寻求产品方法论的不二选择。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://www.kofes.cn/categories/Reading/"/>
    
    
      <category term="APP" scheme="http://www.kofes.cn/tags/APP/"/>
    
      <category term="产品" scheme="http://www.kofes.cn/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="设计流程" scheme="http://www.kofes.cn/tags/%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B/"/>
    
      <category term="规范" scheme="http://www.kofes.cn/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
</feed>
