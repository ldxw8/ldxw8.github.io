<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kofe</title>
  
  <subtitle>Reading / Project / Paper</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kofes.cn/"/>
  <updated>2018-10-10T07:15:55.643Z</updated>
  <id>http://www.kofes.cn/</id>
  
  <author>
    <name>Kofe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>笔记 | 数据分析学习框架</title>
    <link href="http://www.kofes.cn/2018/09/data-analysis-learning-framework.html"/>
    <id>http://www.kofes.cn/2018/09/data-analysis-learning-framework.html</id>
    <published>2018-09-30T01:51:49.000Z</published>
    <updated>2018-10-10T07:15:55.643Z</updated>
    
    <content type="html"><![CDATA[<p>本笔记以秦路老师的文章「如何七周成为数据分析师」为内容框架，整合相关的论文、书籍、视频资料，输出学习笔记。主要目的是检验自己的学习效果和日常复习之需。</p><p>初入数据分析的大门，笔记大部门的知识模块以阅读原资料总结整理而得，难免有理解偏差、错误的地方，若有不正当的解释还望朋友们不吝指教！</p><a id="more"></a><h2 id="更新进度"><a href="#更新进度" class="headerlink" title="更新进度"></a>更新进度</h2><ul><li>2018.09.29：完成初稿，形成笔记的整体框架；</li><li>2018.09.30：更新「数据分析入门」章节；</li></ul><h2 id="学习框架"><a href="#学习框架" class="headerlink" title="学习框架"></a>学习框架</h2><ul><li><code>整体框架</code>：本笔记以秦路老师的文章「如何七周成为数据分析师」$^{[1]}$ 为内容框架，整合相关的论文、书籍、视频资料，输出学习笔记。</li><li><p><code>数学部分</code>：数据分析，离不开数学。关于学习资料的选择，推荐盛骤老师的《概率论与数理统计·第4版》和张宇老师的《带你学概率论与数理统计·浙大4版》。</p><blockquote><p>数学并不是自己擅长的科目，出于这样的考虑，故选择了 <code>大学教材</code> 和 <code>考研辅导书</code>，希望借以习题辅导书复习教材内容，以短时间获得最大成效比。</p></blockquote><ul><li><p>📖 | 书籍 | <a href="https://book.douban.com/subject/3165271/" target="_blank" rel="noopener">盛骤. 概率论与数理统计·第4版. 高等教育出版社</a></p></li><li><p>📖 | 书籍 | <a href="https://book.douban.com/subject/26630236/" target="_blank" rel="noopener">张宇. 带你学概率论与数理统计·浙大4版. 北京理工大学出版社</a></p></li><li><p>📺 | 视频 | <a href="https://www.bilibili.com/video/av14690558?from=search&amp;seid=2673720085936060940" target="_blank" rel="noopener">张宇. 2018 考研概率论强化课程. bilibili.com</a></p></li><li><p>📝 | 文章 | <a href="https://www.kofes.cn/2018/09/probability-and-statistics.html">Kofe | 笔记 | 概率论与数理统计</a></p></li></ul></li><li><p><code>统计部分</code>：很遗憾对此部分知识不了解，在此不具体展开探讨。但《概率论与数理统计》的数理统计部分可以预先复习。</p></li><li><p><code>数据库部分</code>：在秦路老师的文章中，数据库部分侧重 SQL ( 结构化查询语言 ) 的讲解，当然这也是操作性和实用性很强的一模块。且据以往语言学习的经历，<code>多写、多练</code> 是必不可少的阶段，SQL 也不例外，附带的练习题目中有不少经典的实例，作为入门训练材料刚好合适。</p><p>  当然，数据库的知识不仅如此，有需求的朋友可继续参阅书籍《数据库系统概念》$^{[2]}$，即以数据库工程师的角度出发，从需求到维护的流程化学习过程，整体架构上学习数据库这门学科。</p><ul><li><p>📝 | 文章 | <a href="http://www.w3school.com.cn/sql/index.asp" target="_blank" rel="noopener">W3CSchool SQL 教程 &amp; 练习题</a></p></li><li><p>📝 | 文章 | <a href="https://leetcode-cn.com/problemset/database/" target="_blank" rel="noopener">LeetCode SQL 练习题</a></p></li><li><p>📖 | 书籍 | <a href="https://book.douban.com/subject/10548379/" target="_blank" rel="noopener">Abraham Silberschatz. 数据库系统概念. 机械工业出版社</a></p></li><li><p>📖 | 书籍 | <a href="https://book.douban.com/subject/24250054/" target="_blank" rel="noopener">福达(Ben Forta). SQL 必知必会. 人民邮电出版社</a></p></li></ul></li><li><p><code>编程部分</code>：主导 Python 语言编程。由于篇幅的缘故，该部分内容请参阅另一篇博文：</p><ul><li><p>📝 | 文章 | <a href="https://www.kofes.cn/2018/09/life-is-short-we-need-python.html">Kofe | 笔记 | Python 3 入门系列教程</a></p></li><li><p>📝 | 文章 | <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰. Python 教程. 2018. liaoxuefeng.com</a></p><blockquote><p>当然，Python 的学习还可以参考廖雪峰老师的教程。</p></blockquote></li></ul></li><li><p><code>研究部分</code>：自己课题的需求，数据科学方向的研究是必不可少的环节。篇幅原因，则细节在下文中展开探讨。按照惯例，为了便于知识的引用和问题的探讨，以下罗列自己所使用到的学习资料。</p><ul><li><p>🍉 | 书籍 | <a href="https://book.douban.com/subject/26708119/" target="_blank" rel="noopener">周志华. 机器学习 (西瓜书). 清华大学出版社</a></p></li><li><p>🌼 | 书籍 | <a href="https://book.douban.com/subject/27087503/" target="_blank" rel="noopener">[美] 伊恩·古德费洛. 深度学习 (花书). 人民邮电出版社</a></p></li><li><p>📺 | 视频 | <a href="https://www.bilibili.com/video/av15558220" target="_blank" rel="noopener">深度学习. 读书会分享视频集. bilibili.com</a></p><blockquote><p>视频转载自：<a href="https://www.youtube.com/playlist?list=PLsXu9MHQGs8eO64mazCnCU3bc9l25Z1ZZ" target="_blank" rel="noopener">Alena Kruchkova. Deep Learning Book Live Streams. youtube.com</a><br>若有条件科学上网的朋友，可至 Youtube 搭配在线字幕观看。</p></blockquote></li><li><p>📖 | 书籍 | <a href="https://book.douban.com/subject/10590856/" target="_blank" rel="noopener">李航. 统计学习方法. 清华大学出版社</a></p></li><li><p>📖 | 书籍 | <a href="https://book.douban.com/subject/11542972/" target="_blank" rel="noopener">[美] Jiawei Han. 数据挖掘：概念与技术 (原书第3版). 机械工业出版社</a></p></li></ul></li></ul><h2 id="数据分析入门"><a href="#数据分析入门" class="headerlink" title="数据分析入门"></a>数据分析入门</h2><h3 id="Excel：不考虑性能和数据量"><a href="#Excel：不考虑性能和数据量" class="headerlink" title="Excel：不考虑性能和数据量"></a>Excel：不考虑性能和数据量</h3><ul><li>掌握各类功能强大的函数 — <a href="https://ask.hellobi.com/blog/qinlu/5976" target="_blank" rel="noopener">常见 Excel 函数</a><ul><li>清洗处理类：trim、concatenate、replace、substitute、left/right/mid、len/lenb、find、search、text</li><li>关联匹配类：lookup、vlookup、index、match、row、column、offset</li><li>逻辑运算类：if、and、or、is系列</li><li>计算统计类：sum/sumif/sumifs、sumproduct、count/countif/countifs、max、min、rank、rand/randbetween、averagea、quartile、stdev、<code>substotal</code>、int/round</li><li>时间序列类：year、month、weekday、weeknum、day、date、now、today、<code>datedif</code></li></ul></li><li><p>Excel 常用工具 — <a href="https://ask.hellobi.com/blog/qinlu/5977" target="_blank" rel="noopener">数据分析：Excel 技巧大揭秘</a></p><ul><li><p><code>格式转换</code>：自定义格式规范时间。</p><blockquote><p>2016/11/11 写成 yyyy/MM/dd<br>2016-11-11 23:59:59 写成 yyyy-MM-dd HH:mm:ss</p></blockquote></li><li><p><code>分列</code>：分列功能可以将某一列按照特定规则拆分，常常用来进行数据清洗。</p></li><li><p><code>数据透视表</code>：数据透视表的核心思想是聚合运算，将字段名相同的数据聚合起来，所谓数以类分。</p><blockquote><p>列和行的设置，则是按不同轴向展现数据。简单说，你想要什么结构的报表，就用什么样的拖拽方式。</p></blockquote></li><li><p><code>删除重复项</code>：一种数据清洗和检验的快速方式。想要验证某一列有多少个唯一值，或者数据清洗，都可以使用。</p></li><li><code>自定义下拉菜单</code> (数据有效性)：数据有效性是一种约束，针对单元格限制其输入，也就是让其只能固定几个值。下拉菜单是一种高阶应用，通过允许下拉箭头即可。</li><li><code>查找公式错误</code>：公式报错也不知道错在哪里时候可以使用该功能，尤其是各类IF嵌套或者多表关联，逻辑复杂时。查找公式错误是逐步运算的，以方便定位。</li><li><code>分组和分级显示</code>：常用在报表中，在报表行数多到一定程度时，通过分组达到快速切换和隐藏的目的。</li><li><p><strong><code>分析工具库</code></strong>：分析工具库是高阶分析的利器，包含很多统计计算，检验功能等工具。Excel是默认不安装的，要安装需要加载项，在工具菜单下（不同版本安装方式会有一点小差异）。</p><blockquote><p>分析工具库是统计包，如随机数发生器、排位与百分比排位、回归、抽样、t-检验等。</p></blockquote></li></ul></li><li><p>Excel 实战教程 — <a href="https://ask.hellobi.com/blog/qinlu/5978" target="_blank" rel="noopener">数据分析：手把手教你Excel实战</a></p><ul><li>明确目的<ul><li>数据用来解决什么问题？</li><li>汇总统计制作报表？</li><li>数据可视化，作为一张信息图？</li><li>验证某一类业务假设？</li><li>提高某一个指标的KPI？</li></ul></li><li>观察数据<ul><li>数据有无缺失值<ul><li>某一字段缺失数据较多，要考虑是否删除该字段（超过 50% 即没有业务意义了）</li></ul></li><li>数据是否一致化</li><li>数据是否有脏数据：乱码，错位，重复值，未匹配数据，加密数据</li><li>数据标准结构</li></ul></li><li>数据清洗：结合 <code>观察数据</code> 阶段完成的工作，对数据进行 <code>预处理操作</code>。</li><li>分析过程<ul><li>数据透视表</li></ul></li></ul></li><li>单元格格式：数据分析师会和各种数据类型打交道，包括各类 timestamp，date，string，int，bigint，char，factor，float 等。</li><li>了解中文编码：UTF-8、GBK、ASCII 码。</li></ul><h3 id="Excel：数据可视化"><a href="#Excel：数据可视化" class="headerlink" title="Excel：数据可视化"></a>Excel：数据可视化</h3><ul><li>Excel：多种经典图表<ul><li><a href="https://ask.hellobi.com/blog/qinlu/5986" target="_blank" rel="noopener">数据可视化：你想知道的经典图表全在这</a><ul><li>散点图：表示两个变量之间的关系。后续的学习中，多次借用到散点，统计中的 <code>回归分析</code>，比如数据挖掘中的 <code>聚类</code>。</li><li>折线图：了解某一维度在时间上的规律或者趋势。</li><li>柱形图：堆积柱形图，瀑布图，横向条形图，横轴正负图。</li><li>地理图：一切和空间属性有关的分析都可以用到地理图。</li><li>饼图</li><li>雷达图：也叫蛛网图，适合用在固定的框架内表达某种已知的结果。</li><li>箱线图：它能准确地反映数据维度的离散（最大数、最小数、中位数、四分数）情况。凡是离散的数据都适用箱线图。</li><li>热力图：以高亮形式展现数据。</li><li>关系图</li><li>矩形树图：柱形图不适合表达过多类目（比如上百）的数据，那应该怎么办？矩形树图出现了，它直观地以面积表示数值，以颜色表示类目。</li><li>桑基图：常表示信息的变化和流动状态。</li><li>漏斗图</li></ul></li><li><a href="https://ask.hellobi.com/blog/qinlu/5987" target="_blank" rel="noopener">数据可视化：教你打造升职加薪的报表</a></li></ul></li><li>PowerBI：Dashboard 仪表盘，由多个图表集合成的图表仪盘 — <a href="https://ask.hellobi.com/blog/qinlu/5989" target="_blank" rel="noopener">数据可视化：手把手打造BI</a><ul><li>商业智能（Business Intelligence，BI），在传统企业中，它是一套完整的解决方案。将企业的数据有效整合，快速制作出报表以作出决策。涉及 <code>数据仓库</code>，<code>ETL</code>，<code>OLAP</code>，<code>权限控制</code> 等模块。</li></ul></li></ul><h2 id="数据分析思维"><a href="#数据分析思维" class="headerlink" title="数据分析思维"></a>数据分析思维</h2><ul><li>麦肯锡的分析思维：结构化思考，MECE原则，假设先行，关键驱动等方法论。 — <a href="https://ask.hellobi.com/blog/qinlu/6002" target="_blank" rel="noopener">快速掌握麦肯锡的分析思维</a></li><li>分析思维框架：SMART、5W2H、SWOT、4P4C、六顶思考帽等 — <a href="https://ask.hellobi.com/blog/qinlu/6003" target="_blank" rel="noopener">如何建立数据分析的思维框架</a></li></ul><h2 id="业务知识"><a href="#业务知识" class="headerlink" title="业务知识"></a>业务知识</h2><h2 id="课题研究"><a href="#课题研究" class="headerlink" title="课题研究"></a>课题研究</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://ask.hellobi.com/blog/qinlu/8930" target="_blank" rel="noopener">秦路. 如何七周成为数据分析师. hellobi.com. 2017</a></li><li>[2] <a href="https://book.douban.com/subject/10548379/" target="_blank" rel="noopener">Abraham Silberschatz. 数据库系统概念 (原书第6版) [M]. 机械工业出版社, 2012</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本笔记以秦路老师的文章「如何七周成为数据分析师」为内容框架，整合相关的论文、书籍、视频资料，输出学习笔记。主要目的是检验自己的学习效果和日常复习之需。&lt;/p&gt;
&lt;p&gt;初入数据分析的大门，笔记大部门的知识模块以阅读原资料总结整理而得，难免有理解偏差、错误的地方，若有不正当的解释还望朋友们不吝指教！&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://www.kofes.cn/categories/Reading/"/>
    
    
      <category term="数据分析" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="Excel" scheme="http://www.kofes.cn/tags/Excel/"/>
    
      <category term="Python" scheme="http://www.kofes.cn/tags/Python/"/>
    
      <category term="数据库" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>笔记 | 概率论与数理统计</title>
    <link href="http://www.kofes.cn/2018/09/probability-and-statistics.html"/>
    <id>http://www.kofes.cn/2018/09/probability-and-statistics.html</id>
    <published>2018-09-29T03:49:24.000Z</published>
    <updated>2018-10-10T07:39:59.251Z</updated>
    
    <content type="html"><![CDATA[<p>本笔记是备战考研时，跟着张宇老师的概率论课程学习整理所得。且输出本笔记的主要目的是快速构建概率的基础知识体系，以便于日后复习查阅和问题探究。或是更具体的应用场景，如 <code>机器学习</code>、<code>数据挖掘</code>、<code>经济统计</code> 等领域，概率论作为这些领域的 <code>先修课程</code>，理论基础尤为重要。由此，无论是初入门还是温故知新，学习基础学科为必经阶段，不妨选择张宇老师的概率论课程，这不失一种高效的复习方案。</p><p>当然，笔记仅是对知识点的整理和归纳，并不能代表原本知识点的严谨定义。若有更进阶的需求，还请查阅概率论相关教材，或重温课程。</p><a id="more"></a><h2 id="更新进度"><a href="#更新进度" class="headerlink" title="更新进度"></a>更新进度</h2><ul><li>2018.10.04：完成初稿，并更新「如何处理复杂事件」章节 ( 第 4 / 4 节 )；</li></ul><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul><li><p>推荐盛骤老师的《概率论与数理统计·第4版》和张宇老师的《带你学概率论与数理统计·浙大4版》。</p><blockquote><p>数学并不是自己擅长的科目，出于这样的考虑，故选择了 <code>大学教材</code> 和 <code>考研辅导书</code>，希望借以习题辅导书复习教材内容，以短时间获得最大成效比。</p></blockquote><ul><li>📖 | 书籍 | <a href="https://book.douban.com/subject/3165271/" target="_blank" rel="noopener">盛骤. 概率论与数理统计·第4版. 高等教育出版社</a></li><li>📖 | 书籍 | <a href="https://book.douban.com/subject/26630236/" target="_blank" rel="noopener">张宇. 带你学概率论与数理统计·浙大4版. 北京理工大学出版社</a></li><li>📺 | 视频 | <a href="https://www.bilibili.com/video/av14690558?from=search&amp;seid=2673720085936060940" target="_blank" rel="noopener">张宇. 2018 考研概率论强化课程. bilibili.com</a></li></ul></li></ul><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ul><li><p>以<code>张宇老师</code> 的概率论课程为框架的，围绕 <code>五大问题</code> 展开学习与探讨：在导课部分就明确了 <code>课程体系</code> 和 <code>学习目标</code>，即学习什么、学了怎么用都在浓缩于五大问题当中。</p><ul><li>如何处理复杂事件 $P(A)$；</li><li>如何求分布 $F(x)$、$F(x, y)$；</li><li>如何求数字特征 $EX$、$DX$、$Cov(x, y)$、$\rho_{x,y}$；</li><li>如何使用极限定理 ( 大样本， $n \to \infty$ );</li><li>如何做估计与评价.</li></ul></li><li><p>前 <code>四大问题</code> 主要讨论的是 <code>概率论</code> 部分的内容，<code>最后一问题</code> 则是 <code>数理统计</code> 的内容探讨。</p></li><li>事不宜迟，定下小目标，让自己赶紧行动起来！</li></ul><h2 id="壹-如何处理复杂事件"><a href="#壹-如何处理复杂事件" class="headerlink" title="壹 如何处理复杂事件"></a>壹 如何处理复杂事件</h2><h3 id="随机试验与样本空间"><a href="#随机试验与样本空间" class="headerlink" title="随机试验与样本空间"></a>随机试验与样本空间</h3><h4 id="随机试验"><a href="#随机试验" class="headerlink" title="随机试验"></a>随机试验</h4><ul><li>随机试验，记作 $E$：<ul><li>同条件下可重复。</li><li>试验结果明确可知，且不止一个。</li><li>试验前不知哪个结果会发生。</li></ul></li></ul><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><code>试验结果</code> 中每一个最简单、最基本 (不可再分的结果) 叫 <code>样本点</code> (基本事件)，记作 $\omega$。</li><li>$\omega$ 的全体叫 <code>样本空间</code>，记作 $\Omega$。</li><li><code>样本空间的子集</code> 叫 <code>随机事件</code>，记作 $A, B, C, …$，即英文大写字母表示。</li><li>子集中：<ul><li>$\Omega$ 本身为必然事件。</li><li>$\emptyset$ 为不可能事件。</li></ul></li></ul><h3 id="古典概型"><a href="#古典概型" class="headerlink" title="古典概型"></a>古典概型</h3><h4 id="概念梳理"><a href="#概念梳理" class="headerlink" title="概念梳理"></a>概念梳理</h4><ul><li>若随机事件 $E$ 的样本空间 $\Omega$ 中满足下述两种条件，称其为古典概型：<ul><li>存在 <code>有限个</code> 样本点；</li><li>样本点的发生具有 <code>等可能性</code>.</li></ul></li><li>则其概率表达式为：</li></ul><script type="math/tex; mode=display">P(A) = \frac{A中含样本点个数}{\Omega 中含样本点总数}\tag{1}</script><ul><li><p>对于概率表达式 (1)，我们侧重关注其 <code>计数方法</code>：</p><ul><li><code>穷举法</code>：个数不多时，直接计数即可。</li><li><p><code>集合对应法</code>：</p><ul><li><code>加法原理</code>：完成一件事有 $n$ 类方法，第一类方法有 $m_1$ 种方法，第二类有 $m_2$ 种方法，完成此事共 $\sum_{i = 1}^n m_i$ 种方法。</li><li><code>乘法原理</code>：完成一件事有 $n$ 个步骤，第一步有 $m_1$ 种方法，第二步有 $m_2$ 种方法，第 $n$ 步有 $m_n$ 种方法，故完成此事共 $\prod_{i=1}^n m_i$ 种方法。</li><li><p><code>排列</code>：从 $n$ 个不同的元素中取出 $m(\leq n)$ 个元素，并按照一定顺序排成一列，叫做排序。所有排列的个数叫排列数，记作：</p><script type="math/tex; mode=display">A_n^m = n(n-1)···(n - m + 1) = \frac{n!}{(n - m)!}\tag{2}</script><p><code>全排列</code>：当 $m = n$ 时，$A_n^m = \frac{n!}{0!} = n!$ 称为全排列。</p></li><li><p><code>组合</code>：从 $n$ 个不同元素中取出 $m(\leq n)$ 个元素，并成一组，叫组合。所有组合个数叫组合数，记作：</p><script type="math/tex; mode=display">C_n^m = \frac{A_n^m}{m!}\tag{3}</script><blockquote><p>注意：按照欧美规范，对于 $A_n^m$ 或是 $C_n^m$，m 和 n 的上下位置与我们平常见的是相反的，国内的教材以相反为主。</p></blockquote></li></ul></li><li><p><code>对立事件思想</code>：若研究对象是复杂的，则转而研究对立事件 $\overline{A}$，故有：</p><script type="math/tex; mode=display">n - n_{\overline{A}} = n_A\tag{4}</script></li></ul></li></ul><h4 id="练习巩固"><a href="#练习巩固" class="headerlink" title="练习巩固"></a>练习巩固</h4><h5 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h5><ul><li>[题目] 从 0 到 9 个数字中任取 3 个不同数字，求：  <ul><li>$A_1$ = {三个数中不含 0 和 5}</li><li>$A_2$ = {三个数中不含 0 或 5}</li><li>$A_3$ = {三个数中含 0，但不含 5}</li></ul></li><li><p>[分析]  令含数字 0 的事件为 $B_1$，含数字 5 的事件为 $B_2$：</p><ul><li><p>$P(A_1) = \frac{ C_8^3 }{ C_{10}^3 } = \frac{7}{15}$</p></li><li><p>$P(A_2) = \frac{ C_{10}^3 - C_1^1·C_1^1·C_8^1 }{ C_{10}^3 } = \frac{14}{15}$</p><blockquote><p>$A_2$ 事件可通 <code>对立事件思想</code> 解题，即所有数字取值可能减去三个数中含 0 且含 5 的情况，即 $A_2 = \overline{ B_1 \bigcup B_2 } = \overline{B_1} \bigcap \overline{B_2}$。</p></blockquote></li><li><p>$P(A_3) = \frac{ C_1^1·C_8^2 }{ C_{10}^3 } = \frac{7}{30}$</p></li></ul></li></ul><h5 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h5><ul><li>[题目] 袋中有 5 球，3 白 2 黑：<ul><li>先后有放回取 2 球，求 $B_1$ = {至少一白球}</li><li>先后无放回取 2 球，求 $B_2$ = {至少一白球} </li><li>任取 2 球，求 $B_3$ = {至少一白球}</li></ul></li><li><p>[分析] 注意 <code>有放回</code> 和 <code>无放回</code> 的情况，是有区别的：</p><ul><li><p>$P(B_1) = \frac{ C_5^1·C_5^1 - C_2^1·C_2^1 }{ C_5^1·C_5^1 } = \frac{21}{25}$</p></li><li><p>$P(B_2) = \frac{ C_5^1·C_4^1 - C_2^1·C_1^1 }{ C_5^1·C_4^1 } = \frac{9}{10}$</p></li><li><p>通过 <code>对立事件思想</code> 解题，先求 $\overline{B_3}$ = {任取两球全黑} 的概率：</p><script type="math/tex; mode=display">P(\overline{B_3}) = \frac{ C_2^2 }{ C_5^2 } = \frac{1}{10} \\P(B_3) = 1 - P(\overline{B_3}) = \frac{9}{10}</script></li></ul></li><li><p>我们注意到，$P${先后无放回取，至少一白球} 等于 $P${任取两球，至少一白球} 的概率，即 $P(B_2) = P(B_3)$。</p><ul><li><code>得出结论</code>：<code>P{先后无放回} = P{任取}</code></li><li><p><code>证明方式</code>：分别用 <code>先后无放回取两球</code> 的方式和 <code>任取两球</code> 的方式，求 <code>P{两球全黑}</code>，再通过 <code>1 - P{两球全黑}</code> 求 <code>P{至少一白球}</code>： </p><script type="math/tex; mode=display">  p(\text{先后无放回取得两球全黑}) =       \frac{ C_2^1·C_1^1 }{ C_5^1·C_4^1 } = \frac{1}{10} \\  p(\text{任取两球全黑}) =      \frac{ C_2^2 }{ C_5^2 } = \frac{1}{10}</script><p>  当然，任取涉及先后顺序问题，应该对任取结果作排列，但由于上下同乘一种顺序故可略去。</p><script type="math/tex; mode=display">  \require{cancel}  p(\text{任取两球全黑}) =      \frac{ C_2^2·\bcancel{A_2^2} }{ C_5^2 ·\bcancel{A_2^2} } = \frac{1}{10}</script></li><li><p>通过此结论，计算 <code>先后无放回</code> 抽取问题会有很大帮助。例如，从 100 个球中，先后无放回取 40 个球，则可理解为 <code>一把抓 40 个球</code>。</p></li></ul></li></ul><h5 id="例题三"><a href="#例题三" class="headerlink" title="例题三"></a>例题三</h5><ul><li>[题目] 袋有 100 个球，40 白 60 黑：<ul><li>先后 <code>无放回</code> 取 20 个球，求 $C_1$ = {15 白 5 黑}</li><li>先后 <code>无放回</code> 取 20 个球，求 $C_2$ = {第 20 次取到白球}</li><li>先后 <code>有放回</code> 取 20 个球，求 $C_3$ = {15 白 5 黑}</li><li>先后 <code>有放回</code> 取 20 个球，求 $C_4$ = {第 20 次取到白球}</li></ul></li><li><p>[分析] 根据例题二的结论，无放回抽取可等同于任意抽取。</p><ul><li><p>$P(C_1) = \frac{ C_{40}^{15}·C_{60}^5 }{ C_{100}^{20} }$</p></li><li><p>$P(C_2) = \frac{C_{40}^1·99!}{100!} = \frac{40}{100}$ </p><ul><li>1) 利用 <code>抓阄模型</code> 进行解题。即在本题中可理解为：袋中装有 100 个“灰球”，按概率摸球，则有 40% 可能摸到白球，60% 可能摸到黑球。</li><li><p>2) 在本题中，我们可把 100 个球想象成 100 个位置，从左往右排列，位置与次数匹配。例如，我们求第 20 次取到白球的概率，即往 20 的位置只考虑放入白球的情况，剩余位置自由排列即可，故有 $C_{40}^1·99!$。</p><p><img src="/images/illustration/Reading/2018/10/probability-and-statistics_1-1.png" alt="图1-1抓阄模型演示"></p><center>图1-1 抓阄模型演示</center></li></ul></li><li><p>$P(C_3) = C_{20}^{15}·(\frac{40}{100})^{15}·(\frac{60}{100})^5$</p><ul><li>符合二项分布，记取到白球的次数为 X (实验无非取到黑/白两种球)，则可根据公式求解：<script type="math/tex; mode=display">P\{X = k\} = C_n^k·p^k·(1-p)^{n-k}, k = 0, 1, 2, ..., n</script></li></ul></li><li><p>$P(C_4) = \frac{40}{100}$</p></li></ul></li></ul><h3 id="几何概型"><a href="#几何概型" class="headerlink" title="几何概型"></a>几何概型</h3><h4 id="概念梳理-1"><a href="#概念梳理-1" class="headerlink" title="概念梳理"></a>概念梳理</h4><ul><li><p>定义 $\Omega$ 是一个可度量的几何区域，每个样本点的发生具有等可能性。即样本点落入 $\Omega$ 中的某一可度量子区域 $A$ 的可能性大小与 $A$ 的 <code>几何度量</code> 成正比，而与 $A$ 的位置及形状无关。则称其为 <code>几何概型</code>，记作：</p><script type="math/tex; mode=display">  P(A) = \frac{ A 的测度 }{ \Omega 的测度 }  \tag{5}</script></li></ul><h4 id="练习巩固-1"><a href="#练习巩固-1" class="headerlink" title="练习巩固"></a>练习巩固</h4><h5 id="例题一-1"><a href="#例题一-1" class="headerlink" title="例题一"></a>例题一</h5><ul><li>[题目]假设我上午 8:00-9:00 时间段内进入教室：<ul><li>求 $A_1$ = {我在 8:30-9:00 时间段进教室} 的概率</li><li>求 $A_2$ = {我恰好在 8:30 进入教室} 的概率</li></ul></li><li><p>[分析] 如图 1-2 所示，设 8:00-9:00 的时间段为单位 1：</p><ul><li><p>$P(A_1) = \frac{ \frac12 }{1} = \frac12$</p></li><li><p>$P(A_2) = \frac01 = 0$</p><blockquote><p>在 8:30 这一刻所占长度为 “0”，只是数据研究工具的缺陷，致使测不出来。所以 $P(A) = 0$ 并不能推导 $A_2$ 为不可能事件。</p></blockquote><p><img src="/images/illustration/Reading/2018/10/probability-and-statistics_1-2.png" alt="图1-2单位1长时间段"></p><center>图1-2 单位 1 长时间段</center></li></ul></li></ul><h5 id="例题二-1"><a href="#例题二-1" class="headerlink" title="例题二"></a>例题二</h5><ul><li>[题目] 君子有约，9:00-10:00 甲、乙在校门口见面，等 20 分钟即离开：<ul><li>求 $B$ = {甲、乙能见面} 的概率</li></ul></li><li><p>[分析] 设甲出现的时间为 $x$，乙出现的时间为 $y$：</p><ul><li><p>则两方的时间差为 $|x - y| \leq 20, 0 \leq x \leq 60, 0 \leq y \leq 60$</p><p><img src="/images/illustration/Reading/2018/10/probability-and-statistics_1-3.png" alt="图1-3函数图像"></p><center>图1-3  $|x - y| \leq 20$ 的函数图像</center></li><li><p>根据上述函数的图像可得 $P(B) = \frac{ \int_A }{ \int_\Omega } = \frac{ 1 - (\frac{40}{60})^2 }{1} = \frac59$</p></li></ul></li></ul><h5 id="例题三-1"><a href="#例题三-1" class="headerlink" title="例题三"></a>例题三</h5><ul><li>[题目] 在 (0, 1) 内随机取两个数，$P\{两数之和小于 \leq \frac65\}$</li><li><p>[解析] 由题意可得，则有：</p><p>  <img src="/images/illustration/Reading/2018/10/probability-and-statistics_1-4.png" alt="图1-4函数图像"></p>  <center>图1-4  $x + y \leq \frac65$ 的函数图像</center><script type="math/tex; mode=display">P\{ x + y < \frac65\} = \frac{1 - \frac45*\frac45*\frac12}{1} = \frac{17}{25}</script></li></ul><h3 id="重要公式求概率"><a href="#重要公式求概率" class="headerlink" title="重要公式求概率"></a>重要公式求概率</h3><h4 id="概念梳理-2"><a href="#概念梳理-2" class="headerlink" title="概念梳理"></a>概念梳理</h4><h5 id="对立事件"><a href="#对立事件" class="headerlink" title="对立事件"></a>对立事件</h5><script type="math/tex; mode=display">P(A) = 1- P(\overline{A})\tag{6}</script><h5 id="减法公式"><a href="#减法公式" class="headerlink" title="减法公式"></a>减法公式</h5><script type="math/tex; mode=display">P(A - B) = P(A) - P(AB)\tag{7}</script><h5 id="加法公式"><a href="#加法公式" class="headerlink" title="加法公式"></a>加法公式</h5><ul><li><p>一般情况 ( 通用公式 )：</p><script type="math/tex; mode=display">  P(A + B) = P(A) + P(B) - P(AB)  \tag{9}</script><script type="math/tex; mode=display">  P(A + B + C) = P(A) + P(B) + P(C) - P(AB) - P(AC) - P(BC) + P(ABC)</script></li><li><p>若 $A_1, A_2, …, A_n (n &gt; 3)$ <code>两两互斥 (互不相容)</code>，则可得：</p><script type="math/tex; mode=display">  P(A_1 + A_2 + ... + A_n) = \sum_{i = 1}^n P(A_i)  \tag{6}</script></li><li><p>若 $A_1, A_2, …, A_n (n &gt; 3)$  <code>相互独立</code>，则可得：</p><script type="math/tex; mode=display">  P(A_1 + A_2 + ... + A_n) = 1 - P ( \overline{A_1 + A_2 + ... + A_n} ) \\   = 1 - P( \overline{A_1}·\overline{A_2}·...·\overline{A_n} ) = 1 - \prod_{i=1}^n P(\overline{A_i})  \tag{10}</script><ul><li><code>相互独立</code>：设 $A_1, A_2, …, A_n $，若对其中任意有限个 $A_{i_1}, A_{i_2}, …, A_{i_k}$ 都有 $P(A_{i_1})·P(A_{i_2})·…·P(A_{i_k})$，则称 $A_1, A_2, …, A_n $ 相互独立。  </li><li><code>妇唱夫随</code>：$n$ 个事件相互独立 $\Longleftrightarrow$ 它们中任意一部分事件换成其各自的对立事件，所得的 $n$ 个新事件也是相互独立的。</li></ul></li></ul><p><img src="/images/illustration/Reading/2018/10/probability-and-statistics_1-5.png" alt="图1-5上述公式图解"></p><center>图 1-5 上述公式图解</center><h5 id="条件概率公式"><a href="#条件概率公式" class="headerlink" title="条件概率公式"></a>条件概率公式</h5><blockquote><p>标志性词汇：已知…，当…发生了。</p></blockquote><script type="math/tex; mode=display">P(A | B) = \frac{ P(AB) } { P(B) }, P(B) > 0\tag{11}</script><h5 id="乘法公式"><a href="#乘法公式" class="headerlink" title="乘法公式"></a>乘法公式</h5><script type="math/tex; mode=display">P(AB) = P(A | B)·P(B) \\P(AB) = P(B | A)·P(A)\tag{12}</script><p>一般地，推广至 $P(A_1A_2…A_n)$：</p><script type="math/tex; mode=display">P(A_1A_2...A_n) = \\P(A_n | A_1A_2...A_{n-1})·P(A_{n-1} | A_1A_2...A_{n-2})·...P(A_2 | A_1)·P(A_1)\tag{13}</script><h5 id="全集分解公式"><a href="#全集分解公式" class="headerlink" title="全集分解公式"></a>全集分解公式</h5><blockquote><p>也称 <code>全概率公式</code>，已知第一阶段，求第二阶段。</p></blockquote><ul><li><p>引例：设一个村子和三个小偷，小偷分别为 $A_1、A_2、A_3$，B = {村子失窃}</p><ul><li><p>阶段 (I). 什么人去偷：$A_1, A_2, A_3$</p></li><li><p>阶段 (II). 村子失窃，各小偷去偷的概率：$P(B | A_1) = 0, P(B | A_2) = \frac12, P(B | A_3) = 1$</p></li><li><p>则村子失窃的概率：</p><script type="math/tex; mode=display">P(B) = P(A_1)·P(B | A_1) + P(A_2)·P(B | A_2) + P(A_3)·P(B | A_3) \\  = \frac13 * 0 + \frac13 * \frac12 + \frac13 * 1 = \frac12</script></li></ul></li><li><p>定义与公式，设一随机事件 $E$ 可分两个阶段：</p><ul><li>阶段 (I) $\bigcup_{i = 1}^n A_i = \Omega, A_iA_j = \emptyset (两两互斥), i \neq j$，则称 $A_1, A_1,…, A_n$ 为 $\Omega$ 的一个划分，也叫 <code>完备事件组</code>。</li><li><p>阶段 (II) 事件 $B$ 发生的概率：</p><ul><li>$P(B\Omega) = P(B·(\bigcup_{i = 1}^n A_i) )$ 为全集分解过程。</li><li><p>$B$ 为第 (II) 阶段，$A_i$ 为第 (I) 阶段。</p><script type="math/tex; mode=display">P(B) = P(B\Omega) = P(B·(\bigcup_{i = 1}^n A_i) ) = P( B\bigcap(A_1 + A_2 + ... + A_n) ) \\= P(BA_1 + BA_2 + ... + BA_n) = \sum_{i = 1}^n P(BA_i) \\= \sum_{i = 1}^n P(B | A_i)·P(A_i)\tag{13}</script></li></ul></li></ul></li></ul><h5 id="贝叶斯"><a href="#贝叶斯" class="headerlink" title="贝叶斯"></a>贝叶斯</h5><blockquote><p>也称 <code>逆概率公式</code>，已知第二阶段反推第一阶段 ( 执果索因 )。</p></blockquote><ul><li><p>设一随机事件 $E$ 分成两个阶段：</p><ul><li>阶段 (I) $\bigcup_{j = 1}^n A_j = \Omega, A_iA_j = \emptyset (两两互斥), j \neq i$，则称 $A_1, A_1,…, A_n$ 为 $\Omega$ 的一个划分，也叫 <code>完备事件组</code>。</li><li><p>阶段 (II) 已知 $B$ 发生了，求 $P(A_j | B)$：</p><ul><li>$P(B | A_j)$ 是已知的。</li><li><p>一个事件分两个阶段，考虑全概率公式。</p><script type="math/tex; mode=display">P(A_j | B) = \frac{ P(A_jB) }{ P(B) }= \frac{  P(B | A_j)·P(A_j)}{  \sum_{i = 1}^n P(B | A_i)·P(A_i)}\tag{14}</script></li></ul></li></ul></li></ul><h4 id="练习巩固-2"><a href="#练习巩固-2" class="headerlink" title="练习巩固"></a>练习巩固</h4><h2 id="贰-如何求分布"><a href="#贰-如何求分布" class="headerlink" title="贰 如何求分布"></a>贰 如何求分布</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h4><h4 id="分布函数"><a href="#分布函数" class="headerlink" title="分布函数"></a>分布函数</h4><h5 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h5><h5 id="连续型随机变量"><a href="#连续型随机变量" class="headerlink" title="连续型随机变量"></a>连续型随机变量</h5><h3 id="常见一维分布"><a href="#常见一维分布" class="headerlink" title="常见一维分布"></a>常见一维分布</h3><h4 id="两点分布"><a href="#两点分布" class="headerlink" title="两点分布"></a>两点分布</h4><h4 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h4><h4 id="几何分布"><a href="#几何分布" class="headerlink" title="几何分布"></a>几何分布</h4><h4 id="超几何分布"><a href="#超几何分布" class="headerlink" title="超几何分布"></a>超几何分布</h4><h4 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h4><h4 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h4><h4 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h4><h4 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h4><h3 id="一维随机变量及其分布函数"><a href="#一维随机变量及其分布函数" class="headerlink" title="一维随机变量及其分布函数"></a>一维随机变量及其分布函数</h3><h3 id="二维随机变量及其分布函数"><a href="#二维随机变量及其分布函数" class="headerlink" title="二维随机变量及其分布函数"></a>二维随机变量及其分布函数</h3><h2 id="叁-如何求数字特征"><a href="#叁-如何求数字特征" class="headerlink" title="叁 如何求数字特征"></a>叁 如何求数字特征</h2><h3 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h3><h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><h3 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h3><h3 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h3><h2 id="肆-如何使用极限定理"><a href="#肆-如何使用极限定理" class="headerlink" title="肆 如何使用极限定理"></a>肆 如何使用极限定理</h2><h3 id="依概率收敛"><a href="#依概率收敛" class="headerlink" title="依概率收敛"></a>依概率收敛</h3><h3 id="极限定理"><a href="#极限定理" class="headerlink" title="极限定理"></a>极限定理</h3><h4 id="大数定律"><a href="#大数定律" class="headerlink" title="大数定律"></a>大数定律</h4><h4 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h4><h2 id="伍-如何作估计"><a href="#伍-如何作估计" class="headerlink" title="伍 如何作估计"></a>伍 如何作估计</h2><h3 id="总体与样本"><a href="#总体与样本" class="headerlink" title="总体与样本"></a>总体与样本</h3><h3 id="估计方法"><a href="#估计方法" class="headerlink" title="估计方法"></a>估计方法</h3><h3 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本笔记是备战考研时，跟着张宇老师的概率论课程学习整理所得。且输出本笔记的主要目的是快速构建概率的基础知识体系，以便于日后复习查阅和问题探究。或是更具体的应用场景，如 &lt;code&gt;机器学习&lt;/code&gt;、&lt;code&gt;数据挖掘&lt;/code&gt;、&lt;code&gt;经济统计&lt;/code&gt; 等领域，概率论作为这些领域的 &lt;code&gt;先修课程&lt;/code&gt;，理论基础尤为重要。由此，无论是初入门还是温故知新，学习基础学科为必经阶段，不妨选择张宇老师的概率论课程，这不失一种高效的复习方案。&lt;/p&gt;
&lt;p&gt;当然，笔记仅是对知识点的整理和归纳，并不能代表原本知识点的严谨定义。若有更进阶的需求，还请查阅概率论相关教材，或重温课程。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://www.kofes.cn/categories/Reading/"/>
    
    
      <category term="贝叶斯" scheme="http://www.kofes.cn/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
      <category term="全概率" scheme="http://www.kofes.cn/tags/%E5%85%A8%E6%A6%82%E7%8E%87/"/>
    
      <category term="分布函数" scheme="http://www.kofes.cn/tags/%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0/"/>
    
      <category term="数字特征" scheme="http://www.kofes.cn/tags/%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"/>
    
  </entry>
  
  <entry>
    <title>笔记 | Python 3 入门系列教程</title>
    <link href="http://www.kofes.cn/2018/09/life-is-short-we-need-python.html"/>
    <id>http://www.kofes.cn/2018/09/life-is-short-we-need-python.html</id>
    <published>2018-09-03T08:47:14.000Z</published>
    <updated>2018-10-12T11:37:18.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><ul><li>本文章主要以黑马程序员的「<a href="https://pan.baidu.com/s/1oBnk19WfBWQ1Pwd7rNGixw" target="_blank" rel="noopener">传智播客 Python 就业班 (ij6g)</a>」、「 <a href="https://www.bilibili.com/video/av14184325" target="_blank" rel="noopener">Python 从入门到精通教程</a> 」和「 <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰的 Python 教程</a> 」为主线，输出学习笔记，目的是检验自己的学习效果和日常复习之需。</li><li>本文章也可作为入门 Python 的参考资料，除了视频的基础内容外，文章还会补充视频中讲解不详细或遗漏的必要知识点。</li><li>文章的内容和知识框架，与「廖雪峰的 Python 教程」和「传智播客的视频」大体保持一致：<ul><li>文章以模块分块阐述：<code>Linux 基础</code>、<code>Python 基础</code>、<code>Python 面向对象</code>、<code>项目实战</code> ( 实战部分以爬虫、数据分析为主的项目实战 )。</li><li>每个模块按知识点区分：<ul><li>Linux 基础部分参考 <code>传智播客 Python 从入门到精通教程</code>；</li><li>Python 基础部分参考 <code>廖雪峰 Python 教程</code>；</li><li>项目实践，即数据分析部分参考书籍 <code>利用 Python 进行数据分析</code> $^{[5]}$；</li></ul></li></ul></li><li><p>最后，引用 Bruce Eckel 的原话作为开篇，Python 的高效只有切身体验才会深有体会。期待您早日加入 Python 队伍中来。</p>  <div class="note success"><p>Life is short, you need python.</p></div></li></ul><a id="more"></a><h2 id="更新进度"><a href="#更新进度" class="headerlink" title="更新进度"></a>更新进度</h2><ul><li>2018.09.03：完成初稿，且完成 Linux 基础部分的内容；</li><li>2018.09.18：更新 Python 基础部分内容 ( 语言基础、函数、高级特性 )；</li><li>2018.09.21：更新 Python 基础部分内容 ( 函数式编程 )；</li><li>2018.10.10：更新 Python 基础部分内容 ( 模块、面向对象编程 )；</li><li>2018.10.12：更新 Python 基础部分内容 ( 模块、面向对象高级编程 )；</li><li><h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2></li><li><code>Python 基础</code><ul><li>📖 | 埃里克·马瑟斯.《 Python 编程：从入门到实践 》：<a href="https://book.douban.com/subject/26829016/" target="_blank" rel="noopener">豆瓣评分</a></li><li>📖 | Albert Sweigart.《 Python 编程快速上手 》：<a href="https://book.douban.com/subject/26836700/" target="_blank" rel="noopener">豆瓣评分</a> </li></ul></li><li><code>Python 进阶</code><ul><li>📖 | David M. Beazley / Brian K. Jones.《 Python Cookbook 》：<a href="https://book.douban.com/subject/26381341/" target="_blank" rel="noopener">中文版</a> | <a href="https://book.douban.com/subject/20491078/" target="_blank" rel="noopener">英文版</a></li><li>📖 | Luciano Ramalho. 《 Fluent Python 》：<a href="https://book.douban.com/subject/27028517/" target="_blank" rel="noopener">中文版</a> | <a href="https://book.douban.com/subject/26278021/" target="_blank" rel="noopener">英文版</a></li></ul></li><li><code>Python 实践</code><ul><li>📖 | Wes Mckinney.《 利用 Python 进行数据分析 》：<a href="https://book.douban.com/subject/25779298/" target="_blank" rel="noopener">豆瓣评分</a></li><li>📖 | Clinton W. Brownley.《 Python数据分析基础 》：<a href="https://book.douban.com/subject/27100480/" target="_blank" rel="noopener">豆瓣评分</a></li></ul></li></ul><h2 id="教学资源"><a href="#教学资源" class="headerlink" title="教学资源"></a>教学资源</h2><ul><li>📖 | 文章 | <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰. Python 3 教程. liaoxuefeng.com</a></li><li>📺 | 视频 | <a href="https://www.bilibili.com/video/av14184325" target="_blank" rel="noopener">黑马程序员. Python 从入门到精通教程. 2017. bilibili.com</a></li><li><p>📺 | 视频 | <a href="https://pan.baidu.com/s/1oBnk19WfBWQ1Pwd7rNGixw" target="_blank" rel="noopener">传智播客. Python 就业班. 2017. BaiduCloud</a> | Pwd: ij6g</p><blockquote><p>本文章的学习笔记是基于此系列教学视频所得的。</p></blockquote></li></ul><h2 id="Linux-基础"><a href="#Linux-基础" class="headerlink" title="Linux 基础"></a>Linux 基础</h2><h3 id="Linux-常用终端命令"><a href="#Linux-常用终端命令" class="headerlink" title="Linux 常用终端命令"></a>Linux 常用终端命令</h3><blockquote><p>仅列举一些项目中常用的命令。</p></blockquote><ul><li><p>LS 命令与通配符</p><ul><li><code>*</code>：代表任意个数个字符。</li><li><code>?</code>：代表任意一个字符。</li><li><code>[]</code>：表示可匹配字符组中任意一个。</li><li><code>[abc]</code>：匹配 a、b、c 中的任意一个字符。</li><li><p><code>[a-f]</code>：匹配从 a 到 f 范围内的任意一个字符。</p><blockquote><p>常使用 <code>ls -al</code> 显示当前文件目录所有文件的详细信息。</p></blockquote></li></ul></li><li><p>CD 命令与切换目录</p><ul><li>相对路径：最前面不是 <code>/</code> 或 <code>~</code>，表示相对 <code>当前目录</code> 所在的目录位置。</li><li><p>绝对路径：最前面是 <code>/</code> 或 <code>~</code>，表示从 <code>根目录 / Home 目录</code> 开始的具体目录位置。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相对路径：返回上两级目录</span></span><br><span class="line"><span class="built_in">cd</span> ../../ </span><br><span class="line"></span><br><span class="line"><span class="comment"># 绝对路径：相当于 cd /Users/your username/</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>Tree 命令：以树状结构显示文件目录结构，若 <code>tree -d</code> 则显示目录，不显示文件。</p></li><li><p>查看文件内容</p><ul><li><code>cat 文件名</code>：查看文件内容、创建文件、文件合并、追加文件内容等功能。</li><li><code>more 文件名</code>：分屏显示文件内容。</li><li><code>grep 搜索文本的文件名</code>：搜索文件文件内容。<ul><li>例如搜索包含单词 “hello” 的文本，即 <code>grep &quot;hello&quot; sample.txt</code>。</li><li>选项参数：<code>-n</code> 显示匹配行号；<code>-v</code> 显示不包含匹配文本的所有行；<code>-i</code> 忽略大小写。</li></ul></li></ul></li><li><p>Echo 命令与重定向</p><ul><li><code>echo</code> 命令：在终端中显示参数指定的文字。</li><li>重定向 <code>&gt;</code> 和 <code>&gt;&gt;</code>：<ul><li><code>&gt;</code> 表示输出，会覆盖文件原有内容。</li><li><code>&gt;&gt;</code> 表示追加，会将内容追加到已有文件的末尾。</li></ul></li><li><p><code>echo</code> 命令常结合 <code>重定向</code> 使用：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将字符串 "Hello World" 追加到</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello World"</span> &gt;&gt; sample.txt</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>管道符 <code>|</code></p><ul><li>Linux 允许将一个命令的输出通过管道作为另一个命令的输入。</li><li><p>ls 命令与 grep 命令的结合使用，如从 Home 目录下搜索包含 “python” 关键字的文件或者文件夹：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 Home 目录下搜索包含 "python" 关键字的文件或者文件夹</span></span><br><span class="line">ls -al ~ | grep python</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>Ifconfig 命令与 Ping 命令</p><ul><li><code>ifconfig</code> 命令可查看/配置计算机当前的网卡配置。</li><li><p><code>ping</code> 命令一般用于检测当前计算机到目标计算机之间的网络是否畅通。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速查看网卡对应的 IP 地址</span></span><br><span class="line">ifconfig | grep inet</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="远程登录和复制文件"><a href="#远程登录和复制文件" class="headerlink" title="远程登录和复制文件"></a>远程登录和复制文件</h3><h4 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h4><ul><li>远程登录即通过 <code>SSH 客户端</code> 连接运行了 <code>SSH 服务器</code> 的远程机器上。</li><li>SSH 是目前较可靠，专为 <code>远程登录会话</code> 和 <code>其他网络服务</code> 提供安全性协议。<ul><li>有效防止远程管理过程中的信息泄露。</li><li>对所有传输的数据进行加密，也能防止 DNS 欺骗和 IP 欺骗。</li></ul></li><li>SSH 客户端是一种使用 <code>Secure Shell</code> 协议连接到远程计算机的软件程序。</li><li>SSH 客户端简单使用访问服务器：<code>ssh [-p port] user@remote</code><ul><li><code>user</code> 是远程机器上的用户名。</li><li><code>remote</code> 是远程机器地址，可为 IP、域名或别名。</li><li><code>port</code> 是 SSH 服务器监听的端口，若不指定端口默认为 22。</li></ul></li></ul><h4 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h4><ul><li><p>SCP 即 <code>Secure Copy</code>，是一个在 Linux 下用来进行 <code>远程拷贝文件</code> 的命令。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从本地复制文件到远程机器桌面上</span></span><br><span class="line">scp -P sample.py user@remote:Desktop/sample.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从远程机器桌面上复制文件夹到本地上</span></span><br><span class="line">scp -P port -r user@remote:Desktop/sample ~/Desktop/sample</span><br></pre></td></tr></table></figure></li></ul><h4 id="SSH-高级用法"><a href="#SSH-高级用法" class="headerlink" title="SSH 高级用法"></a>SSH 高级用法</h4><h5 id="免密码登录"><a href="#免密码登录" class="headerlink" title="免密码登录"></a>免密码登录</h5><p>免密码登录：即客户端访问服务端时，需要密码验证身份登录。</p><ul><li>Step.01. 配置公钥：执行 <code>ssh-keygen</code> 即生成 SSH 密钥。</li><li><p>Step.02. 上传公钥到服务器：执行 <code>ssh-copy-id -p port user@remote</code>，让远程服务器记住我们的 <code>公钥</code>。</p><blockquote><p>1) 有关 SSH 配置信息都保存在 <code>/Home/your username/.ssh</code> 目录下。<br>2) 免密登录使用的是非对称加密算法 ( RSA )，即使用公钥加密的数据，需要使用私钥解密；使用私钥加密的数据，需要使用公钥解密。若有兴趣了解 <code>RSA 算法</code> 的原理及计算，可参考引用文章 [1]、[2]。</p></blockquote><p>  <img src="/images/illustration/Programme/2018/09/life-is-short-we-need-python_4-1.png" alt="图4-1免密码登录实现原理图"></p>  <center>图 4-1 免密码登录实现原理图</center></li></ul><h5 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h5><p>配置别名：每次输入 <code>ssh -p port user@remote</code> 是非常繁琐重复的工作，配置别名的方式以替代上述这么一串命令代码。</p><ul><li><p>在 <code>/.ssh/config</code> 文件下追加以下内容 ( 需建立 Config 文件 )：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host mac</span><br><span class="line">HostName <span class="number">192.168</span>.<span class="number">10.1</span></span><br><span class="line">User user</span><br><span class="line">Port <span class="number">22</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>命令输入 <code>ssh mac</code> 即可实现远程登录操作 ( SCP 同样原理 )。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若配置别名后，待验证命令的格式:</span></span><br><span class="line"><span class="comment"># 是否为: scp -r ~/Desktop/Sample mac:Desktop/Sample</span></span><br><span class="line"><span class="comment"># 还是: scp -P 22 -r ~/Desktop/Sample mac:Desktop/Sample</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="用户和权限"><a href="#用户和权限" class="headerlink" title="用户和权限"></a>用户和权限</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>在 Linux 中，可指定每一用户针对不同的文件或者目录的不同权限。</li><li>对文件 / 目录包含的权限有：</li></ul><center>表 4-1 文件/目录权限属性说明</center><div class="table-container"><table><thead><tr><th style="text-align:center">权限</th><th style="text-align:center">英文</th><th style="text-align:center">缩写</th><th style="text-align:center">数字代号</th></tr></thead><tbody><tr><td style="text-align:center">读</td><td style="text-align:center">read</td><td style="text-align:center">r</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">写</td><td style="text-align:center">write</td><td style="text-align:center">w</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">执行</td><td style="text-align:center">excute</td><td style="text-align:center">x</td><td style="text-align:center">1</td></tr></tbody></table></div><h4 id="组"><a href="#组" class="headerlink" title="组"></a>组</h4><ul><li>为方便用户管理，提出组的概念。在实际开发中，可预先针对组设置好权限，然后将不同的用户添加到对应组中，从而不用依次为每个用户设置权限。</li></ul><h4 id="LL-命令"><a href="#LL-命令" class="headerlink" title="LL 命令"></a>LL 命令</h4><ul><li>LL 命令即 LS 命令的扩展用法 <code>ls -al</code>。</li><li>LL 命令可查看文件夹下文件的详细信息，从左往右依次是：<ul><li>权限：第一个字符是 <code>d</code>，表示目录；<code>-</code> 表示文件；</li><li>硬链接数：通俗理解即有多少种方式可访问到当前目录 / 文件；</li><li>拥有者：当前用户；</li><li>组：当前用户所属的组；</li><li>文件大小，修改时间，文件 / 目录名称.</li></ul></li></ul><center>表 4-2 "ls -al" 查看文件的权限信息说明</center><div class="table-container"><table><thead><tr><th style="text-align:center">目录</th><th style="text-align:center">拥有者权限</th><th style="text-align:center">组权限</th><th style="text-align:center">其他用户权限</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">-</td><td style="text-align:center">r w -</td><td style="text-align:center">r w -</td><td style="text-align:center">r - -</td><td style="text-align:center">文件权限示例</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">r w x</td><td style="text-align:center">r w x</td><td style="text-align:center">r - x</td><td style="text-align:center">目录权限示例</td></tr></tbody></table></div><h4 id="Chmod-命令"><a href="#Chmod-命令" class="headerlink" title="Chmod 命令"></a>Chmod 命令</h4><ul><li><p>Chmod 命令：可修改 <code>用户/组</code> 对 <code>文件/目录</code> 的权限。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一次性修改拥有者/组的权限</span></span><br><span class="line">chmod +/-rwx 文件名/目录名</span><br></pre></td></tr></table></figure></li></ul><h4 id="Sudo-命令"><a href="#Sudo-命令" class="headerlink" title="Sudo 命令"></a>Sudo 命令</h4><ul><li><p>Sudo 命令：使用预设 ( root, 系统管理员 ) 的身份来执行命令。</p><blockquote><p>Linux 系统中，通常使用标准用户登录及使用系统，通常 <code>sudo</code> 命令临时获得权限用于系统的维护与和管理。</p></blockquote></li></ul><h3 id="系统信息相关命令"><a href="#系统信息相关命令" class="headerlink" title="系统信息相关命令"></a>系统信息相关命令</h3><ul><li>查询时间和日期<ul><li><code>date</code>：查看系统时间。</li><li><code>cal</code>：查看当月日历，<code>cal -y</code> 查看当年的日历。</li></ul></li><li>磁盘和目录空间<ul><li>df：<code>df -h</code>，Disk Free 显示磁盘剩余空间。</li><li>du：<code>du -h</code>，Disk Usage 显示目录下的文件大小。</li></ul></li><li><p>进程信息</p><ul><li>ps：<code>ps aux</code>，即 Process Status，查看进程的详细状况。</li><li>top：动态显示运行中的进程并排序。</li><li><p>kill：<code>kill [-9] 进程代号</code>，<code>-9</code> 表示强行终止，终止指定代号的进程。</p><blockquote><p>使用 <code>kill</code> 命令时，最好终止当前用户开启的进程，而不是终止 <code>root</code> 身份开启的进程。</p></blockquote></li></ul></li></ul><h3 id="其他终端命令"><a href="#其他终端命令" class="headerlink" title="其他终端命令"></a>其他终端命令</h3><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><p>查找文件：<code>find</code> 命令功能非常强大，通常在特定目录下搜索符合条件的文件。</p><ul><li>若省略路径，表示在当前文件夹下查找。</li><li><p><code>find</code> 命令可结合 <code>通配符</code> 一起使用。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [路径] -name <span class="string">"*.py"</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>软链接：建立文件的软链接，通俗理解即 PC/MacOS 上的 <code>快捷方式</code>。</p><ul><li>源文件要使用绝对路径，即便于移动链接文件 (快捷方式) 仍能正常使用。</li><li><p>没有 <code>-s</code> 选项是建立一个硬链接文件。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s 被链接的源文件 快捷方式的名称</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在 Linux 中，文件名和文件的数据是分开储存的。</p><p>  <img src="/images/illustration/Programme/2018/09/life-is-short-we-need-python_4-2.png" alt="图4-2软、硬链接访问文件数据"></p>  <center>图 4-2 软、硬链接访问文件数据</center></li></ul><h4 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h4><ul><li><p><code>tar</code> 是 Linux 中最常用的备份工具 ( <strong>打包并不压缩</strong> )，其命令格式如下：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选项 c：生成档案文件 (.tar)</span></span><br><span class="line"><span class="comment"># 选项 x：解开档案文件</span></span><br><span class="line"><span class="comment"># 选项 v：列出归档/解档的详细过程，显示进程</span></span><br><span class="line"><span class="comment"># 选项 f：指定档案文件名称，选项 f 后应该紧跟 .tar 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包文件：打包放于同一目录下</span></span><br><span class="line">tar -cvf 打包文件.tar. 被打包文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解包文件</span></span><br><span class="line">tar - xvf 打包文件 [-C 目标路径]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>tar</code> 与 <code>gzip</code> 命令结合可实现文件 <code>打包和压缩</code>，即 <code>tar</code> 只负责打包文件， <code>gzip</code> 负责压缩文件。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩文件：压缩文件放于同一目录下</span></span><br><span class="line">tar - zcvf 打包文件.tar.gz 被压缩文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩文件</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩文件到指定路径</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz [-C 目标路径]</span><br></pre></td></tr></table></figure></li></ul><h2 id="Python-基础"><a href="#Python-基础" class="headerlink" title="Python 基础"></a>Python 基础</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><h4 id="Python-优缺点"><a href="#Python-优缺点" class="headerlink" title="Python 优缺点"></a>Python 优缺点</h4><ul><li>Python 是面向对象 / 过程的语言 ( 对象和过程语言各有自己的优缺点 )：<ul><li>面向对象：由 <code>数据</code> 和 <code>功能组合而成的对象</code> 构建而成的程序。</li><li>面向过程：由 <code>过程</code> 或仅仅是 <code>可重用代码</code> 构建起来的程序。</li></ul></li></ul><h4 id="Python-应用场景"><a href="#Python-应用场景" class="headerlink" title="Python 应用场景"></a>Python 应用场景</h4><ul><li>Web 端程序：<ul><li>mod_wsgi 模块：Apache 可运行用 Python 编写 Web 程序。</li><li>常见 Web 框架：Django、TurboGears、Web2py、Zope 等。</li></ul></li><li>操作系统管理：服务器运维的自动化脚本。</li><li>科学计算：NumPy、SciPy、Matplotlib 等。</li><li>桌面端程序：PyQt、PySide、wxPython、PyGTK 等。</li><li>服务端程序：Twisted ( 支持异步网络编程和多数标准的网络协议，包括客户端和服务端 )。</li></ul><h4 id="Python-解释器"><a href="#Python-解释器" class="headerlink" title="Python 解释器"></a>Python 解释器</h4><ul><li><p>当我们编写 Python 代码时，我们得到的是一个包含 Python 代码的以 <code>.py</code> 为扩展名的文本文件。要运行代码，就需要 Python 解释器去执行 <code>xxx.py</code> 文件。</p></li><li><p>CPython  </p><ul><li>当我们从 Python <a href="https://www.python.org/downloads/" target="_blank" rel="noopener">官方网站下载</a> 并安装好 Python 3.x 后，我们就直接获得了一个官方版本的解释器：<code>CPython</code> ( C 语言开发的 )。</li><li>在命令行下运行  <code>python</code> 就是启动 CPython 解释器。</li></ul></li><li><p>iPython   </p><ul><li>iPython 是基于 CPython 之上的一个交互式解释器，即 iPython 只是在交互方式上有所增强，但是执行 Python 代码的功能和 CPython 是完全一样的。</li><li>在命令行下运行  <code>ipython</code> 即可启动 iPython 交互式解释器。</li><li><p>CPython 用 <code>&gt;&gt;&gt;</code> 作为提示符，而 IPython 用 <code>In [序号]:</code> 作为提示符。</p><p><img src="/images/illustration/Programme/2018/09/life-is-short-we-need-python_5-1.jpg" alt="图5-1Python与iPython提示符表现形式"></p><center>图 5-1 Python 与 iPython 提示符表现形式</center></li></ul></li><li><p>PyCharm</p><p>  工欲善其事，必先利其器。为帮助开发者更便捷、更高效来开发 Python 程序，一款集成开发编辑器 ( IDE ) 显得格外重要。IDE 除了快捷键、插件外，重要的是它还支持 <code>调试程序</code>。</p><blockquote><p>当然，支持 Python 程序开发的 IDE 还有很多优秀的产品：如：<a href="http://marketplace.eclipse.org/content/pydev-python-ide-eclipse" target="_blank" rel="noopener">Eclipse with PyDev</a></p></blockquote></li></ul><h4 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h4><ul><li><p>新建并运行 python 程序：<code>vi python_sample.py</code> 开始编写程序；通过 <code>python python_sample.py</code> 执行程序。以下为简单的 Python 示例：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明部分</span></span><br><span class="line"><span class="comment"># 取机器 Path 中指定的第一个 python 来执行脚本</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># python.py 文件中包含中文字符，Python2 在文件头加入以下语句 ( Python3 是默认支持的 )：</span></span><br><span class="line"><span class="comment"># -*- coding=utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码部分</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Life is short, you need python."</span>)</span><br><span class="line"></span><br><span class="line">a = 100</span><br><span class="line">A = 200</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &gt;= 100: <span class="comment"># 冒号 ":" 结尾，缩进的语句即为代码块</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(-A) <span class="comment"># Python 是大小写敏感的</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h3><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul><li><p>行注释、块注释：行注释的风格与 Linux 中 Shell 脚本的注释相同，即以 <code>#</code> 开头的注释；块注释使用三个单引号 <code>&#39;</code> 或三个双引号 <code>&quot;</code> 包裹实现。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 行注释</span></span><br><span class="line"><span class="comment"># line 1...</span></span><br><span class="line"><span class="comment"># line 2...</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">' 单引号块注释</span></span><br><span class="line"><span class="string">' line 1</span></span><br><span class="line"><span class="string">' line 2</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">" 双引号块注释</span></span><br><span class="line"><span class="string">" line 1</span></span><br><span class="line"><span class="string">" line 2</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li><code>整型</code>：可处理 <code>任意大小</code> 的整数，当然包括 <code>负整数</code>。例如 0，1，100，-8080 等。</li><li><p><code>浮点型</code>：即含有小数点的数，如 1.23，1.23e9 ( 1.23x10$^9$ )，1.23e-5 ( 1.23x10$^{-5}$ )</p><blockquote><p>1) 整数和浮点数在计算机内部存储的方式是不同的；<br>2) 整数运算永远是精确的，而浮点数运算则可能会有四舍五入的误差。</p></blockquote></li><li><p><code>字符型</code>：以单引号 <code>&#39;</code> 或双引号 <code>&quot;</code> ( 表示方式不同而已 ) 括起来的任意文本。例如 <code>&#39;(1+2)\%3 == 0&#39;</code>，或者 <code>&quot;The &#39;a&#39; is a lowercase letter of &#39;A&#39;&quot;</code>。</p></li><li><code>布尔型</code>：True / Flase 两种值。<ul><li>布尔运算：and、or、not，例如 <code>(3 &gt; 2) and (1 &gt; 2)</code>，输出 Flase。</li></ul></li><li><code>空值</code>：None，注意 None 不能理解为 0，因为 0 是有意义的，而 None 是一个特殊的空值。</li></ul><blockquote><p>Python 中的数据类型是没有大小限制的，若想定义无限大，可定义为无限大，即 <code>inf</code>。</p></blockquote><h4 id="常量变量"><a href="#常量变量" class="headerlink" title="常量变量"></a>常量变量</h4><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><ul><li>常量：例如定义 <code>PI = 3.14159</code>，其实际也是变量，只是约定俗成罢了。</li></ul><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><ul><li>形如 <code>param = value</code> 的形式赋予变量值，但不用赋变量数据类型。</li><li><p>变量的输入与输出：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">high = int( input(Please enter your high:) )</span><br><span class="line"><span class="comment"># input() 默认输出 String 类型</span></span><br><span class="line">print(<span class="string">"Your high is: %d"</span> % high);</span><br></pre></td></tr></table></figure></li></ul><h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><ul><li>一个字节，表示的最大的整数就是 255，即十进制为 255，二进制为 <code>11111111</code>。若想表示更大的整数则需要更多的字节。</li><li><p><code>ASCII</code>：127 个字符编码，即大小写字母、数字和一些特殊字符。例如大些字母 A，对应的 ASCII 为 65。</p><blockquote><p>但处理中文显然一个字节是不够的 ( 至少两个字节 )，且还不能与 ASCII 编码冲突，所以中国制定了<code>GB2312</code> 编码。  </p><p>然而，世界有上百种语言，日本把日文编到 <code>Shift_JIS</code> 里，韩国把韩文编到 <code>Euc-kr</code> 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。   </p><p>因此，Unicode 应运而生 $^{[3]}$。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p></blockquote></li><li><p><code>Unicode</code>：2 字节及以上。</p><blockquote><p>为节约空间，把 Unicode 编码转化为“可变长编码”的 UTF-8 编码。</p></blockquote></li><li><p><code>UTF-8</code>：根据数字大小编写 1 ~ 6 字节，英文字母 1 字节，汉字 3 字节 ( 生僻字符用到 4 ~ 6 字节 )。</p></li><li><p>ACSII、Unicode 与 UTF-8 的关系</p></li></ul><center>表 5-1 ACSII、Unicode 与 UTF-8 的关系</center><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">ASCII</th><th style="text-align:center">Unicode</th><th style="text-align:center">UTF-8</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">0100 0001</td><td style="text-align:center">00000000 01000001</td><td style="text-align:center">01000001</td></tr><tr><td style="text-align:center">中</td><td style="text-align:center">—</td><td style="text-align:center">01001110 00101101</td><td style="text-align:center">11100100 10111000 1010 1101</td></tr></tbody></table></div><ul><li><p>启示：计算机系统通用的字符编码工作方式，如图 5-2 所示。</p><ul><li>用记事本编辑时，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，当保存的时再把 Unicode 转换为 UTF-8 保存到文件；</li><li><p>浏览网页时，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器。</p><p><img src="/images/illustration/Programme/2018/09/life-is-short-we-need-python_5-2.png" alt="图5-2计算机系统通用的字符编码工作方式"></p><center>图 5-2 计算机系统通用的字符编码工作方式</center></li></ul></li></ul><h4 id="字符串-列表-元组-字典"><a href="#字符串-列表-元组-字典" class="headerlink" title="字符串/列表/元组/字典"></a>字符串/列表/元组/字典</h4><h5 id="字符串-Str"><a href="#字符串-Str" class="headerlink" title="字符串 Str"></a>字符串 Str</h5><ul><li><p>Python 3 中，字符串是以 Unicode 编码的。</p><ul><li>Python 的字符串类型为 String，内存中以 Unicode 表示。若在网络中传输，则可以把 string 类型的数据变成以字节为单位的 <code>bytes</code>。</li><li><p><code>encode()</code> 与 <code>decode()</code>：</p><ul><li>英文字符可用 ASCII 编码 Bytes，即 <code>&quot;ABC&quot;.encode(&quot;ascii&quot;)</code>。</li><li><p>中文字符可用 UTF-8 编码，即 <code>&quot;中国&quot;.encode(&quot;utf-8&quot;)</code>。</p><blockquote><p>含有中文的 str 无法用 ASCII 编码，因中文编码的范围超过了 ASCII 编码的范围。强制编码会抛出异常：<br><code>&#39;ascii&#39; codec can&#39;t encode characters in position 0-1: ordinal not in range(128)</code>。</p></blockquote></li></ul></li></ul></li><li><p>常用数据类型转换，见表 5-2 所示。</p></li></ul><center>表 5-2 常用数据类型转换说明表</center><div class="table-container"><table><thead><tr><th>函数格式</th><th>使用示例</th><th>描述</th></tr></thead><tbody><tr><td>int(x [,base])</td><td>int(“8”) 或 int(‘A’, base = 16)</td><td>可转换的包括 String 类型和其他数字类型，但高精度转换会丢失精度</td></tr><tr><td>float(x)</td><td>float(1) 或 float(“1”)</td><td>可转换 String 和其他数字类型，不足的位数用 0 补齐，例如 1 会变成 1.0</td></tr><tr><td>comple(real,imag)</td><td>complex(“1”) 或 complex(1,2)</td><td>第一个参数可以是 String 或者数字，第二个参数只能为数字类型，第二个参数没有时默认为 0</td></tr><tr><td>str(x)</td><td>str(1)</td><td>将数字转化为 String</td></tr><tr><td>repr(x)</td><td>repr(Object)</td><td>返回一个对象的 String 格式</td></tr><tr><td>eval(str)</td><td>eval(“12+23”)</td><td>执行一个字符串表达式，返回计算的结果，如例子中返回 35</td></tr><tr><td>tuple(seq)</td><td>tuple((1,2,3,4))</td><td>参数可以是元组、列表或字典。若为字典时，返回字典的 key 组成的集合</td></tr><tr><td>list(s)</td><td>list((1,2,3,4))</td><td>将序列转变成一个列表，参数可为元组、字典、列表。若为字典时，返回字典的 key 组成的集合</td></tr><tr><td>set(s)</td><td>set([‘b’, ‘r’, ‘u’, ‘o’, ‘n’])或者set(“asdfg”)</td><td>将一个可迭代对象转变为可变集合且去重复，返回结果可以用来计算差集 <code>x - y</code>、并集 <code>x l y</code>、交集 <code>x &amp; y</code></td></tr><tr><td>frozenset(s)</td><td>frozenset([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</td><td>将一个可迭代对象转变成不可变集合，参数为元组、字典、列表等</td></tr><tr><td>chr(x)</td><td>chr(0x30)</td><td>chr() 用一个范围在 range (0～255) 内的整数作参数，返回一个对应的字符。返回值是当前整数对应的 ASCII 字符。</td></tr><tr><td>ord(x)</td><td>ord(‘a’)</td><td>返回对应的 ASCII 数值，或者 Unicode 数值</td></tr><tr><td>hex(x)</td><td>hex(12)</td><td>把整数 x 转换为 16 进制字符串</td></tr><tr><td>oct(x)</td><td>oct(12)</td><td>把整数 x 转换为 8 进制字符串</td></tr></tbody></table></div><ul><li><p>字符串输入和输出：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = input(<span class="string">"Enter your name:"</span>)</span><br><span class="line">age = int( input(<span class="string">"Enter your age:"</span>) )</span><br><span class="line">print(<span class="string">"name: %s, age: %d"</span> % (name, age))</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>组成字符串的方式：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"Hello"</span></span><br><span class="line">str2 = <span class="string">"World"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str3 组装成 "HelloWorld"</span></span><br><span class="line">str3 = str1 + str2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组装成 "===HelloWorld==="，此方式常用拼凑字符串</span></span><br><span class="line"><span class="string">"===%s==="</span> % (str1 + str2)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>字符串下标与取值：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">array = <span class="string">"ABCDE"</span></span><br><span class="line"></span><br><span class="line">print( array[<span class="number">0</span>] ) <span class="comment"># 输出 A</span></span><br><span class="line">print( array[<span class="number">4</span>] ) <span class="comment"># 输出 E</span></span><br><span class="line">print( array[<span class="number">-1</span>] ) <span class="comment"># 输出 E</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片</span></span><br><span class="line">print( array[<span class="number">0</span>:<span class="number">3</span>] ) <span class="comment"># 输出 ABC</span></span><br><span class="line">print( array[<span class="number">0</span>:<span class="number">-1</span>] ) <span class="comment"># 输出 ABCD</span></span><br><span class="line">print( array[<span class="number">0</span>:] ) <span class="comment"># 输出 ABCDE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 即以 2 为步进距离，从下标 0 开始取值至末尾，输出 ACE</span></span><br><span class="line">print( array[<span class="number">0</span>::<span class="number">2</span>] )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 即以 -1 为步进距离，从末尾开始取值至开端，逆序输出</span></span><br><span class="line">print( array[<span class="number">-1</span>::<span class="number">-1</span>] )</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>字符串常见操作</p><ul><li><p><code>find(s)</code> 与 <code>index(s)</code>：从目标字符串中寻找子串，找到会返回子串的起始下标；若找不到则返回 <code>-1</code>。index() 找到目标的情况和 find() 相同，找不到目标则会抛出异常。</p><blockquote><p>当然还有 rfind(s) 和 rindex()，即从右端开始寻找子字符串。</p></blockquote></li><li><p><code>count(str, start, end)</code>：即在目标字符串 <code>myStr</code>，求得 <code>str</code> 在位置 start 和 end 之间出现的次数。</p><blockquote><p>例如：<code>myStr.count(str, start = 0, end = len(myStr))</code>，</p></blockquote></li><li><p><code>replace(原始字符串, 目标字符串)</code> 或 <code>replace(原始字符串, 目标字符串，替代次数)</code>：</p><blockquote><p>例如：<code>myStr.replace(&quot;world&quot;, &quot;python&quot;)</code></p></blockquote></li><li><p><code>split(str)</code>：根据 <code>str</code> 把原字符串切开。</p></li><li><p><code>splitlines(str)</code>：将字符串中的每一行切割开来。</p><blockquote><p>re.split(正则表达式, 目标字符串)，根据正则表达式切割字符。</p></blockquote></li><li><p><code>capitalize()</code> 与 <code>title()</code>：前者是把字符串中的第一个字符转为大写字母，后者是把字符串中每个单词的首字母转为大写。</p></li><li><code>startsWith(str)</code> 与 <code>endsWith(str)</code>：前者是判断目标字符是否以字符串 str 开头，后者则是判断目标字符是否以字符串 str 结尾。</li><li><code>lower()</code> 与 <code>upper()</code>：前者是将目标字符串全转为小写字母，后者是将字符串全转为大写字母。</li><li><code>rstrip()</code>、<code>lstrip()</code> 与 <code>strip()</code>：去除字符串左边、右边或者两端的空白字符。</li><li><code>partition(str)</code>：以 str 为中心，将目标字符串划分成左、中 ( str 本身 )、右三部分的字符串。</li><li><code>isalpha()</code>、<code>isdigit()</code> 与 <code>isalnum()</code>：分别用于判断是否为字符，是否为数字和是否全为数字。</li><li><p><code>join()</code>：例如 <code>str.join(array)</code>，即使用 str 将列表 array 的内容拼接起来。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]</span><br><span class="line">str1 = <span class="string">'&amp;'</span></span><br><span class="line"><span class="comment"># str2 被组装成 A&amp;B&amp;C，即将 str1 组装到字符数组中</span></span><br><span class="line">str2 = str1.join(array)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="列表-List"><a href="#列表-List" class="headerlink" title="列表 List"></a>列表 List</h5><ul><li>定义一个列表：<code>list = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code> 或者 <code>student = [&#39;lucy&#39;, 25, &#39;female&#39;]</code>。</li><li>列表的增删改查 ：<ul><li>增加：<br>1) 在列表尾部追加元素：<code>list.append(&#39;D&#39;)</code><br>2) 自定义插入位置：<code>list.insert(位置，添加的内容)</code><br>3) 往一列表中添加另一个列表：<code>student + list</code> 或者 <code>student.extend(list)</code>  </li><li>删除：<br>1) 出栈：<code>list.pop()</code> / 入栈：<code>list.append()</code><br>2) 根据下标来删除：<code>del list[0]</code>，清空列表 <code>del list[0::1]</code>  </li><li>查询：<br>1) <code>(&#39;B&#39; in list)</code> 结果为 Ture<br>2) <code>(&#39;D&#39; not in list)</code> 结果为 Ture</li></ul></li></ul><h5 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h5><ul><li><p>有序列表元组 ( Tuple )，与 List 不同，<code>Tuple 一旦初始化就不能修改</code>。</p><blockquote><p>定义一些常量参数时可用 Tuple。</p></blockquote></li><li><p>定义：<code>tuples = (&#39;A&#39;, &#39;B&#39;, &#39;C&#39;)</code>。</p></li><li>歧义：<code>tuple = (1)</code> 相当于 <code>tuple = 1</code>；<code>tuple(-1, )</code> 才是元组列表。</li><li><p>事实： Tuple 中存储的是 <code>引用</code>。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tuple = (<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'A'</span>, <span class="string">'B'</span>])</span><br><span class="line">tuple[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">'X'</span></span><br><span class="line">tuple[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'Y'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事实上，'A' 和 'B' 被改变为 'X' 和 'Y'</span></span><br><span class="line"><span class="comment"># 即 Tuple 定义是不变的，只是 Tuple 上存储的 List 为引用</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>再议不可变对象：replace() 并没有改变字符串的内容，我们理解 <code>str</code> 是变量，<code>abc</code> 是字符串对象。replace() 相当于创建了新的字符串对象 <code>Abc</code>。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">'abc'</span></span><br><span class="line">print( str.replace(<span class="string">'a'</span>, <span class="string">'A'</span>) ) <span class="comment"># 输出 Abc</span></span><br><span class="line">print(str) <span class="comment"># 输出 abc</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="字典-Dict"><a href="#字典-Dict" class="headerlink" title="字典 Dict"></a>字典 Dict</h5><ul><li>字典 ( Dict )，其他语言中又称 Map，使用键值 ( key-value ) 存储。</li><li>定义：<code>dict = {&#39;name&#39;: &#39;Lucy&#39;, &#39;age&#39;：25, &#39;gender&#39;: &#39;female}</code>。</li><li>字典的增删改查：<ul><li>增加：<code>dict[&#39;high&#39;] = 175</code>，若对应键值存在即修改的效果。</li><li>删除：<code>dict.pop(&#39;high&#39;)</code> / <code>del dict[&#39;high&#39;]</code></li><li>查询：<code>dict.get(&#39;name&#39;)</code>，若找不到对应键值则抛出异常。</li></ul></li></ul><h5 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合 Set"></a>集合 Set</h5><ul><li>Set 与 Dict 类似，是一组 key 的集合，但不存储 value。</li><li><p>Set 可看成数学意义上的 <code>无序</code> 和 <code>无重复</code> 元素的集合。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print( set([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]) ) <span class="comment"># 输出 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;condition1&gt;:</span><br><span class="line">    &lt;action1&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;condition2&gt;:</span><br><span class="line">    &lt;action2&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> &lt;condition3&gt;: <span class="comment"># if 嵌套</span></span><br><span class="line">        &lt;action3&gt;</span><br></pre></td></tr></table></figure><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><ul><li><p><code>For</code> 循环与 <code>While</code> 循环</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For 循环</span></span><br><span class="line">names = [<span class="string">'LiMing'</span>, <span class="string">'ZhangWei'</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names</span><br><span class="line">    print(name)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># While 循环</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>( i&lt;<span class="number">100</span> ):</span><br><span class="line">    sum += <span class="number">1</span></span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p><code>Break</code> 与 <code>Continue</code></p><ul><li>Break：终止 ( 跳出 ) 循环。</li><li>Continue：中断本次循环。</li></ul></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><ul><li><p>定义函数使用 <code>def</code> 语句，依次写 <code>函数名</code>、<code>括号</code>、( 还可以包括 <code>参数</code> )、<code>冒号</code>。然后是 <code>函数体</code> ( 需缩进编写 )。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FuncName</span><span class="params">(param)</span>:</span></span><br><span class="line">    &lt;action&gt;</span><br><span class="line">    <span class="keyword">return</span> [返回参数]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>空函数：模块化设计，即先架构后编码。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FuncName</span><span class="params">(param)</span>:</span>   </span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># 占位符：暂不书写代码逻辑</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>返回多个值：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    y = y + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x, y</span><br><span class="line">    </span><br><span class="line">x, y = move(<span class="number">100</span>, <span class="number">100</span>) <span class="comment"># 其实返回的是一个 Tuple，即 (x, y)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><ul><li><p>默认参数 ( 缺省参数 )：最大好处是降低调用函数难度，类似注册时，多数用户只关心核心的信息，即其余信息设置为默认值。</p><blockquote><p>注意：定义默认参数时，必须指向不变对象。如 n = 2，不能 n = m ( m 为变量 )</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n = <span class="number">2</span>)</span>:</span></span><br><span class="line">s = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(n &gt; <span class="number">0</span>):</span><br><span class="line">    n = n - <span class="number">1</span></span><br><span class="line">    s = s * x</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">print( power(<span class="number">5</span>) ) <span class="comment"># 输出 25</span></span><br><span class="line">print( power(<span class="number">5</span>, <span class="number">3</span>) ) <span class="comment"># 计算 5 的 3 次方，输出 125</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>可变参数：顾名思义，可变参数就是传入的参数个数是可变的。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># def calculator(numbers)，即理解 numbers 为一个 tuple</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculator</span><span class="params">(*numbers)</span>:</span> </span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于 calculator( (1, 3, 5, 7) )</span></span><br><span class="line">print( calculator(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>) ) <span class="comment"># 输出 84</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>关键字参数：<br>  <code>可变参数</code> 允许你传入 0 个或任意个参数，这些参数在函数调用时自动组装为一个 <code>元组</code> ( Tuple )。<br>  <code>关键字参数</code> 允许你传入 0 个或任意个参数，这些关键字参数在函数内部自动组装成为一个 <code>词典</code> ( Dict )。  </p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span> </span><br><span class="line">    print(<span class="string">' name:'</span>, name, <span class="string">' age:'</span>, age, <span class="string">' others:'</span>, kw)</span><br><span class="line"></span><br><span class="line">person(<span class="string">'Lucy'</span>, <span class="number">35</span>, city = <span class="string">'Guangzhou'</span>, gender = <span class="string">'M'</span>)</span><br><span class="line"><span class="comment"># 输出  name: Lucy  age: 35  others: &#123;'city': 'Guangzhou', 'gender': 'M'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然，我们可先组装词典 dict，然后把该 dict 转换为关键字参数传进去</span></span><br><span class="line">extra = &#123;<span class="string">'city'</span>: <span class="string">'Guangzhou'</span>, <span class="string">'gender'</span>: <span class="string">'M'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字典中的元素，拆分成独立的 Key-Value 键值，引用时前缀也要加 "**"</span></span><br><span class="line">person(<span class="string">'Jack Ma'</span>, <span class="number">50</span>, **extra)</span><br><span class="line"><span class="comment"># 输出 name: Jack Ma  age: 50  others: &#123;'city': 'Guangzhou', 'gender': 'M'&#125;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>参数组合：Python 中定义函数，可多种参数组合使用，但必须满足一下参数定义顺序：<code>必选参数</code>、<code>默认参数</code>、<code>可变参数</code>、<code>命名关键字</code> 和 <code>关键字参数</code>。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b, c = <span class="number">0</span>, *args, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">' a='</span>, a, <span class="string">' b='</span>, b, <span class="string">' c='</span>, c, <span class="string">' args='</span>, args, <span class="string">' kw='</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 a=1 b=2 c=3 args=('a', 'b') kw=&#123;'x'=99&#125;</span></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'x'</span>=<span class="number">99</span>)</span><br></pre></td></tr></table></figure></li><li><p>结合 <code>tuple</code> 和 <code>dict</code>：即通过类似 <code>func(*args, **kw)</code> 形式调用函数。参数虽可自由组合使用，但不要组合太复杂，以造成可理解性较差的结果。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">kw = &#123;<span class="string">'x'</span> = <span class="number">5</span>, <span class="string">'y'</span> = <span class="number">6</span>&#125;</span><br><span class="line">func(*args, **kw)</span><br></pre></td></tr></table></figure></li></ul><h4 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h4><ul><li><p>函数内部可以调用其他函数。若一个函数内部调用了其自身，即该函数为 <code>递归函数</code>。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li>递归的过深调用会导致栈溢出。可通过 <code>尾递归</code> 优化。</li><li><p>尾递归优化：解决递归调用栈溢出的方法，即函数返回时调用本身，并且 return 语句不能包含表达式。</p><ul><li>区别上述的 fact(n) 函数，由于 <code>return n * fact(n - 1)</code> 引入了乘法表达式，即非尾递归。</li><li>而 <code>return fact_iter(num - 1, num * product)</code> 仅仅返回函数本身。</li><li><p>这样，编译器 / 解释器就可对尾递归做优化，即使递归本身调用 n 次，都只占用一个栈帧，不会出现栈溢出的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact_iter</span><span class="params">(num, product)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line">    <span class="keyword">return</span> fact_iter(num <span class="number">-1</span>, num * product)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><ul><li><p>切片操作符：在 List 中指定 <code>索引范围</code> 的操作。<br>  索引范围具体为： <code>起始位置:结束位置:步进</code> ，注意步进数 ( 默认为 1，不能为 0 )。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 [11, 22, 33]，即从小标为 0 开始，步进为 1，取前 3 个元素</span></span><br><span class="line">print( list[<span class="number">0</span>:<span class="number">3</span>:<span class="number">1</span>] )</span><br></pre></td></tr></table></figure></li><li><p>倒数切片：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 ['A', 'B', 'C', 'D']，即从下标为 0 开始，切片至倒数第一个元素 (不含其本身)</span></span><br><span class="line">print( list[<span class="number">0</span>:<span class="number">-1</span>] )</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>字符串切片：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">'ABCDE'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 ACE，即对字符串中所有字符作用，每隔两位取值</span></span><br><span class="line">print( str[::<span class="number">2</span>] )</span><br></pre></td></tr></table></figure></li></ul><ul><li>注意：<code>Tuple</code> 也是一种 <code>List</code>，唯一不同的是 Tuple 不可变，因此 Tuple 不可用切片操作。</li></ul><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><ul><li><p>迭代：给定一个 List 或 Tuple，通过 For 循环遍历这个 List 或 Tuple。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> str <span class="keyword">in</span> list:</span><br><span class="line">    print(str) <span class="comment"># 输出 ABCDE</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>enumerate</code> 函数可以把一个 list 变成 <code>索引-元素树</code>，这样就可以在 For 循环中同时迭代 <code>索引</code> 和 <code>元素本身</code>。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate(list):</span><br><span class="line">    print(i, value)</span><br></pre></td></tr></table></figure></li></ul><h4 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h4><ul><li><p>列表生成式：List Comprehensions，用于创建 List 的生成式。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">list1 = []</span><br><span class="line"></span><br><span class="line">list1 = [x**<span class="number">2</span> <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line"><span class="comment"># 输出 1x1，2x2，3x3, ..., 9x9</span></span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">等价于：</span></span><br><span class="line"><span class="string">for num in range(1, 10):</span></span><br><span class="line"><span class="string">    list1.append(num ** 2)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># for 循环与 if 判断配合，例如取得 10 以内的偶数，求其平方数</span></span><br><span class="line">list2 = [ num**<span class="number">2</span> <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>) <span class="keyword">if</span> num%<span class="number">2</span> == <span class="number">0</span> ]</span><br><span class="line"><span class="comment"># 输出 2x2, 4x4, 6x6, 8x8</span></span><br><span class="line">print(list2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两层 for 循环</span></span><br><span class="line">list3 = [ m+str(n) <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>) ]</span><br><span class="line"><span class="comment"># 输出 ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']</span></span><br><span class="line">print(list3)</span><br><span class="line"></span><br><span class="line">list4 = [ m*n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>) ]</span><br><span class="line"><span class="comment"># 输出 ['A', 'AA', 'AAA', 'B', 'BB', 'BBB', 'C', 'CC', 'CCC']</span></span><br><span class="line">print(list4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前目录下所有文件和目录名</span></span><br><span class="line"><span class="keyword">import</span> os <span class="comment"># 导入 os 模块</span></span><br><span class="line">list = [d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>)]</span><br></pre></td></tr></table></figure></li></ul><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><ul><li>引入：<code>列表生成式</code>，可直接创建一个列表。但受到内存限制，列表容量肯定是有限的。例如：我们需要一个包含 100 万个元素的列表 ( 列表中的元素按照某种算法推算出来 )，直接创建是不太现实的，那么我们是否可通过某种过程，实现 <code>动态推算</code> 并 <code>输出元素</code> ？ </li><li>Generator：<code>生成器</code>，即不用一步到位创建 list 对象，而是通过循环过程中不断推算出后续的元素。在 Python中，把这种一边循环一边计算的机制称作 <code>Generator</code>。</li><li><p>创建 Generator：把列表生成式的 <code>[]</code> 改成 <code>()</code> 即可。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 受到内存限制，运行过程中可能会崩掉</span></span><br><span class="line">list = [ x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, int(<span class="number">10e10</span>)) ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单生成器：</span></span><br><span class="line">generator = ( x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, int(<span class="number">10e10</span>)) )</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> generator:</span><br><span class="line">    print(n)</span><br><span class="line"></span><br><span class="line"><span class="string">"""    </span></span><br><span class="line"><span class="string">" 简单示例：</span></span><br><span class="line"><span class="string">" 带 yield 的 Generator 函数</span></span><br><span class="line"><span class="string">" 1) 在每次循环时都执行，遇到 yield 语句返回</span></span><br><span class="line"><span class="string">" 2) 再次执行时，从上次返回的 yield 语句处继续执行</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">odd</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'First Return: '</span>)</span><br><span class="line">    <span class="keyword">yield</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    print(<span class="string">'Second Return:'</span>)</span><br><span class="line">    <span class="keyword">yield</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'Third Return:'</span>)</span><br><span class="line">    <span class="keyword">yield</span> &#123;<span class="string">'key'</span>: <span class="string">'value'</span>&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> odd():</span><br><span class="line">    print(n)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Fibonacci 数列：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(times)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; times:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        (a, b) = (b, a+b)</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'done'</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fibonacci(<span class="number">10</span>):</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure></li></ul><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul><li>可用于 for 循环的数据类型：<ul><li>集合数据类型：list、tuple、dict (字典)、set、str (字符串)</li><li>Generator 生成器和带 <code>yield</code> 的 Generator 函数</li></ul></li><li><p>可用于 for 循环的对象统称为可迭代对象 <code>Iterable</code>。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 isinstance() 判断一个对象是否为 Iterable 对象</span></span><br><span class="line">form collections <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line">isinstance([], Iterable) <span class="comment"># True</span></span><br><span class="line">isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>)), Iterable) <span class="comment"># True</span></span><br><span class="line">isinstance(<span class="number">100</span>, Iterable) <span class="comment"># False</span></span><br></pre></td></tr></table></figure></li><li><p>生成器是 <code>Iterator</code> 对象；List、Dict、Str 虽然是 Iterable 对象，但却不是 <code>Iterator</code>。<br>  我们可以通过 <code>iter()</code> 函数，把 List、Dict、Str 等 Iterable 转换达成 <code>Iterator</code>。</p><blockquote><p>Python 的迭代器 ( Iterator ) 对象表示的是一个数据流，即 Iterator 对象可被 <code>next()</code> 函数调用并不断返回下一个数据，直至没有数据时抛出 <code>StopIteration</code> 异常。</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isinstance(iter([]), Iterator) <span class="comment"># True</span></span><br><span class="line">isinstance(iter(<span class="string">'abc'</span>), Iterator) <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><ul><li>函数：<ul><li><code>模块化编程</code>，即把大段功能代码拆分、封装成模块，通过层层调用，把复杂任务解构成简单任务。</li><li>这种分解称之为 <code>面向过程</code> 的程序设计。</li><li>函数是面向过程程序设计的 <code>基本单元</code>。</li></ul></li><li>函数式编程：<ul><li>就是一种抽象程序很高的 <code>编程范式</code>；</li><li>纯粹的函数式编程语言编写的函数没有变量；</li><li>函数式编程的特点：允许函数作为 <code>参数</code>，作为另一函数的 <code>输入</code>。</li></ul></li></ul><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><ul><li><p>变量可指向函数：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接调用函数</span></span><br><span class="line">x = abs(<span class="number">-10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量可指向函数</span></span><br><span class="line">f = abs</span><br><span class="line">x = f(<span class="number">-10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x 的结果都为 10</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>函数名也是变量：函数名其实就是指向函数的变量。</p><blockquote><p>注意：<br>1) 而在实际编码当中，绝对不能这样写，只是为了说明函数名也是变量。<br>2) 若需恢复 abs 函数，请重启 Python 交互环境。  </p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">abs = <span class="number">10</span></span><br><span class="line">abs(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抛出异常</span></span><br><span class="line"><span class="comment"># 即 abs 已指向一个整数 10，而不是指向求绝对值的函数。  </span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'int'</span> object <span class="keyword">is</span> <span class="keyword">not</span> callble</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>传入函数：一个函数接收另一个函数作为参数，称为 <code>高阶函数</code>。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y, f)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> f(x) + f(y)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 调用 add(-5, 6 abs) 时，计算的过程为：</span></span><br><span class="line"><span class="comment"># x = -5</span></span><br><span class="line"><span class="comment"># y = -6</span></span><br><span class="line"><span class="comment"># f = abs</span></span><br><span class="line"><span class="comment"># f(x) + f(y)</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h5><ul><li>Python 内建了 map() 和 reduce() 函数。</li><li><p>Map / Reduce 的概念 ：</p><ul><li>MapReduce 是一种编程模型，是 <code>处理</code> 和 <code>生成</code> 大型数据集的相关实现。</li><li><p>用户指定一映射函数 <code>map()</code> 处理键/值对，以生成一组<code>中间键/值对</code>；同时也指定 <code>reduce()</code> 函数用以 <code>合并</code> 含相同中间键所关联的所有中间值。</p><blockquote><p>为了更加透彻理解 MapReduce，可研读  Google 关于 MapReduce 的论文：<br><code>MapReduce: Simplified Data Processing on Large Clusters</code> $^{[4]}$。</p></blockquote></li></ul></li></ul><h6 id="Map-函数"><a href="#Map-函数" class="headerlink" title="Map 函数"></a>Map 函数</h6><ul><li><p>map() 函数：其接收 <code>两个参数</code>，第一个是 <code>函数</code>，第二个是 <code>Iterable</code>。即 map 将传入的 <code>函数</code> 依次 <code>作用</code> 到序列的 <code>每个元素</code>，并把结果作为新的 <code>Iterator</code> 返回。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例 1：有一个函数 f(x) = x*x，将其作用于一个 list = [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1) map() 函数</span></span><br><span class="line">r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">print(list(r)) <span class="comment"># 输出 [1, 4, 9, 16, 25]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) 不需要 map() 函数的等价写法</span></span><br><span class="line">list = []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    list.append( f(n) )</span><br><span class="line">print(list) <span class="comment"># 输出 [1, 4, 9, 16, 25]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例 2：map 作为高阶函数，事实上它把运算规则抽象了，如把 list 中数字转字符串</span></span><br><span class="line">list( map(str, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) ) <span class="comment"># 输出 ['1', '2', '3', '4', '5']</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="Reduce-函数"><a href="#Reduce-函数" class="headerlink" title="Reduce 函数"></a>Reduce 函数</h6><ul><li><p>reduce() 函数：其接收 <code>两个参数</code>，第一个是 <code>函数</code>，第二个是 <code>Iterable</code>。即 reduce 把结果继续和序列的 <code>下一个元素</code> 做 <code>累积计算</code>。</p><blockquote><p>reduce(f, [x1, x2, x3, x4]) 等价于 f( f( f(x1, x2), x3 ), x4 )</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">print( reduce(add, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) )</span><br></pre></td></tr></table></figure></li><li><p>当然，上述的实例只是为了描述原理而设定，下面将结合 map() 与 reduce() 举例：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一计算公式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一字符转数字的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">char2num</span><span class="params">(s)</span>:</span></span><br><span class="line">    digits = &#123;<span class="string">'0'</span>: <span class="number">10</span>, <span class="string">'1'</span>: <span class="number">20</span>, <span class="string">'2'</span>: <span class="number">30</span>, <span class="string">'3'</span>: <span class="number">40</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> digits[s]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># map/reduce 实现处理与计算的功能</span></span><br><span class="line">print( reduce(fn, map(char2num, <span class="string">'0123'</span>)) )</span><br></pre></td></tr></table></figure></li></ul><h5 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h5><ul><li>Python 内建了 <code>filter()</code> 函数，用于过滤序列。</li><li><p>filter() 函数：接收 <code>两个参数</code>，一个是 <code>函数</code>，另一个是 <code>序列</code>。即 filter 把传入的函数作用于每个元素，然后根据返回值是 <code>True/False</code> 决定是否 <code>保留/丢弃</code> 该元素。</p><blockquote><p>filter() 函数返回的是一个 Iterator，即一个惰性序列，故需要强迫 filter() 完成计算结果，如 list() 函数获得所有结果。</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在一个 list 中，删掉偶数，只保留奇数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isOdd</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出 [1, 3, 5]</span></span><br><span class="line">list( filter(isOdd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把一个序列中的空字符剔除</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rejectBlankStr</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s <span class="keyword">and</span> s.strip()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出 ABC</span></span><br><span class="line">list( filter(rejectBlankStr, [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">''</span>, <span class="keyword">None</span>, <span class="string">'C'</span>]) )</span><br></pre></td></tr></table></figure></li></ul><h5 id="Sorted"><a href="#Sorted" class="headerlink" title="Sorted"></a>Sorted</h5><ul><li><p>排序算法：排序的核心是 <code>比较两元素的大小</code>。若是数字则直接比较；但比较的若是字符串或两个字典，则比较过程需通过函数抽象实现。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出 [-6, 2, 12, 24, 36]</span></span><br><span class="line">print( sorted( [<span class="number">36</span>, <span class="number">24</span>, <span class="number">-6</span>, <span class="number">12</span>, <span class="number">2</span>] ) )</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>sorted()</code> 也是一高阶函数，可接收一个 key 函数来自定义排序:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出 [2, -6, 12, 24, 36]</span></span><br><span class="line">print( sorted([<span class="number">36</span>, <span class="number">24</span>, <span class="number">-6</span>, <span class="number">12</span>, <span class="number">2</span>], key = abs) )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略大小写，实现字符串排序</span></span><br><span class="line"><span class="comment"># 实现字符串的比较是根据 ASCII 实现比较的</span></span><br><span class="line">print( sorted([<span class="string">'Bob'</span>, <span class="string">'Lucy'</span>, <span class="string">'Zoo'</span>, <span class="string">'Danny'</span>], key = str.lower) ) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行反向排序，可传入第三个参数实现</span></span><br><span class="line">print( sorted([<span class="string">'Bob'</span>, <span class="string">'Lucy'</span>, <span class="string">'Zoo'</span>, <span class="string">'Danny'</span>], key = str.lower, reverse = <span class="keyword">True</span>) )</span><br></pre></td></tr></table></figure></li></ul><h4 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h4><h5 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h5><ul><li><p>函数作为返回值：高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通常情况实现一个可变参数的求和</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcSum</span><span class="params">(*args)</span>:</span></span><br><span class="line">    ax = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">        ax = ax + n</span><br><span class="line">    <span class="keyword">return</span> ax</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 若不想立刻求和，可不返回求和结果，而是求和函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazySum</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></span><br><span class="line">        ax = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        <span class="keyword">return</span> ax</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 lazySum() 时，返回函数而不是结果</span></span><br><span class="line">f = lazySum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 f，才真正计算求和的结果</span></span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当每次调用 lazySum() 时，都会返回一个新的函数，既使传入参数相同</span></span><br><span class="line">f1 = lazySum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">f2 = lazySum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">print( f1 == f2 ) <span class="comment"># 输出 False</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><ul><li>注意到上述例子返回的函数在其定义内部引用了局部变量 <code>args</code>，故当一个函数返回一个函数后，其内部的局部变量还被新函数引用。</li><li><p>注意返回的函数并没有立刻执行，而是调用了 <code>f()</code> 才执行。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> i ** <span class="number">2</span></span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line">    </span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line"><span class="comment"># 输出 9::9::9</span></span><br><span class="line">print( str(f1()) + <span class="string">'::'</span> + str(f2()) + <span class="string">'::'</span> + str(f3()) ) </span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">" 实际结果为：f1() --&gt; 9，f2() --&gt; 9, f3() --&gt; 9</span></span><br><span class="line"><span class="string">" 全部结果都为 9，原因在于返回的函数引用了变量 i，但它并非立刻执行</span></span><br><span class="line"><span class="string">" 需等到 3 个函数都返回时，它们所引用的变量 i 已经变成了 3，故最终结果是 9</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若需引用循环的变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> j * j</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    </span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        fs.append( f(i) ) <span class="comment"># f(i) 立刻执行，i 的当前值被传入 f()</span></span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line">    </span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line"><span class="comment"># 输出 1::4::9</span></span><br><span class="line">print( str(f1()) + <span class="string">'::'</span> + str(f2()) + <span class="string">'::'</span> + str(f3()) )</span><br></pre></td></tr></table></figure>  <div class="note danger"><p>返回闭包时牢记一点：返回函数不要引用任何循环变量，或后续会发生变化的变量。</p></div></li></ul><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><ul><li>当函数作为 <code>传入参数</code> 时，我们不需要显式地定义函数，直接传入匿名函数更便捷。</li><li><p>关键字 <code>lambda</code> 表示匿名函数，冒号前面表示传入参数，后面为返回值 ( 一般为表达式运算后的结果 )，如 <code>lambda x, y : x+y</code></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 map() 函数为例</span></span><br><span class="line"><span class="comment"># 输出 [1, 4, 9, 16, 25]</span></span><br><span class="line">print( list(map(<span class="keyword">lambda</span> x : x ** <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])) )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数实际为：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>匿名函数有一好处，即不必担心 <code>函数名冲突</code>。此外，匿名函数也是一个函数对象，可把匿名函数赋值给一个变量，再利用变量来调用。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x : x ** <span class="number">2</span></span><br><span class="line">print( f(<span class="number">5</span>) ) <span class="comment"># 输出 25</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>匿名函数作为返回值返回：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span>: x * x + y * y</span><br></pre></td></tr></table></figure></li></ul><h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><ul><li><p>对于装饰器章节，除了廖雪峰老师的教程外，还可以参考程序员大咖的推文搭配学习。</p><blockquote><p>程序员大咖：<a href="https://mp.weixin.qq.com/s/0nZTAjeftR3Xa9T9TbQc-g" target="_blank" rel="noopener">Python 装饰器的诞生过程</a> </p></blockquote></li></ul><h4 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h4><ul><li><p>例：int() 函数可把字符串转为整数，当且仅当传入字符串时，int() 函数默认按照 <code>10 进制转换</code>。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">print( int(<span class="string">'12345'</span>) ) <span class="comment"># 输出 12345</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># int() 函数提供额外 base 参数，默认值为 10</span></span><br><span class="line"><span class="comment"># 若传入 base 参数即可做 N 进制转换 ( N 进制转到 10 进制 )</span></span><br><span class="line">print( int(<span class="string">'10'</span>, base = <span class="number">8</span>) ) <span class="comment"># 输出 8</span></span><br><span class="line">print( int(<span class="string">'A'</span>, base = <span class="number">16</span>) ) <span class="comment"># 输出 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若我们要转换大量二进制字符串，则可通过定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">int2</span><span class="params">(x, base = <span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(x, base)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 这样转换二进制就非常便捷了</span></span><br><span class="line">print( int2(<span class="string">'10000000'</span>) ) <span class="comment"># 输出 128</span></span><br><span class="line">print( int2(<span class="string">'10101010'</span>) ) <span class="comment"># 输出 170</span></span><br></pre></td></tr></table></figure></li><li><p>其实 <code>functools.partial</code> 就是帮助我们创建一个偏函数，即其作用就是把一个函数的某些参数固定住 ( 设置默认值 )，返回一个新函数。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">int2 = functools.partial(int, base = <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>创建偏函数时，实际可接收 <code>函数对象</code>、<code>*args</code> 和 <code>**kw</code> 这三个参数。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int2 = functools.partial(int, base = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于：</span></span><br><span class="line">args = <span class="string">'10001000'</span></span><br><span class="line">kw = &#123;<span class="string">'base'</span>: <span class="number">2</span>&#125;</span><br><span class="line">int(*args, **kw)</span><br></pre></td></tr></table></figure></li></ul><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><p>一个 <code>.py</code> 文件称之为一个模块 (Module)，模块可避免函数名和变量名冲突。</p><blockquote><p>⚠️ 尽量不与 Python 内置函数名称相冲突，详细可参考 Python 标准函数库 $^{[6]}$。</p></blockquote></li><li><p>按目录来组织模块的方法，称为包 (Package)，可避免模块名称的冲突。</p><blockquote><p>⚠️ 创建模块的名称不能和 Python 自带的模块名称相冲突。例如系统自带 <code>sys</code> 模块。</p></blockquote><ul><li><code>__init__.py</code> 该文件必须存在，否则 Python 就把当前 目录当作普通目录，而不是一个包了。</li><li><code>__init__.py</code> 可以是空文件，也可含有代码。</li><li><code>samplye.py</code> 的模块名称为 <code>mypython.sample</code>。</li><li><p><code>__init__.py</code> 的模块名称为 <code>mypython</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mypython</span><br><span class="line">  ├─ __init__.py</span><br><span class="line">  ├─ sample.py</span><br><span class="line">  └─ example.py</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h4><ul><li><p>以内建的 <code>sys</code> 模块为例，编写 <code>sample</code> 模块:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    args = sys.argv</span><br><span class="line">    <span class="keyword">if</span> len(args) &gt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">for</span> str <span class="keyword">in</span> args:</span><br><span class="line">            print(<span class="string">'%s'</span> % str)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Empty paramter'</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>作用域：在一模块中，我们可能会定义很多函数和变量。或许我们有这样的需求：有的函数和变量仅希望是在模块内部使用。Python 中通过 <code>_</code> 前缀实现的。</p><ul><li><p>正常的函数和变量名是公开的 (public)，可被直接引用。例如，<code>abc</code>、<code>x1</code>、<code>PI</code> 等。</p></li><li><p>非公开的函数和变量 (private)，不应该被直接引用。例如 <code>_xxx</code>、<code>__xxx</code>。</p><blockquote><p><code>不应该</code> 被直接引用，而不是不能被直接引用，因为 Python 并没有一种方法可以完全限制访问 private 函数或者变量。</p></blockquote></li><li><p>使用 <code>private</code> 函数，实现代码封装和抽象的方法：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__sayHello</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Hello'</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span><span class="params">(name)</span>:</span></span><br><span class="line">    __sayHello(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">greeting(<span class="string">'Bob'</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h4><ul><li>Python 中，安装第三方模块是通过包管理工具 <code>pip</code> 完成的。 <ul><li>若是 <code>Mac/Linux</code> 用户，可跳过安装 <code>pip</code> 的步骤。</li><li>若是 <code>Windows</code> 用户，则需要安装 <code>pip</code> 工具。( 安装方法自行搜索或参考 [7] )</li></ul></li><li>安装完包管理工具 <code>pip</code>，可通过 <code>pip install Pillow</code> (Python 2.x) 或 <code>pip3 install Pillow</code> (Python 3.x) 命令安装 Python Imaging Library (处理图像的工具库)。</li><li><p>当然，Python 使用过程中需要安装和使用大量的第三方库，若通过上述方式安装未免太过繁琐，故我们可考虑直接安装 <a href="https://www.baidu.com/link?url=wU4ubxmhQWv3nZxRpf8-49yE1jNiaKCbtn0a1tfl9V4OOvw4KG0FH0mbdC4REMDf&amp;wd=&amp;eqid=f287538e0000a002000000065bbc170c" target="_blank" rel="noopener">Anaconda</a>。</p><p>  Anaconda，其是一个基于 Python 的数据处理和科学计算的平台，他已经内置了许多非常有用的第三方库。在完整完 Anaconda 后，重新在命令行中键入 <code>python</code>，出现以下信息即安装成功，可正常导库使用：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">python <span class="number">3.</span>x.x | Anconda, Inc. | ... on darwin</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="comment"># 直接倒入第三方模块即可</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h4><ul><li><p>当我们试图搜索某一模块，若找不到会报错。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mymodule</span><br><span class="line">Traceback (most recent call last)</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ModuleNotFoundError: No module named <span class="string">'mymodule'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>默认情况，Python 解释器会搜索当前目录，所有已安装内置模块和第三方模块，<code>搜索路径</code> 存放在 <code>sys 模块</code> 的 <code>path 变量</code> 中：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若需要添加搜索目录</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">'/User/kofe/mypython'</span>)</span><br><span class="line">print(sys.path) <span class="comment"># 查看是否已添加</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><ul><li><p>面向对象编程，Object Oriented Programming，简称 OOP。是一种程序设计思想。其把对象作为 <code>程序基本单元</code>，且对象中包含了 <code>数据</code> 和 <code>操作的函数</code>。</p><blockquote><p>面向对象的程序设计把计算机程序视为一组对象集合，而每个对象都可接收其他对象发送的消息并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p></blockquote></li><li><p>面向对象的程序可理解为：<code>程序 = 对象 + 对象</code>；<code>对象 = 成员变量 + 成员函数</code>。</p></li><li>面向过程编程，即把计算机程序视为一系列的命令集合，或可理解为一组函数的顺序执行。</li><li><p>面向过程的程序可理解：<code>程序 = 函数 + 算法</code>。 </p></li><li><p>在 Python 中，所有数据都可视为对象。当然，可以通过类来自定义对象的数据类型。例如，我们定义一个 <code>Student</code> 类型来代表学生的范畴：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printScore</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'name: %s, score: %s'</span> % (self.name, self.score))</span><br><span class="line">        </span><br><span class="line">stu1 = Student(<span class="string">'Lucy'</span>, <span class="number">80</span>)</span><br><span class="line">stu2 = Student(<span class="string">'Danny'</span>, <span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给对象发送消息实际就是调用对应的关联函数</span></span><br><span class="line">stu1.printScore()</span><br><span class="line">stu2.printScore()</span><br></pre></td></tr></table></figure></li></ul><h4 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h4><ul><li>面向对象的核心概念是 <code>类 (Class)</code> 和 <code>实例 (Instance)</code>，牢记类是抽象的模板。例如，上述的 <code>Student 类</code>，实例即根据类创建出一个个具体的对象 <code>stu1</code>、<code>stu2</code>。</li><li><p>通过 <code>class</code> 关键字定义类：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若没有合适的继承类，则默认使用 object 类，这是所有类最终都会继承的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>创建类的实例，如 <code>stu = Student()</code></p></li><li><p>由于类起到模板的作用，因此可在创建实例时，通过特殊方法 <code>__init__()</code>，把属性绑定进去。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建实例时，不需要传入 self，即实例本身</span></span><br><span class="line">stu = Student(<span class="string">'Lucy'</span>, <span class="number">95</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>数据封装</code>：访问实例本身的数据，不通过外部函数访问，而是通过类的内部定义访问数据的函数，这样实现数据封装。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printInfo</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'name: %s, score: %s'</span> % (self.name, self.score))</span><br></pre></td></tr></table></figure></li></ul><h4 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h4><ul><li><p><code>私有变量</code>：让内部属性不被外部访问，在 Python 中，通过双下划线 <code>__</code> 开头，变量变成私有变量。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line">     </span><br><span class="line">    <span class="comment"># Getter 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getName</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__name  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getScore</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Setter 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setName</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setScore</span><span class="params">(self, score)</span>:</span></span><br><span class="line">        <span class="comment"># Setter 方法修改属性值的好处，可定义规则约束有效值</span></span><br><span class="line">        <span class="keyword">if</span>  <span class="number">0</span>  &lt;= score &lt;= <span class="number">100</span>:</span><br><span class="line">            self.__score = score</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Bad Score'</span>)</span><br><span class="line"></span><br><span class="line">stu = Student(<span class="string">'Bob'</span>, <span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接访问会报错误:</span></span><br><span class="line"><span class="comment"># AttributeError: 'Student' object has no attribute '__name'</span></span><br><span class="line">print( stu.__name ) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现数据封装后</span></span><br><span class="line"><span class="comment"># 使用 Getter 函数访问属性</span></span><br><span class="line">print( stu.getName() )</span><br><span class="line"><span class="comment"># 使用 Setter 函数修改属性</span></span><br><span class="line">stu.setName(<span class="string">'Lucy'</span>)</span><br></pre></td></tr></table></figure></li><li><p>在 Python 中，类似 <code>__xxx__</code> 的变量名，是 <code>特殊变量</code>，可直接访问。</p></li><li><p>在 Python 中，私有变量 <code>_xxx</code> 和 <code>__xxx</code>，也是可以外部访问的。其实 Python 编译器是会把变量名修改为 <code>_类名__变量名</code>，致使直接访问报错。例如：<code>_Student__name</code>，通过 <code>stu. _Student__name</code> 可实现外部访问 “私有变量”。</p><blockquote><p>⚠️ 当然，我们不建议这样做。因为不同版本的 Python 解释器可能会把 <code>__xxx</code> 改成不同变量名称。我们还是按照 <code>约定俗成</code> 的规定，视 <code>__xxx</code> 为私有变量。</p></blockquote></li></ul><h4 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h4><ul><li><p><code>继承</code>：在面向对象程序设计中，可从某个现有类继承，新的类称为 <code>子类</code>，被继承的类称为 <code>基类、父类或超类</code>，例如：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'Animal is running...'</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># Animal 实现了 run() 方法，Dog 继承 Animal 类</span></span><br><span class="line"> <span class="comment"># Dog 作为子类自然也拥有了 run() 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'Dog is running...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然，我们还可以重写方法和增加方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'Cat is running...'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'Miao, Miao, Miao...'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>多态</code>：把不同子类对象都当作父类来看，可屏蔽不同子类对象之间的差异，写出通用代码。我们可从实例中理解多态：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runTwice</span><span class="params">(animal)</span>:</span></span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br><span class="line">    </span><br><span class="line">runTwice( Animal() ) <span class="comment"># 输出：Animal is running...</span></span><br><span class="line">runTwice( Dog() ) <span class="comment"># 输出：Dog is running...</span></span><br><span class="line">runTwice( Cat() ) <span class="comment"># 输出：Cat is running...</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h4><ul><li><p><code>type()</code> 函数：可判断对象类型</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本类型</span></span><br><span class="line">type(<span class="number">12345</span>) <span class="comment"># &lt;class 'int'&gt;</span></span><br><span class="line">type(<span class="string">'hello'</span>) <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">type(<span class="keyword">None</span>) <span class="comment"># &lt;type(None) 'NoneType'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量指向函数或者类</span></span><br><span class="line">type(abs) <span class="comment"># &lt;class 'builtin_function_or_method'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type() 函数返回类型</span></span><br><span class="line">type(<span class="number">12345</span>) == int <span class="comment"># True</span></span><br><span class="line">type(<span class="string">'HelloWorld'</span>) == str <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断其他类型</span></span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line">type(abs) == types.BuiltinFunctionType <span class="comment"># True</span></span><br><span class="line">type(<span class="keyword">lambda</span> x:x) == types.lambdaType <span class="comment"># True</span></span><br><span class="line">type( (x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)) ) == types.GeneratorType <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>isinstance()</code> 函数</p><ul><li>判断基本类型：<code>isinstance(&#39;abc&#39;, str)</code>，<code>isinstance(b&#39;a&#39;, bytes)</code>  </li><li>判断 class 类型：如有继承关系，如 <code>object -&gt; Animal -&gt; Dog</code>，则有：<br>a = Animal() =&gt; isinstance(a, Animal) =&gt;True<br>d = Dog() =&gt; isinstance(d, Animal) =&gt;True<br>d = Dog() =&gt; isinstance(d, Dog) =&gt;True  </li></ul></li><li><p><code>dir()</code> 函数：若要获得一个对象的所有属性和方法，可使用该函数。它返回一个包含字符串的 <code>list</code>。例如，获得一个 str 对象的所有属性和方法。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出：['__add__', '__class__', ... 'zfill']</span></span><br><span class="line">dir(<span class="string">'abc'</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>类似 <code>__xxx___</code> 的属性和方法在 Python 中都有特殊用途。如 <code>__len__()</code> 方法返回长度。调用 <code>len()</code> 函数，在函数内部实际是它自动地去调用该对象的 <code>__len__（)</code> 方法，故下面代码是等价的。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(<span class="string">'abc'</span>) == <span class="string">'abc'</span>.__len__() <span class="comment"># 输出 True</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>仅仅把属性和方法列出来是不够的，配合 <code>getattr()</code>、<code>setattr()</code> 及 <code>hasattr()</code>，我们可直接操作一个对象的状态。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Retangle</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.x * self.y</span><br><span class="line"></span><br><span class="line">rectangle = Rectangle(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">hasattr(rectangle, <span class="string">'z'</span>) <span class="comment"># 是否含有属性 z</span></span><br><span class="line">setattr(rectangle, <span class="string">'z'</span>, <span class="number">1</span>) <span class="comment"># 设置一个属性 z，令其等于 1</span></span><br><span class="line">getattr(rectangle, <span class="string">'z'</span>) <span class="comment"># 获取属性 z</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以获得对象方法</span></span><br><span class="line"><span class="keyword">if</span> hasattr(rectangle, <span class="string">'area'</span>):</span><br><span class="line">    fn = getattr(rectangle, <span class="string">'area'</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h4><ul><li><p>给实例绑定属性的方法是通过 <code>实例变量</code> 赋值，或通过 <code>self 变量</code> 赋值。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># self 变量赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">stu = Student(<span class="string">'Bob'</span>, <span class="number">80</span>)</span><br><span class="line"><span class="comment"># 实例变量赋值</span></span><br><span class="line">stu.gender = <span class="string">'male'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>给类绑定属性，直接在 class 中定义属性即可。</p><blockquote><p>编写程序时，不要对 <code>实例属性</code> 和 <code>类属性</code> 使用相同名称，因为相同名称的实例属性将屏蔽掉同名称的类属性。</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    grade = <span class="string">'postgraduate'</span></span><br><span class="line">    </span><br><span class="line">stu = Student(<span class="string">'Lucy'</span>, <span class="number">95</span>)</span><br><span class="line">print( stu.grade ) <span class="comment"># 与 print(Student.grade()) 效果相同</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h3><h4 id="使用-property"><a href="#使用-property" class="headerlink" title="使用 @property"></a>使用 @property</h4><ul><li><p>引入：在「<a href="https://www.kofes.cn/2018/09/life-is-short-we-need-python.html#访问限制">访问限制</a>」章节中，我们通过 setScore() 和 getScore() 方法实现修改数据和获取数据，以实现数据封装。且在 setXXX() 方法中，还可书写规则以约束输入数据或检查数据。</p><p>  既然本节提及 <code>@property</code>  属性，到底是何意图？先看看原始的 Setter 和 Getter 使用方法：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># Getter 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getScore</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line">       </span><br><span class="line">    <span class="comment"># Setter 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setScore</span><span class="params">(self, score)</span>:</span></span><br><span class="line">        <span class="comment"># Setter 方法修改属性值的好处，可定义规则约束有效值</span></span><br><span class="line">        <span class="keyword">if</span>  <span class="number">0</span>  &lt;= score &lt;= <span class="number">100</span>:</span><br><span class="line">            self.__score = score</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Bad Score'</span>)</span><br><span class="line"></span><br><span class="line">stu = Student()</span><br><span class="line">stu.set_score(<span class="number">90</span>)</span><br><span class="line">print( stu.get_score() )</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>改进：在操作逻辑层面，Python 还提供了更多特性，既直接调用变量的方式操作属性，又不破坏数据的封装特性，<code>@property 装饰器</code> 的作用就在于此。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__score</span><br><span class="line"></span><br><span class="line"><span class="meta">@score.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Score must be an integer!'</span>)</span><br><span class="line">    <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</span><br><span class="line">    self.__score = value</span><br><span class="line">    </span><br><span class="line">stu = Student()</span><br><span class="line">stu.score = <span class="number">90</span> <span class="comment"># 实际转化为 s.set_score(90)</span></span><br><span class="line">print( stu.score ) <span class="comment"># 输出 90</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><ul><li>继承是面向对象编程的一个重要的特性。通过继承，子类可以扩展父类的功能。</li><li><p>在 Python 中，多实现多重继承，子类就可同时获得多个父类的所有功能。这种设计模式也叫 <code>MixIn</code>。</p><blockquote><p>⚠️ 同样是面向对象编程的语言，Java 只允许单继承，即一个类最多只能显示地继承于一个父类。当然，Java 要获得更多 “属性能力”，也可通过实现接口的方式实现。</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需求：我们赋予不同动物不同的能力</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Walking</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Walking...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Swimming</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swim</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Swimming...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flying</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Flying...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一双栖动物：通过继承父类，从而获得对应能力</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Amphibian</span><span class="params">(Walking, Swimming)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 定义一只天鹅：能走能飞能游泳</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Swan</span><span class="params">(Walking, Flying, Swimming)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h4><ul><li><p>形如 <code>__xxx__</code> 的变量或者函数名在 Python 中是有特殊用途的。例如：<code>__slots__</code> 用于限制能绑定的属性，<code>__len__()</code> 方法返回对象本身的长度。</p><p>  除此之外，Python 的 class 中还有许多这样有特殊用途的 <code>属性</code> 和 <code>函数</code>，可帮助我们定制属性和定制类。</p></li></ul><h5 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a>__slots__</h5><ul><li><p>当我们创建一 class 实例后，可给该实例绑定 <code>任何</code> 属性和方法，这正体现了动态语言的灵活性。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实例</span></span><br><span class="line">stu = Student()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定属性</span></span><br><span class="line">stu.name = <span class="string">'Bob'</span></span><br><span class="line">stu.score = <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定方法</span></span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setAge</span><span class="params">(self, age)</span>:</span></span><br><span class="line">    self.age = age</span><br><span class="line">stu.setAge = MethodType(setAge, stu) <span class="comment"># 给实例绑定方法</span></span><br><span class="line">stu.setAge(<span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述方式只对本实例有效，若要所有实例起效，则需给 class 绑定方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setGrage</span><span class="params">(self, grade)</span>:</span></span><br><span class="line">    self.grade = grade</span><br><span class="line">Student.setGrage = setGrage</span><br></pre></td></tr></table></figure></li><li><p><code>动态绑定</code>：允许我们在程序运行的过程中动态给 class 添加功能 (方法)。</p></li><li><p><code>限定实例子的属性</code>：定义特殊变量 <code>__slots__</code>，可限制 class 实例能添加的属性。</p><ul><li>当子类定义了 slots 时，子类会继承父类的 slots，那么子类实例能添加的属性是子类与父类 slots 的 <code>并集</code>。</li><li><p>当子类定义中没有 slots 时，父类的 slots 对子类不起作用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'name'</span>, <span class="string">'score'</span>, <span class="string">'gender'</span>, <span class="string">'age'</span>)</span><br><span class="line">    </span><br><span class="line">stu = Student()</span><br><span class="line">stu.email = <span class="string">'admin@kofes.cn'</span> <span class="comment"># 会报 AttributeError 错误</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a>__getattr__</h5><ul><li><p>正常情况下，当我们调用类的方法或属性，若不存在则会报错。例如定义 Student 类：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'Bob'</span></span><br><span class="line">       </span><br><span class="line">stu = Student()</span><br><span class="line">print(stu.name) <span class="comment"># 输出 Bob</span></span><br><span class="line">print(stu.score) <span class="comment"># 没有对应属性故会报 AttributeError 错误</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>要避免这个错误，除了补上 score 属性外，Python 还有另一个机制，即通过 <code>__getattr__()</code> 方法，动态返回一个属性。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'Bob'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'score'</span> == attr:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">90</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 注意：只有在没有找到属性的情况下，才调用 __getattr__</span></span><br><span class="line"><span class="comment"># 已有的属性，不会在 __getattr__ 中查找</span></span><br><span class="line">print(stu.score) <span class="comment"># 输出 90</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：若在 __getattr__ 也没有匹配属性，则返回 None</span></span><br><span class="line"><span class="comment"># __getattr__ 默认返回 None</span></span><br><span class="line">print(stu.age) <span class="comment"># 输出 None</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>要让 class 只响应特定的几个属性，我们就要按照约定，抛出 <code>AttributeError</code> 错误即可：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'Bob'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'score'</span> == attr:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">90</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">'\'Student\' object has no attribute \'%s\''</span> % attr)</span><br></pre></td></tr></table></figure></li></ul><h5 id="iter"><a href="#iter" class="headerlink" title="__iter__"></a>__iter__</h5><ul><li><p>若想让一个类用于 <code>for ... in</code> 循环，类似 list 或 tuple 那样，就必须实现一个 <code>__iter__()</code> 方法，该方法返回一个迭代对象，然后 Python 的 For 循环就会不断调用该迭代对象的 <code>__next__()</code> 方法拿到循环的下一个值，直到遇到 <code>StopIteration</code> 错误时退出循环。</p><p>  我们以斐波那契数列为例，写一个 Fib 类作用于 For 循环 ：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 初始化两个计数器 a，b</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法重写</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self <span class="comment"># 实例本身就是迭代对象，故返回自己</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法重写</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b = self.b, self.a + self.b <span class="comment"># 计算下一个值</span></span><br><span class="line">        <span class="keyword">if</span> self.a &gt; <span class="number">100000</span>: <span class="comment"># 退出循环的条件</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        <span class="keyword">return</span> self.a <span class="comment"># 返回下一个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fib 实例作用于 For 循环：  </span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> Fib():</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure></li><li><p>对于定制类，我们让其实现了 <code>__iter__()</code> 和 <code>__next__()</code> 方法，那么它就是一个 <code>Iterator</code> 类型的，这正是动态语言的特性。  </p>  <div class="note success"><p>这种特性称为 <code>动态语言</code> 的 <code>鸭子类型</code>，动态语言并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p></div></li></ul><h5 id="call"><a href="#call" class="headerlink" title="__call__"></a>__call__</h5><ul><li><p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，使用 <code>instance.method()</code> 来调用。能不能直接在实例本身上调用呢？</p><p>  答案是可以的。任何类，只需要定义一个 <code>__call__()</code> 方法，就可以直接对实例进行调用。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'My name is %s.'</span> % self.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用方式</span></span><br><span class="line">stu = Student(<span class="string">'Bob'</span>)</span><br><span class="line">stu() <span class="comment"># 输出 My name is Bob.</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="更多定制"><a href="#更多定制" class="headerlink" title="更多定制"></a>更多定制</h5><ul><li>Python的 class 允许定义许多定制方法，让我们非常方便地生成特定的类。更多的定制方法请参考 Python 的官方文档：<a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" target="_blank" rel="noopener">Special Method Names</a>。</li></ul><h4 id="使用枚举类"><a href="#使用枚举类" class="headerlink" title="使用枚举类"></a>使用枚举类</h4><ul><li>在 Python 中，我们定义常量是采用 <code>约定俗成</code> 的方法来定义的，例如：<code>PI = 3.14159</code>。但其本质仍然是 <code>变量</code>。</li><li><p>而本节介绍的枚举类，通过 <code>Enum</code> 定义一个 <code>class</code> 类型，然后，每个常量都是 class 的一个 <code>唯一实例</code>。例如：定义 <code>Month</code> 类型的枚举类。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line">Month = Enum(<span class="string">'Month'</span>, (<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>, <span class="string">'May'</span>, <span class="string">'Jun'</span>,</span><br><span class="line">    <span class="string">'Jul'</span>, <span class="string">'Aug'</span>, <span class="string">'Sep'</span>, <span class="string">'Oct'</span>, <span class="string">'Nov'</span>, <span class="string">'Dec'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():</span><br><span class="line">    <span class="comment"># value 属性：则是自动赋给成员的 int 常量，默认从 1 开始计数</span></span><br><span class="line">    print(name, <span class="string">'=&gt;'</span>, member, <span class="string">','</span>, member.value)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">' 输出结果：</span></span><br><span class="line"><span class="string">' Jan =&gt; Month.Jan , 1</span></span><br><span class="line"><span class="string">' Feb =&gt; Month.Feb , 2</span></span><br><span class="line"><span class="string">' Mar =&gt; Month.Mar , 3</span></span><br><span class="line"><span class="string">' Apr =&gt; Month.Apr , 4</span></span><br><span class="line"><span class="string">' May =&gt; Month.May , 5</span></span><br><span class="line"><span class="string">' Jun =&gt; Month.Jun , 6</span></span><br><span class="line"><span class="string">' Jul =&gt; Month.Jul , 7</span></span><br><span class="line"><span class="string">' Aug =&gt; Month.Aug , 8</span></span><br><span class="line"><span class="string">' Sep =&gt; Month.Sep , 9</span></span><br><span class="line"><span class="string">' Oct =&gt; Month.Oct , 10</span></span><br><span class="line"><span class="string">' Nov =&gt; Month.Nov , 11</span></span><br><span class="line"><span class="string">' Dec =&gt; Month.Dec , 12</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然，我们还可以这样访问枚举类</span></span><br><span class="line">print( Month.Jan ) <span class="comment"># 输出 Month.Jan</span></span><br><span class="line">print( Month(<span class="number">1</span>) ) <span class="comment"># 输出 Month.Jan</span></span><br><span class="line">print( Month[<span class="string">'Jan'</span>] ) <span class="comment"># 输出 Month.Jan</span></span><br><span class="line">print( Month.Jan.value ) <span class="comment"># 输出 1</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>若有需求，我们可精确地控制枚举类型，即从 <code>Enum</code> 派生出自定义类：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="comment"># @unique 装饰器可以帮助我们检查保证没有重复值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekday</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    Sun = <span class="number">0</span></span><br><span class="line">    Mon = <span class="number">1</span></span><br><span class="line">    Tue = <span class="number">2</span></span><br><span class="line">    Wed = <span class="number">3</span></span><br><span class="line">    Thu = <span class="number">4</span></span><br><span class="line">    Fri = <span class="number">5</span></span><br><span class="line">    Sat = <span class="number">6</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://www.bilibili.com/video/av10742893?from=search&amp;seid=163310817147442185" target="_blank" rel="noopener">Eddie Woo. The RSA Encryption Algorithm. 2017. bilibili.com</a>  </li><li>[2] <a href="https://www.jianshu.com/p/3221e07d3310" target="_blank" rel="noopener">John cui. 轻松学习RSA加密算法原理. 2018. jianshu.com</a>  </li><li>[3] <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000" target="_blank" rel="noopener">廖雪峰. Python 教程. 2018. liaoxuefeng.com</a>  </li><li>[4] <a href="https://dl.acm.org/citation.cfm?id=1327492" target="_blank" rel="noopener">Dean J, Ghemawat S. MapReduce: simplified data processing on large clusters [J].<br>Communications of the ACM, 2008, 51(1): 107-113.</a>  </li><li>[5] <a href="https://book.douban.com/subject/25779298/" target="_blank" rel="noopener">Wes McKinney. 利用 Python 进行数据分析 [M]. 机械工业出版社, 2013</a>  </li><li>[6] <a href="http://docs.python.org/3/library/functions.html" target="_blank" rel="noopener">Python. The Python Standard Library. python.org</a> </li><li>[7] <a href="https://blog.csdn.net/silence2015/article/details/56483892" target="_blank" rel="noopener">渐行渐远silence. Windows 下多版本 Python 安装与 pip 安装和 pip 使用. 2017. csdn.net</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本文章主要以黑马程序员的「&lt;a href=&quot;https://pan.baidu.com/s/1oBnk19WfBWQ1Pwd7rNGixw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传智播客 Python 就业班 (ij6g)&lt;/a&gt;」、「 &lt;a href=&quot;https://www.bilibili.com/video/av14184325&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python 从入门到精通教程&lt;/a&gt; 」和「 &lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;廖雪峰的 Python 教程&lt;/a&gt; 」为主线，输出学习笔记，目的是检验自己的学习效果和日常复习之需。&lt;/li&gt;
&lt;li&gt;本文章也可作为入门 Python 的参考资料，除了视频的基础内容外，文章还会补充视频中讲解不详细或遗漏的必要知识点。&lt;/li&gt;
&lt;li&gt;文章的内容和知识框架，与「廖雪峰的 Python 教程」和「传智播客的视频」大体保持一致：&lt;ul&gt;
&lt;li&gt;文章以模块分块阐述：&lt;code&gt;Linux 基础&lt;/code&gt;、&lt;code&gt;Python 基础&lt;/code&gt;、&lt;code&gt;Python 面向对象&lt;/code&gt;、&lt;code&gt;项目实战&lt;/code&gt; ( 实战部分以爬虫、数据分析为主的项目实战 )。&lt;/li&gt;
&lt;li&gt;每个模块按知识点区分：&lt;ul&gt;
&lt;li&gt;Linux 基础部分参考 &lt;code&gt;传智播客 Python 从入门到精通教程&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;Python 基础部分参考 &lt;code&gt;廖雪峰 Python 教程&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;项目实践，即数据分析部分参考书籍 &lt;code&gt;利用 Python 进行数据分析&lt;/code&gt; $^{[5]}$；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后，引用 Bruce Eckel 的原话作为开篇，Python 的高效只有切身体验才会深有体会。期待您早日加入 Python 队伍中来。&lt;/p&gt;
  &lt;div class=&quot;note success&quot;&gt;&lt;p&gt;Life is short, you need python.&lt;/p&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Programme" scheme="http://www.kofes.cn/categories/Programme/"/>
    
    
      <category term="python" scheme="http://www.kofes.cn/tags/python/"/>
    
      <category term="linux" scheme="http://www.kofes.cn/tags/linux/"/>
    
      <category term="爬虫" scheme="http://www.kofes.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="数据分析" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>项目 | SVN 环境搭建与使用</title>
    <link href="http://www.kofes.cn/2018/08/building-a-svn-server.html"/>
    <id>http://www.kofes.cn/2018/08/building-a-svn-server.html</id>
    <published>2018-08-27T08:24:20.000Z</published>
    <updated>2018-09-03T08:39:17.223Z</updated>
    
    <content type="html"><![CDATA[<p>最近有机会接触到公司的新项目，对于多人参与的项目，充分感受到 <code>源代码的版本控制</code> 的重要性。为了深刻理解和复用起见，本文将从 <code>搭建</code>、<code>配置</code> 和 <code>使用</code> 多方面总结 SVN。</p><p>当然，版本控制的工具有很多，譬如 CVS、GIT、SVN，CVS 几乎淘汰；GIT 适合开源软件项目；SVN 适合企业内部由项目经理统一协调的多个并行项目的开发。选择哪款版本控制工具视具体情况而定。</p><a id="more"></a><h2 id="源代码管理"><a href="#源代码管理" class="headerlink" title="源代码管理"></a>源代码管理</h2><blockquote><p>介绍参考了资料 [1]。 </p></blockquote><h3 id="管理意义"><a href="#管理意义" class="headerlink" title="管理意义"></a>管理意义</h3><ul><li>目的：为了解决在软件开发过程中，由源代码引发的各种繁琐的问题。</li><li>作用：<ul><li>能追踪一个项目从诞生一直到定案的过程；</li><li>记录一个项目的所有内容变化，方便地查阅特定版本的修订情况.</li></ul></li><li>常见问题：<ul><li><strong>代码冲突</strong>：多人操作同一个文件 ( 团队开发中的常见问题 )；</li><li>无法后悔：做错了一个操作后，没有后悔药可以吃；</li><li>版本备份：费空间；</li><li>版本混乱：因版本备份过多造成混乱，难于找回正确的想要的版本；</li><li>权限控制：无法对源代码进行精确的权限控制；</li><li>追究责任：出现了严重的 BUG，无法得知是谁干的，容易耍赖.</li></ul></li></ul><h3 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h3><ul><li>CVS：历史悠久，现在几乎没人使用。</li><li>SVN：<ul><li>集中式版本控制的代表；</li><li>CVS 的接班人，速度和功能比 CVS 有很大幅度提升.</li></ul></li><li>GIT：<ul><li>分布式源代码管理工具；</li><li>目前被大多数开源项目使用。</li></ul></li></ul><h2 id="概念概述"><a href="#概念概述" class="headerlink" title="概念概述"></a>概念概述</h2><ul><li>Subversion 的简称为 SVN，是一个开放源代码的版本控制系统；</li><li>SVN 用于多个人共同开发同一个项目，目的是为了资源共享共用；</li><li>SVN 服务器有 2 种 <code>运行方式</code>：独立服务器和借助 Apache。两种方式各有利弊，可自行选择。</li><li>SVN <code>存储版本数据</code> 也有 2 种方式：<code>Berkeley DB</code> ( 事务安全型表类型 ) 和 <code>FSFS</code> ( 不需要数据库的存储系统 )。因为 Berkeley DB 方式在服务器中断时，有可能锁住数据，故选择 FSFS 的存储方式会更安全一点。</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="SVN-服务器"><a href="#SVN-服务器" class="headerlink" title="SVN 服务器"></a>SVN 服务器</h3><ul><li><p>安装 SVN Server For Windows：<a href="https://www.visualsvn.com/server/download/" target="_blank" rel="noopener">VisualSVN Server</a> </p><p>  具体安装流程就不阐述了，可参考引用文章完成配置 $^{[1,2]}$。</p><blockquote><p>Tips.01. 安装过程中，其中 SVN 服务器端口配置推荐使用HTTPS 的 <code>8443</code> 端口，因为 HTTPS 安全性比較高，尽管 <code>443</code> 是标准 HTTPSport。<br>Tips.02. 还有就是用于验证的身份配置：Windows 验证和 Subversion 身份验证，默认是 Subversion 身份验证。</p></blockquote></li><li><p>安装 SVN Server For MacOS：MacOS 自带了 SVN 的服务器端和客户端功能。参考引用文章完成配置即可使用 $^{[3,4]}$。</p></li></ul><h3 id="SVN-客户端"><a href="#SVN-客户端" class="headerlink" title="SVN 客户端"></a>SVN 客户端</h3><ul><li>Windows Client：<a href="https://tortoisesvn.net/downloads.html" target="_blank" rel="noopener">TortoiseSVN</a></li><li><p>MacOS Client：<a href="https://cornerstone.assembla.com/" target="_blank" rel="noopener">Cornerstone</a></p><blockquote><p>在 MacOS 上可利用 SVN 图形界面工具来管理源代码，可以大大减小使用命令行的痛苦 $^{[5]}$。</p></blockquote></li></ul><h3 id="SVN-配置与使用"><a href="#SVN-配置与使用" class="headerlink" title="SVN 配置与使用"></a>SVN 配置与使用</h3><p>Windows 端配置和使用 SVN 可通过图形界面工具即可完成操作，详细的步骤在引用文章 [1]、[2] 中也有提及。<br>故在本章节主要讲述 Mac 环境下搭建和配置 SVN。</p><h4 id="创建代码仓库"><a href="#创建代码仓库" class="headerlink" title="创建代码仓库"></a>创建代码仓库</h4><ul><li>Step.01. 新建一个 <code>svn</code> 目录，例如 <code>/Users/kofe/svn</code>，以后可在 <code>svn</code> 目录下创建多个仓库目录。</li><li><p>Step.02. 打开终端，创建一个名为 <code>idea</code> 仓库，输入指令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指令执行成功后，会发现硬盘上多了个 /Users/kofe/svn/idea 目录</span></span><br><span class="line">svnadmin create /Users/kofe/svn/idea</span><br></pre></td></tr></table></figure></li></ul><h4 id="配置用户权限"><a href="#配置用户权限" class="headerlink" title="配置用户权限"></a>配置用户权限</h4><p>主要是修改 <code>/svn/idea/conf</code> 目录下的三个文件：<code>svnserve.conf</code>、<code>Passwd</code> 文件和 <code>Authz</code> 文件。</p><ul><li><p>svnserve.conf</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># anon-access = read 代表匿名访问的时候是只读的</span></span><br><span class="line"><span class="comment"># anon-access = none 代表禁止匿名访问，需要帐号密码才能访问</span></span><br><span class="line">anon-access = <span class="built_in">read</span></span><br><span class="line">auth-access = write</span><br><span class="line">password-db = passwd</span><br><span class="line">authz-bd = authz</span><br></pre></td></tr></table></figure></li><li><p>Passwd 文件：在 <code>[users]</code> 下面添加账号和密码。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line"><span class="comment"># 格式：账号 = 密码</span></span><br><span class="line">kofe = 123456</span><br><span class="line">lucy = 123456</span><br></pre></td></tr></table></figure></li><li><p>Authz 文件：配置用户组和权限我们可以将在 Passwd 里添加的用户分配到不同的用户组里。以后就可对不同用户组设置不同的权限，没有必要对每个用户进行单独设置权限。即在 <code>[groups]</code> 下面添加组名和用户名，多个用户之间用逗号 <strong>,</strong> 隔开。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[groups] </span><br><span class="line">usergroup = kofe, lucy <span class="comment"># 格式：组名 = 用户1, 用户2, ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 [/] 代表 SVN 服务器中的所有资源库</span></span><br><span class="line"><span class="comment"># 某个组有读写权限</span></span><br><span class="line">[/]</span><br><span class="line">@usergroup = rw</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 [/] 代表 SVN 服务器中的所有资源库</span></span><br><span class="line"><span class="comment"># 某个用户有读写权限</span></span><br><span class="line"><span class="comment"># lucy = rw</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="启动关闭服务"><a href="#启动关闭服务" class="headerlink" title="启动关闭服务"></a>启动关闭服务</h4><ul><li><p>在终端输入下列指令：若没有任何提示，恭喜你启动成功。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svnserve -d -r /Users/kofe/svn</span><br><span class="line"><span class="comment"># 或输入: svnserve -d -r /User/kofe/svn/idea</span></span><br></pre></td></tr></table></figure></li><li><p>当然，会启用也要会关闭 SVN 服务器，特别是首次配置完 SVN 服务器需要重启。<br>  Case.01. 在 <code>活动监视器</code> 中搜索 <code>svn</code>, 在列表中找到进程 <code>svnserve</code>, 点击左上角的<code>强制退出进程</code>。<br>  Case.02. 或者可通过 shell 脚本实现一键关闭。  </p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Current Process List:"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"= = = = = = = = = = ="</span></span><br><span class="line">ps -A | grep svn</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"= = = = = = = = = = ="</span></span><br><span class="line"><span class="built_in">kill</span> `pgrep <span class="string">"svn"</span>`</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Kill successfully!"</span> Current Process Status:</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"= = = = = = = = = = = = = = = = = = = = = ="</span></span><br><span class="line">ps -A | grep svn</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"= = = = = = = = = = = = = = = = = = = = = ="</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="代码版本控制"><a href="#代码版本控制" class="headerlink" title="代码版本控制"></a>代码版本控制</h4><blockquote><p>当然，充分利用 SVN 图形界面工具 ( <a href="https://cornerstone.assembla.com/" target="_blank" rel="noopener">Cornerstone</a> ) 来管理源代码，可大大减小使用命令行的痛苦，提升使用效率。</p></blockquote><ul><li><p>首次导入工程文件到 SVN 服务器：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /Users/kofe/procedure/idea/SSM_DEMO，指的是需要导入的工程文件</span></span><br><span class="line"><span class="comment"># svn://localhost/idea 指把工程文件上传到 idea 目录下</span></span><br><span class="line"><span class="comment"># --username=admin --password=123456 指的是校验用户名和密码</span></span><br><span class="line"><span class="comment"># -m "初始化导入" 指的是提交的信息注释</span></span><br><span class="line">svn import /Users/kofe/procedure/idea/SSM_DEMO svn://localhost/idea --username=kofe --password=123456 -m <span class="string">"初始化导入"</span></span><br></pre></td></tr></table></figure></li><li><p>从 SVN 服务器下载工程文件到本地 ( Checkout )：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn checkout svn://localhost/idea --username=kofe --password=123456 /Users/kofe/procedure/idea</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>二次提交代码到服务器：二次提交是有一个前提的, 那就是你首先需要在 SVN服务器上下载代码到本地，然后再去修改这一份代码, 才能够二次提交。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /Users/kofe/procedure/idea</span><br><span class="line">svn commit -m <span class="string">"修改部分代码 (注释修改的内容)"</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>SVN 基本操作原理：</p><ul><li><code>svn checkout</code>：将服务器代码完整下载到本地。</li><li><code>svn update</code>：将服务器最新的代码下载到本地。</li><li><p><code>svn commit</code>：将本地修改的内容提交到服务器。</p><p><img src="/images/illustration/Project/2018/08/building-a-svn-server_3-1.png" alt="图3-1SVN 基本操作原理"></p><center>图 3-1 SVN 基本操作原理</center></li></ul></li></ul><h4 id="代码版本冲突"><a href="#代码版本冲突" class="headerlink" title="代码版本冲突"></a>代码版本冲突</h4><ul><li><p>版本冲突原因：</p><p>  假设 A、B 两用户都在版本号为 100 时更新了 <code>sample.txt</code> 文件，A 用户在修改完成之后提交 sample.txt 到服务器，这个时候提交成功，这个时候 sample.txt 文件的版本号已经变成 101 了。同时 B 用户在版本号为 100 的 sample.txt 文件上作修改，修改完成之后提交到服务器时，由于不是在当前最新的 101 版本上作的修改，所以导致提交失败。</p></li><li><p>版本冲突现象：</p><p>  冲突发生时，SVN 会在当前工作目录中保存所有的目标文件版本 [ 上次更新版本、当前获取的版本 ( 即别人提交的版本 )、自己更新的版本、目标文件 ]。  假设文件名是 <code>sample.txt</code> ，对应的文件名分别是 ( 同时在目标文件中标记来自不同用户的更改 )：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sample.txt.r101</span><br><span class="line">sample.txt.r102</span><br><span class="line">sample.txt.mine</span><br><span class="line">sample.txt</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>手工合并</code> SVN 冲突 $^{[6]}$，开始的时候让人觉得害怕，但有规律可循。例如有以下文本：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Mayonnaise</span><br><span class="line">Lettuce</span><br><span class="line">Tomato</span><br><span class="line">Provolone</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;.mine</span><br><span class="line">Salami</span><br><span class="line">Mortadella</span><br><span class="line">Prosciutto</span><br><span class="line">=======</span><br><span class="line">Sauerkraut</span><br><span class="line">GrilledChicken</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;.r2</span><br></pre></td></tr></table></figure><p>  一连串的大于、小于、等于号是 SVN 冲突标记，这些数据得全部删除才可以提交。在 SVN 冲突区中，或许你需要和你的同事沟通来安排冲突区的文本内容，待所有冲突区得到合理的解决之后方可再提交文件。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是你在冲突区里面做的修改</span></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;.mine</span><br><span class="line">Salami</span><br><span class="line">Mortadella</span><br><span class="line">Prosciutto</span><br><span class="line">=======</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是别人在冲突区做的修改</span></span><br><span class="line">Sauerkraut</span><br><span class="line">GrilledChicken</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;.r2</span><br></pre></td></tr></table></figure></li></ul><ul><li>如何降低冲突解决的复杂度：<ul><li>在提交时写上明确的 Message ( 注释 )，方便以后查找用户更新的原因。</li><li>养成良好的使用习惯，使用 SVN 时每次都是先提交，后更新。每天 <code>早上</code> 打开后，首先要从版本库 <code>获取最新版本</code>，每天 <code>下班前</code> 必须将已经编辑过的文档都 <code>提交</code> 到版本库。</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://www.jianshu.com/p/96f2db36044b" target="_blank" rel="noopener">PhelanGeek. SVN 服务器搭建教程. jianshu.com. 2016</a><br>[2] <a href="https://juejin.im/post/5b0e50f5f265da08ec33b74e" target="_blank" rel="noopener">RealLiuNing. Windows 10 搭建独立 SVN 服务器. jianshu.com. 2018</a><br>[3] <a href="https://juejin.im/post/58209be1a0bb9f0058c08452" target="_blank" rel="noopener">CainLuo. 搭建 MacOS 本地 SVN 服务器. juejin.im. 2016</a><br>[4] <a href="https://www.jianshu.com/p/66f085556fb2" target="_blank" rel="noopener">Sunny Fight. iOS 版本控制 SVN (Mac 环境下 SVN 的使用). jianshu.com. 2016</a><br>[5] <a href="https://www.jianshu.com/p/650342b0a0ce" target="_blank" rel="noopener">天蓝. SVN 在 Mac 上使用 Xcode+Cornerstone. jianshu.com. 2017</a><br>[6] <a href="https://www.cnblogs.com/aaronLinux/p/5521844.html" target="_blank" rel="noopener">aaronGao. svn conflict 冲突解决. cnbologs.com. 2016</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有机会接触到公司的新项目，对于多人参与的项目，充分感受到 &lt;code&gt;源代码的版本控制&lt;/code&gt; 的重要性。为了深刻理解和复用起见，本文将从 &lt;code&gt;搭建&lt;/code&gt;、&lt;code&gt;配置&lt;/code&gt; 和 &lt;code&gt;使用&lt;/code&gt; 多方面总结 SVN。&lt;/p&gt;
&lt;p&gt;当然，版本控制的工具有很多，譬如 CVS、GIT、SVN，CVS 几乎淘汰；GIT 适合开源软件项目；SVN 适合企业内部由项目经理统一协调的多个并行项目的开发。选择哪款版本控制工具视具体情况而定。&lt;/p&gt;
    
    </summary>
    
      <category term="Project" scheme="http://www.kofes.cn/categories/Project/"/>
    
    
      <category term="svn" scheme="http://www.kofes.cn/tags/svn/"/>
    
      <category term="mac" scheme="http://www.kofes.cn/tags/mac/"/>
    
      <category term="git" scheme="http://www.kofes.cn/tags/git/"/>
    
      <category term="版本控制" scheme="http://www.kofes.cn/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>框架 | Java EE 之 SSM 框架配置与使用</title>
    <link href="http://www.kofes.cn/2018/08/J2EE-SSM-1.html"/>
    <id>http://www.kofes.cn/2018/08/J2EE-SSM-1.html</id>
    <published>2018-08-13T02:16:05.000Z</published>
    <updated>2018-09-03T08:39:29.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>本文章主要围绕 J2EE 中 SSM ( Spring、Spring MVC、MyBatis ) 框架的配置以及使用问题展开学习的，最终目的是输出可复用的版本，以供后续的项目复用。当然，学习和配置的过程难免有不恰当或错误之处，还望朋友指出、斧正。</p><h2 id="更新进度"><a href="#更新进度" class="headerlink" title="更新进度"></a>更新进度</h2><ul><li>2018.08.13：完成初稿，梳理 SSM 框架初识章节；</li><li>2018.08.20：框架内容，梳理 SSM 框架基本内容；</li><li>2018.08.24：框架内容，修正 SSM 框架部分内容；</li><li>2018.08.26：框架内容，整合 Spring 和 MyBatis；</li></ul><h2 id="教学资源"><a href="#教学资源" class="headerlink" title="教学资源"></a>教学资源</h2><ul><li><p>视频 | <a href="https://www.bilibili.com/video/av20394903" target="_blank" rel="noopener">黑马程序员. J2EE 进阶. MyBatis 框架由浅入深. 2017. bilibili.com</a></p><blockquote><p>本框架的学习笔记是基于此系列教学视频所得的。</p></blockquote></li><li><p>文章 | <a href="https://blog.csdn.net/noaman_wgs/article/details/79503559" target="_blank" rel="noopener">吴操. 搭建一个基于 SSM 框架的人力资源管理系统. 2018. csdn.net</a></p><blockquote><p>发现这位博主搭建的例子 ( <a href="https://github.com/nomico271/SSM_HRMS" target="_blank" rel="noopener">nomico271. SSM_HRMS. Github</a> ) 紧凑、简练，适合初入门时来模仿构建自己的项目。</p></blockquote></li></ul><a id="more"></a><h2 id="IDE-搭建"><a href="#IDE-搭建" class="headerlink" title="IDE 搭建"></a>IDE 搭建</h2><p>IDE 搭建以 <a href="https://www.kofes.cn/2018/07/J2EE-SSH-SSI-1.html#IDE-搭建">Java EE 之 SSH 框架配置与使用</a> 为参考。</p><h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><ul><li>框架版本：<ul><li>Spring MVC：4.3.x</li><li>Spring：4.3.x</li><li>MyBatis：3.4.x</li></ul></li><li>其他组件：<ul><li>MySQL：5.7.x / SQL Server：2008 R2</li><li>Tomcat：9.0.x</li><li>Maven：3.3.9</li><li>JDK：1.8</li></ul></li><li>构建框架，还需要相关依赖库 ( Jar 包 )，为便于你下载 Jar 包或校对依赖是否齐全，具体地，以下列举了 SSM 框架所需要的依赖库。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">Spring</th><th style="text-align:left">MyBatis</th></tr></thead><tbody><tr><td style="text-align:left">spring-core</td><td style="text-align:left">mybatis</td></tr><tr><td style="text-align:left">spring-beans</td><td style="text-align:left">mybatis-spring ( Spring 整合 Mybatis )</td></tr><tr><td style="text-align:left">spring-context</td><td style="text-align:left">pagehelper ( 分页助手 )</td></tr><tr><td style="text-align:left">spring-webmvc</td><td style="text-align:left">&nbsp;</td></tr><tr><td style="text-align:left">spring-web</td><td style="text-align:left">&nbsp;</td></tr><tr><td style="text-align:left">spring-aop ( 整合 Aop )</td><td style="text-align:left">&nbsp;</td></tr><tr><td style="text-align:left">aopalliance ( 整合 Aop )</td><td style="text-align:left">&nbsp;</td></tr><tr><td style="text-align:left">spring-aspect ( 整合 Aop )</td><td style="text-align:left">&nbsp;</td></tr><tr><td style="text-align:left">aspectjweaver ( 整合 Aop )</td><td style="text-align:left">&nbsp;</td></tr><tr><td style="text-align:left">spring-tx ( 整合事务 )</td><td style="text-align:left">&nbsp;</td></tr><tr><td style="text-align:left">spring-jdbc</td><td style="text-align:left">&nbsp;</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">其他依赖库 ( Jar 包 )</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">log4j</td><td style="text-align:left">日志支持</td></tr><tr><td style="text-align:left">log4j-core、log4j-api</td><td style="text-align:left">日志支持</td></tr><tr><td style="text-align:left">slf4j-api、slf4j-log4j12</td><td style="text-align:left">日志支持</td></tr><tr><td style="text-align:left">junit</td><td style="text-align:left">Junit 单元测试</td></tr><tr><td style="text-align:left">c3p0</td><td style="text-align:left">c3p0 数据库连接池</td></tr><tr><td style="text-align:left">mysql-connector-java</td><td style="text-align:left">添加 MySQL 数据库支持</td></tr><tr><td style="text-align:left">jackson-databind</td><td style="text-align:left">Json 数据转化为类对象</td></tr><tr><td style="text-align:left">jsp-api</td><td style="text-align:left">JSP</td></tr><tr><td style="text-align:left">javax.servlet-api</td><td style="text-align:left">Servlet</td></tr><tr><td style="text-align:left">jstl</td><td style="text-align:left">JSTL 标签库</td></tr><tr><td style="text-align:left">taglibs-standard-impl</td><td style="text-align:left">JSP 标准标签库</td></tr></tbody></table></div><h2 id="框架初识"><a href="#框架初识" class="headerlink" title="框架初识"></a>框架初识</h2><ul><li><p>SSM 框架集由 Spring、SpringMVC、MyBatis 三个开源框架整合而成，是继 SSH (Spring、Struts2、Hibernate ) 之后，目前比较主流的 Java EE 企业级框架，适用于搭建各种大型的企业级应用系统。 </p><blockquote><p>SSM 与 SSH 都有各自的优缺点，而根据你的项目特点而选择合适的框架即可。关于 SSH 框架的配置与使用，感兴趣的可参考本博客的文章：<a href="https://www.kofes.cn/2018/07/J2EE-SSH-SSI-1.html">Java EE 之 SSH 框架配置与使用</a></p></blockquote></li></ul><h3 id="ORM-框架"><a href="#ORM-框架" class="headerlink" title="ORM 框架"></a>ORM 框架</h3><ul><li>对象关系映射（Object Relational Mapping，O/R Mapping，ORM）是通过使用描述对象和数据库之间映射的 <code>元数据</code>，将面向对象语言程序中的 <code>对象</code> 自动 <code>持久化</code> 到 <code>关系数据库</code> 中。本质上就是将数据从一种形式转换到另外一种形式。 </li><li>让 <code>实体类</code> 和 <code>数据库表</code> 进行一一对应关系 (映射关系)，<code>实体类属性</code> 和 <code>表里面的字段</code> 对应。操作表对应实体类对象，而不需操作数据库表。</li></ul><h3 id="SSM-框架"><a href="#SSM-框架" class="headerlink" title="SSM 框架"></a>SSM 框架</h3><h4 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h4><h5 id="原生-Jdbc-操作数据库"><a href="#原生-Jdbc-操作数据库" class="headerlink" title="原生 Jdbc 操作数据库"></a>原生 Jdbc 操作数据库</h5><p>在引入 MyBatis ( 或 Hibernate ) 前，一般通过原生 Jdbc 来操作数据库，而这种方式存在很多问题 $^{[2]}$：</p><ul><li><p>程序创建数据库连接，即需求时创建，用完后关闭。若频繁的创建、关闭数据库连接，显然存在问题。 ( 可以通过数据库连接池来处理这个问题 )</p></li><li><p>硬编码的地方太多了。例如，数据库连接相关信息，SQL相关信息等。( 可通过使用 XML 配置文件，来避免这个问题 )</p></li><li><p>实质上，我们编写JDBC是有步骤可循的，即先得到数据库连接对象，传入SQL、输入参数、设置参数，再去执行SQL，然后遍历结果集将数据库 SQL 执行的结果对象转化为 JAVA 对象，然后再去业务处理，最后释放资源。</p><p>  那么这个过程，实际上是个 <code>模板方法</code>，能不能抽离出来，更好的去完成这个过程呢？</p></li></ul><h5 id="框架比较"><a href="#框架比较" class="headerlink" title="框架比较"></a>框架比较</h5><ul><li>Hibernate<ul><li>优点：<br>1) Hibernate 这个纯粹的 ORM 框架，以面向对象的方式来完成数据库的操作。<br>2) Hibernate 不需要编写 SQL 即可完全映射，且可通过 HQL (Hibernate Query Language) 语言对 POJO 操作。<br>3) Hibernate 提供了日志、缓存、级联等特性。  </li><li>缺点：<br>1) Hibernate 可自由编写 SQL，但非常繁琐，则优化 SQL 实现高性能数据库操作有限制，在互联网项目快速迭代开发中显得过于笨重。<br>2) Hibernate 的 <code>级联会造成太多性能的丢失</code>。<br>3) Hibernate 不支持存储过程。</li></ul></li><li>MyBatis<ul><li>优点：自由书写 SQL、支持动态 SQL、处理列表、动态生成表名、支持存储过程。</li><li>缺点：需要编写 SQL 和映射规则，工作量相对较大。</li></ul></li></ul><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul><li><p>MyBatis 前身是 Apache 的开源项目 <code>iBatis</code>，<code>iBatis</code> 一词源于 internet 和 abatis 的组合，是一个基于 Java 的持久层框架。</p></li><li><p>MyBatis 是一款持久层框架，它支持定制化 SQL (不屏蔽 SQL)、存储过程以及高级映射。</p></li><li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li><li><p>MyBatis 可使用 XML配置文件形式或注解形式来配置和映射原生信息，将接口和 POJOs ( Plain Ordinary Java Object，普通 Java 对象 / 实体类 ) 映射成数据库中的记录。</p><blockquote><p>我们把 POJO 对象和数据库表相互映射的框架称为对象关系映射框架 ( Object Relational )。</p></blockquote></li></ul><h5 id="架构原理"><a href="#架构原理" class="headerlink" title="架构原理"></a>架构原理</h5><p><img src="/images/illustration/Project/2018/08/J2EE-SSM-1_6-1.png" alt="图6-1SSM架构原理图"></p><center>图 6-1 SSM架构原理图</center><ul><li><p><code>SqlMapConfig.xml</code>：MyBatis 全局配置文件，配置数据源、事务等运行环境相关信息；SQL文件即是 <code>Mapper.xml</code>。</p></li><li><p><code>SqlSessionFactory</code>：会话工厂，用于创建 SqlSession。</p></li><li><p><code>SqlSession</code>：即操作数据库的接口，其内部借助 <code>Executor</code> 执行器完成对数据库的操作。</p></li><li><p><code>MappedStatement</code>：底层封装对象，对操作数据库储存封装，其中包括 SQL 语句 ( Mapper.xml )、输入对象和输出结果类型。</p></li></ul><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><ul><li><p>全局配置文件：在 Src 根目录下建立并配置 <code>SqlMapConfig.xml</code>  </p><p>  与 Spring 整合 Hibernate 一样，后期 Spring 整合 MyBatis 后此配置文件可省略。当然，学习阶段代码还是得提供。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">    PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">    "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 加载 Java 的配置文件或者声明属性信息 ( 详细见本项目源码 ) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"c3p0.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 全局参数配置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;settings&gt;&lt;/settings&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自定义别名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 单个别名定义</span></span><br><span class="line"><span class="comment">        &lt;typeAlias type="cn.kofes.ssm.pojo.Sample" alias="Sample"/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 批量别名定义 ( 推荐 )</span></span><br><span class="line"><span class="comment">         | package：指定包名称来为该包下的 pojo 类声明别名，默认的别名就是类名 ( 首字母大小写都可 )</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.kofes.pojo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置 MyBatis 的环境信息，与 Spring 整合，该信息由spring来管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置 Jdbc 事务控制，由 MyBatis 进行管理 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置数据源，采用 MyBatis 连接池 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;datasource.driverClass&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;datasource.jdbcUrl&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;datasource.user&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;datasource.password&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 加载映射文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 单个映射文件添加 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper/SampleMapper.xml"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 批量加载映射文件：mapper.java 与 mapper.xml 同名，且在同一目录下</span></span><br><span class="line"><span class="comment">        &lt;package name="cn.kofes.ssm.mapper" /&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Mapper 映射文件：例如 <code>SampleMapper.xml</code></p><ul><li><p>创建实体类对象 ( POJOs )：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cn.kofes.pojo.Sample.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123; <span class="keyword">this</span>.id = id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件中配置 SQL 语句，如建立 <code>SampleMapper.xml</code> ( 便于管理，把映射文件统一放置 mapper 文件夹下 )：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mapper/SampleMapper.xml --&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">    "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- namespace 用于绑定 Mapper 代理开发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.kofes.mapper.SampleMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     | 配置 SQL 语句：例如查找某一元组</span></span><br><span class="line"><span class="comment">     | - id 属性：唯一标识映射文件中的 SQL</span></span><br><span class="line"><span class="comment">     | - parameterType 属性：指定输入参数的类型</span></span><br><span class="line"><span class="comment">     | - resultType 属性：指定输出参数的类型</span></span><br><span class="line"><span class="comment">     |   SQL 语句会封装到 MappedStatement 对象中，故 ID 又称为 Statement 的 ID</span></span><br><span class="line"><span class="comment">     | - #&#123;&#125;：表示一个占位符号</span></span><br><span class="line"><span class="comment">     | - #&#123;id&#125;：id 表示接收输入的参数，参数名称就是 id</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findCertianTupleById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"cn.kofes.bean.Sample"</span>&gt;</span></span><br><span class="line">        SELECT * FROM t_sample WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 插入元组 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertOneTuple"</span> <span class="attr">parameterType</span>=<span class="string">"cn.kofes.pojo.Sample"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 用于自增 ID 的情况，在完成插入后将 ID 返回 user 对象中</span></span><br><span class="line"><span class="comment">        &lt;selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer"&gt;</span></span><br><span class="line"><span class="comment">            SELECT LAST_INSERT_ID()</span></span><br><span class="line"><span class="comment">        &lt;/selectKey&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 用于非自增 ID 的情况，先产生 ID 放入 user 对象中，再执行保存</span></span><br><span class="line"><span class="comment">        &lt;selectKey keyProperty="id" order="BEFORE" resultType="java.lang.String"&gt;</span></span><br><span class="line"><span class="comment">            SELECT UUID()</span></span><br><span class="line"><span class="comment">        &lt;/selectKey&gt;</span></span><br><span class="line"><span class="comment">        INSERT INTO t_sample (id, name) VALUES (#&#123;id&#125;, #&#123;name&#125;)</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        INSERT TO t_sample(id, name) value(#&#123;id&#125;, #&#123;name&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 删除一条元组 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteOneTupleById"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">        DELETE FROM t_sample WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 更新一条元组 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateOneTupleById"</span> <span class="attr">parameterType</span>=<span class="string">"cn.kofes.pojo.Sample"</span>&gt;</span></span><br><span class="line">        UPDATE t_sample SET id = #&#123;id&#125;, name = #&#123;name&#125;</span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h5><ul><li><p>单独使用 MyBatis 框架，根据 id 查询指定用户：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 便于检验效果，这里以单元测试类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBOperatorTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDoSomethingInDB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加载 MyBatis 配置文件</span></span><br><span class="line">        String resource  = <span class="string">"SqlMapConfig.xml"</span>;</span><br><span class="line">        <span class="comment">// 得到配置文件流</span></span><br><span class="line">        InputStream inputStream = Resource.getResourceAsStream(resource);</span><br><span class="line">        <span class="comment">// 创建会话工厂</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder()</span><br><span class="line">            .build(inputStream);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 通过会话工厂，得到 SqlSession 对象</span></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过 SqlSession 操作数据库</span></span><br><span class="line">        <span class="comment">// 第一个参数：namespace + statement id</span></span><br><span class="line">        <span class="comment">// 第二个参数：指定和映射文件中所匹配的 parameterType 相同属性类型的参数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 根据 ID 查询元组</span></span><br><span class="line"><span class="comment">        Sample sample = sqlSession.selectOne(</span></span><br><span class="line"><span class="comment">            "cn.kofes.mapper.SampleMapper.findCertainTupleById", 1);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 插入一条元组</span></span><br><span class="line"><span class="comment">        Sample sample = new Sample();</span></span><br><span class="line"><span class="comment">        sample.setName("邯郸");</span></span><br><span class="line"><span class="comment">        sqlSession.insert(</span></span><br><span class="line"><span class="comment">            "cn.kofes.mapper.SampleMapper.insertOneTuple", sample);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 根据 ID 修改元组</span></span><br><span class="line"><span class="comment">        Sample sample = new Sample();</span></span><br><span class="line"><span class="comment">        sample.setId(14);</span></span><br><span class="line"><span class="comment">        sample.setName("阿斗");</span></span><br><span class="line"><span class="comment">        sqlSession.update(</span></span><br><span class="line"><span class="comment">            "cn.kofes.mapper.SampleMapper.updateOneTupleById", sample);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>案例总结：</p><ul><li><code>namespace</code>：命名空间，作用是隔离 SQL。在 MyBatis 和 Spring 结合使用时具有特殊的意义，这里暂且使用全限定类名。</li><li><code>&lt;select&gt;</code> 等 SQL Command 标签需要一个 ID，还需要输入参数 parameterType，输出参数映射 resultType 等。在 MyBatis 底层封装成了一个 MappedStatement 对象，使用时以 <code>namespace.id</code> 的方式引用即可。</li><li><code>#{}</code> 和 <code>${}</code>：<ul><li><code>#{}</code>：表示一个占位符号，用于接收输入参数，类型可以是简单类型，也可是 POJO、HashMap 等。( 通过 <code>OGNL 表达式</code> 读取对象的属性值 )</li><li><code>${}</code>：表示一个拼接符号，会引入 <code>SQL注入</code>，故不建议使用。</li></ul></li></ul></li><li><p>思考问题：</p><ul><li>我们重点关注的是 SqlSession，它其实是一个 interface，定义了很多操作数据库的接口，其中实现了 Closeable 接口，很明确是使用完毕后需要 <code>close()</code> 的。  </li><li>它的实现类 DefaultSqlSession 中有一些数据域，比如说 autoCommit，在默认情况下是不开启自动提交的；且方法也并不是 Synchronized 的，这说明 SqlSession 并不是线程安全的，因此我们应该是局部使用 SqlSession，且在使用完毕后 <code>close()</code> 关闭 sqlSession。</li></ul></li></ul><h5 id="MyBatis-原始方法"><a href="#MyBatis-原始方法" class="headerlink" title="MyBatis 原始方法"></a><del>MyBatis 原始方法</del></h5><blockquote><p>这种方式，重复的代码太多，现阶段基本弃用，目前使用最多的就是 Mapper 代理开发。</p></blockquote><ul><li>在开始 Mapper 代理开发前，可了解一种 MyBatis 的原始 Dao 开发方法：<ul><li>Step.01.提供 Dao 接口，有增、删、改、查的方法。</li><li>Step.02.提供 Dao 的实现类，在实现类中利用 Spring 注入 SqlSessionFactory，然后在各个方法中得到 SqlSession，进行操作后，关闭 SqlSession 即可。</li></ul></li><li><p>便于理解，放上实现代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DAO 层接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertOneTuple</span><span class="params">(User user)</span> throw Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteOneTupleById</span><span class="params">(<span class="keyword">int</span> id)</span>  throw Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOneTupleById</span><span class="params">(User user)</span>  throw Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findCertainById</span><span class="params">(<span class="keyword">int</span> id)</span> throw Exception</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DAO 层实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleDaoImpl</span> <span class="keyword">implements</span> <span class="title">BaseDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SampleDaoImpl</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span></span><br><span class="line"><span class="function">        throw Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findCertainById</span><span class="params">(<span class="keyword">int</span> id)</span> throw Exception </span>&#123; </span><br><span class="line">        <span class="comment">// 省略实现逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteOneTupleById</span><span class="params">(<span class="keyword">int</span> id)</span>  throw Exception </span>&#123; </span><br><span class="line">        <span class="comment">// 省略实现逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOneTupleById</span><span class="params">(User user)</span>  throw Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 省略实现逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findCertainById</span><span class="params">(<span class="keyword">int</span> id)</span> throw Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 省略实现逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单元测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleDaoTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = </span><br><span class="line">            Resource.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = </span><br><span class="line">            <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindCertainById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BaseDao sampleDao = <span class="keyword">new</span> SampleDaoImpl(sqlSessionFactory);</span><br><span class="line">        User user = sampleDao.findCertainById(<span class="number">5</span>);</span><br><span class="line">        System.out.println( user.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Mapper-代理开发"><a href="#Mapper-代理开发" class="headerlink" title="Mapper 代理开发"></a>Mapper 代理开发</h5><ul><li><p>Mapper 映射文件：上一节配置的映射文件 <code>SampleMapper.xml</code></p></li><li><p>Mapper 接口：</p><ul><li>在 SampleMapper.xml 中 namespace 等于 Mapper 的接口地址 ( <code>全路径地址</code> )；</li><li>在 Mapper 接口中的 <code>方法名</code> 和 SampleMapper.xml 中 Statement 的 <code>ID</code> 名称一致；</li><li>在 Mapper 接口中的方法 <code>输入参数类型</code> 和 SampleMapper.xml 中 Statement 的 <code>parameterType</code> 指定的类型一致。</li><li>在 Mapper 接口中的 <code>方法返回值类型</code> 和 SampleMapper.xml 中 Statement 的 <code>resultType</code> 指定的类型一致。</li></ul></li><li><p>关于规范的启示：故我们进行 Mapper 的开发应该遵循一些规范，这样 MyBatis 方可自动生成 <code>XXXMapper</code> 类的代理实现类。</p><ul><li>保证 XXXMapper.xml 中的 <code>namespace</code> 同 XXXMapper.java 的 <code>全限定名称</code> 一致；</li><li>保证 XXXMapper.xml 中的 <code>Statement ID</code> 同 XXXMapper.java 的 <code>方法名称</code> 一致；</li><li><p>保证 XXXMapper.xml 中的 Statement 的输入参数的类型 ( <code>parameterType</code> )、输出参数的类型 ( <code>resultType</code> ) 同 <code>XXXMapper.java</code> 的保持一致.</p><p><img src="/images/illustration/Project/2018/08/J2EE-SSM-1_6-2.png" alt="图6-2Mapper代理开发规范"></p><center>图6-2 Mapper 代理开发规范</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mapper 接口：cn.kofes.ssm.mapper.SampleMapper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertOneTuple</span><span class="params">(Sample sample)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteOneTupleById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOneTupleById</span><span class="params">(Sample sample)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample <span class="title">findCertainTupleById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单元测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleMapperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">private</span>  SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 加载 MyBatis 配置文件，得到配置文件流</span></span><br><span class="line">        InputStream inputStream =</span><br><span class="line">            Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        <span class="comment">// 创建会话工厂</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory =</span><br><span class="line">            <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        <span class="comment">// 通过会话工厂，得到 SqlSession 对象</span></span><br><span class="line">        sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindCertainTupleById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SampleMapper sampleMapper = sqlSession.getMapper(SampleMapper.class);</span><br><span class="line">        System.out.println( sampleMapper.findCertainTupleById(<span class="number">15</span>).toString() );</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>当然不要忘记在全局配置文件 <code>SqlMapConfig.xml</code> 中加载映射文件 ( 参考上述配置文件 )。</p></li></ul><h5 id="POJO-包装类型查询"><a href="#POJO-包装类型查询" class="headerlink" title="POJO 包装类型查询"></a>POJO 包装类型查询</h5><h6 id="输入映射"><a href="#输入映射" class="headerlink" title="输入映射"></a>输入映射</h6><ul><li><p>输入映射：通过 parameterType 指定输入参数的类型，类型可以是 <code>简单类型</code>，也可以是  <code>POJO</code>、<code>HashMap</code> 类型。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义包装类型 POJO：自定义所需要的查询条件，实现多表查询</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">POJOCollection</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为更加形象、理解，这里引入用户和部门的实体类</span></span><br><span class="line"><span class="comment">     * 一个用户对应一个部门，一个部门包含多个用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> User user; <span class="comment">// User 实体类</span></span><br><span class="line">    <span class="keyword">private</span> Department department; <span class="comment">// Department 实体类</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">POJOCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        user = <span class="keyword">new</span> User();</span><br><span class="line">        department = <span class="keyword">new</span> Department();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 Setter 和 Getter 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123; <span class="keyword">this</span>.user = user; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> user; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDepartment</span><span class="params">(Department department)</span> </span>&#123; <span class="keyword">this</span>.department = department; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDepartment</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> department; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在映射文件 <code>SampleMapper.xml</code> 中配置 SQL 语句：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  自定义所需要的查询条件，实现多表查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findPOJOList"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">parameterType</span>=<span class="string">"cn.kofes.ssm.pojo.POJOCollection"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">resultType</span>=<span class="string">"cn.kofes.ssm.pojo.User"</span>&gt;</span></span><br><span class="line">    SELECT * FROM t_user as u, t_department as d</span><br><span class="line">    WHERE u.uid = #&#123;user.uid&#125; and d.depart_id = #&#123;department.depart_id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Mapper 接口：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mapper 接口：cn.kofes.ssm.mapper.SampleMapper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Sample&gt; <span class="title">findPOJOList</span><span class="params">(POJOCollection pojoCollection)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单元测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleMapperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">private</span>  SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindPOJOList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Mapper 接口代理</span></span><br><span class="line">        SampleMapper sampleMapper =</span><br><span class="line">            sqlSession.getMapper(SampleMapper.class);</span><br><span class="line"></span><br><span class="line">        POJOCollection pojoCollection = <span class="keyword">new</span> POJOCollection();</span><br><span class="line">        pojoCollection.getUser().setUid(<span class="number">50</span>);</span><br><span class="line">        pojoCollection.getDepartment().setDepart_id(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; list =</span><br><span class="line">            sampleMapper.findPOJOList(pojoCollection);</span><br><span class="line">        System.out.println( list.get(<span class="number">0</span>).toString() );</span><br><span class="line"></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="输出映射"><a href="#输出映射" class="headerlink" title="输出映射"></a>输出映射</h6><ul><li><p>输出映射：使用 resultType 进行输出映射，查询列名和 POJO 中的属性名一致，该列才会成功映射。</p><blockquote><p>若查询出来的列名 ( 通过 AS 自定义的列名 ) 和 POJO 的属性名不一致，通过定义一个 resultMap 对列名和属性名之间作一个映射关系。</p></blockquote></li><li><p>定义 resultMap：在映射文件 <code>SampleMapper.xml</code> 中定义；</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> | id：resultMap 唯一标识</span></span><br><span class="line"><span class="comment"> | type：</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"sampleResultMap"</span> <span class="attr">type</span>=<span class="string">"cn.kofes.ssm.pojo.Sample"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     | id 表示查询结果集中的唯一标识</span></span><br><span class="line"><span class="comment">     | colum：查询出来的列名 ( AS 自定义列名 )</span></span><br><span class="line"><span class="comment">     | property：type 指定的 POJO 类型中的属性名</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id_"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     | result 对非 ID 的属性进行映射定义</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name_"</span> <span class="attr">property</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用 resultMap 作为 Statement 的输出映射类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listCustomView"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"sampleResultMap"</span>&gt;</span></span><br><span class="line">    SELECT id as id_, name as name_</span><br><span class="line">    FROM t_sample</span><br><span class="line">    WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Mapper 接口：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mapper 接口：cn.kofes.ssm.mapper.SampleMapper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample <span class="title">listCustomView</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单元测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleMapperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">private</span>  SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListCustomView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Mapper 接口代理</span></span><br><span class="line">        SampleMapper sampleMapper = </span><br><span class="line">            sqlSession.getMapper(SampleMapper.class);</span><br><span class="line">           </span><br><span class="line">        System.out.println( sampleMapper.listCustomView(<span class="number">15</span>) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="映射对比"><a href="#映射对比" class="headerlink" title="映射对比"></a>映射对比</h6><ul><li><code>resultType</code> 查询出来的列名 ( 通过 AS 自定义的列名 ) 和 POJO 的属性名需一致，该列才会成功映射。<br>  <code>resultMap</code> 可根据查询出来的列名指定 POJO 类型中的应的属性名。</li><li><code>resultType</code> 返回的是 User 对象，适应较简单的输出结果映射，MyBatis 其实还提供了<code>resultMap</code> 作为复杂输出结果映射。在 <a href="#高级映射">高级映射</a> 章节将对比阐述。</li></ul><h5 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h5><p>MyBatis 核心是对 SQL 语句进行灵活操作，通过表达式进行判断，对 SQL 进行灵活拼接、组装。</p><ul><li>SQL 语句 <code>拼接</code>，例如 <code>&lt;where&gt;</code> 和 <code>&lt;if&gt;</code> 标签的组合使用；</li><li>SLQ 语句 <code>抽离</code>，例如 <code>&lt;sql&gt;</code> 和 <code>&lt;include&gt;</code> 标签的组合使用； </li><li><p>Foreach：向 SQL 传递数组或 List 集合，MyBatis 使用 <code>&lt;foreach&gt;</code> 标签解析。例如，我们需要查询多个 ID 值；</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将通用的 SQL 语句抽离，例如：属性名、表名等 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"t_sample"</span>&gt;</span>t_sample<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findPOJOList"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">parameterType</span>=<span class="string">"cn.kofes.ssm.pojo.POJOCollection"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">resultType</span>=<span class="string">"cn.kofes.ssm.pojo.Sample"</span>&gt;</span></span><br><span class="line">    SELECT * FROM <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"t_sample"</span> /&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- 自动去掉条件中第一个 AND 或者 OR  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Case.01.注意下面这种写法只适用于 id 类型为 String  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">" sample.id != null and sample.id != '' "</span>&gt;</span></span><br><span class="line">            AND sample.id = #&#123;sample.id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">" other.id != null and other.id  != '' "</span>&gt;</span></span><br><span class="line">            AND other.id = #&#123;other.id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">&lt;!-- Case.02.若 id 类型为 Integer 需要以下写法 </span></span><br><span class="line"><span class="comment">        &lt;if test="_parameter!=null and _parameter &gt; 0"&gt;</span></span><br><span class="line"><span class="comment">            AND id = #&#123;id&#125;</span></span><br><span class="line"><span class="comment">        &lt;/if&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- Case.03.查询多个 ID 值 --&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--  拼接效果：AND(id = ? OR id = ? OR id = ?) </span></span><br><span class="line"><span class="comment">        &lt;if test="ids != null"&gt;</span></span><br><span class="line"><span class="comment">            &lt;foreach collection="ids" item="id" </span></span><br><span class="line"><span class="comment">                open="AND (" close=")" separator="OR"&gt;</span></span><br><span class="line"><span class="comment">                id = #&#123;id&#125;</span></span><br><span class="line"><span class="comment">            &lt;/foreach&gt;</span></span><br><span class="line"><span class="comment">        &lt;/if&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--  拼接效果：IN(1, 3, 5)</span></span><br><span class="line"><span class="comment">        &lt;if test="ids != null"&gt;</span></span><br><span class="line"><span class="comment">            &lt;foreach collection="ids" item="id" </span></span><br><span class="line"><span class="comment">                open="IN (" close=")" separator=","&gt;</span></span><br><span class="line"><span class="comment">                id = #&#123;id&#125;</span></span><br><span class="line"><span class="comment">            &lt;/foreach&gt;</span></span><br><span class="line"><span class="comment">        &lt;/if&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="高级映射"><a href="#高级映射" class="headerlink" title="高级映射"></a>高级映射</h5><p>为便于后续章节的学习，这里以用户表、商品表、订单表和订单明细表的实例来阐述问题：</p><p><img src="/images/illustration/Project/2018/08/J2EE-SSM-1_6-3.png" alt="图6-3用户购物清单ER图"></p><center>图 6-3 用户购物清单 ER 图</center><ul><li>用户表 ( User )：购买商品的用户信息；</li><li>商品表 ( Item )：商品的明细信息；</li><li>订单表 ( Order )：用户所创建的订单；</li><li><p>订单明细表 ( OrderDetail )：每一张订单记录购买的商品信息；</p><blockquote><p>为便于理解，数据表与 POJO ( 实体类 ) 的名称统一命名为相同名称。</p></blockquote></li></ul><h6 id="一对一映射"><a href="#一对一映射" class="headerlink" title="一对一映射"></a>一对一映射</h6><p>便于理解，我们可以确立一需求：查询订单表，关联查询 <code>创建订单的用户信息</code>。</p><p>User 和 Order 的关联查询，关键是查询出来的结果如何映射？是用 resultType，还是用 resultMap？</p><p>1) <code>resultType</code>  </p><p>显然我们的实体类 ( User 仅仅包含用户信息，Order 仅仅包含订单信息，Order 中没有 User 的引用 ) 并不能接受关联查询的结果集，那么我们可以考虑使用 OrderVoUser 映射类，即让它 <code>extends Orders</code>，然后在加上一些 User 的属性作为输出结果类型。</p><blockquote><p>OrdersVoUser 映射类的创建原理与上述的 POJOCollection 映射类一样。</p></blockquote><p>2) <code>resultMap</code>  </p><p>可满足复杂输出结果映射，例如数据库字段名称与查询的字段名称 ( 或通过 AS 声明了别名 ) 不一致的映射；延迟加载；一对一，一对多，多对多等高级映射特性。</p><blockquote><p>这里引用实例说明，即使用 resultMap 将查询结果中的订单信息映射到 Other 对象中，在 Order 类中添加 User 属性，将关联查询出来的用户信息映射到 Other 对象中的 User 属性中。 </p></blockquote><ul><li><p>配置映射文件 Mapper.xml </p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 映射文件 Mapper.xml --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 订单查询映关联查询用户信息的 resultMap  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"OrderUserResultMap"</span> <span class="attr">type</span>=<span class="string">"cn.kofes.ssm.pojo.Order"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">     | 配置映射的订单信息</span></span><br><span class="line"><span class="comment">     | colum：订单信息的列名</span></span><br><span class="line"><span class="comment">     | property：订单信息的列名所映射到 POJO 中的属性名</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"order_id"</span> <span class="attr">property</span>=<span class="string">"order_id"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"createtime"</span> <span class="attr">property</span>=<span class="string">"createtime"</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">     | 配置映射的关联用户信息</span></span><br><span class="line"><span class="comment">     | association 标签中 javaType 必须要明确指明类型</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">javaType</span>=<span class="string">"cn.kofes.ssh.pojo.User"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"uid"</span> <span class="attr">property</span>=<span class="string">"uid"</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">property</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">property</span>=<span class="string">"age"</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"phone"</span> <span class="attr">property</span>=<span class="string">"phone"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- SQL 语句：查询订单表，关联查询创建订单的用户信息  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findOrderUserResultMap"</span> <span class="attr">resultMap</span>=<span class="string">"OrderUserResultMap"</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">        u.uid, u,username, u.age, u.phone, </span><br><span class="line">        o.order_id</span><br><span class="line">    FROM</span><br><span class="line">        Order AS o, User AS u</span><br><span class="line">    WHERE</span><br><span class="line">        o.id = u.uid</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Mapper 接口：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SampleMapper 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">findOrderUserResultMap</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单元测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleMapperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">private</span>  SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindOrderUserResultMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Mapper 接口代理</span></span><br><span class="line">        SampleMapper sampleMapper = </span><br><span class="line">            sqlSession.getMapper(SampleMapper.class);</span><br><span class="line">           </span><br><span class="line">        List&lt;Order&gt; list = sampleMapper.findOrderUserResultMap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="一对多映射"><a href="#一对多映射" class="headerlink" title="一对多映射"></a>一对多映射</h6><p>确立一需求：查询订单及订单明细的信息。</p><ul><li><p>实体类配置</p><blockquote><p>为了满足二级缓存需求，所有实体类实现 <code>Serializablle</code> 接口，实现序列化。</p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getter 和 Setter 方法要实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer order_id;</span><br><span class="line">    <span class="keyword">private</span> Date createtime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把订单所对应的订单明细映射到 orderDetail 属性中</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderDetail&gt; orderDetail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getter 和 Setter 方法要实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDetail</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer orderdetail_id;</span><br><span class="line">    <span class="keyword">private</span> Integer item_id;</span><br><span class="line">    <span class="keyword">private</span> Integer order_id;</span><br><span class="line">    <span class="keyword">private</span> Integer amount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getter 和 Setter 方法要实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer item_id;</span><br><span class="line">    <span class="keyword">private</span> String itemname;</span><br><span class="line">    <span class="keyword">private</span> String itemprice;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// Getter 和 Setter 方法要实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置映射文件 Mapper.xml </p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 映射文件 Mapper.xml --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 查询订单及关联查询订单明细的 resultMap  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"OrderAndOrderDetailResultMap"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"cn.kofes.ssm.pojo.Order"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">extend</span>=<span class="string">"OrderUserResultMap"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置映射的订单信息 --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 配置映射的用户信息 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过继承免去重复配置：extend="Objective ResultMap ID" --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">     | 配置映射的订单明细信息：使用 Collection 对关联查询的多条记录</span></span><br><span class="line"><span class="comment">     | 映射到一个 List 集合属性中</span></span><br><span class="line"><span class="comment">     | ofType：指定映射到集合属性中 POJO 的类型</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"orderDetail"</span> <span class="attr">ofType</span>=<span class="string">"cn.kofe.ssm.pojo.OrderDetail"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"orderdetail_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"item_id"</span> <span class="attr">property</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"order_id"</span> <span class="attr">property</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"amount"</span> <span class="attr">property</span>=<span class="string">"amount"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- SQL：查询订单及订单明细的信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"findOrderAndOrderDetailResultMap"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">resultMap</span>=<span class="string">"OrderAndOrderDetailResultMap"</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">        o.order_id, o.createtime, </span><br><span class="line">        od.item_id, od.amount,</span><br><span class="line">        i.itemname</span><br><span class="line">    FROM</span><br><span class="line">        Order AS o, Item AS i, OrderDetail As od</span><br><span class="line">    WHERE </span><br><span class="line">        od.order_id = o.order_id AND </span><br><span class="line">        od.item_id = i.item_id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Mapper 接口：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SampleMapper 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">findOrderAndOrderDetailResultMap</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单元测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleMapperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">private</span>  SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindOrderAndOrderDetailResultMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Mapper 接口代理</span></span><br><span class="line">        SampleMapper sampleMapper = </span><br><span class="line">            sqlSession.getMapper(SampleMapper.class);</span><br><span class="line">           </span><br><span class="line">        List&lt;Order&gt; list = sampleMapper.findOrderAndOrderDetailResultMap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="多对多映射"><a href="#多对多映射" class="headerlink" title="多对多映射"></a>多对多映射</h6><p>确立一需求：查询用户及用户购买的商品信息。</p><p>在多对多映射中，具体的映射思路是：<br>1) 在 User 实体类中添加订单列表属性 <code>List&lt;Order&gt; orderList</code>，将用户创建的订单映射到 orderList。<br>2) 在 Order 实体类中添加订单明细列表属性 <code>List&lt;OrderDetail&gt; orderDetail</code>，将订单的明细映射到 orderDetail。<br>3) 在 OrderDetail 实体类中添加 <code>Item</code> 属性，将订单明细所对应的商品映射到 item。  </p><ul><li><p>实体类配置</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将用户创建的订单映射到 orderList</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orderList;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getter 和 Setter 方法要实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer order_id;</span><br><span class="line">    <span class="keyword">private</span> Date createtime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将订单所对应的订单明细映射到 orderDetail 属性中</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderDetail&gt; orderDetail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getter 和 Setter 方法要实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDetail</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer orderdetail_id;</span><br><span class="line">    <span class="keyword">private</span> Integer item_id;</span><br><span class="line">    <span class="keyword">private</span> Integer order_id;</span><br><span class="line">    <span class="keyword">private</span> Integer amount;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Item item;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getter 和 Setter 方法要实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer item_id;</span><br><span class="line">    <span class="keyword">private</span> String itemname;</span><br><span class="line">    <span class="keyword">private</span> String itemprice;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// Getter 和 Setter 方法要实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置映射文件 Mapper.xml </p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 映射文件 Mapper.xml --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 查询用户及关联查询用户购买的商品信息的 resultMap  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"UserAndItemResultMap"</span> <span class="attr">type</span>=<span class="string">"cn.kofes.ssm.pojo.User"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 配置用户信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"uid"</span> <span class="attr">property</span>=<span class="string">"uid"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">property</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">property</span>=<span class="string">"age"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"phone"</span> <span class="attr">property</span>=<span class="string">"phone"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">     | 配置映射的订单信息：使用 Collection 对关联查询的多条记录</span></span><br><span class="line"><span class="comment">     | 映射到一个 List 集合属性中</span></span><br><span class="line"><span class="comment">     | ofType：指定映射到集合属性中 POJO 的类型</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"orderList"</span> <span class="attr">ofType</span>=<span class="string">"cn.kofe.ssm.pojo.Order"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"order_id"</span> <span class="attr">property</span>=<span class="string">"order_id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"createtime"</span> <span class="attr">property</span>=<span class="string">"createtime"</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 配置映射的订单明细信息：一个订单包含多个订单明细 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"orderDetail"</span> <span class="attr">ofType</span>=<span class="string">"cn.kofe.ssm.pojo.OrderDetail"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"orderdetail_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"item_id"</span> <span class="attr">property</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"order_id"</span> <span class="attr">property</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"amount"</span> <span class="attr">property</span>=<span class="string">"amount"</span> /&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">&lt;!-- 配置映射的商品信息：一个订单明细对应一个商品 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"item"</span> <span class="attr">javaType</span>=<span class="string">"cn.kofes.ssm.pojo.Item"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"item_id"</span> <span class="attr">property</span>=<span class="string">"item_id"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"itemname"</span> <span class="attr">property</span>=<span class="string">"itemname"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"itemprice"</span> <span class="attr">property</span>=<span class="string">"itemprice"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- SQL：查询用户信息和用户购买过的商品信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserAndItemResultMap"</span> <span class="attr">resultMap</span>=<span class="string">"UserAndItemResultMap"</span>&gt;</span></span><br><span class="line">    SELECT </span><br><span class="line">        u.uid, u.username, </span><br><span class="line">        o.order_id,</span><br><span class="line">        od.item_id, od.amount</span><br><span class="line">        i.itemname, i.itemprice</span><br><span class="line">    FROM</span><br><span class="line">        Order AS o, User AS u, Item AS i, OrderDetail As od</span><br><span class="line">    WHERE</span><br><span class="line">        o.user_id = u.uid AND</span><br><span class="line">        od.order_id = o.order_id AND</span><br><span class="line">        od.item_id = i.item_id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Mapper 接口：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SampleMapper 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserAndItemResultMap</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单元测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleMapperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">private</span>  SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindUserAndItemResultMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Mapper 接口代理</span></span><br><span class="line">        SampleMapper sampleMapper = </span><br><span class="line">            sqlSession.getMapper(SampleMapper.class);</span><br><span class="line">           </span><br><span class="line">        List&lt;User&gt; list = sampleMapper.findUserAndItemResultMap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="高级映射总结"><a href="#高级映射总结" class="headerlink" title="高级映射总结"></a>高级映射总结</h6><ul><li>一对一映射：在 <code>Order</code> 实体对象中引入 <code>User</code> 属性，且在配置文件 Mapper.xml 中，通过 <code>&lt;association&gt;</code> 标签关联用户信息。</li><li>一对多映射：在 <code>Order</code> 实体对象中添加订单明细列表属性 <code>List&lt;OrderDetail&gt; orderDetails</code>，且在配置文件 Mapper.xml 中，通过 <code>&lt;collection&gt;</code> 标签关联订单明细信息。</li><li>多对多映射：<ul><li>在 User 实体对象中添加订单列表属性 <code>List&lt;Order&gt; orderList</code>，将用户创建的订单映射到 orderList。  </li><li>在 Order 实体对象中添加订单明细列表属性 <code>List&lt;OrderDetail&gt; orderDetail</code>，将订单的明细映射到 orderDetail。  </li><li>在 OrderDetail 实体对象中添加 <code>Item</code> 属性，将订单明细所对应的商品映射到 item。</li></ul></li></ul><h5 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h5><ul><li><p>延迟加载，即需要时才发出 SQL 查询请求。Hibernate 中有延迟加载，MyBatis 同样提供了这个功能，具体以 <code>&lt;resultMap&gt;</code> 标签的属性完成配置。当然，我们可具体分析 MyBatis 的延迟加载。</p></li><li><p>MyBatis是默认开启延迟加载的么？如果不是，那么显然应该进行延迟加载配置。</p><p>  在 MyBatis 的全局核心配置文件 SqlMapConfig.xml 的 <code>&lt;settings&gt;</code> 标签中可设置 lazyLoadingEnabled 以及 aggressiveLazyLoading 属性值。</p><ul><li><p><code>lazyLoadingEnabled</code>：全局性设置懒加载，默认值为 flase，即所有相关联的都会被初始化加载。</p></li><li><p><code>aggressiveLazyLoading</code>：默认值为 ture，懒加载的对象可能被任何懒属性全部加载。否者，每个属性按需加载。</p></li></ul></li><li><p>要实现延迟加载，就得进行 SQL 拆分 ( 若我们的SQL都写在一起，DB要么执行，要么不执行，根本做不到按需查询，所以要延迟加载就得拆分 SQL ) 那么怎么进行拆分呢？</p><p>  在 resultMap 中的 <code>&lt;collection&gt;</code> 以及 <code>&lt;association&gt;</code> 标签中有 <code>select</code> 属性，也就是说当使用到了 <code>&lt;collection&gt;</code> 或者 <code>&lt;association&gt;</code> 时才发出 <code>select</code> 属性对应的 SQL。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 映射文件 Mapper.xml --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 延迟加载的 resultMap --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"OrderUserLazyLoadingResultMap"</span> <span class="attr">type</span>=<span class="string">"cn.kofes.ssm.pojo.Order"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"order_id"</span> <span class="attr">property</span>=<span class="string">"order_id"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"createtime"</span> <span class="attr">property</span>=<span class="string">"createtime"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 实现对用户信息进行延迟加载</span></span><br><span class="line"><span class="comment">     | select 属性：指定延迟加载需要执行的 Statement 的 ID，</span></span><br><span class="line"><span class="comment">     | 即根据 user_id 查询用户信息的 Statement</span></span><br><span class="line"><span class="comment">     | column 属性：订单信息中关联查询用户信息得到的列，</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">javaType</span>=<span class="string">"cn.kofes.ssh.pojo.User"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">select</span>=<span class="string">"findUserById"</span> <span class="attr">column</span>=<span class="string">"user_id"</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Step.01.查询订单管理查询用户信息，用户信息需要延迟加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"finOrderUserLazyLoading"</span> <span class="attr">resultMap</span>=<span class="string">"OrderUserLazyLoadingResultMap"</span>&gt;</span></span><br><span class="line">    SELECT * FROM Order</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Step.02.关联查询用户信息：根据订单信息中的 user_id 去关联查询用户信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"findUserById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"cn.kofes.ssm.pojo.User"</span>&gt;</span></span><br><span class="line">    SELECT * FROM User WHERE user_id = #&#123;user_id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> | 执行顺序：即先执行 finOrderUserLazyLoading，</span></span><br><span class="line"><span class="comment"> | 当需要查询用户时在再执行 findUserById</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>我们其实可以借助 MyBatis 去完成延迟加载，也可以自己实现延迟加载。怎么做呢？即有需求时，我们自己调用相应的 Statement 完成即可。</li></ul><h5 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h5><p><img src="/images/illustration/Project/2018/08/J2EE-SSM-1_6-4.png" alt="图6-4MyBatis的一级缓存和二级缓存"></p><center>图 6-4 MyBatis 的一级缓存和二级缓存 $^{[3]}$</center><ul><li>MyBatis 提供一级缓存和二级缓存：<ul><li>一级缓存是 sqlSession 级别的缓存。在操作数据库时需要构造 sqlSession 对象，在对象中有一个数据结构 ( HashMap，KEY 主要就是 SqlSession + StatementId 构成 ) 用于存储缓存数据。不同的 sqlSession 之间的缓存数据区域是互不影响的；</li><li>二级缓存是 Mapper 级别的缓存 ( <code>按 Namespace 划分</code> )。多个 sqlSession 去操作同一个 Mapper 的 SQL 语句，多个 sqlSession 去操作数据库得到数据的数据会存到二级缓存中。二级缓存区域是共享的。</li></ul></li></ul><h6 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h6><ul><li>一级缓存的工作原理：<ul><li>如图 6-3 所示，当 sqlSession 发起 <code>查询</code> 操作，查询结果会 <code>写入</code> 到一级缓存中，待二次 <code>读取</code> 直接从一次缓存中读取即可；若 sqlSession 发起 <code>插入、更新、删除</code> 操作，则会 <code>清空</code> 一级缓存区域中的信息，以避免脏读。</li><li>当 sqlSession 关闭时，sqlSession 缓存也随之失效。</li></ul></li><li>MyBatis 是默认支持一级缓存的，无需配置开启。</li></ul><h6 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h6><ul><li><p>二级缓存是需要配置开启的：</p><ul><li>在全局配置文件 <code>SqlMapConfig.xml</code> 中指明，即在 <code>&lt;setting&gt;</code> 标签中的 <code>cacheEnabled</code> 属性，开启全局性缓存开关；</li><li><p>其次在需要开启二级缓存的 <code>XXXMapper.xml</code> 中指明 <code>&lt;cache&gt;</code> 标签。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.kofes.mapper.SampleMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">     | 开启本 Mapper namespace 下的二级缓存</span></span><br><span class="line"><span class="comment">     | type 属性：指定 cache 接口的实现类的类型，默认使用 PerpetualCache</span></span><br><span class="line"><span class="comment">     | </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 当然也可使用分布式缓存：Ehcache</span></span><br><span class="line"><span class="comment">    &lt;cache type="org.mybatis.caches.ehcache.EhcacheCache"/&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>所有 POJO 实现序列化接口：若开启二级缓存，其存储介质可在内存、磁盘等，即为了将缓存数据取出执行反序列化操作。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">/* 省略细节 */</span> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">/* 省略细节 */</span> &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>二级缓存的局限性：</p><p>  例如，我们仅仅更新了其中一个信息，那么意味着二级缓存的清空。而我们真正想要的是刷新该商品的缓存信息而不要影响其他商品的缓存信息。</p></li></ul><h5 id="整合-ehcache"><a href="#整合-ehcache" class="headerlink" title="整合 ehcache"></a>整合 ehcache</h5><ul><li><code>ehcache</code> 是一个分布式缓存框架，当然还有 <code>redis</code>、<code>memached</code> 等。</li><li>分布式缓存，系统为了提高系统并发、性能，一般对系统进行分布式部署 ( 集群部署方式 )。</li><li><p>整合方法：MyBatis 提供的 Cache 接口，实现缓存逻辑即实现 Cache 接口即可。</p><ul><li>提供 ehcache 以及 ehcache 与 MyBatis 整合的依赖 ( 或者 Jar 包 )；</li><li>在 <code>&lt;cache&gt;</code> 标签中，type 属性指明 ehcache 实现 Cache 接口的实现类，既有：<br><code>&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;</code>；</li><li><p>提供相关的 ehcache 配置文件.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBatis 提供的 Cache 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object var1, Object var2)</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">getObject</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">removeObject</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h5><ul><li>MyBatis 官方提供逆向工程，可针对单表自动生成 MyBatis 执行所需要的代码 ( mapper.java，mapper.xml，pojo 等 )。</li><li>企业实际开发中，常用的逆向工程方式：由数据库表生成 Java 代码。</li><li>添加依赖或添加 Jar 包：<a href="http://mvnrepository.com/artifact/org.mybatis.generator/mybatßis-generator-core" target="_blank" rel="noopener">MyBatis-Generator</a> ( Maven 中央仓库 )</li></ul><h6 id="运行逆向工程"><a href="#运行逆向工程" class="headerlink" title="运行逆向工程"></a>运行逆向工程</h6><ul><li>参考官方指南 <a href="http://www.mybatis.org/generator/running/running.html" target="_blank" rel="noopener">MyBatis Generator</a>，运行逆向工程有如下方式：<ul><li>使用命令提示符读取 XML 配置文件；</li><li>使用 Maven 插件；</li><li>使用 Java 程序读取 XML 配置文件 ( 推荐，即不依赖 IDE )；</li><li>使用 IDE 插件 ( Eclipse )；</li></ul></li></ul><h6 id="代码配置文件"><a href="#代码配置文件" class="headerlink" title="代码配置文件"></a>代码配置文件</h6><ul><li><p>MyBatis 官方提供了配置文档的范例：<a href="http://www.mybatis.org/generator/configreference/xmlconfig.html" target="_blank" rel="noopener">MyBatis GeneratorXML Configuration File Reference</a></p><p>  当然，你可以参考下文 $^{[5]}$，搭配注释，互相补充：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- generatorConfig.xml --&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE generatorConfiguration</span></span><br><span class="line"><span class="meta">    PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span><br><span class="line"><span class="meta">    "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"testTables"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否去除自动生成的注释：true / false --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressAllComments"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- ( 必填 ) 数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 连接 MySQL 数据库 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql.jdbc.Driver"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://127.0.0.1:3306/db_testdb?characterEncoding=utf-8"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">userId</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"123456"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 连接 Oracle 数据库</span></span><br><span class="line"><span class="comment">        &lt;jdbcConnection driverClass="oracle.jdbc.OracleDriver"</span></span><br><span class="line"><span class="comment">            connectionURL="jdbc:oracle:thin:@127.0.0.1:1521:db_testdb" </span></span><br><span class="line"><span class="comment">            userId="kofe" password="123456"&gt;</span></span><br><span class="line"><span class="comment">        &lt;/jdbcConnection&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">         | false ( 默认 )，把 Jdbc Decimal 和 Numeric 类型解析为 Integer</span></span><br><span class="line"><span class="comment">         | true，把 Jdbc Decimal 和 Numeric 类型解析为 java.math.BigDecimal</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceBigDecimals"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- targetProject：生成 PO 类的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"cn.kofes.ssm.pojo"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">".\src"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- enableSubPackages 是否让 schema 作为包的后缀 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">&lt;!-- targetProject:mapper 映射文件生成的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"cn.kofes.ssm.mapper"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">".\src"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- enableSubPackages 是否让 schema 作为包的后缀 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">&lt;!-- targetPackage:mapper 接口生成的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetPackage</span>=<span class="string">"cn.kofes.ssm.mapper"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">".\src"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- enableSubPackages 是否让 schema 作为包的后缀 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">&lt;!-- 指定数据库表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"Item"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"Order"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"Orderdetail"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"User"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        &lt;table schema="" tableName="sys_user"&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment">        &lt;table schema="" tableName="sys_role"&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment">        &lt;table schema="" tableName="sys_permission"&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment">        &lt;table schema="" tableName="sys_user_role"&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment">        &lt;table schema="" tableName="sys_role_permission"&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 有些表的字段需要指定 Java 类型</span></span><br><span class="line"><span class="comment">        &lt;table schema="" tableName=""&gt;</span></span><br><span class="line"><span class="comment">            &lt;columnOverride column="" javaType="" /&gt;</span></span><br><span class="line"><span class="comment">        &lt;/table&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="执行逆向工程生成代码"><a href="#执行逆向工程生成代码" class="headerlink" title="执行逆向工程生成代码"></a>执行逆向工程生成代码</h6><ul><li><p>配置文件配置完成后，执行以下程序即可生成代码，细节如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratorSqlmap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generator</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; warnings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> overwrite = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//指定逆向工程配置文件</span></span><br><span class="line">        File configFile = <span class="keyword">new</span> File(<span class="string">"generatorConfig.xml"</span>); </span><br><span class="line">        </span><br><span class="line">        ConfigurationParser cp = <span class="keyword">new</span> ConfigurationParser(warnings);</span><br><span class="line">        Configuration config = cp.parseConfiguration(configFile);</span><br><span class="line">        DefaultShellCallback callback = <span class="keyword">new</span> DefaultShellCallback(overwrite);</span><br><span class="line">        MyBatisGenerator myBatisGenerator = <span class="keyword">new</span> MyBatisGenerator(config,</span><br><span class="line">            callback, warnings);</span><br><span class="line">        myBatisGenerator.generate(<span class="keyword">null</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 generator() 执行逆向工程生成代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            GeneratorSqlmap generatorSqlmap = <span class="keyword">new</span> GeneratorSqlmap();</span><br><span class="line">            generatorSqlmap.generator();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>值得注意的是，除了生成基本的 POJO 类还多了一个类，就是 <code>xxxExample.java</code>。这个类是给用户自定义 SQL 使用的。到这里就生成好了，下面我们就把生成的代码 <code>拷贝</code> 到自己的工程即可。</p></li></ul><hr><h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><ul><li>Spring 框架是 Java 应用最广的框架，其成功源于它的理念，即 <code>控制反转</code> ( Inversion of Control，IoC ) 和 <code>面向切面编程</code> ( Aspect Oriented Programming，AOP )。</li><li>Spring 框架也可理解为一个轻量级的 IoC 和 AOP 的容器框架。</li><li><p>Spring 框架在 <a href="https://www.kofes.cn/2018/07/J2EE-SSH-SSI-1.html#Spring">SSH 部分</a> 有阐述，在本章节就不具体展开探讨，笔记以补充和整合部分内容为主。</p><blockquote><p>在 SSH Spring 章节中，要求导入相关 Jar 包，而本文的 SSM 框架要求导入的 Jar 包 ( 或者 Maven 依赖 ) 以 <code>版本信息</code> 的为标准。</p></blockquote></li></ul><h5 id="Spring-整合-MyBatis"><a href="#Spring-整合-MyBatis" class="headerlink" title="Spring 整合 MyBatis"></a>Spring 整合 MyBatis</h5><p>Spring 整合 MyBatis 是通过 <code>MyBatis-Spring</code> 的类库实现的，具体配置和使用信息可参考 <a href="http://www.mybatis.org/spring/zh/index.html" target="_blank" rel="noopener">MyBatis-Spring 官方使用文档</a> $^{[4]}$。</p><h6 id="原始-DAO-开发"><a href="#原始-DAO-开发" class="headerlink" title="原始 DAO 开发"></a>原始 DAO 开发</h6><p>首先要向 DAO 的实现类中注入 SqlSessionFactory ( 交由 Spring 管理，即 Spring 声明式注入 SqlSessionFactory )，然后在各个方法中得到 SqlSession 进行数据库操作。</p><blockquote><p><code>诉求</code>：在 Spring 运作中，首先加载 Spring 核心配置文件，再创建对象 ( SqlSessionFactory )。而创建对象可通过 New 的方式创建 ( <a href="#MyBatis-原始方法">原始方法</a> )，但效率太低，则我们可以把加载配置文件和创建对象过程，在服务器启动时完成。故引入 Spring 声明式注入 SqlSessionFactory。</p></blockquote><ul><li>使用封装的方法，即让 Dao 的实现类继承 <code>SqlSessionDaoSupport</code>，而 SqlSessionDaoSupport 类中已经存在 <code>setSqlSessionFactory()</code> 方法，因此我们可以直接向 Dao 的实现类注入 SqlSessionFactory。</li><li><p>另外 SqlSessionDaoSupport 中有 SqlSession，因此使得操作更加简单；而且都交给 Spring 管理，我们自然不必担心忘记关闭 SqlSession。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下述实现是通过 XML 配置方式加载配置和 Bean ( 注解方式也是可行的，但写法有区别 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dao 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Sample&gt; <span class="title">findSampleById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dao 层实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleDaoImpl</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">BaseDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SampleDaoImpl</span><span class="params">()</span> <span class="keyword">throws</span> Expection </span>&#123;</span><br><span class="line">        sqlSession = <span class="keyword">this</span>.getSqlSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample <span class="title">findSampleById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSession.selectOne(</span><br><span class="line">            <span class="string">"cn.kofes.ssm.mapper.SampleMapper.findSampleById"</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单元测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleDaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BaseDao baseDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        applicationContext = </span><br><span class="line">            <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:spring.xml"</span>);</span><br><span class="line">        baseDao = (BaseDao) applicationContext.getBean(<span class="string">"baseDao"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindCertainById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println( baseDao.findSampleById(<span class="number">15</span>).toString() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="Mapper-代理开发-1"><a href="#Mapper-代理开发-1" class="headerlink" title="Mapper 代理开发"></a>Mapper 代理开发</h6><ul><li><p>Mapper 代理开发的具体思路：</p><ul><li><p>SqlSessionFactory 交给 Spring 管理 ( 单例模式 )。</p><p>注意到 SqlSessionFactory 的创建显然需要数据库连接相关的信息，因此需要 <code>数据库连接池 (c3p0)</code>；除此之外还需要 MyBatis 的主配置文件 <code>SqlMapConfig.xml</code>。</p></li><li><p>Spring 和 MyBatis 整合生成代理对象，使用 SqlSessionFactory 创建 SqlSession ( Spring 和 MyBatis 整合后自动完成此过程 )。</p></li><li><p>若采用 Mapper 代理的方式开发，我们需要 Spring 管理 Mapper 动态代理实现。</p></li></ul></li><li><p>在 Spring 配置文件下配置数据库信息，并整合 MyBatis。后者将 SessionFacotry 交由 Spring 管理：</p><blockquote><p>c3p0.properties 配置文件位于 Src 根目录下，键值分离以便修改配置。</p></blockquote>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring.xml --&gt;</span></span><br><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描包下注解，并注册为 Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.kofes.ssm"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">context:exclude-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">          </span><br><span class="line">    <span class="comment">&lt;!-- 在根目录下新建文件 c3p0.properties，存储数据连接信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:c3p0.properties"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Dao 层的配置，即 Mybatis 的配置 ( 分模块开发思想 ) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"spring/mybatis-spring.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mybatis-spring.xml --&gt;</span></span><br><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 1. 数据源 : DriverManagerDataSource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引用 c3p0.properties 的键值对即可，格式如 $&#123;key.value&#125; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;datasource.driverClass&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;datasource.jdbcUrl&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;datasource.user&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;datasource.password&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置数据库连接池的最大连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;datasource.maxPoolSize&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置数据库连接池的最小连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;datasource.minPoolSize&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置数据库连接池的初始化连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;datasource.initialPoolSize&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置数据库连接池的连接最大空闲时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdleTime"</span> <span class="attr">value</span>=<span class="string">"$&#123;datasource.maxIdleTime&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- c3p0缓存Statement的数量数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatements"</span> <span class="attr">value</span>=<span class="string">"$&#123;datasource.maxStatements&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当连接池的连接用完的，从 C3p0 下获取新的连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireIncrement"</span> <span class="attr">value</span>=<span class="string">"$&#123;datasource.acquireIncrement&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"checkoutTimeout"</span> <span class="attr">value</span>=<span class="string">"$&#123;datasource.checkoutTimeout&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idleConnectionTestPeriod"</span> <span class="attr">value</span>=<span class="string">"$&#123;datasource.idleConnectionTestPeriod&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 配置和 MyBatis 的整合 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3. 配置一个可以执行批量的 SqlSession --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"executorType"</span> <span class="attr">value</span>=<span class="string">"BATCH"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     | 4. MyBatis 自动扫描加载 Sql 映射文件: MapperScannerConfigurer</span></span><br><span class="line"><span class="comment">     | 自动扫描出的 Mapper Bean 的 ID 名称为首字母小写的类名</span></span><br><span class="line"><span class="comment">     | 且效果与 SqlMapConfig.xml 中配置批量加载映射文件相同，即 &lt;package name="cn.kofes.ssm.mapper"/&gt;</span></span><br><span class="line"><span class="comment">     | 1) 批量加载映射文件：mapper.java 与 mapper.xml 同名，且在同一目录下</span></span><br><span class="line"><span class="comment">     | 2) 当然，你可以建立同样的文件夹目录 (cn/kofes/ssm/mapper)，把 mapper.xml 单独放置资源目录下</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"cn.kofes.ssm.mapper"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>代码实现：注解方式实现 Mapper 类的调用：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下述实现是通过注解方式加载配置和 Bean ( XML 方式也是可行的，但写法有区别 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Mapper 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample <span class="title">findCertainTupleById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单元测试类</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"classpath:spring.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleMapperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SampleMapper sampleMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindCertainTupleById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println( </span><br><span class="line">            sampleMapper.findCertainTupleById(<span class="number">15</span>).toString() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h4><ul><li>MVC ( Model-View-Controller ) 模式把应用程序 ( 输入逻辑、业务逻辑和 UI 逻辑 ）分成不同的方面，同时提供这些元素间的松耦合。<ul><li>Model：模型，封装了应用程序的 <code>数据</code> 和由它们组成的 <code>POJO</code>。</li><li>View：视图，负责把模型数据 <code>渲染到视图</code> 上，将数据以一定形式展现给用户。</li><li>Controller：负责 <code>处理用户请求</code>，并建立适当的模型把它传递给视图渲染。</li></ul></li><li>Spring MVC 把 <code>模型</code>、<code>视图</code> 和 <code>控制器</code> 分层，组合成一个有机灵活的系统。</li><li>Spring MVC 中可定义逻辑视图，通过其提供的解析器找到对应的视图渲染；或在 Controller 的方法内加入注解 ( <code>@ResponseBody</code> )，通过消息转换系统将数据转换为 JSON，提供给前端 Ajax 请求使用。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://book.douban.com/subject/27090950/" target="_blank" rel="noopener"> 杨开振. Java EE 互联网轻量级框架整合开发 [M]. 电子工业出版社. 2017</a></li><li>[2] <a href="https://www.jianshu.com/p/91a32e3d4b26" target="_blank" rel="noopener">张丰哲. MyBatis + Spring MVC 开发指南 (一). 简书. 2017</a></li><li>[3] <a href="https://www.jianshu.com/p/48b78ee24fa3" target="_blank" rel="noopener">张丰哲. MyBatis + Spring MVC 开发指南 (二). 简书. 2017</a></li><li>[4] <a href="http://www.mybatis.org/spring/zh/index.html" target="_blank" rel="noopener">MyBatis. MyBatis-Spring 官方使用文档. mybatis.org</a></li><li>[5] <a href="https://blog.csdn.net/yerenyuan_pku/article/details/71909325" target="_blank" rel="noopener">李阿昀. MyBatis 逆向工程自动生成代码. csdn.net. 2017</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;本文章主要围绕 J2EE 中 SSM ( Spring、Spring MVC、MyBatis ) 框架的配置以及使用问题展开学习的，最终目的是输出可复用的版本，以供后续的项目复用。当然，学习和配置的过程难免有不恰当或错误之处，还望朋友指出、斧正。&lt;/p&gt;
&lt;h2 id=&quot;更新进度&quot;&gt;&lt;a href=&quot;#更新进度&quot; class=&quot;headerlink&quot; title=&quot;更新进度&quot;&gt;&lt;/a&gt;更新进度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;2018.08.13：完成初稿，梳理 SSM 框架初识章节；&lt;/li&gt;
&lt;li&gt;2018.08.20：框架内容，梳理 SSM 框架基本内容；&lt;/li&gt;
&lt;li&gt;2018.08.24：框架内容，修正 SSM 框架部分内容；&lt;/li&gt;
&lt;li&gt;2018.08.26：框架内容，整合 Spring 和 MyBatis；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;教学资源&quot;&gt;&lt;a href=&quot;#教学资源&quot; class=&quot;headerlink&quot; title=&quot;教学资源&quot;&gt;&lt;/a&gt;教学资源&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;视频 | &lt;a href=&quot;https://www.bilibili.com/video/av20394903&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;黑马程序员. J2EE 进阶. MyBatis 框架由浅入深. 2017. bilibili.com&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本框架的学习笔记是基于此系列教学视频所得的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文章 | &lt;a href=&quot;https://blog.csdn.net/noaman_wgs/article/details/79503559&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;吴操. 搭建一个基于 SSM 框架的人力资源管理系统. 2018. csdn.net&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;发现这位博主搭建的例子 ( &lt;a href=&quot;https://github.com/nomico271/SSM_HRMS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nomico271. SSM_HRMS. Github&lt;/a&gt; ) 紧凑、简练，适合初入门时来模仿构建自己的项目。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Project" scheme="http://www.kofes.cn/categories/Project/"/>
    
    
      <category term="J2EE" scheme="http://www.kofes.cn/tags/J2EE/"/>
    
      <category term="JSP" scheme="http://www.kofes.cn/tags/JSP/"/>
    
      <category term="Spring" scheme="http://www.kofes.cn/tags/Spring/"/>
    
      <category term="SSM" scheme="http://www.kofes.cn/tags/SSM/"/>
    
      <category term="MyBatis" scheme="http://www.kofes.cn/tags/MyBatis/"/>
    
      <category term="Spring MVC" scheme="http://www.kofes.cn/tags/Spring-MVC/"/>
    
  </entry>
  
</feed>
