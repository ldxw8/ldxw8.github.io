<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kofe</title>
  
  <subtitle>Reading / Project / Paper</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kofes.cn/"/>
  <updated>2020-11-19T15:31:21.937Z</updated>
  <id>http://www.kofes.cn/</id>
  
  <author>
    <name>Kofe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>笔记 | 超级笔记术 &quot;子弹笔记&quot;</title>
    <link href="http://www.kofes.cn/2020/11/bullet-journal.html"/>
    <id>http://www.kofes.cn/2020/11/bullet-journal.html</id>
    <published>2020-11-19T15:27:17.000Z</published>
    <updated>2020-11-19T15:31:21.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="零-引言"><a href="#零-引言" class="headerlink" title="零 引言"></a>零 引言</h2><ul><li>子弹笔记术：概括描述就是以列表的方式，并结合其特色符号及方法，以高效实现有目的性和功能性地去记录任务、事项以及笔记。最直观感受是，本笔记由 Markdown 编写生成，Markdown 所具有的样式特征或多或少正符合着子弹笔记术的指导思想。</li><li>本书更多讲述是方法论，不建议生搬硬套交作业，侧重理解子弹笔记的核心理念，便可设计、创造属于自己的笔记方法论。让我们带着创作的热情，以子弹笔记术为指导方法来书写属于自己的一部自传。</li></ul><h2 id="壹-准备阶段"><a href="#壹-准备阶段" class="headerlink" title="壹 准备阶段"></a>壹 准备阶段</h2><blockquote><p>关键词：做什么；为什么</p></blockquote><h3 id="指导"><a href="#指导" class="headerlink" title="指导"></a>指导</h3><ul><li>初学者指南<ul><li>子弹笔记有两大元素组成：方法和实践。第二章介绍方法（包括要素概念及用途），第三、四章则深入实践。</li><li>推荐顺序方式阅读本书。</li></ul></li><li>非初学指南<ul><li>书中的章节设计是独立子集，若熟悉子弹笔记的术语，可任意阅读感兴趣的章节。</li></ul></li></ul><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li><p>意向性地生活：作者认为是一种遵循自己 <code>信念行动</code> 的生活方式。</p><blockquote><p>与之相反的是 <code>随心所欲</code> 的生活方式。</p></blockquote><ul><li>认同自己的行动；</li><li>关注自己能产生共鸣和兴趣的事物，也需要关注无法产生共鸣和兴趣的事物；</li><li>视作一部持续更新的自传，不断地追踪，自我回顾与思考。</li></ul></li></ul><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><ul><li>选择是有成本的，减少强加于自身的决策，专注于重要的事情。</li><li>思想清单：将想法具象化并记录下来，形成思想清单。<ul><li>正在做的</li><li>应该做的</li><li>想要做的</li></ul></li><li>测验：对于每一项事情，以是否紧要、是否重要的方式思考问题，剔除没有价值的事情，剩余事情分类：<ul><li>需要做的事情：属于你的责任</li><li>想要做的事情：属于你的目标</li></ul></li></ul><h2 id="贰-结构介绍"><a href="#贰-结构介绍" class="headerlink" title="贰 结构介绍"></a>贰 结构介绍</h2><blockquote><p>关键词： 任务单；规划簿；日记本</p></blockquote><h3 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h3><ul><li><code>索引</code>：标题 + 页码 —&gt; 定位内容</li><li><p><code>快速记录</code>：简单的记号或符号捕捉想法（笔记、时间、任务分门别类），并依据时间/优先级等方式排序。</p><p>  |样式 | 备注 |<br>  |:—- | :—- |<br>  | - 笔记 | <code>-</code> 表示为一笔记 |<br>  | ○ 事件 | <code>○</code> 表示为一事件 |<br>  | ● 任务 | <code>●</code> 表示为一任务 |<br>  | ✕ 已完成任务 | <code>✕</code> 表示为已完成的任务 |<br>  | &gt; 迁移的任务 | <code>&gt;</code> 表示为迁移的任务 |<br>  | &lt; 计划中任务 | <code>&lt;</code> 表示为计划中的任务 |<br>  | <del>● 不相关任务</del> | <code>--</code> 表示为不相关的任务 |</p></li><li><p><code>未来记录</code>：记录本月意外的任务和事件。</p></li><li><code>月度记录</code>： 本月的时间安排和任务（或本月的思想清单）。</li><li><code>每日记录</code>：一天零碎的想法。</li><li><p><code>子集</code>：模块化笔记</p><blockquote><p>单独项目独立成项，行为子弹笔记的子集，子集中也存在索引、未来记录、月度记录、每日记录以及快速记录。</p></blockquote></li><li><p><code>迁移</code>：每月从笔记中过滤掉无意义内容的过程。</p></li></ul><h3 id="快速记录"><a href="#快速记录" class="headerlink" title="快速记录"></a>快速记录</h3><ul><li>快速记录法：一言蔽之，就是以不断更新的列表形式，通过特定的符号和结构帮助我们捕捉并管理想法。</li></ul><h3 id="标题页码"><a href="#标题页码" class="headerlink" title="标题页码"></a>标题页码</h3><ul><li><p>确定标题</p><ul><li><p>标题即描述内容：对比以下内容，显然后者的标题信息更实用？</p><p>  |一般形式 |刻意表达 |<br>  | :—-: | :—-: |<br>  |10月13日-第四次会议笔记 |10-13.四.艾米克公司.企业网站更新 |</p></li><li><p>阐明意图：具有意向性、目的性</p></li><li>内容安排</li></ul></li><li>页码索引</li></ul><h3 id="子弹短句"><a href="#子弹短句" class="headerlink" title="子弹短句"></a>子弹短句</h3><ul><li><p>项目分类</p><ul><li>你需要做的事情 — <code>任务</code></li><li>你的经历 — <code>事件</code></li><li><p>你不想遗忘的信息 — <code>笔记</code></p><blockquote><p>每类子弹短句会被赋予特定的符号，其能够帮助你快速捕捉想法、帮助你通过特定的背景理解想法，也便于定位查找特定的内容。</p></blockquote></li></ul></li></ul><h4 id="任务子弹"><a href="#任务子弹" class="headerlink" title="任务子弹"></a>任务子弹</h4><ul><li><p>任务子弹的不同形态</p><p>  | 形态 | 符号 | 说明 |<br>  | :—- | :—- | :—- |<br>  | 任务 | ● 任务 | 需要采取行动的事项 |<br>  | 完成的任务 | * 完成的任务 | 已完成的任务 |<br>  | 迁移的任务 |  &gt; 迁移的任务 | 推迟的月度记录或者某个特定的子集 |<br>  | 计划的任务 | &lt; 计划的任务 | 不在本月范围但被提前前几项的未来记录 |<br>  | 不相关任务 | <del>不相关任务</del> | 计划赶不上变化，怕影响你的注意力则剔除它 |</p></li><li><p>主任务和次任务</p><ul><li>次任务从属于某一主任务，可简单地缩进位列于主任务下方。</li><li>主任务下设过多次任务，建议将该主任务形成独立的子集。</li></ul></li></ul><h4 id="事件子弹"><a href="#事件子弹" class="headerlink" title="事件子弹"></a>事件子弹</h4><ul><li>事件子弹：在事件过去后及时记笔记，保留细节且描述保持简洁。</li></ul><h4 id="笔记子弹"><a href="#笔记子弹" class="headerlink" title="笔记子弹"></a>笔记子弹</h4><ul><li><p>笔记子弹：包括事实、注意、想法、评论，想要记住但又无须或者无法立刻采取行动的信息。</p><blockquote><p>适用于会议、讲座、课堂等。</p></blockquote></li></ul><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><ul><li>特殊符号置于子弹短句前，达到突出短句的目的，方便我们快速定位、浏览。</li><li>尽量减少使用特殊符号和个性化子弹，太多规则反而让记事变得复杂，效率变低。</li></ul><h3 id="每日记录"><a href="#每日记录" class="headerlink" title="每日记录"></a>每日记录</h3><ul><li>每日记录之需要写上今天的日期和页码，利用 <code>快速记录法</code> 将一天的任务、事件、笔记统统记录下来。</li><li><p>设定目标，但不强求设定期望，毕竟期望是我们无法控制的。</p><blockquote><p>自己通常的做法是标记目标的完成度（0 - 100%）。</p></blockquote></li></ul><h3 id="月度记录"><a href="#月度记录" class="headerlink" title="月度记录"></a>月度记录</h3><ul><li><p>日历页（时间轴）</p><ul><li>简短地记述内容，仅供参考所需。</li><li><p>可提前在日历页标注事件与任务，但计划不会一成不变，为此建议完成后补充记录。</p><blockquote><p>体验了时间轴的功能，它不仅阐明了事件内容，且交代了发生时间、发生背景。</p></blockquote></li></ul></li><li><p>任务页（思想清单）</p><ul><li>记录每月需要完成的事务，事务优先级</li><li><p>回顾上月未完成事务，把重要事务记录到下一个月的任务页</p><blockquote><p>从另一角度思考，这反馈了待完成事务的延期信息（是否可以结合甘特图来制定时间计划表？）。</p></blockquote></li></ul></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li>子集索引</li><li><p>专用索引：为某一项计划专门设立的子集，并为之设定索引页。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 公司新网站计划 1.0</span></span><br><span class="line"></span><br><span class="line">头脑风暴 1 - 15</span><br><span class="line">网站设计 16 - 60</span><br><span class="line">用户流 16 - 20</span><br><span class="line">线框图 21 - 30</span><br><span class="line">设计稿 31 - 50</span><br><span class="line">用户测试 51 - 60</span><br><span class="line">网站内容 61 - 90</span><br><span class="line">内容策略 61 - 70</span><br><span class="line">更新后的输入输出系统 / 片段描述 71 - 80</span><br><span class="line">产品描述 81 - 90</span><br></pre></td></tr></table></figure></li><li><p>引线法</p></li></ul><h3 id="任务迁移"><a href="#任务迁移" class="headerlink" title="任务迁移"></a>任务迁移</h3><ul><li><p>定期审视自己的任务，把时间和精力放在真正重要的事情上。</p><blockquote><p>毕竟计划的初衷就是，我们可以完成某件事，但并不要求我们应该/必须完成某件事（期限性和不可控性）。</p></blockquote></li><li><p>月度迁移</p></li><li>年度迁移（全书迁移）：建议笔记以年度归档，将子集以及其未完成的项目计入下一笔记本中。</li><li>思想清单迁移</li></ul><h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><blockquote><p>关键词：行动；信念</p></blockquote><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><ul><li>每日反思<ul><li>被动回应：受到刺激 —&gt; 被动回应 —&gt; 人通常会感到恐惧、焦虑</li><li>意向驱使：受到刺激 —&gt; 主动应对 —&gt; 通过选择/方法/目标 —&gt; 人会积极反思</li></ul></li><li>日反思 —&gt; 规划 </li><li>夜反思 —&gt; 回顾</li><li>通过迁移进行月度反思和年度反思：迁移操作实质上是一种过滤机制，你需要对未完成的任务进行反思，如此迁移才有意向性。</li></ul><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ul><li>思想实验：试想自己站在岔路口，面前有两条路可走，一条人迹更多，另一条人迹更少。待迟暮之年，在个人生活或者专业技术方面会获得什么成就，这样的生活给您带来什么结果？<ul><li><code>人迹更多的路</code>：带你走向更熟悉的地方，是目前生活的延续，只追求舒适的进步，不降低现有生活品质，也不改变现状。</li><li><code>人迹更少的路</code>：带你走向不熟悉的地方，冒险多于舒适的生活。敢于追求感兴趣的目标，愿意通过奋斗来提升自己。</li></ul></li><li>身后反思：分别为两条路创建一份 “两种生活” 的子集。选择你喜欢的生活方式，圈出你最骄傲的成就。完成后把这些事项迁移到你的 <code>目标子集</code>。</li></ul><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>适当的目标：带有意向地设定目标。</li><li>盗用他人的目标，或许会成为一种诱惑，看似很宏大但相对于自己意义不大。例如：挣它一个亿。</li><li>长期的目标：源于自身生活经历，明确意义设定长期目标。</li><li><p>实践</p><ul><li><p><code>54321倒计时法则</code></p><ul><li>将目标分为短期、中期、长期</li><li><p>左边空白两页，左页是你的个人目标，右页是你的职业目标页；每个页面分 5 栏，5 栏依上往下是 5 年内目标、4 月内目标、3 周内目标、2 日内目标以及 1 小时内目标。</p><p>  | 54321倒计时法则 |<br>  | :—- |<br>  | <strong>5 年目标</strong>&lt;/br&gt;组建家庭&lt;/br&gt;购置房产&lt;/br&gt;流利掌握一门语言  |<br>  | <strong>4 月目标</strong>&lt;/br&gt;环岛旅行&lt;/br&gt;体脂降低10%&lt;/br&gt;拜访研究生导师 |<br>  | <strong>3 周目标</strong>&lt;/br&gt;捐赠衣物&lt;/br&gt;志愿活动 |<br>  | <strong>2 日目标</strong>&lt;/br&gt;清理衣柜&lt;/br&gt;打扫房间&lt;/br&gt;激活社保卡 |<br>  | <strong>1 时目标</strong>&lt;/br&gt;月度记账&lt;/br&gt;给父母打电话 |</p><blockquote><p>可以采纳作为记事应用的一项特色功能来开发。</p></blockquote></li></ul></li><li><p><code>分清目标轻重主次</code></p><ul><li>每一栏都分开考虑个人目标和职业目标</li><li>每一栏只考虑一项最先考虑的目标</li></ul></li><li><code>专注于优先事项</code>：注意力残留原则，一次只专注于一件事，专注于实现目标过程。最具价值的也是实现目标的过程，因它占据了大部分的生活，因此提供了大量信息让你成长。</li><li><code>长期目标为冲刺目标</code><ul><li>并不一定要把喜欢的事情变成职业，建议在体验过一段时间后再做决断。</li><li>将长期目标分解一个短期、独立的冲刺目标。类似软件开发的开发周期，即分阶段设立目标。</li></ul></li><li><code>设立冲刺目标的要求</code><ul><li>初始阶段忌设立大障碍目标</li><li>具有清晰可行的任务步骤</li><li>完成时间必须固定在短期内</li></ul></li><li><code>头脑风暴</code>：在分解目标前，我们必须认识考虑，思考要做什么和为什么做？<ul><li>目标为什么会激起我的好奇心？</li><li>是什么鼓励我为这个目标费时费力？</li><li>我要达成什么目标？</li><li>有什么要求？</li><li>在这个目标上，成功的定义是？</li></ul></li></ul></li></ul><h3 id="循序渐进"><a href="#循序渐进" class="headerlink" title="循序渐进"></a>循序渐进</h3><ul><li><code>PDCA 循环</code>：Plan -&gt; Do -&gt; Check -&gt; Act<ul><li>计划 / Plan：发现机会，制定改进计划</li><li>执行 / Do：执行计划，测试改进结果</li><li>检查 / Check：分析测试结果，确认学习成果</li><li>行动 / Act：按照学习成果行动<ul><li>没有改进：换一个计划重新开始，循环上述步骤</li><li>取得改进：结合所学执行新计划，循环上述步骤</li></ul></li></ul></li><li><code>达成小成就</code>：找到任何一种成就，即使微小都无所谓，降低标准保证切实可行，然后以任务子弹的形式写进子弹笔记，完成它以达成成就。</li></ul><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><ul><li>时间箱管理：把任务完成时间规定在一定范围内，其意图是把百分百的注意力按照规定的时间限制投入一事物上。<ul><li>两个关键激励因素：条理感和紧迫感</li></ul></li><li>勿拖延请置顶：找出自己最高效、最专注的时候，事情从难到易排序，以制定执行计划。</li><li>勿忘死亡：人固有一死，珍惜生命一分一秒。</li></ul><h3 id="感恩"><a href="#感恩" class="headerlink" title="感恩"></a>感恩</h3><ul><li>反思完成一项任务对自己的影响？什么感觉，有何价值？</li><li>自我庆祝：根据自己心理预期，对所有事项设定奖励机制，有意识地创造动力以形成良性循环。</li><li>感恩子集：创建 <code>感恩记录</code>，并每天写下至少一件让你感恩的事，养成习惯。因为你对生活的留心观察，微小的幸福汇将促成更美好的生活。</li></ul><h3 id="掌控"><a href="#掌控" class="headerlink" title="掌控"></a>掌控</h3><ul><li>我们无法掌控外部的世界、人和事，但我们能控制自己的内心世界。</li><li>应对与回应：若与他人有冲突之时，冷静分析现状，千万不要有过激行为，毕竟恐惧或愤怒的回应只会加深对方和自身的创伤，失去相互理解、解决问题的机会。因此，需要每日反思重新审视这件事。</li><li><p>过程与结果：</p><ul><li>在进行日反思与夜反思以及月度迁移时，遍历一遍任务列表，试着找出在你掌握之内以及之外的事情。</li></ul></li><li><p>观察这条任务是侧重结果，还是侧重于过程。尽管目标带来方向，若目标过于侧重结果，往往结果是不可控的。</p><blockquote><p>例：减脂 10%、雅思 6.5、做一个很棒的汇报等。</p></blockquote><ul><li>对于过于庞大的目标，尝试把目标分解成一个个可执行的小步骤。</li></ul></li></ul><h3 id="辐射力"><a href="#辐射力" class="headerlink" title="辐射力"></a>辐射力</h3><ul><li>坚信你的一言一行所带有的能量会改变周遭世界和其中的人。</li><li>自我怜悯：自我评判与自我反思。</li><li>共同进步：辐射力是双向的，自己与朋友自己都需要时不时接受对方的审视。找一个朋友，两人互相尊重、赏识、关怀，共同成长。</li></ul><h3 id="忍耐"><a href="#忍耐" class="headerlink" title="忍耐"></a>忍耐</h3><ul><li><p>分析记录：不要把注意力放在干活的痛苦一面，我们更应该关注它带来收获的方面。创建一个 <code>分析记录</code>，留意为什么要做这件事情，努力的具体目的是？</p><blockquote><p>例如：付房租 —&gt; 浪费钱？ &lt;—&gt; 学区房 / 通勤时间短 / 朋友相聚 —&gt; 平衡心中的负面情绪 </p></blockquote></li><li><p>追踪进度：不要轻易放弃，但一件事情对于自己目前来说毫无价值，或是付诸努力与结果不成正比，这可能是分散注意力的事，暂且放下它吧。</p><blockquote><p>利用月度迁移定期检查自己的进度。</p></blockquote></li></ul><h3 id="拆解"><a href="#拆解" class="headerlink" title="拆解"></a>拆解</h3><ul><li>五问法：分解大问题为小问题，在子弹笔记中创建一个子集，以问题为标题，以不同维度提出问题，并挖掘潜在的价值。</li></ul><h3 id="无力感"><a href="#无力感" class="headerlink" title="无力感"></a>无力感</h3><ul><li>橡皮鸭调试法：如身边无人聆听，你可以向一只玩具橡皮鸭写一份信，在详细叙述事情的过程中，可能你已经找到应对方法了。<ul><li>你遇到的问题</li><li>出问题的地方</li><li>出问题的原因</li><li>尝试过的方法</li><li>未尝试的方法</li><li>你想要的结果</li></ul></li><li>停顿目标：<ul><li>时间不可多于两周：在不影响主项目进展情况下，停下来歇歇，可走得更远。</li><li>困扰你的项目 / 问题无关：你和主要项目都需要空间。停顿目标不是要脱离主项目，而是享受一些 “自我时光”。</li><li>关键点是要有明确的开头、结尾和过程。</li></ul></li></ul><h3 id="不完美"><a href="#不完美" class="headerlink" title="不完美"></a>不完美</h3><ul><li>练习不完美</li><li>良好的改变<ul><li>寻求进步的方法，把答案制成任务或目标，记录在子弹笔记中。</li><li>可量化的进步：完成一项任务即得到一段经历。 </li></ul></li></ul><h2 id="艺术创作"><a href="#艺术创作" class="headerlink" title="艺术创作"></a>艺术创作</h2><h3 id="关键概念-1"><a href="#关键概念-1" class="headerlink" title="关键概念"></a>关键概念</h3><ul><li><p>利用个性化子集延伸子弹笔记的功能</p><blockquote><p>注意：个性化子集应具有目的性，不断更新的子集能给你的生活带来价值，提高生产力的关键在于谨慎地投资你的时间。</p></blockquote></li><li><p>明确你的动机</p></li><li><p>温故而知新</p><blockquote><p>研究的不只是你在做的内容，还有这样做的方法。</p></blockquote></li><li><p>功能大于形式</p></li><li><p>设计应具有长效保质期</p><blockquote><p>设计不仅当下浅显易懂，往后回顾也要清晰明白。</p></blockquote></li></ul><h3 id="个性化子集"><a href="#个性化子集" class="headerlink" title="个性化子集"></a>个性化子集</h3><ul><li>个性化子集的设计意图<ul><li>满足特定的需求</li><li>特定的子集设计，具有主题性，可引发思考</li></ul></li><li><p>个性化子集的来源</p><ul><li>目标：大目标、阶段性目标，需要拆分为 n 个小目标来逐个解决。</li><li>难题：通过不同维度解读、分析难题，得出不同解决方案，并记录你的进步。</li><li><p>任务：大任务、发杂性任务，同样可以细分为小任务。</p><blockquote><p>任务还可以结合甘特图管理时间进度，百分比记录小任务甚至整体任务的完成度。</p></blockquote></li></ul></li></ul><h3 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h3><ul><li>分清主次：每个事项清单都应有优先级别设定。</li><li>背景信息：清单中可加入 <code>参考元素</code> 以描述背景信息，例如时间维度、空间维度等。<ul><li>时间信息</li><li>地点信息</li><li>成本信息</li><li>…</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;零-引言&quot;&gt;&lt;a href=&quot;#零-引言&quot; class=&quot;headerlink&quot; title=&quot;零 引言&quot;&gt;&lt;/a&gt;零 引言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;子弹笔记术：概括描述就是以列表的方式，并结合其特色符号及方法，以高效实现有目的性和功能性地去记录任务、事项以及笔
      
    
    </summary>
    
      <category term="Reading" scheme="http://www.kofes.cn/categories/Reading/"/>
    
    
      <category term="todo-list" scheme="http://www.kofes.cn/tags/todo-list/"/>
    
      <category term="手账" scheme="http://www.kofes.cn/tags/%E6%89%8B%E8%B4%A6/"/>
    
      <category term="规划" scheme="http://www.kofes.cn/tags/%E8%A7%84%E5%88%92/"/>
    
      <category term="备忘" scheme="http://www.kofes.cn/tags/%E5%A4%87%E5%BF%98/"/>
    
  </entry>
  
  <entry>
    <title>论文 | 基于根因分析的报警聚类算法</title>
    <link href="http://www.kofes.cn/2019/08/root-cause-analysis-alarm-clustering.html"/>
    <id>http://www.kofes.cn/2019/08/root-cause-analysis-alarm-clustering.html</id>
    <published>2019-08-04T12:27:58.000Z</published>
    <updated>2019-08-04T18:10:45.275Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p>原文：Clustering intrusion detection alarms to support root cause analysis<br>作者：Klaus Julisch<br>来源：ACM Transactions on Information and System Security, 2003, 6(4):443-471.</p></div><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>系统出现故障时，运维人员一般先查看错误日志定位故障原因。</li><li>业务流量小、逻辑复杂度低时，应用出现故障时错误日志一般较少，运维人员根据错误日志迅速定位到问题。但随着业务逻辑的迭代，系统接入的依赖服务不断增多、引入的组件不断增多，当系统出现故障时，<code>错误日志的量级急剧增加</code>。极端情况下更甚出现 “疯狂报错” 的现象，这时错误日志的内容会存在 <code>相互掩埋</code>、<code>相互影响</code> 的问题，运维人员面对报错一时难以理清逻辑， 失去焦点，没能第一时间解决最核心问题。</li><li>若在报警流出现时，通过处理程序将报警进行聚类，整理出一段时间内的报警摘要。运维人员就可以在摘要信息的帮助下，先对当前的故障有一个大致的轮廓，再结合技术知识与业务知识定位故障的根本原因。</li><li>围绕上面描述的问题，以及对于报警聚类处理的分析假设，本文主要做了以下事情：  <ul><li><code>选定算法</code>：选定聚类算法，简单描述算法基本原理，并给出针对报警日志聚类的一种具体实现方案。  </li><li><code>验证算法</code>：在分布式业务服务的系统下构造了三种不同实验场景，验证了算法的效果，并且对算法的不足进行分析阐述。</li></ul></li></ul><a id="more"></a><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>我们希望这些泛化报警既要具有很强的概括性，同时尽可能地保留细节。这样运维人员在收到报警时，便能快速定位故障的大致方向，从而提高故障排查的效率。</li><li><p>对一段时间内的报警进行聚类处理，将具有相同根因的报警归纳为能够涵盖报警内容的泛化报警，最终形成仅有几条泛化报警的报警摘要，如图 1-1 所示。</p><p>  <img src="/images/illustration/Paper/2019/alarm-clustering_1-1.jpg" alt=""></p>  <center>图 1-1 通过聚类算法泛化报警日志</center></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>如图 1-2 所示，文章主要分三个部分阐述：提取报警特征、算法实现以及展示报警摘要。</li><li><p>首先，是根据根因分析提取报警关键特征，并生成报警信息的泛化层次结构。其次，则是从泛化层次结构中计算得不同报警对象之间的不相似度度量，以确定最具象化的泛化表示、最大程度涵盖原始报警集合的泛化层次结构。最后，经由聚类算法获得泛化报警簇群，以簇群代表某一类报警信息。</p><blockquote><p>聚类算法还涉及 <code>min_size</code> 与 <code>聚类停止条件</code> 的调参问题，详情见下文描述。</p></blockquote><p>  <img src="/images/illustration/Paper/2019/alarm-clustering_1-2.png" alt=""></p>  <center>图 1-2 文章的章节布局</center></li></ul><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="泛化初探"><a href="#泛化初探" class="headerlink" title="泛化初探"></a>泛化初探</h3><ul><li><p>将报警信息抽象表达、逐层分解，形成类似于 <code>树结构</code> 或者 <code>有向无环图</code> 的泛化层次结构。</p><p>  如图 1-3 所示，可将服务器的报警抽象为 “全部服务器 网络调用 故障”，也可以抽象为 “server_room_a 服务器 网络调用 产品信息获取失败” 和 “server_room_b 服务器 RPC 获取产品类型信息失败”。</p><blockquote><p>前者泛化范围较广、抽象层次较高，细节越少；后者包含的范围较小、抽象层次低，则包含的无用信息可能越多。当然不局限于一种层次关系，你也可以用其他层次的抽象来表达这个报警集群。</p></blockquote><p>  <img src="/images/illustration/Paper/2019/alarm-clustering_1-3.jpg" alt=""></p>  <center>图 1-3 服务器的报警泛化初探</center></li></ul><h3 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h3><ul><li>为了确定报警聚类泛化的程度，我们需要先了解一些定义：<ul><li><code>属性</code> ( Attribute )：构成报警日志的基本信息，如机器、环境、时间等，记作 $A_i$。</li><li><code>值域</code> ( Domain )：属性 $A_i$  的值域 ( 取值范围 )，记作 $Dom(A_i)$。</li><li><code>泛化层次结构</code> ( Generalization Hierarchy )：对于每个属性 $A_i$，都有一个对应的泛化层次结构，记作 $G_i$。</li><li><code>不相似度</code> ( Dissimilarity )：定义为 $d(\mathcal{a_1}, \mathcal{a_2})$。它接受两个报警 $\mathcal{a_1}$、$\mathcal{a_2}$ 作为输入，并返回一个数值量，表示这两个报警不相似的程度。当 $d(\mathcal{a_1}, \mathcal{a_2})$ 较小时，表示报警 $\mathcal{a_1}$ 和报警 $\mathcal{a_2}$ 越相似，相反越大则越不相似。为了计算不相似度，则需要用户预先定义好报警信息的 <code>泛化层次结构</code>。</li></ul></li><li><p>计算 $d(\mathcal{a_1}, \mathcal{a_2})$，我们先定义两个属性值的不相似度：令 $x_1$、$x_2$ 为 $\mathcal{a_1}$、$\mathcal{a_2}$ 某个属性 $A_i$ 的两个不同的值，$x_1、x_2 \in Dom(A_i)$。</p><ul><li><p>在属性 $A_i$ 的泛化层次结构 $G_i$ 中，通过一个公共点父节点 $p$ 连接 $x_1$、$x_2$ 的最短路径长度。$\delta(·,·)$ 表示两节点的最短路径长度，把它们累加起来以表示两个属性的不相似度。</p><script type="math/tex; mode=display">d(x_1, x_2) := \min \left\{ \delta(x_1, p) + \delta(x_2, p) \mid  p \in G_i, x1 \trianglelefteq p, x2 \trianglelefteq p\right\}\tag{1}</script><blockquote><p>举例：在图 1-3 的泛化层次结构中：<br>d(“Thrift”, “Pigeon”) = d(“RPC”, “Thrift”) + d(“RPC”, “Pigeon”) =  1 + 1 = 2  </p></blockquote></li><li><p>接下来把警报的所有属性都加入计算，累加报警的所有属性的不相似度，即可表示报警的不相似度。对于两个报警 $\mathcal{a_1}$、$\mathcal{a_2}$，其不相似度的计算公式为：</p><script type="math/tex; mode=display">d(\mathcal{a_1}, \mathcal{a_2}) :=   \sum_{i=1}^n d(\mathcal{a_1}[A_i], \mathcal{a_2}[A_i])\tag{2}</script><blockquote><p>举例：参考图 1-3 的泛化层次结构：<br>$\mathcal{a_1}$ = (“server_room_b-biz_tag-offline02”, “Thrift”)<br>$\mathcal{a_2}$ = (“server_room_a-biz_tag-online01”, “Pigeon”)  </p><p>$d(\mathcal{a_1}, \mathcal{a_2})$ =<br>d(“server_room_b-biz_tag-offline02”, “server_room_a-biz_tag-online01”) +<br>d(“Thrift”, “Pigeon”)  </p><p>$d(\mathcal{a_1}, \mathcal{a_2})$ =<br>d(“server_room_b-biz_tag-offline02”, “服务器”) +<br>d(“server_room_a-biz_tag-online01”, “服务器”) +<br>d(“RPC”, “Thrift”) +<br>d(“RPC”,  “Pigeon”)<br>= 2 + 2 + 1 + 1 = 6</p></blockquote></li></ul></li><li><p>对于某个报警聚类来说，我们如何获得既能够涵盖它的集合又有最具象化的泛化表示？回答问题前，我们预先完成一些定义：</p><ul><li>一个警报对象是 n 维属性空间 $dom(A_1) \times dom(A_2) … \times dom(A_n)$ 上的元组，记作 $\mathcal{X}_{i = 1}^{n} Dom(A_i)$。</li><li><p>我们用 $C$ 表示报警集合，$\mathbf{g}$ 是 $C$ 的一个泛化表示，满足 $\forall \mathcal{a} \in C, \mathcal{a} \trianglelefteq \mathcal{g}$。</p><blockquote><p>以报警集合 {“dx-trip-package-api02 Thrift get deal list error”, “dx-trip-package-api01 Thrift get deal list error”} 为例，<code>dx服务器 thrift调用 获取产品信息失败</code> 是一个泛化表示，<code>服务器 网络调用 获取产品信息失败</code> 也是一个泛化表示。</p></blockquote></li><li><p>定义 $d_i := d(\mathcal{g}, a_i), i = 1, 2$，$d_i$ 表示在警报 $a_i$ 中需要多少个属性即可让 $\mathcal{g}$ 泛化表示 $\mathcal{a_i}$。当 $d_1 + d_2$ 越小，$\mathcal{g}$ 从警报 $\mathcal{a_1}、\mathcal{a_2}$ 中获得泛化表示的步数越少，说明 $\mathcal{g}$ 对 $\mathcal{a_1}、\mathcal{a_2}$ 覆盖越充分。相反，当 $d_1 + d_2$ 越大，由于过于抽象或者未能有效捕获警报 $\mathcal{a_1}、\mathcal {a_2}$ 的详细信息，说明当前 $\mathcal{g}$ 的覆盖效果不好。</p></li><li><p>因此，明确我们的目标是计算得 <code>最小化的报警不相似度</code> 以获得 <code>最具象化的泛化表示</code>。为了解决这个问题，定义以下两个指标：</p><script type="math/tex; mode=display">\overline{d} (\mathcal{g}, \mathcal{C}) :=   1 / | \mathcal{C} |   \times \sum _{\mathcal{a} \in C} d (\mathcal{g}, \mathcal{a})\tag{3}</script><script type="math/tex; mode=display">H(C) := \min \left\{  \overline {d}(\mathcal{g} , C) \mid  \mathcal {g} \in \mathcal{X}_{i = 1}^{n} Dom(A_i),  \forall \mathcal {a} \in C : \mathcal{a} \trianglelefteq \mathcal{g}\right\} \tag{4}</script><blockquote><p>$H(C)$ 代表一个报警簇群 $C$ 的相异性度量，$\overline{d} (\mathcal{g}, \mathcal{C})$ 代表一个报警簇群的平均相异性度量。$H(C)$ 值最小时对应的 $\mathcal{g}$ 就是我们要找的最适合的泛化表示，我们称 $\mathcal{g}$ 为 $C$ 的覆盖。</p></blockquote></li></ul></li><li><p>基于以上的概念，将报警日志聚类问题定义为：</p><ul><li>定义 $L$ 为一个日志集合，$G_i(i = 1, 2, 3……n)$ 为属性 $A_i$ 的泛化层次结构，min_size $ \in \mathbb{N}$ 为一个预设的常量。</li><li><p>目标是找到一个 $L$ 的子集 $C$，簇群中元素数量满足 $|C| \geq$ min_size，且 $H(C)$ 值最小。</p><blockquote><p><code>min_size</code> 是用来控制抽象程度的，即一个簇群至少包含的元素个数。若 <code>min_size</code> 与 $L$ 集合的大小一样，那么我们只能使用终极抽象了；若 <code>min_size = 1</code>，则每个报警日志是它自己的抽象。</p></blockquote></li><li><p>找到一个聚类之后，我们可以去除这些元素，然后在 $L$ 剩下的集合里找其他的聚类。</p></li></ul></li><li><p>不幸的是，这是个 NP 完全问题 ( <a href="https://en.wikipedia.org/wiki/Clique_problem" target="_blank" rel="noopener">分团问题</a> )。因此论文 $^{[2]}$ 提出了一种启发式算法，该算法满足 $|C| \geq$ min_size，使 $H(C)$ 值尽量小 ( 并不一定要最小化的 $H(C)$  )。</p></li></ul><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li><p>启发式 Alarm-Clustering 算法：面向属性归纳的改进算法 (Attribute-oriented induction, AOI) $^{[3]}$。</p><blockquote><p><code>面向属性归纳的改进算法</code>：1) 对比经典的 AOI 算法更保守地概括属性；2) 使用了类似基于密度聚类的聚类终止条件。  </p></blockquote><ul><li><code>Step.01</code>: 算法假设所有的泛化层次结构 $G_i$ 都是树，这样每个报警集群都有一个唯一的、最顶层的泛化结果。</li><li><code>Step.02</code>: 将 $L$ 定义为一个原始的报警日志集合，算法选择一个属性 $A_i$，将 $L$ 中所有报警的 $A_i$ 值替换为 $G_i$ 中 $A_i$ 的父值，通过这一操作不断对报警进行泛化。</li><li><code>Step.03</code>: 持续步骤 2 的操作，直到找到至少可以将原始报警泛化为报警簇群的最小值 min_size。</li><li><code>Step.04</code>: 输出步骤 3 中找到的报警。</li></ul></li><li><p>算法的伪代码描述： </p><ul><li><code>Input</code>：(报警日志集合 $L$，min_size，每个属性的泛化层次结构 $G_1、…、G_n$)</li><li><p><code>Output</code>：(泛化报警日志集合 $L$，min_size，每个属性的泛化层次结构 $G_1、…、G_n$)</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* 将报警日志集合 L 保存至表 <span class="literal">T</span>，且表中每一列代表报警的一项属性 Ai */</span><br><span class="line"><span class="literal">T</span> := L</span><br><span class="line"></span><br><span class="line">/* count 是统计当前报警记录数量的变量 (可理解为报警簇群的大小)</span><br><span class="line"> * count 初始化为 <span class="number">1</span> 可理解为当前报警为一个仅且包含它本身的簇群 */</span><br><span class="line"><span class="keyword">for</span> all alarms a <span class="keyword">in</span> <span class="literal">T</span> do a[count] = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">/* 开始对报警进行泛化操作 */</span><br><span class="line"><span class="keyword">while</span> ∀a∈<span class="literal">T</span>:a[count] &lt; min_size do &#123;</span><br><span class="line"></span><br><span class="line">// Step.1 使用启发算法选择一个属性 Ai</span><br><span class="line"></span><br><span class="line">// Step.2 对 L 中所有报警进行泛化：</span><br><span class="line">// 即把报警的属性 Ai 替换为泛化层次结构 Gi 中 Ai 的父值</span><br><span class="line"><span class="keyword">for</span> all alarms a <span class="keyword">in</span> <span class="literal">T</span> do &#123;</span><br><span class="line">a[Ai] := parent of a[Ai] <span class="keyword">in</span> Gi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Step.3 如果 a[Ai] == a’[Ai], i = <span class="number">1</span>, <span class="number">2</span>, <span class="keyword">...</span>, n</span><br><span class="line">// 即报警的所有属性 Ai 都相同</span><br><span class="line"><span class="keyword">while</span> identical alarms a, a<span class="string">' exist do &#123;</span></span><br><span class="line"><span class="string">// 合并相同警报于同一个泛化报警 a 中并更新泛化警报的计数</span></span><br><span class="line"><span class="string">Set a[count] := a[count] + a'</span>[count];</span><br><span class="line">// 完成统计后移除报警记录 a<span class="string">'</span></span><br><span class="line"><span class="string">Delete a'</span> from <span class="literal">T</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="启发式选择属性泛化报警"><a href="#启发式选择属性泛化报警" class="headerlink" title="启发式选择属性泛化报警"></a>启发式选择属性泛化报警</h4><blockquote><p>其中第 11 行的启发算法为:</p></blockquote><ul><li><p>统计在 $A_i$ 属性上值为 $v$ 的报警的数量，记作 $f_i(v)$：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fi(v) := <span class="keyword">SELECT</span> <span class="keyword">sum</span>(<span class="keyword">count</span>) <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> Ai = v</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>让 $F_i$ 记作每个属性 $A_i$ 的最大值函数 ：</p><script type="math/tex; mode=display">  F_i := \max \left\{      f_i(v) | v \in Dom(A_i)  \right\} \tag{5}</script></li><li><p>这里的逻辑是：</p><ul><li>若有一个报警 $\mathcal{a}$ 满足 $\mathcal{a}[count] \geq$ min_size，那么对于所有属性 $A_i$ 均能满足 $F_i \geq f_i(\mathcal{a}[A_i]) \geq$ min_size。</li><li><p>相反，如果有一个属性 $A_i$ 的 $F_i &lt;$ min_size，那么 $\mathcal{a}[count]$ 就不可能大于 min_size。所以选择 $F_i$ 值最小的属性 $A_i$ 进行泛化。</p><blockquote><p>类似于木桶定律，装水量由最短的木板决定。</p></blockquote></li></ul></li></ul><h4 id="DAG-形式的泛化层次结构"><a href="#DAG-形式的泛化层次结构" class="headerlink" title="DAG 形式的泛化层次结构"></a>DAG 形式的泛化层次结构</h4><ul><li><p>当泛化层次结构是一个有向无环图 (Directed Acyclic Graph, DAG)，而不是一颗树时，结构上的任何一个节点都有可能包含多个父节点，那么一个属性值存在多个父节点将其泛化。</p><p>  针对此问题，基于经典的 AOI 提出两种解决策略：</p></li><li><p><code>选择其一法</code>：基于用户定义的规则解决歧义问题。例如，考虑运行在同一 IP 下的 HTTP 服务器和 FTP 服务器，我们通过附加端口值进行准确泛化。</p>  <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a[Destination-port] = <span class="number">80</span></span><br><span class="line">then generalize ip to HTTP-server </span><br><span class="line"><span class="keyword">else</span> generalize ip to FTP-server;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>探索所有法</code>：并行地探索所有可能的泛化结果 (穷举法)。改写上述代码 16 行即可实现：</p>  <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Step.2 对 L 中所有报警进行泛化</span><br><span class="line"><span class="keyword">for</span> all alarms a <span class="keyword">in</span> <span class="literal">T</span> do &#123;</span><br><span class="line"><span class="literal">T</span> := <span class="literal">T</span> \ &#123;a&#125;;</span><br><span class="line">// 由属性 Ai 泛化报警的所有可能性都加入 <span class="literal">T</span> 中</span><br><span class="line"><span class="keyword">for</span> all parents p that a[Ai] has <span class="keyword">in</span> Gi do &#123;</span><br><span class="line">a<span class="string">' := a; </span></span><br><span class="line"><span class="string">a'</span>[Ai] := p; </span><br><span class="line"><span class="literal">T</span> := <span class="literal">T</span> ∪ &#123;a<span class="string">'&#125;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="MINSIZE-参数自适应算法"><a href="#MINSIZE-参数自适应算法" class="headerlink" title="MINSIZE 参数自适应算法"></a>MINSIZE 参数自适应算法</h4><ul><li>此外，关于 min_size 的选择问题，如果选择了一个过大的 min_size，那么会迫使算法合并具有不同根源的报警。另一方面，如果过小，那么聚类可能会提前结束，具有相同根源的报警可能会出现在不同的聚类中。</li><li>因此，设置一个初始值，可以记作 $ms_0$。定义一个较小的值 $\varepsilon (0 &lt; \varepsilon &lt; 1)$，当 min_size 取值为 $ms_0$、$ms_0 \times (1 - \varepsilon )$、$ms_0 \times (1 + \varepsilon )$ 时的聚类结果相同时，我们就说此时聚类是 $ \varepsilon$-鲁棒的。</li><li><p>如果不相同，则使 $ms_1 = ms_0 * (1 - \varepsilon)$，重复这个测试，直到找到一个鲁棒的最小值。</p><blockquote><p>需要注意的是，$ \varepsilon$-鲁棒性与特定的报警日志相关。因此，给定的最小值，可能相对于一个报警日志来说是鲁棒的，而对于另一个报警日志来说是不鲁棒的。</p></blockquote></li></ul><h2 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h2><h3 id="提取报警特征"><a href="#提取报警特征" class="headerlink" title="提取报警特征"></a>提取报警特征</h3><ul><li>根据线上问题排查的经验，运维人员通常关注的指标包括时间、机器 ( 机房、环境 )、异常来源、报警日志文本提示、故障所在位置 ( 代码行数、接口、类 )、Case 相关的特殊 ID ( 订单号、产品编号、用户ID ) 等。</li><li>在本案例中，实际应用场景都是线上准实时场景，时间间隔短，因此我们不需要关注时间指标；同时，Case 相关的特殊 ID 不符合抽象描述的要求，因此也无需关注此项指标。</li><li>综上所述，我们选择的特征包括：<code>机房</code>、<code>环境</code>、<code>异常来源</code>、<code>报警日志文本摘要</code>、<code>故障所在位置</code> ( 接口、类 )。</li></ul><h3 id="提取关键特征"><a href="#提取关键特征" class="headerlink" title="提取关键特征"></a>提取关键特征</h3><blockquote><p>我们的数据来源是日志中心已经格式化过的报警日志信息，这些信息主要包含：报警日志产生的时间、服务标记、在代码中的位置、日志内容等。在定义泛化层次结构前夕，我们需要从已知的数据源中梳理出关键特征。</p></blockquote><ul><li><code>机房和环境</code>：提取这两个指标比较简单，在此不做详细赘述。</li><li><code>异常来源</code>：获得故障所在位置后，优先使用此信息确定异常报警的来源；若不能获取，则在日志内容中根据关键字匹配。需要说明的是，两者都需要预先定义词典支持。</li><li><code>报警日志文本摘要</code>：优先查找日志内容中是否有异常堆栈，若存在，则查找最后一个异常 ( 通常为真正的故障原因 )；若不能获取，则在日志中查找是否存在 “code=……, message=……” 这样形式的错误提示；若不能获取，则取日志内容的第一行内容 ( 以换行符为界 )，并去除其中可能存在的 Case 相关的提示信息。</li><li><code>故障所在位置</code>：优先查找是否有异常堆栈，如存在则查找第一个本地代码的位置； 若不存在，则取日志打印位置。</li></ul><h3 id="泛化层次结构"><a href="#泛化层次结构" class="headerlink" title="泛化层次结构"></a>泛化层次结构</h3><ul><li>泛化层次结构，用于记录属性的泛化关系，是泛化时向上抽象的依据，需要预先定义。</li><li><p>根据实验所用项目的实际使用环境，根据 <code>关键特性</code> 定义的 <code>泛化层次结构</code> 如下：</p><p>  <img src="/images/illustration/Paper/2019/alarm-clustering_1-4.png" alt=""></p>  <center>图 1-4 机房泛化层次结构</center><p>  <img src="/images/illustration/Paper/2019/alarm-clustering_1-5.png" alt=""></p>  <center>图 1-5 环境泛化层次结构</center><p>  <img src="/images/illustration/Paper/2019/alarm-clustering_1-6.png" alt=""></p>  <center>图 1-6 异常来源的泛化层次结构</center><p>  <img src="/images/illustration/Paper/2019/alarm-clustering_1-7.png" alt=""></p>  <center>图 1-7 报警日志文本摘要的泛化层次结构</center></li><li><p><code>故障所在位置</code> 此属性无需泛化层次结构，每次泛化时直接按照包路径向上层截断，直到系统包名。</p></li></ul><h3 id="报警聚类算法"><a href="#报警聚类算法" class="headerlink" title="报警聚类算法"></a>报警聚类算法</h3><ul><li><p>算法的执行流程，我们以图 1-8 来表述：</p><p>  <img src="/images/illustration/Paper/2019/alarm-clustering_1-8.png" alt=""></p>  <center>图 1-8 报警日志聚类流程图</center></li><li><p><code>min_size</code> 参数设定：考虑到日志数据中可能包含种类极多，且根据小规模数据实验表明，min_size $= \frac15 \times$ 报警日志数量时，算法已经有较好的表现，再高会增加过度聚合的风险，因此我们取 min_size $= \frac15 \times$ 报警日志数量，$\varepsilon$ 参考论文中的实验取 0.05。</p></li><li><p><code>聚类停止条件</code>：考虑到部分场景下，报警日志可能较少，因此 min_size 的值也较少，此时聚类已无太大意义，因此设定聚类停止条件为：聚类结果的报警摘要数量小于等于 20 或已经存在某个类别的 count 值达到 min_size 的阈值，即停止聚类。</p></li></ul><h2 id="延伸探究"><a href="#延伸探究" class="headerlink" title="延伸探究"></a>延伸探究</h2><ul><li><p>在论文中，警报 $\mathcal{a_x}$、$\mathcal{a_y}$ 的不相似度量定义为 $d(\mathcal{a_x}, \mathcal{a_y}) := \sum_{i=1}^n d(\mathcal{a_x}[A_i], \mathcal{a_y}[A_i])$，$d(·,·)$ 即把警报 a 中每个属性的不相似度量累加起来。</p><blockquote><p>在现实条件下，警报对象包含的属性值理应是有主次、重要性之分。我们计算警报的不相似度，具体计算不同的属性的不相似度时，是否考虑加入权重计算系统。</p></blockquote></li><li><p>关于泛化层次结构的表现形式包括 <code>有向无环图</code> 和 <code>树</code>。针对有向无环图形式的泛化层次结构，一个结构节点可能存在多个父节点，即一个属性值存在多个父节点将其泛化，故论文基于经典的 AOI 提出两种解决策略，以准确地选择唯一父节点去泛化报警。</p><p>  首先，是结合领域知识的 <code>选择其一法</code>，满足基本要求但需要人为因素干预。而现在问题是，若采取 <code>探索所有法</code> 将所有的泛化报警都加入集合 T 中，然而存在重复加入泛化报警的可能性，那么由原始方法构建簇群将是不正确的 (上述伪代码 23 行)。</p><blockquote><p>原论文描述解决办法：重新扫描原始警报日志，并确定与之匹配的原始警报的数量？细节和意图不明确，是否有替代方案？</p></blockquote></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://tech.meituan.com/2019/02/28/root-clause-analysis.html" target="_blank" rel="noopener">美团技术团队. 根因分析初探：一种报警聚类算法在业务系统的落地实施. 2019. tech.meituan.com</a></li><li>[2] Julisch K . Clustering intrusion detection alarms to support root cause analysis[J]. ACM Transactions on Information and System Security, 2003, 6(4):443-471.</li><li>[3] Jiawei Han 等著; 范明等译. 数据挖掘:概念与技术 (原书第3版) [M]. 机械工业出版社., 2012. 111-116.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;原文：Clustering intrusion detection alarms to support root cause analysis&lt;br&gt;作者：Klaus Julisch&lt;br&gt;来源：ACM Transactions on Information and System Security, 2003, 6(4):443-471.&lt;/p&gt;&lt;/div&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;系统出现故障时，运维人员一般先查看错误日志定位故障原因。&lt;/li&gt;
&lt;li&gt;业务流量小、逻辑复杂度低时，应用出现故障时错误日志一般较少，运维人员根据错误日志迅速定位到问题。但随着业务逻辑的迭代，系统接入的依赖服务不断增多、引入的组件不断增多，当系统出现故障时，&lt;code&gt;错误日志的量级急剧增加&lt;/code&gt;。极端情况下更甚出现 “疯狂报错” 的现象，这时错误日志的内容会存在 &lt;code&gt;相互掩埋&lt;/code&gt;、&lt;code&gt;相互影响&lt;/code&gt; 的问题，运维人员面对报错一时难以理清逻辑， 失去焦点，没能第一时间解决最核心问题。&lt;/li&gt;
&lt;li&gt;若在报警流出现时，通过处理程序将报警进行聚类，整理出一段时间内的报警摘要。运维人员就可以在摘要信息的帮助下，先对当前的故障有一个大致的轮廓，再结合技术知识与业务知识定位故障的根本原因。&lt;/li&gt;
&lt;li&gt;围绕上面描述的问题，以及对于报警聚类处理的分析假设，本文主要做了以下事情：  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;选定算法&lt;/code&gt;：选定聚类算法，简单描述算法基本原理，并给出针对报警日志聚类的一种具体实现方案。  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;验证算法&lt;/code&gt;：在分布式业务服务的系统下构造了三种不同实验场景，验证了算法的效果，并且对算法的不足进行分析阐述。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Paper" scheme="http://www.kofes.cn/categories/Paper/"/>
    
    
      <category term="数据挖掘" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="聚类" scheme="http://www.kofes.cn/tags/%E8%81%9A%E7%B1%BB/"/>
    
      <category term="根因分析" scheme="http://www.kofes.cn/tags/%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>框架 | Django 框架入门到应用</title>
    <link href="http://www.kofes.cn/2019/02/Django.html"/>
    <id>http://www.kofes.cn/2019/02/Django.html</id>
    <published>2019-02-17T14:44:07.000Z</published>
    <updated>2019-02-21T13:29:36.026Z</updated>
    
    <content type="html"><![CDATA[<p>Django 是基于 MVC 模式，由 Python 写成的开源 Web 应用框架。在 Django 中，控制器接受用户输入的部分由框架自行处理，而 Django 里更关注的是模型 ( Model )、模板 ( Template ) 和视图 ( Views )，为此也称其为 MTV 模式的 Web 框架。</p><p>当然，基于 Python 的 Web 框架不仅这一家，如  flask、tornado、web2py 等。而任何一款框架的产生都有自身的亮点和缺陷 $^{[2, 3]}$，综合自我诉求、性能要求等诸多因素考量，选择适合的框架即可。在本次开发中，我们只需要一款数据库驱动的内容发布与管理系统，而 Django 的中间件 <a href="https://baike.baidu.com/item/对象关系映射" target="_blank" rel="noopener">ORM</a> 设计，使得我们在具体操作业务对象时，不需要和复杂的 SQL 语句打交道，只要像平时操作对象一样操作即可。为此，本着轻量开发的原则选择了 Django。</p><a id="more"></a><h2 id="教学资源"><a href="#教学资源" class="headerlink" title="教学资源"></a>教学资源</h2><ul><li>📺 | 视频 | <a href="https://www.bilibili.com/video/av22606568/?p=3" target="_blank" rel="noopener">老男孩.Python 全栈: Django 框架入门到应用. 2018. bilibili.com</a></li><li>📄 | 文章 | <a href="https://docs.djangoproject.com/zh-hans/2.1/" target="_blank" rel="noopener">Django.Django 快速入门&amp;中文使用文档. djangoproject.com</a></li></ul><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><ul><li><p>安装：命令行模式安装 ( Mac / Linux 用户注意管理员权限 )</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install django</span><br><span class="line">pip install django == x.xx.xx</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>配置：配置 Django 项目并初次启动它。</p><ul><li><p>创建项目：可通过命令模式启动项目 ( 多用于部署环境 )，也可通过 PyCharm 启动、运行项目。</p><ul><li>命令模式：<code>django-admin startproject mysite</code></li><li><p>PyCharm：通过 PyCharm 一步到位，即 <code>新建工程 &gt; Django &gt; ( 建立单独的 Venv ) &gt; mysite</code>。</p><blockquote><p>Virtualenv：为一个应用创建一套“隔离”的 Python 运行环境，具体配置方法可参考 [1]。</p></blockquote></li></ul></li><li><p>项目目录结构说明</p><ul><li><code>mysite</code>：同名目录，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名，比如 mysite.urls。</li><li><code>__init__.py</code>：空文件，标识这个目录应识别为 Python 包。</li><li><code>settings.py</code>：Django 的项目配置文件。</li><li><code>urls.py</code>：Django 项目的 URL 声明。</li><li><code>wsgi.py</code>：Web 服务网关接口 ( Socket )。</li><li><p><code>manage.py</code>：对网络所有管理是通过其来实现的。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysite</span><br><span class="line">  ├─── mysite</span><br><span class="line">  │ ├── init__.py</span><br><span class="line">  │ ├── settings.py</span><br><span class="line">  │ ├── urls.py</span><br><span class="line">  │ ├── wsgi.gy</span><br><span class="line">  └─── manage.py</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>使用：以命令模式启动本地服务器为例，当然可以使用 Pycharm 一键运行。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver 127.0.0.1:8000</span><br></pre></td></tr></table></figure></li></ul><h3 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h3><h4 id="返回内容至页面"><a href="#返回内容至页面" class="headerlink" title="返回内容至页面"></a>返回内容至页面</h4><p>返回内容 ( Html 元素或对象 ) 至页面，代码应包含在 <code>urls.py</code> 文件中。</p><ul><li><p>下述是返回字符串或 Html 元素的示例代码：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">arguments:</span></span><br><span class="line"><span class="string">@param request 放置用户请求相关的所有信息</span></span><br><span class="line"><span class="string">@return 响应与返回处理结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="comment"># 1. 可返回字符串</span></span><br><span class="line"><span class="keyword">return</span> HttpResponse(<span class="string">"Hello World!"</span>)</span><br><span class="line"><span class="comment"># 2. 可返回 Html 元素 (对象)</span></span><br><span class="line"><span class="comment"># return HttpResponse("&lt;input type='text' /&gt;")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 Site 根目录</span></span><br><span class="line">urlpatterns = [ url(<span class="string">''</span>, info), ]</span><br></pre></td></tr></table></figure></li></ul><h4 id="返回独立-Html-页面"><a href="#返回独立-Html-页面" class="headerlink" title="返回独立 Html 页面"></a>返回独立 Html 页面</h4><p>返回独立 Html 页面，且尝试把数据返回到页面中。</p><ul><li>Html 页面放置 <code>tempates</code> 目录下；</li><li><p><code>settings.py</code> 中配置模板的路径 ( 告诉程序网页模板在哪个目录下 )；</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line"><span class="string">'DIRS'</span>: [os.path.join(BASE_DIR, <span class="string">'templates'</span>)]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>urs.py</code> 中加入调用代码，绑定请求地址与处理函数；</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># render 能抓取页面全部信息 ( 它也调用了 HttpResponse )</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'info.html'</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>若要引用资源目录，如存放 images、css 等，则需要在 <code>settings.py</code> 中加入声明语句。</p><p>  引用资源时，需要加入 <code>static</code>。例如 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;static/style.css&quot;&gt;</code>。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STATIC_URL = <span class="string">'/static/'</span></span><br><span class="line">STATICFILES_DIRS = (</span><br><span class="line">    <span class="comment"># '文件名' 是自由命名的，这里取 'static' 是为了统一命名</span></span><br><span class="line">    os.path.join(BASE_DIR, <span class="string">'static'</span>), </span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h3 id="简单登录功能"><a href="#简单登录功能" class="headerlink" title="简单登录功能"></a>简单登录功能</h3><blockquote><p>本实例主要展示的是，在 Django 框架下 Web 前后端的交互过程。</p></blockquote><ul><li><p>首先，我们在 <code>urls.py</code> 中配置路由关系，并绑定路由触发的函数以实现功能。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse, render, redirect</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首次加载页面调用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="comment"># GET 可通过请求的链接地址传参，如 url?page=1</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'GET'</span> == request.method):</span><br><span class="line"><span class="comment">## render() 是抓取页面全部信息 ( 它也调用了 HttpResponse )</span></span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">'login.html'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录成功后把数据回传到目标页面</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">user = request.POST</span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">'index.html'</span>, &#123;</span><br><span class="line"><span class="string">'username'</span>: str(user.get(<span class="string">'username'</span>)),</span><br><span class="line"><span class="string">'password'</span>: &#123;</span><br><span class="line"><span class="string">'origin'</span>: user.get(<span class="string">'password'</span>),</span><br><span class="line"><span class="string">'encode'</span>: base64.b64encode( (user.get(<span class="string">'password'</span>) + user.get(<span class="string">'password'</span>)).encode(<span class="string">'utf-8'</span>) )</span><br><span class="line">&#125;&#125;</span><br><span class="line">)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># path(相对地址, 调用函数)，如请求地址为根目录，故这里填写 '' </span></span><br><span class="line">urlpatterns = [ </span><br><span class="line">    path(<span class="string">''</span>, login), </span><br><span class="line">    path(<span class="string">'index'</span>, index), </span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>最后附上相关联的 <code>login.html</code> 和 <code>index.html</code>。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- login.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Information Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"static/css/style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Welcome to use the exhibation page.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">"login"</span> <span class="attr">type</span>=<span class="string">"submit"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Home Index<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"static/css/style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1. 模板中接受函数体返回的属性 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &#123;&#123;&#125;&#125; 特殊占位符: Django render() 会自动解析它 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>username<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> &#123;&#123; username &#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>password<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> &#123;&#123; password.origin &#125;&#125; =&gt; &#123;&#123; password.encode &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="comment">&lt;!-- 换行 --&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2. 模板中调用对象的方法和属性，例如循环体 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">&#123;% for key, value in password.items %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Password:&#123;&#123; key &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="增删改查系统"><a href="#增删改查系统" class="headerlink" title="增删改查系统"></a>增删改查系统</h3><blockquote><p>本实例主要展示的是 Python 与数据库的交互过程。</p></blockquote><h4 id="建立数据表"><a href="#建立数据表" class="headerlink" title="建立数据表"></a>建立数据表</h4><p>数据关系：这里以学生 ( Student )、任教老师 ( Teacher ) 和课程 ( Course ) 三个实体为例，构建数据表。</p><ul><li>ER 图，如图 4-1 所示：<ul><li>学生可以选修多门课程，一门课程可以多个学生参与，即多对多关系。</li><li>老师只能任教一门课程，但是一门课程有多个老师开课，即一对多关系。</li></ul></li></ul><p><img src="/images/illustration/Programme/2019/02/django_1-1.jpg" alt="django_1-1"></p><center>图 1-1 演示数据库的数据关系</center><ul><li>关系模式：<ul><li>学生实体(学生序号, 学生姓名) == t_student(_sid_, name)</li><li>课程实体(课程序号, 课堂名称) == t_course(_cid_, name)</li><li>老师实体(老师序号, 老师姓名) == t_teacher(_tid_, name, cid)</li><li>选课关系(学生序号, 课程序号, 成绩) == Student2Course(_sid_, _cid_, score)</li></ul></li></ul><h4 id="前-后端交互原理"><a href="#前-后端交互原理" class="headerlink" title="前 / 后端交互原理"></a>前 / 后端交互原理</h4><ul><li>Web 程序的前后端交互原理如图 4-2 所示。</li></ul><p><img src="/images/illustration/Programme/2019/02/django_1-2.jpg" alt="django_1-2"></p><center>图 1-2 Web 程序的前后端交互原理</center><h4 id="原生代码操作数据"><a href="#原生代码操作数据" class="headerlink" title="原生代码操作数据"></a>原生代码操作数据</h4><ul><li>Python 的 MySQL 驱动有 <code>MySQLdb</code>、<code>PyMySQL</code> 以及 <code>MySQLClient</code>。</li><li><p>在 Python 2.7 版本，主要是用 MySQLdb，而 Python 3.x 版本多数使用 PyMySQL 以及 MySQLClient。两者操作风格类似，本文则以 PyMySQL 展开探讨。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 封装连接数据库的信息</span></span><br><span class="line">db_infos = &#123;</span><br><span class="line"><span class="string">'host'</span>: <span class="string">"IP 地址"</span>,</span><br><span class="line"><span class="string">'port'</span>: <span class="number">3306</span>,</span><br><span class="line"><span class="string">'user'</span>: <span class="string">"数据库账户"</span>,</span><br><span class="line"><span class="string">'password'</span>: <span class="string">"数据库密码"</span>,</span><br><span class="line"><span class="string">'db'</span>: <span class="string">"数据库名称"</span>,</span><br><span class="line"><span class="string">'charset'</span>: <span class="string">"utf8"</span>,</span><br><span class="line"><span class="string">'cursorclass'</span>: pymysql.cursors.DictCursor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">db = pymysql.connect(db_infos)</span><br><span class="line"></span><br><span class="line">SQL = <span class="string">"SELECT * FROM t_student"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">with</span> db.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">cursor.excute(SQL) <span class="comment"># 执行 SQL 语句</span></span><br><span class="line">db.commit() <span class="comment"># 提交修改数据请求</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">db.rollback() <span class="comment"># 回滚</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">db.close() <span class="comment"># 关闭数据库连接</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Ajax-方式交互数据"><a href="#Ajax-方式交互数据" class="headerlink" title="Ajax 方式交互数据"></a>Ajax 方式交互数据</h4><ul><li><p>借助 Ajax，实现数据的本地刷新，而不需要重新加载、渲染网页。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'提交地址'</span>,</span><br><span class="line">    type: <span class="string">'POST'</span> <span class="comment">// POST / GET</span></span><br><span class="line">    data: &#123;<span class="string">'key_1'</span>: <span class="string">'value_1'</span>, ..., <span class="string">'key_n'</span>: <span class="string">'value_n'</span> &#125;</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 当前服务端处理数据，自动执行回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="框架正文"><a href="#框架正文" class="headerlink" title="框架正文"></a>框架正文</h2><p>本章节的内容参考 <a href="https://docs.djangoproject.com/zh-hans/2.1/" target="_blank" rel="noopener">Django 官方文档 v2.1</a> 整理所得，即把模型、模板和视图的概念更加细化，通过一个投票应用的实例以讲述如何搭建一个 <code>MTV模式</code> 的 Web 框架，如图 3-1 所示。</p><p><img src="/images/illustration/Programme/2019/02/django_2-1.jpg" alt="django_2-1"></p><center>图 2-1 MTV 模式的 Web 框架</center><h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><ul><li><p>编辑 <code>mysite/settings.py</code> 文件前，先设置 <a href="https://docs.djangoproject.com/zh-hans/2.1/ref/settings/#std:setting-TIME_ZONE" target="_blank" rel="noopener">TIME_ZONE</a> 为你自己时区，可参考 Wikipedia 的 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="noopener">List of time zones</a>。</p><blockquote><p>新建立的项目，默认时区为 <code>UTC</code>。</p></blockquote></li><li><p>打开 <code>mysite/settings.py</code>，通常这个配置文件使用 SQLite 作为默认数据库。</p><ul><li><code>ENGINE</code>：选值 <code>django.db.backends.sqlite3</code>。</li><li><p><code>NAME</code>：数据库的名称。若使用 <a href="https://baike.baidu.com/item/SQLite/375020?fr=aladdin" target="_blank" rel="noopener">SQLite</a>，数据库将是你电脑上的一个文件，NAME 应该是此文件的绝对路径 + 文件名，默认值 <code>os.path.join(BASE_DIR, &#39;db.sqlite3&#39;)</code> 将会把数据库文件储存在项目的根目录。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.sqlite3'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: os.path.join(BASE_DIR, <span class="string">'db.sqlite3'</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若使用了 SQLite 以外的数据库，请确认在使用前已经 <code>创建了数据库</code>。连接到其他数据库时 ( MySQL，Oracle 或 PostgreSQL )，参考 <a href="https://docs.djangoproject.com/zh-hans/2.1/ref/settings/#std:setting-DATABASE-ENGINE" target="_blank" rel="noopener">ENGINE</a> 的设置来连接其他数据库。例如连接 MySQL 的配置如下所示：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'mydatabase'</span>,</span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'mydatabaseuser'</span>,</span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'mypassword'</span>,</span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        <span class="string">'PORT'</span>: <span class="string">'3306'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>此外，关注一下文件头部的 <code>INSTALLED_APPS</code> 设置项。这里包括了项目中启用的所有 Django 应用。应用能在多个项目中使用，也可以打包并且发布应用，让别人使用它们。通常 INSTALLED_APPS 默认包括了以下 Django 的自带应用：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="comment"># 因为 ApplicationConfig 类写在文件 polls/apps.py 中，</span></span><br><span class="line">    <span class="comment"># 所以它的点式路径是 'polls.apps.ApplicationConfig'</span></span><br><span class="line">    <span class="string">'polls.apps.ApplicationConfig'</span>,<span class="comment"># 激活模型</span></span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,<span class="comment"># 管理员站点</span></span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,<span class="comment"># 认证授权系统</span></span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,<span class="comment"># 内容类型框架</span></span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,<span class="comment"># 会话框架</span></span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,<span class="comment"># 消息框架</span></span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,<span class="comment"># 管理静态文件的框架</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>默认开启的某些应用需要至少一个数据表，故在使用他们前需要在数据库中创建一些表。请执行命令：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> MacOS / Linux</span></span><br><span class="line">python manage.py migrate</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Windows ( 下述代码同理，基本上 <span class="string">"py"</span> 对应于 <span class="string">"python"</span> )</span></span><br><span class="line">py manage.py migrate</span><br></pre></td></tr></table></figure></li></ul><h3 id="模型和站点管理"><a href="#模型和站点管理" class="headerlink" title="模型和站点管理"></a>模型和站点管理</h3><h4 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h4><ul><li><p>定义模型 ( Model )，即数据库结构设计和附加的其它元数据。在 Django 中，你只需要定义数据模型，其中的实现代码不用理会，它们会自动从模型生成。</p><blockquote><p>模型是真实数据的简单明确的描述，它包含了储存的数据所必要的字段和行为。</p></blockquote></li><li><p>例如，在本案例中 ( 投票应用 )，需要创建两个模型：问题 Question 和选项 Choice。</p><ul><li>Question 模型：包括问题描述和发布时间。</li><li>Choice 模型：包括选项描述和当前得票数。每个选项属于一个问题 ( 一对一关系 )。</li></ul></li><li><p>这些概念可通过 Python 类来描述。按照下面的例子来编辑 <code>polls/models.py</code> 文件：</p><ul><li>每个模型被表示为 <code>django.db.models.Model</code> 类的子类。每个模型有一些类变量，它们都表示模型里的一个数据库字段。</li><li>每个字段都是 <code>Field</code> 类的实例，这将告诉 Django 每个字段要处理的数据类型。比如，字符字段被表示为 <code>CharField</code>，日期时间字段被表示为 <code>DateTimeField</code>。</li><li><p>定义某些 Field 类实例需要参数，例如 CharField 需要一个 max_length 参数。</p><blockquote><p>这个参数的用处不止于用来定义数据库结构，也用于验证数据。</p></blockquote></li><li><p>Django 支持所有常用的数据库关系：一对一、一对多和多对多，我们使用外键 <code>ForeignKey</code> 定义了一个关系。例如，每个 Choice 对象都关联到一个 Question 对象。</p></li><li><p>数据表最重要的 <code>主键</code> 会被自动创建，当然也可以自定义。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Question</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    question_text = models.CharField(max_ length=<span class="number">200</span>)</span><br><span class="line">    pub_date = models.DateTimeField(<span class="string">'date published'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Question.objects.all() 返回信息对我们用处不大，如下所示：</span></span><br><span class="line">    <span class="comment"># &lt;QuerySet [&lt;Question: Question object (1)&gt;]&gt;</span></span><br><span class="line">    <span class="comment"># 可尝试通过 __str__() 方法返回一些字段信息</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.question_text</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Choice</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    question = models.ForeignKey(Question, on_delete=models.CASCADE)</span><br><span class="line">    choice_text = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    votes = models.IntegerField(default=<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.choice_text</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="激活模型"><a href="#激活模型" class="headerlink" title="激活模型"></a>激活模型</h4><ul><li><p>从上述用于创建模型的代码可知，Django 可实现：</p><ul><li>为这个应用创建数据库 <code>schema</code> ( 生成 CREATE TABLE 语句 )。</li><li>创建与 Question 和 Choice 对象与数据库进行交互的 <code>API</code> ( Python 版本 )。</li></ul></li><li><p>但是首先得把 polls 应用安装到我们的项目里。具体地， 在文件 <code>mysite/settings.py</code> 中 <code>INSTALLED_APPS</code> 子项添加点式路径：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="comment"># 因为 ApplicationConfig 类写在文件 polls/apps.py 中，</span></span><br><span class="line">    <span class="comment"># 所以它的点式路径是 'polls.apps.ApplicationConfig'</span></span><br><span class="line">    <span class="string">'polls.apps.ApplicationConfig'</span>,<span class="comment"># 激活模型</span></span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,<span class="comment"># 管理员站点</span></span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,<span class="comment"># 认证授权系统</span></span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,<span class="comment"># 内容类型框架</span></span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,<span class="comment"># 会话框架</span></span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,<span class="comment"># 消息框架</span></span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,<span class="comment"># 管理静态文件的框架</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>现在你的 Django 项目会包含 polls 应用。接着通过运行 <code>makemigrations</code> 命令，Django 会检测你对模型文件的修改 ( 在这种情况下刚创建的可理解为最新修改的  )，并且把修改的部分储存为一次 <code>迁移</code>。</p><blockquote><p>迁移：Django 对于模型定义，也就是你的数据库结构的变化的储存形式。它们其实也只是一些你磁盘上的文件。</p></blockquote>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations polls</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Django 有一个自动执行 <code>数据库迁移</code> 并同步管理你的数据库结构的命令：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>当然，你是否会好奇，迁移是怎样的过程，迁移命令会执行哪些 SQL 语句？那么，<code>sqlmigrate</code> 命令接收一个迁移的名称，然后返回对应的 SQL。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sqlmigrate 命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 并没有真正在数据库中的执行迁移，它只是把命令输出到屏幕上</span></span><br><span class="line">python manage.py sqlmigrate polls 0001</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>输入以上命令，你将看到如下结果 ( 格式化输出 SQL )：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 输出示例使用的是 PostgreSQL / MySQL --</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- Create model Choice</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">"polls_choice"</span> (</span><br><span class="line">    <span class="string">"id"</span> <span class="built_in">serial</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="string">"choice_text"</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">"votes"</span> <span class="built_in">integer</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- Create model Question</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">"polls_question"</span> (</span><br><span class="line">    <span class="string">"id"</span> <span class="built_in">serial</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="string">"question_text"</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">"pub_date"</span> <span class="keyword">timestamp</span> <span class="keyword">with</span> <span class="keyword">time</span> zone <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 省略剩余语句，具体可自行测试 --</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li><li><p>从格式化的 SQL 语句可注意到：</p><ul><li><p>数据库的表名是由应用名 ( polls ) 和模型名的小写形式 ( question 和 choice ) 连接而来。</p></li><li><p>主键 ( id ) 会被自动创建，当然你也可以自定义。</p></li><li><p>默认 Django 会在外键字段名后追加字符串 “_id” ，同样也可以自定义。</p></li><li><p>生成的 SQL 语句是为你所用的数据库定制的，所以那些和数据库有关的字段类型，比如 auto_increment ( MySQL )、 serial ( PostgreSQL ) 和 integer primary key autoincrement ( SQLite )，Django 会帮你自动处理。那些和引号相关的事情，比如使用单引号还是双引号，也一样会被自动处理。</p></li></ul></li><li><p>总结：迁移是非常强大的功能，它能让你在开发过程中持续的改变数据库结构而不需要重新删除和创建表，即它专注于使数据库平滑升级而不会丢失数据。<strong>现在改变模型只需要记住这三步</strong>：</p><ul><li><p>编辑 <code>models.py</code> 文件，改变模型。</p></li><li><p>运行 <code>python manage.py makemigrations</code> 为模型的改变 <code>生成</code> 迁移文件。</p></li><li><p>运行 <code>python manage.py migrate</code> 来 <code>应用</code> 数据库迁移。</p></li></ul></li></ul><h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><ul><li>当完成 <code>创建模型</code> ( 定义数据实体和数据关系 ) 与 <code>激活模型</code> ( 模型驱动自动生成 SQL 代码 ) 的工作，即表明数据表已建立起来，紧接着便可操作数据库了。</li><li>关于操作数据库的 Python API 所有细节可在 <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/" target="_blank" rel="noopener">Database API For Python</a> 参考文档中找到。</li></ul><h5 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h5><ul><li><p>假设模型存在于文件中 mysite/polls/models.py：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> polls.models <span class="keyword">import</span> Choice, Question</span><br><span class="line"><span class="comment"># 使用模型类的关键字参数对其实例化，再调用 save() 以将其保存到数据库中</span></span><br><span class="line">q = Question(question_text=<span class="string">"What's new?"</span>, pub_date=timezone.now())</span><br><span class="line"><span class="comment"># 创建和保存对象则使用 create() 方法</span></span><br><span class="line">q.save()</span><br></pre></td></tr></table></figure></li></ul><h5 id="更新对象"><a href="#更新对象" class="headerlink" title="更新对象"></a>更新对象</h5><ul><li><p>UPDATE 在幕后执行 SQL 语句：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存对象的更改</span></span><br><span class="line">q.question = <span class="string">"What do you think about?"</span></span><br><span class="line">q.save()</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>保存 ForeignKey 字段：更新 ForeignKey 字段的工作方式与保存普通字段的方式完全相同，只需将正确类型的对象分配给相关字段即可。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般情况 pk ( Primary Key ) 和 id 是一样的，只有 id 不是主键时才不一样</span></span><br><span class="line">choice = Choice.objects.get(pk=<span class="number">1</span>)</span><br><span class="line">question = Question.objects.get(<span class="string">'What do you think about?'</span>)</span><br><span class="line">choice.question = question</span><br><span class="line">choice.save()</span><br></pre></td></tr></table></figure></li></ul><ul><li>更新ManyToManyField 工作的方式略有不同 ：使用 add() 字段上的方法向关系添加记录。</li></ul><h5 id="检索对象"><a href="#检索对象" class="headerlink" title="检索对象"></a>检索对象</h5><ul><li><p>使用 all() 返回所有对象：例如，返回 Question 数据库中所有对象。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_question = Question.objects.all()</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>使用过滤器检索特定对象</code>：若我们仅需要选择整个对象集的子集，则需要向 QuerySet 添加过滤条件。两种最常见的改进方法：</p><ul><li><code>filter(**kwargs)</code>：返回 QuerySet 包含与给定查找参数匹配的新对象。</li><li><p><code>exclude(**kwargs)</code>：返回 QuerySet 包含与给定查找参数不匹配的新对象。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如：获取 2018 年间所有问题记录</span></span><br><span class="line">Question.objects.filter(pub_date__year=<span class="number">2017</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>链接过滤器</code>：QuerySet 检索结果本身也是 QuerySet 对象，故可使用多个过滤器。作用与 <code>多条件查询</code> 类似效果。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如：获取以“What”开头，在 2018 年 1 月 1 日至当天前的所有记录</span></span><br><span class="line">Question.objects.filter(</span><br><span class="line">headline__startswith=<span class="string">'What'</span></span><br><span class="line">).exclude(</span><br><span class="line">pub_date__gte=datetime.date.today()</span><br><span class="line">).filter(</span><br><span class="line">pub_date__gte=datetime.date(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用 get() 检索单个对象：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one_question = Question.objects.get(pk=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># Question 没有主键为 1 的对象，Django 将引发异常 Entry.DoesNotExist。</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>限制 QuerySet 返回集合的大小：使用 Python 的数组切片语法将限制 QuerySet 为一定数量的结果。这相当于 SQL 中 <code>LIMIT</code> 和 <code>OFFSET</code> 子句。</p><ul><li>注意 1：<code>Entry.objects.all()[-1]</code> 不支持负索引。</li><li><p>注意 2：<code>Entry.objects.all()[:10:2]</code> 不支持使用步进 ( Step ) 取值。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如：返回前5个对象（）：LIMIT 5</span></span><br><span class="line">Question.objects.all()[:<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 例如：返回第6到第10个对象：OFFSET 5 LIMIT 5</span></span><br><span class="line">Question.objects.all()[<span class="number">5</span>:<span class="number">10</span>]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="站点管理"><a href="#站点管理" class="headerlink" title="站点管理"></a>站点管理</h4><h5 id="开篇引言"><a href="#开篇引言" class="headerlink" title="开篇引言"></a>开篇引言</h5><ul><li>相信你也有过同样的经历，例如为你的员工或客户生成一个用户添加、修改和删除内容的管理后台，即简单的增删改查操作 ( CRUD ) ，但它却是一项缺乏创造性和乏味的工作。因此，Django 全自动地根据模型创建界面化的管理后台。</li><li>管理界面不是为了网站的访问者，而是为管理者准备的。需要客制化的后台管理界面还需自行实现。</li></ul><h5 id="创建管理员账号"><a href="#创建管理员账号" class="headerlink" title="创建管理员账号"></a>创建管理员账号</h5><ul><li><p>首先，我们得创建一个能登录管理页面的用户。请运行下面的命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br><span class="line"><span class="comment"># Username: kofe</span></span><br><span class="line"><span class="comment"># Email address: kofe@example.com</span></span><br><span class="line"><span class="comment"># Password: **********</span></span><br><span class="line"><span class="comment"># Password (again): *********</span></span><br><span class="line"><span class="comment"># Superuser created successfully.</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="启动开发服务器"><a href="#启动开发服务器" class="headerlink" title="启动开发服务器"></a>启动开发服务器</h5><ul><li><p>Django 的管理界面默认就是启用的。让我们启动开发服务器。当然，你可以通过 PyCharm 启动服务器，也可以通过命令启动：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure></li><li><p>打开浏览器即可访问：<code>http://127.0.0.1:8000/admin/</code></p></li></ul><h5 id="管理页添加应用"><a href="#管理页添加应用" class="headerlink" title="管理页添加应用"></a>管理页添加应用</h5><ul><li><p>在索引页面中，我们并没有看到应用，如本例中的投票应用 <code>polls</code>。所以我们得告诉管理页面，问题 <code>Question</code> 对象需要被管理。打开 <code>polls/admin.py</code> 文件，把它编辑成下面这样：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line">admin.site.register(Question)</span><br></pre></td></tr></table></figure></li></ul><h3 id="模板和视图"><a href="#模板和视图" class="headerlink" title="模板和视图"></a>模板和视图</h3><h4 id="开篇引言-1"><a href="#开篇引言-1" class="headerlink" title="开篇引言"></a>开篇引言</h4><ul><li><p>每个视图必须要做的只有两件事：返回一个包含被请求页面内容的 <code>HttpResponse</code> 对象或者抛出一个 <code>异常</code>，比如 HTTP 404。</p><blockquote><p>Django 只要求返回的是一个 HttpResponse ，或抛出一个异常。</p></blockquote></li><li><p>视图可以从数据库里读取记录，可使用一个模板引擎 ( Django 自带或者其他第三方的 )，生成一个 PDF 文件、输出一个 XML、创建一个 ZIP 文件等，你可以使用任何你想用的 Python 库，实现你想做的事。</p></li><li><p>Django 自带的 <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/" target="_blank" rel="noopener">Database API</a> 很方便，与试图结合使用即可实现数据的基本交互操作。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 index() 函数里插入了一些新内容</span></span><br><span class="line"><span class="comment"># 让它能展示数据库里以发布日期排序的最近5个投票问题</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">latest_question_list = Question.objects.order_by(<span class="string">'-pub_date'</span>)[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">output = <span class="string">', '</span>.join([q.question_text <span class="keyword">for</span> q <span class="keyword">in</span> latest_question_list])</span><br><span class="line"><span class="keyword">return</span> HttpResponse(output)</span><br></pre></td></tr></table></figure></li></ul><h4 id="模板系统"><a href="#模板系统" class="headerlink" title="模板系统"></a>模板系统</h4><ul><li><p>这里有个问题：页面的设计写死在视图函数的代码里的。如果你想改变页面的样子，你需要编辑 Python 代码。我们是否能将此过程相互分离，即 <code>视图负责处理、组装数据</code>；<code>模板则负责样式</code>。</p><ul><li>首先，在你的项目根目录里创建一个 <code>templates</code> 目录。Django 将会在这个目录里查找模板文件。</li><li>在 <code>templates</code> 目录里，再创建一个目录 <code>polls</code>，然后在其中新建一个文件 <code>index.html</code>。</li><li><p>换句话说，你的模板文件的路径应该是 <code>mysite/templates/polls/index.html</code>。因为 Django 会寻找到对应的 <code>app_directories</code>，所以你只需要使用 <code>polls/index.html</code> 就可引用到这一模板了。</p><blockquote><p><code>模板命名空间</code>：虽然可将模板文件直接放在 mysite/templates 目录下，但若有一个模板文件正好和另一个应用中的某个模板文件重名，则 Django 没有办法区分它们，从而选择第一个匹配的模板文件，造成不能准确匹配的状况。</p><p>帮助 Django 正确选择模板，最简单的方法是把他们放入各自的 <code>命名空间</code> 中，即把这些模板放入一个和 <code>自身应用重名</code> 的子文件夹里，如本例中的 <code>polls</code>。</p></blockquote></li></ul></li></ul><h4 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h4><ul><li><p>我们将下面的代码输入到刚刚创建的模板文件中：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mysite/templates/polls/index.html --&gt;</span></span><br><span class="line">&#123;% if latest_question_list %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% for question in latest_question_list %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/polls/&#123;&#123; question.id &#125;&#125;/"</span>&gt;</span></span><br><span class="line">&#123;&#123; question.question_text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% else %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>No polls are available.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>然后，让我们更新一下 polls/views.py 里的 index 视图来使用模板：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.template <span class="keyword">import</span> loader</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">latest_question_list = Question.objects.order_by(<span class="string">'-pub_date'</span>)[:<span class="number">5</span>]</span><br><span class="line">template = loader.get_template(<span class="string">'polls/index.html'</span>)</span><br><span class="line">context = &#123;</span><br><span class="line"><span class="string">'latest_question_list'</span>: latest_question_list,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> HttpResponse(template.render(context, request))</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>载入模板，填充上下文，再返回由它生成的 HttpResponse 对象，这里引入一个便捷函数 render() 函数。它已经把此过程封装一起，调用即可使用。</p><p>  render() 函数的第一个参数是 request 对象，第二个参数是模板名，第三个参数是字典。它返回给定上下文呈现的给定模板的 HttpResponse 对象。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">latest_question_list = Question.objects.order_by(<span class="string">'-pub_date'</span>)[:<span class="number">5</span>]</span><br><span class="line">context = &#123;<span class="string">'latest_question_list'</span>: latest_question_list&#125;</span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">'polls/index.html'</span>, context)</span><br></pre></td></tr></table></figure></li></ul><ul><li>用你的浏览器访问 <code>http://127.0.0.1:8000/polls/</code>，你将会看见一个无序列表。</li></ul><h4 id="使用模板系统"><a href="#使用模板系统" class="headerlink" title="使用模板系统"></a>使用模板系统</h4><blockquote><p>使用模板系统的过程，更像是前端与后端信息交互的过程，即前端访问请求地址获取数据的过程。</p></blockquote><ul><li>模板系统统一使用 <code>点符号</code> 来访问变量的属性。在示例 {{ question.question_text }} 中，首先 Django 尝试对 question 对象使用字典查找 ( 也就是使用 obj.get(str) 操作 )，如果失败了就尝试属性查找 ( 也就是 obj.str 操作 )，结果是成功了。如果这一操作也失败的话，将会尝试列表查找 ( 也就是 obj[int] 操作 )。</li><li>在{% for %}循环中发生的函数调用：question.choice_set.all 被解释为 Python 代码 question.choice_set.all()，将会返回一个可迭代的 Choice 对象，这一对象可以在 {% for %} 标签内部使用。</li><li>查看 <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/templates/" target="_blank" rel="noopener">模板指南</a> 可以了解关于模板的更多信息。</li></ul><h4 id="去除模板中的硬编码-URL"><a href="#去除模板中的硬编码-URL" class="headerlink" title="去除模板中的硬编码 URL"></a>去除模板中的硬编码 URL</h4><ul><li><p>硬编码：硬编码和强耦合的链接，对于一个包含很多应用的项目来说，修改起来是十分困难的。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/polls/&#123;&#123; question.id &#125;&#125;/"</span>&gt;</span></span><br><span class="line">&#123;&#123; question.question_text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>软编码：然而，因为你在 polls.urls 的 url() 函数中通过 name 参数为 URL 定义了名字，你可以使用 {% url %} 标签代替它。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> | 具有名字 'detail' 的 URL 在 polls/url.py 中定义为：</span></span><br><span class="line"><span class="comment"> | path('&lt;int:question_id&gt;/', views.detail, name='detail')</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'detail' question.id %&#125;"</span>&gt;</span></span><br><span class="line">&#123;&#123; question.question_text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> | 若你想改变投票详情视图的 URL，比如 polls/specifics/12/</span></span><br><span class="line"><span class="comment"> | 不用在模板里修改任何东西 (包括模板)，只在 polls/urls.py 稍微修改就行</span></span><br><span class="line"><span class="comment"> | path('specifics/&lt;int:question_id&gt;/', views.detail, name='detail')</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="为-URL-名称添加命名空间"><a href="#为-URL-名称添加命名空间" class="headerlink" title="为 URL 名称添加命名空间"></a>为 URL 名称添加命名空间</h4><ul><li>在一个真实的 Django 项目中，可能会有多个应用，Django 如何分辨重名的 URL 呢？具体情况则是，{% url %} 标签到底对应哪一个应用的 URL 呢？</li><li><p>在根 <code>URLconf</code> 中添加命名空间。在 polls/urls.py 文件中稍作修改，加上 <code>app_name</code> 设置命名空间：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line">app_name = <span class="string">'polls'</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">path(<span class="string">''</span>, views.index, name=<span class="string">'index'</span>),</span><br><span class="line">path(<span class="string">'&lt;int:question_id&gt;/'</span>, views.detail, name=<span class="string">'detail'</span>),</span><br><span class="line">path(<span class="string">'&lt;int:question_id&gt;/results/'</span>, views.results, name=<span class="string">'results'</span>),</span><br><span class="line">path(<span class="string">'&lt;int:question_id&gt;/vote/'</span>, views.vote, name=<span class="string">'vote'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>修改为指向具有命名空间的详细视图：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'polls:detail' question.id %&#125;"</span>&gt;</span></span><br><span class="line">&#123;&#123; question.question_text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="表单和通用视图"><a href="#表单和通用视图" class="headerlink" title="表单和通用视图"></a>表单和通用视图</h3><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><blockquote><p>在此小节中，通过表单接收数据，再通过 Django 视图来处理提交的数据。此过程，更像是前端打包数据通过 GET/POST 请求，把数据传送到后端，交由后端视图处理数据。</p></blockquote><ul><li><p>编写一个简单的表单：让我们更新一下在上一个教程中编写的投票详细页面的模板  <code>polls/detail.html</code>，让它包含一个 HTML <code>&lt;form&gt;</code> 元素：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mystie/templates/polls/detail.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;% if error_message %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123; error_message &#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"&#123;% url 'polls:vote' question.id %&#125;"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> | 跨站点请求伪造保护：</span></span><br><span class="line"><span class="comment"> | 在 Django 中，所有针对内部 URL 的 POST 表单，</span></span><br><span class="line"><span class="comment"> | 都应该使用  &#123;% csrf_token %&#125; 模板标签。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">&#123;% csrf_token %&#125;</span><br><span class="line">&#123;% for choice in question.choice_set.all %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"choice"</span> <span class="attr">id</span>=<span class="string">"choice&#123;&#123; forloop.counter &#125;&#125;"</span> <span class="attr">value</span>=<span class="string">"&#123;&#123; choice.id &#125;&#125;"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指示 for 标签已经循环多少次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"choice&#123;&#123; forloop.counter &#125;&#125;"</span>&gt;</span>&#123;&#123; choice.choice_text &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Vote"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://docs.djangoproject.com/zh-hans/2.1/ref/csrf/" target="_blank" rel="noopener">跨站点请求伪造保护</a>：当恶意网站包含链接，表单按钮或某些旨在在您的网站上执行某些操作的JavaScript时，会发生此类攻击，使用登录用户访问其浏览器中的恶意网站的凭据。一种相关类型的攻击，“登录CSRF”，攻击网站欺骗用户的浏览器以其他人的凭据登录网站也受到保护。</p></blockquote></li><li><p>我们为投票应用创建了一个 URLconf ，即新增一行 <code>path()</code>：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># polls/urls.py</span></span><br><span class="line">path(<span class="string">'&lt;int:question_id&gt;/vote/'</span>, views.vote, name=<span class="string">'vote'</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>创建一个 <code>vote()</code> 函数，来处理相关的数据请求：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># polls/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse, HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404, render</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Choice, Question</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vote</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">question = get_object_or_404(Question, pk=question_id)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">selected_choice = question.choice_set.get(pk=request.POST[<span class="string">'choice'</span>])</span><br><span class="line"><span class="keyword">except</span> (KeyError, Choice.DoesNotExist):</span><br><span class="line"><span class="comment"># Redisplay the question voting form.</span></span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">'polls/detail.html'</span>, &#123;</span><br><span class="line"><span class="string">'question'</span>: question,</span><br><span class="line"><span class="string">'error_message'</span>: <span class="string">"You didn't select a choice."</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">selected_choice.votes += <span class="number">1</span></span><br><span class="line">selected_choice.save()</span><br><span class="line"><span class="comment"># Always return an HttpResponseRedirect after successfully dealing</span></span><br><span class="line"><span class="comment"># with POST data. This prevents data from being posted twice if a</span></span><br><span class="line"><span class="comment"># user hits the Back button.</span></span><br><span class="line"><span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">'polls:results'</span>, args=(question.id,)))</span><br></pre></td></tr></table></figure><ul><li>代码返回一个 HttpResponseRedirect 而不是常用的 HttpResponse；</li><li>HttpResponseRedirect 只接收一个参数：用户将要被重定向的 URL；</li><li><p>在 HttpResponseRedirect 的构造函数中使用 reverse() 函数。这个函数避免了我们在视图函数中硬编码 URL。</p><blockquote><p>reverse() 调用将返回一个这样的字符串 <code>/polls/3/results/</code>。<br>其中 3 是 question.id 的值。重定向的 URL 将调用 ‘results’ 视图来显示最终的页面。</p></blockquote></li></ul></li><li><p>当对 Question 进行投票后，vote() 视图将请求重定向到 Question 的结果界面。让我们来编写这个视图 ( 这和上一章节中的 detail() 视图几乎一模一样，唯一的不同是模板的名字。 我们将在稍后解决这个冗余问题 )：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># polls/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404, render</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">results</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line">question = get_object_or_404(Question, pk=question_id)</span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">'polls/results.html'</span>, &#123;<span class="string">'question'</span>: question&#125;)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>再创建一个 <code>polls/results.html</code> 模板：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- polls/templates/polls/results.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% for choice in question.choice_set.all %&#125;<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;&#123; choice.choice_text &#125;&#125; -- &#123;&#123; choice.votes &#125;&#125; vote&#123;&#123; choice.votes|pluralize &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span>&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'polls:detail' question.id %&#125;"</span>&gt;</span>Vote again?<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="通用视图"><a href="#通用视图" class="headerlink" title="通用视图"></a>通用视图</h4><blockquote><p>猜想：通用视图是否是通用模板的思想，即使用统一的界面展示数据？</p></blockquote><ul><li>detail() 和 results() 视图都很简单。并且，像上面提到的那样，存在冗余问题。</li><li>这些视图反映基本的 Web 开发中的一个常见情况：根据 URL 中的参数从数据库中获取数据、载入模板文件然后返回渲染后的模板。 由于这种情况特别常见，Django 提供一种快捷方式，叫做“通用视图”系统。</li><li><p>通用视图将常见的模式抽象化，可以使你在编写应用时甚至不需要编写 Python 代码。</p><blockquote><p>一般来说，当编写一个 Django 应用时，你应该先评估一下通用视图是否可以解决你的问题，你应该在一开始使用它，而不是进行到一半时重构代码。</p></blockquote></li><li><p>让我们将我们的投票应用转换成使用通用视图系统，这样我们可以删除许多我们的代码。我们仅仅需要做以下几步来完成转换，我们将：</p><ul><li>转换 URLconf。</li><li>删除一些旧的、不再需要的视图。</li><li>基于 Django 的通用视图引入新的视图。</li></ul></li></ul><h5 id="改良-URLconf"><a href="#改良-URLconf" class="headerlink" title="改良 URLconf"></a>改良 URLconf</h5><ul><li><p>首先，打开 polls/urls.py 这个 URLconf 并将它修改成：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">app_name = <span class="string">'polls'</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">path(<span class="string">''</span>, views.IndexView.as_view(), name=<span class="string">'index'</span>),</span><br><span class="line"><span class="comment"># 路径字符串中匹配模式的名称已经由 &lt;question_id&gt; 改为 &lt;pk&gt;</span></span><br><span class="line">path(<span class="string">'&lt;int:pk&gt;/'</span>, views.DetailView.as_view(), name=<span class="string">'detail'</span>),</span><br><span class="line">path(<span class="string">'&lt;int:pk&gt;/results/'</span>, views.ResultsView.as_view(), name=<span class="string">'results'</span>),</span><br><span class="line">path(<span class="string">'&lt;int:question_id&gt;/vote/'</span>, views.vote, name=<span class="string">'vote'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h5 id="改良视图"><a href="#改良视图" class="headerlink" title="改良视图"></a>改良视图</h5><ul><li><p>下一步，我们将删除旧的 index, detail, 和 results 视图，并用 Django 的通用视图代替。打开 polls/views.py 文件，并将它修改成：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404, render</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> generic</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Choice, Question</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexView</span><span class="params">(generic.ListView)</span>:</span></span><br><span class="line">template_name = <span class="string">'polls/index.html'</span></span><br><span class="line">context_object_name = <span class="string">'latest_question_list'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">       <span class="comment"># Return the last five published questions.</span></span><br><span class="line">       <span class="keyword">return</span> Question.objects.order_by(<span class="string">'-pub_date'</span>)[:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailView</span><span class="params">(generic.DetailView)</span>:</span></span><br><span class="line">model = Question</span><br><span class="line">template_name = <span class="string">'polls/detail.html'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultsView</span><span class="params">(generic.DetailView)</span>:</span></span><br><span class="line">model = Question</span><br><span class="line">template_name = <span class="string">'polls/results.html'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vote</span><span class="params">(request, question_id)</span>:</span></span><br><span class="line"><span class="comment"># Same as above, no changes needed.</span></span><br></pre></td></tr></table></figure></li><li><p>上述代码详细解释：        </p><ul><li>默认情况下，通用视图 DetailView 使用一个叫做 <code>&lt;app name&gt;/&lt;model name&gt;_detail.html</code> 的模板。在我们的例子中，它将使用 <code>polls/question_detail.html</code> 模板。</li><li><code>template_name</code> 属性是用来告诉 Django 使用一个指定的模板名字，而不是自动生成的默认名字。 </li><li>我们也为 results 列表视图和 detail 视图指定了 template_name。即使它们在后台都是同一个 DetailView，results 视图和 detail 视图在渲染时具有不同的访问名称。</li><li>类似地，ListView 使用一个叫做 <code>&lt;app name&gt;/&lt;model name&gt;_list.html</code> 的默认模板；我们使用 template_name 来告诉 ListView 使用我们创建的已经存在的 <code>polls/index.html</code> 模板。</li><li>在之前的教程中，提供模板文件时都带有一个包含 question 和 latest_question_list 变量的 context。<ul><li>对于 DetailView ， question 变量会自动提供—— 因为我们使用 Django 的模型 (Question)， Django 能够为 context 变量决定一个合适的名字。</li><li>对于 ListView， 自动生成的 context 变量是 question_list。为了覆盖这个行为，我们提供 <code>context_object_name</code> 属性，表示我们想使用 <code>latest_question_list</code>。</li></ul></li></ul></li></ul><h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><h4 id="为什么你需要写测试"><a href="#为什么你需要写测试" class="headerlink" title="为什么你需要写测试"></a>为什么你需要写测试</h4><ul><li><code>测试将节约你的时间</code>：在复杂的应用程序中，组件之间可能会有数十个复杂的交互。改变其中某一组件的行为，也有可能会造成意想不到的结果。判断「代码是否正常工作」意味着你需要用大量的数据来完整的测试全部代码的功能，以确保你的小修改没有对应用整体造成破坏，可想而知其中的工作量。</li><li><code>测试不仅能发现错误且能预防错误</code>：测试是开发的对立面，这种思想是不对的，开发其实更像是一个不断试错的过程。</li></ul><h4 id="开始写一个测试程序"><a href="#开始写一个测试程序" class="headerlink" title="开始写一个测试程序"></a>开始写一个测试程序</h4><ul><li>约定俗称，Django 应用的测试应该写在应用的 <code>tests.py</code> 文件里，测试系统会自动的在所有以 tests 开头的文件里寻找并执行测试代码。</li><li><p>制造一个 BUG：继续上述提及的应用 Polls，要求 Question 是在一天之内发布， 则 Question.was_published_recently() 方法将会返回 True 。然而现在这个方法在 Question 的 pub_date 字段比当前时间还晚 ( 未来的时间 ) 时也会返回 True。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"><span class="keyword">from</span> polls.models <span class="keyword">import</span> Question</span><br><span class="line"><span class="comment"># create a Question instance with pub_date 30 days in the future</span></span><br><span class="line">time = timezone.now() + datetime.timedelta(days=<span class="number">30</span>)</span><br><span class="line">future_question = Question(pub_date=time)</span><br><span class="line"><span class="comment"># was it published recently? ==&gt; True</span></span><br><span class="line">future_question.was_published_recently()</span><br></pre></td></tr></table></figure></li><li><p>创造一个测试用例：创建一个 <code>django.test.TestCase</code> 的子类。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Question</span><br><span class="line"><span class="keyword">from</span> django.test <span class="keyword">import</span> TestCase</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuestionModelTests</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_was_published_recently_with_future_question</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        was_published_recently() returns False </span></span><br><span class="line"><span class="string">        for questions whose pub_date is in the future.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        time = timezone.now() + datetime.timedelta(days=<span class="number">30</span>)</span><br><span class="line">        future_question = Question(pub_date=time)</span><br><span class="line">        self.assertIs(future_question.was_published_recently(), <span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></li><li><p>最后，我们可通过 PyCharm 单独运行测试用例，也可以通过终端命令运行自动化测试。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py <span class="built_in">test</span> polls</span><br></pre></td></tr></table></figure></li><li><p>发生了什么呢？以下是自动化测试的运行过程：</p><ul><li><code>python manage.py test polls</code> 将会寻找 Polls 应用里的测试代码，它找到了 django.test.TestCase 的一个子类，并创建一个特殊的数据库供测试使用；</li><li>在类中寻找测试方法 ( 以 test 开头的 )，在 <code>test_was_published_recently_with_future_question</code> 方法中，它创建了一个 pub_date 值为 30 天后的 Question 实例。</li><li>接着使用 <code>assertls()</code> 方法，发现 <code>was_published_recently()</code> 返回了 True，而我们期望它返回 False。</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432712108300322c61f256c74803b43bfd65c6f8d0d0000" target="_blank" rel="noopener">廖雪峰. Python 教程之 virtualenv. 2017. liaoxuefeng.com</a></li><li>[2] <a href="https://zhuanlan.zhihu.com/p/31447222" target="_blank" rel="noopener">地球的外星人君. Python Web 框架大乱斗：哪个框架适合你. 2017. zhihu.com</a></li><li>[3] <a href="https://www.zhihu.com/question/20706333" target="_blank" rel="noopener">知乎问答. Python 有哪些好的 Web 框架. zhihu.com</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Django 是基于 MVC 模式，由 Python 写成的开源 Web 应用框架。在 Django 中，控制器接受用户输入的部分由框架自行处理，而 Django 里更关注的是模型 ( Model )、模板 ( Template ) 和视图 ( Views )，为此也称其为 MTV 模式的 Web 框架。&lt;/p&gt;
&lt;p&gt;当然，基于 Python 的 Web 框架不仅这一家，如  flask、tornado、web2py 等。而任何一款框架的产生都有自身的亮点和缺陷 $^{[2, 3]}$，综合自我诉求、性能要求等诸多因素考量，选择适合的框架即可。在本次开发中，我们只需要一款数据库驱动的内容发布与管理系统，而 Django 的中间件 &lt;a href=&quot;https://baike.baidu.com/item/对象关系映射&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ORM&lt;/a&gt; 设计，使得我们在具体操作业务对象时，不需要和复杂的 SQL 语句打交道，只要像平时操作对象一样操作即可。为此，本着轻量开发的原则选择了 Django。&lt;/p&gt;
    
    </summary>
    
      <category term="Project" scheme="http://www.kofes.cn/categories/Project/"/>
    
    
      <category term="python" scheme="http://www.kofes.cn/tags/python/"/>
    
      <category term="web" scheme="http://www.kofes.cn/tags/web/"/>
    
      <category term="django" scheme="http://www.kofes.cn/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>框架 | FastDFS 入门到应用</title>
    <link href="http://www.kofes.cn/2019/02/FastDFS.html"/>
    <id>http://www.kofes.cn/2019/02/FastDFS.html</id>
    <published>2019-02-05T06:37:37.000Z</published>
    <updated>2019-02-05T06:43:22.082Z</updated>
    
    <content type="html"><![CDATA[<p>余庆老师在他的 Github 上介绍关于 <a href="https://github.com/happyfish100/fastdfs" target="_blank" rel="noopener">FastDFS</a> 开源项目的描述：FastDFS 是一个开源的高性能分布式文件系统 ( DFS )。 它的主要功能包括文件存储，文件同步和文件访问，以及高容量和负载平衡。</p><a id="more"></a><h2 id="FastDFS-简单介绍"><a href="#FastDFS-简单介绍" class="headerlink" title="FastDFS 简单介绍"></a>FastDFS 简单介绍</h2><h3 id="FastDFS-核心组件"><a href="#FastDFS-核心组件" class="headerlink" title="FastDFS 核心组件"></a>FastDFS 核心组件</h3><ul><li><code>Tracker Server</code>：跟踪服务器，负责维持集群的信息；负责管理所有的 Storage Server 和 Group，每个 Storage 在启动后会连接 Tracker，告知自己所属 group 等信息，并保持周期性心跳。</li><li><code>Storage server</code>：存储服务器，以 Group 为单位进行组织，任何一个 Storage Server 都应该属于某个 Group；一个 Group 可含多个 Storage server；在同一个 Group 内部，各 Storage Server 的数据自行同步、备份。</li><li><p><code>Client</code>：客户端，上传、下载数据的服务器，也就是我们自己的项目所部署在的服务器。</p><blockquote><p>核心组件的介绍参考了 [1]、[2] 的概念叙述。</p></blockquote></li></ul><h3 id="FastDFS-组织架构"><a href="#FastDFS-组织架构" class="headerlink" title="FastDFS 组织架构"></a>FastDFS 组织架构</h3><ul><li><p>结合组件的功能描述可知，FastDFS 的组织架构 $^{[2]}$ 如图 1-1 所示。</p><p>  <img src="/images/illustration/Project/2019/02/fastdfs_1-1.jpg" alt="fastdfs_1-1"></p>  <center>图 1-1 FastDFS 的组织架构</center></li></ul><h3 id="FastDFS-文件传输"><a href="#FastDFS-文件传输" class="headerlink" title="FastDFS 文件传输"></a>FastDFS 文件传输</h3><ul><li><p>通过时序图，分析 FastDFS 文件上传、文件下载等操作的流程，如图 1-2 所示。</p><p>  <img src="/images/illustration/Project/2019/02/fastdfs_1-2.jpg" alt="fastdfs_1-2"></p>  <center>图 1-2 FastDFS 文件上传、下载的时序图</center></li><li><p>文件上传流程：</p><ul><li>1) Client 询问 Tracker，发送上传文件的请求；</li><li>2) Tracker 返回可调用的 <code>Storage ID: Port</code>；</li><li>3) Client 直接与目标 Storage 通讯，完成文件上传；</li><li>4) Storage 返回 <code>文件ID</code>，文件ID 为 <code>Group ID + FileName</code>。</li></ul></li><li>文件下载流程：<ul><li>1) Client 询问 Tracker  下载文件所在的 Storage ( 参数为 <code>文件ID</code> )；</li><li>2) Tracker 返回可调用的 <code>Storage ID: Port</code>；</li><li>3) Client 直接与目标 Storage 通讯，完成文件下载；</li><li>4) Storage 返回 <code>文件内容</code>。</li></ul></li></ul><h2 id="FastDFS-客户端"><a href="#FastDFS-客户端" class="headerlink" title="FastDFS 客户端"></a>FastDFS 客户端</h2><h3 id="Java-客户端"><a href="#Java-客户端" class="headerlink" title="Java 客户端"></a>Java 客户端</h3><ul><li>调用余庆老师封装的 <a href="https://github.com/happyfish100/fastdfs-client-java" target="_blank" rel="noopener">FastDFS Client Java SDK</a>，即可实现客户端访问 FastDFS。</li></ul><h3 id="Python-客户端"><a href="#Python-客户端" class="headerlink" title="Python 客户端"></a>Python 客户端</h3><ul><li><p><code>安装环境</code>：网上教程一般都是指 Python 2.7，在 Python 3.x 版本下跑不了，即使是通过 <code>pip3 install fdfs-client-py</code> 安装也跑不通，这里建议通过源码方式安装 $^{[3, 4]}$。</p><blockquote><p>源码地址：<a href="https://github.com/jefforeilly/fdfs_client-py.git" target="_blank" rel="noopener">Hay86. fdfs_client-py. Last Updated on Sept.9, 2018</a></p></blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Case.01.通过 pip 安装</span></span><br><span class="line">pip install fdfs_client-py-master.zip</span><br><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">Case.02.通过 python 安装</span></span><br><span class="line"><span class="string">解压 fdfs_client-py-master.zip，进入目录 /fdfs_client-py-master</span></span><br><span class="line"><span class="string">python steup.py install</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line"><span class="comment"># 安装完成后，若导入时提示缺少 mutagen、requests，请继续安装依赖包</span></span><br><span class="line">pip install mutagen</span><br><span class="line">pip install requests</span><br></pre></td></tr></table></figure></li><li><p><code>安装指南</code>：当然，安装指南和 <a href="https://github.com/hay86/fdfs_client-py#api-reference" target="_blank" rel="noopener">API Reference</a> 请参考源码的官方文档。</p></li><li><p><code>生成配置</code>：在测试代码前夕，我们还需要创建一配置文件 <code>client.conf</code>。注意配置文件名称就是 <strong>client.conf</strong>，更改为其他名称好像行不通。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># connect timeout in seconds</span></span><br><span class="line"><span class="comment"># default value is 30s</span></span><br><span class="line">connect_timeout=<span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># network timeout in seconds</span></span><br><span class="line"><span class="comment"># default value is 30s</span></span><br><span class="line">network_timeout=<span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the base path to store log files</span></span><br><span class="line">base_path=log</span><br><span class="line"></span><br><span class="line"><span class="comment"># tracker_server can ocur more than once, and tracker_server format is</span></span><br><span class="line"><span class="comment"># "host:port", host can be hostname or ip address</span></span><br><span class="line">tracker_server=<span class="number">192.168</span><span class="number">.200</span><span class="number">.221</span>:<span class="number">22122</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># standard log level as syslog, case insensitive, value list:</span></span><br><span class="line"><span class="comment">### emerge for emergency</span></span><br><span class="line"><span class="comment">### alert</span></span><br><span class="line"><span class="comment">### crit for critical</span></span><br><span class="line"><span class="comment">### error</span></span><br><span class="line"><span class="comment">### warn for warning</span></span><br><span class="line"><span class="comment">### notice</span></span><br><span class="line"><span class="comment">### info</span></span><br><span class="line"><span class="comment">### debug</span></span><br><span class="line">log_level=info</span><br><span class="line"></span><br><span class="line"><span class="comment"># if use connection pool</span></span><br><span class="line"><span class="comment"># default value is false</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">use_connection_pool = false</span><br><span class="line"></span><br><span class="line"><span class="comment"># connections whose the idle time exceeds this time will be closed</span></span><br><span class="line"><span class="comment"># unit: second</span></span><br><span class="line"><span class="comment"># default value is 3600</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">connection_pool_max_idle_time = <span class="number">3600</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if load FastDFS parameters from tracker server</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line"><span class="comment"># default value is false</span></span><br><span class="line">load_fdfs_parameters_from_tracker=false</span><br><span class="line"></span><br><span class="line"><span class="comment"># if use storage ID instead of IP address</span></span><br><span class="line"><span class="comment"># same as tracker.conf</span></span><br><span class="line"><span class="comment"># valid only when load_fdfs_parameters_from_tracker is false</span></span><br><span class="line"><span class="comment"># default value is false</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">use_storage_id = false</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify storage ids filename, can use relative or absolute path</span></span><br><span class="line"><span class="comment"># same as tracker.conf</span></span><br><span class="line"><span class="comment"># valid only when load_fdfs_parameters_from_tracker is false</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">storage_ids_filename = storage_ids.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTP settings</span></span><br><span class="line">http.tracker_server_port=<span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># use "#include" directive to include HTTP other settings</span></span><br><span class="line"><span class="comment">## include http.conf</span></span><br></pre></td></tr></table></figure></li><li><p><code>测试代码</code>：这里假设你已成功安装了 <code>fdfs-client-py</code>，那么以一段测试代码正式开始使用。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Step.01. import fdfs_client.client module</span></span><br><span class="line"><span class="comment"># Step.02. instantiate class Fdfs_client</span></span><br><span class="line"><span class="comment"># Step.03. call memeber functions</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fdfs_client.client <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># client.conf 配置文件放在 .py 文件同目录下</span></span><br><span class="line">client = Fdfs_client(<span class="string">'client.conf'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传文件</span></span><br><span class="line">ret = client.upload_by_filename(<span class="string">'upload.txt'</span>)</span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment">## 等待 3 秒，否则下载时会报错文件不存在</span></span><br><span class="line">time.sleep(<span class="number">3</span>)  </span><br><span class="line"><span class="comment">## 新版本文件存放 Remote file_id 格式变化</span></span><br><span class="line">file_id = ret[<span class="string">'Remote file_id'</span>].replace(<span class="string">'\\'</span>, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line">ret_download = client.download_to_file(<span class="string">'download.txt'</span>, file_id)</span><br><span class="line">print(ret_download)</span><br></pre></td></tr></table></figure></li><li><p><code>说明文档</code>：关于 <code>Fdfs_client</code> 类的成员函数详细说明请参考 <a href="https://github.com/hay86/fdfs_client-py#api-reference" target="_blank" rel="noopener">API Reference</a>：</p><ul><li>upload_by_filename(self, filename, meta_dict = None)</li><li>upload_by_buffer(self, filebuffer, file_ext_name = None, meta_dict = None)</li><li>upload_slave_by_filename(self, filename, remote_file_id, prefix_name, meta_dict = None)</li><li>upload_slave_by_buffer(self, filebuffer, remote_file_id, meta_dict = None, file_ext_name = None)</li><li>upload_appender_by_filename(self, local_filename, meta_dict = None)</li><li>upload_appender_by_buffer(self, filebuffer, file_ext_name = None, meta_dict = None)</li><li>delete_file(self, remote_file_id)</li><li>download_to_file(self, local_filename, remote_file_id, offset = 0, down_bytes = 0)</li><li>download_to_buffer(self, remote_file_id, offset = 0, down_bytes = 0)</li><li>list_one_group(self, group_name)</li><li>list_all_groups(self)</li><li>list_servers(self, group_name, storage_ip = None)</li><li>get_meta_data(self, remote_file_id)</li><li>append_by_filename(self, local_filename, remote_fileid)</li><li>append_by_buffer(self, file_buffer, remote_fileid)</li><li>truncate_file(self, truncated_filesize, appender_fileid)</li><li>modify_by_filename(self, filename, appender_fileid, offset = 0)</li><li>modify_by_buffer(self, filebuffer, appender_fileid, offset = 0)</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://www.cnblogs.com/mafly/p/fastdfs.html" target="_blank" rel="noopener">Mafly. 分布式文件系统 FastDFS 简单了解. 2016. cnblogs.com</a></li><li>[2] <a href="https://www.cnblogs.com/shenxm/p/8459292.html" target="_blank" rel="noopener">shenxm. FastDFS 的介绍. 2018. cnblogs.com</a></li><li>[3] <a href="http://zifuchuan.com/me/index.php/python/725-1.html" target="_blank" rel="noopener">小草. FastDFS 的 Python 客户端. 2017. zifuchuan.com</a></li><li>[4] <a href="https://blog.csdn.net/weixin_42149982/article/details/82391218" target="_blank" rel="noopener">ZbyFt. Django-FDFS 配置. 2018. csdn.net</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;余庆老师在他的 Github 上介绍关于 &lt;a href=&quot;https://github.com/happyfish100/fastdfs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FastDFS&lt;/a&gt; 开源项目的描述：FastDFS 是一个开源的高性能分布式文件系统 ( DFS )。 它的主要功能包括文件存储，文件同步和文件访问，以及高容量和负载平衡。&lt;/p&gt;
    
    </summary>
    
      <category term="Project" scheme="http://www.kofes.cn/categories/Project/"/>
    
    
      <category term="分布式" scheme="http://www.kofes.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="文件系统" scheme="http://www.kofes.cn/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="DFS" scheme="http://www.kofes.cn/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>极客 | 树莓派能做什么？</title>
    <link href="http://www.kofes.cn/2019/01/Raspbian-Guideline.html"/>
    <id>http://www.kofes.cn/2019/01/Raspbian-Guideline.html</id>
    <published>2019-01-21T01:20:22.000Z</published>
    <updated>2019-02-28T06:57:20.082Z</updated>
    
    <content type="html"><![CDATA[<p>树莓派能做什么？关于此命题，最直观感受就是看看树莓派实验室整理的一些<a href="http://shumeipai.nxez.com/what-raspi-used-for" target="_blank" rel="noopener">案例</a>，相信你心目中会有答案的。例如，打造一个家庭媒体中心 ( KODI )、配置无线路由器、搭建 BT 下载服务器、搭建代码托管服务器 ( SVN、GIt )、搭建网站服务器、搭建 Shadowsocks、用 HomeKit + Siri 声控家里电器等，即可把树莓派想象成嵌入式、微小型的服务器，这一过程就好比操作系统 ( Linux ) 赋予硬件生命，编程 ( Python、Java )、程序灌入灵魂，借助树莓派低能耗、移动便携性、GPIO 等特性，很多想法不是不可能，相信树莓派会给你创造更多的惊喜！</p><a id="more"></a><p>需要说明的是，本文将围绕两大方面去探索树莓派，即基础应用和解决方案两大部分，也可理解为基础到进阶的过程。</p><ul><li><a href="#基础应用">基础应用</a>：介绍使用树莓派必须的应用或组件，这些应用和组件主要作用是：一方面是增强系统功能，另一方面则是为解决方案建立软件基础。</li><li><a href="#解决方案">解决方案</a>：诸如引言中谈及的，搭建服务器、智能家居控制中心等，即针对某部分需求集成为服务，学术说法称其为某某即服务 ( XaaS )。</li></ul><h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><ul><li>树莓派型号：树莓派 3B+</li><li>树莓派系统：<a href="https://www.raspberrypi.org/downloads/noobs/" target="_blank" rel="noopener">Raspbian v.3.0.0</a></li></ul><h2 id="更新进度"><a href="#更新进度" class="headerlink" title="更新进度"></a>更新进度</h2><ul><li>2019.01.21：完成初稿，形成笔记的整体框架；</li><li>2019.02.25：更新「Jupyter 服务器」 章节内容；</li><li>2019.02.26：更新「Conda 服务器」 章节内容；</li></ul><h2 id="教学资源"><a href="#教学资源" class="headerlink" title="教学资源"></a>教学资源</h2><ul><li>🚩 | 社区 | <a href="http://shumeipai.nxez.com/" target="_blank" rel="noopener">树莓派实验室</a> | 教程、创意、作品、资讯、硬件五位一体的爱好者交流社区。</li><li>🚩 | 社区 | <a href="https://www.quwj.com/" target="_blank" rel="noopener">趣无尽</a> | 树莓派高端、创意的玩法探索博客站。</li><li>📄 | 资料 | <a href="https://www.yahboom.com/study/raspberry" target="_blank" rel="noopener">亚博智能官方资料. 树莓派3代B型开发板</a> | <a href="https://pan.baidu.com/s/1OUa0KszF7sxim5FcUdqccQ" target="_blank" rel="noopener">资料打包下载 ( bwnr )</a></li></ul><h2 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h2><h3 id="TeamViewer-远程控制"><a href="#TeamViewer-远程控制" class="headerlink" title="TeamViewer 远程控制"></a>TeamViewer 远程控制</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>访问树莓派有多种方式，如直连显示器交互使用、通过 SSH 远程登录访问、通过软件实现控制使用等。其中，TeamViewer 是通过软件方式实现对树莓派的远程控制，其拥有有以下几种特性：</p><ul><li>可穿透局域网，支持外网连接；</li><li>实时 GUI 界面显示；</li><li>支持文件双向传输。</li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在本节，则单独介绍 TeamViewer 的配置与使用，当然教程是参考文章 <a href="http://www.52pi.net/archives/549" target="_blank" rel="noopener">[5]</a>、<a href="https://blog.csdn.net/realDonaldTrump/article/details/79694196" target="_blank" rel="noopener">[6]</a> 整理而得。</p><h5 id="删除-TeamViewer"><a href="#删除-TeamViewer" class="headerlink" title="删除 TeamViewer"></a>删除 TeamViewer</h5><p>删除 TeamViewer，用于安装出错时，清理残留软件包，方便从头再来。😂</p><blockquote><p>此步骤是非必要执行的步骤。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove teamviewer-host</span><br><span class="line"><span class="comment"># 清除所有已删除包的残余配置文件</span></span><br><span class="line"><span class="comment"># 若报错误 dpkg: –purge needs at least one package name argument</span></span><br><span class="line"><span class="comment"># 证明你的系统中没有残留配置文件了</span></span><br><span class="line">dpkg -l |grep ^rc|awk <span class="string">'&#123;print $2&#125;'</span> |sudo xargs dpkg -P</span><br></pre></td></tr></table></figure><h5 id="安装-TeamViewer"><a href="#安装-TeamViewer" class="headerlink" title="安装 TeamViewer"></a>安装 TeamViewer</h5><p>Step.01：进入 <a href="https://www.teamviewer.com/en-us/download/linux/" target="_blank" rel="noopener">官方下载</a>，在「TeamViewer Host for Raspberry Pi」模块，复制安装包地址，接着正式开始安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 wget 在线下载安装包</span></span><br><span class="line">wget https://download.teamviewer.com/download/linux/teamviewer-host_armhf.deb</span><br><span class="line"><span class="comment"># 安装本地软件包，但不解决依赖关系</span></span><br><span class="line">sudo dpkg -i teamviewer-host_armhf.deb</span><br><span class="line"><span class="comment"># 修复损坏的软件包，尝试卸载出错的包，重新安装正确版本的</span></span><br><span class="line">sudo apt-get -f install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若提示未找到依赖包，可安装 Gdebi，通过 Gdebi 安装解决依赖问题</span></span><br><span class="line"><span class="comment"># 使用 Gdebi 可代替软件中心接管 deb 软件包的安装</span></span><br><span class="line"><span class="comment"># 它会根据软件仓库这一实用的特性来解算依赖关系</span></span><br><span class="line">sudo apt-get install gdebi</span><br><span class="line">sudo gdebi teamviewer-host_armhf.deb</span><br></pre></td></tr></table></figure><h5 id="配置-TeamViewer"><a href="#配置-TeamViewer" class="headerlink" title="配置 TeamViewer"></a>配置 TeamViewer</h5><p>Step.02：因为我们烧写的系统有图形界面，默认 TeamViewer 要在图形界面进行配置，如远程控制的账号、密码设置等。若有条件支持，可移步图形化界面操作，即可忽略此步骤。</p><ul><li><p>没有图形界面，则我们需要在命令行下配置。使用 <code>raspi-config</code> 配置 Raspbian 仅命令行模式运行。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令模式的操作界面</span></span><br><span class="line"><span class="comment"># 依次选择操作 ( 同理，还原桌面模式也是类似操作 )</span></span><br><span class="line"><span class="comment"># Boot Options -&gt; Desktop / CLI -&gt; Console AutoLogin -&gt;</span></span><br><span class="line"><span class="comment"># Finished</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>配置保存后，树莓派会自动重启，那么重新远程登录继续操作。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo teamviewer setup</span><br><span class="line"><span class="comment"># 1. Accept License Agreement? (y/n) y</span></span><br><span class="line"><span class="comment"># 2. 输入用户名和密码的步骤无法跳过，没有账号请移步「官网完成注册」</span></span><br><span class="line"><span class="comment">#  注册地址：https://login.teamviewer.com/LogOn</span></span><br><span class="line"><span class="comment">#  Please enter your e-mail / username: kofe</span></span><br><span class="line"><span class="comment">#  Please enter your password: ******</span></span><br><span class="line"><span class="comment"># 3. 然后 TeamViewer 会发一份设备授权邮件，请移步「邮箱处理」</span></span><br><span class="line"><span class="comment"># 4. 重新输入用户名和密码登录，提示分组信息，点击 y：</span></span><br><span class="line"><span class="comment">#  Adding this machine as 'raspberrypi' to ... </span></span><br><span class="line"><span class="comment"># Do you want to continue? (y/n) [n]  y</span></span><br><span class="line"><span class="comment"># 5. 提示 "Successfully...." 即表示已经完成配置工作了</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>完成初始化配置后，只需设置远程控制密码即可使用了。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本机 ID</span></span><br><span class="line">teamviewer info</span><br><span class="line"><span class="comment"># 设置本机密码</span></span><br><span class="line">teamviewer passwd [你的密码]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>当然，我们还需要把 Raspbian 还原为图形化操作界面。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br><span class="line"><span class="comment"># Boot Options -&gt; Desktop / CLI -&gt; Desktop AutoLogin -&gt;</span></span><br><span class="line"><span class="comment"># Finished</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li><p>一般情况下，我们主要是通过命令模式访问树莓派、配置 TeamViewer。当然也可以通过图形界面完成配置操作，按照文字提示操作即可，这里就不详细阐述了。附上 TeamViewer 常用的命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看帮助信息</span></span><br><span class="line">teamviewer <span class="built_in">help</span></span><br><span class="line"><span class="comment"># 查看本机 ID</span></span><br><span class="line">teamviewer info</span><br><span class="line"><span class="comment"># 设置本机密码</span></span><br><span class="line">sudo teamviewer passwd [你的密码]</span><br><span class="line"><span class="comment"># 启动 TeamViewer 服务</span></span><br><span class="line">sudo teamviewer --daemon start</span><br><span class="line"><span class="comment"># 开启 TeamViewer 服务随机启动</span></span><br><span class="line">sudo teamviewer --daemon <span class="built_in">enable</span></span><br></pre></td></tr></table></figure></li><li><p>最后，关于图形化界面显示方面，可能还有分辨率调整与存在黑边的问题，详细可参考以下文章解决问题：</p><ul><li><a href="https://www.raspberrypi.org/documentation/configuration/config-txt/README.md" target="_blank" rel="noopener">树莓派. 官方使用文档之 CONFIG-TXT. raspberrypi.org</a></li><li><a href="https://blog.csdn.net/fishchina/article/details/54564395" target="_blank" rel="noopener">FishChina. 树莓派有黑边不能全屏解决方法. 2017. csdn.net</a></li></ul></li></ul><h3 id="MySQL-数据库"><a href="#MySQL-数据库" class="headerlink" title="MySQL 数据库"></a>MySQL 数据库</h3><h4 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h4><p>数据库的用途毋庸置疑，若在树莓派上跑脚本、程序、网站系统等，少不了数据的交互，为此我们需要一款数据库作为数据储存的媒介。MySQL，是一款开源免费的数据库，也是关系型数据库管理系统，支持多种存储引擎 $^{[1, 2]}$，对于个人开发和日常使用足矣。</p><p>以下将介绍，在树莓派 Raspbian 上安装 Mysql  服务，并开启远程访问。</p><h4 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h4><ul><li><p>删除 MySQL：安装前，确保系统没有旧版的 MySQL。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoremove --purge mysql-server</span><br><span class="line">sudo apt-get remove mysql-common</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除所有已删除包的残馀配置文件</span></span><br><span class="line"><span class="comment"># 若报错误 dpkg: –purge needs at least one package name argument</span></span><br><span class="line"><span class="comment"># 证明你的系统中没有残留配置文件了</span></span><br><span class="line">dpkg -l |grep ^rc|awk <span class="string">'&#123;print $2&#125;'</span> |sudo xargs dpkg -P</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>安装 MySQL：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt-get install mysql-client</span><br><span class="line">sudo apt-get install python-mysqldb <span class="comment"># 安装 Python 接口的 MySQL</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="配置-MySQL"><a href="#配置-MySQL" class="headerlink" title="配置 MySQL"></a>配置 MySQL</h4><ul><li><p>命令行安装，默认是不用配置用户和密码信息，故我们首先配置登录信息 $^{[3]}$：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql -u root # 无密码登录 MySQL</span><br><span class="line"><span class="keyword">use</span> mysql;</span><br><span class="line"></span><br><span class="line"># 加密方式选择，系统默认是 'unix_socket'，这里暂为空</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> <span class="keyword">plugin</span>=<span class="string">''</span> <span class="keyword">WHERE</span> <span class="keyword">user</span>=<span class="string">'root'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> <span class="keyword">password</span>=<span class="keyword">PASSWORD</span>(<span class="string">'你自己的密码'</span>) <span class="keyword">WHERE</span> <span class="keyword">user</span>=<span class="string">'root'</span>;</span><br><span class="line"></span><br><span class="line">flush privileges; # 清空缓存</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure></li><li><p>操作数据库 ( 配置完信息，重启 MySQL 以让设置生效 )</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudo /etc/init.d/mysql status/start/stop/restart</span></span><br><span class="line">sudo /etc/init.d/mysql restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然可通过 systemctl 命令管理系统服务</span></span><br><span class="line"><span class="comment"># sudo systemctl restart mysql # 重启系统服务</span></span><br><span class="line"><span class="comment"># sudo systemctl status mysql # 查看系统状态</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="开启远程访问"><a href="#开启远程访问" class="headerlink" title="开启远程访问"></a>开启远程访问</h4><p>以上配置工作完成后，即可本地使用 MySQL 数据库了。若需要开启远程访问服务，我们还需要实现以下工作：防火墙与访问规则配置和远程登录的账号配置。</p><h5 id="外网访问"><a href="#外网访问" class="headerlink" title="外网访问"></a>外网访问</h5><p>若在树莓派下测试，让数据库允许外网访问，注意得关闭防火墙或添加规则允许某端口的访问权限 $^{[4]}$。</p><ul><li>Case.01：本机和服务器端 ( 树莓派 ) 互相 Ping 对方 IP，以检验网络是否畅通、是否拒绝访问。</li><li><p>Case.02：若网络畅通、没有拒绝访问，还要留意对应端口是否有权限访问，通过 nc -vz IP 端口检验，返回 Succeeded 即成功。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MacOS：nc -vz IP地址 端口号</span></span><br><span class="line">nc -vz 192.168.x.x 3306</span><br><span class="line"><span class="comment"># Windows：telnet IP地址 端口号</span></span><br><span class="line">telnet 192.168.x.x 22 <span class="comment"># SSH 远程访问</span></span><br><span class="line">telnet 192.168.x.x 3306 <span class="comment"># MySQL 数据库</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="防火墙与访问规则"><a href="#防火墙与访问规则" class="headerlink" title="防火墙与访问规则"></a>防火墙与访问规则</h5><p>针对上述两种情况，则可通过关闭防火墙或者添加端口的访问规则，以授权 IP 和相关端口接受访问。</p><ul><li><p>配置防火墙：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 ufw ( 已安装忽略 )</span></span><br><span class="line">sudo apt-get install ufw</span><br><span class="line"><span class="comment"># 设置默认规则为 allow，除指明打开的端口，所有端口默认关闭</span></span><br><span class="line">ufw default deny</span><br><span class="line"><span class="comment"># 启用 /关闭 ufw</span></span><br><span class="line">ufw <span class="built_in">enable</span>/<span class="built_in">disable</span></span><br><span class="line"><span class="comment"># 查看防火墙状态</span></span><br><span class="line">ufw status</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>配置访问规则：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如：打开 SSH 远程登录</span></span><br><span class="line">sudo ufw allow 22</span><br><span class="line"><span class="comment"># 删除添加过的规则</span></span><br><span class="line">sudo ufw delete allow 22</span><br></pre></td></tr></table></figure></li></ul><h5 id="远程登录的账号"><a href="#远程登录的账号" class="headerlink" title="远程登录的账号"></a>远程登录的账号</h5><p>最后，我们还需要设置可远程登录的账号。</p><ul><li><p>修改 MySQL 配置：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/mysql/mariadb.conf.d/50-server.cnf</span><br><span class="line"><span class="comment"># 找到 bind-address 这行注释掉，然后重启</span></span><br><span class="line">sudo systemctl restart mysql</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>修改 MySQL 账号信息：在配置 <code>登录信息</code> 时已授权，此项可日后用作远程登录账号的配置。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line"><span class="keyword">use</span> mysql;</span><br><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'root账号密码'</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Jupyter-服务器"><a href="#Jupyter-服务器" class="headerlink" title="Jupyter 服务器"></a>Jupyter 服务器</h3><h4 id="引言-2"><a href="#引言-2" class="headerlink" title="引言"></a>引言</h4><p>Jupyter Notebooks 是什么？相信做数据科学项目的同学都清楚，Jupyter 其提供了一个集成环境，无需更多附加操作就可在其中编写你的代码、运行代码、查看输出、可视化数据并查看结果。</p><p>作为一款可执行端到端的数据科学工作流程的便捷工具，它不仅支持数据清理、统计建模、构建和训练机器学习模型、可视化数据等数据科学工作，而且其强大的交互性，使得它可以更具教学性的方式展示代码。</p><blockquote><p>当然 Jupyter 也能运行其他 Python 程序，这里只是为了代入特定场景介绍它。</p></blockquote><h4 id="安装-Jupyter-Notebook"><a href="#安装-Jupyter-Notebook" class="headerlink" title="安装 Jupyter Notebook"></a>安装 Jupyter Notebook</h4><ul><li><p>在此之前，需要确保你安装了 <code>Python</code> 以及 <code>pip</code> 模块。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 树莓派 Raspbian 原生内置了 Python 2.7</span></span><br><span class="line"><span class="comment"># 我们需要基于 Python 3.x 基础上运作 Jupyter，则需要先安装 Python 3.x</span></span><br><span class="line">sudo apt-get install python3.5 python3-pip</span><br></pre></td></tr></table></figure></li><li><p>安装 Jupyter Notebook：</p><blockquote><p>若你已经有使用 virtualenv 的经验，强烈建议在虚拟环境中安装所需版本的 jupyter notebook。</p></blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于 Python 2.7</span></span><br><span class="line">pip install --upgrade jupyter</span><br><span class="line"><span class="comment"># 基于 Python 3.x</span></span><br><span class="line">pip3 install --upgrade jupyter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否安装成功，成功返回版本号</span></span><br><span class="line">jupyter --version</span><br></pre></td></tr></table></figure></li></ul><h4 id="配置-Jupyter-Notebook"><a href="#配置-Jupyter-Notebook" class="headerlink" title="配置 Jupyter Notebook"></a>配置 Jupyter Notebook</h4><p>配置 Jupyter Notebook，参考了文档 <a href="https://www.jianshu.com/p/639c8d939643" target="_blank" rel="noopener">[7]</a>：</p><ul><li><p>生成配置文件：注意不同用户组，生成的配置文件是存放在不同位置的。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件存放于 /root/.jupyter/jupyter_notebook_config.py </span></span><br><span class="line">sudo jupyter notebook --generate-config</span><br><span class="line"><span class="comment"># 配置文件存放于 /home/pi/.jupyter/jupyter_notebook_config.py ( 推荐 )</span></span><br><span class="line"><span class="comment"># /home/pi/ 为当前登录用户的工作目录</span></span><br><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure></li><li><p>设置密码：终端进入 iPython / Python 环境，借助 Python 生成 SHA 密钥：</p><blockquote><p>若不开启远程服务，则可跳过此步骤。</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd <span class="comment"># 导入授权模块设置密码</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>passwd() <span class="comment"># 提示键入密码</span></span><br><span class="line">Enter password: your password</span><br><span class="line">Verify password: your password again</span><br><span class="line"><span class="comment"># 密码的哈希值，用于配置文件中设置密码</span></span><br><span class="line"><span class="string">'sha1:67c9e601de......7d111089e11aed'</span></span><br></pre></td></tr></table></figure></li><li><p>进入配置文件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /home/pi/.jupyter/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>修改配置内容：配置选项非常丰富，关于其他配置的选项用途详细可参考 <code>jupyter_notebook_config.py</code> 内的注释。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意开启配置选项，记得去掉 #，才能使配置生效！</span></span><br><span class="line"><span class="comment"># 允许所有 IP 访问</span></span><br><span class="line">c.NotebookApp.ip=<span class="string">'*'</span></span><br><span class="line"><span class="comment"># 远程访问密钥</span></span><br><span class="line">c.NotebookApp.password = u<span class="string">'sha:67c9e......11aed'</span></span><br><span class="line"><span class="comment"># 不在本机自动打开浏览器</span></span><br><span class="line">c.NotebookApp.open_browser = False</span><br><span class="line"><span class="comment"># 指定监听端口</span></span><br><span class="line">c.NotebookApp.port =8888</span><br><span class="line"><span class="comment"># Jupyter 的默认工作目录</span></span><br><span class="line">c.NotebookApp.notebook_dir = <span class="string">'/home/pi/ipynb/'</span></span><br><span class="line"><span class="comment"># 允许使用 root 用户启动 jupyter</span></span><br><span class="line"><span class="comment"># c.NotebookApp.allow_root = True</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>启动 Jupyter Notebook：<code>jupyter notebook</code></li></ul><h4 id="拓展-Jupyter-Notebook"><a href="#拓展-Jupyter-Notebook" class="headerlink" title="拓展 Jupyter Notebook"></a>拓展 Jupyter Notebook</h4><h5 id="开启远程访问-1"><a href="#开启远程访问-1" class="headerlink" title="开启远程访问"></a>开启远程访问</h5><p>Jupyter Notebook 开启远程访问 ( 远程访问这里指同一局域网，其他终端访问树莓派，若是要外网访问请参阅内网穿透相关内容 )，但端口被拒绝访问。</p><ul><li><p>在配置文件中，我们只设置了 <code>0.0.0.0</code> 或 <code>*</code> 的 IP 地址，在局域网环境运行能正常访问。但对于远程访问，归根结底，我们还需要知道树莓派的 IP 才能访问到服务端的 Jupyter，故我们是这样解决访问问题的 $^{[7]}$。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nohup: 一直执行命令，即使关闭了 SSH。</span></span><br><span class="line"><span class="comment"># --ip: 指定在 192.168.10.200 ( 树莓派的IP ) 上监听活动。</span></span><br><span class="line"><span class="comment"># &amp;: 在后台运行这条命令。</span></span><br><span class="line">nohup jupyter notebook --ip 192.168.10.200 &amp;</span><br></pre></td></tr></table></figure></li><li><p>最后，我们需要确保该端口是否在安全策略下已经开启，详细可参考 MySQL 数据库的 <a href="#防火墙与访问规则">防火墙与访问规则</a> 章节内容。</p></li></ul><h5 id="开启自启服务"><a href="#开启自启服务" class="headerlink" title="开启自启服务"></a>开启自启服务</h5><p>搭建 Jupyter 服务器，Jupyter 挂靠后台服务，且开通断电自动重启功能，参考了文档 <a href="https://blog.csdn.net/q361949240/article/details/83179560" target="_blank" rel="noopener">[8]</a>。</p><ul><li><p>在 <code>/etc/systemd/system</code> 下创建 <code>jupyter.service</code> 输入如下内容：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/sytemd/system/jupyter.service</span><br></pre></td></tr></table></figure></li><li><p><code>jupyter.service</code> 内容填写如下：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Jupyter Notebook</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line"><span class="comment"># 这里在 /run 目录下没有 jupyter.pid</span></span><br><span class="line"><span class="comment"># 这个是进程产生之后出现的，虽然在启动前没有，但是可以使用</span></span><br><span class="line">PIDFile=/run/jupyter.pid</span><br><span class="line"><span class="comment"># ExecStart 是执行文件 jupyter-notebook</span></span><br><span class="line"><span class="comment"># config 是配置文件 jupyter_notebook_config.py</span></span><br><span class="line"><span class="comment"># ip 是树莓派的地址</span></span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/jupyter-notebook --config=/home/pi/.jupyter/jupyter_notebook_config.py --ip=192.168.10.200</span><br><span class="line">User=pi</span><br><span class="line"><span class="comment"># 查看用户组 groups pi，发现属于 pi 组</span></span><br><span class="line">Group=pi</span><br><span class="line"><span class="comment"># 自己设置的工作目录</span></span><br><span class="line"><span class="comment"># 需同时在 jupyter_notebook_config.py 中设置</span></span><br><span class="line"><span class="comment"># c.NotebookApp.notebook_dir = '/home/pi/ipynb/'</span></span><br><span class="line">WorkingDirectory=/home/pi/ipynb/</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li><li><p>使服务自启动：<code>systemctl enable jupyter</code></p></li><li>启动服务：<code>service jupyter start</code></li></ul><h5 id="加载虚拟环境"><a href="#加载虚拟环境" class="headerlink" title="加载虚拟环境"></a>加载虚拟环境</h5><ul><li><p>首先，我们为 Jupyter Notebook 创建隔绝的虚拟环境，从而便捷、更针对地管理软件包。</p><blockquote><p>比如，某个 Python 程序需要 Python 2.7 特定环境运行，而我们编译的环境是 Python 3.x ，即为了运行该程序需要把原来的 Python 3.x 给替换成 Python 2.7。同理，对于程序的依赖包，即使是同一个软件包也存在不同版本的要求。那么问题就出现在这，在同一台电脑上，为让更多程序兼容运行，这正是虚拟环境的作用之一。  </p></blockquote></li><li><p>再者，引入 <a href="#Conda-管理器">Conda 管理器</a> 的概念，简单来说 Conda 是一款包管理系统。conda 与 pip 类似，它会根据你的键入需求，且自行交代清楚相互依赖的包，并实现自动化地下载、安装它们。</p></li><li><p>基于以上两点的理解，我们正式进入正题，开始配置一个虚拟环境，并让 Jupyter Notebook 使用起来：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 参考 Conda 管理器的 BerryConda 小节，完成 BerryConda 的安装</span></span><br><span class="line"><span class="comment"># 2. 建立一个虚拟环境运作 Conda 以方便管理各种包</span></span><br><span class="line">conda create -n your_venv_name python=3.6</span><br><span class="line"><span class="comment"># 3. 激活环境</span></span><br><span class="line"><span class="built_in">source</span> activate your_venv_name</span><br><span class="line"><span class="comment"># 4. 安装 Jupyter 包：上述内容中，Jupyter 是安装在原生环境下的</span></span><br><span class="line"><span class="comment"># 考虑到兼容性的情况 (例如第5点的情况)，在该虚拟环境中重新安装一个 Jupyter</span></span><br><span class="line">conda install jupyter</span><br><span class="line"><span class="comment"># 给该环境下载其他软件包也是类似操作</span></span><br><span class="line"><span class="comment"># conda install scipy numpy scikit-learn...</span></span><br><span class="line"><span class="comment"># 5. 指定版本安装 tornado，不然 Jupyter 会报错</span></span><br><span class="line">conda install tornado=4.5</span><br><span class="line"><span class="comment"># 6. 安装 nb_conda 包，让 Jupyter 支持使用虚拟环境</span></span><br><span class="line">conda install nb_conda</span><br></pre></td></tr></table></figure></li><li><p>若使用虚拟环境中的 Jupyter ( 自启服务的 ExecStart 设置同理 )，此时启动 Jupyter 的程序应该改为：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /home/pi/ 为当前登录用户的工作目录</span></span><br><span class="line">/home/pi/berryconda3/envs/your_venv_name/bin/jupyter-notebook</span><br></pre></td></tr></table></figure></li></ul><h5 id="打造科学环境"><a href="#打造科学环境" class="headerlink" title="打造科学环境"></a>打造科学环境</h5><h6 id="Tensorflow"><a href="#Tensorflow" class="headerlink" title="Tensorflow"></a>Tensorflow</h6><p>值得庆贺的是，<a href="https://medium.com/tensorflow/tensorflow-1-9-officially-supports-the-raspberry-pi-b91669b0aa0" target="_blank" rel="noopener">Tensorflow 1.9</a> 官方版本开始支持树莓派 RaspBerry Pi 了，没有繁琐的步骤即可体验 Tensorflow！具体的安装方法大概参考 <a href="https://tensorflow.google.cn/install/pip" target="_blank" rel="noopener">Tensorflow 官方说明文档</a>。</p><ul><li><p>但在实操过程中还是碰到了不可预计的情况：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装 libatlas-base-dev (Required for Numpy)</span></span><br><span class="line">sudo apt install libatlas-base-dev</span><br><span class="line"><span class="comment"># 2. 同样，在虚拟环境内安装 tensorflow，虚拟环境的 Python 版本为 3.6</span></span><br><span class="line"><span class="built_in">source</span> activate your_venv_name</span><br><span class="line"><span class="comment"># 3. 安装 h5py、hdf5，不然 tf 安装过程中会报错 ( 缺少 hdf5.h 文件 )：</span></span><br><span class="line"><span class="comment"># /tmp/pip-install-ve4RnJ/h5py/h5py/api_compat.h:27:18: </span></span><br><span class="line"><span class="comment"># fatal error: hdf5.h: No such file or directory</span></span><br><span class="line"><span class="comment"># 4. 通过 conda 安装 h5py ( 好像 pip (Python3.x) 安装 h5py 会遇到缺少文件的问题？)</span></span><br><span class="line">conda install h5py </span><br><span class="line"><span class="comment"># 5. 正式安装 tensorflow</span></span><br><span class="line"><span class="comment"># pip --version 查看是否是虚拟环境的 pip，不然未能安装在当前环境</span></span><br><span class="line">pip install --upgrade --user tensorflow</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>若中途不出错、不提示错误，等待安装成功即可。然后输入代码测试验证：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python <span class="comment"># 命令进入 ipython / python 模式</span></span><br><span class="line">&gt;&gt;&gt; import tensorflow as tf</span><br><span class="line">&gt;&gt;&gt; tf.enable_eager_execution()</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>( tf.reduce_sum(tf.random_normal([1000, 1000])) )</span><br></pre></td></tr></table></figure></li><li><p>当然，还可能遇到 tensorflow 部分模块的 Python 版本跟编译环境的 Python 版本对不上，则可通过针对 ( 编译环境的 ) Python 版本的 pip 升级 tensorflow 解决此问题：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 异常的情况大概如下：</span></span><br><span class="line"><span class="comment"># /usr/lib/python3.6/importlib/_bootstrap.py:219: </span></span><br><span class="line"><span class="comment"># RuntimeWarning: compiletime version 3.5 of module 'tensorflow.python.framework.fast_tensor_util' </span></span><br><span class="line"><span class="comment"># does not match runtime version 3.6</span></span><br><span class="line">python3.6 -m pip install --upgrade --user tensorflow</span><br></pre></td></tr></table></figure></li></ul><h6 id="Keras"><a href="#Keras" class="headerlink" title="Keras"></a>Keras</h6><ul><li><p>安装过程演示：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 同样，在虚拟环境内安装 keras，虚拟环境的 Python 版本为 3.6</span></span><br><span class="line"><span class="built_in">source</span> activate your_venv_name</span><br><span class="line"><span class="comment"># 2. 正式安装 keras</span></span><br><span class="line"><span class="comment"># pip --version 查看是否是虚拟环境的 pip，不然未能安装在当前环境</span></span><br><span class="line">pip install --upgrade --user keras</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>当然，还可能遇到版本对不上的异常，参考 上述解决方案：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3.6 -m pip install --upgrade --user keras</span><br></pre></td></tr></table></figure></li></ul><h5 id="常见问题整理"><a href="#常见问题整理" class="headerlink" title="常见问题整理"></a>常见问题整理</h5><ul><li><p>当新建或修改 ipynb 文档时，出现 <code>Permission denied: Untitled.ipynb</code> 权限异常，检查工作目录是否具有操作权限、当前用户是否有操作权限。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保 Jupyter 工作目录属于当前登录用户 pi</span></span><br><span class="line">sudo chown -R pi:pi /home/pi/ipynb</span><br><span class="line"><span class="comment"># 确保 Jupyter 工作目录有可读、可写和可执行的权限</span></span><br><span class="line"><span class="comment"># 更新后的权限情况：drwxrwxr--</span></span><br><span class="line">chmod ug=rwx /home/pi/ipynb</span><br></pre></td></tr></table></figure></li></ul><h3 id="Conda-管理器"><a href="#Conda-管理器" class="headerlink" title="Conda 管理器"></a>Conda 管理器</h3><h4 id="引言-3"><a href="#引言-3" class="headerlink" title="引言"></a>引言</h4><p>无论是使用 Jupyter Notebook，亦或是原生 Python 环境做 <code>数据科学</code> 相关工作，难免需要 <code>安装各种科学计算包</code>，而且还涉及众多依赖包的安装。那么如何管理包变成了一门 “手艺活” 了，此时推荐你使用 Conda 包管理系统，繁琐的包安装工作交由 Conda 处理，你只管专心地开展数据科学工作。</p><p>参考 <a href="https://www.zhihu.com/question/65430209" target="_blank" rel="noopener">树莓派 Raspbian 系统可安装 Anaconda 吗？</a>，得知树莓派安装 Conda 共有两种选择：</p><ul><li><a href="https://conda.io/en/latest/miniconda.html" target="_blank" rel="noopener">MiniConda</a>：年久未更，目前 Python 只停留在 Python 3.4 版本。</li><li><a href="https://github.com/jjhelmus/berryconda" target="_blank" rel="noopener">BerryConda</a>：是一款为树莓派定制基于 Conda Python 发行版的开源软件。Berryconda 提供了 Python 2.7 的 Berryconda 2 和 Python 3.6 的 Berryconda 3，同时还支持树莓派 0、1、2、3 各个系列，我们可根据树莓派的版本选择适合的软件版本安装即可。</li></ul><h4 id="Miniconda"><a href="#Miniconda" class="headerlink" title="Miniconda"></a>Miniconda</h4><p>Miniconda 与 Anaconda 同为发行版本的 Conda 包管理系统，Miniconda 则是最小的 Conda 安装环境。以下直接安装操作演示，安装过程参考了 <a href="https://blog.csdn.net/tju_cc/article/details/80024721" target="_blank" rel="noopener">[9]</a>、<a href="https://www.jianshu.com/p/edaa744ea47d" target="_blank" rel="noopener">[10]</a>。</p><h5 id="安装-MiniConda"><a href="#安装-MiniConda" class="headerlink" title="安装 MiniConda"></a>安装 MiniConda</h5><ul><li><p>首先，确保安装了 <code>wget</code> 和 <code>bzip2</code>：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看是否有反馈，有则表示已安装</span></span><br><span class="line">wget --<span class="built_in">help</span></span><br><span class="line">bzip2 --<span class="built_in">help</span></span><br><span class="line">sudo apt-get install -y wget bzip2</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>下载安装脚本：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wget 不添加参数，默认是保存到当前路径</span></span><br><span class="line"><span class="comment"># wget -O /path/name 指定路径及文件名</span></span><br><span class="line">wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-armv7l.sh</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>运行安装脚本：</p><blockquote><p>安装过程中不需要使用 sudo，程序默认会安装到 /home/pi/miniconda3 中。当然，也是为了确保 miniconda3 工作目录属于当前登录用户 pi。</p></blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bash Miniconda3-latest-Linux-armv7l.sh</span><br><span class="line"><span class="comment"># 安装过程中，需要阅读一份声明，后面需要输入两次 Yes 确认</span></span><br><span class="line"><span class="comment"># 第一个 Yes 是是否同意声明，若回车跳过则是默认输入了 No</span></span><br><span class="line"><span class="comment"># 第二个 Yes 是添加到环境变量，否则需要自己手动添加到环境变量</span></span><br><span class="line"><span class="comment"># --------- 若选择了 No 则需进行以下步骤的操作 --------- #</span></span><br><span class="line"><span class="comment"># 1. 编辑 /bashrc 文件</span></span><br><span class="line">vim /home/pi/.bashrc</span><br><span class="line"><span class="comment"># 2. 添加以下内容 (根据自己的安装路径修改)：</span></span><br><span class="line"><span class="comment"># export PATH="/home/pi/miniconda3/bin:$PATH"</span></span><br><span class="line"><span class="comment"># 3. 添加完成后记得让其生效 ( 启动时才执行原则 )</span></span><br><span class="line"><span class="comment"># export 生成的环境变量是临时的，关闭终端即结束 ( 可改永久性环境变量 )</span></span><br><span class="line"><span class="built_in">source</span> /home/pi/.bashrc</span><br></pre></td></tr></table></figure></li></ul><h5 id="使用-MiniConda"><a href="#使用-MiniConda" class="headerlink" title="使用 MiniConda"></a>使用 MiniConda</h5><ul><li><p>检查 conda 是否安装成功，返回版本信息：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查 conda 是否安装成功，返回版本信息</span></span><br><span class="line">conda --version</span><br><span class="line"><span class="comment"># 显示当前已经安装好的包</span></span><br><span class="line">conda list</span><br></pre></td></tr></table></figure></li><li><p><code>创建虚拟环境</code>，以避免 “污染” 环境，便于管理各种 Python 包：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立一个虚拟环境运作 Conda 以方便管理各种包</span></span><br><span class="line">conda create -n your_venv_name python=3.4</span><br><span class="line"><span class="comment"># 删除一个虚拟环境：</span></span><br><span class="line"><span class="comment"># conda env remove -n your_venv_name</span></span><br><span class="line"><span class="comment"># 激活环境 &lt;---&gt; 关闭环境：source deactivate</span></span><br><span class="line"><span class="built_in">source</span> activate your_venv_name</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>更改国内源，优化安装包下载速度：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加国内下载源 ( 例如: 清华源 )</span></span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line"><span class="comment"># 替换源后记得更新 Conda 以促使配置生效</span></span><br><span class="line">conda update conda</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用 Conda 安装包:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事先查找指定软件是否存在</span></span><br><span class="line">conda search numpy</span><br><span class="line"><span class="comment"># 安装指定软件</span></span><br><span class="line">conda install numpy</span><br><span class="line"><span class="comment"># 安装特定版本的软件，Conda 会先卸载已安装版本，然后重新安装指定版本</span></span><br><span class="line">conda install 软件名=版本号</span><br><span class="line"><span class="comment"># 更新指定软件</span></span><br><span class="line">conda update numpy</span><br><span class="line"><span class="comment"># 卸载指定软件</span></span><br><span class="line">conda remove numpy</span><br></pre></td></tr></table></figure></li></ul><h5 id="卸载-MiniConda"><a href="#卸载-MiniConda" class="headerlink" title="卸载 MiniConda"></a>卸载 MiniConda</h5><ul><li><p>卸载 MiniConda 的方法：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 在 /home/pi/.bashrc 移除环境变量 ( 注释掉 )</span></span><br><span class="line"><span class="comment"># export PATH="/home/pi/miniconda3/bin:$PATH"</span></span><br><span class="line"><span class="comment"># 2. 删除 miniconda 整个文件</span></span><br><span class="line">rm -rf miniconda3/</span><br><span class="line"><span class="comment"># 3. 重新激活 .bashrc</span></span><br><span class="line"><span class="built_in">source</span> /home/pi/.bashrc</span><br></pre></td></tr></table></figure></li></ul><h4 id="BerryConda"><a href="#BerryConda" class="headerlink" title="BerryConda"></a>BerryConda</h4><p>BerryConda 是一款为树莓派定制基于 conda python 发行版的开源软件。安装过程参考了 <a href="https://www.jianshu.com/p/ccad38dbb897" target="_blank" rel="noopener">[11]</a>。</p><h5 id="安装-BerryConda"><a href="#安装-BerryConda" class="headerlink" title="安装 BerryConda"></a>安装 BerryConda</h5><ul><li><p>参考 <a href="https://github.com/jjhelmus/berryconda" target="_blank" rel="noopener">BerryConda</a> 文档，根据自己的机器版本 ( 树莓派 3B+ / Armv7l 架构 )，并确定 Python 版本号 ( Python 3.x )，为此选择了 Berryconda 3 版本安装，安装方法与 Miniconda 类似。</p></li><li><p>下载安装脚本：</p><blockquote><p>安装过程中不需要使用 sudo，程序默认会安装到 /home/pi/berryconda3 中。当然，也是为了确保 berryconda3 工作目录属于当前登录用户 pi。</p></blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/jjhelmus/berryconda/releases/download/v2.0.0/Berryconda3-2.0.0-Linux-armv7l.sh</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>执行安装脚本：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bash Berryconda3-2.0.0-Linux-armv7l.sh</span><br><span class="line"><span class="comment"># 安装过程中，需要阅读一份声明，后面需要输入两次 Yes 确认</span></span><br><span class="line"><span class="comment"># 第一个 Yes 是是否同意声明，若回车跳过则是默认输入了 No</span></span><br><span class="line"><span class="comment"># 第二个 Yes 是添加到环境变量，否则需要自己手动添加到环境变量</span></span><br><span class="line"><span class="comment"># --------- 若选择了 No 则需进行以下步骤的操作 --------- #</span></span><br><span class="line"><span class="comment"># 1. 编辑 /bashrc 文件</span></span><br><span class="line">vim /home/pi/.bashrc</span><br><span class="line"><span class="comment"># 2. 添加以下内容 (根据自己的安装路径修改)：</span></span><br><span class="line"><span class="comment"># export PATH="/home/pi/miniconda3/bin:$PATH"</span></span><br><span class="line"><span class="comment"># 3. 添加完成后记得让其生效</span></span><br><span class="line"><span class="comment"># export 生成的环境变量是临时的，关闭终端即结束 ( 可改永久性环境变量 )</span></span><br><span class="line"><span class="built_in">source</span> /home/pi/.bashrc</span><br></pre></td></tr></table></figure></li></ul><h5 id="使用-BerryConda"><a href="#使用-BerryConda" class="headerlink" title="使用 BerryConda"></a>使用 BerryConda</h5><ul><li><p>至此，BerryConda 已经安装完成，查看版本信息检验是否安装成功，剩余的 Conda 操作参考 <a href="#使用-MiniConda">使用 MiniConda</a> 章节即可。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查 conda 是否安装成功，返回版本信息</span></span><br><span class="line">conda --version</span><br><span class="line"><span class="comment"># 显示当前已经安装好的包</span></span><br><span class="line">conda list</span><br></pre></td></tr></table></figure></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://baike.baidu.com/item/存储引擎" target="_blank" rel="noopener">百度百科. 存储引擎. baike.baidu.com</a></li><li>[2] <a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md" target="_blank" rel="noopener">jaywcjlove. mysql-tutorial. 2017. github.com</a></li><li>[3] <a href="https://www.cnblogs.com/apanly/p/9061803.html" target="_blank" rel="noopener">编程浪子. 树莓派3之安装Mysql服务. 2018. cnblogs.com</a></li><li>[4] <a href="https://blog.csdn.net/faryang/article/details/50788795" target="_blank" rel="noopener">farYang. 树莓派安装mysql并开启远程访问. 2016. csdn.net</a></li><li>[5] <a href="http://www.52pi.net/archives/549" target="_blank" rel="noopener">Li, TaterLi. 十步配置TeamViewer远程控制Pi. 2017. 52pi.net</a></li><li>[6] <a href="https://blog.csdn.net/realDonaldTrump/article/details/79694196" target="_blank" rel="noopener">萝是carrot夢是Dream. 树莓派安装配置TeamViewer实现外网远程控制. 2018. csdn.net</a></li><li>[7] <a href="https://www.jianshu.com/p/639c8d939643" target="_blank" rel="noopener">终可见. 树莓派 3B 搭建 Jupyter notebook. 2018. jianshu.com</a></li><li>[8] <a href="https://blog.csdn.net/q361949240/article/details/83179560" target="_blank" rel="noopener">齐志刚. 树莓派 3B Jupyter notebook 设置为后台服务. 2018. csdn.net</a></li><li>[9] <a href="https://blog.csdn.net/tju_cc/article/details/80024721" target="_blank" rel="noopener">Holy_C. 树莓派 miniconda3+opencv3.3+tensorflow1.7 踩坑总结. 2018. csdn.net</a></li><li>[10] <a href="https://www.jianshu.com/p/edaa744ea47d" target="_blank" rel="noopener">卖萌哥. Conda 的安装与使用. 2018. jiansu.com</a></li><li>[11] <a href="https://www.jianshu.com/p/ccad38dbb897" target="_blank" rel="noopener">Speculatecat. 解决 Raspbian Miniconda 无法安装最新 Python3.6. 2018. jianshu.com</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树莓派能做什么？关于此命题，最直观感受就是看看树莓派实验室整理的一些&lt;a href=&quot;http://shumeipai.nxez.com/what-raspi-used-for&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;案例&lt;/a&gt;，相信你心目中会有答案的。例如，打造一个家庭媒体中心 ( KODI )、配置无线路由器、搭建 BT 下载服务器、搭建代码托管服务器 ( SVN、GIt )、搭建网站服务器、搭建 Shadowsocks、用 HomeKit + Siri 声控家里电器等，即可把树莓派想象成嵌入式、微小型的服务器，这一过程就好比操作系统 ( Linux ) 赋予硬件生命，编程 ( Python、Java )、程序灌入灵魂，借助树莓派低能耗、移动便携性、GPIO 等特性，很多想法不是不可能，相信树莓派会给你创造更多的惊喜！&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://www.kofes.cn/categories/Technique/"/>
    
    
      <category term="树莓派" scheme="http://www.kofes.cn/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="Raspbian" scheme="http://www.kofes.cn/tags/Raspbian/"/>
    
      <category term="博客搭建" scheme="http://www.kofes.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
      <category term="服务器" scheme="http://www.kofes.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="数据科学" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
</feed>
