<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kofe</title>
  
  <subtitle>Reading / Project / Paper</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kofes.cn/"/>
  <updated>2018-07-26T12:51:28.420Z</updated>
  <id>http://www.kofes.cn/</id>
  
  <author>
    <name>Kofe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>彩蛋 -  MACOS VMware 安装 OpenWrt ( 从软路由到硬路由的过渡 )</title>
    <link href="http://www.kofes.cn/2018/07/Vmware-OpenWrt.html"/>
    <id>http://www.kofes.cn/2018/07/Vmware-OpenWrt.html</id>
    <published>2018-07-26T06:52:45.000Z</published>
    <updated>2018-07-26T12:51:28.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="固件信息"><a href="#固件信息" class="headerlink" title="固件信息"></a>固件信息</h2><ul><li>OpenWrt：<a href="https://openwrt.org/" target="_blank" rel="noopener">官方网站</a></li><li><p>版本信息：openwrt-15.05.1-x86-generic-combined-squashfs</p><blockquote><p>虚拟机上运行的，我们选择 x86 架构的即可。</p></blockquote></li><li><p>固件选择：当然，你需要对路由器刷固件，固件版本要配对你的设备 ( <a href="https://openwrt.org/toh/views/toh_fwdownload" target="_blank" rel="noopener">设备支持信息表单</a> )</p><blockquote><p>例如：网件 WNDR 4300，找到的固件为：<a href="http://downloads.lede-project.org/releases/17.01.4/targets/ar71xx/nand/lede-17.01.4-ar71xx-nand-wndr4300-ubi-factory.img" target="_blank" rel="noopener">lede-17.01.4-ar71xx-nand-wndr4300-ubi-factory.img</a></p></blockquote></li></ul><a id="more"></a><h2 id="更新进度"><a href="#更新进度" class="headerlink" title="更新进度"></a>更新进度</h2><ul><li>2018.07.25：完成初稿；</li><li>2018.07.26：安装 OpenWrt 系统，配置 MySQL、FTP 插件，并形成文档；</li></ul><h2 id="路由信息"><a href="#路由信息" class="headerlink" title="路由信息"></a>路由信息</h2><ul><li><p>本机 VMware 配置了两张虚拟网卡，暂且命名为：</p><ul><li>网络适配器 1 (MAC 地址)：<code>00:50:56:28:EF</code></li><li><p>网络适配器 2 (MAC 地址)：<code>00:50:56:3B:0E:CD</code></p><blockquote><p>MAC 地址可让我们判断 OpenWrt 中外网接口 <code>WAN</code> 和内网接口 <code>LAN</code> 口的映射情况。</p></blockquote></li></ul></li><li><p>在 OpenWrt 默认配置中，外网接口 WAN 对应于 Eth1，内网接口 LAN 对应于 Eth0，即：</p><ul><li>外网接口 WAN：<code>Eth1</code></li><li><p>内网接口 LAN：<code>Eth0</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 如何查看虚拟主机的网卡与外网、内外接口的关系：</span><br><span class="line">   </span><br><span class="line"><span class="meta">#</span> OpenWrt 下执行下述代码：</span><br><span class="line"><span class="meta">#</span> 查看网卡的具体信息，即可以查到虚拟机网卡 MAC 地址</span><br><span class="line">ifconfig | more</span><br><span class="line"><span class="meta">#</span> 查看网络配置信息，即可查看外网、内外接口 (Ethx) 与虚拟主机的网卡的绑定情况</span><br><span class="line">cat /etc/config/network</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在 OpenWrt 中，配置外网、内外接口 (Ethx) 信息：</p><blockquote><p>提示：使用 WAN 口的网卡桥接到宿主机的网卡即可访问外网。</p></blockquote>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 环路地址，不用配置</span><br><span class="line">config interface 'loopback'</span><br><span class="line">   option ifname 'lo'</span><br><span class="line">option ipaddr '127.0.0.1'</span><br><span class="line">option netmask '255.255.255.0'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 内网接口</span><br><span class="line">config interface 'lan'</span><br><span class="line">option ifname 'eth0'</span><br><span class="line">option type 'bridge'</span><br><span class="line">option proto 'static'</span><br><span class="line">option ipaddr '192.168.1.1'</span><br><span class="line">option netmask '255.255.255.0'</span><br><span class="line">option ip6assign '60'</span><br><span class="line">   </span><br><span class="line"><span class="meta">#</span> 外网接口</span><br><span class="line">config interface 'wan'</span><br><span class="line">option ifname 'eth1'</span><br><span class="line">option proto 'dhcp'</span><br><span class="line">   </span><br><span class="line"><span class="meta">#</span> 其他配置默认，不作修改</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>关于配置中的一些批注：</p></blockquote><ul><li>Note.01：配置完成后，记得重启下网络服务 <code>./etc/init.d/network restart</code> 。</li><li><p>Note.02：若需要让宿主机访问本 OpenWrt 系统，你可以配置 (关闭) 防火墙。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 让防火墙开机不自启</span><br><span class="line">./etc/init.d/firewall disable</span><br><span class="line"><span class="meta">#</span> 关闭防火墙服务</span><br><span class="line">./etc/init.d/firewall stop</span><br></pre></td></tr></table></figure></li></ul><ul><li>本机 OpenWrt 信息：<ul><li>IP：<code>192.168.0.x (192.168.0.161)</code> — 与宿主机在同一局域网就对了</li><li>Route.User：<code>root</code></li><li>Route.Password：<code>123321</code></li></ul></li></ul><h2 id="拓展功能"><a href="#拓展功能" class="headerlink" title="拓展功能"></a>拓展功能</h2><ul><li>关于插件的批注：<ul><li>默认情况，插件会安装在：<code>/etc/init.d/</code> 目录下；</li><li>其相应的配置文件放置在： <code>/etc/config/</code> 目录下。</li></ul></li></ul><h3 id="安装-FTP-服务"><a href="#安装-FTP-服务" class="headerlink" title="安装 FTP 服务"></a>安装 FTP 服务</h3><ul><li><p>快速引导：<a href="https://wiki.openwrt.org/doc/howto/ftp.overview" target="_blank" rel="noopener">官方指南</a></p><ul><li>可通过 Web 交互界面安装或者命令行安装 <code>VSFTPD</code>。</li><li>安装完成后，即可使用；<code>ftp://Your route IP adress</code>。</li><li><p>配置文件位于 <code>/etc/vsftpd.conf</code>，配置可参考：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">chown_uploads=YES       # 上传后更改文件所属权</span><br><span class="line">chown_username=root     # 上传后更改文件所属权</span><br><span class="line">ftp_username=nobody     # 定义匿名用户名</span><br><span class="line">anonymous_enable=YES            # 允许匿名用户访问</span><br><span class="line">anon_upload_enable=YES          # 允许匿名上传</span><br><span class="line">anon_mkdir_write_enable=YES     # 允许匿名创建目录</span><br><span class="line">anon_root=/mnt/anymous          # 匿名用户根目录</span><br><span class="line">anon_max_rate=512000            # 匿名用户限速</span><br><span class="line">local_enable=YES    # 允许本地用户登录 (必须)</span><br><span class="line">local_root=/mnt/ftp # 本地用户的默认访问路径 (必须)</span><br><span class="line">write_enable=YES    # 允许上传</span><br><span class="line">local_umask=022     # 允许上传</span><br><span class="line">check_shell=NO</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>命令操作细节如下：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 第一次使用 opkg 需更新资源</span><br><span class="line">opkg update</span><br><span class="line">opkg install vsftpd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> FTP 服务操作</span><br><span class="line">/etc/init.d/vsftpd start        # Start the service</span><br><span class="line">/etc/init.d/vsftpd stop         # Stop the service</span><br><span class="line">/etc/init.d/vsftpd restart      # Restart the service</span><br><span class="line">/etc/init.d/vsftpd reload       # Reload configuration files or restart if that fails</span><br><span class="line">/etc/init.d/vsftpd enable       # Enable service autostart)</span><br><span class="line">/etc/init.d/vsftpd disable      # Disable service autostart)</span><br><span class="line">   </span><br><span class="line"><span class="meta">#</span> 附：修改文件权限</span><br><span class="line">chown root /mnt/ftp</span><br><span class="line">chmod 666 /mnt/ftp</span><br></pre></td></tr></table></figure></li></ul><ul><li>当然，除了 FTP 服务外，还有 Samba 服务，具体配置可参考 [4] 。</li></ul><h3 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h3><ul><li><p>通过命令行安装：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 第一次使用 opkg 需更新资源</span><br><span class="line">opkg update</span><br><span class="line">opkg install mysql-server</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>设置数据库数据存储目录：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 配置 Mysql 数据库的存储目录</span><br><span class="line">cd /mnt</span><br><span class="line">mkdir -p /mysql/data /mysql/tmp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 当然也可把数据放到 U 盘或 SD 卡上</span><br><span class="line"><span class="meta">#</span> 详细教程可查看 USB 挂载相关教程，参考 [6]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>配置 MySql：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br><span class="line"><span class="meta">#</span> 找到 datadir 和 tmpdir 字段，并修改其值</span><br><span class="line">datadir = /mnt/mysql/data</span><br><span class="line">tmpdir = /mnt/mysql/tmp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 找到 bind-address，修改为 0.0.0.0，以允许远程访问</span><br><span class="line">bind-address = 0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>  记得保存再退出</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 初始化建库 ( Database )</span><br><span class="line">/usr/bin/mysql_install_db --force</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>启动 MySQL 数据库：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动 mysql 守护进程</span><br><span class="line">/etc/init.d/mysqld enable# 开启自启动</span><br><span class="line">/etc/init.d/mysqld start# 启动 MySQL 服务</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 当重新修改配置时，需要重启 Mysql 服务，可这样处理</span><br><span class="line"><span class="meta">#</span> killall mysqld</span><br><span class="line"><span class="meta">#</span> /etc/init.d/mysqld start</span><br><span class="line"><span class="meta">#</span> 或者重新加载配置信息</span><br><span class="line"><span class="meta">#</span> /etc/init.d/mysqld reload</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用 MySQL 数据库和修改账户密码：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 提示输入密码，进入即可数据库操作</span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 当然，刚配置的 MySQL 用户名账号密码不是还没有配置么？</span><br><span class="line"><span class="meta">#</span> 故我们需要以非授权的方式进入 MySQL 进行权限设置</span><br><span class="line">/etc/init.d/mysqld --skip-grant &amp;</span><br><span class="line">mysql -u root</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 注意：命名行里面的形式已经变成【mysql&gt;】提示符，即可继续下步操作</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示数据库，选择 mysql 数据库</span><br><span class="line">SHOW databases;</span><br><span class="line">USE mysql;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 修改账户连接权限：</span><br><span class="line">UPDATE user </span><br><span class="line">SET host = '%', password = PASSWORD("Your Password")</span><br><span class="line">WHERE user = 'root';</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> (非必要操作) 当你的数据库需要远程访问时，你还需要建立一个新用户</span><br><span class="line"><span class="meta">#</span> grant all privileges on *.* to  kofe@"%"</span><br><span class="line"><span class="meta">#</span> identified by "pwd123"</span><br><span class="line"><span class="meta">#</span> with grant option;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Grant 是授权命令</span><br><span class="line"><span class="meta">#</span> 其中 kofe 是我们连接用的用户名、pwd123 是连接密码</span><br><span class="line"><span class="meta">#</span> @ 后接的 “%” 通用符表示允许各 host 操作</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 清理数据库缓存</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 退出 mysql</span><br><span class="line">quit;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 重启 Mysql 服务</span><br><span class="line">/etc/init.d/mysqld restart</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 此时重新执行 mysql -u root -p</span><br><span class="line"><span class="meta">#</span> 输入你修改过后的密码能进入 【mysql&gt;】模式即成功。</span><br></pre></td></tr></table></figure></li><li><p>MySQL 数据库管理软件推荐： <a href="http://www.sequelpro.com/" target="_blank" rel="noopener">Sequel Pro</a> 或者 <a href="https://dbeaver.io/download/" target="_blank" rel="noopener">Dbeaver</a>。</p></li></ul><h3 id="安装-Python"><a href="#安装-Python" class="headerlink" title="安装 Python"></a>安装 Python</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://www.cnblogs.com/codeinsight/p/openwrt_vmware.html" target="_blank" rel="noopener">Code Insight. HowTo 虚拟机上尝试 OpenWrt 开源路由. cnblogs.com</a></li><li>[2] <a href="https://github.com/luoqeng/OpenWrt-on-VMware" target="_blank" rel="noopener">luoqeng. OpenWrt-on-VMware. github.com</a></li><li>[3] <a href="https://blog.csdn.net/whatday/article/details/78920494" target="_blank" rel="noopener">whatday. 路由、交换机等嵌入设备软件包管理 OPKG. csdn.net</a></li><li>[4] <a href="http://www.cnblogs.com/double-win/p/3848797.html" target="_blank" rel="noopener">Double WIn. Samba 服务 &amp; vsFTP 服务. cnblogs.com</a></li><li>[5] <a href="http://www.cnblogs.com/double-win/p/3866189.html" target="_blank" rel="noopener">Double Win. MySQL配置. cnblogs.com</a></li><li>[6] <a href="http://www.cnblogs.com/double-win/p/3841801.html" target="_blank" rel="noopener">Double Win. USB挂载 &amp; U盘启动. cnblogs.com</a></li><li>[100] <a href="http://www.cnblogs.com/double-win/p/3888399.html" target="_blank" rel="noopener">Double Win. Openwrt 项目开发笔记. cnblogs.com</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;固件信息&quot;&gt;&lt;a href=&quot;#固件信息&quot; class=&quot;headerlink&quot; title=&quot;固件信息&quot;&gt;&lt;/a&gt;固件信息&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;OpenWrt：&lt;a href=&quot;https://openwrt.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;版本信息：openwrt-15.05.1-x86-generic-combined-squashfs&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟机上运行的，我们选择 x86 架构的即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;固件选择：当然，你需要对路由器刷固件，固件版本要配对你的设备 ( &lt;a href=&quot;https://openwrt.org/toh/views/toh_fwdownload&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设备支持信息表单&lt;/a&gt; )&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如：网件 WNDR 4300，找到的固件为：&lt;a href=&quot;http://downloads.lede-project.org/releases/17.01.4/targets/ar71xx/nand/lede-17.01.4-ar71xx-nand-wndr4300-ubi-factory.img&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lede-17.01.4-ar71xx-nand-wndr4300-ubi-factory.img&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://www.kofes.cn/categories/Technique/"/>
    
    
      <category term="MAC" scheme="http://www.kofes.cn/tags/MAC/"/>
    
      <category term="OpenWrt" scheme="http://www.kofes.cn/tags/OpenWrt/"/>
    
      <category term="Vmware" scheme="http://www.kofes.cn/tags/Vmware/"/>
    
      <category term="mysql" scheme="http://www.kofes.cn/tags/mysql/"/>
    
      <category term="python" scheme="http://www.kofes.cn/tags/python/"/>
    
      <category term="路由器" scheme="http://www.kofes.cn/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>框架 - Java EE 之 SSH 框架配置与使用</title>
    <link href="http://www.kofes.cn/2018/07/J2EE-SSH-SSI-1.html"/>
    <id>http://www.kofes.cn/2018/07/J2EE-SSH-SSI-1.html</id>
    <published>2018-07-24T06:48:22.000Z</published>
    <updated>2018-07-25T01:00:46.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>本文章主要围绕 J2EE 中 SSH ( Spring、Struts、Hibernate ) 框架的配置以及使用问题展开学习的，最终目的是输出可复用的版本，以供后续的项目复用。当然，学习和配置的过程难免有不恰当或错误之处，还望朋友指出、斧正。</p><h2 id="更新进度"><a href="#更新进度" class="headerlink" title="更新进度"></a>更新进度</h2><ul><li>2018.07.17：完成初稿，IDE 搭建、框架初识章节；</li><li>2018.07.18：更新 SSH 框架 Hibernate 部分内容；</li></ul><a id="more"></a><h2 id="IDE-搭建"><a href="#IDE-搭建" class="headerlink" title="IDE 搭建"></a>IDE 搭建</h2><ul><li>Step.01：安装 JDK；</li><li>Step.02：安装 IDE ( <code>IntelliJ Idea</code> / Eclipse / MyEclipse )；</li><li>Step.03：配置 Tomcat 环境；</li><li>Step.04：配置 MySQL / SQL Server 数据库；<ul><li>命名规范：数据库 <code>db_dbname</code>；数据表 <code>t_tablename</code>；属性 <code>attribute</code></li></ul></li><li>Step.05：以 IntelliJ Idea IDE 为参考搭建框架，参考 [1] - [3] 中的方法；<ul><li>Note.01：在具体的 Module 下 Add Framework Support 的 Jar 包，会随着 Module 的删除而删除。故再次创建 SSH 框架时，需要引用相同的 Jar 包，故在 Libraries 中加载相关 Jar 包切记要重新下载 ( 错误的示范：每次都默认勾选了使用原先的 library，但是原先的 Jar 包已经删除  )。</li><li>Note.02：当然，推荐 Maven 构建项目，即 Maven 本身是添加依赖即可实现导入 Jar 包，以避免走同样的弯路。</li></ul></li></ul><h2 id="框架初识"><a href="#框架初识" class="headerlink" title="框架初识"></a>框架初识</h2><h3 id="SSH-框架"><a href="#SSH-框架" class="headerlink" title="SSH 框架"></a>SSH 框架</h3><p>SSH 框架：<a href="http://spring.io/" target="_blank" rel="noopener">Spring</a>、<a href="http://struts.apache.org/" target="_blank" rel="noopener">Struts2</a>、<a href="http://hibernate.org/" target="_blank" rel="noopener">Hibernate</a> </p><p>集成 SSH 框架的系统从职责上分为四层：<code>表示层</code>、<code>业务逻辑层</code>、<code>数据持久层</code> 和 <code>域模块层</code>，以帮助开发人员在短期内搭建结构清晰、可复用性好、维护方便的 Web 应用程序。其中使用 <code>Struts</code> 作为 <code>系统的整体基础架构</code>，负责 MVC 的分离，在 Struts 框架的模型部分，控制业务跳转，利用 <code>Hibernate</code> 框架对 <code>持久层</code> 提供支持，<code>Spring</code> 做管理，<code>管理 Struts 和 Hibernate</code>。</p><p>具体做法是：用面向对象的分析方法根据需求提出一些模型，将这些模型实现为基本的Java对象，然后编写基本的 DAO (Data Access Objects) 接口，并给出 Hibernate 的 DAO 实现，采用 Hibernate 架构实现的 DAO 类来实现 Java 类与数据库之间的转换和访问，最后由 Spring 做管理，管理 Struts 和 Hibernate。</p><h4 id="Struts"><a href="#Struts" class="headerlink" title="Struts"></a>Struts</h4><p>主要是用来做 <code>表示层</code>，也就所谓的 <code>界面</code>，和用户直接打交道，用来处理用户的请求和请求后返回给用户的模型数据。 Struts 对 Model，View 和 Controller 都提供了对应的组件。</p><h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><p><code>业务逻辑层</code>，是一个轻量级的控制反转 (IoC) 和面向切面 (AOP) 的容器框架。</p><h4 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h4><p><code>数据持久层</code>，Hibernate 是一个开放源码的 <code>ORM</code> 持久层框架。简单的说，Hibernate 只是一个将持久化类与数据库表相映射的工具，<code>每个持久化类实例均对应于数据库表中的一个数据行而已</code>。用户只需直接使用面向对象的方法操作此持久化类实例，即可完成对数据库表数据的插入、删除、修改、读取等操作。</p><h5 id="Hibernate-配置"><a href="#Hibernate-配置" class="headerlink" title="Hibernate 配置"></a>Hibernate 配置</h5><ul><li><p>使用配置文件将映射关系对应起来；</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置文件命名规范：*.hbm.xml --&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC </span></span><br><span class="line"><span class="meta">    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     | 配置类和表相对应：Class 标签</span></span><br><span class="line"><span class="comment">     | name 属性：实体类全路径</span></span><br><span class="line"><span class="comment">     | table 属性：数据库表名称</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"cn.entity.User"</span> <span class="attr">table</span>=<span class="string">"t_user"</span>&gt;</span>          </span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">         | 配置实体类 ID 与表 ID 对应：ID 标签</span></span><br><span class="line"><span class="comment">         | Hibernate 要求实体类有一个属性唯一值，且要求表有字段作为唯一值</span></span><br><span class="line"><span class="comment">         | name 属性：实体类的 id 属性名称</span></span><br><span class="line"><span class="comment">         | column 属性：生产的表字段名称</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置数据库表 id 增长策略：Class 标签</span></span><br><span class="line"><span class="comment">             | 属性有：increment、hilo、squence、identity、native、uuid、guid 等。</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                   </span><br><span class="line">        <span class="comment">&lt;!-- 配置其他属性和表字段对应：Property 标签 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 若使用的是 SQL Server 数据库系统，Property 映射对的顺序要和数据库中列 (属性) 的顺序相对应 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"string"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"int"</span> /&gt;</span>       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>关于映射配置的一些批注：</p></blockquote><ul><li>Note.01：就映射配置来说，这里千万要记住，若访问的是 SQL Server 数据库系统，则 <strong><property> 映射对的顺序要和数据库中列 (属性) 的顺序相对应</property></strong>。( 其他数据库系统没有出现此类问题，鉴于阅读与编程的规范，则不管使用哪种数据库系统驱动，都以此种方式编辑 Property 映射对 )</li><li>Note.02：关于配置中实体类的主键生成策略有多种形式，详细见参考 [4]。</li><li><p>Note.03：User 实体类对象的状态：</p><ul><li><code>瞬时态</code>：对象没有 ID 值，且其与 Session 没有关联。</li><li><code>持久态</code>：对象有 ID 值，且其与 Session 有关联。</li><li><p><code>托管态</code>：对象有 ID 值，但其与 Session 没有关联。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下述代码只列举了细节不同的部分，其他细节见源代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">           </span><br><span class="line"><span class="comment">// 瞬时态：即插入元组</span></span><br><span class="line">user.setUserName(<span class="string">"Sample"</span>);</span><br><span class="line">user.setAge(<span class="number">25</span>);</span><br><span class="line">session.saveOrUpdate(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 托管态：对数据表中具体 ID 的元组进行数据修改，即更新元祖</span></span><br><span class="line">user.setUid(attr_id);</span><br><span class="line">user.setUserName(<span class="string">"Sample"</span>);</span><br><span class="line">user.setAge(<span class="number">25</span>);</span><br><span class="line">session.saveOrUpdate(user);</span><br><span class="line"><span class="comment">// session.save(user); // 注意：此操作为新增元组，但不是全部属性都修改，会引入空值</span></span><br><span class="line">           </span><br><span class="line"><span class="comment">// 持久态：对数据表中具体 ID 的元组进行数据修改，即更新元祖</span></span><br><span class="line">user = session.get(User.class, attr_id);</span><br><span class="line">user.setUserName(<span class="string">"Sample"</span>);</span><br><span class="line">user.setAge(<span class="number">25</span>);</span><br><span class="line">session.saveOrUpdate(user);</span><br><span class="line">           </span><br><span class="line"><span class="comment">// 启示：从持久态和托管态态的实验结果可知，修改元组，先查再改，防止空值。</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建 Hibernate 的核心配置文件；</p><p>  核心配置文件格式是 XML，且核心配置文件名称和位置是 <code>固定的</code> ( Src 根目录下，且名称为 <code>hibernate.cfg.xml</code> )。Hibernate 操作过程中，仅加载核心配置文件。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置文件命名规范：hibernate.cfg.xml --&gt;</span></span><br><span class="line">               </span><br><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">    "-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- (必填) 配置数据库信息：从 hibernate.property 中获取 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span> /&gt;</span></span><br><span class="line">           </span><br><span class="line">        <span class="comment">&lt;!-- SQL Server 数据库管理系统的 Driver </span></span><br><span class="line"><span class="comment">        &lt;property name="hibernate.connection.driver_class"&gt;com.microsoft.sqlserver.jdbc.SQLServerDriver&lt;/property&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name="hibernate.connection.url"&gt;</span></span><br><span class="line"><span class="comment">            jdbc:sqlserver://192.168.0.133:1433;DatabaseName=testDB</span></span><br><span class="line"><span class="comment">        &lt;/property&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">           </span><br><span class="line">        <span class="comment">&lt;!-- MySQL 数据库管理系统的 Driver --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span></span><br><span class="line">            jdbc:mysql://192.168.0.163:3306/testDB?serverTimezone=UTC</span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">           </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>sa<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>pztech753<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                   </span><br><span class="line">        <span class="comment">&lt;!-- (可选) 配置 Hibernate 信息：从 hibernate.property 中获取 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 操作数据库时，向控制台输出 SQL 语句 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 操作数据库时，向控制台输出格式化的 SQL 语句 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Hibernate 配置自动建表：Update，有表更新没表建立 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> =<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">         | 例如，实现分页功能：</span></span><br><span class="line"><span class="comment">         | MySQL 里面使用 LIMIT 关键字，Oracle 中使用 ROWNUM 关键字</span></span><br><span class="line"><span class="comment">         | 让 Hibernate 识别不同数据库中特有的语句</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                   </span><br><span class="line">        <span class="comment">&lt;!-- (必填) 把映射文件放到核心配置文件中 ( 填 Src 之后的路径 ) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"cn/entity/User.hbm.xml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>关于核心配置的一些批注：</p><p>面对不同的数据库管理系统，对应的配置属性也存在差异，详细见参考 [5]。</p></blockquote><ul><li><p>通过 Session 保存实体类数据到数据库表中；</p><p>  简单演示，详细见下一章节：<a href="#Hibernate-使用">Hibernate 使用</a></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUsername(<span class="string">"Lucy"</span>);</span><br><span class="line">user.setAge(<span class="number">25</span>);</span><br><span class="line">Session.save(user);</span><br></pre></td></tr></table></figure></li></ul><h5 id="Hibernate-使用"><a href="#Hibernate-使用" class="headerlink" title="Hibernate 使用"></a>Hibernate 使用</h5><ul><li><p>以下代码为 Hibernate 最基本的使用方法，后续将通过优化 Configuration，以及规范事务来优化 Hibernate。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step.01：加载 Hibernate 核心配置文件 hibernate.cfg.xml</span></span><br><span class="line">Configuration cfg = <span class="keyword">new</span> Configuration();</span><br><span class="line">cfg.configure();</span><br><span class="line">   </span><br><span class="line"><span class="comment">// Step.02：创建 SessionFactory 对象；</span></span><br><span class="line"><span class="comment">// 在此过程中，根据映射关系在数据库中把表创建起来</span></span><br><span class="line">SessionFactory sessionFactory = cfg.buildSessionFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step.03：使用 SessionFactory 创建 Session 对象；</span></span><br><span class="line">Session session = sessionFactory.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step.04：手动开始事务；</span></span><br><span class="line">Transaction trans = session.beginTransaction();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step.05：写具体逻辑，例如：增删改查；</span></span><br><span class="line"><span class="comment">// 例如添加操作 ( 不操作数据表，而操作实体类 )</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUsername(<span class="string">"Lucy"</span>);</span><br><span class="line">user.setAge(<span class="number">25</span>);</span><br><span class="line">session.save(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step.06：提交事务；</span></span><br><span class="line">trans.commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step.07：关闭资源；</span></span><br><span class="line">session.close();</span><br><span class="line">sessionFactory.close();</span><br></pre></td></tr></table></figure></li><li><p>Configuration</p><ul><li>到 Src 目录下加载核心配置文件 <code>hibernate.cfg.xml</code>；</li></ul></li><li><p>SessionFactory</p><ul><li>根据核心配置文件中数据库配置、映射配置，且根据映射关系，到数据库中把表创建起来。</li><li><p>创建 SessionFactory 过程中，特别消耗资源，故应该采取优化措施：</p><p>在 Hibernate 操作中，建议一个项目创建一个 SessionFacotry 对象，以静态的工具类形式封装使用 ( <a href="https://www.kofes.cn/2018/01/Design-Pattern-Based-on-Android.html#单例模式的其他实现方式">单例模式中的懒汉模式</a>，用时才初始化，即惰性处理机制 )。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateUtils</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Configuration cfg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SessionFactory sessionFactory = <span class="keyword">null</span>;            </span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    cfg = <span class="keyword">new</span> Configuration();</span><br><span class="line">    cfg.configure();</span><br><span class="line">    sessionFactory = cfg.buildSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SessionFactory <span class="title">getSessionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sessionFactory();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Session</p><ul><li>类似 Jdbc 中的 Connection，可调用 Session 中的不同方法实现 <code>增、删、改、查</code> 操作。 <ul><li>增加：save()；</li><li>修改：update()；</li><li>删除：delete()；</li><li>查询：get()；</li></ul></li><li><p>Session 为单线程对象，即不能共用，仅自己使用。</p><ul><li><p>Hibernate 已实现本地线程与 Session 的绑定：在 Hibernate 的核心配置文件中，再调用 sessionFactory 的方法得到。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 HibernateUtils 静态工具类中追加静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回与本地线程绑定的 Session</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSessionObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sessionFactory.getCurrentSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">/* 在其他类中调用该方法 */</span></span><br><span class="line">Session session = HibernateUtils.getSessionObject();</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>Transaction</p><ul><li>事务概念；</li><li><p>事务特性：原子性、一致性、隔离性、持久性；</p><blockquote><p>隔离性：不考虑隔离性会产生的问题，如脏读、不可重复读和虚读。当然，可以设置隔离的级别来解决问题。</p></blockquote></li><li><p>Hibernate 使用 Transaction 创建事务对象；</p></li><li><p>事务的 commit() 与 rollback() 方法 ( <code>规范用法</code> )；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SessionFactory sessionFactory = <span class="keyword">null</span>;</span><br><span class="line">Session session = <span class="keyword">null</span>;</span><br><span class="line">Transaction trans = nu</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sessionFactory = HibernateUtils.getSessionFactory()</span><br><span class="line">    session = sessionFactory.openSession();</span><br><span class="line">    <span class="comment">// 开启事务</span></span><br><span class="line">    trans = session.beginTransaction();</span><br><span class="line">           </span><br><span class="line">    <span class="comment">// 人为制造异常，被除数不能为零</span></span><br><span class="line">    User user = <span class="function">ne0w <span class="title">User</span><span class="params">()</span></span>;</span><br><span class="line">    user.setAge(<span class="number">50</span>/<span class="number">0</span>);</span><br><span class="line">    session.save(user);</span><br><span class="line">           </span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    trans.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">    <span class="comment">// 发生异常</span></span><br><span class="line">    trans.rollback();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    session.close();</span><br><span class="line">    sessionFactory.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="Hibernate-优化"><a href="#Hibernate-优化" class="headerlink" title="Hibernate 优化"></a>Hibernate 优化</h5><h6 id="Hibernate-缓存机制"><a href="#Hibernate-缓存机制" class="headerlink" title="Hibernate 缓存机制"></a>Hibernate 缓存机制</h6><ul><li>一级缓存：默认是打开的，其使用的范围为 Session 创建到关闭的范围，且存储数据必须为持久态数据。</li><li><p>一级缓存的特性：持久态的数据会自动更新数据库 ( 不用 session.update(user)、session.save(user) )，过程细节如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get() 操作后，将返回持久态对象 user 存于一级缓存中，</span></span><br><span class="line"><span class="comment">// 及存一份到缓存中的快照区 (副本)。</span></span><br><span class="line">user = session.get(User.class, attr_id);</span><br><span class="line"><span class="comment">// setXXX() 操作，同时修改持久态对象的值和一级缓存中的内容。</span></span><br><span class="line">user.setUserName(<span class="string">"Sample"</span>);</span><br><span class="line"><span class="comment">// 当提交事务时，会比较一级缓存和快照区，</span></span><br><span class="line"><span class="comment">// 若不相同，会触发更新数据库操作。</span></span><br><span class="line">trans.commit();</span><br></pre></td></tr></table></figure></li></ul><ul><li>二级缓存 (替代技术：<code>redis</code> )：默认关闭，SessionFactroy 的使用范围。</li></ul><h5 id="Hibernate-API"><a href="#Hibernate-API" class="headerlink" title="Hibernate API"></a>Hibernate API</h5><h6 id="Query-对象"><a href="#Query-对象" class="headerlink" title="Query 对象"></a>Query 对象</h6><ul><li><p>使用 Query 对象，不需要写 SQL 语句，以 HQL 替代。</p><blockquote><p>HQL：Hibernate Query Language，有别于 SQL 语句，即：SQL 操作表和表字段，而 HQL 操作实体类和属性。</p></blockquote></li><li><p>Query 对象的使用：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Query 对象</span></span><br><span class="line">Query query = session.createQuery(<span class="string">"from User"</span>);</span><br><span class="line"><span class="comment">// 调用 query 对象的方法得到结果</span></span><br><span class="line">List&lt;User&gt; list = query.list();</span><br></pre></td></tr></table></figure></li></ul><h6 id="Criteria-对象"><a href="#Criteria-对象" class="headerlink" title="Criteria 对象"></a>Criteria 对象</h6><ul><li><p>Ceiteria 对象的使用：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Criteria 对象　</span></span><br><span class="line">Criteria criteria = session.createCriteria(User.class);</span><br><span class="line"><span class="comment">// 调用 criteria 对象的方法得到结果</span></span><br><span class="line">List&lt;User&gt; list = criteria.list();</span><br></pre></td></tr></table></figure></li></ul><h6 id="SQLQuery-对象"><a href="#SQLQuery-对象" class="headerlink" title="SQLQuery 对象"></a>SQLQuery 对象</h6><ul><li><p>SQLQuery 对象的使用：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 SQLQuery 对象</span></span><br><span class="line">String sql = <span class="string">"SELECT * FROM t_user t WHERE t.username= ? AND t.age = ?"</span>;</span><br><span class="line">SQLQuery sqlQuery = session.createSQLQuery(sql)</span><br><span class="line">    .setParameter(<span class="number">0</span>, <span class="string">"ABC"</span>).setParameter(<span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">   </span><br><span class="line"><span class="comment">// Case.01. 以数组形式接收结果</span></span><br><span class="line"><span class="comment">// List&lt;Object []&gt; list = sqlQuery.list();</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// Case.02. 返回目标的 User 对象 </span></span><br><span class="line">sqlQuery.addEntity(User.class);</span><br><span class="line">List&lt;User&gt; list = sqlQuery.list();</span><br></pre></td></tr></table></figure></li></ul><h6 id="Hibernate-实现多表操作"><a href="#Hibernate-实现多表操作" class="headerlink" title="Hibernate 实现多表操作"></a>Hibernate 实现多表操作</h6><ul><li>数据库的多表查询<ul><li>外键<ul><li>指定外键关键字： Foreign Key(列名)</li><li>引用外键关键字： References &lt;主表名&gt;(主表主键)</li></ul></li><li>关系<ul><li>一对一</li><li>一对多</li><li>多对多</li></ul></li></ul></li><li><p>一对多映射配置：<code>实体类配置</code></p><ul><li>创建两个实体类，例如：公司和客户 ( 公司是一，客户是多 )；</li><li><p>让两个实体类间互相表示；  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 在客户实体类中表示所属公司，一个客户只属于一个公司</span></span><br><span class="line">    <span class="keyword">private</span> Firm firm;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirm</span><span class="params">(Firm firm)</span> </span>&#123; <span class="keyword">this</span>.frim = firm; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Firm <span class="title">getFirm</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> firm; &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 公司实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Firm</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Set 集合：无序，元素不可重复</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Customer&gt; customerSet = <span class="keyword">new</span> HanSet&lt;Customer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Customer&gt; <span class="title">getCustomerSet</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> customerSet; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>一对多映射配置：<code>XML 配置文件</code>，一个实体类对应一个映射文件，除了映射文件的基本配置之外，且要在映射文件中配置一对多的关系。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- firm.bhm.xml </span></span><br><span class="line"><span class="comment"> | 在公司映射文件 firm.bhm.xml 中，表示公司的所有客户</span></span><br><span class="line"><span class="comment"> | Name 属性：属性值写公司实体类里表示客户 Set 集合的对象名称</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"cn.kofes.entity.Firm"</span> <span class="attr">table</span>=<span class="string">"t_firm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"customerSet"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">         | 一对多关系建表，有外键</span></span><br><span class="line"><span class="comment">         | Hibernate 机制，双向维护外键，即在一和多方都配置外键</span></span><br><span class="line"><span class="comment">         | Column 属性：属性值为外键的名称，名称可自定义</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"f_fid"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 公司的所有客户，即 Class 里写客户实体类全路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"cn.entity.Customer"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- customer.bhm.xml</span></span><br><span class="line"><span class="comment"> | 在客户映射文件 customer.bhm.xml 中，表示客户所属公司</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"cn.kofes.entity.Customer"</span> <span class="attr">table</span>=<span class="string">"t_customer"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     | Name 属性：客户实体类中使用 firm 对象表示</span></span><br><span class="line"><span class="comment">     | Class 属性：Firm 实体类的全路径</span></span><br><span class="line"><span class="comment">     | Column 属性：外键名称，名称可自定义</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"firm"</span> <span class="attr">class</span>=<span class="string">"cn.entity.Firm"</span> <span class="attr">column</span>=<span class="string">"c_fid"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>一对多级联的操作实现</p><blockquote><p>在原生数据库中，对包含外键的元组直接删除，是无法成功执行的。正确操作方式为：先删除外键约束，再删除对应元组。但在 Hibernate 中，不用考虑此类问题，因为内置封装了相关功能组件。</p></blockquote><ul><li><p>一对多级联的保存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step.01.建立公司对象和客户对象的关系</span></span><br><span class="line"> Firm firm = <span class="keyword">new</span> Firm();</span><br><span class="line">Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line"><span class="comment">// Step.02.把客户对象放到公司对象的 Set 集合里</span></span><br><span class="line">firm.getCustomerSet().add(customer);</span><br><span class="line"><span class="comment">// Step.03.把公司对象放到客户对象里</span></span><br><span class="line">customer.setFirm(firm);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 级联保存：即一方和多方都需配置数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">session.save(customer);</span><br><span class="line">session.save(firm);</span><br></pre></td></tr></table></figure></li><li><p>一对多级联的删除：在一方的对象即公司对象，修改其配置文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">&lt;!-- firm.bhm.xml </span></span><br><span class="line"><span class="comment">&lt;class name="cn.kofes.entity.Firm" table="t_firm"&gt;</span></span><br><span class="line"><span class="comment">    &lt;set name="customerSet" cascade="delete"&gt;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &lt;/set&gt;</span></span><br><span class="line"><span class="comment">&lt;/class&gt;</span></span><br></pre></td></tr></table></figure><p>最后，直接在代码中进行删除即可。</p></li><li><p>优化步骤之 <code>Inverse 属性</code></p><p>  因为 Hibernate 是双向维护外键，在公司和客户里面都需维护外键 ( 从级联删除的执行过程中可体验出来 )。故我们可以设置其中的一方 <code>放弃</code> 维护外键，以优化性能。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- firm.bhm.xml </span></span><br><span class="line"><span class="comment">&lt;class name="cn.kofes.entity.Firm" table="t_firm"&gt;</span></span><br><span class="line"><span class="comment">    &lt;!--</span></span><br><span class="line"><span class="comment">     | Inverse 属性</span></span><br><span class="line"><span class="comment">     | Flase，表示不放弃关系维护</span></span><br><span class="line"><span class="comment">     | True，表示放弃关系维护</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"customerSet"</span> <span class="attr">cascade</span>=<span class="string">"delete"</span> <span class="attr">inverse</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="SSI-框架"><a href="#SSI-框架" class="headerlink" title="SSI 框架"></a>SSI 框架</h3><p>SSI 框架：Struts、Spring、iBatis / MyBatis<br>Java SSI 为 Struts、Spring 和 Ibatis 的一个集成框架，也是目前较流行的一种Web应用程序开源框架。</p><blockquote><p><a href="http://blog.mybatis.org/" target="_blank" rel="noopener">Mybatis</a>：持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs (Plain Old Java Objects，普通的 Java对象 ) 映射成数据库中的记录。</p></blockquote><h3 id="ORM-O-R-Mapping-框架"><a href="#ORM-O-R-Mapping-框架" class="headerlink" title="ORM (O/R Mapping) 框架"></a>ORM (O/R Mapping) 框架</h3><ul><li>对象关系映射（Object Relational Mapping，简称ORM）是通过使用描述对象和数据库之间映射的 <code>元数据</code>，将面向对象语言程序中的 <code>对象</code> 自动 <code>持久化</code> 到 <code>关系数据库</code> 中。本质上就是将数据从一种形式转换到另外一种形式。 </li><li>让 <code>实体类</code> 和 <code>数据库表</code> 进行一一对应关系 (映射关系)，<code>实体类属性</code> 和 <code>表里面的字段</code> 对应。操作表对应实体类对象，而不需操作数据库表。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] <a href="https://blog.csdn.net/weixin_37852133/article/details/62416263" target="_blank" rel="noopener"> 笨笨CEO. 利用 IntelliJ Idea 搭建 SSH 框架. csdn.net</a></li><li>[2] <a href="http://blog.lunhui.ren/archives/225" target="_blank" rel="noopener">刻下岁月. IntelliJ IDEA 2016.1.2 + Spring + Struts2 + Hibernate ( SSH ). lunhui.ren</a> </li><li>[3] <a href="https://www.cnblogs.com/xieyupeng/p/7108141.html" target="_blank" rel="noopener">kent. JavaEE SSH 三大框架整合 ( Spring + Struts2 + Hibernate ). cnblogs.com</a></li><li>[4] <a href="https://www.cnblogs.com/hoobey/p/5508992.html" target="_blank" rel="noopener">Starskyhu. Hibernate 各种主键生成策略与配置详解. cnblogs.cn</a></li><li>[5] <a href="https://blog.csdn.net/chentiefeng521/article/details/58775415" target="_blank" rel="noopener">陈铁锋. Hibernate 连接三种数据库的配置 ( SQL Server、Oracle、MySQL ). csdn.net</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;本文章主要围绕 J2EE 中 SSH ( Spring、Struts、Hibernate ) 框架的配置以及使用问题展开学习的，最终目的是输出可复用的版本，以供后续的项目复用。当然，学习和配置的过程难免有不恰当或错误之处，还望朋友指出、斧正。&lt;/p&gt;
&lt;h2 id=&quot;更新进度&quot;&gt;&lt;a href=&quot;#更新进度&quot; class=&quot;headerlink&quot; title=&quot;更新进度&quot;&gt;&lt;/a&gt;更新进度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;2018.07.17：完成初稿，IDE 搭建、框架初识章节；&lt;/li&gt;
&lt;li&gt;2018.07.18：更新 SSH 框架 Hibernate 部分内容；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Project" scheme="http://www.kofes.cn/categories/Project/"/>
    
    
      <category term="J2EE" scheme="http://www.kofes.cn/tags/J2EE/"/>
    
      <category term="JSP" scheme="http://www.kofes.cn/tags/JSP/"/>
    
      <category term="SSH" scheme="http://www.kofes.cn/tags/SSH/"/>
    
      <category term="Hibernate" scheme="http://www.kofes.cn/tags/Hibernate/"/>
    
      <category term="Spring" scheme="http://www.kofes.cn/tags/Spring/"/>
    
      <category term="Struts" scheme="http://www.kofes.cn/tags/Struts/"/>
    
  </entry>
  
  <entry>
    <title>论文 - 从商用车队的 GPS 数据中归类车辆停留意图信息</title>
    <link href="http://www.kofes.cn/2018/06/Stop-purpose-classification-from-GPS-data-of-commercial-vehicle-fleets.html"/>
    <id>http://www.kofes.cn/2018/06/Stop-purpose-classification-from-GPS-data-of-commercial-vehicle-fleets.html</id>
    <published>2018-06-11T16:58:25.000Z</published>
    <updated>2018-07-08T09:09:15.693Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p>原文：Stop purpose classification from GPS data of commercial vehicle fleets<br>作者：Sarti L, Bravi L, Sambo F.<br>来源：Data Mining Workshops, 2017 IEEE International Conference on. IEEE, 2017: 280-287.  </p></div><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>从原始 GPS (全球定位系统) 数据中提取 <code>汽车停靠意图数据</code> 是大多数位置感知应用程序中的关键任务，且随着从移动设备收集 GPS 数据的不断增长，这项任务变得越来越有趣。近期很多研究都集中在行人 (手机) 数据上 (可理解为红海市场)，而商用车领域几乎没有探索 (蓝海市场)。</p><p>在本论文中，针对车辆 GPS 数据的汽车停靠意图的 <code>识别</code> 和 <code>分类</code> 问题 (利用来自不同行业的商业车队的大型异构数据集)。按照意图分类，旨在把汽车停靠点分为：<code>工作相关</code> 和 <code>非工作相关</code>，以挖掘相关商业价值。</p><p>且还对每个汽车停靠点计算一组含 100 个不同特征的集合，特征可分为四个主要类别：<code>汽车停靠点特征</code>，<code>兴趣点特征</code>，<code>汽车停靠点集群特征</code> 和 <code>序列特征</code>。并通过随机森林分类模型，评估四组特征中每个特征对停靠点的相对重要性，以处理不同类型的问题。</p><p>实验结果表明，本论文的方法显着地超越了现有商业车辆背景下用于汽车停靠意图的分类模型。</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>在过去的十年中，GPS 设备的巨大推广，使得人们越发关注 <code>数据挖掘算法</code> 在 <code>时空数据</code> (GPS 产生的数据) 中的应用。而许多实际应用需要使用关于用户行为和地理位置的语义信息。例如，下述的两个实例：</p><ul><li>基于用户的历史位置以衡量用户之间的相似度 $^{[1]}$；</li><li>基于位置的兴趣地点推荐系统 $^{[2]}$。</li></ul><p>语义标记 GPS 数据，目标旨在 <code>识别</code> 和 <code>归类</code> GPS 沿途轨迹上的位置信息，即具体工作有 <code>语义位置的侦察</code> 和 <code>汽车停靠或出游的意图识别</code>。尽管上述问题不是同一类型的问题，但却是强相关的。例如，对多个用户而言具有相同意图的共同定位点，可能是语义上相关联的地方，因为知道某个地方的语义对分类每个汽车停靠点意图有很大的帮助。</p><p>通常，对于上述 <code>识别</code> 和 <code>归类</code> 问题的解决方法分两个阶段执行：</p><ul><li><p><code>侦查兴趣地点</code>：通常以非监督的方式实现位置侦查 $^{[3,4]}$，而作者提出了基于 <code>DBSCAN</code> $^{[5\,or\,6]}$ 的修改版本的聚类算法，即利用层次聚类从汽车停靠位置中提取访问点。</p><blockquote><p>当要处理非常大的数据集时需要考虑计算性能的问题，可参考其他论文中的扩展方法，例如对地点坐标进行哈希散列法 $^{[7,8]}$。</p></blockquote></li><li><p><code>对侦查到的地点分类</code>：对有关地点或汽车停靠点进行分类，可以在文献中找到两种主要方法：</p><ul><li>基于规则的系统 $^{[9,10]}$，其主要依赖于活动的位置、土地利用的数据以及机器学习方法，即活动本身提取特征；</li><li><p>利用 SVM 分类器来区分标识位置内的活动停靠点和非活动停靠点。分类器 (SVM，随机森林或逻辑回归) 利用时间和空间特征 $^{[6]}$，以及隐马尔可夫模型 (HMM) 利用时序特征把这些汽车停靠点分类为预定义类型。</p><blockquote><p>1) SVM 提取三个主要特征：停车驻留时间，每个汽车停靠地段周围的点到质心的平均距离。<br>2) 地点的语义分类是基于GPS数据和卫星图像的组合而定的 $^{[8]}$。  </p></blockquote></li></ul></li></ul><p>最后说明，本论文解决了与参考文献 [7] 的同样问题，即利用四个不同的特征集，使用一个随机森林分类器，对商业车队的汽车停靠意图数据进行分类。且本文的主要贡献如下：</p><ul><li>描述了一种方法，即从 GPS Pings (GPS 定位仪) 中提取汽车停靠点信息，并从工作状态停车点一览表 (已知的地点信息) 中給它们分配地面实况标签 (贴标签);</li><li>基于带标签的数据集，建立了一个模型，可以自动分类汽车停靠点，即工作状态和非工作状态的停靠点;</li><li>提供了严格评估的多类型特征集，便于我们处理不同问题，其中包括：<ul><li>汽车停靠点特征 (Stop-wise features，SWF)；</li><li>兴趣点特征 (Points of interest features，POIF)；</li><li>停靠点集群特征 (Stop Cluster，CF)；</li><li>序列特征 (Sequential features，SeqF).</li></ul></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="GPS和工单数据"><a href="#GPS和工单数据" class="headerlink" title="GPS和工单数据"></a>GPS和工单数据</h4><ul><li>本论文采用的数据集由 Fleetmatics 公司 (车队情报公司) 提供。</li><li>采集的数据有两种类型，分别是<code>原始 GPS pings 数据</code> 和 <code>工单数据</code>。<ul><li>原始 GPS Pings 数据<ul><li>提供有关车辆位置的信息，工单状态的信息，有关司机执行的工作进度及进度信息；</li><li>设定有一系列的 GPS Pings $\{P_i\}_{i=1}^n = \{P_1, …, P_n\}$ 分别描述每辆车行驶的路线。</li><li>每一个 GPS Ping $P_i$ 包含每辆车的状态信息，即有车辆 ID $v_i$，经度和纬度 (位置信息 $p_i$)，里程表 $d_i$，时间戳 $t_i$ 和 事件代码 $e_i$。</li></ul></li><li>工单数据<ul><li>设定有一系列的工单 $\{W_i\}_{i=1}^n = \{W_1, …, W_n\}$。</li><li>每一个工单包含的信息有：车辆 ID $v_i$，经度和纬度 (位置 $p_i$)，时间戳 $t_i$ 和 状态代码 $c_i$ (例如：挂起，启动，完成)。</li></ul></li></ul></li></ul><h4 id="车辆停靠侦查技术"><a href="#车辆停靠侦查技术" class="headerlink" title="车辆停靠侦查技术"></a>车辆停靠侦查技术</h4><p>正如上述所描述的，关于瞬时车辆位置的原始数据是由 GPS Ping 组成的，将它们汇集起来以描述车辆的活动。为此本论文开发了一个 <code>时空聚类程序</code>。</p><ul><li>首先得为每个 GPS 信息分配一种状态类型 (Engine off，iDling，Journey)，然后把它们聚集成 GPS Ping 群组，并把这个 GPS Ping 群组称为 <code>汽车停靠点集</code>。</li><li>GPS Ping 的状态可分为三种类型：<ul><li><code>Engine Off (发动机关闭状态)</code>：发动机关闭事件。即这些 Ping 在发动机关闭的瞬间产生的 (当发动机处于关闭状态时不发送 Ping);</li><li><code>iDling (空转/怠速状态)</code>：发动机处于开启状态，但车辆静止或车辆在小区域内仍然缓慢行驶。对于后者，我们还需要作一些约束，设定 $H(p_i,p_{i-1})$ 表示两点间的半正定距离。然后，对于给定车辆给予一对连续的 Ping $P_{i-1}\,and\,P_i$，且满足以下约束，则可定义为怠速：<ul><li>$s_i = H(p_i,p_{i-1})\,/\,(t_i - t_{i-1}) \leq 1.4\,m/s\,(5km/h)$，确定速度接近零；</li><li>$H(p_i,p_{i-1}) \leq 150\,m$，确保 $P_{i-1}\,and\,P_i$ 足够接近，且避免了由于丢失数据而产生的 <code>伪影</code>。</li></ul></li><li><code>Journey (行驶状态)</code>：即不是发动机关闭状态，也不是怠速状态。</li></ul></li><li>当 Ping 被分类后，以每辆车为单位，按时间顺序排序；并把所有连续的怠速状态和发动机关闭状态的 Ping 聚集成集群 (并不会被其中 Journey 状态的 Ping 給分割开来)。</li><li><p>由于丢失数据，导致一组连续的怠速状态 Ping 彼此相对较远地分布开来。故我们得重新执行 <code>时间-空间</code> 的约束条件 ($s_i \leq 1.4\,m/s$ and $H(p_i,p_{i-1}) \leq 150\,m$)。</p><blockquote><p>无法满足约束条件：即一组连续的怠速状态 Ping 将被分隔得很远，其中的 Journey 状态的 Ping 都给丢失了。 </p></blockquote></li><li><p>以这种方式创建的 <code>Pings 集群</code> 代表我们想要分类的 <code>已识别的汽车停靠点</code>。综上所述，汽车停靠点被定义为按时间顺序排序的 Ping  集群 (包含怠速状态或发动机关闭状态的 Ping，并且满足进一步的 <code>时间-空间</code> 得约束条件。</p></li><li>每个 <code>汽车停靠点</code> 都有几个特性 (通过计算其中的 Ping)：Ping 的数量，停靠点的起点和终点 (属于该停靠点的 Ping 的第一个和最后一个时间戳)，驻留时间 (属于该停靠点的起始时间和结束时间) 和形状 (由GPS消息的最大 (最小) 纬度/经度坐标定义)。</li><li>所有这些信息对于在第二阶段提取特征工作至关重要，即汽车停靠点意图的分类。</li></ul><h4 id="贴标签"><a href="#贴标签" class="headerlink" title="贴标签"></a>贴标签</h4><ul><li>首先，对上述程序中获得的汽车停靠点分配 <code>地面实况标签</code>；再者，将它们与 <code>工单数据</code> 进行匹配。一般来说，若车辆停留点在时间上和空间上与工单数据 $W_i$ 相匹配，则可认为该汽车停靠点即为某一工单数据。<ul><li>对于只包含 idling 和 engine off Pings 的停靠点，我们认为它满足空间上的匹配。</li><li>对于任何工单，空间上匹配了停留点；如果停留点的驻留时间与工单的时间项 (指示作业已启动的时间和指示服务已结束的时间) 间隔相交，时间的匹配也随着满足。</li></ul></li></ul><h4 id="分类特征"><a href="#分类特征" class="headerlink" title="分类特征"></a>分类特征</h4><p>在 <code>车辆停靠侦查技术</code> 章节中描述的，从一系列的 GPS Pings 提取汽车停靠点，并从中提取 100 个不同的特征用于训练随机森林模型，随之将这些特征划分为 4 个不同的组：</p><ul><li>汽车停靠点特征 ( Stop-wise features，SWF )：<ul><li>驻留时间：(汽车) 停靠点第一个和最后一个 Ping 的时间差。</li><li>开始时间特征：一天中的小时，一周中的某天，某月某日，某年某日。</li><li>关闭引擎所花费的时间：对于每一个引擎关闭事件，我们计算当前 Ping 与前一个非引擎关闭状态的 Ping 之间的时间差，以表示引擎启动的时间。由于每个停靠点包含多个引擎关闭状态的 Ping，我们需要使用几个聚合函数聚合取得结果。</li><li>形状：停靠点的宽度、高度、面积、比例。</li><li>停靠点类型：发动机关闭状态。</li><li>停靠点中发动机关闭状态 Ping 的数量。</li><li>里程表距离：从第一次 Ping 到最后一次 Ping。</li><li>停靠点内 Ping 的总数。</li><li>平均速度 (根据停留点中第一次和最后一次 Ping 之间的里程差除以驻留时间计算所得)。</li></ul></li><li>兴趣点特征 ( Points of interest features，POIF)：利用 <code>PTV xLocate Server</code> 中提取以下 POI 类型：<ul><li>银行;</li><li>大学;</li><li>酒店;</li><li>餐厅;</li><li>休息区;</li><li>杂货店;</li><li>学校;</li><li>购物中心;</li><li>汽油;</li><li>开放式停车场;</li></ul></li><li><p>汽车停靠点集群特征 ( Stop cluster features，CF )：其原理是存在一些工单数据和非工单数据趋向于聚类成簇，类似于 [7] 中提出的熵度量方法：对于每个停靠点，查看并收集 250 米半径内的周边环绕的停靠点数据。</p><ul><li><p>车辆熵，计算公式为：</p><script type="math/tex; mode=display">E_v = - \sum_{\nu \in V}   \frac{n_{\nu}}{N} ln(\frac{n_{\nu}}{N})  \tag{1}</script><blockquote><p>$V$ 是车队中的车辆集合， $N$ 是 250 米半径范围内车队所有车辆的总停留点数，$n_{\nu}$ 是车辆 $\nu$ 在同一区域停靠的总次数。这个熵度量给出了一个区域内同一车队车辆的多样性。</p></blockquote></li><li><p>簇中汽车停靠点的平均，总和，最大和最小驻留时间。</p></li><li>邻近汽车停靠点的数量 (在其质心250米半径以内)。</li></ul></li><li><p>序列特征 (Sequential features，SeqF).</p></li></ul><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul><li>在车辆停靠点侦查技术章节中，使用的是非监督方式的算法，即基于密度的 DBSCAN 聚类算法。其中涉及密度阈值的设定多少问题，就需要对具体样本量进行考究才能决定。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] Horozov T, Narasimhan N, Vasudevan V. Using location for personalized POI recommendations in mobile environments [C]//Applications and the internet, 2006. SAINT 2006. International symposium on. IEEE, 2006: 6 pp.-129.<br>[2] Jiang K, Yin H, Wang P, et al. Learning from contextual information of geo-tagged web photos to rank personalized tourism attractions [J]. Neurocomputing, 2013, 119: 17-25.<br>[3] Palma A T, Bogorny V, Kuijpers B, et al. A clustering-based approach for discovering interesting places in trajectories [C]//Proceedings of the 2008 ACM symposium on Applied computing. ACM, 2008: 863-868.<br>[4] Gong L, Sato H, Yamamoto T, et al. Identification of activity stop locations in GPS trajectories by density-based clustering method combined with support vector machines [J]. Journal of Modern Transportation, 2015, 23(3): 202-213.<br>[5] Ester M, Kriegel H P, Sander J, et al. A density-based algorithm for discovering clusters in large spatial databases with noise [C]//Kdd. 1996, 96(34): 226-231.<br>[6] Lv M, Chen L, Xu Z, et al. The discovery of personally semantic places based on trajectory data mining [J]. Neurocomputing, 2016, 173: 1142-1153.<br>[7] Gingerich K, Maoh H, Anderson W. Classifying the purpose of stopped truck events: An application of entropy to GPS data [J]. Transportation Research Part C: Emerging Technologies, 2016, 64: 17-27.<br>[8] Sambo F, Salti S, Bravi L, et al. Integration of GPS and satellite images for detection and classification of fleet hotspots [C]//Intelligent Transportation Systems (ITSC), 2017 IEEE 20th International Conference on. IEEE, 2017: 1-6.<br>[9] Wolf J, Guensler R, Bachman W. Elimination of the travel diary: Experiment to derive trip purpose from global positioning system travel data [J]. Transportation Research Record: Journal of the Transportation Research Board, 2001 (1768): 125-134.<br>[10] Bohte W, Maat K. Deriving and validating trip purposes and travel modes for multi-day GPS-based travel surveys: A large-scale application in the Netherlands [J]. Transportation Research Part C: Emerging Technologies, 2009, 17(3): 285-297.  </p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;原文：Stop purpose classification from GPS data of commercial vehicle fleets&lt;br&gt;作者：Sarti L, Bravi L, Sambo F.&lt;br&gt;来源：Data Mining Workshops, 2017 IEEE International Conference on. IEEE, 2017: 280-287.  &lt;/p&gt;&lt;/div&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;从原始 GPS (全球定位系统) 数据中提取 &lt;code&gt;汽车停靠意图数据&lt;/code&gt; 是大多数位置感知应用程序中的关键任务，且随着从移动设备收集 GPS 数据的不断增长，这项任务变得越来越有趣。近期很多研究都集中在行人 (手机) 数据上 (可理解为红海市场)，而商用车领域几乎没有探索 (蓝海市场)。&lt;/p&gt;
&lt;p&gt;在本论文中，针对车辆 GPS 数据的汽车停靠意图的 &lt;code&gt;识别&lt;/code&gt; 和 &lt;code&gt;分类&lt;/code&gt; 问题 (利用来自不同行业的商业车队的大型异构数据集)。按照意图分类，旨在把汽车停靠点分为：&lt;code&gt;工作相关&lt;/code&gt; 和 &lt;code&gt;非工作相关&lt;/code&gt;，以挖掘相关商业价值。&lt;/p&gt;
&lt;p&gt;且还对每个汽车停靠点计算一组含 100 个不同特征的集合，特征可分为四个主要类别：&lt;code&gt;汽车停靠点特征&lt;/code&gt;，&lt;code&gt;兴趣点特征&lt;/code&gt;，&lt;code&gt;汽车停靠点集群特征&lt;/code&gt; 和 &lt;code&gt;序列特征&lt;/code&gt;。并通过随机森林分类模型，评估四组特征中每个特征对停靠点的相对重要性，以处理不同类型的问题。&lt;/p&gt;
&lt;p&gt;实验结果表明，本论文的方法显着地超越了现有商业车辆背景下用于汽车停靠意图的分类模型。&lt;/p&gt;
    
    </summary>
    
      <category term="Paper" scheme="http://www.kofes.cn/categories/Paper/"/>
    
    
      <category term="数据挖掘" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="聚类" scheme="http://www.kofes.cn/tags/%E8%81%9A%E7%B1%BB/"/>
    
      <category term="机器学习" scheme="http://www.kofes.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="分类" scheme="http://www.kofes.cn/tags/%E5%88%86%E7%B1%BB/"/>
    
      <category term="特征提取" scheme="http://www.kofes.cn/tags/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>论文 - 通过非线性随机邻近嵌入自动分类细胞表达</title>
    <link href="http://www.kofes.cn/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding.html"/>
    <id>http://www.kofes.cn/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding.html</id>
    <published>2018-06-06T13:14:53.000Z</published>
    <updated>2018-06-11T16:57:11.760Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p>原文：Automatic classification of cellular expression by nonlinear stochastic embedding (ACCENSE)<br>作者：Karthik Shekhar, Petter Brodin, Mark M.Davis and Arup K.Chakraborty.<br>来源：Proceedings of the National Academy of Sciences (PNAS), 2014, 111(1): 202-207.  </p></div><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>质谱流式细胞技术 (Mass cytometry) 能够在单细胞水平上测试近 40 种不同的蛋白质，即提供前所未有的多维信息水平。由于各式各样的细胞种群数据集的复杂性，要收集有用的生物学知识对计算工具也有新的要求。回顾之前的聚类方法，即对于不同功能的细胞识别是基于细胞表征相似性来实现区分的。当然，经典方法存在一定局限性，例如单细胞分辨率的损失；经典方法需要预知簇中的对象数量 (本文中指细胞亚群的规模数量)。</p><a id="more"></a><p>则该论文引入 <code>ACCENSE</code> (Automatic classification of cellular expression by nonlinear stochastic embedding) 高维单细胞数据分析工具：</p><ul><li>基于密度划分的非线性降维方法，降维步骤采用 <code>t-Distributed Stochastic Neighbor Embedding (t-SNE)</code> 算法 $^{[1]}$。</li><li>探索性数据分析，同时避免任何手动 <code>阀门(阈值)</code> 的需要，即有别于基于距离的方法 (离群点判定)、基于密度的方法 (密度阈值)。</li><li>化繁为简，在二维或三维图上展示多元细胞的表型。</li></ul><p>再有，本论文将 ACCENSE 应用于 35 参数的质谱流式细胞技术，检测 CD8+ T 细胞的数量 (数据来自于特定的无病原和无菌小鼠)，并将细胞分层到表型亚群中。即对于具体的聚类算法、降维算法中，特定的符号名称会以具体的对象名称替代。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><ul><li><p>免疫系统包含了许多类型的细胞，它们在免疫应答过程中表现出多样化的功能和复杂方式的相互作用，即通过不同蛋白质的表达水平所定义，故个体细胞的功能与其细胞表型密切相关。这里启示我们，对于不同功能的细胞可通过细胞表型相似性进行聚类区分。</p></li><li><p>传统流式细胞技术和质谱流式细胞技术</p><ul><li><p>传统流式细胞技术 (Flow Cytometry) $^{[2]}$ 中，用 <code>荧光基因</code> 标记的抗体染色，其蛋白质靶标通过单细胞分辨率的光发射信号进行量化。</p><blockquote><p>由于有限的光谱和重叠的发射信号，每个细胞限制为 12-16 个参数。</p></blockquote></li><li><p>质谱流式细胞技术 (Mass Cytometry) $^{[3]}$ ，使用 <code>金属螯合探针</code> 可以对多达 42 个参数的单个细胞进行量化。</p></li><li><p>传统流式细胞技术和质谱流式细胞技术相比，主要有两点不同：  </p><ul><li>标签系统的不同，前者主要使用各种荧光基团作为抗体的标签，后者则使用各种金属元素作为标签；  </li><li>检测系统的不同，前者使用激光器和光电倍增管，而后者使用 ICP 质谱技术。 </li></ul></li></ul></li></ul><h3 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h3><p>由 <code>质谱流式细胞技术产生的高维数据</code>，以具有生物学意义的方式解释是具有挑战性的。然而，很多聚类工具是基于细胞的蛋白表达相似性进行细胞分类的，例如：</p><ul><li><code>SPADE 算法</code> $^{[4,5]}$：SPADE 使用多元信息定义细胞簇，并在树状结构中显示潜在的表型层次结构。但尚有不足之处：<ul><li>一是单细胞分辨率的损失；</li><li>二是对目标集群数量的需要预知。</li></ul></li></ul><h3 id="降维算法"><a href="#降维算法" class="headerlink" title="降维算法"></a>降维算法</h3><p>同样，降维算法以蛋白质表达相似性，把空间组织的细胞群在低维空间聚集成不同的细胞亚群。    </p><ul><li><code>PCA 算法</code>：PCA降维的大致思想就是，挑选特征明显的、显得比较重要的信息保留下来。在本论文中，Newell 等人将主成分分析 (Principal component analysis，PCA) 应用于 25 参数的质谱流式细胞技术，检测人的 CD8+ T 细胞的数量，且使用前三种主成分 (3D-PCA) 分离细胞亚群。3D-PCA 以三个汇总变量表示数据，每个汇总变量都是原始维度的线性组合，并去捕获投影后数据的方差，直至其取值为最大值。然而，PCA 能在数据中所有的可能线性组合中找到最优表达，但也存在限制条件：线性投影可能太严格而不能产生精确的表示 $^{[6]}$ ( 引入 t-SNE 算法 )。</li><li><p><code>t-SNE 算法</code> $^{[7]}$：t-Distributed Stochastic Neighbor Embedding，数据降维与可视化的方法，具体的算法细节如下：</p><ul><li>让 $\{x^{(i)}\}$ 表示归一化 n 维蛋白质表达向量编码的细胞 i 表型 (i=1, 2, …, M)。</li><li>若在 2D 平面图下，$\{y^{(i)}\}$ 向量表示高维 $\{x^{(i)}\}$ 对应于低维的映射，它使得具有相似表型的 T 细胞彼此靠近嵌入，表型不相似的则嵌入相对较远的距离。</li><li>采用细胞 i 和 j 之间的成对概率 $\{p_{i,j}\}$ 表示 $\{x^{(i)}\}$ 与 $\{x^{(j)}\}$ 之间的相似性。</li><li>若在 2D 平面图下，成对概率 $\{q_{i,j}\}$ 表示 $\{y^{(i)}\}$ 与 $\{y^{(j)}\}$ 之间的相似性。</li><li><p>通过最小化 $\{p_{i,j}\}$ 与 $\{q_{i,j}\}$ 的 KL 散度 (可理解为代价函数)，然后找出嵌入向量 $\{y^{(i)}\}$，即它让高维转低维的表示信息能最大程度被保存下来。</p><blockquote><p>KL 散度 (<a href="#1-t-SNE-中的概率">详细见附录 1</a>)，Kullback-Leibler Divergence，又称相对熵，即描述两概率分布 P 和 Q 的差异。KL 散度公式 (1) 如下：</p></blockquote><script type="math/tex; mode=display">D_{KL}(\{p_{i,j}\}|\{q_{i,j}\}) = \sum_{i,j} p_{i,j} log \frac{p_{i,j}}{q_{i,j}} \tag{1}</script></li><li><p>$\{y^{(i)}\}$ 可以编码非线性关系，不像 PCA 中被约束为 $\{x^{(i)}\}$ 的线性组合。</p></li><li><code>最佳嵌入</code> 是通过数值梯度下降法来确定的，即所有数据点的 KL 散度总和减小到最小 (<a href="#2-数值梯度下降法">详细见附录 2</a>)。</li></ul></li></ul><h3 id="识别细胞亚群"><a href="#识别细胞亚群" class="headerlink" title="识别细胞亚群"></a>识别细胞亚群</h3><ul><li><p>使用一个内核密度变换，从 t-SNE 的细胞散布图计算出一个复合图像 $K_\gamma(y)$：</p><script type="math/tex; mode=display">K_\gamma(y) = exp(  -\frac{||y - y'||^{2}}{2\gamma^2}  )\tag{2}</script></li><li><p>在本论文中，$K_\gamma(y)$ 的 <code>局部最大值</code> 表示具有共同表型的 CD8+ T 细胞亚群，且使用了 matlab 的峰值检测算法识别这些局部最大值。</p><blockquote><p>当然，也可以在嵌入点上使用 K-Means 聚类算法来识别 T 细胞子集，但其要求事先指定簇的数量。</p></blockquote></li><li><p>如何求得 <code>局部最大值</code>，关键是对于公式 (2) 中 $\gamma$ 的参数设定多少有关。即通过比较不同的核-宽带 $\gamma$ 产生的结果，则存在一个 $\gamma$ 值为表型空间中存在的局部和全局特征提供了准确的粗粒度表示。从图 1-2 中可得，即启示我们可以以数据驱动的方式，近似地识别 CD8+ T 细胞的亚群。</p></li></ul><h3 id="相关图表"><a href="#相关图表" class="headerlink" title="相关图表"></a>相关图表</h3><ul><li>如图 1-1 所示，ACCENSE 应用于质谱高维数据。</li></ul><p><img src="/images/illustration/Paper/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding_1-1.jpg" alt="图1-1ACCENSE ACCENSE 应用于质谱高维数据"></p><center>图 1-1 ACCENSE 应用于质谱高维数据</center><p>(A) 质谱细胞计数数据集样本的图示。行对应于不同的细胞，而列对应于测量其表达 (细胞表面抗原和细胞内蛋白) 的不同标记的金属螯合抗体。每一元组对应于指示每个标记的表达水平的质荷比变换值 (反双曲函数)。(C) 来自SPF B6 小鼠的 CD8+ T 细胞的 2D t-SNE 图谱。每个点代表来自训练集的一个细胞 (M = 18304)，且数据点是通过对原始数据集进行下采样得到。(D) 通过使用基于内核密度变换 ($K_{\gamma}(y)\,{,}\,\gamma = 7$)，将细胞的局部概率密度嵌入 (C) 的复合图像。并使用标准的峰值检测算法进行识别局部最大值，在二维密度图表示表型亚群的中心。</p><ul><li>如图 1-2 所示，展示了峰值随着 $\gamma$ 的增加而变化。</li></ul><p><img src="/images/illustration/Paper/2018/06/Automatic-classification-of-cellular-expression-by-nonlinear-stochastic-embedding_1-2.png" alt="图1-2展示了峰值随着γ的增加而变化"></p><center>图 1-2 展示了峰值随着 $\gamma$ 的增加而变化</center><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="1-t-SNE-中的概率"><a href="#1-t-SNE-中的概率" class="headerlink" title="1 t-SNE 中的概率"></a>1 t-SNE 中的概率</h3><h4 id="p-i-j-概率"><a href="#p-i-j-概率" class="headerlink" title="$p_{i,j}$ 概率"></a>$p_{i,j}$ 概率</h4><p>基于蛋白质相似性，设 $p_{j|i}$ (i,j = 1, 2, …, M) 表示细胞 i 将选择细胞 j 作为其最近邻的概率 ( $p_{j|i}$ 越大，$x^{(i)} 和 x^{(j)}$ 越近 )：</p><script type="math/tex; mode=display">p_{j|i} = \frac{    exp({-d_{i,j}^2} / {    2\sigma_i^2})}{     \sum_{k \neq i} exp({-d_{i,k}^2} / {    2\sigma_i^2})}, d_{i,j} = ||x^{(i)} - x^{(j)}||_2\tag{3}</script><p>对于概率 $p_{j|i}$ 的几点说明：</p><ul><li>$d_{i,j}$ 可以使用其他距离范式替代欧式距离范式；</li><li><p>原始的 SNE 算法是不对称的，为简化梯度公式，t-SNE 中让公式 (3) 的条件概率是对称的。即初始化 $p_{i|i} = 0$，对于任意的 $p_{i|j} = p_{j|i}$，可得：    </p><script type="math/tex; mode=display">p_{i,j} = \frac{  p_{j|i} + p_{i|j} }{2M} = \frac{  exp({-d_{i,j}^2} / {  2\sigma_i^2})}{   \sum_{k \neq i} exp({-d_{i,k}^2} / {  2\sigma_i^2})}\tag{4}</script></li><li><p>不同的点 $x_i$，带宽 $\sigma_i$ 的取值也是不同的。</p><ul><li>公式 (3) 中的带宽 $\sigma_i$ 是确保对于每一个细胞都有相同的复杂度 (Complexity)。复杂度可理解为一个点附近的 <code>有效近邻点个数</code>。</li><li>定义复杂度为 $P_i = 2^{H_{j|i}}$，其近似地解释为细胞 i 的最近邻点的数量。</li><li><p>定义 $p_{j|i}$ 的香农熵 (信息熵) 为 $H_{j|i} = - \sum_j p_{j|i} \log_2 p_{j|i}$，且 $H_{j|i}$ 随着 $\sigma_i$ 的增加而增加。</p><blockquote><p>在本论文中，t-SNE 图谱的复杂度被设定为 30，即 10-50 范围内的复杂度对最终结果的影响不大 (较好的鲁棒性)。</p></blockquote></li></ul></li></ul><h4 id="q-i-j-概率"><a href="#q-i-j-概率" class="headerlink" title="$q_{i,j}$ 概率"></a>$q_{i,j}$ 概率</h4><p>对于低维度下的 $\{y_i\}$，在原始的 SNE 算法 $^{[7]}$ 中 Hinton 和 Rowers 引用高斯核函数 (Gaussian Kernels) 定义 $q_{i,j}$，但在低维表达中发现了 <code>拥挤问题</code>。</p><blockquote><p><code>拥挤问题</code>：就是说各个簇聚集在一起，无法区分。譬如，有一高维度数据在降维到 10 维下可以有很好的表达，但是降维到两维后无法得到可信映射。具体情况是，10 维中有数个点之间两两等距离的，在二维下就无法得到可信的映射结果。<br>进一步说明，假设一个以数据点 $x^i$ 为中心，半径为 r 的 m 维球(三维空间就是球)，其体积是按 $r^m$ 增长的，假设数据点是在 m 维球中均匀分布的，我们来看看其他数据点与 $x^i$ 的距离随维度增大而产生的变化。</p></blockquote><p>t-SNE 减轻了拥挤问题，即使用更加偏重长尾分布的方式来将距离转换为概率分布 $^{[8]}$，故有 $q_{i,j}$：</p><script type="math/tex; mode=display">q_{i,j} = \frac{    (1 + \Delta_{i,j}^2)^{-1}}{     \sum_{k \neq i} (1 + \Delta_{i,k}^2)^{-1}}, \Delta_{i,j} = ||y^{(i)} - y^{(j)}||_2\tag{5}</script><p>同样地，对于概率 $q_{i,j}$ 的几点说明：</p><ul><li>$\Delta_{i,j}$ 可以使用其他距离范式替代欧式距离范式；</li><li>原始的 SNE 算法是不对称的，为简化梯度公式，t-SNE 中让公式 (5) 的条件概率是对称的。即初始化 $q_{i|i}=0$，对于任意的 $q_{i|j} = q_{j|i}$。</li></ul><h3 id="2-数值梯度下降法"><a href="#2-数值梯度下降法" class="headerlink" title="2 数值梯度下降法"></a>2 数值梯度下降法</h3><ul><li>在 [7] 中的概述过程，获得优化的梯度公式，如下所示:</li></ul><script type="math/tex; mode=display">\frac{    \partial D_{KL}(\{p_{i,j}\} | \{q_{i,j}\})}{    \partial_{y_t}^{(i)}} = 4 \sum_j \frac{        (p_{i,j} - q_{i,j})    }{        (1 + ||y_t^{(i)} - y_t^{(j)}||^2)    }    (y_t^{(i)} - y_t^{(j)})    \tag{6}</script><ul><li><p>通过梯度下降法迭代计算局部最大值：</p><script type="math/tex; mode=display">  y_{t+1}^{(i)} = y_{t}^{(i)} + \eta(t) \frac{      \partial D_{KL}(\{p_{i,j}\} | \{q_{i,j}\})  }{      \partial_{y_t}^{(i)}  }  + \alpha(t)(y_{t}^{(i)} - y_{t-1}^{(i)})  \tag{7}</script><ul><li>$y_t^{(i)}$ 表示迭代 t 次的解，$\eta(t)$ 表示学习速率，$\alpha(t)$ 表示迭代 t 次的动量。</li><li><p>学习速率初始值为 $\eta(t) = 100\,^{[9]}$，且动能量 $\alpha(t)$ 设定为：</p><script type="math/tex; mode=display">\alpha(t) = \begin{cases} 0.8, & t < 300 \\0.5, & t \geq 300 \end{cases}</script></li></ul></li></ul><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul><li>t-SNE 主要用于可视化，很难用于其他目的。譬如测试集合降维，因为他没有显式的预估部分，不能在测试集合直接降维。</li><li>关于核-带宽 $\gamma$ 参数设定问题：文中展示了 $\gamma$ 参数的大小与识别细胞亚群能力的数量关系。然而，数据驱动方式虽能实现自动聚类，但缺乏对于 $\gamma$ 参数设定范围该如何控制的说明。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] Maaten L, Hinton G. Visualizing data using t-SNE [J]. Journal of machine learning research, 2008, 9(Nov): 2579-2605.<br>[2] Cantor H, Simpson E, Sato V L, et al. And functional studies of peripheral t-cells binding different amounts of fluorescent anti-thy 1.2 (theta) Antibody using a fluorescence—activated cell sorter (FACS) [J]. 1975.<br>[3] Bendall S C, Nolan G P, Roederer M, et al. A deep profiler’s guide to cytometry [J]. Trends in immunology, 2012, 33(7): 323-332.<br>[4] Qiu P, Simonds E F, Bendall S C, et al. Extracting a cellular hierarchy from high-dimensional cytometry data with SPADE [J]. Nature biotechnology, 2011, 29(10): 886.<br>[5] Bendall S C, Simonds E F, Qiu P, et al. Single-cell mass cytometry of differential immune and drug responses across a human hematopoietic continuum [J]. Science, 2011, 332(6030): 687-696.<br>[6] Van Der Maaten L, Postma E, Van den Herik J. Dimensionality reduction: a comparative [J]. J Mach Learn Res, 2009, 10: 66-71.<br>[7] Maaten L, Hinton G. Visualizing data using t-SNE [J]. Journal of machine learning research, 2008, 9(Nov): 2579-2605.<br><a href="http://www.datakit.cn/blog/2017/02/05/t_sne_full.html" target="_blank" rel="noopener">[8] Chrispher. t-SNE 完整笔记 [OL]. www.datakit.cn. 2017.</a><br>[9] Jacobs R A. Increased rates of convergence through learning rate adaptation[J]. Neural networks, 1988, 1(4): 295-307.</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;原文：Automatic classification of cellular expression by nonlinear stochastic embedding (ACCENSE)&lt;br&gt;作者：Karthik Shekhar, Petter Brodin, Mark M.Davis and Arup K.Chakraborty.&lt;br&gt;来源：Proceedings of the National Academy of Sciences (PNAS), 2014, 111(1): 202-207.  &lt;/p&gt;&lt;/div&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;质谱流式细胞技术 (Mass cytometry) 能够在单细胞水平上测试近 40 种不同的蛋白质，即提供前所未有的多维信息水平。由于各式各样的细胞种群数据集的复杂性，要收集有用的生物学知识对计算工具也有新的要求。回顾之前的聚类方法，即对于不同功能的细胞识别是基于细胞表征相似性来实现区分的。当然，经典方法存在一定局限性，例如单细胞分辨率的损失；经典方法需要预知簇中的对象数量 (本文中指细胞亚群的规模数量)。&lt;/p&gt;
    
    </summary>
    
      <category term="Paper" scheme="http://www.kofes.cn/categories/Paper/"/>
    
    
      <category term="数据挖掘" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="聚类" scheme="http://www.kofes.cn/tags/%E8%81%9A%E7%B1%BB/"/>
    
      <category term="降维" scheme="http://www.kofes.cn/tags/%E9%99%8D%E7%BB%B4/"/>
    
      <category term="免疫表型" scheme="http://www.kofes.cn/tags/%E5%85%8D%E7%96%AB%E8%A1%A8%E5%9E%8B/"/>
    
      <category term="机器学习" scheme="http://www.kofes.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>论文 - 扩展 K-Means 算法：混合数据类型的聚类方法</title>
    <link href="http://www.kofes.cn/2018/06/Extensions-to-the-k-Means-algorithm-for-custering-large-datasets-with-categorical-values.html"/>
    <id>http://www.kofes.cn/2018/06/Extensions-to-the-k-Means-algorithm-for-custering-large-datasets-with-categorical-values.html</id>
    <published>2018-06-03T12:47:42.000Z</published>
    <updated>2018-07-17T01:07:36.604Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p>原文：Extensions to the k-means algorithm for clustering large datasets with categorical values<br>作者：ZHEXUE HUANG.<br>来源：Data mining and knowledge discovery, 1998, 2(3): 283-304.  </p></div><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在早期，大多数聚类工作主要集中在数值数据上，且它们主要是利用数值数据的固有几何特性，即数据点之间的 <code>距离函数</code> (<a href="#1-距离函数">见附录1</a>)。但是，数据挖掘应用程序通常涉及许多数据集，这些数据集是由混合数值属性和标称属性组成的，仅拥有数值数据的测量方法已无法满足混合数据类型的聚类工作。</p><p>本论文基于经典的 K-Means 算法上，提出了两种聚类算法，分别应对 <code>标称域</code> 和 <code>混合数值与标称域</code> 属性值的聚类操作。首先介绍的是<code>K-Modes (K-众数)</code> 聚类算法，他运作的方式与 K-Means 相仿，只是它利用的是相异性度量处理标称对象，聚类中心以众数替代均值，且众数以基于频率的方法去迭代更新，直至 <code>聚类代价函数</code> 的结果最小化停止迭代。其次，是 <code>K-Prototype</code> 聚类算法，它定义了一组合的相异性度量值，进一步整合 <code>K-Means</code> 和 <code>K-Modes</code> 算法，以实现对混合数值与标称属性的对象进行聚类操作。</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>将数据库中的一组对象划分为同构组或集群是数据挖掘中最基本的操作。而讨论划分操作，自然离不开聚类。聚类是把每一组对象划分为一个簇，且同一簇中对象之间相似，而不同簇之间的对象相异。</p><p>数据挖掘最显著的特征是处理复杂的大型数据集。特别地，数据集包含数以百万计由不同类型属性或变量描述的对象，由此数据挖掘操作和算法应充分考虑可扩展性，以应付处理不同类型的属性。</p><p>在本论文中，提出的两个新聚类算法，即利用 <code>K-Means 范式</code> 对拥有标称属性的数据进行聚类。<code>K-Modes (K-众数)</code> 聚类算法，他运作的方式与 K-Means 相仿，只是它利用的是相异性度量处理标称对象，聚类中心以众数替代均值，且众数以基于频率的方法去迭代更新，直至 <code>聚类代价函数</code> 的结果最小化停止迭代。其次，是 <code>K-Prototype</code> 聚类算法，它定义了一组合的相异性度量值 $s^r + \gamma s^c$，以实现对混合数值与标称属性的对象进行聚类操作。其中，$s^r$ 是由 <code>平方欧式距离</code> 定义的 <code>数值属性</code> 的相异性度量值，$s^c$ 是由 <code>两个对象间类别不匹配的数量</code> 定义的 <code>标称属性</code> 的相异性度量值，$\gamma$ 是平衡数值属性和标称属性两部分的的权值，以避免偏向于某一属性。若聚类的效果更青睐于数值属性，则可以设定一个较小的 $\gamma$ 值；反之，设定一较大的 $\gamma$ 值。</p><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><ul><li>假设需要聚类的对象数据集储存在数据集 D 中。<ul><li>集合的属性 $A_1, A_2, … , A_m$ 分别是值域 $D_1, D_2, … , D_m$ 的描述。</li><li>在 D 中的每个对象由元组 t 表示，$t \in D_1 \times D_2 \times … \times D_m$。</li></ul></li><li>针对本文讨论的聚类问题，仅考虑两种常见数据类型：数值类型和标称类型。<ul><li>数值域的取值范围是实数域。</li><li>在多维的密度空间中，每一个数值型的数据点都采用诸如欧式或马氏的距离度量方法。</li><li>若值域 $D_i$ 被定义为有限、无序的标称域，则对象的比较操作只允许在 $D_i$ 中执行，即有 $a, b \in D_i$，either a = b or $a \neq b$。</li></ul></li><li><p>对于数据集中的每一数据对象 $X$，也可由 <code>属性-属性值</code> 的键值对表示，</p><script type="math/tex; mode=display">[A_1=x_1] \bigwedge [A_2=x_2] \bigwedge ... \bigwedge [A_m=x_m]</script></li><li><p>即当 $x_i \in D_i$，for i = 1, 2, …, m。为简单起见，这里以 $X$ 表示元组：</p><script type="math/tex; mode=display">[x_1^r, x_2^r, ...,x_p^r, x_{p+1}^c, ..., x_m^c] \in D_1 \times D_2 \times ... \times D_m</script><blockquote><p>最后一个数值对象为元素 $p$ ，其余的都是标称对象。当然，若元组中仅有一种数据类型，可表示为 $[x_1, x_2, …, x_m]$。</p></blockquote></li></ul><h3 id="K-Means-均值-算法"><a href="#K-Means-均值-算法" class="headerlink" title="K-Means (均值) 算法"></a>K-Means (均值) 算法</h3><ul><li>K-Means，是一种划分或非分层的聚类算法，为进一步阐述细节，需给出如下设定：<ul><li>一组含 $n$ 个数值数据的对象集 $D = \{X_1, X_2, …, X_n\}$；</li><li>距离度量 $d$；</li><li>自然数 $k (\leq n)$，并把 $D$ 划分 $k$ 个非空且相分离的簇群：<script type="math/tex; mode=display">C_1, C_2, ..., C_k, \, with \, C_i \bigcap C_j = \emptyset \, and \, \bigcup_{i=1}^k C_i = D</script></li><li>$D$ 中随机选取 $k$ 个对象，每个对象代表一个簇的初始均值或中心。</li></ul></li><li><p>如此一来，使得数据对象与其簇的中心之间的平方误差总和被最小化。然后，根据非线性优化问题，将该问题描述为:</p><script type="math/tex; mode=display">  Minimise \, P(W,Q) = \sum_{l=1}^k \sum_{i=1}^n w_{i,l} d(X_i, Q_l)  \tag{1}</script><p>  且服从：</p><script type="math/tex; mode=display">  \begin{cases}  \sum_{l=1}^k w_{i,l} = 1, \, i = 1, 2, ..., n   \\ w_{i,l} \in \{0,1\}, \, i = 1, 2, ..., n; l = 1, 2, ..., k  \end{cases}  \tag{2}</script><ul><li>$w_{i,l}$ 指标变量表示对象 $X_i$ 仅属于哪一个簇。即取值为 1 时，表示对象 $X_i $ 在 簇 $C_l$ 中；反之，取值为 0。</li><li><p>$W = \left[ w_{i,l} \right]_{n \times k}$ 是分块矩阵 (见公式 3)，$Q = \{Q_1, Q_2, …, Q_K\}$ 是簇的中心集合，$d(·,·)$ 是两对象间的平方欧式距离 (<a href="#1-距离函数">见附录1</a>)。</p><script type="math/tex; mode=display">W = \left[ w_{i,l} \right]_{n \times k} = \begin{bmatrix} w_{11} & \cdots & w_{1l} & \cdots & w_{1k} \\ \vdots & & \vdots & & \vdots \\w_{i1} & \cdots & w_{il} & \cdots & w_{ik} \\\vdots & & \vdots & & \vdots \\w_{n1} & \cdots & w_{nl} & \cdots & w_{nk} \\ \end{bmatrix}\tag{3}</script></li></ul></li><li><p>紧接着，在约束条件 (2) 下对 (1) 中的 P 进行优化，即对 Q 和 W 进行局部优化。首先，我们先固定 Q 并找出必要条件 W 使 P 最小化。然后，根据 Q 去修正 W 并最小化 P。基于上述几点，若为了达到 P 最小化，K-Means 算法通过 <code>三步迭代</code>，直到 P(W, Q) <code>收敛</code> 到某个 <code>局部最小值</code>。</p><ul><li><code>Step.01</code>： 初始化 $Q^{(0)} = \{Q_1^{(0)}, Q_2^{(0)}, …, Q_k^{(0)}\}$，且设立 $t = 0$。</li><li><code>Step.02</code>：固定 $Q^{(t)}$ 不变，求解 $P(W, Q^{(t)})$ 再去获得 W，即以 Q 作为簇群的中心，将每个对象分配到距离其最近的簇中心的簇群当中。</li><li><p><code>Step.03</code>：固定 $W^{(t)}$  不变，生成 $Q^{(t+1)}$，求解 $P(W^{(t)}, Q^{(t+1)})$。比较 $P(W, Q^{(t)}) \, and \, P(W^{(t)}, Q^{(t+1)})$，若后者为最小化，则根据当前的对象部分构造新的簇群中心。</p><ul><li><p>$Q_t^{t+1} = \{q_{l,1}^{(t+1)}, …, q_{l,m}^{(t+1)}\}, \, for \, l = 1, 2, …, k$，且：</p><script type="math/tex; mode=display">q_{l,j}^{(t+1)} = \frac {  \sum_{i=1}^n w_{i,l}^{(t)} x_{i,j}}{  \sum_{i=1}^n w_{i,l}^{(t)}}, \, j = 1, 2, ..., m\tag{4}</script></li></ul></li><li><p><code>Step.04</code>：当满足收敛或给定的停止条件时 ( <code>局部最优化</code> )，输出结果并停止；反之，令 $t = t + 1$，并继续从 <code>Step.02</code> 开始执行。</p></li></ul></li><li>为了解决 <code>簇间边界不明确</code> 的问题，模糊分区的概念成功地应用到聚类问题中，即模糊聚类 $^{[2,3]}$。但是，我们在本论文中不考虑这个问题。</li><li>综上所述，K-Means 算法具有以下特征：<ul><li>局部最优化为算法结束的终止条件；</li><li>仅适用于数值属性数据的聚类；</li><li>簇群的特征为球形簇.</li></ul></li></ul><h3 id="K-Modes-众数-算法"><a href="#K-Modes-众数-算法" class="headerlink" title="K-Modes (众数) 算法"></a>K-Modes (众数) 算法</h3><p>原则上，K-Means 算法中问题 P 的公式对于分类和混合类型的对象也是有效的，之所以 K-Means 算法不能对标称属性对象进行聚类的原因是它的相异性度量方法和用于构造新的簇群中心的方法不适用，故通过对 K-Means 算法进行以下修改，可消除不适用问题：</p><ul><li>用于标称属性对象的相异性度量的方法；</li><li>簇群的中心以 <code>众数</code> 替代 <code>均值</code>；</li><li>使用基于频率的方法求的众数，以构造新的簇群中心。</li></ul><h4 id="相异性度量"><a href="#相异性度量" class="headerlink" title="相异性度量"></a>相异性度量</h4><p>相异性度量：设 $X,Y$ 是由 m 个标称属性描述的两个标称属性对象， $X,Y$ 的相异性度量可通过两个对象间相对应属性的不匹配总和来定义，即不匹配的次数越少，两个对象越相似。定义如下：</p><script type="math/tex; mode=display">d_1(X,Y) = \sum_{j=1}^m \delta (x_j,y_j)\tag{5}</script><p> 且满足条件：</p><script type="math/tex; mode=display">\delta (x_j,y_j) = \begin{cases}0 , \, (x_j = y_j) \\1 , \, (x_j \neq y_j)\end{cases} \tag{6}</script><h4 id="众数集"><a href="#众数集" class="headerlink" title="众数集"></a>众数集</h4><p>设 $X$ 是由标称属性 $A_1, A_2, …, A_m$ 描述的标称属性对象集。$X= \{X_1, X_2, …, X_n\}$ 的众数由向量 $Q =\{q_1, q_2, …, q_m\}$ 表示，并最小化函数：</p><script type="math/tex; mode=display">Minimise \, D(X,Q) = \sum_{i=1}^n d_1(Xi,Q)\tag{7}</script><blockquote><p> 注意，这里 $Q$ 并不一定是 $X$ 中包含元素 (有别于 K-Medoids 算法 $^{[4]}$，质心从它的样本点中选择 )。    </p></blockquote><h4 id="挑选众数"><a href="#挑选众数" class="headerlink" title="挑选众数"></a>挑选众数</h4><p>设 $n_{c_{k,j}}$ 为属性 $A_j$ 中包含第 k 个标称属性 $c_{k,j}$ 的对象数量，且定义 $f(A_j = c_{k,j} | X) = \frac{ n_{c_{k,j}} }{n}$ 为标称属性 $c_{k,j}$ 在 $X$ 中的出现频率。</p><ul><li><p><code>定理 1</code>：若满足下述条件 (8)，即 $D(X,Q)$ 已最小化 ( 证明见<a href="#2-定理证明">附录2</a> )。即定理定义了一种从给定的 $X$ 中找到 $Q$ 的方法，即它允许使用 K-Means 范式来聚类标称数据，且定理 1 暗示了数据集 $X$ 的众数不是唯一的。 </p><script type="math/tex; mode=display">  f(A_j = q_j | X) \geq f(A_j = c_{k,j} | X) \, for \, q_j \neq c_{k,j},j=1, 2, ..., m  \tag{8}</script></li></ul><h4 id="算法核心"><a href="#算法核心" class="headerlink" title="算法核心"></a>算法核心</h4><ul><li>当公式 (5) 用作标称属性对象的相异性度量时，公式 (1) 的代价函数将推导为：</li></ul><script type="math/tex; mode=display">P(W,Q) = \sum_{l=1}^k \sum_{i=1}^n \sum_{j=1}^m w_{i,l} \delta(x_{i,j},q_{l,j})\\\ where \, w_{i,l}  \in W \, and \, Q_l = [q_{l,1}, q_{l,1}, ..., q_{l,m}] \in Q\tag{9}</script><ul><li>为了最小化代价函数，则修改经典 K-Means 算法：<ul><li>以相异性度量方法求解 $W$，即上述 <code>Step.02</code> 所描述的，以当前 $Q$ 为簇群中心，将每个对象分配到距离其最近的簇中心的簇当中去；</li><li>用簇的众数代替均值，根据 <code>定理 1</code> 选择众数来求解  $Q$，即上述 <code>Step.03</code> 所描述的，求得新的簇群中心。</li></ul></li><li><p>在经典算法中，我们需要在每次获得一个新的 $Q$ 或 $W$ 时，根据整个数据集计算总代价 P。为了提高计算效率，我们在实践中采用了下面的算法。</p><ul><li><code>Step.01</code>：初始化 k 个众数，且每个众数对应一个簇；</li><li><code>Step.02</code>：根据公式 (5)，将距离众数最近的对象分配该簇当中。再根据 <code>定理 1</code>，在每次分配后更新簇群的众数。</li><li><code>Step.03</code>：当所有对象分配到具体的簇群之后，重新测试对象与当前众数的相异性。如果找到一个对象，距离其最近的众数属于另一个簇群而不是当前的簇群，则将该对象重新分配给该簇群，并更新两个簇群的众数。</li><li><p><code>Step.04</code>：重复执行 <code>Step.03</code>，直到对整个数据集进行完整的循环测试之后，没有对象更改簇群。</p><blockquote><p>目前，虽没有证明该算法的收敛性，但在实际使用过程中，它的表现总是收敛的。</p></blockquote></li></ul></li><li><p>与 K-Means 算法一样，K-Modes 算法也是产生 <code>局部最优解</code>，且依赖于数据集中的 <code>初始的众数</code> 和 <code>对象的顺序</code>。考虑 <code>初始的众数</code> 和 <code>对象的顺序</code> 的因素影响，我们通过两种方法改进算法。</p><ul><li>第一个方法是第一次从数据集中选择 $k$ 个不同的记录作为初始 $k$ 个众数值。</li><li><p>第二个方法通过以下步骤实现：</p><ul><li><code>Step.01</code>：计算所有属性的所有标称值的频率，并按照频率的降序将它们存储在一个标称类型的数组中，如图 2-1 所示，展示了标称类型数组中，分别包含 4、2、5、3 个标称值的 4 个属性。这里 $c_{i,j}$ 表示属性 $i$ 的标称值 $j$，$f(c_{i,j})$ 为标称值的频率，且 $f(c_{i,j}) \geq f(c_{i+1,j})$。</li><li><code>Step.02</code>：将频率最高的标称值作为 $k$ 个众数的初始值。</li><li><p><code>Step.03</code>：从 $Q_1$ 开始，选择相似性最接近其的记录并替换它的初始众数。以此类推，直至 $Q_k$  的初始众数被替换完成。其中，$Q_l \neq Q_t \, for \, l \neq t$。</p><blockquote><p><code>Step.03</code> 的目的在于避免空簇群的情况，致使初始众数具有多样性，以获得更好的聚类结果。</p></blockquote></li></ul><script type="math/tex; mode=display">\begin{Bmatrix} c_{1,1} & c_{1,2} & c_{1,3} & c_{1,4} \\ c_{2,1} & c_{2,2} & c_{2,3} & c_{2,4} \\ c_{3,1} & \, & c_{3,3} & c_{3,4} \\ c_{4,1} & \,  & c_{4,3} & \, \\ \,  & \,  & c_{5,3} & \, \\ \end{Bmatrix}</script><center>图 2-1 标称类型数组 ( 横向表示集合的属性 A，纵向表示簇中心点 Q )</center></li></ul></li></ul><h3 id="K-Prototypes-算法"><a href="#K-Prototypes-算法" class="headerlink" title="K-Prototypes 算法"></a>K-Prototypes 算法</h3><ul><li><p>将 K-Means 和 K-Modes 算法集成到 K-Prototypes 算法中是很容易的，这种算法用于混合类型对象的簇群聚类。</p></li><li><p>在混合对象 $X$ 和 $Y$ 间的相异性可由属性 $A_1^r, A_2^r, …, A_p^r, A_{p+1}^c, …, A_m^c$ 描述，并定义其相异性度量为：</p><script type="math/tex; mode=display">  d_2(X,Y) = \sum_{j=1}^p (x_j - y_j)^2 + \gamma \sum_{j=p+1}^m \delta(x_j,y_j)  \tag{10}</script><blockquote><p>其中，第一项是数值属性的平方欧氏距离度量，第二项是标称属性的相异性度量。权重 $\gamma$ 是用来避免偏袒任何类型的属性，即聚类结果更趋向于数值属性还是标称属性。</p></blockquote></li><li><p>当公式 (10) 用作混合类型属性对象的相异性度量时，公式 (1) 的代价函数将推导为：</p><script type="math/tex; mode=display">  P(W,Q) = \sum_{l=1}^k (      \sum_{i=1}^n w_{i,l} \sum_{j=1}^p(x_{i,j}-q_{l,j})^2      + \gamma \sum_{i=1}^n w_{i,l} \sum_{j=p+1}^m \delta(x_{i,j}-q_{l,j})  )  \tag{11}</script><blockquote><p>$ \sum_{i=1}^n w_{i,l}$ 即公式 (2) 所描述的，每个簇对象只对应一个簇中心。</p></blockquote><ul><li><p>为简化公式 (11)，让：</p><script type="math/tex; mode=display">P_l^r = \sum_{i=1}^n w_{i,l} \sum_{j=1}^p(x_{i,j}-q_{l,j})^2\tag{12}</script><script type="math/tex; mode=display">P_l^c =  \gamma \sum_{i=1}^n w_{i,l} \sum_{j=p+1}^m \delta(x_{i,j}-q_{l,j})\tag{13}</script></li><li><p>重写公式 (11)：</p><script type="math/tex; mode=display">P(W,Q) = \sum_{l=1}^k (P_l^r + P_l^c)\tag{14}</script></li></ul><ul><li>$P_l^r$ 和 $P_l^c$ 都是非负的，最小化 $P(W,Q)$ 等同于最小化 $P_l^r$ 和 $P_l^c$，$1 \leq l \leq k$。</li></ul></li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="1-距离函数"><a href="#1-距离函数" class="headerlink" title="1 距离函数"></a>1 距离函数</h3><p><code>距离函数</code>：关于数据点之间的距离函数，即数值属性刻画的对象相异性的距离度量。度量方法 $^{[1]}$ 包括闵可夫斯基距离 (闵氏距离)、欧几里得距离 (欧式距离) 和曼哈顿距离。</p><p>令 $i=(x_{i1},x_{i2},…,x_{ih})$ 和 $j=(x_{j1},x_{j2},…,x_{jh})$ 是两个被 h 个属性描述的对象。 </p><p>闵氏距离是欧式距离和曼哈顿距离的推广，定义如下：</p><script type="math/tex; mode=display">d(i, j) = \sqrt[h](    \sum_{f=1}^h |x_{if}-x_{jf}|^{h}),h \geq 1\tag{1}</script><ul><li>当 h = 1 时，它表示 <code>曼哈顿距离</code>，也称 <code>城市块</code> 距离 (城市两点之间的街区距离，如向南 2 个街区，横过 3 个街区，共计五个街区)，其定义如下：</li></ul><script type="math/tex; mode=display">d(i, j) = \sum_{f=1}^h |x_{if}-x_{jf}|,h \geq 1\tag{2}</script><ul><li>当 h = 2 时，它表示 <code>欧式距离</code>，也称 <code>直线或乌鸦飞行</code> 距离，其定义如下：</li></ul><script type="math/tex; mode=display">d(i, j) = \sqrt(\sum_{f=1}^h (x_{if}-x_{jf})^2),h \geq 1\tag{3}</script><ul><li>当 h = $\infty$ 时，它表示 <code>上确界距离</code>，又称 <code>切比雪夫距离</code>，其定义如下L：</li></ul><script type="math/tex; mode=display">d(i, j) = \lim_{h \to \infty} (    \sum_{f=1}^h |x_{if}-x_{jf}|^h)^\frac{1}{h} = max_{f}^h |x_{if}-x_{jf}|\tag{4}</script><h3 id="2-定理证明"><a href="#2-定理证明" class="headerlink" title="2 定理证明"></a>2 定理证明</h3><p><code>定理 1</code> 的证明如下：</p><ul><li>让 $f_r (A_j = c_{k,j} | X) = \frac { n_{c_{k,j}} }{n}$ 为属性 $A_j$ 的第 $k$ 个标称属性 $c_{k,j}$ 的相对频率，$n$ 是 $X$ 中对象的总数，$n_{C_{k,j}}$ 是拥有标称属性 $c_{k,j}$ 的对象的计数。</li><li>则有，相异性度量公式可推导为：</li></ul><script type="math/tex; mode=display">\sum_{i=1}^n d(X_i,Q) = \sum_{i=1}^n \sum_{j=1}^m \delta(x_{i,j},q_j)\\ = \sum_{i=1}^n ( \sum_{j=1}^m \delta(x_{i,j},q_j) )= \sum_{i=1}^m n(1-\frac{n_{q_j}}{n})= \sum n( 1-f_r(A_j = q_j | X) )</script><ul><li>因为 $n( 1-f_r(A_j = q_j | X) ) \geq 0 \, , \, 1 \leq j \leq m$，若让 $\sum_{i=1}^n  d(X_i,Q)$ 最小化，则需让每一个 $n( 1-f_r(A_j = q_j | X) )$ 取最小值，即 $f_r(A_j = q_j | X)$ 必须取最大值。</li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] Jiewei Han, Micheline Kamber and Jian Pei. 数据挖掘 (第三版) [M]. 机械工业出版社, 2018, 48-49.<br>[2] Bezdek J C. A convergence theorem for the fuzzy ISODATA clustering algorithms [J]. IEEE transactions on pattern analysis and machine intelligence, 1980 (1): 1-8.<br>[3] Ismail M A, Selim S Z. Fuzzy c-means: optimality of solutions and effective termination of the algorithm[J]. Pattern recognition, 1986, 19(6): 481-485.<br>[4] Park H S, Jun C H. A simple and fast algorithm for K-medoids clustering[J]. Expert systems with applications, 2009, 36(2): 3336-3341.  </p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;原文：Extensions to the k-means algorithm for clustering large datasets with categorical values&lt;br&gt;作者：ZHEXUE HUANG.&lt;br&gt;来源：Data mining and knowledge discovery, 1998, 2(3): 283-304.  &lt;/p&gt;&lt;/div&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;在早期，大多数聚类工作主要集中在数值数据上，且它们主要是利用数值数据的固有几何特性，即数据点之间的 &lt;code&gt;距离函数&lt;/code&gt; (&lt;a href=&quot;#1-距离函数&quot;&gt;见附录1&lt;/a&gt;)。但是，数据挖掘应用程序通常涉及许多数据集，这些数据集是由混合数值属性和标称属性组成的，仅拥有数值数据的测量方法已无法满足混合数据类型的聚类工作。&lt;/p&gt;
&lt;p&gt;本论文基于经典的 K-Means 算法上，提出了两种聚类算法，分别应对 &lt;code&gt;标称域&lt;/code&gt; 和 &lt;code&gt;混合数值与标称域&lt;/code&gt; 属性值的聚类操作。首先介绍的是&lt;code&gt;K-Modes (K-众数)&lt;/code&gt; 聚类算法，他运作的方式与 K-Means 相仿，只是它利用的是相异性度量处理标称对象，聚类中心以众数替代均值，且众数以基于频率的方法去迭代更新，直至 &lt;code&gt;聚类代价函数&lt;/code&gt; 的结果最小化停止迭代。其次，是 &lt;code&gt;K-Prototype&lt;/code&gt; 聚类算法，它定义了一组合的相异性度量值，进一步整合 &lt;code&gt;K-Means&lt;/code&gt; 和 &lt;code&gt;K-Modes&lt;/code&gt; 算法，以实现对混合数值与标称属性的对象进行聚类操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Paper" scheme="http://www.kofes.cn/categories/Paper/"/>
    
    
      <category term="数据挖掘" scheme="http://www.kofes.cn/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="聚类" scheme="http://www.kofes.cn/tags/%E8%81%9A%E7%B1%BB/"/>
    
      <category term="机器学习" scheme="http://www.kofes.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="混合类型" scheme="http://www.kofes.cn/tags/%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="K-Means" scheme="http://www.kofes.cn/tags/K-Means/"/>
    
  </entry>
  
</feed>
