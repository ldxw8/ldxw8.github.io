<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="数据库,MySQL,架构,索引,">





  <link rel="alternate" href="/atom.xml" title="Kofe" type="application/atom+xml">






<meta name="description" content="遵循“先抽象后具体，先软件后硬件”原则，通过数据库结构设计、SQL 优化、存储引擎、操作系统以及服务器硬件等方面，设计方案以优化数据库性能。">
<meta name="keywords" content="数据库,MySQL,架构,索引">
<meta property="og:type" content="article">
<meta property="og:title" content="扛得住的 MySQL 数据库性能优化">
<meta property="og:url" content="http://www.kofes.cn/2022/06/mysql-architect.html">
<meta property="og:site_name" content="Kofe">
<meta property="og:description" content="遵循“先抽象后具体，先软件后硬件”原则，通过数据库结构设计、SQL 优化、存储引擎、操作系统以及服务器硬件等方面，设计方案以优化数据库性能。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.kofes.cn/images/CS/MySQL-Architect/MySQL-Architecture-RAID.svg">
<meta property="og:image" content="http://www.kofes.cn/images/CS/MySQL-Architect/MySQL-Architecture-BTree-B+Tree.svg">
<meta property="og:image" content="http://www.kofes.cn/images/CS/MySQL-Architect/MySQL-Architecture-BTree-B+Tree.svg">
<meta property="og:image" content="http://www.kofes.cn/images/CS/MySQL-Architect/MySQL-Architecture-MyISAM-MainIndex.svg">
<meta property="og:image" content="http://www.kofes.cn/images/CS/MySQL-Architect/MySQL-Architecture-MyISAM-SecondaryIndex.svg">
<meta property="og:image" content="http://www.kofes.cn/images/CS/MySQL-Architect/MySQL-Architecture-InnoDB-MainIndex.svg">
<meta property="og:image" content="http://www.kofes.cn/images/CS/MySQL-Architect/MySQL-Architecture-InnoDB-SecondaryIndex.svg">
<meta property="og:image" content="http://www.kofes.cn/images/CS/MySQL-Architect/MySQL-Architecture-Sharding-Horizontal.svg">
<meta property="og:image" content="http://www.kofes.cn/images/CS/MySQL-Architect/MySQL-Architecture-Sharding-Vertical.svg">
<meta property="og:updated_time" content="2023-02-15T06:35:23.910Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="扛得住的 MySQL 数据库性能优化">
<meta name="twitter:description" content="遵循“先抽象后具体，先软件后硬件”原则，通过数据库结构设计、SQL 优化、存储引擎、操作系统以及服务器硬件等方面，设计方案以优化数据库性能。">
<meta name="twitter:image" content="http://www.kofes.cn/images/CS/MySQL-Architect/MySQL-Architecture-RAID.svg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.kofes.cn/2022/06/mysql-architect.html">





  <title>扛得住的 MySQL 数据库性能优化 | Kofe</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?79b30ca99079b04e5fbf1ad6164bf0c1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kofe</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Reading / Project / Paper</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.kofes.cn/2022/06/mysql-architect.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kofe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/profile/society_face_version_1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kofe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">扛得住的 MySQL 数据库性能优化</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-06-03T00:12:59+08:00">
                2022-06-03
              </time>
            

            

            
          </span>


	  
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2023-02-15T14:35:23+08:00" content="2023-02-15">
                2023-02-15
              </time>
            </span>
          


          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Project/" itemprop="url" rel="index">
                    <span itemprop="name">Project</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2022/06/mysql-architect.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2022/06/mysql-architect.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2022/06/mysql-architect.html" class="leancloud_visitors" data-flag-title="扛得住的 MySQL 数据库性能优化">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9,284
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>遵循“先抽象后具体，先软件后硬件”原则，通过数据库结构设计、SQL 优化、存储引擎、操作系统以及服务器硬件等方面，设计方案以优化数据库性能。</p>
<a id="more"></a>
<h2 id="数据库性能分析"><a href="#数据库性能分析" class="headerlink" title="数据库性能分析"></a>数据库性能分析</h2><ul>
<li>数据库性能优化顺序：原则是先抽象后具体，先软件后硬件。<ul>
<li>Case.01：数据库结构设计与 SQL 优化</li>
<li>Case.02：存储引擎选型</li>
<li>Case.03：操作系统选型</li>
<li>Case.04：服务器硬件升级</li>
</ul>
</li>
</ul>
<h3 id="数据库结构设计"><a href="#数据库结构设计" class="headerlink" title="数据库结构设计"></a>数据库结构设计</h3><ul>
<li>过分的范式化设计会造成太多表关联，影响查询效率。过分的反范式化设计会造成表中太多冗余列。在项目当中要以实际场景出发合理设计数据表。</li>
<li>避免在 OLTP 环境中使用不恰当的分区表。</li>
<li>使用外键保证了数据完整性，但对于表维护等操作的效率影响是尤为明显的。</li>
</ul>
<h3 id="数据库存储引擎"><a href="#数据库存储引擎" class="headerlink" title="数据库存储引擎"></a>数据库存储引擎</h3><ul>
<li><p>围绕事务、备份、锁粒度等方面选择合适的数据库存储引擎。</p>
<blockquote>
<p>MySQL 如何选择合适的存储引擎：<a href="#存储引擎">存储引擎</a></p>
</blockquote>
</li>
</ul>
<h3 id="服务器硬件"><a href="#服务器硬件" class="headerlink" title="服务器硬件"></a>服务器硬件</h3><h4 id="CPU-方案"><a href="#CPU-方案" class="headerlink" title="CPU 方案"></a>CPU 方案</h4><ul>
<li>对于高并发场景，CPU 多核心数量比 CPU 单核心频率更重要。</li>
<li>对于复杂 SQL 以及 CPU 密集型场景，CPU 单核心频率更重要。</li>
</ul>
<h4 id="内存方案"><a href="#内存方案" class="headerlink" title="内存方案"></a>内存方案</h4><ul>
<li>理论上，内存大小、内存频率的选型方案以硬件支持的最大性能输出最好。</li>
</ul>
<h4 id="磁盘方案"><a href="#磁盘方案" class="headerlink" title="磁盘方案"></a>磁盘方案</h4><ul>
<li><p>使用 RAID 增强传统机械硬盘性能：磁盘冗余阵列（RAID），利用多块磁盘实现数据的并发读写和数据备份，主要为了改善磁盘的访问延迟，增加磁盘的可用性和容错能力。</p>
  <blockquote class="blockquote-center"><p><img src="/images/CS/MySQL-Architect/MySQL-Architecture-RAID.svg" alt>  RAID</p>
</blockquote>
<ul>
<li><p>RAID 0：根据磁盘将数据分为 n 份，数据同时并发写入 n 快磁盘，使得数据整体写入速度是一块磁盘的 n 倍。同理，RAID 0 也具有极速的读速度。</p>
<blockquote>
<p>但 RAID 0 不做数据备份，n 块硬盘中只要有一块损坏，数据完整性即被破环，所有磁盘的速度都会损坏。</p>
</blockquote>
</li>
<li><p>RAID 1：一份数据同时写入两块硬盘，这样任何一块硬盘损坏都不会导致数据丢失，插入一块新磁盘可通过复制数据方式自动修复。</p>
</li>
<li><p>RAID 10：将所有磁盘平均分成两份，数据同时在两份磁盘写入（相当与 RAID 1）。但每一份数据在 n/2 块磁盘上，利用 RAID 0 技术并发读写。</p>
<blockquote>
<p>结合 RAID 0 和 RAID 1 两种方案，但 RAID 10 磁盘利用率较低（一半磁盘用来备份数据）。</p>
</blockquote>
</li>
<li><p>RAID 3：一般情况，一台服务器不会同时损坏两块磁盘的情况（物理因素除外），假设在只损坏一块磁盘情况下，利用其他磁盘的数据回复损坏磁盘的数据，即保证了可靠性和性能，同时提升了磁盘利用率。</p>
<p>  将数据分成 n-1 份，并发写入 n-1 块磁盘，并在第 n 块磁盘记录校验数据，任何一块磁盘损坏（包含校验数据磁盘），都可利用其他 n-1 块磁盘恢复数据。</p>
</li>
<li><p>RAID 5：原理与 RAID 3 相似，但校验数据不是写入第 n 块磁盘，而是螺旋式地写入所有磁盘中。即检验数据也平均到所有磁盘上，避免了频繁写坏一块磁盘。</p>
</li>
<li><p>RAID 6：原理与 RAID 3 相似，数据写入 n-2 块磁盘中，并螺旋式地在两块磁盘中写入校验信息（使用不同算法生成）。</p>
</li>
</ul>
</li>
<li><p>使用固态存储 SSD 与 PCIe 卡</p>
<ul>
<li>较于机械磁盘有较好随机读写性能</li>
<li>解决单线程负载 I/O 性能瓶颈问题</li>
</ul>
</li>
<li><p>使用网络存储 NAS 与 SAN：两种外部文件存储设备加载到服务器上的方法</p>
<ul>
<li>NAS（Network-Attached Storage）：NAS 设备使用标准以太网连接，NAS 通过基于文件协议来访问数据，比如 NFS / SMB 协议。</li>
<li><p>SAN（Storage Area Network）：SAN 设备通过光纤连接，SAN 在块级别存储数据。</p>
<blockquote>
<p>通俗理解，SAN 是网络上的硬盘，NAS 则是网络上的文件系统。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="数据库结构设计-1"><a href="#数据库结构设计-1" class="headerlink" title="数据库结构设计"></a>数据库结构设计</h2><h3 id="设计的目的"><a href="#设计的目的" class="headerlink" title="设计的目的"></a>设计的目的</h3><ul>
<li><p>尽量避免数据维护中出现更新、插入以及删除异常。</p>
  <table>
      <thead>
          <tr>
              <th>学号</th>
              <th>姓名</th>
              <th>年龄</th>
              <th>课程号</th>
              <th>课程</th>
              <th>学分</th>
          </tr>
      </thead>
      <tbody>
          <tr>
              <td>1</td>
              <td>张三</td>
              <td>20</td>
              <td>C1</td>
              <td>马克思基本原理概论</td>
              <td>3.0</td>
          </tr>
          <tr>
              <td>2</td>
              <td>张三</td>
              <td>20</td>
              <td>C2</td>
              <td>数据结构</td>
              <td>5.0</td>
          </tr>
          <tr>
              <td>3</td>
              <td>李四</td>
              <td>21</td>
              <td>C3</td>
              <td>高等数学</td>
              <td>5.0</td>
          </tr>
          <tr>
              <td>4</td>
              <td>王五</td>
              <td>19</td>
              <td>C2</td>
              <td>数据结构</td>
              <td>5.0</td>
          </tr>
      </tbody>
  </table>

<ul>
<li><p>插入异常：表中某个实体随着另一个实体而存在。</p>
<blockquote>
<p>比如：插入一门新课程 (C4, 论文写作, 2.0)，但此课程并暂没有学生选修，此时会报 “ ‘学号’ doesn’t have a default value” 异常。</p>
</blockquote>
</li>
<li><p>更新异常：更改表中某个实体的单独属性时，需对多行进行更新。</p>
<blockquote>
<p>比如：修改课程 “数据结构” 的学分为 4.5，则多条数据更新异常。</p>
</blockquote>
</li>
<li><p>删除异常：删除表中某一实体则会导致其他实体消失。</p>
<blockquote>
<p>比如：删除 “学号=4” 的记录，”高等数学” 这门课随之删除。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>减少数据冗余</p>
</li>
<li><p>提高查询效率</p>
</li>
<li><p>节省存储空间</p>
</li>
</ul>
<h3 id="设计的步骤"><a href="#设计的步骤" class="headerlink" title="设计的步骤"></a>设计的步骤</h3><ul>
<li>需求分析：存储需求、数据处理需求、数据的安全性以及完整性</li>
<li>逻辑设计：设计数据的逻辑存储结构<ul>
<li>数据实体之间的逻辑关系，解决数据冗余和数据维护异常</li>
<li>范式设计准则</li>
</ul>
</li>
<li>物理设计：根据所使用的数据库特征进行表结构设计</li>
<li>维护优化：索引、存储结构优化等</li>
</ul>
<h3 id="范式设计"><a href="#范式设计" class="headerlink" title="范式设计"></a>范式设计</h3><h4 id="范式化设计"><a href="#范式化设计" class="headerlink" title="范式化设计"></a>范式化设计</h4><ul>
<li>第一范式（1NF）：<ul>
<li>属性不可分，即数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。</li>
<li>单一属性列由基本的数据类型所构成。</li>
</ul>
</li>
<li><p>第二范式（2NF）：</p>
<ul>
<li>表中只具有一个主键。</li>
<li><p>每个非主属性完全函数依赖于键码，而不能存在非主属性部分依赖于键码。</p>
<blockquote>
<p>比如，复合主键中常包括两种实体，如上述例子中的学生实体与课程实体，它们各自的属性依赖于各实体的主键。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>第三范式（3NF）：</p>
<ul>
<li><p>非主属性即不部分依赖，也不传递函数依赖于键码。</p>
<blockquote>
<p>简而言之，第三范式就是属性不依赖于其它非主属性。</p>
</blockquote>
</li>
<li><p>上述的关系中存在以下传递函数依赖：学号 $\to$ 课程 $\to$ 学分。</p>
</li>
</ul>
</li>
</ul>
<h4 id="反范式设计"><a href="#反范式设计" class="headerlink" title="反范式设计"></a>反范式设计</h4><ul>
<li>反范式化：鉴于性能和读取效率考量，适当违反数据库范式设计要求，允许少量数据冗余。</li>
<li><p>优劣比较</p>
  <table>
      <thead>
          <tr>
              <th>优劣</th>
              <th>范式化</th>
              <th>反范式化</th>
          </tr>
      </thead>
      <tbody>
          <tr>
              <td>优势</td>
              <td>1) 可尽量减少数据冗余<br>2) 更新操作较反范式化快</td>
              <td>1) 减少表关联查询<br>2) 更好进行索引优化</td>
          </tr>
          <tr>
              <td>劣势</td>
              <td>1) 多表关联查询<br>2) 难以进行索引优化</td>
              <td>1) 存在数据冗余及数据维护异常</td>
          </tr>
      </tbody>
  </table>

</li>
</ul>
<h3 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h3><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><ul>
<li><p>选择合适的存储引擎</p>
  <table>
      <thead>
          <tr>
              <th>存储引擎</th>
              <th>事务</th>
              <th>锁粒度</th>
              <th>忌用</th>
          </tr>
      </thead>
      <tbody>
          <tr>
              <td>MyISAM</td>
              <td>不支持</td>
              <td>支持并发插入的表级锁</td>
              <td>读写操作频繁</td>
          </tr>
          <tr>
              <td>Innodb</td>
              <td>支持</td>
              <td>行级锁</td>
              <td>--</td>
          </tr>
          <tr>
              <td>Archive</td>
              <td>不支持</td>
              <td>支持并发插入的表级锁</td>
              <td>随时读取、更新、删除</td>
          </tr>
          <tr>
              <td>Ndb Cluster</td>
              <td>支持</td>
              <td>行级锁</td>
              <td>--</td>
          </tr>
      </tbody>
  </table>
</li>
<li><p>InnoDB</p>
<ul>
<li>MySQL 默认的事务型存储引擎，只有在它不支持某些特性时，才考虑其它存储引擎。</li>
<li>实现了四个标准的隔离级别，默认级别是可重复读 (REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制 (MVCC) + Next-Key Locking 防止幻影读。</li>
<li><p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<blockquote>
<p>聚簇与非聚簇的区别在于：数据文件与索引文件是否分开存储。比如非聚簇索引，索引文件的叶子节点的 data 域仅保存数据记录地址。</p>
</blockquote>
</li>
<li><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
</li>
<li>支持真正的 <code>在线热备份</code>。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</li>
</ul>
</li>
<li><p>MyISAM</p>
<ul>
<li>管理非事务表，是 ISAM (Indexed Sequential Access Method，有索引的顺序访问方法) 的扩展格式。</li>
<li>不是事务安全的，且不支持外键。</li>
<li>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入。</li>
<li>可手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</li>
</ul>
</li>
</ul>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul>
<li><p>整数类型</p>
<table>
    <thead>
        <tr>
            <th>描述</th>
            <th>列类型</th>
            <th>存储空间</th>
            <th width="30%">显示宽度（默认值 M）</th>
            <th width="30%">取值范围</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>标准整型</td>
            <td>int</td>
            <td>4 字节</td>
            <td>int(11)</td>
            <td>有符号：[-2^{31},  2^{31}-1]<br>无符号：[0,  2^{32}]</td>
        </tr>
        <tr>
            <td>大整型</td>
            <td>bigint</td>
            <td>8 字节</td>
            <td>int(20)</td>
            <td>有符号：[-2^{63},  2^{63}-1]<br>无符号：[0,  2^{64}]</td>
        </tr>
    </tbody>
</table>


</li>
</ul>
<ul>
<li>显示宽度和数据类型的取值范围是没有任何关系的，显示宽度指 MySQL 最大可能显示的数字个数，数值位数小于指定宽度时由空格填充。</li>
<li>若插入大于显示宽度的值，只要该值不超过该类型的取值范围，数值依然可以插入。</li>
</ul>
<ul>
<li><p>浮点类型</p>
<table>
    <thead>
        <tr>
            <th>描述</th>
            <th>列类型</th>
            <th width="25%">存储空间</th>
            <th width="25%">显示宽度（默认值 M）</th>
            <th>取值范围</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>定点数</td>
            <td>decimal</td>
            <td>9 个数 / 4 字节<br>小数点占 1 字节</td>
            <td>decimal(10, 0)</td>
            <td>--</td>
        </tr>
    </tbody>
</table>


</li>
</ul>
<ul>
<li>整个数字长度 M = 小数点左边位数 + 小数点右边位数 D，但不包括负号</li>
</ul>
<ul>
<li><p>字符类型</p>
  <table>
      <thead>
          <tr>
              <th>描述</th>
              <th>列类型</th>
              <th>存储空间</th>
              <th>取值范围</th>
          </tr>
      </thead>
      <tbody>
          <tr>
              <td>固定长度字符串</td>
              <td>char</td>
              <td>255 字符</td>
              <td>[0, 2^8-1]</td>
          </tr>
          <tr>
              <td>可变长度字符串</td>
              <td>text</td>
              <td>65535 字符</td>
              <td>[0, 2^{16}-1</td>
          </tr>
          <tr>
              <td>非二进制字符串</td>
              <td>varchar</td>
              <td>65535 字符</td>
              <td>[0, 2^{16}-1</td>
          </tr>
          <tr>
              <td>二进制大对象</td>
              <td>blob</td>
              <td>--</td>
              <td>[0, 2^{16}-1</td>
          </tr>
      </tbody>
  </table>

<ul>
<li>使用比较运算符比较 char 值时，MySQL 不会考虑尾随空格，例如：=，&lt;&gt;，&gt;，&lt; 等。</li>
<li>当使用模式匹配检索 char 值时，LIKE 运算符会考虑尾随空格。</li>
</ul>
</li>
<li><p>日期类型</p>
  <table>
      <thead>
          <tr>
              <th>列类型</th>
              <th>存储空间</th>
              <th>取值范围</th>
          </tr>
      </thead>
      <tbody>
          <tr>
              <td>date</td>
              <td>3 字节</td>
              <td>[0000-01-01, 9999-12-31]</td>
          </tr>
          <tr>
              <td>datetime</td>
              <td>8 字节</td>
              <td>YYYY-MM-DD HH:MM:SS</td>
          </tr>
      </tbody>
  </table>

<ul>
<li>[注意] 原则上不要使用字符串类型存储日期/时间数据！</li>
</ul>
</li>
</ul>
<h2 id="数据库索引优化"><a href="#数据库索引优化" class="headerlink" title="数据库索引优化"></a>数据库索引优化</h2><h3 id="索引的数理基础"><a href="#索引的数理基础" class="headerlink" title="索引的数理基础"></a>索引的数理基础</h3><h4 id="B-Tree-amp-B-Tree"><a href="#B-Tree-amp-B-Tree" class="headerlink" title="B-Tree &amp; B+Tree"></a>B-Tree &amp; B+Tree</h4><h5 id="引入背景"><a href="#引入背景" class="headerlink" title="引入背景"></a>引入背景</h5><ul>
<li>区别于动态查找算法，它们都是在内存中进行的，适用于小规模文件查找。B-Tree/B+Tree 则适用于磁盘等直接存取的设备上组织动态查找。</li>
<li><p>B-Tree/B+Tree 多应用于数据库索引中，而数据库索引是存储在磁盘的索引文件上的。</p>
<ul>
<li>当数据量较大时，整个索引无法全部加载至内存中，只能逐一加载每一个磁盘页（对应索引树的节点）。</li>
<li><p>换句话说，数据库索引利用磁盘预读原理，把一个 B-Tree/B+Tree 节点大小刚好设为一个页的大小，这样一个树结点只需一次 I/O 即可完成加载。为此，检索目标一次最多需要访问 h 个结点（h 次 I/O 操作）。</p>
<blockquote>
<p>对于 B-Tree/B+Tree 的数据结构来说，树的高度可代表 I/O 次数，而 “矮胖” 就是 B-Tree/B+Tree 的阶，阶的大小取决于磁盘页的大小。</p>
</blockquote>
<blockquote class="blockquote-center"><p><img src="/images/CS/MySQL-Architect/MySQL-Architecture-BTree-B+Tree.svg" alt> B 树与 B+树</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ul>
<li><a href>维基百科. B+树. zh.wikipedia.org</a></li>
<li><a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">Nullzx. B 树和 B+ 树的插入删除图文详解. cnblogs.com</a></li>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">CodingLabs. MySQL索引背后的数据结构及算法原理. CodingLabs.org</a></li>
</ul>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h5><ul>
<li><p>B-Tree（Balanced Tree），一种 <code>平衡</code> 的多路查找树，它或是一棵空树，或满足下列特性的 m 叉树（$m \geq 3$）：</p>
<ul>
<li>树中每个结点至多有 m 棵子树；</li>
<li>树中非叶子结点至少有两棵子树；</li>
<li>除根结点与叶子结点外，至少有 $\lceil m/2 \rceil$ 棵子树；</li>
<li><p>每个结点的关键字个数 = ${ n \, | \, \lceil m/2 \rceil \leq n \leq m-1 }$；</p>
<blockquote>
<p>1) 根结点至少可以有一个关键字，即关键字个数 = ${ n \, | \, 1 \leq n \leq m-1 }$。<br>2) 当结点的关键字数量大于等于 m-1 时，则触发结点分裂过程，以结点中间的关键字为中心分裂成左右两部分。</p>
</blockquote>
</li>
<li><p>每个结点中的关键字都按照从小到大排序，每个结点的关键字的左子树中所有关键字都小于它，而右子树中所有关键字都大于它。</p>
</li>
<li><p>所有叶子结点都位于同一层，或者说根到每个叶子结点的长度都相同。</p>
<blockquote>
<p>在实际应用中，B-Tree 的阶数 m 通常很大（$m \geq 100$），即使存储大量数据 B-Tree 高度仍然很小。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h5><ul>
<li><p>B+Tree 是 B-Tree 的一种变形形式，一棵 m 阶的 B+Tree 定义如下： </p>
<ul>
<li>树中每个结点至多有 m 棵子树；</li>
<li>若根结点而非叶子结点，则至少有两棵子树；</li>
<li><p>除根结点与叶子结点外，至少有 $\lceil m/2 \rceil$ 棵子树；</p>
<ul>
<li><p>每个结点的关键字个数比它的孩子结点个数少 1；</p>
<blockquote>
<p>各种资料上对于 B+Tree 结点的关键字个数定义不同，这里取 Wikipedia 的定义（也可以同步 B-Tree 的关键字个数定义）。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>所有叶子结点包含了全部关键字及相应记录的存储地址，按照从小到大的顺序排序，并存放在同一层的叶子节点中，而且叶子节点以指针进行链接。</p>
</li>
<li>所有 <code>非叶子结点</code> 仅起到 <code>索引作用</code>，即结点中的每一个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</li>
</ul>
</li>
</ul>
<h5 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h5><ul>
<li>对于 <code>范围查找</code> 来说，B+Tree 只需 <code>遍历叶子节点链表</code> 即可，B-Tree 却需要重复地 <code>中序遍历整棵树</code>。</li>
<li>B+Tree 只有叶子结点存储数据，非叶子结点只起到索引作用；B-Tree 的所有结点都存储数据。</li>
</ul>
<h4 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h4><ul>
<li>B-Tree (平衡树, Balance Tree)：也称为 <code>多路平衡查找树</code>，并且所有叶子节点位于同一层。</li>
<li><p>B+Tree：</p>
<ul>
<li>它不仅具有 B-Tree 的平衡性，并且可通过 <code>顺序访问指针</code> 来提高 <code>区间查询</code> 的性能。</li>
<li>在 B+Tree 中，一个节点中的 key 从左到右非递减排列，若某个指针的 $key<em>i$ 左右相邻分别是 $key</em>{i-1}$ 和 $key<em>{i+1}$，且不为 null，则该指针指向节点的所有 key 满足 $key</em>{i-1} \leq key<em>i \leq key</em>{i+1}$。</li>
<li><p>B+Tree 与 B-Tree 最大区别是，B+Tree 的非叶子结点不保存数据，只用于索引，所有数据都保存在叶子结点中。而且叶子结点间按照从小到大顺序链接起来。如图 3-1 (b) 所示的为一棵 B+Tree。</p>
<blockquote class="blockquote-center"><p><img src="/images/CS/MySQL-Architect/MySQL-Architecture-BTree-B+Tree.svg" alt> B 树与 B+树</p>
</blockquote>
</li>
</ul>
</li>
<li><p>B-Tree/B+Tree 的增删改查：</p>
<ul>
<li><p><code>查找操作</code>：首先在<code>根节点</code>进行 <code>二分查找</code>，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在 <code>叶子节点</code> 上进行 <code>二分查找</code>，找出 key 所对应的 data。</p>
<blockquote>
<p>二分查找要求表有序，正好 B-Tree 和 B+Tree 结点中的 key 从左到右非递减有序排列。</p>
</blockquote>
</li>
<li><p><code>增删操作</code>：会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。</p>
</li>
</ul>
</li>
</ul>
<h4 id="红黑树方案考量"><a href="#红黑树方案考量" class="headerlink" title="红黑树方案考量"></a>红黑树方案考量</h4><p>同样是平衡树，红黑树（自平衡的二叉树）也可以用来实现索引。但在文件系统及数据库系统中，普遍采用 B+Tree 作为索引结构，主要有以下两个原因：</p>
<ul>
<li><p><code>更少的查找次数</code>：平衡树查找操作的时间复杂度和树高 $h$ 相关，$O(h)=O(log_dN)$，其中 d 为每个节点的出度，即 <code>d叉树的阶</code>。红黑树的出度 d 为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大，查找的次数也就大。</p>
</li>
<li><p><code>利用磁盘预读特性</code>：</p>
<blockquote>
<p>存储器原理解释推荐阅读：<a href="https://wdxtub.com/csapp/thin-csapp-3/2016/04/16/#概念学习" target="_blank" rel="noopener">小土刀. 读薄CSAPP-内存与缓存. wdxtub.com</a></p>
</blockquote>
<ul>
<li>索引本身也很大，不可能全部存储在内存中，为此索引往往以索引文件的形式存储的磁盘上。索引查找过程中就要产生磁盘I/O消耗，即索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。</li>
<li>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会 <code>预读</code>。</li>
<li><p>预读过程中，即使只需一个字节，磁盘也是从这个位置开始，向后 <code>顺序读取</code> 一定长度的数据放入内存 (预读的长度一般为页的整倍数)。</p>
<blockquote>
<p>顺序读取不需要进行 <code>磁盘寻道</code>，只需要很短的磁盘旋转时间。</p>
</blockquote>
</li>
<li><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。</p>
<blockquote>
<p>页是计算机管理存储器的逻辑块。</p>
</blockquote>
</li>
<li><p>数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。这样一来，最多花费 h 次 I/O 操作即可检索到目标。</p>
</li>
</ul>
</li>
</ul>
<h4 id="索引的存取原理"><a href="#索引的存取原理" class="headerlink" title="索引的存取原理"></a>索引的存取原理</h4><ul>
<li>磁盘存取原理</li>
<li>局部性原理与磁盘预读</li>
</ul>
<h3 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h3><ul>
<li>索引，在 MySQL 也称为键（Key），是 <code>存储引擎</code> 快速找到记录的一种 <code>数据结构</code>。相当于图书的目录，可根据目录中的页码快速找到所需的内容。</li>
<li>索引，是 <code>存储引擎层</code> 的概念，所以不同存储引擎具有不同的索引类型和实现。下文主要以 MyISAM 和 InnoDB 两个存储引擎的索引实现方式展开讨论。</li>
</ul>
<h4 id="索引结构类型"><a href="#索引结构类型" class="headerlink" title="索引结构类型"></a>索引结构类型</h4><h5 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B+Tree 索引"></a>B+Tree 索引</h5><ul>
<li>B+Tree 索引是大多数 MySQL 存储引擎的默认索引类型。</li>
<li><p>InnoDB 的 B+Tree 索引分为 <code>主索引</code>（Primary key）和 <code>辅助索引</code>（Secondary key）。而且 InnoDB 的主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为 <code>聚簇索引</code>。</p>
<blockquote>
<p>MyISAM 的索引方式也叫做 <code>非聚集</code> 的。MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</p>
</blockquote>
</li>
<li><p>因为 B+ Tree 的 <code>有序性</code>，因此可用于 <code>部分查找</code>、<code>范围查找</code>、<code>排序</code> 和 <code>分组</code>。</p>
</li>
<li>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。若不是按照索引列的顺序进行查找，则无法使用索引。</li>
</ul>
<h5 id="Hash-索引"><a href="#Hash-索引" class="headerlink" title="Hash 索引"></a>Hash 索引</h5><ul>
<li><p>Hash 索引能以 O(1) 时间进行查找，但是失去了有序性。因此无法用于排序与分组，无法用于部分查找和范围查找，只支持 <code>精确查找</code>。</p>
<blockquote>
<p>Hash 索引仅满足 <code>=</code>，<code>IN</code> 和 <code>&lt;=&gt;</code> 查询，不能使用范围查询。因为 Hash 索引比较的是 Hash 运算后的 Hash 值，所以它只能用于等值的过滤。</p>
</blockquote>
</li>
<li><p>InnoDB 存储引擎有一个特殊的功能叫 <code>自适应哈希索引</code>，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
</li>
</ul>
<h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><ul>
<li>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</li>
<li>查找条件使用 <code>MATCH AGAINST</code>，而不是普通的 <code>WHERE</code>。</li>
<li>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</li>
<li>InnoDB 存储引擎在 <code>MySQL 5.6.4</code> 版本中也开始支持全文索引。</li>
</ul>
<h5 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h5><ul>
<li>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</li>
<li>必须使用 GIS 相关的函数来维护数据。</li>
</ul>
<h4 id="MyISAM-索引实现"><a href="#MyISAM-索引实现" class="headerlink" title="MyISAM 索引实现"></a>MyISAM 索引实现</h4><ul>
<li>MyISAM 引擎可使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址</li>
<li><p>MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。如图所示，为 MyISAM 的 B+Tree 主索引结构：</p>
  <blockquote class="blockquote-center"><p><img src="/images/CS/MySQL-Architect/MySQL-Architecture-MyISAM-MainIndex.svg" alt> MyISAM 的 B+Tree 主索引结构</p>
</blockquote>
<blockquote>
<p>这里假设表一共有三列，以 Col1 为主键，则上图是一个主索引示意图。</p>
</blockquote>
</li>
<li><p>在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复，比如在 Col2 上建立一个辅助索引，如图所示：</p>
  <blockquote class="blockquote-center"><p><img src="/images/CS/MySQL-Architect/MySQL-Architecture-MyISAM-SecondaryIndex.svg" alt> MyISAM 的 B+Tree 辅助索引结构</p>
</blockquote>
</li>
<li><p>MyISAM 的索引检索方法是按照 B+Tree 搜索算法实现的，若指定的 key 存在，则取出其 data 域的值，然后以 data 域的值为地址，再以地址读取相应数据记录。</p>
</li>
</ul>
<h4 id="InnoDB-索引实现"><a href="#InnoDB-索引实现" class="headerlink" title="InnoDB 索引实现"></a>InnoDB 索引实现</h4><ul>
<li>InnoDB 引擎也可使用 B+Tree 作为索引结构，在 InnoDB 中数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点 data 域保存了完整的数据记录。</li>
<li><p>InnoDB 的 B+Tree 主索引结构：索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引结构的。</p>
<ul>
<li>因 InnoDB 的数据文件本身要按主键聚集的，为此 InnoDB 要求表必须有主键。</li>
<li>若没有显式指定，则 MySQL 会自动选择一个可以唯一标识数据记录的列作为主键。</li>
<li><p>若不存在这种列，则 MySQL 会自动生成一个隐含字段作为主键（字段长度为 6 个字节，类型为长整型）。</p>
<blockquote class="blockquote-center"><p><img src="/images/CS/MySQL-Architect/MySQL-Architecture-InnoDB-MainIndex.svg" alt> InnoDB 的 B+Tree 主索引结构</p>
</blockquote>
</li>
</ul>
</li>
<li><p>InnoDB 的 B+Tree 辅助索引结构：索引 data 域存储相应记录主键的值而不是地址。换句话说，InnoDB 的所有辅助索引都引用主键作为 data 域。如图所示在 Col3 上的一个辅助索引：</p>
<blockquote>
<p>使用辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
</blockquote>
  <blockquote class="blockquote-center"><p><img src="/images/CS/MySQL-Architect/MySQL-Architecture-InnoDB-SecondaryIndex.svg" alt> InnoDB 的 B+Tree 辅助索引结构</p>
</blockquote>
</li>
</ul>
<h3 id="索引的优点缺点"><a href="#索引的优点缺点" class="headerlink" title="索引的优点缺点"></a>索引的优点缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>大大减少了服务器需要扫描的数据行数。</li>
<li><p>避免服务器进行排序和分组操作，以避免创建 <code>临时表</code>。</p>
<blockquote>
<p>B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表。</p>
</blockquote>
</li>
<li><p>将 <code>随机 I/O</code> 变为 <code>顺序 I/O</code>。</p>
<blockquote>
<p>B+Tree 索引是有序的，会将相邻的数据都存储在一起。</p>
</blockquote>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>索引并不是越多越好，索引固然可以提高相应的 SELECT 的效率，但同时也降低了 INSERT 及 UPDATE 的效率，因为 INSERT 或 UPDATE 时有可能会 <code>重建索引</code>。</li>
</ul>
<h3 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h3><blockquote>
<p>从索引的优、缺点考虑索引的设计原则。</p>
</blockquote>
<ul>
<li><code>忌过度索引</code>：索引需要额外的磁盘空间，而且会降低写操作的性能。<ul>
<li>在修改表内容时，索引会进行更新甚至重构，索引列越多花销时间越长。为此优化检索性能，只保持需要的索引即可。</li>
<li>经常用在 <code>排列</code>、<code>分组</code> 和 <code>范围搜索</code> 的列适合创建索引，因为索引是有序的。</li>
<li>经常出现在 <code>WHERE</code> 子句的列，或是 <code>JOIN</code> 连接子句中指定的列适合创建索引。</li>
</ul>
</li>
<li><code>使用短索引</code>：若对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间。</li>
</ul>
<h3 id="索引的优化策略"><a href="#索引的优化策略" class="headerlink" title="索引的优化策略"></a>索引的优化策略</h3><ul>
<li><p><code>独立的列</code>：在进行查询时，索引列不能是 <code>表达式</code> 的一部分，也不能是 <code>函数参数</code>，否则无法使用索引。例如下面的查询不能使用 actor_id 列的索引：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>多列索引</code>：在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_id <span class="keyword">FROM</span> sakila.film_actor</span><br><span class="line"><span class="keyword">WHERE</span> actor_id = <span class="number">1</span> <span class="keyword">AND</span> film_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>索引列的顺序</code>：让选择性最强的索引列放在前面。</p>
<blockquote>
<p>索引的选择性：不重复的索引值和记录总数的比值最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>
</blockquote>
<p>  例如，从下面显示的结果中可知，customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	<span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> StaffId,</span><br><span class="line">	<span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)/<span class="keyword">COUNT</span>(*)  <span class="keyword">AS</span> CustomerId,</span><br><span class="line">	<span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br><span class="line">	</span><br><span class="line"><span class="comment">-- StaffId: 0.0001</span></span><br><span class="line"><span class="comment">-- CustomerId: 0.0373</span></span><br><span class="line"><span class="comment">-- COUNT(*): 16049</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>前缀索引</code>：对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。前缀长度的选取需要根据索引选择性来确定。</p>
</li>
<li><code>覆盖索引</code>：索引包含所有需要查询的字段的值。具有以下优点：<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>
</li>
</ul>
<h3 id="索引的使用场景"><a href="#索引的使用场景" class="headerlink" title="索引的使用场景"></a>索引的使用场景</h3><ul>
<li>对于 <code>非常小的表</code>：大部分情况下简单的 <code>全表扫描</code> 比建立索引更高效；</li>
<li>对于 <code>中大型的表</code>：<code>建立索引</code> 非常有效；</li>
<li>对于 <code>特大型的表</code>：建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配。例如可以使用 <code>分区技术</code>。</li>
</ul>
<h3 id="创建与删除索引"><a href="#创建与删除索引" class="headerlink" title="创建与删除索引"></a>创建与删除索引</h3><ul>
<li><p>创建表时：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (</span><br><span class="line">	字段名<span class="number">1</span> 数据类型 [完整性约束条件…],</span><br><span class="line">	字段名<span class="number">2</span> 数据类型 [完整性约束条件…],</span><br><span class="line">	[<span class="keyword">UNIQUE</span> | FULLTEXT | SPATIAL] <span class="keyword">INDEX</span> | <span class="keyword">KEY</span></span><br><span class="line">	[索引名] (字段名[(长度)] [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>])</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>CREATE 在已存在的表上创建索引：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span> | FULLTEXT | SPATIAL] <span class="keyword">INDEX</span> 索引名 </span><br><span class="line"><span class="keyword">ON</span> 表名 (字段名[(长度)] [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]) ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ALTER TABLE 在已存在的表上创建索引：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span> | FULLTEXT | SPATIAL] <span class="keyword">INDEX</span></span><br><span class="line">索引名 (字段名[(长度)] [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]) ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除索引：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> 索引名 <span class="keyword">ON</span> 表名字;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="SQL-大查询优化"><a href="#SQL-大查询优化" class="headerlink" title="SQL 大查询优化"></a>SQL 大查询优化</h2><h3 id="使用-EXPLAIN-分析性能"><a href="#使用-EXPLAIN-分析性能" class="headerlink" title="使用 EXPLAIN 分析性能"></a>使用 EXPLAIN 分析性能</h3><ul>
<li><p>使用 EXPLAIN 关键字可以模拟执行 SQL 查询语句，从而知道 MySQL 是如何处理 SQL语句的，分析查询语句可知道查询语句的性能瓶颈。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 EXPLAIN 可以分析出以下结果：</p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
</li>
</ul>
<ul>
<li>执行计划中较重要字段含义 ( 详细可参考另一篇文章 <a href="https://m.jb51.net/article/38357.htm" target="_blank" rel="noopener">MySQL 查询优化之 Explain</a> )：<ul>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>key : 使用的索引类型</li>
<li>rows : 扫描的行数</li>
</ul>
</li>
</ul>
<h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><ul>
<li><p><code>减少请求的数据量</code>：</p>
<ul>
<li>只返回必要的列：最好不要使用 <code>SELECT *</code> 语句。</li>
<li>只返回必要的行：使用 <code>LIMIT</code> 语句来限制返回的数据。</li>
<li>缓存重复查询数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
</li>
<li><p><code>减少服务器端扫描的行数</code>：最有效的方式是使用索引来覆盖查询。</p>
</li>
</ul>
<h3 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h3><h4 id="切分大查询"><a href="#切分大查询" class="headerlink" title="切分大查询"></a>切分大查询</h4><ul>
<li><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小而重要的查询任务。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大查询 SQL：删除历史数据的任务</span></span><br><span class="line"><span class="comment"># Delete from messages Where created_time &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方案：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1）一次删除一万行一般来说是一个比较高效而且对服务器影响也最小的方案</span></span><br><span class="line"><span class="comment"># 2）执行一次删除任务建议暂停一会再执行任务，还可以大大减少删除时锁的持有时间。</span></span><br><span class="line">rows_affected = 0</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	rows_affected = do_query(</span><br><span class="line">		<span class="string">"Delete from Messages created_time &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000"</span></span><br><span class="line">	)</span><br><span class="line">&#125; <span class="keyword">while</span> rows_affected &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="分解大连接"><a href="#分解大连接" class="headerlink" title="分解大连接"></a>分解大连接</h4><ul>
<li><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>减少锁的竞争</li>
<li><p>缓存效率更高</p>
<blockquote>
<p>对于连接查询，若其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然不影响使用。</p>
</blockquote>
</li>
<li><p>减少冗余记录的查询：单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</p>
</li>
<li><p>高性能和可拓展查询：在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可拓展。</p>
<blockquote>
<p>例如，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机连接要更高效。</p>
</blockquote>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大连接查询示例</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag</span><br><span class="line">	<span class="keyword">INNER</span> <span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id = tag.id</span><br><span class="line">	<span class="keyword">INNER</span> <span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id = post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag = <span class="string">'mysql'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分解大连接</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag = <span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id = <span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>, <span class="number">456</span>, <span class="number">567</span>, <span class="number">9098</span>, <span class="number">8904</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="巧用临时表"><a href="#巧用临时表" class="headerlink" title="巧用临时表"></a>巧用临时表</h4><ul>
<li><p>临时表：顾名思义，临时表只是在当前连接可见，当关闭连接时，MySQL 会自动删除临时表并释放存储空间。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建临时表：表结构与数据存放于内存</span></span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Temporary</span> <span class="keyword">Table</span> tmp_user (</span><br><span class="line">	username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">	age <span class="built_in">int</span>(<span class="number">3</span>) <span class="literal">NULL</span></span><br><span class="line">	user_status <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1'</span></span><br><span class="line">) <span class="keyword">ENGINE</span> = MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp_user <span class="keyword">values</span>(<span class="string">'Kofe'</span>, <span class="number">26</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建内存表：表结构存放于磁盘上，数据存放于内存</span></span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Temporary</span> <span class="keyword">Table</span> tmp_user (</span><br><span class="line">	<span class="keyword">Select</span> * <span class="keyword">from</span> t_user</span><br><span class="line">) <span class="keyword">TYPE</span> ＝ <span class="keyword">HEAP</span> <span class="keyword">ENGINE</span>=<span class="keyword">MEMORY</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8；</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询直接创建临时表</span></span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Temporary</span> <span class="keyword">Table</span> tmp_user (</span><br><span class="line">	<span class="keyword">Select</span> * <span class="keyword">from</span> t_user</span><br><span class="line">)；</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除临时表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> tmp_user;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>使用场景：大查询或者关联查询频繁关联一些中间大结果集的子集，使用临时表可提高此类场景的查询效率。</li>
</ul>
<h2 id="高可用架构设计"><a href="#高可用架构设计" class="headerlink" title="高可用架构设计"></a>高可用架构设计</h2><h3 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h3><h4 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html" target="_blank" rel="noopener">美团技术团队. 大众点评订单系统分库分表实践 [OL]. tech.meituan.com</a></li>
<li><a href="https://crossoverjie.top/2019/07/24/framework-design/sharding-db-03/" target="_blank" rel="noopener">CrossoverJie. 一次难得的分库分表实践 [OL]. crossoverjie.top</a></li>
<li><a href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/database-shard.md" target="_blank" rel="noopener">Doocs. 面试题:为什么要分库分表 [OL]. github.com</a></li>
</ul>
<h4 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h4><ul>
<li><p>水平切分：将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，水平切分是必然选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p>
  <blockquote class="blockquote-center"><p><img src="/images/CS/MySQL-Architect/MySQL-Architecture-Sharding-Horizontal.svg" alt> 水平切分</p>
</blockquote>
</li>
<li><p>切分方式</p>
<ul>
<li>Range：根据一定范围进行分发。比如：根据时间范围，一个月内的数据存储为一张表，或者根据用户 ID 这种自增序列，用户 ID 在 000001 至 100000 范围的存一张表、100001 至200000 范围的存一张表等。<ul>
<li>优势是数据扩容时方便。</li>
<li>不足是容易产生数据热点问题。</li>
</ul>
</li>
<li><p>Hash：通过一次哈希运算然后取余（分表数量-1）的方式确定数据要存的表位置。</p>
<blockquote>
<p>比如：根据用户姓名进行 Hash 分发。用户姓名小明，计算 hashcode，得到754703，预先确定分表数量为 8，再取余 7 得到 3，即分发到索引为 3 表位置上。</p>
</blockquote>
<ul>
<li>优势是数据分发均匀，不会产生数据热点问题。</li>
<li>不足是扩容时候非常不方便，还需要重新计算数据的哈希值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h4><ul>
<li>垂直切分：将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分。<ul>
<li>利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中，让数据库可以以更少字段缓存更多的行，进而带来性能的提升。</li>
<li>数据库的三大范式设计其实也是一种垂直切分。</li>
</ul>
</li>
<li><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中。</p>
  <blockquote class="blockquote-center"><p><img src="/images/CS/MySQL-Architect/MySQL-Architecture-Sharding-Vertical.svg" alt> 垂直切分</p>
</blockquote>
</li>
</ul>
<h4 id="分表分库中间件"><a href="#分表分库中间件" class="headerlink" title="分表分库中间件"></a>分表分库中间件</h4><blockquote>
<p>不同的分库分表（包括水平以及垂直切分）中间件都有什么优点和缺点？</p>
</blockquote>
<ul>
<li>Mycat：基于 java 语言编写的数据库中间件，是一个实现了 MySQL 协议的服务器。<ul>
<li>基于 Cobar 改造的、同属于 proxy 层方案。</li>
<li>前端用户可以把它看作是一个数据库代理，用 MySQL 客户端工具和命令行访问。</li>
<li>后端使用 MySQL 原生协议与多个 MySQL 服务器通信，也可以用 JDBC 协议与大多数主流数据库服务器通信，其核心功能是分库分表。配合数据库的主从模式还可实现读写分离。</li>
</ul>
</li>
<li>Sharding-jdbc：属于 ShardingSphere 的 client 层方案。ShardingSphere 还提供 proxy 层的方案 Sharding-Proxy。因为 SQL 语法支持也比较多，没有太多限制，支持分库分表、读写分离、分布式 ID 生成、柔性事务（最大努力送达型事务、TCC 事务等）。</li>
</ul>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><ul>
<li><p>主从复制：主要涉及三个线程</p>
<ul>
<li><p>Binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</p>
<blockquote>
<p>二进制日志：记录了所有对 MySQL 数据库修改，不限于数据增删改查、表结构修改等事件。</p>
</blockquote>
</li>
<li><p>I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</p>
</li>
<li>SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li>
</ul>
</li>
<li><p>二进制日志格式：比如同一 SQL 修改 1000 条数据</p>
<ul>
<li>基于行 <code>binlog_format = ROW</code>，日志记录 1000 条执行语句。</li>
<li>基于段 <code>binlog_format = STATEMENT</code>，日志只记录该 SQL 语句。</li>
<li>混合日志格式 <code>binlog_format = MIXED</code>，由系统决定是基于端还是基于行方式记录日志。</li>
</ul>
</li>
</ul>
<h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><ul>
<li>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</li>
<li>读写分离能提高性能的原因在于：<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
<li>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</li>
</ul>
</li>
</ul>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Kofe
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://www.kofes.cn/2022/06/mysql-architect.html" title="扛得住的 MySQL 数据库性能优化">http://www.kofes.cn/2022/06/mysql-architect.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据库/" rel="tag"># 数据库</a>
          
            <a href="/tags/MySQL/" rel="tag"># MySQL</a>
          
            <a href="/tags/架构/" rel="tag"># 架构</a>
          
            <a href="/tags/索引/" rel="tag"># 索引</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/02/mega-web-site-architecture.html" rel="next" title="大型网站技术架构">
                <i class="fa fa-chevron-left"></i> 大型网站技术架构
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/07/Live-a-happy-life.html" rel="prev" title="别因名字错过一本好书：活出心花怒放的人生">
                别因名字错过一本好书：活出心花怒放的人生 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/profile/society_face_version_1.jpg" alt="Kofe">
            
              <p class="site-author-name" itemprop="name">Kofe</p>
              <p class="site-description motion-element" itemprop="description">人往往需要说很多话，然后才能归入潜默。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">137</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ldxw8" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://dribbble.com/Kofe" target="_blank" title="Dribbble">
                      
                        <i class="fa fa-fw fa-dribbble"></i>Dribbble</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://weibo.com/ldxw8" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.acxer.cn" title="zcxer" target="_blank">zcxer</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库性能分析"><span class="nav-number">1.</span> <span class="nav-text">数据库性能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库结构设计"><span class="nav-number">1.1.</span> <span class="nav-text">数据库结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库存储引擎"><span class="nav-number">1.2.</span> <span class="nav-text">数据库存储引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器硬件"><span class="nav-number">1.3.</span> <span class="nav-text">服务器硬件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU-方案"><span class="nav-number">1.3.1.</span> <span class="nav-text">CPU 方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存方案"><span class="nav-number">1.3.2.</span> <span class="nav-text">内存方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘方案"><span class="nav-number">1.3.3.</span> <span class="nav-text">磁盘方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库结构设计-1"><span class="nav-number">2.</span> <span class="nav-text">数据库结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设计的目的"><span class="nav-number">2.1.</span> <span class="nav-text">设计的目的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计的步骤"><span class="nav-number">2.2.</span> <span class="nav-text">设计的步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#范式设计"><span class="nav-number">2.3.</span> <span class="nav-text">范式设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#范式化设计"><span class="nav-number">2.3.1.</span> <span class="nav-text">范式化设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反范式设计"><span class="nav-number">2.3.2.</span> <span class="nav-text">反范式设计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#物理设计"><span class="nav-number">2.4.</span> <span class="nav-text">物理设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#存储引擎"><span class="nav-number">2.4.1.</span> <span class="nav-text">存储引擎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据类型"><span class="nav-number">2.4.2.</span> <span class="nav-text">数据类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库索引优化"><span class="nav-number">3.</span> <span class="nav-text">数据库索引优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的数理基础"><span class="nav-number">3.1.</span> <span class="nav-text">索引的数理基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B-Tree-amp-B-Tree"><span class="nav-number">3.1.1.</span> <span class="nav-text">B-Tree &amp; B+Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#引入背景"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">引入背景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#参考资料"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">参考资料</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-Tree"><span class="nav-number">3.1.1.3.</span> <span class="nav-text">B-Tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-Tree-1"><span class="nav-number">3.1.1.4.</span> <span class="nav-text">B+Tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#两者比较"><span class="nav-number">3.1.1.5.</span> <span class="nav-text">两者比较</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引的数据结构"><span class="nav-number">3.1.2.</span> <span class="nav-text">索引的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#红黑树方案考量"><span class="nav-number">3.1.3.</span> <span class="nav-text">红黑树方案考量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引的存取原理"><span class="nav-number">3.1.4.</span> <span class="nav-text">索引的存取原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-索引"><span class="nav-number">3.2.</span> <span class="nav-text">MySQL 索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#索引结构类型"><span class="nav-number">3.2.1.</span> <span class="nav-text">索引结构类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B-Tree-索引"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">B+Tree 索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hash-索引"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">Hash 索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#全文索引"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">全文索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#空间数据索引"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">空间数据索引</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyISAM-索引实现"><span class="nav-number">3.2.2.</span> <span class="nav-text">MyISAM 索引实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB-索引实现"><span class="nav-number">3.2.3.</span> <span class="nav-text">InnoDB 索引实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的优点缺点"><span class="nav-number">3.3.</span> <span class="nav-text">索引的优点缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优点"><span class="nav-number">3.3.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点"><span class="nav-number">3.3.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的设计原则"><span class="nav-number">3.4.</span> <span class="nav-text">索引的设计原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的优化策略"><span class="nav-number">3.5.</span> <span class="nav-text">索引的优化策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的使用场景"><span class="nav-number">3.6.</span> <span class="nav-text">索引的使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建与删除索引"><span class="nav-number">3.7.</span> <span class="nav-text">创建与删除索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL-大查询优化"><span class="nav-number">4.</span> <span class="nav-text">SQL 大查询优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-EXPLAIN-分析性能"><span class="nav-number">4.1.</span> <span class="nav-text">使用 EXPLAIN 分析性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化数据访问"><span class="nav-number">4.2.</span> <span class="nav-text">优化数据访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重构查询方式"><span class="nav-number">4.3.</span> <span class="nav-text">重构查询方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#切分大查询"><span class="nav-number">4.3.1.</span> <span class="nav-text">切分大查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分解大连接"><span class="nav-number">4.3.2.</span> <span class="nav-text">分解大连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#巧用临时表"><span class="nav-number">4.3.3.</span> <span class="nav-text">巧用临时表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高可用架构设计"><span class="nav-number">5.</span> <span class="nav-text">高可用架构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#切分"><span class="nav-number">5.1.</span> <span class="nav-text">切分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料-1"><span class="nav-number">5.1.1.</span> <span class="nav-text">参考资料</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#水平切分"><span class="nav-number">5.1.2.</span> <span class="nav-text">水平切分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#垂直切分"><span class="nav-number">5.1.3.</span> <span class="nav-text">垂直切分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分表分库中间件"><span class="nav-number">5.1.4.</span> <span class="nav-text">分表分库中间件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制"><span class="nav-number">5.2.</span> <span class="nav-text">复制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主从复制"><span class="nav-number">5.2.1.</span> <span class="nav-text">主从复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读写分离"><span class="nav-number">5.2.2.</span> <span class="nav-text">读写分离</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kofe</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>








        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: true,
        notify: true,
        appId: 'STGXfYUEVVq1AoccxhumXjsB-gzGzoHsz',
        appKey: 'jbgIHEzUigo8apYgTon6xXE8',
        placeholder: '非常期待您的想法或意见，推荐留言~',
        avatar:'hide',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("STGXfYUEVVq1AoccxhumXjsB-gzGzoHsz", "jbgIHEzUigo8apYgTon6xXE8");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
